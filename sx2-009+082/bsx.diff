diff -urN ./out/Ongaku Tsukuru - Kanadeeru (J).xml ../../bsnes-sx2_v009/out/Ongaku Tsukuru - Kanadeeru (J).xml
--- ./out/Ongaku Tsukuru - Kanadeeru (J).xml	1970-01-01 09:00:00.000000000 +0900
+++ ../../bsnes-sx2_v009/out/Ongaku Tsukuru - Kanadeeru (J).xml	2011-12-03 13:57:24.000000000 +0900
@@ -0,0 +1,20 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<cartridge region="NTSC">
+  <rom>
+	<map mode="shadow" address="00-3f:8000-ffff"/>
+    <map mode="linear" address="40-7d:0000-ffff"/>
+	<map mode="shadow" address="80-bf:8000-ffff"/>
+	<map mode="linear" address="c0-fd:0000-ffff"/>
+  </rom>
+
+  <ram size="10000">
+    <map mode="linear" address="20-3f:6000-7fff"/>
+	<map mode="linear" address="a0-bf:6000-7fff"/>
+  </ram>
+
+  <bsx>
+    <slot>
+		<map mode="linear" address="e0-ff:0000-ffff"/>
+	</slot>
+  </bsx>
+</cartridge>
\ No newline at end of file
diff -urN ./out/readme.txt ../../bsnes-sx2_v009/out/readme.txt
--- ./out/readme.txt	1970-01-01 09:00:00.000000000 +0900
+++ ../../bsnes-sx2_v009/out/readme.txt	2012-08-05 22:09:41.000000000 +0900
@@ -0,0 +1,102 @@
+bsnes-sx2 v009 (bsnes-bsx) (32/64-bit Compatibility+Debugger)
+(based on bsnes v082)
+by LuigiBlood/Seru-kun
+
+------
+Facts
+------
+- Super Famicom Box isn't well emulated, mostly because of the non support of Z80, which won't be done in bsnes-sx2.
+- XBAND is partially emulated, but I've yet to update how the registers work and give the data it expects.
+But it's not a priority there so it ain't gonna happen for now.
+- From now on (v007), the Time can be "downloaded" from Satellaview Stream 1 & 2.
+To have the Time data, ask the Hardware Channel 0x0000 and get 22 bytes (1 packet).
+Note that BSX0000-0.bin won't be read because of this change.
+- Cartridge Tilt and Swap are only there for fun.
+- From now on (v008), BSX files have a new format that only contains the Download Data.
+The emulator itself will do the rest.
+
+------
+Changelog
+------
+v009:
+- Debugger removed for faster emulation
+- Proper BS-X Memory Mapping added. (Note: This version isn't tested.)
+
+v008:
+- New format of BSX data files supported.
+- Added Year data to Time Channel.
+- Fixed Day data to Time Channel.
+- Fixed Crash when erasing full Flash data.
+
+v007:
+- Super Famicom Box emulation (which doesn't work) added.
+- Fixed Page Erase Memory Pack command.
+- Added Satellaview Second Stream support. ($218E-$2193)
+- Added Hardcoded Time Stream Channel (0x0000)
+- Time Stream Channel now have Month and Day data.
+
+v006:
+- XBAND is now supported. (Without Online features)
+- Added Cartridge Tilt and Swap features.
+- New name. "sx2" stands for "Seru's bs-X and Xband".
+
+v005:
+- Fixed some Memory Pack Erase commands.
+- Added Memory Pack saving support.
+(It will make a MEMPACK.bs file, and will replace the contents EVERY TIME you save, be careful.)
+- Removed Memory Pack Logging feature that slows down emulation.
+
+v004:
+- Added more Memory Pack commands support
+- Fixed XML BS-X Slot support! (Try RPG Maker 2 and others now!)
+
+v003:
+- Signal Type Filter support (Registers $2188-$2189)
+- BSX files have different filenames.
+
+v002:
+- Better Customizable files that the BS-X BIOS downloads.
+- Better detection of file change.
+- Added a folder for the BSX?.bin files.
+
+v001:
+- Initial release
+
+------
+Thanks to
+------
+Byuu - For making bsnes.
+nocash - For his well made documentation (of BS-X, XBAND...)
+ikari_01 - For his Memory Pack documentation (and adding BS-X support for sd2snes)
+d4s - For his Satellaview Register Testing Doc, mostly.
+p4plus2 - For his BS-X BIOS disassembly.
+Kiddo - If he wasn't here, i wouldn't do all this, and thanks for making the SatellaBlog.
+Matthew Callis - For hosting the BS-X Project website, and for doing superfamicom.org.
+
+(Probably forgot some... I only made this part in the Readme in class ^^')
+
+------
+NEW BSX????-?.bin FILE FORMAT
+------
+Only contains the $218B/$2191 Data.
+Max File Size is 2794 bytes.
+
+
+------
+OLD BSX????-???.bin FILE FORMAT
+------
+Kept it for archiving purposes.
+
+BSX<Channel>-<Number>.bin
+<Channel>: Must be 4 HEXADECIMAL DIGITS.
+<Number>: From 0 to 255 decimal numbers.
+
+Offset - Size (Bytes) - Description
+0x00 - 50 - UNUSED (You can put anything in there.)
+0x32 - 1 - $218A/$2190 Data (Packet Queue)
+0x33 - 1 - $218D/$2193 Data (Status Data) [UNUSED SINCE V007]
+0x34 - 20 - $218B/$2191 Data (Queue Status Data)
+0x48 - 440 - $218C/$2192 Data (MAIN DOWNLOAD)
+
+Note: It "downloads" all of them in a infinite loop. You can add them if you want.
+The limit is BSX????-255.bin.
\ No newline at end of file
diff -urN ./out/RPG Tsukuru 2 (J) [!].xml ../../bsnes-sx2_v009/out/RPG Tsukuru 2 (J) [!].xml
--- ./out/RPG Tsukuru 2 (J) [!].xml	1970-01-01 09:00:00.000000000 +0900
+++ ../../bsnes-sx2_v009/out/RPG Tsukuru 2 (J) [!].xml	2010-10-19 17:36:39.000000000 +0900
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<cartridge region="NTSC">
+  <rom>
+    <map mode="linear" address="00-6f:8000-ffff"/>
+    <map mode="linear" address="80-ff:8000-ffff"/>
+  </rom>
+
+  <ram size="10000">
+    <map mode="linear" address="70-7d:0000-7fff"/>
+  </ram>
+
+  <bsx>
+    <slot>
+		<map mode="linear" address="c0-ff:8000-ffff"/>
+	</slot>
+  </bsx>
+</cartridge>
\ No newline at end of file
diff -urN ./out/Sound Novel Tsukuru (J).xml ../../bsnes-sx2_v009/out/Sound Novel Tsukuru (J).xml
--- ./out/Sound Novel Tsukuru (J).xml	1970-01-01 09:00:00.000000000 +0900
+++ ../../bsnes-sx2_v009/out/Sound Novel Tsukuru (J).xml	2010-10-19 15:46:41.000000000 +0900
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<cartridge region="NTSC">
+  <rom>
+    <map mode="linear" address="00-7d:8000-ffff"/>
+    <map mode="linear" offset="200000" address="80-bd:8000-ffff"/>
+  </rom>
+
+  <ram size="10000">
+    <map mode="linear" address="70-7d:0000-7fff"/>
+  </ram>
+
+  <bsx>
+    <slot>
+		<map mode="linear" address="c0-ff:8000-ffff"/>
+	</slot>
+  </bsx>
+</cartridge>
\ No newline at end of file
diff -urN ./snes/cartridge/xml.cpp ../../bsnes-sx2_v009/snes/cartridge/xml.cpp
--- ./snes/cartridge/xml.cpp	2011-07-03 23:07:58.000000000 +0900
+++ ../../bsnes-sx2_v009/snes/cartridge/xml.cpp	2012-01-11 09:25:54.000000000 +0900
@@ -439,7 +445,7 @@
     if(node.name == "slot") {
       foreach(leaf, node.element) {
         if(leaf.name == "map") {
-          Mapping m(bsxflash.memory);
+          Mapping m(bsxflash);
           foreach(attr, leaf.attribute) {
             if(attr.name == "address") xml_parse_address(m, attr.content);
             if(attr.name == "mode") xml_parse_mode(m, attr.content);
diff -urN ./snes/chip/bsx/cartridge/cartridge.cpp ../../bsnes-sx2_v009/snes/chip/bsx/cartridge/cartridge.cpp
--- ./snes/chip/bsx/cartridge/cartridge.cpp	2011-03-14 04:41:44.000000000 +0900
+++ ../../bsnes-sx2_v009/snes/chip/bsx/cartridge/cartridge.cpp	2012-08-05 22:06:52.000000000 +0900
@@ -24,8 +24,14 @@
 
 void BSXCartridge::reset() {
   for(unsigned i = 0; i < 16; i++) r[i] = 0x00;
+  r[0x02] = 0x80;
+  r[0x03] = 0x80;
+  r[0x05] = 0x80;
+  r[0x06] = 0x80;
   r[0x07] = 0x80;
   r[0x08] = 0x80;
+  r[0x09] = 0x80;
+  r[0x0b] = 0x80;
   mmio_commit();
 }
@@ -46,6 +52,7 @@
 
 //mcu_access() allows mcu_read() and mcu_write() to share decoding logic
 uint8 BSXCartridge::mcu_access(bool write, unsigned addr, uint8 data) {
+  //BIOS ROM Access
   if(within<0x00, 0x1f, 0x8000, 0xffff>(addr)) {
     if(r07 == 1) {
       addr = ((addr & 0x1f0000) >> 1) | (addr & 0x7fff);
@@ -60,34 +67,155 @@
     }
   }
 
-  if(within<0x20, 0x3f, 0x6000, 0x7fff>(addr)) {
-    return memory_access(write, psram, addr, data);
+  //PSRAM Access
+  //LoROM
+  if(r02==0) {
+  
+	if(within<0x70, 0x7d, 0x0000, 0x7fff>(addr)) {
+		if(r03==1) return memory_access(write, psram, addr & 0x07ffff, data);
+	}
+	
+	if(within<0xf0, 0xff, 0x0000, 0x7fff>(addr)) {
+		if(r04==1) return memory_access(write, psram, addr & 0x07ffff, data);
+	}
+	
+	
+	if(within<0x00, 0x0f, 0x8000, 0xffff>(addr)) {
+		if(r03==1 && r05==0 && r06==0) return memory_access(write, psram, ((addr & 0x7f0000) >> 1) | (addr & 0x7fff), data);
+	}
+	
+	if(within<0x80, 0x8f, 0x8000, 0xffff>(addr)) {
+		if(r04==1 && r05==0 && r06==0) return memory_access(write, psram, ((addr & 0x7f0000) >> 1) | (addr & 0x7fff), data);
+	}
+	
+	if(within<0x20, 0x2f, 0x8000, 0xffff>(addr)) {
+		if(r03==1 && r05==1 && r06==0) return memory_access(write, psram, ((addr & 0x7f0000) >> 1) | (addr & 0x7fff), data);
+	}
+	
+	if(within<0xa0, 0xaf, 0x8000, 0xffff>(addr)) {
+		if(r04==1 && r05==1 && r06==0) return memory_access(write, psram, ((addr & 0x7f0000) >> 1) | (addr & 0x7fff), data);
+	}
+	
+	if(within<0x40, 0x4f, 0x0000, 0xffff>(addr)) {
+		if(r03==1 && r05==0 && r06==1) return memory_access(write, psram, ((addr & 0x7f0000) >> 1) | (addr & 0x7fff), data);
+	}
+	
+	if(within<0xc0, 0xcf, 0x0000, 0xffff>(addr)) {
+		if(r04==1 && r05==0 && r06==1) return memory_access(write, psram, ((addr & 0x7f0000) >> 1) | (addr & 0x7fff), data);
+	}
+	
+	if(within<0x60, 0x6f, 0x0000, 0xffff>(addr)) {
+		if(r03==1 && r05==1 && r06==1) return memory_access(write, psram, ((addr & 0x7f0000) >> 1) | (addr & 0x7fff), data);
+	}
+	
+	if(within<0xe0, 0xef, 0x0000, 0xffff>(addr)) {
+		if(r04==1 && r05==1 && r06==1) return memory_access(write, psram, ((addr & 0x7f0000) >> 1) | (addr & 0x7fff), data);
+	}
+  
+  } else {
+  //HiROM
+	if(within<0x20, 0x3f, 0x6000, 0x7fff>(addr)) {
+		if(r03==1) return memory_access(write, psram, (addr&0x1fff)|0x6000, data);
+	}
+	
+	if(within<0xa0, 0xbf, 0x6000, 0x7fff>(addr)) {
+		if(r04==1) return memory_access(write, psram, (addr&0x1fff)|0x6000, data);
+	}
+	
+
+	if(within<0x40, 0x47, 0x0000, 0xffff>(addr)) {
+		if(r03==1 && r05==0 && r06==0) return memory_access(write, psram, addr & 0x0fffff, data);
+	}
+
+	if(within<0x50, 0x57, 0x0000, 0xffff>(addr)) {
+		if(r03==1 && r05==1 && r06==0) return memory_access(write, psram, addr & 0x0fffff, data);
+	}
+
+	if(within<0x60, 0x67, 0x0000, 0xffff>(addr)) {
+		if(r03==1 && r05==0 && r06==1) return memory_access(write, psram, addr & 0x0fffff, data);
+	}
+	
+	if(within<0x70, 0x77, 0x0000, 0xffff>(addr)) {
+		if(r03==1 && r05==1 && r06==1) return memory_access(write, psram, addr & 0x0fffff, data);
+	}
+	
+	
+	if(within<0xc0, 0xc7, 0x0000, 0xffff>(addr)) {
+		if(r04==1 && r05==0 && r06==0) return memory_access(write, psram, addr & 0x0fffff, data);
+	}
+
+	if(within<0xd0, 0xd7, 0x0000, 0xffff>(addr)) {
+		if(r04==1 && r05==1 && r06==0) return memory_access(write, psram, addr & 0x0fffff, data);
+	}
+
+	if(within<0xe0, 0xe7, 0x0000, 0xffff>(addr)) {
+		if(r04==1 && r05==0 && r06==1) return memory_access(write, psram, addr & 0x0fffff, data);
+	}
+	
+	if(within<0xf0, 0xf7, 0x0000, 0xffff>(addr)) {
+		if(r04==1 && r05==1 && r06==1) return memory_access(write, psram, addr & 0x0fffff, data);
+	}
+
+  }
+  
+  //Memory Pack Hole
+  if(r02==0) {
+	if(within<0x00, 0x1f, 0x8000, 0xffff>(addr)) {
+		if(r09==1 && r0b==0) return cpu.regs.mdr;
+	}
+	
+	if(within<0x40, 0x5f, 0x0000, 0xffff>(addr)) {
+		if(r09==1 && r0b==1) return cpu.regs.mdr;
+	}
+	
+	if(within<0x80, 0x9f, 0x8000, 0xffff>(addr)) {
+		if(r0a==1 && r0b==0) return cpu.regs.mdr;
+	}
+	
+	if(within<0xc0, 0xdf, 0x0000, 0xffff>(addr)) {
+		if(r0a==1 && r0b==1) return cpu.regs.mdr;
+	}
+
+  } else {
+	if(within<0x00, 0x0f, 0x8000, 0xffff>(addr)
+	|| within<0x40, 0x4f, 0x0000, 0xffff>(addr)
+	) {
+		if(r09==1 && r0b==0) return cpu.regs.mdr;
+	}
+	
+	if(within<0x20, 0x2f, 0x8000, 0xffff>(addr)
+	|| within<0x60, 0x6f, 0x0000, 0xffff>(addr)
+	) {
+		if(r09==1 && r0b==1) return cpu.regs.mdr;
+	}
+	
+	if(within<0x80, 0x8f, 0x8000, 0xffff>(addr)
+	|| within<0xc0, 0xcf, 0x0000, 0xffff>(addr)
+	) {
+		if(r0a==1 && r0b==0) return cpu.regs.mdr;
+	}
+	
+	if(within<0xa0, 0xaf, 0x8000, 0xffff>(addr)
+	|| within<0xe0, 0xef, 0x0000, 0xffff>(addr)
+	) {
+		if(r0a==1 && r0b==1) return cpu.regs.mdr;
+	}
+	  
   }
-
-  if(within<0x40, 0x4f, 0x0000, 0xffff>(addr)) {
-    if(r05 == 0) return memory_access(write, psram, addr & 0x0fffff, data);
-  }
-
-  if(within<0x50, 0x5f, 0x0000, 0xffff>(addr)) {
-    if(r06 == 0) return memory_access(write, psram, addr & 0x0fffff, data);
-  }
-
-  if(within<0x60, 0x6f, 0x0000, 0xffff>(addr)) {
-    if(r03 == 1) return memory_access(write, psram, addr & 0x0fffff, data);
-  }
-
-  if(within<0x70, 0x77, 0x0000, 0xffff>(addr)) {
-    return memory_access(write, psram, addr & 0x07ffff, data);
-  }
-
+  
+  //Memory Pack Access  
   if(within<0x00, 0x3f, 0x8000, 0xffff>(addr)
-  || within<0x40, 0x7f, 0x0000, 0xffff>(addr)
   || within<0x80, 0xbf, 0x8000, 0xffff>(addr)
-  || within<0xc0, 0xff, 0x0000, 0xffff>(addr)
   ) {
     if(r02 == 0) addr = ((addr & 0x7f0000) >> 1) | (addr & 0x7fff);
-    Memory &memory = (r01 == 0 ? (Memory&)bsxflash : (Memory&)psram);
-    return memory_access(write, memory, addr & 0x7fffff, data);
+	return memory_access(write && r0c, bsxflash, addr & 0x7fffff, data);
+  }
+  
+  if(within<0x40, 0x7d, 0x0000, 0xffff>(addr)
+  || within<0xc0, 0xff, 0x0000, 0xffff>(addr)
+  ) {
+	if(r02 == 0) addr = ((addr & 0x7f0000) >> 1) | (addr & 0x7fff);
+	return memory_access(write && r0c, bsxflash, addr & 0x7fffff, data);
   }
 
   return cpu.regs.mdr;
diff -urN ./snes/chip/bsx/flash/flash.cpp ../../bsnes-sx2_v009/snes/chip/bsx/flash/flash.cpp
--- ./snes/chip/bsx/flash/flash.cpp	2011-01-25 21:57:00.000000000 +0900
+++ ../../bsnes-sx2_v009/snes/chip/bsx/flash/flash.cpp	2012-04-07 19:44:02.000000000 +0900
@@ -2,6 +2,23 @@
 
 BSXFlash bsxflash;
 
+void BSXFlash::save() {
+	if(memory.size() >= 1) {
+		file MEMPAK;
+		//uint8 filenumber;
+		char filenm [25];
+		bool writeisdone = false;
+		sprintf(filenm, ".\\MEMPACK.bs");
+		if (MEMPAK.open(filenm, file::mode::write)) {
+			int x;
+			for (x=0; x <= memory.size()-1; x++) {
+				MEMPAK.write(memory.read(x));
+			}
+			MEMPAK.close();
+		}
+	}
+}
+
 void BSXFlash::init() {
 }
 
@@ -27,6 +44,7 @@
   regs.flash_enable = false;
   regs.read_enable  = false;
   regs.write_enable = false;
+  regs.command_done = false;
   memory.write_protect(!regs.write_enable);
 }
 
@@ -35,29 +53,44 @@
 }
 
 uint8 BSXFlash::read(unsigned addr) {
-  if(addr == 0x0002) {
-    if(regs.flash_enable) return 0x80;
+  unsigned addr2 = addr&0xffff;
+  
+  if(addr2 == 0x5555 && regs.flash_enable) { return 0x80; }
+  
+  if(regs.flash_stat_bsr && addr2 == 0x0002)
+  {
+	//printf("Read BSR\n");
+	return 0xc0;
   }
-
-  if(addr == 0x5555) {
-    if(regs.flash_enable) return 0x80;
+  if(regs.flash_stat_gsr && addr2 == 0x0004)
+  {
+	//printf("Read GSR\n");
+	return 0x82;
+  }
+  
+  if(regs.flash_stat_csr)
+  {
+	//printf("Read CSR (%x)\n", addr);
+	regs.flash_stat_csr = false;
+	return 0x80;
   }
 
-  if(regs.read_enable && addr >= 0xff00 && addr <= 0xff13) {
+  if(regs.read_enable && addr2 >= 0xff00 && addr2 <= 0xff13) {
     //read flash cartridge vendor information
+	//printf("Read Vendor Info (%x)\n", addr);
     switch(addr - 0xff00) {
       case 0x00: return 0x4d;
-      case 0x01: return 0x00;
+      case 0x01: return 0x50;
       case 0x02: return 0x50;
       case 0x03: return 0x00;
       case 0x04: return 0x00;
       case 0x05: return 0x00;
-      case 0x06: return 0x2a;  //0x2a = 8mbit, 0x2b = 16mbit (not known to exist, though BIOS recognizes ID)
+      case 0x06: return 0x1a;  //0x2a = 8mbit, 0x2b = 16mbit (not known to exist, though BIOS recognizes ID)
       case 0x07: return 0x00;
       default:   return 0x00;
     }
   }
-
+  //printf("Read Flash Memory: %x : %x\n", addr, memory.read(addr));
   return memory.read(addr);
 }
 
@@ -71,28 +104,133 @@
   //read-only flashcarts.
   //below is an unfortunately necessary workaround to this problem.
   //if(cartridge.mapper() == Cartridge::BSCHiROM) return;
-
   if((addr & 0xff0000) == 0) {
     regs.write_old = regs.write_new;
     regs.write_new = data;
 
     if(regs.write_enable && regs.write_old == regs.write_new) {
+	  regs.write_enable = false;
       return memory.write(addr, data);
     }
   } else {
     if(regs.write_enable) {
+	  regs.write_enable = false;
       return memory.write(addr, data);
     }
   }
+  
+  if(regs.write_enable) {
+	  //printf("Write Flash Memory: %x : %x\n", addr, data);
+	  regs.write_enable = false;
+      return memory.write(addr, data);
+  }
 
-  if(addr == 0x0000) {
+  //if(addr == 0x0000 || addr == 0x8000) {
+  if(true) {
     regs.command <<= 8;
     regs.command  |= data;
 
-    if((regs.command & 0xffff) == 0x38d0) {
-      regs.flash_enable = true;
-      regs.read_enable  = true;
+    switch(regs.command & 0xff)
+	{
+		case 0x00:
+			regs.flash_enable = false;
+			regs.read_enable  = false;
+			regs.write_enable = false;
+			regs.flash_stat_csr = false;
+			regs.flash_stat_gsr = false;
+			regs.flash_stat_bsr = false;
+			regs.command_done = true;
+			break;
+		case 0x38:
+			regs.flash_enable = true;
+			regs.read_enable  = true;
+			regs.flash_stat_csr = false;
+			regs.flash_stat_gsr = false;
+			regs.flash_stat_bsr = false;
+			//regs.command_done = true;
+			break;
+		case 0x10:
+			regs.write_enable = true;
+			regs.flash_stat_csr = true;
+			regs.flash_stat_gsr = false;
+			regs.flash_stat_bsr = false;
+			regs.command_done = true;
+			break;
+		case 0x40:
+			regs.write_enable = true;
+			regs.flash_stat_csr = true;
+			regs.flash_stat_gsr = false;
+			regs.flash_stat_bsr = false;
+			regs.command_done = true;
+			break;
+		case 0x50:
+			regs.flash_stat_csr = false;
+			regs.flash_stat_gsr = false;
+			regs.flash_stat_bsr = false;
+			regs.command_done = true;
+		case 0x70:
+			regs.flash_stat_csr = true;
+			regs.write_enable = false;
+			regs.flash_stat_gsr = false;
+			regs.flash_stat_bsr = false;
+			regs.command_done = true;
+			break;
+		case 0x71:
+			regs.flash_stat_gsr = true;
+			regs.flash_stat_bsr = true;
+			regs.flash_stat_csr = false;
+			regs.flash_enable = true;
+			regs.command_done = true;
+		case 0x72:
+			regs.command_done = true;
+			break;
+		case 0x75:
+			regs.read_enable  = true;
+			regs.flash_stat_csr = false;
+			regs.command_done = true;
+			break;
+		case 0xd0:
+			regs.command_done = true;
+			break;
+		case 0xff:
+			regs.flash_enable = false;
+			regs.read_enable  = false;
+			regs.write_enable = false;
+			regs.flash_stat_csr = false;
+			regs.flash_stat_gsr = false;
+			regs.flash_stat_bsr = false;
+			regs.command_done = true;
+			break;
     }
+	if(regs.command_done)
+	{
+		//printf("Flash Command: %x\n", regs.command);
+		memory.write_protect(!regs.write_enable);
+		//Page Erase
+		if (regs.command == 0x20d0) {
+			memory.write_protect(false);
+			int erase_addr = addr & 0xff0000;
+			//printf("Page Erase (Page %x)\n", erase_addr);
+			uint32 x;
+			for (x=0; x < 0xffff; x++) {
+				memory.write(erase_addr+x, 0xff);
+			}
+			memory.write_protect(true);
+		}
+	
+		//Chip Erase
+		if (regs.command == 0xa7d0) {
+			memory.write_protect(false);
+			unsigned x;
+			//printf("Chip Erase\n");
+			for (x=0; x < bsxflash.size(); x++) {
+				memory.write(x, 0xff);
+			}
+			memory.write_protect(true);
+		}
+		regs.command = 0;
+		regs.command_done = false;
+	}
   }
 
   if(addr == 0x2aaa) {
@@ -106,6 +244,7 @@
 
     if((regs.command & 0xffffff) == 0xaa5570) {
       regs.write_enable = false;
+	  regs.flash_enable = true;
     }
 
     if((regs.command & 0xffffff) == 0xaa55a0) {
@@ -118,7 +257,10 @@
     if((regs.command & 0xffffff) == 0xaa55f0) {
       regs.flash_enable = false;
       regs.read_enable  = false;
-      regs.write_enable = false;
+      regs.write_enable = true;
+	  regs.flash_stat_csr = false;
+	  regs.flash_stat_gsr = false;
+	  regs.flash_stat_bsr = false;
     }
 
     memory.write_protect(!regs.write_enable);
diff -urN ./snes/chip/bsx/flash/flash.hpp ../../bsnes-sx2_v009/snes/chip/bsx/flash/flash.hpp
--- ./snes/chip/bsx/flash/flash.hpp	2011-01-25 21:56:47.000000000 +0900
+++ ../../bsnes-sx2_v009/snes/chip/bsx/flash/flash.hpp	2011-12-03 21:55:02.000000000 +0900
@@ -1,7 +1,10 @@
+#include <nall/file.hpp>
+
 class BSXFlash : public Memory {
 public:
   MappedRAM memory;
 
+  void save();
   void init();
   void load();
   void unload();
@@ -15,12 +18,19 @@
 private:
   struct {
     unsigned command;
+	unsigned command2;
     uint8 write_old;
     uint8 write_new;
 
     bool flash_enable;
     bool read_enable;
     bool write_enable;
+	
+	bool command_done; //Giving Flash Command is done.
+	
+	bool flash_stat_csr;
+	bool flash_stat_gsr;
+	bool flash_stat_bsr;
   } regs;
 };
 
diff -urN ./snes/chip/bsx/satellaview/satellaview.cpp ../../bsnes-sx2_v009/snes/chip/bsx/satellaview/satellaview.cpp
--- ./snes/chip/bsx/satellaview/satellaview.cpp	2011-01-25 21:58:52.000000000 +0900
+++ ../../bsnes-sx2_v009/snes/chip/bsx/satellaview/satellaview.cpp	2012-04-07 18:56:33.000000000 +0900
@@ -7,7 +7,7 @@
 
 void BSXSatellaview::load() {
   bus.map(Bus::MapMode::Direct, 0x00, 0x3f, 0x2188, 0x219f, { &BSXSatellaview::mmio_read, &bsxsatellaview }, { &BSXSatellaview::mmio_write, &bsxsatellaview });
-  bus.map(Bus::MapMode::Direct, 0x80, 0xbf, 0x2188, 0x219f, { &BSXSatellaview::mmio_read, &bsxsatellaview }, { &BSXSatellaview::mmio_write, &bsxsatellaview });
+  bus.map(Bus::MapMode::Direct, 0x80, 0xbf, 0x2188, 0x219f, { &BSXSatellaview::mmio_read, &bsxsatellaview }, { &BSXSatellaview::mmio_write, &bsxsatellaview });  
 }
 
 void BSXSatellaview::unload() {
@@ -18,64 +18,241 @@
 }
 
 void BSXSatellaview::reset() {
+  BSXF.close();
+  regs.BSXF_NUM = 0;
   memset(&regs, 0x00, sizeof regs);
 }
 
+void BSXSatellaview::BSXfileopen(uint8 filenumber) {
+	BSXF.close();
+	uint16 Signal_Nb=regs.r2188^(regs.r2189*256);
+	char filenm [25];
+	sprintf(filenm, ".\\bsxdat\\BSX%04.4hX-%d.bin", Signal_Nb, filenumber);
+	BSXF.open(filenm, file::mode::read);
+	if(BSXF.size()!= -1) {
+	  //printf("%02.2hX, %02.2hX, %04.4hX: %s\n",regs.r2189, regs.r2188, Signal_Nb, filenm);
+	  regs.BSX_access=true;
+	  regs.BSXF_Signal++;
+	  float QueueSize = BSXF.size() / 22.;
+	  regs.BSXF_Queue = (uint8)(ceil(QueueSize));
+	  regs.BSXF_1ST = true;
+	  }
+	else {
+	  regs.BSX_access=false;
+	  regs.BSXF_Signal=0;
+	  }
+}
+
+void BSXSatellaview::BSX2fileopen(uint8 filenumber) {
+	BSXF2.close();
+	uint16 Signal_Nb=regs.r218e^(regs.r218f*256);
+	char filenm [25];
+	sprintf(filenm, ".\\bsxdat\\BSX%04.4hX-%d.bin", Signal_Nb, filenumber);
+	BSXF2.open(filenm, file::mode::read);
+	if(BSXF2.size()!= -1) {
+	  //printf("%02.2hX, %02.2hX, %04.4hX: %s\n",regs.r218f, regs.r218e, Signal_Nb, filenm);
+	  regs.BSX2_access=true;
+	  regs.BSXF2_Signal++;
+	  float QueueSize = BSXF2.size() / 22.;
+	  regs.BSXF2_Queue = (uint8)(ceil(QueueSize));
+	  regs.BSXF2_1ST = true;
+	  }
+	else {
+	  regs.BSX2_access=false;
+	  regs.BSXF2_Signal=0;
+	  }
+}
+
+uint8 BSXSatellaview::GetTime(bool reset_count) {
+		if(reset_count == true) {
+			regs.time_counter = 0;
+			return 0xff;
+		}
+		unsigned counter = regs.time_counter;
+		regs.time_counter++;
+		if(regs.time_counter >= 22) regs.time_counter = 0;
+		if(counter == 0) {
+			time_t rawtime;
+			time(&rawtime);
+			tm *t = localtime(&rawtime);
+
+			regs.time_hour   = t->tm_hour;
+			regs.time_minute = t->tm_min;
+			regs.time_second = t->tm_sec;
+			regs.time_weekday = (t->tm_wday)++;
+			regs.time_day = (t->tm_mday)++;
+			regs.time_month = t->tm_mon;
+			uint16 time_year = (t->tm_year) + 1900;
+			regs.time_yearL = time_year & 0xFF;
+			regs.time_yearH = time_year >> 8;
+		}
+
+		switch(counter) {
+			case  0: return 0x00;  //???
+			case  1: return 0x00;  //???
+			case  2: return 0x00;  //???
+			case  3: return 0x00;  //???
+			case  4: return 0x03;  //???
+			case  5: return 0x01;
+			case  6: return 0x01;
+			case  7: return 0x00;
+			case  8: return 0x00;
+			case  9: return 0x00;
+			case 10: return regs.time_second;
+			case 11: return regs.time_minute;
+			case 12: return regs.time_hour;
+			case 13: return regs.time_weekday;
+			case 14: return regs.time_day;
+			case 15: return regs.time_month;
+			case 16: return regs.time_yearL;  //???
+			case 17: return regs.time_yearH;  //???
+		}
+		return 0;
+}
+
+
 uint8 BSXSatellaview::mmio_read(unsigned addr) {
-  addr &= 0xffff;
+  addr &= 0xffff;  
 
   switch(addr) {
     case 0x2188: return regs.r2188;
     case 0x2189: return regs.r2189;
-    case 0x218a: return regs.r218a;
-    case 0x218c: return regs.r218c;
+    case 0x218a: {
+		if(regs.r2188 == 0 && regs.r2189 == 0) {
+			return 0x01;
+		}
+		if (regs.BSXF_Queue <= 0) {
+			regs.BSXF_NUM++;
+			BSXfileopen(regs.BSXF_NUM-1);
+		}
+		if(!regs.BSX_access && (regs.BSXF_NUM-1) > 0) {
+			regs.BSXF_NUM=1;
+			BSXfileopen(regs.BSXF_NUM-1);
+		}
+		if(regs.BSX_access) {
+			regs.r218b_chk=true;
+			regs.r218c_chk=true;
+			return regs.BSXF_Queue;
+		}
+		else return 0;
+		//return regs.r218a;
+	}
+	
+	case 0x218b: {
+		if(regs.r218b_port) {
+			if(regs.r2188 == 0 && regs.r2189 == 0) {
+				regs.r218b = 0x90;
+				return 0x90;
+			}
+			if(regs.BSX_access) {
+				regs.r218b_chk=false;
+				uint8 lol = 0;
+				if (regs.BSXF_1ST) {
+					lol = 0x10;
+					regs.BSXF_1ST = false;
+				}
+				regs.BSXF_Queue--;
+				if (regs.BSXF_Queue==0) { lol |= 0x80; }
+				regs.r218d |= lol;
+				return lol;
+			}
+		}
+		else return 0x00;
+	}
+    case 0x218c: {
+		if(regs.r218c_port) {
+			if(regs.r2188 == 0 && regs.r2189 == 0) {
+				return GetTime(false);
+			}
+			if(regs.BSX_access) {
+			/*	if(!regs.r218c_chk && BSXF.offset() <= 0x48) regs.r218b_chk=true;
+				if(regs.r218c_chk) {
+					//BSXF.seek(0x48);
+					regs.r218c_chk=false;
+					return BSXF.read();
+				} */
+				return BSXF.read();
+			}
+		}
+		else return 0x00;
+	}
+	case 0x218d: {
+		uint8 lol = regs.r218d;
+		regs.r218d = 0;
+		return lol;
+	}
     case 0x218e: return regs.r218e;
     case 0x218f: return regs.r218f;
-    case 0x2190: return regs.r2190;
+    case 0x2190: {
+		if(regs.r218e == 0 && regs.r218f == 0) {
+			return 0x01;
+		}
+		if (regs.BSXF2_Queue <= 0) {
+			regs.BSXF2_NUM++;
+			BSX2fileopen(regs.BSXF2_NUM-1);
+		}
+		if(!regs.BSX2_access && (regs.BSXF2_NUM-1) > 0) {
+			regs.BSXF2_NUM=1;
+			BSX2fileopen(regs.BSXF2_NUM-1);
+		}
+		if(regs.BSX2_access) {
+			regs.r2191_chk=true;
+			regs.r2192_chk=true;
+			return regs.BSXF2_Queue;
+		}
+		else return 0;
+	}
+	
+	case 0x2191: {
+	  if(regs.r2191_port) {
+			if(regs.r218e == 0 && regs.r218f == 0) {
+				regs.r2193 = 0x90;
+				return 0x90;
+			}
+			if(regs.BSX2_access) {
+				uint8 lol = 0;
+				if (regs.BSXF2_1ST) {
+					lol = 0x10;
+					regs.BSXF2_1ST = false;
+				}
+				regs.BSXF2_Queue--;
+				if (regs.BSXF2_Queue==0) { lol |= 0x80; }
+				regs.r2193 |= lol;
+				return lol;
+			}
+	  }
+	  else return 0;
+	}
 
     case 0x2192: {
-      unsigned counter = regs.r2192_counter++;
-      if(regs.r2192_counter >= 18) regs.r2192_counter = 0;
+	  if(regs.r2192_port) {
+		if(regs.r218e == 0 && regs.r218f == 0) {
+			return GetTime(false);
+		}
+		if(regs.BSX2_access) {
+		/*
+			if(!regs.r2192_chk && BSXF2.offset() <= 0x48) regs.r2191_chk=true;
+			if(regs.r2192_chk) {
+				//BSXF2.seek(0x48);
+				regs.r2192_chk=false;
+				return BSXF2.read();
+			} */
+			return BSXF2.read();
+		}
+		else return 0x00;
+	} break;
 
-      if(counter == 0) {
-        time_t rawtime;
-        time(&rawtime);
-        tm *t = localtime(&rawtime);
-
-        regs.r2192_hour   = t->tm_hour;
-        regs.r2192_minute = t->tm_min;
-        regs.r2192_second = t->tm_sec;
-      }
-
-      switch(counter) {
-        case  0: return 0x00;  //???
-        case  1: return 0x00;  //???
-        case  2: return 0x00;  //???
-        case  3: return 0x00;  //???
-        case  4: return 0x00;  //???
-        case  5: return 0x01;
-        case  6: return 0x01;
-        case  7: return 0x00;
-        case  8: return 0x00;
-        case  9: return 0x00;
-        case 10: return regs.r2192_second;
-        case 11: return regs.r2192_minute;
-        case 12: return regs.r2192_hour;
-        case 13: return 0x00;  //???
-        case 14: return 0x00;  //???
-        case 15: return 0x00;  //???
-        case 16: return 0x00;  //???
-        case 17: return 0x00;  //???
-      }
-    } break;
-
-    case 0x2193: return regs.r2193 & ~0x0c;
-    case 0x2194: return regs.r2194;
+    case 0x2193: {
+		uint8 lol = regs.r2193;
+		regs.r2193 = 0;
+		return lol;
+	}
+    case 0x2194: return 0xff; //regs.r2194;
     case 0x2196: return regs.r2196;
     case 0x2197: return regs.r2197;
     case 0x2199: return regs.r2199;
   }
-
+ }
   return cpu.regs.mdr;
 }
 
@@ -84,11 +261,23 @@
 
   switch(addr) {
     case 0x2188: {
-      regs.r2188 = data;
+	  //printf("Write 2188: %02.2hX\n", regs.r2188);
+	  if (regs.r2188 != data) {
+		regs.BSXF_Signal = 0;
+		regs.BSXF_NUM = 0;
+	  }
+	  else regs.BSXF_Signal++;
+	  regs.r2188 = data;
     } break;
 
     case 0x2189: {
-      regs.r2189 = data;
+	  //printf("Write 2189: %02.2hX\n", regs.r2189);
+	  if (regs.r2189 != data) {
+		regs.BSXF_Signal = 0;
+		regs.BSXF_NUM = 0;
+	  }
+	  else regs.BSXF_Signal++;
+	  regs.r2189 = data;
     } break;
 
     case 0x218a: {
@@ -96,30 +285,55 @@
     } break;
 
     case 0x218b: {
-      regs.r218b = data;
+	  if (data && 1 == 1) {
+		regs.r218b_port=true;
+		regs.r218b_chk=true;
+	  }
+	  else regs.r218b_port=false;
+      //regs.r218b = data;
     } break;
 
     case 0x218c: {
-      regs.r218c = data;
+	  if (regs.r2188 == 0 && regs.r2189 == 0) { GetTime(true); }
+	  if (data && 1 == 1) {
+		regs.r218c_port=true;
+		regs.r218c_chk=true;
+	  }
+	  else regs.r218c_port=false;
+      //regs.r218c = data;
     } break;
 
     case 0x218e: {
-      regs.r218e = data;
+      //printf("Write 218E: %02.2hX\n", regs.r2188);
+	  if (regs.r218e != data) {
+		regs.BSXF2_Signal = 0;
+		regs.BSXF2_NUM = 0;
+	  }
+	  else regs.BSXF2_Signal++;
+	  regs.r218e = data;
     } break;
 
     case 0x218f: {
-      regs.r218e >>= 1;
-      regs.r218e = regs.r218f - regs.r218e;
-      regs.r218f >>= 1;
+      //printf("Write 218F: %02.2hX\n", regs.r2189);
+	  if (regs.r218f != data) {
+		regs.BSXF2_Signal = 0;
+		regs.BSXF2_NUM = 0;
+	  }
+	  else regs.BSXF2_Signal++;
+	  regs.r218f = data;
     } break;
 
     case 0x2191: {
-      regs.r2191 = data;
-      regs.r2192_counter = 0;
+      if (data && 1 == 1) regs.r2191_port=true;
+	  else regs.r2191_port=false;
+	  //regs.r2191 = data;
+      regs.time_counter = 0;
     } break;
 
     case 0x2192: {
-      regs.r2190 = 0x80;
+	  if (regs.r218e == 0 && regs.r218f == 0) { GetTime(true); }
+	  if (data && 1 == 1) regs.r2192_port=true;
+	  else regs.r2192_port=false;
     } break;
 
     case 0x2193: {
diff -urN ./snes/chip/bsx/satellaview/satellaview.hpp ../../bsnes-sx2_v009/snes/chip/bsx/satellaview/satellaview.hpp
--- ./snes/chip/bsx/satellaview/satellaview.hpp	2011-01-25 21:58:39.000000000 +0900
+++ ../../bsnes-sx2_v009/snes/chip/bsx/satellaview/satellaview.hpp	2012-04-07 13:32:03.000000000 +0900
@@ -1,3 +1,5 @@
+#include <nall/file.hpp>
+
 class BSXSatellaview {
 public:
   void init();
@@ -6,6 +8,14 @@
   void power();
   void reset();
 
+  file BSXF;
+  file BSXF2;
+
+  void BSXfileopen(uint8 filenumber);
+  void BSX2fileopen(uint8 filenumber);
+  
+  uint8 GetTime(bool reset_count);
+  
   uint8 mmio_read(unsigned addr);
   void mmio_write(unsigned addr, uint8 data);
 
@@ -18,8 +28,33 @@
     uint8 r2198, r2199, r219a, r219b;
     uint8 r219c, r219d, r219e, r219f;
 
-    uint8 r2192_counter;
-    uint8 r2192_hour, r2192_minute, r2192_second;
+    uint8 time_counter;
+    uint8 time_hour, time_minute, time_second;
+	uint8 time_weekday, time_day, time_month;
+	uint8 time_yearL, time_yearH;
+	
+	bool r218b_port, r218c_port;
+	bool r2191_port, r2192_port;
+	
+	bool BSX_access;
+	uint8 BSXF_NUM;
+	uint8 BSXF_Signal;
+	
+	uint8 BSXF_Queue;
+	bool BSXF_1ST;
+	
+	bool BSX2_access;
+	uint8 BSXF2_NUM;
+	uint8 BSXF2_Signal;
+	
+	uint8 BSXF2_Queue;
+	bool BSXF2_1ST;
+	
+	bool r218b_chk;
+	bool r218c_chk;
+	
+	bool r2191_chk;
+	bool r2192_chk;
   } regs;
 };
diff -urN ./ui/general/main-window.cpp ../../bsnes-sx2_v009/ui/general/main-window.cpp
--- ./ui/general/main-window.cpp	2011-08-12 07:14:22.000000000 +0900
+++ ../../bsnes-sx2_v009/ui/general/main-window.cpp	2012-01-22 20:42:30.000000000 +0900
@@ -28,6 +28,15 @@
 
   systemLoadCartridgeSuperGameBoy.setText("Load Super Game Boy Cartridge ...");
   systemLoadCartridgeSpecial.append(systemLoadCartridgeSuperGameBoy);

+  systemSaveMemoryPack.setText("Save Memory Pack");
+  system.append(systemSaveMemoryPack);
 
   system.append(systemSeparator1);
 
@@ -265,6 +282,15 @@
   systemLoadCartridgeBsx.onTick = [] { singleSlotLoader.loadCartridgeBsx(); };
   systemLoadCartridgeSufamiTurbo.onTick = [] { doubleSlotLoader.loadCartridgeSufamiTurbo(); };
   systemLoadCartridgeSuperGameBoy.onTick = [] { singleSlotLoader.loadCartridgeSuperGameBoy(); };
+  
+  systemSaveMemoryPack.onTick = [] { SNES::bsxflash.save(); };
 
   systemPower.onTick = [] {
     SNES::system.power();
diff -urN ./ui/general/main-window.hpp ../../bsnes-sx2_v009/ui/general/main-window.hpp
--- ./ui/general/main-window.hpp	2011-08-12 06:43:39.000000000 +0900
+++ ../../bsnes-sx2_v009/ui/general/main-window.hpp	2012-01-22 20:23:11.000000000 +0900
@@ -6,10 +6,16 @@
   Item systemLoadCartridgeBsx;
   Item systemLoadCartridgeSufamiTurbo;
   Item systemLoadCartridgeSuperGameBoy;
+  Item systemSaveMemoryPack;
   Separator systemSeparator1;
   Item systemPower;
   Item systemReset;
   Separator systemSeparator2;
   Menu systemPort1;
   RadioItem systemPort1None;
   RadioItem systemPort1Gamepad;
diff -urN ./ui/general/slot-loader.cpp ../../bsnes-sx2_v009/ui/general/slot-loader.cpp
--- ./ui/general/slot-loader.cpp	2011-08-08 17:26:43.000000000 +0900
+++ ../../bsnes-sx2_v009/ui/general/slot-loader.cpp	2012-01-11 09:30:20.000000000 +0900
@@ -35,7 +35,7 @@
 
   slotBrowse.onTick = []() {
     FileBrowser::Mode fileMode = (singleSlotLoader.mode == Mode::SuperGameBoy
-    ? FileBrowser::Mode::GameBoy : FileBrowser::Mode::Satellaview);
+    ? FileBrowser::Mode::GameBoy : (singleSlotLoader.mode == Mode::Bsx || singleSlotLoader.mode == Mode::BsxSlotted) ? FileBrowser::Mode::Satellaview : FileBrowser::Mode::XBand); //hard dependency on xband patch
     fileBrowser.fileOpen(fileMode, [](string filename) {
       singleSlotLoader.slotPath.setText(filename);
     });
 
