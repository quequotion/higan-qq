diff --git a/../../../git/Emulator/bsnes/bsnes/ananke/ananke.cpp b/nSide_v005-source-revised/ananke/ananke.cpp
index 51be602..9060c30 100644
--- a/../../../git/Emulator/bsnes/bsnes/ananke/ananke.cpp
+++ b/nSide_v005-source-revised/ananke/ananke.cpp
@@ -10,6 +10,7 @@ using namespace nall;
 using namespace phoenix;
 
 namespace Database {
+  #include "database/famicom.hpp"
   #include "database/super-famicom.hpp"
   #include "database/sufami-turbo.hpp"
   #include "database/bsx-satellaview.hpp"
@@ -37,6 +38,7 @@ struct Ananke {
 
   //famicom.cpp
   void copyFamicomSaves(const string &pathname);
+  string createFamicomDatabase(vector<uint8_t> &buffer, Markup::Node &document, const string &manifest);
   string createFamicomHeuristic(vector<uint8_t> &buffer);
   string openFamicom(vector<uint8_t> &buffer);
   string syncFamicom(const string &pathname);
diff --git a/nSide_v005-source-revised/ananke/database/famicom.hpp b/nSide_v005-source-revised/ananke/database/famicom.hpp
new file mode 100644
index 0000000..a3a950b
--- /dev/null
+++ b/nSide_v005-source-revised/ananke/database/famicom.hpp
@@ -0,0 +1,1092 @@
+string Famicom = R"(
+
+database revision=2012-10-22
+
+release
+  cartridge region=NTSC
+    board type=HVC-TLSROM
+    chip type=MMC3B
+    prg
+      rom name=program.rom size=0x40000
+    chr
+      rom name=character.rom size=0x20000
+  information
+    title:    アルマジロ
+    name:     Armadillo
+    region:   JP
+    revision: 1.0
+    board:    HVC-TLSROM-01
+    serial:   IGS-9T
+    sha256:   54526dc9444c0eb4b0e5814f98b5e522bcb9881a6f2c0644fc7a21ca8c03502b
+    configuration
+      rom name=program.rom size=0x40000
+      rom name=character.rom size=0x20000
+
+release
+  cartridge region=NTSC
+    board type=NAMCOT-3401
+    mirror mode=horizontal
+    prg
+      rom name=program.rom size=0x8000
+    chr
+      rom name=character.rom size=0x8000
+  information
+    title:    バベルの塔
+    name:     Babel no Tou
+    region:   JP
+    revision: 1.0
+    board:    3401
+    serial:   NAM-NBL-3900-16
+    sha256:   a9d7e89bd4ea28cfd169e32c4516ef5d059e19afb9dfa4ede8412f2373dfb0a7
+    configuration
+      rom name=program.rom size=0x8000
+      rom name=character.rom size=0x8000
+
+release
+  cartridge region=NTSC
+    board type=HVC-CNROM
+      security pass=0x3
+    mirror mode=horizontal
+    prg
+      rom name=program.rom size=0x8000
+    chr
+      rom name=character.rom size=0x2000
+  information
+    title:    B-ワイング
+    name:     B-Wings
+    region:   JP
+    revision: 1.0
+    board:    HVC-CNROM-256K-01
+    serial:   DFC-BW
+    sha256:   2b4ac20082e2f45a8f8fd4922a0e995829719a523e118a9eec891c3206adf25b
+    configuration
+      rom name=program.rom size=0x8000
+      rom name=character.rom size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=KONAMI-VRC-2
+    chip type=VRC2
+      pinout a0=0 a1=1
+    prg
+      rom name=program.rom size=0x20000
+    chr
+      rom name=character.rom size=0x20000
+  information
+    title:    コントラ 魂斗羅
+    name:     Contra
+    region:   JP
+    revision: 1.0
+    board:    LROG009-00
+    serial:   KON-RC826
+    sha256:   62c9d4e0578cb1e615ce9bb2c8ebc15b1e8de4c928c5c07ba9a85c11aa36ae4d
+    configuration
+      rom name=program.rom size=0x20000
+      rom name=character.rom size=0x20000
+
+release
+  cartridge region=NTSC
+    board type=HVC-UNROM
+    chip type=74HC08
+    mirror mode=horizontal
+    prg
+      rom name=program.rom size=0x20000
+    chr
+      ram size=0x2000
+  information
+    title:    クレイジークライマー
+    name:     Crazy Climber
+    region:   JP
+    revision: 1.0
+    board:    HVC-UNROM-02
+    serial:   NBF-CY (04)
+    sha256:   e24d3c754dce20e27046afeacb2dfc217950d4be766ded80c20283392cb3891e
+    configuration
+      rom name=program.rom size=0x20000
+      ram name=character.ram size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=NAMCOT-3453
+    chip type=118
+    prg
+      rom name=program.rom size=0x20000
+    chr
+      rom name=character.rom size=0x20000
+  information
+    title:    デビルマン
+    name:     Devil Man
+    region:   JP
+    revision: 1.0
+    board:    UNK-NAMCOT-DM
+    serial:   NAM-DM-5500
+    sha256:   d2140fc2e6354a9f4d0154dabac757e5559890edba4885799c1c979d8b7a8b20
+    configuration
+      rom name=program.rom size=0x20000
+      rom name=character.rom size=0x20000
+
+release
+  cartridge region=NTSC
+    board type=HVC-HROM
+    prg
+      rom name=program.rom size=0x4000
+    chr
+      rom name=character.rom size=0x2000
+  information
+    title:    ドンキーコングJr
+    name:     Donkey Kong Jr.
+    region:   JP
+    revision: 1.0
+    board:    HVC-HROM-01
+    serial:   HVC-JR
+    sha256:   950ebe68e7f74219b9e5e104200b03165d59c24264f02e32c12be967fd311ac2
+    configuration
+      rom name=program.rom size=0x4000
+      rom name=character.rom size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=HVC-RROM
+    mirror mode=vertical
+    prg
+      rom name=program.rom size=0x4000
+    chr
+      rom name=character.rom size=0x2000
+  information
+    title:    ダックハント
+    name:     Duck Hunt
+    region:   JP
+    revision: 1.0
+    board:    HVC-RROM-05
+    serial:   HVC-DH
+    sha256:   7026334a7e8742b61b450f4b3b182922c6a69fc723d7cd19c83db365f15e45ba
+    configuration
+      rom name=program.rom size=0x4000
+      rom name=character.rom size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=FDS
+    prg
+      rom name=program.rom size=0x2000
+      ram size=0x8000
+    chr
+      ram size=0x2000
+  information
+    title:    Famicom Disk System
+    name:     Famicom Disk System
+    region:   JP
+    revision: 1.0
+    board:    Famicom Disk System
+    serial:   N/A
+    sha256:   99c18490ed9002d9c6d999b9d8d15be5c051bdfa7cc7e73318053c9a994b0178
+    configuration
+      rom name=program.rom size=0x2000
+      ram name=work.ram size=0x8000
+      ram name=character.ram size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=BANDAI-JUMP2
+    chip type=LZ93D50
+    prg
+      rom name=program.rom size=0x80000
+      ram name=save.ram size=0x2000
+    chr
+      ram size=0x2000
+  information
+    title:    ファミコンジャンプII 最強の7人
+    name:     Famicom Jump II - Saikyou no 7 Nin
+    region:   JP
+    revision: 1.0
+    board:    BA-JUMP2
+    serial:   BA-FJ2
+    sha256:   dd031b72924e1d080f8758412c73224a274ae5e5a50d90310d578975df74101f
+    configuration
+      rom name=program.rom size=0x80000
+      ram name=save.ram size=0x2000
+      ram name=character.ram size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=NAMCOT-3301
+    mirror mode=horizontal
+    prg
+      rom name=program.rom size=0x4000
+    chr
+      rom name=character.rom size=0x2000
+  information
+    title:    ギャラガ
+    name:     Galaga
+    region:   JP
+    revision: 1.0
+    board:    3301
+    serial:   NAM-NGG-4500-05
+    sha256:   e6fe68b9f12578e74ba016ca146aaf8232b20475fb675c7d32e0ea4e47eb1cc8
+    configuration
+      rom name=program.rom size=0x4000
+      rom name=character.rom size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=NAMCOT-3301
+    mirror mode=horizontal
+    prg
+      rom name=program.rom size=0x2000
+    chr
+      rom name=character.rom size=0x2000
+  information
+    title:    ギャラクシアン
+    name:     Galaxian
+    region:   JP
+    revision: 1.0
+    board:    3301
+    serial:   NAM-NGX-4500-01
+    sha256:   50178a2856f8ed3574b4e7fd45b9d1ec44c660d51fe9783d0012a19df5892cce
+    configuration
+      rom name=program.rom size=0x2000
+      rom name=character.rom size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=SUNSOFT-5B
+    chip type=Sunsoft-5B
+    prg
+      rom name=program.rom size=0x40000
+    chr
+      rom name=character.rom size=0x20000
+  information
+    title:    ギミック!
+    name:     Gimmick!
+    region:   JP
+    revision: 1.0
+    board:    FC-GMK
+    serial:   SUN-GMK-6200
+    sha256:   1bbe4b3e20a004a4f741018e31e6ae291772b8876d6fb6f01494c9c5b0917c6c
+    configuration
+      rom name=program.rom size=0x40000
+      rom name=character.rom size=0x20000
+
+release
+  cartridge region=NTSC
+    board type=HVC-SROM
+    mirror mode=vertical
+    prg
+      rom name=program.rom size=0x4000
+    chr
+      rom name=character.rom size=0x2000
+  information
+    title:    ホーガンズアレイ
+    name:     Hogan's Alley
+    region:   JP
+    revision: 1.0
+    board:    HVC-SROM-03
+    serial:   HVC-HA
+    sha256:   8e4a04076b6a728a7e65a09737776dcb9defed7922bf0437d9a89bbe8c724b55
+    configuration
+      rom name=program.rom size=0x4000
+      rom name=character.rom size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=HVC-TLROM
+    chip type=MMC3C
+    prg
+      rom name=program.rom size=0x20000
+    chr
+      rom name=character.rom size=0x20000
+  information
+    title:    熱血格闘伝説
+    name:     Nekketsu Kakutou Densetsu
+    region:   JP
+    revision: 1.0
+    board:    HVC-TLROM-04
+    serial:   TJC-NA
+    sha256:   3c419e3ecf328c03364afbcf5bd15bf0029a525db9e8f74379ae1cce4062b3c3
+    configuration
+      rom name=program.rom size=0x20000
+      rom name=character.rom size=0x20000
+
+release
+  cartridge region=NTSC
+    board type=NAMCOT-3416
+    chip type=118
+    mirror mode=vertical
+    prg
+      rom name=program.rom size=0x20000
+    chr
+      rom name=character.rom size=0x10000
+  information
+    title:    カイの冒険: The Quest of Ki
+    name:     Quest of Ki, The
+    region:   JP
+    revision: 1.0
+    serial:   NAM-QK-3900
+    sha256:   67123fe28cf5fbadeafc77400a0812f0135ab36706ec7d1267f84931d044e71d
+    configuration
+      rom name=program.rom size=0x20000
+      rom name=character.rom size=0x10000
+
+release
+  cartridge region=NTSC
+    board type=HVC-CNROM
+      security pass=0x1
+    mirror mode=vertical
+    prg
+      rom name=program.rom size=0x8000
+    chr
+      rom name=character.rom size=0x2000
+  information
+    title:    スパイVSスパイ
+    name:     Spy vs. Spy
+    region:   JP
+    revision: 1.0
+    board:    HVC-CNROM-256K-01
+    serial:   KSC-SP
+    sha256:   a9cf92ec1a080faa195d0b3dcb48fbb5ee3362f0f2f14e14e4257def48ac4346
+    configuration
+      rom name=program.rom size=0x8000
+      rom name=character.rom size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=HVC-NROM-256
+    mirror mode=vertical
+    prg
+      rom name=program.rom size=0x8000
+    chr
+      rom name=character.rom size=0x2000
+  information
+    title:    スーパーマリオブラザーズ
+    name:     Super Mario Bros.
+    region:   JP
+    revision: 1.0
+    board:    HVC-NROM-256K-02
+    serial:   HVC-SM
+    sha256:   fcb6a0ef3a20c19b356005fbb21dc8009563b1cb5a9aaebc8e9386b4a8c5912e
+    configuration
+      rom name=program.rom size=0x8000
+      rom name=character.rom size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=HVC-NROM-256
+    mirror mode=horizontal
+    prg
+      rom name=program.rom size=0x8000
+    chr
+      rom name=character.rom size=0x2000
+  information
+    title:    テグザー
+    name:     Thexder
+    region:   JP
+    revision: 1.0
+    board:    HVC-NROM-256K-02S
+    serial:   SQF-TX
+    sha256:   18d41a2dc65d8afce295eaf29c391539a69d7cfe6dd32503713ae13d4495a545
+    configuration
+      rom name=program.rom size=0x8000
+      rom name=character.rom size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=FDS
+    prg
+      rom name=program.rom size=0x2000
+      ram size=0x8000
+    chr
+      ram size=0x2000
+  information
+    title:    Twin Famicom Disk System
+    name:     Twin Famicom Disk System
+    region:   JP
+    revision: 1.0
+    board:    Famicom Disk System
+    serial:   N/A
+    sha256:   a0a9d57cbace21bf9c85c2b85e86656317f0768d7772acc90c7411ab1dbff2bf
+    configuration
+      rom name=program.rom size=0x2000
+      ram name=work.ram size=0x8000
+      ram name=character.ram size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=HVC-NROM-128
+    mirror mode=vertical
+    prg
+      rom name=program.rom size=0x4000
+    chr
+      rom name=character.rom size=0x2000
+  information
+    title:    Wild Gunman
+    name:     Wild Gunman
+    region:   JP
+    revision: 1.1
+    board:    2I
+    serial:   HVC-WG
+    sha256:   adff304553b64384f86f6c2b63571f43972b9d087f92359a1b9b93b54d523542
+    configuration
+      rom name=program.rom size=0x4000
+      rom name=character.rom size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=NES-SGROM
+    chip type=MMC1A
+    prg
+      rom name=program.rom size=0x40000
+    chr
+      ram size=0x2000
+  information
+    title:    Bionic Commando
+    name:     Bionic Commando
+    region:   NA
+    revision: 1.0
+    board:    NES-SGROM-03
+    serial:   NES-CM-USA
+    sha256:   aeb61fd5cf5a5ed73344c46a43f8a8d539f601ff57e8f56c49bc1caea4ab3d9e
+    configuration
+      rom name=program.rom size=0x40000
+      ram name=character.ram size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=NES-SLROM
+    chip type=MMC1B2
+    prg
+      rom name=program.rom size=0x20000
+    chr
+      rom name=character.rom size=0x20000
+  information
+    title:    Clash at Demonhead
+    name:     Clash at Demonhead
+    region:   NA
+    revision: 1.0
+    board:    NES-SLROM-05
+    serial:   NES-B6-USA
+    sha256:   cf226f0d9486103bbaa19ee124b673d47aa2b3766334b6b7587d704c03e6649e
+    configuration
+      rom name=program.rom size=0x20000
+      rom name=character.rom size=0x20000
+
+release
+  cartridge region=NTSC
+    board type=NES-CNROM
+    mirror mode=vertical
+    prg
+      rom name=program.rom size=0x8000
+    chr
+      rom name=character.rom size=0x8000
+  information
+    title:    Cybernoid: The Fighting Machine
+    name:     Cybernoid - The Fighting Machine
+    region:   NA
+    revision: 1.0
+    serial:   NES-YN-USA
+    sha256:   ad1e14d08657d99c8b70f779931f62524b4beb529090b82b368925d8b642e40c
+    configuration
+      rom name=program.rom size=0x8000
+      rom name=character.rom size=0x8000
+
+release
+  cartridge region=NTSC
+    board type=NES-BNROM
+    mirror mode=horizontal
+    prg
+      rom name=program.rom size=0x20000
+    chr
+      ram size=0x2000
+  information
+    title:    Deadly Towers
+    name:     Deadly Towers
+    region:   NA
+    revision: 1.0
+    board:    NES-BN-ROM-01
+    serial:   NES-DE-USA
+    sha256:   0115356b0791cc8ddcb7d3163d6ef7aa664f3ff4e68dba561ffffb79eefcbca9
+    configuration
+      rom name=program.rom size=0x20000
+      ram name=character.ram size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=NES-SNROM
+    chip type=MMC1B2
+    prg
+      rom name=program.rom size=0x40000
+      ram name=save.ram size=0x2000
+    chr
+      ram size=0x2000
+  information
+    title:    Destiny of an Emperor
+    name:     Destiny of an Emperor
+    region:   NA
+    revision: 1.0
+    serial:   NES-YZ-USA
+    sha256:   6d082c801942ce6787b471428ab4c8a6acb3e21f3f38fa197f2aeb698d9a2d7e
+    configuration
+      rom name=program.rom size=0x40000
+      ram name=save.ram size=0x2000
+      ram name=character.ram size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=NES-NROM-128
+    mirror mode=vertical
+    prg
+      rom name=program.rom size=0x4000
+    chr
+      rom name=character.rom size=0x2000
+  information
+    title:    Donkey Kong Jr.
+    name:     Donkey Kong Jr.
+    region:   NA
+    revision: 1.0
+    board:    NES-NROM-128-03
+    serial:   NES-JR-USA
+    sha256:   950ebe68e7f74219b9e5e104200b03165d59c24264f02e32c12be967fd311ac2
+    configuration
+      rom name=program.rom size=0x4000
+      rom name=character.rom size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=NES-NROM-128
+    mirror mode=vertical
+    prg
+      rom name=program.rom size=0x4000
+    chr
+      rom name=character.rom size=0x2000
+  information
+    title:    Duck Hunt
+    name:     Duck Hunt
+    region:   NA
+    revision: 1.0
+    board:    NES-NROM-128-03
+    serial:   NES-DH-USA
+    serial:   NES-DH-CAN
+    sha256:   7026334a7e8742b61b450f4b3b182922c6a69fc723d7cd19c83db365f15e45ba
+    configuration
+      rom name=program.rom size=0x4000
+      rom name=character.rom size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=NES-UNROM
+    chip type=74HC32
+    mirror mode=vertical
+    prg
+      rom name=program.rom size=0x20000
+    chr
+      ram size=0x2000
+  information
+    title:    Disney's DuckTales
+    name:     DuckTales
+    region:   NA
+    revision: 1.0
+    board:    NES-UNROM-09
+    serial:   NES-UK-USA
+    sha256:   8ba8baed01a9fbaf1e9ff29e0c9825db1963ac2aff211d6f1f3bcfd3839e2013
+    configuration
+      rom name=program.rom size=0x20000
+      ram name=character.ram size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=NES-UNROM
+    chip type=74HC32
+    mirror mode=vertical
+    prg
+      rom name=program.rom size=0x20000
+    chr
+      ram size=0x2000
+  information
+    title:    Disney's DuckTales 2
+    name:     DuckTales 2
+    region:   NA
+    revision: 1.0
+    board:    NES-UNROM-10
+    serial:   NES-DL-USA
+    sha256:   54c70628739c9cfab40b8d79555e9076adae34127ef369988ca91635b4a688bf
+    configuration
+      rom name=program.rom size=0x20000
+      ram name=character.ram size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=NES-GNROM
+    mirror mode=vertical
+    prg
+      rom name=program.rom size=0x20000
+    chr
+      rom name=character.rom size=0x8000
+  information
+    title:    Gumshoe
+    name:     Gumshoe
+    region:   NA
+    revision: 1.0
+    board:    NES-GN-ROM-01
+    serial:   NES-GS-USA
+    sha256:   4628f32db9b826d19fe5dd8e2c45a9f70e1041f15b7b44b06dee2f01731566e8
+    configuration
+      rom name=program.rom size=0x20000
+      rom name=character.rom size=0x8000
+
+release
+  cartridge region=NTSC
+    board type=NES-TQROM
+    chip type=MMC3B
+    prg
+      rom name=program.rom size=0x20000
+    chr
+      rom name=character.rom size=0x10000
+      ram size=0x2000
+  information
+    title:    High Speed
+    name:     High Speed
+    region:   NA
+    revision: 1.0
+    serial:   NES-8H-USA
+    sha256:   710e907230bbd82143286b40a56a298b25cf326697a9f07bfd8e043c1936a4b1
+    configuration
+      rom name=program.rom size=0x20000
+      rom name=character.rom size=0x10000
+      rom name=nametable.ram size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=NES-NROM-128
+    mirror mode=vertical
+    prg
+      rom name=program.rom size=0x4000
+    chr
+      rom name=character.rom size=0x2000
+  information
+    title:    Hogan's Alley
+    name:     Hogan's Alley
+    region:   NA
+    revision: 1.0
+    board:    NES-NROM-128-04
+    serial:   NES-HA-USA
+    sha256:   8e4a04076b6a728a7e65a09737776dcb9defed7922bf0437d9a89bbe8c724b55
+    configuration
+      rom name=program.rom size=0x4000
+      rom name=character.rom size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=NES-SNROM
+    chip type=MMC1B2
+    prg
+      rom name=program.rom size=0x20000
+      ram name=save.ram size=0x2000
+    chr
+      ram size=0x2000
+  information
+    title:    The Legend of Zelda
+    name:     Legend of Zelda, The
+    region:   NA
+    revision: 1.1
+    serial:   NES-ZL-USA
+    serial:   ec0d4ebf6d2fcecd1d95fef7329954efe79676959bc281ea908b226459bc6dc2
+    configuration
+      rom name=program.rom size=0x20000
+      ram name=save.ram size=0x2000
+      ram name=character.ram size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=NES-TLROM
+    chip type=MMC3C
+    prg
+      rom name=program.rom size=0x40000
+    chr
+      rom name=character.rom size=0x20000
+  information
+    title:    Little Samson
+    name:     Little Samson
+    region:   NA
+    revision: 1.0
+    board:    NES-TLROM-03
+    serial:   NES-LT-USA
+    sha256:   a5165565263eaf8bdc45a8e6a615704f9bf271cd6d547d22c098c80cbaffd879
+    configuration
+      rom name=program.rom size=0x40000
+      rom name=character.rom size=0x20000
+
+release
+  cartridge region=NTSC
+    board type=NES-SGROM
+    chip type=MMC1B2
+    prg
+      rom name=program.rom size=0x40000
+    chr
+      ram size=0x2000
+  information
+    title:    Mega Man 2
+    name:     Mega Man 2
+    region:   NA
+    revision: 1.0
+    sha256:   1e588d435e75d80c5c0b578b4fa8d196f2cf4346c11c9a7b7e435d768828ad01
+    configuration
+      rom name=program.rom size=0x40000
+      ram name=character.ram size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=NES-TQROM
+    chip type=MMC3A
+    prg
+      rom name=program.rom size=0x20000
+    chr
+      rom name=character.rom size=0x10000
+      ram size=0x2000
+  information
+    title:    Pin-Bot
+    name:     Pin-Bot
+    region:   NA
+    revision: 1.0
+    serial:   NES-IO-USA
+    sha256:   f4ddb0f1a02f823ebed30b55547344de3c8fb9d87254ff993584373ecadd9141
+    configuration
+      rom name=program.rom size=0x20000
+      rom name=character.rom size=0x10000
+      rom name=nametable.ram size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=NES-CNROM
+    mirror mode=horizontal
+    prg
+      rom name=program.rom size=0x8000
+    chr
+      rom name=character.rom size=0x8000
+  information
+    title:    Puzznic
+    name:     Puzznic
+    region:   NA
+    revision: 1.0
+    board:    NES-CNROM-07
+    serial:   NES-ZP-USA
+    sha256:   0cf2fc17a59a0932ce43e6b2e9ea4e2570f03139784b5c9df429a499e734b92e
+    configuration
+      rom name=program.rom size=0x8000
+      rom name=character.rom size=0x8000
+
+release
+  cartridge region=NTSC
+    board type=NES-HKROM
+    chip type=MMC6B
+    prg
+      rom name=program.rom size=0x40000
+      ram name=save.ram size=0x400
+    chr
+      rom name=character.rom size=0x40000
+  information
+    title:    StarTropics
+    name:     StarTropics
+    region:   NA
+    revision: 1.0
+    serial:   NES-OC-USA
+    sha256:   69de2c7552fa81ca5921da0e457abf1be35f18ffbad159788a76141be59c9f6b
+    configuration
+      rom name=program.rom size=0x40000
+      ram name=save.ram size=0x400
+      rom name=character.rom size=0x40000
+
+release
+  cartridge region=NTSC
+    board type=NES-NROM-256
+    mirror mode=vertical
+    prg
+      rom name=program.rom size=0x8000
+    chr
+      rom name=character.rom size=0x2000
+  information
+    title:    Super Mario Bros.
+    name:     Super Mario Bros.
+    region:   NA
+    revision: 1.0
+    board:    NES-NROM-256-04
+    serial:   NES-SM-USA
+    sha256:   fcb6a0ef3a20c19b356005fbb21dc8009563b1cb5a9aaebc8e9386b4a8c5912e
+    configuration
+      rom name=program.rom size=0x8000
+      rom name=character.rom size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=NES-MHROM
+    mirror mode=vertical
+    prg
+      rom name=program.rom size=0x10000
+    chr
+      rom name=character.rom size=0x4000
+  information
+    title:    Super Mario Bros. / Duck Hunt
+    name:     Super Mario Bros. + Duck Hunt
+    region:   NA
+    revision: 1.0
+    board:    NES-MHROM-04
+    serial:   NES-MH-USA
+    sha256:   5dde385041aa7364c78205f2ba49615f416c701b6025e38aa1d7b9c4f99a62db
+    configuration
+      rom name=program.rom size=0x10000
+      rom name=character.rom size=0x4000
+
+release
+  cartridge region=NTSC
+    board type=NES-TSROM
+    chip type=MMC3B
+    prg
+      rom name=program.rom size=0x20000
+      ram size=0x2000
+    chr
+      rom name=character.rom size=0x20000
+  information
+    title:    Super Mario Bros. 2
+    name:     Super Mario Bros. 2
+    region:   NA
+    revision: 1.1
+    board:    NES-TSROM-08
+    serial:   NES-MW-USA
+    serial:   NES-MW-CAN
+    sha256:   728d0ca6751b0c039fc3e34f2e7f27a870afcab30f5e270244ac40979c5f69ca
+    configuration
+      rom name=program.rom size=0x20000
+      ram name=work.ram size=0x2000
+      rom name=character.rom size=0x20000
+
+release
+  cartridge region=NTSC
+    board type=NES-TSROM
+    chip type=MMC3B
+    prg
+      rom name=program.rom size=0x40000
+      ram size=0x2000
+    chr
+      rom name=character.rom size=0x20000
+  information
+    title:    Super Mario Bros. 3
+    name:     Super Mario Bros. 3
+    region:   NA
+    revision: 1.0
+    board:    NES-TSROM-06
+    serial:   NES-UM-USA
+    sha256:   d77d17d34af24871d7ce1160ccd3330555835c8e940b7100e095ac38973d927a
+    configuration
+      rom name=program.rom size=0x40000
+      ram name=work.ram size=0x2000
+      rom name=character.rom size=0x20000
+
+release
+  cartridge region=NTSC
+    board type=NES-TSROM
+    chip type=MMC3B
+    prg
+      rom name=program.rom size=0x40000
+      ram size=0x2000
+    chr
+      rom name=character.rom size=0x20000
+  information
+    title:    Super Mario Bros. 3
+    name:     Super Mario Bros. 3
+    region:   NA
+    revision: 1.1
+    board:    NES-TSROM-07
+    serial:   NES-UM-USA
+    serial:   NES-UM-CAN
+    sha256:   959fdd32c71735d6fb2bd16a646d39f4ee65623273dd035e6a968e991bd13ef8
+    configuration
+      rom name=program.rom size=0x40000
+      ram name=work.ram size=0x2000
+      rom name=character.rom size=0x20000
+
+release
+  cartridge region=NTSC
+    board type=NES-SEROM
+    chip type=MMC1B2
+    prg
+      rom name=program.rom size=0x8000
+    chr
+      rom name=character.rom size=0x4000
+  information
+    title:    Tetris
+    name:     Tetris
+    region:   NA
+    revision: 1.0
+    board:    NES-SEROM-04
+    serial:   NES-EI-USA
+    serial:   NES-EI-CAN
+    sha256:   2ae5fb18a1bf841077e3872ba05060f030ea0bfc573994b2f8fe2fb570dc7853
+    configuration
+      rom name=program.rom size=0x8000
+      rom name=character.rom size=0x4000
+
+release
+  cartridge region=NTSC
+    board type=NES-TKROM
+    chip type=MMC3C
+    prg
+      rom name=program.rom size=0x40000
+      ram name=save.ram size=0x2000
+    chr
+      rom name=character.rom size=0x40000
+  information
+    title:    Wario's Woods
+    name:     Wario's Woods
+    region:   NA
+    revision: 1.0
+    board:    NES-TKROM-10
+    serial:   NES-WB-USA
+    sha256:   c12771e8155b030eff0081bfabd98e57a162d6592899f29dd16f141f0e6e08a3
+    configuration
+      rom name=program.rom size=0x40000
+      ram name=save.ram size=0x2000
+      rom name=character.rom size=0x40000
+
+release
+  cartridge region=NTSC
+    board type=NES-NROM-128
+    mirror mode=vertical
+    prg
+      rom name=program.rom size=0x4000
+    chr
+      rom name=character.rom size=0x2000
+  information
+    title:    Wild Gunman
+    name:     Wild Gunman
+    region:   NA
+    revision: 1.0
+    board:    NES-NROM-128-01
+    serial:   NES-WG-USA
+    sha256:   62aec65696ecf24a487b7cdd19bad5cbd19f4229a89a7888634d468c67da378a
+    configuration
+      rom name=program.rom size=0x4000
+      rom name=character.rom size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=NES-NROM-128
+    mirror mode=vertical
+    prg
+      rom name=program.rom size=0x4000
+    chr
+      rom name=character.rom size=0x2000
+  information
+    title:    Wild Gunman
+    name:     Wild Gunman
+    region:   NA
+    revision: 1.1
+    board:    NES-NROM-128-04
+    serial:   NES-WG-USA
+    sha256:   adff304553b64384f86f6c2b63571f43972b9d087f92359a1b9b93b54d523542
+    configuration
+      rom name=program.rom size=0x4000
+      rom name=character.rom size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=NES-CNROM
+    mirror mode=horizontal
+    prg
+      rom name=program.rom size=0x8000
+    chr
+      rom name=character.rom size=0x8000
+  information
+    title:    World Class Track Meet
+    name:     World Class Track Meet
+    region:   NA
+    revision: 1.1
+    serial:   NES-WT-USA
+    sha256:   ac766a8d99bfd8e95c02b9a9c68279c72ba5b3307b78edc67b52781ed185fa89
+    configuration
+      rom name=program.rom size=0x8000
+      rom name=character.rom size=0x8000
+
+release
+  cartridge region=NTSC
+    board type=NES-HKROM
+    chip type=MMC6B
+    prg
+      rom name=program.rom size=0x40000
+      ram name=save.ram size=0x400
+    chr
+      rom name=character.rom size=0x40000
+  information
+    title:    Zoda's Revenge: StarTropics 2
+    name:     Zoda's Revenge - StarTropics 2
+    region:   NA
+    revision: 1.0
+    board:    NES-HKROM-02
+    serial:   NES-6C-USA
+    sha256:   d0850075065ecbd125a33accc952de5d012527be45aa14a1b8223a9adf1643ae
+    configuration
+      rom name=program.rom size=0x40000
+      ram name=save.ram size=0x400
+      rom name=character.rom size=0x40000
+
+release
+  cartridge region=PAL
+    board type=NES-NROM-128
+    mirror mode=vertical
+    prg
+      rom name=program.rom size=0x4000
+    chr
+      rom name=character.rom size=0x2000
+  information
+    title:    Hogan's Alley
+    name:     Hogan's Alley
+    region:   EU
+    revision: 1.0
+    board:    NES-NROM-128-03
+    serial:   NES-HA-EEC
+    sha256:   8e4a04076b6a728a7e65a09737776dcb9defed7922bf0437d9a89bbe8c724b55
+    configuration
+      rom name=program.rom size=0x4000
+      rom name=character.rom size=0x2000
+
+release
+  cartridge region=PAL
+    board type=NES-TSROM
+    chip type=MMC3C
+    prg
+      rom name=program.rom size=0x20000
+      ram size=0x2000
+    chr
+      rom name=character.rom size=0x20000
+  information
+    title:    Noah's Ark
+    name:     Noah's Ark
+    region:   EU
+    revision: 1.0
+    serial:   NES-NH-NOE
+    sha256:   6157c99fe7a214025c65fd3649e4afe9cd2d38c333e65af028b935e49fbeb500
+    configuration
+      rom name=program.rom size=0x20000
+      ram name=work.ram size=0x2000
+      rom name=character.rom size=0x20000
+
+release
+  cartridge region=PAL
+    board type=NES-TKROM
+    chip type=MMC3C
+    prg
+      rom name=program.rom size=0x40000
+      ram name=save.ram size=0x2000
+    chr
+      rom name=character.rom size=0x40000
+  information
+    title:    Wario's Woods
+    name:     Wario's Woods
+    region:   EU
+    revision: 1.0
+    board:    NES-TKROM-10
+    serial:   NES-WB-NOE
+    sha256:   9fe815d8fd175ef9ef03fb010638f2b6b7aa9d11d5a40eda2476450918543e6f
+    configuration
+      rom name=program.rom size=0x40000
+      ram name=save.ram size=0x2000
+      rom name=character.rom size=0x40000
+
+)";
diff --git a/nSide_v005-source-revised/ananke/database/playchoice-10.hpp b/nSide_v005-source-revised/ananke/database/playchoice-10.hpp
new file mode 100644
index 0000000..a4cc24e
--- /dev/null
+++ b/nSide_v005-source-revised/ananke/database/playchoice-10.hpp
@@ -0,0 +1,30 @@
+string Famicom = R"(
+
+database revision=2012-10-22
+
+release
+  cartridge region=NTSC
+    board type=NES-NROM-256
+    mirror mode=vertical
+    prg
+      rom name=program.rom size=0x8000
+    chr
+      rom name=character.rom size=0x2000
+    pc10
+      rom name=pc10.rom size=0x2000
+      rom name=key1.rom size=0x10
+      rom name=key2.rom size=0x10
+  information
+    title:    Super Mario Bros.
+    name:     Super Mario Bros.
+    region:   NA
+    revision: 1.0
+    sha256:   fd8652394c0c9cba34c35a5f8c0ed6ab155e2c99aa4180fc940bdf1e25a0132d
+    configuration
+      rom name=program.rom size=0x8000
+      rom name=character.rom size=0x2000
+      rom name=pc10.rom size=0x2000
+      rom name=key1.rom size=0x10
+      rom name=key2.rom size=0x10
+
+)";
diff --git a/../../../git/Emulator/bsnes/bsnes/ananke/famicom.cpp b/nSide_v005-source-revised/ananke/famicom.cpp
index a54039c..f4083ba 100644
--- a/../../../git/Emulator/bsnes/bsnes/ananke/famicom.cpp
+++ b/nSide_v005-source-revised/ananke/famicom.cpp
@@ -1,11 +1,42 @@
 void Ananke::copyFamicomSaves(const string &pathname) {
   if(!file::exists({pathname, "save.ram"})) {
     if(file::exists({information.path, nall::basename(information.name), ".sav"})) {
-      file::copy({information.path, nall::basename(information.name), ".srm"}, {pathname, "save.ram"});
+      file::copy({information.path, nall::basename(information.name), ".sav"}, {pathname, "save.ram"});
     }
   }
 }
 
+string Ananke::createFamicomDatabase(vector<uint8_t> &buffer, Markup::Node &document, const string &manifest) {
+  string pathname = {
+    libraryPath, "Famicom/",
+    document["release/information/name"].text(),
+    " (", document["release/information/region"].text(), ")",
+    " (", document["release/information/revision"].text(), ")",
+    ".fc/"
+  };
+  directory::create(pathname);
+
+  //strip "release" root node from database entry (since a single game manifest isn't part of a database)
+  string markup = manifest;
+  markup.replace("\n  ", "\n");
+  markup.replace("information", "\ninformation");
+  markup.ltrim<1>("release\n");
+
+  file::write({pathname, "manifest.bml"}, markup);
+
+  unsigned offset = 0;
+  for(auto &node : document["release/information/configuration"]) {
+    if(node.name != "rom") continue;
+    string name = node["name"].text();
+    unsigned size = node["size"].decimal();
+    file::write({pathname, name}, buffer.data() + offset, size);
+    offset += size;
+  }
+
+  copyFamicomSaves(pathname);
+  return pathname;
+}
+
 string Ananke::createFamicomHeuristic(vector<uint8_t> &buffer) {
   string pathname = {
     libraryPath, "Famicom/",
@@ -16,7 +47,7 @@ string Ananke::createFamicomHeuristic(vector<uint8_t> &buffer) {
 
   FamicomCartridge info(buffer.data(), buffer.size());
   string markup = {"unverified\n\n", info.markup};
-  markup.append("\ninformation\n  title: ", nall::basename(information.name), "\n");
+  markup.append("\ninformation\n  title: ", nall::basename(information.name));
   if(!information.manifest.empty()) markup = information.manifest;  //override with embedded beat manifest, if one exists
 
   file::write({pathname, "manifest.bml"}, markup);
@@ -28,6 +59,33 @@ string Ananke::createFamicomHeuristic(vector<uint8_t> &buffer) {
 }
 
 string Ananke::openFamicom(vector<uint8_t> &buffer) {
+  bool ines = true;
+  ines = ines && buffer.data()[0] == 'N';
+  ines = ines && buffer.data()[1] == 'E';
+  ines = ines && buffer.data()[2] == 'S';
+  ines = ines && buffer.data()[3] == 0x1A;
+  if(ines && buffer.data()[4] == 0x01) {
+    string sha256_1 = nall::sha256(buffer.data() + 0x0010, 0x2000);
+    string sha256_2 = nall::sha256(buffer.data() + 0x2010, 0x2000);
+    if(sha256_1 == sha256_2) {
+      buffer.remove(16,0x2000);
+    }
+  }
+  string sha256 = nall::sha256(buffer.data() + (ines ? 16 : 0), buffer.size() - (ines ? 16 : 0));
+
+  string databaseText = string::read({configpath(), "ananke/database/Famicom.bml"}).strip();
+  if(databaseText.empty()) databaseText = string{Database::Famicom}.strip();
+  lstring databaseItem = databaseText.split("\n\n");
+
+  for(auto &item : databaseItem) {
+    auto document = Markup::Document(item);
+
+    if(document["release/information/sha256"].text() == sha256) {
+      if(ines) buffer.remove(0, 16);
+      return createFamicomDatabase(buffer, document, item);
+    }
+  }
+
   return createFamicomHeuristic(buffer);
 }
 
@@ -35,5 +93,32 @@ string Ananke::openFamicom(vector<uint8_t> &buffer) {
 //game folders discard iNES header required for heuristic detection
 //a games database of all commercial Famicom software will be required
 string Ananke::syncFamicom(const string &pathname) {
-  return "";
+  vector<uint8_t> buffer;
+
+  auto append = [&](string filename) {
+    filename = {pathname, filename};
+    auto data = file::read(filename);
+    if(data.size() == 0) return;  //file does not exist
+
+    unsigned position = buffer.size();
+    buffer.resize(buffer.size() + data.size());
+    memcpy(buffer.data() + position, data.data(), data.size());
+  };
+
+  append("program.rom");
+  append("character.rom");
+
+  if(buffer.size() == 0) return "";
+
+  auto save = file::read({pathname, "save.ram"});
+  if(save.size() == 0) save = file::read({pathname, "save.rwm"});
+
+  directory::remove(pathname);
+  information.path = pathname;
+  information.name = notdir(string{pathname}.rtrim<1>("/"));
+  string outputPath = openFamicom(buffer);
+
+  if(save.size()) file::write({outputPath, "save.ram"}, save);
+
+  return outputPath;
 }
diff --git a/../../../git/Emulator/bsnes/bsnes/ananke/heuristics/famicom.hpp b/nSide_v005-source-revised/ananke/heuristics/famicom.hpp
index 08d243a..756a3bd 100644
--- a/../../../git/Emulator/bsnes/bsnes/ananke/heuristics/famicom.hpp
+++ b/nSide_v005-source-revised/ananke/heuristics/famicom.hpp
@@ -17,62 +17,126 @@ struct FamicomCartridge {
   unsigned prgram;
   unsigned chrrom;
   unsigned chrram;
+  bool     battery;
+  bool     region;
+  bool     vs;
+  // NES 2.0
+  bool     pc10;
+  bool     nes2;
+  unsigned submapper;
 };
 
 FamicomCartridge::FamicomCartridge(const uint8_t *data, unsigned size) {
   markup = "";
   if(size < 16) return;
-  if(data[0] != 'N') return;
-  if(data[1] != 'E') return;
-  if(data[2] != 'S') return;
-  if(data[3] !=  26) return;
+  if(data[0] != 'N' ) return;
+  if(data[1] != 'E' ) return;
+  if(data[2] != 'S' ) return;
+  if(data[3] != 0x1A) return;
 
-  mapper = ((data[7] >> 4) << 4) | (data[6] >> 4);
-  mirror = ((data[6] & 0x08) >> 2) | (data[6] & 0x01);
-  prgrom = data[4] * 0x4000;
-  chrrom = data[5] * 0x2000;
-  prgram = 0u;
-  chrram = chrrom == 0u ? 8192u : 0u;
+  mapper  = ((data[7] >> 4) << 4) | (data[6] >> 4);
+  prgrom  = data[4] * 0x4000;
+  chrrom  = data[5] * 0x2000;
+  prgram  = 0u;
+  chrram  = chrrom == 0u ? 8192u : 0u;
+  mirror  = ((data[6] & 0x08) >> 2) | (data[6] & 0x01);
+  battery = data[6] & 0x02;
+  vs      = data[7] & 0x01;
+  nes2    = data[7] & 0x0c == 0x08;
+  if(!nes2) {
+    // ignore the last 9 bytes of headers that have "DiskDude!" or other
+    // messages written there
+    if(data[12] == 0 && data[13] == 0 && data[14] == 0 && data[15] == 0) {
+      prgram = data[8] * 0x2000;
+      region = data[9] & 0x01;
+    } else {
+      mapper &= 0x0f;
+      vs = false;
+      pc10 = false;
+    }
+  } else {
+    pc10 = data[7] & 0x02;
+    mapper |= (data[8] & 0x0f) << 8;
+    submapper |= data[8] >> 4;
+    prgrom += (data[9] & 0x0f) * 0x400000;
+    chrrom += (data[9] >> 4) * 0x200000;
+    prgram = (data[10] & 0x0f == 0 ? 0 : 64) << (data[10] & 0x0f); // no battery
+    prgram += (data[10] >> 4 == 0 ? 0 : 64) << (data[10] >> 4); // battery
+    chrram = (data[11] & 0x0f == 0 ? 0 : 64) << (data[11] & 0x0f); // no battery
+    chrram += (data[11] >> 4 == 0 ? 0 : 64) << (data[11] >> 4); // battery
+    region = data[12] & 0x01;
+  }
+
+  // Galaxian has its PRG ROM doubled to fit within iNES's constraints.
+  if(prgrom == 0x4000 && (prgrom + chrrom + 0x10 == size + 0x2000)) prgrom = 0x2000;
 
-  markup.append("cartridge\n");
+  markup.append("cartridge region=", region == 0 ? "NTSC" : "PAL", "\n");
 
   switch(mapper) {
   default:
-    markup.append("  board type=NES-NROM-256\n");
+    if(prgrom <= 8192) {
+      markup.append("  board type=NAMCOT-3301\n");
+    } else if(prgrom <= 16384) {
+      markup.append("  board type=NES-NROM-128\n");
+    } else {
+      markup.append("  board type=NES-NROM-256\n");
+    }
     markup.append("  mirror mode=", mirror == 0 ? "horizontal" : "vertical", "\n");
     break;
 
   case   1:
-    markup.append("  board type=NES-SXROM\n");
-    markup.append("  chip type=MMC1B2\n");
-    prgram = 8192;
+  case 155:
+    if(prgram <= 8192) {
+      markup.append("  board type=NES-SUROM\n");
+    } else {
+      markup.append("  board type=NES-SXROM\n");
+    }
+    markup.append("  chip type=MMC1", mapper != 155 ? "B2" : "A", "\n");
+    if(!nes2 && !prgram) prgram = 8192;
     break;
 
   case   2:
-    markup.append("  board type=NES-UOROM\n");
+  case 180:
+    if(prgrom <= 131072) markup.append("  board type=NES-UNROM\n");
+    else                 markup.append("  board type=NES-UOROM\n");
+    markup.append("  chip type=74HC", mapper != 180 ? "32" : "08", "\n");
     markup.append("  mirror mode=", mirror == 0 ? "horizontal" : "vertical", "\n");
     break;
 
   case   3:
+  case 185:
     markup.append("  board type=NES-CNROM\n");
+    if(mapper == 185) {
+      markup.append("    security pass=0x", hex(submapper & 3), "\n");
+    }
     markup.append("  mirror mode=", mirror == 0 ? "horizontal" : "vertical", "\n");
     break;
 
   case   4:
-    //MMC3
-    markup.append("  board type=NES-TLROM\n");
-    markup.append("  chip type=MMC3B\n");
-    prgram = 8192;
-    //MMC6
-  //markup.append("  board type=NES-HKROM\n");
-  //markup.append("  chip type=MMC6n");
-  //prgram = 1024;
+  case 118:
+  case 119:
+    if(prgram != 0x400) {
+      switch(mapper) {
+      case   4:
+        if(mirror & 2) markup.append("  board type=NES-TR1ROM\n");
+        else           markup.append("  board type=NES-TLROM\n");
+        break;
+      case 118: markup.append("  board type=NES-TLSROM\n"); break;
+      case 119: markup.append("  board type=NES-TQROM\n"); break;
+      }
+      markup.append("  chip type=MMC3B\n");
+    } else {
+      markup.append("  board type=NES-HKROM\n");
+      markup.append("  chip type=MMC6n");
+    }
+    if(!nes2 && !prgram) prgram = 8192;
+    if(mapper == 119 && !nes2 && !chrram) chrram = 0x2000;
     break;
 
   case   5:
     markup.append("  board type=NES-ELROM\n");
     markup.append("  chip type=MMC5\n");
-    prgram = 65536;
+    if(!nes2 && !prgram) prgram = 32768;
     break;
 
   case   7:
@@ -82,46 +146,83 @@ FamicomCartridge::FamicomCartridge(const uint8_t *data, unsigned size) {
   case   9:
     markup.append("  board type=NES-PNROM\n");
     markup.append("  chip type=MMC2\n");
-    prgram = 8192;
+    if(!nes2 && !prgram) prgram = 8192;
     break;
 
   case  10:
     markup.append("  board type=NES-FKROM\n");
     markup.append("  chip type=MMC4\n");
-    prgram = 8192;
+    if(!nes2 && !prgram) prgram = 8192;
+    break;
+
+  case  13:
+    markup.append("  board type=NES-CPROM\n");
+    markup.append("  mirror mode=", mirror == 0 ? "horizontal" : "vertical", "\n");
     break;
 
   case  16:
-    markup.append("  board type=BANDAI-FCG\n");
-    markup.append("  chip type=LZ93D50\n");
+  case 153:
+  case 159:
+    switch(mapper) {
+    case  16:
+      markup.append("  board type=BANDAI-FCG\n");
+      markup.append("  chip type=LZ93D50\n");
+      markup.append("  chip type=24C02\n");
+      break;
+    case 153:
+      markup.append("  board type=BANDAI-JUMP2\n");
+      markup.append("  chip type=LZ93D50\n");
+      if(!nes2 && !prgram) prgram = 8192;
+      break;
+    case 159:
+      markup.append("  board type=BANDAI-LZ93D50\n");
+      markup.append("  chip type=LZ93D50\n");
+      markup.append("  chip type=24C01\n");
+      break;
+    }
     break;
 
-  case  21:
-  case  23:
-  case  25:
-    //VRC4
+  case  21: //VRC4a,VRC4c
+  case  23: //VRC4e,VRC4f,VRC2b
+  case  25: //VRC4b,VRC4d,VRC2c
     markup.append("  board type=KONAMI-VRC-4\n");
-    markup.append("  chip type=VRC4\n");
-    markup.append("    pinout a0=1 a1=0\n");
-    prgram = 8192;
+    markup.append("  chip type=", submapper == 15 ? "VRC2" : "VRC4", "\n");
+    if(submapper == 0) {
+      switch(mapper) {
+      case 21: markup.append("    pinout a0=1 a1=2\n"); break;
+      case 23: markup.append("    pinout a0=0 a1=1\n"); break;
+      case 25: markup.append("    pinout a0=1 a1=0\n"); break;
+      }
+    } else if(submapper == 15) {
+      markup.append("    pinout",
+        " a0=", submapper == 25,
+        " a1=", submapper == 23,
+      "\n");
+    } else {
+      markup.append("    pinout",
+        " a0=", submapper & 7,
+        " a1=", (submapper & 7) + (((submapper & 8) >> 2) - 1),
+      "\n");
+    }
+    if(!nes2 && !prgram) prgram = 8192;
     break;
 
   case  22:
-    //VRC2
+    //VRC2a
     markup.append("  board type=KONAMI-VRC-2\n");
     markup.append("  chip type=VRC2\n");
-    markup.append("    pinout a0=0 a1=1\n");
+    markup.append("    pinout a0=1 a1=0\n");
     break;
 
   case  24:
-    markup.append("  board type=KONAMI-VRC-6\n");
-    markup.append("  chip type=VRC6\n");
-    break;
-
   case  26:
     markup.append("  board type=KONAMI-VRC-6\n");
     markup.append("  chip type=VRC6\n");
-    prgram = 8192;
+    switch(mapper) {
+    case 24: markup.append("    pinout a0=0 a1=1\n"); break;
+    case 26: markup.append("    pinout a0=1 a1=0\n"); break;
+    }
+    if(!nes2 && !prgram) prgram = 8192;
     break;
 
   case  34:
@@ -137,14 +238,14 @@ FamicomCartridge::FamicomCartridge(const uint8_t *data, unsigned size) {
   case  69:
     markup.append("  board type=SUNSOFT-5B\n");
     markup.append("  chip type=5B\n");
-    prgram = 8192;
+    if(!nes2 && !prgram) prgram = 8192;
     break;
 
   case  73:
     markup.append("  board type=KONAMI-VRC-3\n");
     markup.append("  chip type=VRC3\n");
     markup.append("  mirror mode=", mirror == 0 ? "horizontal" : "vertical", "\n");
-    prgram = 8192;
+    if(!nes2 && !prgram) prgram = 8192;
     break;
 
   case  75:
@@ -155,13 +256,35 @@ FamicomCartridge::FamicomCartridge(const uint8_t *data, unsigned size) {
   case  85:
     markup.append("  board type=KONAMI-VRC-7\n");
     markup.append("  chip type=VRC7\n");
-    prgram = 8192;
+    if(!nes2 && !prgram) prgram = 8192;
+    break;
+
+  case  76:
+  case  88:
+  case  95:
+  case 154:
+  case 206:
+    switch(mapper) {
+    case  76: markup.append("  board type=NAMCOT-3446\n"); break;
+    case  88: markup.append("  board type=NAMCOT-3443\n"); break;
+    case  95: markup.append("  board type=NAMCOT-3425\n"); break;
+    case 154: markup.append("  board type=NAMCOT-3453\n"); break;
+    case 206: markup.append("  board type=NAMCOT-3401\n"); break;
+    // Normally 3416, but バベルの塔 (Babel no Tou) uses bankswitching despite
+    // fitting entirely in the memory map, and other 32KB programs are not
+    // broken by having it enabled.
+    }
+    markup.append("  chip type=Namcot108\n");
+    markup.append("  mirror mode=", mirror == 0 ? "horizontal" : "vertical", "\n");
     break;
   }
 
   markup.append("  prg\n");
   if(prgrom) markup.append("    rom name=program.rom size=0x", hex(prgrom), "\n");
-  if(prgram) markup.append("    ram name=save.ram size=0x", hex(prgram), "\n");
+  if(prgram) {
+    if(battery) markup.append("    ram name=save.ram size=0x", hex(prgram), "\n");
+    else        markup.append("    ram size=0x", hex(prgram), "\n");
+  }
 
   markup.append("  chr\n");
   if(chrrom) markup.append("    rom name=character.rom size=0x", hex(chrrom), "\n");
diff --git a/../../../git/Emulator/bsnes/bsnes/data/higan.desktop b/nSide_v005-source-revised/data/higan.desktop
index 70a2242..a71bfb3 100644
--- a/../../../git/Emulator/bsnes/bsnes/data/higan.desktop
+++ b/nSide_v005-source-revised/data/higan.desktop
@@ -1,6 +1,6 @@
 [Desktop Entry]
 Name=higan
-Comment=SNES emulator
+Comment=NES, SNES, Game Boy, Game Boy Advance emulator
 Exec=higan
 Icon=higan
 Terminal=false
diff --git a/../../../git/Emulator/bsnes/bsnes/emulator/interface.hpp b/nSide_v005-source-revised/emulator/interface.hpp
index b46fdfe..26ad890 100644
--- a/../../../git/Emulator/bsnes/bsnes/emulator/interface.hpp
+++ b/nSide_v005-source-revised/emulator/interface.hpp
@@ -111,6 +111,10 @@ struct Interface {
   //utility functions
   enum class PaletteMode : unsigned { Literal, Channel, Standard, Emulation };
   virtual void paletteUpdate(PaletteMode mode) {}
+
+  //debugger functions
+  virtual bool tracerEnable(bool) { return false; }
+  virtual void exportMemory() {}
 };
 
 }
diff --git a/../../../git/Emulator/bsnes/bsnes/fc/Makefile b/nSide_v005-source-revised/fc/Makefile
index ce5bad5..6220e5e 100644
--- a/../../../git/Emulator/bsnes/bsnes/fc/Makefile
+++ b/nSide_v005-source-revised/fc/Makefile
@@ -1,16 +1,14 @@
-fc_objects := fc-interface fc-system fc-scheduler fc-input
-fc_objects += fc-memory fc-cartridge fc-cpu fc-apu fc-ppu
-fc_objects += fc-cheat fc-video
+fc_objects := fc-interface fc-system fc-controller
+fc_objects += fc-cartridge fc-cheat
+fc_objects += fc-memory fc-cpu fc-apu fc-ppu
 objects += $(fc_objects)
 
 obj/fc-interface.o: $(fc)/interface/interface.cpp $(call rwildcard,$(fc)/interface/)
 obj/fc-system.o: $(fc)/system/system.cpp $(call rwildcard,$(fc)/system/)
-obj/fc-scheduler.o: $(fc)/scheduler/scheduler.cpp $(call rwildcard,$(fc)/scheduler/)
-obj/fc-input.o: $(fc)/input/input.cpp $(call rwildcard,$(fc)/input/)
-obj/fc-memory.o: $(fc)/memory/memory.cpp $(call rwildcard,$(fc)/memory/)
+obj/fc-controller.o: $(fc)/controller/controller.cpp $(call rwildcard,$(fc)/controller/)
 obj/fc-cartridge.o: $(fc)/cartridge/cartridge.cpp $(call rwildcard,$(fc)/cartridge/)
+obj/fc-cheat.o: $(fc)/cheat/cheat.cpp $(call rwildcard,$(fc)/cheat/)
+obj/fc-memory.o: $(fc)/memory/memory.cpp $(call rwildcard,$(fc)/memory/)
 obj/fc-cpu.o: $(fc)/cpu/cpu.cpp $(call rwildcard,$(fc)/cpu/)
 obj/fc-apu.o: $(fc)/apu/apu.cpp $(call rwildcard,$(fc)/apu/)
 obj/fc-ppu.o: $(fc)/ppu/ppu.cpp $(call rwildcard,$(fc)/ppu/)
-obj/fc-cheat.o: $(fc)/cheat/cheat.cpp $(call rwildcard,$(fc)/cheat/)
-obj/fc-video.o: $(fc)/video/video.cpp $(call rwildcard,$(fc)/video/)
diff --git a/../../../git/Emulator/bsnes/bsnes/fc/apu/apu.cpp b/nSide_v005-source-revised/fc/apu/apu.cpp
index 9c38b39..86d560a 100644
--- a/../../../git/Emulator/bsnes/bsnes/fc/apu/apu.cpp
+++ b/nSide_v005-source-revised/fc/apu/apu.cpp
@@ -67,7 +67,7 @@ void APU::main() {
 }
 
 void APU::tick() {
-  clock += 12;
+  clock += (system.region == System::Region::NTSC ? 12 : 16);
   if(clock >= 0 && scheduler.sync != Scheduler::SynchronizeMode::All) co_switch(cpu.thread);
 }
 
@@ -92,7 +92,7 @@ void APU::power() {
 }
 
 void APU::reset() {
-  create(APU::Main, 21477272);
+  create(APU::Main, system.cpu_frequency);
 
   pulse[0].reset();
   pulse[1].reset();
@@ -249,7 +249,10 @@ void APU::write(uint16 addr, uint8 data) {
       frame.irq_pending = false;
       set_irq_line();
     }
-    frame.divider = FrameCounter::NtscPeriod;
+    if(system.region == System::Region::NTSC)
+      frame.divider = FrameCounter::NtscPeriod;
+    else
+      frame.divider = FrameCounter::PalPeriod;
     break;
   }
 }
@@ -287,7 +290,12 @@ void APU::clock_frame_counter() {
   noise.envelope.clock();
 
   if(frame.counter == 0) {
-    if(frame.mode & 2) frame.divider += FrameCounter::NtscPeriod;
+    if(frame.mode & 2) {
+      if(system.region == System::Region::NTSC)
+        frame.divider += FrameCounter::NtscPeriod;
+      else
+        frame.divider += FrameCounter::PalPeriod;
+    }
     if(frame.mode == 0) {
       frame.irq_pending = true;
       set_irq_line();
@@ -299,7 +307,10 @@ void APU::clock_frame_counter_divider() {
   frame.divider -= 2;
   if(frame.divider <= 0) {
     clock_frame_counter();
-    frame.divider += FrameCounter::NtscPeriod;
+    if(system.region == System::Region::NTSC)
+      frame.divider += FrameCounter::NtscPeriod;
+    else
+      frame.divider += FrameCounter::PalPeriod;
   }
 }
 
diff --git a/../../../git/Emulator/bsnes/bsnes/fc/apu/apu.hpp b/nSide_v005-source-revised/fc/apu/apu.hpp
index a0ea128..1dad293 100644
--- a/../../../git/Emulator/bsnes/bsnes/fc/apu/apu.hpp
+++ b/nSide_v005-source-revised/fc/apu/apu.hpp
@@ -35,7 +35,10 @@ struct APU : Thread {
   #include "dmc.hpp"
 
   struct FrameCounter {
-    enum : unsigned { NtscPeriod = 14915 };  //~(21.477MHz / 6 / 240hz)
+    enum : unsigned {
+      NtscPeriod = 14915,  //~(21.477MHz / 6 / 240hz)
+      PalPeriod = 18473, // conjectural
+    };
 
     bool irq_pending;
 
diff --git a/../../../git/Emulator/bsnes/bsnes/fc/apu/dmc.cpp b/nSide_v005-source-revised/fc/apu/dmc.cpp
index ffe221f..8e7538b 100644
--- a/../../../git/Emulator/bsnes/bsnes/fc/apu/dmc.cpp
+++ b/nSide_v005-source-revised/fc/apu/dmc.cpp
@@ -57,7 +57,10 @@ uint8 APU::DMC::clock() {
       }
     }
 
-    period_counter = ntsc_dmc_period_table[period];
+    if(system.region == System::Region::NTSC)
+      period_counter = ntsc_dmc_period_table[period];
+    else
+      period_counter = pal_dmc_period_table[period];
   }
 
   if(length_counter > 0 && have_dma_buffer == false && dma_delay_counter == 0) {
diff --git a/../../../git/Emulator/bsnes/bsnes/fc/apu/noise.cpp b/nSide_v005-source-revised/fc/apu/noise.cpp
index 65eee58..193f3cc 100644
--- a/../../../git/Emulator/bsnes/bsnes/fc/apu/noise.cpp
+++ b/nSide_v005-source-revised/fc/apu/noise.cpp
@@ -19,7 +19,10 @@ uint8 APU::Noise::clock() {
     }
 
     lfsr = (lfsr >> 1) | (feedback << 14);
-    period_counter = apu.ntsc_noise_period_table[period];
+    if(system.region == System::Region::NTSC)
+      period_counter = apu.ntsc_noise_period_table[period];
+    else
+      period_counter = apu.pal_noise_period_table[period];
   }
 
   return result;
diff --git a/../../../git/Emulator/bsnes/bsnes/fc/cartridge/board/bandai-fcg.cpp b/nSide_v005-source-revised/fc/cartridge/board/bandai-fcg.cpp
index a23ad2a..77be3e0 100644
--- a/../../../git/Emulator/bsnes/bsnes/fc/cartridge/board/bandai-fcg.cpp
+++ b/nSide_v005-source-revised/fc/cartridge/board/bandai-fcg.cpp
@@ -1,117 +1,105 @@
 //BANDAI-FCG
+//BANDAI-FCG-1
+//BANDAI-FCG-2
+//BANDAI-JUMP2
+//BANDAI-LZ93D50
 
 struct BandaiFCG : Board {
 
-uint8 chr_bank[8];
-uint8 prg_bank;
-uint2 mirror;
-bool irq_counter_enable;
-uint16 irq_counter;
-uint16 irq_latch;
+enum class Revision : unsigned {
+  FCGAll,
+  FCG1,
+  FCG2,
+  JUMP2,
+  LZ93D50,
+} revision;
 
-void main() {
-  while(true) {
-    if(scheduler.sync == Scheduler::SynchronizeMode::All) {
-      scheduler.exit(Scheduler::ExitReason::SynchronizeEvent);
-    }
+FCG fcg;
 
-    if(irq_counter_enable) {
-      if(--irq_counter == 0xffff) {
-        cpu.set_irq_line(1);
-        irq_counter_enable = false;
-      }
-    }
-
-    tick();
-  }
-}
+uint2 last_chr_bank;
 
-unsigned ciram_addr(unsigned addr) const {
-  switch(mirror) {
-  case 0: return ((addr & 0x0400) >> 0) | (addr & 0x03ff);
-  case 1: return ((addr & 0x0800) >> 1) | (addr & 0x03ff);
-  case 2: return 0x0000 | (addr & 0x03ff);
-  case 3: return 0x0400 | (addr & 0x03ff);
-  }
+void main() {
+  fcg.main();
 }
 
 uint8 prg_read(unsigned addr) {
-  if(addr & 0x8000) {
-    bool region = addr & 0x4000;
-    unsigned bank = (region == 0 ? prg_bank : 0x0f);
-    return prgrom.read((bank << 14) | (addr & 0x3fff));
+  if((addr & 0xe000) == 0x6000) {
+    switch(revision) {
+    case Revision::LZ93D50:
+      //TODO: serial EEPROM support
+      return 0x00 | (cpu.mdr() & 0xef);
+    case Revision::JUMP2:
+      return fcg.eeprom_i2c_scl ? fcg.ram_read(addr) : cpu.mdr();
+    }
+  }
+  if((addr & 0x8000) == 0x8000) {
+    if(revision != Revision::JUMP2)
+      return prgrom.read(fcg.prg_addr(addr));
+    else
+      return prgrom.read(fcg.prg_addr(addr) | ((fcg.chr_bank[last_chr_bank] & 1) << 18));
   }
   return cpu.mdr();
 }
 
 void prg_write(unsigned addr, uint8 data) {
-  if(addr >= 0x6000) {
-    switch(addr & 15) {
-    case 0x00: case 0x01: case 0x02: case 0x03:
-    case 0x04: case 0x05: case 0x06: case 0x07:
-      chr_bank[addr & 7] = data;
-      break;
-    case 0x08:
-      prg_bank = data & 0x0f;
-      break;
-    case 0x09:
-      mirror = data & 0x03;
-      break;
-    case 0x0a:
-      cpu.set_irq_line(0);
-      irq_counter_enable = data & 0x01;
-      irq_counter = irq_latch;
-      break;
-    case 0x0b:
-      irq_latch = (irq_latch & 0xff00) | (data << 0);
-      break;
-    case 0x0c:
-      irq_latch = (irq_latch & 0x00ff) | (data << 8);
-      break;
-    case 0x0d:
+  if((addr & 0xe000) == 0x6000) {
+    switch(revision) {
+    case Revision::FCGAll:
+    case Revision::FCG1:
+    case Revision::FCG2:
+      return fcg.reg_write(addr, data);
+    case Revision::LZ93D50:
       //TODO: serial EEPROM support
       break;
+    case Revision::JUMP2:
+      if(fcg.eeprom_i2c_scl) return fcg.ram_write(addr, data);
+      else                   break;
+    }
+  }
+  if((addr & 0x8000) == 0x8000) {
+    switch(revision) {
+    case Revision::FCGAll:
+    case Revision::LZ93D50:
+    case Revision::JUMP2:
+      return fcg.reg_write(addr, data);
     }
   }
 }
 
 uint8 chr_read(unsigned addr) {
-  if(addr & 0x2000) return ppu.ciram_read(ciram_addr(addr));
-  addr = (chr_bank[addr >> 10] << 10) | (addr & 0x03ff);
-  return Board::chr_read(addr);
+  if(addr & 0x2000) return ppu.ciram_read(fcg.ciram_addr(addr));
+  last_chr_bank = 0;(addr & 0x0c00) >> 10;
+  if(chrrom.size) return Board::chr_read(fcg.chr_addr(addr));
+  if(chrram.size) return Board::chr_read(addr);
 }
 
 void chr_write(unsigned addr, uint8 data) {
-  if(addr & 0x2000) return ppu.ciram_write(ciram_addr(addr), data);
-  addr = (chr_bank[addr >> 10] << 10) | (addr & 0x03ff);
-  return Board::chr_write(addr, data);
+  if(addr & 0x2000) return ppu.ciram_write(fcg.ciram_addr(addr), data);
+  last_chr_bank = 0;(addr & 0x0c00) >> 10;
+  if(chrram.size) Board::chr_write(addr, data);
 }
 
 void power() {
-  reset();
+  fcg.power();
 }
 
 void reset() {
-  for(auto &n : chr_bank) n = 0;
-  prg_bank = 0;
-  mirror = 0;
-  irq_counter_enable = 0;
-  irq_counter = 0;
-  irq_latch = 0;
+  fcg.reset();
 }
 
 void serialize(serializer& s) {
   Board::serialize(s);
-
-  s.array(chr_bank);
-  s.integer(prg_bank);
-  s.integer(mirror);
-  s.integer(irq_counter_enable);
-  s.integer(irq_counter);
-  s.integer(irq_latch);
+  fcg.serialize(s);
+  s.integer(last_chr_bank);
 }
 
-BandaiFCG(Markup::Node& document) : Board(document) {
+BandaiFCG(Markup::Node& document) : Board(document), fcg(*this, document) {
+  string type = document["cartridge/board/type"].data;
+  revision = Revision::FCGAll;
+  if(type.match("*FCG-1*"  )) revision = Revision::FCG1;
+  if(type.match("*FCG-2*"  )) revision = Revision::FCG2;
+  if(type.match("*JUMP2*"  )) revision = Revision::JUMP2;
+  if(type.match("*LZ93D50*")) revision = Revision::LZ93D50;
 }
 
 };
diff --git a/../../../git/Emulator/bsnes/bsnes/fc/cartridge/board/board.cpp b/nSide_v005-source-revised/fc/cartridge/board/board.cpp
index 383ebc8..afae16d 100644
--- a/../../../git/Emulator/bsnes/bsnes/fc/cartridge/board/board.cpp
+++ b/nSide_v005-source-revised/fc/cartridge/board/board.cpp
@@ -5,9 +5,11 @@
 #include "konami-vrc4.cpp"
 #include "konami-vrc6.cpp"
 #include "konami-vrc7.cpp"
+#include "namco-163.cpp"
+#include "namco-34xx.cpp"
 #include "nes-axrom.cpp"
 #include "nes-bnrom.cpp"
-#include "nes-cnrom.cpp"
+#include "nes-cxrom.cpp"
 #include "nes-exrom.cpp"
 #include "nes-fxrom.cpp"
 #include "nes-gxrom.cpp"
@@ -17,7 +19,18 @@
 #include "nes-sxrom.cpp"
 #include "nes-txrom.cpp"
 #include "nes-uxrom.cpp"
+#include "sunsoft-4.cpp"
 #include "sunsoft-5b.cpp"
+#include "fds.cpp"
+#include "vs.cpp"
+
+// Unlicensed board definitions; feel free to remove
+#include "unlicensed/camerica.cpp"
+#include "unlicensed/colordreams-74377.cpp"
+#include "unlicensed/mlt-action52.cpp"
+#include "unlicensed/nina.cpp"
+#include "unlicensed/noconflicts-cnrom.cpp"
+#include "unlicensed/single-chip.cpp"
 
 uint8 Board::Memory::read(unsigned addr) const {
   return data[mirror(addr, size)];
@@ -51,13 +64,13 @@ void Board::main() {
       scheduler.exit(Scheduler::ExitReason::SynchronizeEvent);
     }
 
-    cartridge.clock += 12 * 4095;
+    cartridge.clock += (system.region == System::Region::NTSC ? 12 : 16) * 4095;
     tick();
   }
 }
 
 void Board::tick() {
-  cartridge.clock += 12;
+  cartridge.clock += (system.region == System::Region::NTSC ? 12 : 16);
   if(cartridge.clock >= 0 && scheduler.sync != Scheduler::SynchronizeMode::All) co_switch(cpu.thread);
 }
 
@@ -122,91 +135,184 @@ Board::~Board() {
 Board* Board::load(string manifest) {
   auto document = Markup::Document(manifest);
   cartridge.information.title = document["information/title"].text();
+  cartridge.region = document["cartridge/region"].data != "PAL" ? Cartridge::Region::NTSC : Cartridge::Region::PAL;
 
   string type = document["cartridge/board/type"].text();
 
-  if(type == "BANDAI-FCG"  ) return new BandaiFCG(document);
-
-  if(type == "KONAMI-VRC-1") return new KonamiVRC1(document);
-  if(type == "KONAMI-VRC-2") return new KonamiVRC2(document);
-  if(type == "KONAMI-VRC-3") return new KonamiVRC3(document);
-  if(type == "KONAMI-VRC-4") return new KonamiVRC4(document);
-  if(type == "KONAMI-VRC-6") return new KonamiVRC6(document);
-  if(type == "KONAMI-VRC-7") return new KonamiVRC7(document);
-
-  if(type == "NES-AMROM"   ) return new NES_AxROM(document);
-  if(type == "NES-ANROM"   ) return new NES_AxROM(document);
-  if(type == "NES-AN1ROM"  ) return new NES_AxROM(document);
-  if(type == "NES-AOROM"   ) return new NES_AxROM(document);
-
-  if(type == "NES-BNROM"   ) return new NES_BNROM(document);
-
-  if(type == "NES-CNROM"   ) return new NES_CNROM(document);
-
-  if(type == "NES-EKROM"   ) return new NES_ExROM(document);
-  if(type == "NES-ELROM"   ) return new NES_ExROM(document);
-  if(type == "NES-ETROM"   ) return new NES_ExROM(document);
-  if(type == "NES-EWROM"   ) return new NES_ExROM(document);
-
-  if(type == "NES-FJROM"   ) return new NES_FxROM(document);
-  if(type == "NES-FKROM"   ) return new NES_FxROM(document);
-
-  if(type == "NES-GNROM"   ) return new NES_GxROM(document);
-  if(type == "NES-MHROM"   ) return new NES_GxROM(document);
-
-  if(type == "NES-HKROM"   ) return new NES_HKROM(document);
-
-  if(type == "NES-NROM"    ) return new NES_NROM(document);
-  if(type == "NES-NROM-128") return new NES_NROM(document);
-  if(type == "NES-NROM-256") return new NES_NROM(document);
-
-  if(type == "NES-PEEOROM" ) return new NES_PxROM(document);
-  if(type == "NES-PNROM"   ) return new NES_PxROM(document);
-
-  if(type == "NES-SAROM"   ) return new NES_SxROM(document);
-  if(type == "NES-SBROM"   ) return new NES_SxROM(document);
-  if(type == "NES-SCROM"   ) return new NES_SxROM(document);
-  if(type == "NES-SC1ROM"  ) return new NES_SxROM(document);
-  if(type == "NES-SEROM"   ) return new NES_SxROM(document);
-  if(type == "NES-SFROM"   ) return new NES_SxROM(document);
-  if(type == "NES-SFEXPROM") return new NES_SxROM(document);
-  if(type == "NES-SGROM"   ) return new NES_SxROM(document);
-  if(type == "NES-SHROM"   ) return new NES_SxROM(document);
-  if(type == "NES-SH1ROM"  ) return new NES_SxROM(document);
-  if(type == "NES-SIROM"   ) return new NES_SxROM(document);
-  if(type == "NES-SJROM"   ) return new NES_SxROM(document);
-  if(type == "NES-SKROM"   ) return new NES_SxROM(document);
-  if(type == "NES-SLROM"   ) return new NES_SxROM(document);
-  if(type == "NES-SL1ROM"  ) return new NES_SxROM(document);
-  if(type == "NES-SL2ROM"  ) return new NES_SxROM(document);
-  if(type == "NES-SL3ROM"  ) return new NES_SxROM(document);
-  if(type == "NES-SLRROM"  ) return new NES_SxROM(document);
-  if(type == "NES-SMROM"   ) return new NES_SxROM(document);
-  if(type == "NES-SNROM"   ) return new NES_SxROM(document);
-  if(type == "NES-SOROM"   ) return new NES_SxROM(document);
-  if(type == "NES-SUROM"   ) return new NES_SxROM(document);
-  if(type == "NES-SXROM"   ) return new NES_SxROM(document);
-
-  if(type == "NES-TBROM"   ) return new NES_TxROM(document);
-  if(type == "NES-TEROM"   ) return new NES_TxROM(document);
-  if(type == "NES-TFROM"   ) return new NES_TxROM(document);
-  if(type == "NES-TGROM"   ) return new NES_TxROM(document);
-  if(type == "NES-TKROM"   ) return new NES_TxROM(document);
-  if(type == "NES-TKSROM"  ) return new NES_TxROM(document);
-  if(type == "NES-TLROM"   ) return new NES_TxROM(document);
-  if(type == "NES-TL1ROM"  ) return new NES_TxROM(document);
-  if(type == "NES-TL2ROM"  ) return new NES_TxROM(document);
-  if(type == "NES-TLSROM"  ) return new NES_TxROM(document);
-  if(type == "NES-TNROM"   ) return new NES_TxROM(document);
-  if(type == "NES-TQROM"   ) return new NES_TxROM(document);
-  if(type == "NES-TR1ROM"  ) return new NES_TxROM(document);
-  if(type == "NES-TSROM"   ) return new NES_TxROM(document);
-  if(type == "NES-TVROM"   ) return new NES_TxROM(document);
-
-  if(type == "NES-UNROM"   ) return new NES_UxROM(document);
-  if(type == "NES-UOROM"   ) return new NES_UxROM(document);
-
-  if(type == "SUNSOFT-5B"  ) return new Sunsoft5B(document);
+  if(substr(type,0,4) == "HVC-" || substr(type,0,4) == "NES-") {
+    type = substr(type,4);
+    if(type == "AMROM"   ) return new NES_AxROM(document);
+    if(type == "ANROM"   ) return new NES_AxROM(document);
+    if(type == "AN1ROM"  ) return new NES_AxROM(document);
+    if(type == "AOROM"   ) return new NES_AxROM(document);
+
+    if(type == "BNROM"   ) return new NES_BNROM(document);
+
+    if(type == "BTR"     ) return new Sunsoft5B(document);
+
+    if(type == "CNROM"   ) return new NES_CxROM(document);
+    if(type == "CPROM"   ) return new NES_CxROM(document);
+
+    if(type == "DEROM"   ) return new Namco34xx(document);
+    if(type == "DE1ROM"  ) return new Namco34xx(document);
+    if(type == "DRROM"   ) return new Namco34xx(document);
+
+    if(type == "EKROM"   ) return new NES_ExROM(document);
+    if(type == "ELROM"   ) return new NES_ExROM(document);
+    if(type == "ETROM"   ) return new NES_ExROM(document);
+    if(type == "EWROM"   ) return new NES_ExROM(document);
+
+    if(type == "FJROM"   ) return new NES_FxROM(document);
+    if(type == "FKROM"   ) return new NES_FxROM(document);
+
+    if(type == "GNROM"   ) return new NES_GxROM(document);
+    if(type == "MHROM"   ) return new NES_GxROM(document);
+
+    if(type == "HKROM"   ) return new NES_HKROM(document);
+
+    if(type == "JLROM"   ) return new Sunsoft5B(document);
+    if(type == "JSROM"   ) return new Sunsoft5B(document);
+
+    if(type == "NROM"    ) return new NES_NROM(document);
+    if(type == "NROM-128") return new NES_NROM(document);
+    if(type == "NROM-256") return new NES_NROM(document);
+    if(type == "HROM"    ) return new NES_NROM(document);
+    if(type == "RROM"    ) return new NES_NROM(document);
+    if(type == "RROM-128") return new NES_NROM(document);
+    if(type == "RTROM"   ) return new NES_NROM(document);
+    if(type == "SROM"    ) return new NES_NROM(document);
+    if(type == "STROM"   ) return new NES_NROM(document);
+
+    if(type == "PEEOROM" ) return new NES_PxROM(document);
+    if(type == "PNROM"   ) return new NES_PxROM(document);
+
+    if(type == "SAROM"   ) return new NES_SxROM(document);
+    if(type == "SBROM"   ) return new NES_SxROM(document);
+    if(type == "SCROM"   ) return new NES_SxROM(document);
+    if(type == "SC1ROM"  ) return new NES_SxROM(document);
+    if(type == "SEROM"   ) return new NES_SxROM(document);
+    if(type == "SFROM"   ) return new NES_SxROM(document);
+    if(type == "SFEXPROM") return new NES_SxROM(document);
+    if(type == "SGROM"   ) return new NES_SxROM(document);
+    if(type == "SHROM"   ) return new NES_SxROM(document);
+    if(type == "SH1ROM"  ) return new NES_SxROM(document);
+    if(type == "SIROM"   ) return new NES_SxROM(document);
+    if(type == "SJROM"   ) return new NES_SxROM(document);
+    if(type == "SKROM"   ) return new NES_SxROM(document);
+    if(type == "SLROM"   ) return new NES_SxROM(document);
+    if(type == "SL1ROM"  ) return new NES_SxROM(document);
+    if(type == "SL2ROM"  ) return new NES_SxROM(document);
+    if(type == "SL3ROM"  ) return new NES_SxROM(document);
+    if(type == "SLRROM"  ) return new NES_SxROM(document);
+    if(type == "SMROM"   ) return new NES_SxROM(document);
+    if(type == "SNROM"   ) return new NES_SxROM(document);
+    if(type == "SNWEPROM") return new NES_SxROM(document);
+    if(type == "SOROM"   ) return new NES_SxROM(document);
+    if(type == "SUROM"   ) return new NES_SxROM(document);
+    if(type == "SXROM"   ) return new NES_SxROM(document);
+
+    if(type == "TBROM"   ) return new NES_TxROM(document);
+    if(type == "TEROM"   ) return new NES_TxROM(document);
+    if(type == "TFROM"   ) return new NES_TxROM(document);
+    if(type == "TGROM"   ) return new NES_TxROM(document);
+    if(type == "TKROM"   ) return new NES_TxROM(document);
+    if(type == "TKSROM"  ) return new NES_TxROM(document);
+    if(type == "TLROM"   ) return new NES_TxROM(document);
+    if(type == "TL1ROM"  ) return new NES_TxROM(document);
+    if(type == "TL2ROM"  ) return new NES_TxROM(document);
+    if(type == "TLSROM"  ) return new NES_TxROM(document);
+    if(type == "TNROM"   ) return new NES_TxROM(document);
+    if(type == "TQROM"   ) return new NES_TxROM(document);
+    if(type == "TR1ROM"  ) return new NES_TxROM(document);
+    if(type == "TSROM"   ) return new NES_TxROM(document);
+    if(type == "TVROM"   ) return new NES_TxROM(document);
+
+    if(type == "UNROM"   ) return new NES_UxROM(document);
+    if(type == "UOROM"   ) return new NES_UxROM(document);
+  }
+
+  if(type == "ACCLAIM-MC-ACC") return new NES_TxROM(document);
+
+  if(type == "AVE-NINA-01") return new Nina(document);
+  if(type == "AVE-NINA-02") return new Nina(document);
+  if(type == "AVE-NINA-03") return new Nina(document);
+  if(type == "AVE-NINA-06") return new Nina(document);
+
+  if(type == "BANDAI-74*161/32") return new NES_CxROM(document);
+  if(type == "BANDAI-CNROM"    ) return new NES_CxROM(document);
+  if(type == "BANDAI-FCG"      ) return new BandaiFCG(document);
+  if(type == "BANDAI-FCG-1"    ) return new BandaiFCG(document);
+  if(type == "BANDAI-FCG-2"    ) return new BandaiFCG(document);
+  if(type == "BANDAI-GNROM"    ) return new NES_GxROM(document);
+  if(type == "BANDAI-JUMP2"    ) return new BandaiFCG(document);
+  if(type == "BANDAI-LZ93D50"  ) return new BandaiFCG(document);
+  if(type == "BANDAI-NROM-128" ) return new NES_NROM(document);
+  if(type == "BANDAI-NROM-256" ) return new NES_NROM(document);
+  if(type == "BANDAI-PT-544"   ) return new NES_CxROM(document);
+
+  if(type == "IREM-BNROM"   ) return new NES_BNROM(document);
+  if(type == "IREM-FCG-1"   ) return new BandaiFCG(document);
+  if(type == "IREM-NROM-128") return new NES_NROM(document);
+  if(type == "IREM-NROM-256") return new NES_NROM(document);
+  if(type == "IREM-UNROM"   ) return new NES_UxROM(document);
+  //TODO:
+  //IREM-G101 (iNES 032)
+  //IREM-H3001 (iNES 065)
+  //IREM-74*161/161/21/138 (iNES 077)
+  //IREM-HOLYDIVER (iNES 078)
+  //IREM-TAM-S1 (iNES 097)
+
+  if(type == "KONAMI-CNROM"   ) return new NES_CxROM(document);
+  if(type == "KONAMI-NROM-128") return new NES_NROM(document);
+  if(type == "KONAMI-SLROM"   ) return new NES_SxROM(document);
+  if(type == "KONAMI-TLROM"   ) return new NES_TxROM(document);
+  if(type == "KONAMI-UNROM"   ) return new NES_UxROM(document);
+  if(type == "KONAMI-VRC-1"   ) return new KonamiVRC1(document);
+  if(type == "KONAMI-VRC-2"   ) return new KonamiVRC2(document);
+  if(type == "KONAMI-VRC-3"   ) return new KonamiVRC3(document);
+  if(type == "KONAMI-VRC-4"   ) return new KonamiVRC4(document);
+  if(type == "KONAMI-VRC-6"   ) return new KonamiVRC6(document);
+  if(type == "KONAMI-VRC-7"   ) return new KonamiVRC7(document);
+
+  if(type == "NAMCOT-163" ) return new Namco163(document);
+  if(type == "NAMCOT-3301") return new NES_NROM(document);
+  if(type == "NAMCOT-3302") return new NES_NROM(document);
+  if(type == "NAMCOT-3305") return new NES_NROM(document);
+  if(type == "NAMCOT-3311") return new NES_NROM(document);
+  if(type == "NAMCOT-3312") return new NES_NROM(document);
+  if(type == "NAMCOT-3401") return new Namco34xx(document);
+  if(type == "NAMCOT-3406") return new Namco34xx(document);
+  if(type == "NAMCOT-3407") return new Namco34xx(document);
+  if(type == "NAMCOT-3416") return new Namco34xx(document);
+  if(type == "NAMCOT-3417") return new Namco34xx(document);
+  if(type == "NAMCOT-3443") return new Namco34xx(document);
+  if(type == "NAMCOT-3446") return new Namco34xx(document);
+  if(type == "NAMCOT-3453") return new Namco34xx(document);
+
+  if(type == "SUNSOFT-4" ) return new Sunsoft4(document);
+  if(type == "SUNSOFT-5B") return new Sunsoft5B(document);
+
+  if(type == "FDS") return new FDS(document);
+  if(type == "VS" ) return new VS(document);
+
+  // Unlicensed boards below; feel free to remove
+  if(type == "CAMERICA-ALGN"     ) return new Camerica(document);
+  if(type == "CAMERICA-ALGQ"     ) return new Camerica(document);
+  if(type == "CAMERICA-BF9093"   ) return new Camerica(document);
+  if(type == "CAMERICA-BF9096"   ) return new Camerica(document);
+  if(type == "CAMERICA-BF9097"   ) return new Camerica(document);
+  if(type == "CODEMASTERS-NR8N"  ) return new Camerica(document);
+  if(type == "COLORDREAMS-74*377") return new ColorDreams74377(document);
+  if(type == "MLT-ACTION52"      ) return new MLT_Action52(document);
+  if(type == "TENGEN-800002"     ) return new Namco34xx(document);
+  if(type == "TENGEN-800003"     ) return new NES_NROM(document);
+  if(type == "TENGEN-800004"     ) return new Namco34xx(document);
+  if(type == "TENGEN-800008"     ) return new NES_CxROM(document);
+  if(type == "TENGEN-800030"     ) return new Namco34xx(document);
+  if(type == "TENGEN-800042"     ) return new Sunsoft4(document);
+  // Homebrew boards; feel free to remove
+  if(type == "NoConflicts-CNROM") return new NoConflicts_CNROM(document);
+  if(type == "SingleChip") return new SingleChip(document);
 
   return nullptr;
 }
diff --git a/nSide_v005-source-revised/fc/cartridge/board/fds.cpp b/nSide_v005-source-revised/fc/cartridge/board/fds.cpp
new file mode 100644
index 0000000..5c8625c
--- /dev/null
+++ b/nSide_v005-source-revised/fc/cartridge/board/fds.cpp
@@ -0,0 +1,67 @@
+struct FDS : Board {
+
+uint16 irq_timer = 0x0000;
+uint8 fds_control = 0x2E;
+bool irq_enable = false;
+uint2 io_enable = 0b00;
+
+uint8 prg_read(unsigned addr) {
+  switch(addr) {
+  case 0x4032:
+    // 0x01: 0=Disk inserted;       1=Disk ejected
+    // 0x02: 0=Disk ready;          1=Disk not ready
+    // 0x04: 0=Not write protected; 1=Write protected (on if disk ejected)
+    return 0x07;
+  case 0x4033: return 0x00; // 7-bit expansion input; 0x80 means low battery
+  }
+  switch(addr & 0xe000) {
+  case 0x6000:
+  case 0x8000:
+  case 0xa000:
+  case 0xc000: return prgram.read(addr);
+  case 0xe000: return prgrom.read(addr);
+  }
+  return cpu.mdr();
+}
+
+void prg_write(unsigned addr, uint8 data) {
+  switch(addr) {
+  case 0x4020: irq_timer &= 0xff00 | data;
+  case 0x4021: irq_timer &= 0x00ff | (data << 8);
+  case 0x4022: irq_enable = data & 0x02;
+  case 0x4023: io_enable = data & 0x03;
+  case 0x4025: fds_control = data;
+  }
+  switch(addr & 0xe000) {
+  case 0x6000:
+  case 0x8000:
+  case 0xa000:
+  case 0xc000: prgram.write(addr,data); break;
+  }
+}
+
+uint8 chr_read(unsigned addr) {
+  if(addr & 0x2000) {
+    if(fds_control & 0x08) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    return ppu.ciram_read(addr & 0x07ff);
+  }
+  if(chrram.size) return chrram.read(addr);
+  return chrrom.read(addr);
+}
+
+void chr_write(unsigned addr, uint8 data) {
+  if(addr & 0x2000) {
+    if(fds_control & 0x08) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    return ppu.ciram_write(addr & 0x07ff, data);
+  }
+  if(chrram.size) return chrram.write(addr, data);
+}
+
+void serialize(serializer& s) {
+  Board::serialize(s);
+}
+
+FDS(Markup::Node& document) : Board(document) {
+}
+
+};
diff --git a/../../../git/Emulator/bsnes/bsnes/fc/cartridge/board/konami-vrc2.cpp b/nSide_v005-source-revised/fc/cartridge/board/konami-vrc2.cpp
index 826ac31..c571d32 100644
--- a/../../../git/Emulator/bsnes/bsnes/fc/cartridge/board/konami-vrc2.cpp
+++ b/nSide_v005-source-revised/fc/cartridge/board/konami-vrc2.cpp
@@ -4,6 +4,7 @@ struct Settings {
   struct Pinout {
     unsigned a0;
     unsigned a1;
+    unsigned chr_shift;
   } pinout;
 } settings;
 
@@ -28,7 +29,9 @@ void prg_write(unsigned addr, uint8 data) {
 
 uint8 chr_read(unsigned addr) {
   if(addr & 0x2000) return ppu.ciram_read(vrc2.ciram_addr(addr));
-  return Board::chr_read(vrc2.chr_addr(addr));
+  addr = vrc2.chr_addr(addr);
+  addr = ((addr >> settings.pinout.chr_shift) & ~0x3ff) | (addr & 0x3ff);
+  return Board::chr_read(addr);
 }
 
 void chr_write(unsigned addr, uint8 data) {
@@ -50,8 +53,9 @@ void serialize(serializer& s) {
 }
 
 KonamiVRC2(Markup::Node& document) : Board(document), vrc2(*this) {
-  settings.pinout.a0 = 1 << decimal(document["cartridge"]["chip"]["pinout"]["a0"].data);
-  settings.pinout.a1 = 1 << decimal(document["cartridge"]["chip"]["pinout"]["a1"].data);
+  settings.pinout.a0 = 1 << decimal(document["cartridge/chip/pinout/a0"].data);
+  settings.pinout.a1 = 1 << decimal(document["cartridge/chip/pinout/a1"].data);
+  settings.pinout.chr_shift = decimal(document["cartridge/chip/pinout/chr-shift"].data);
 }
 
 };
diff --git a/../../../git/Emulator/bsnes/bsnes/fc/cartridge/board/konami-vrc4.cpp b/nSide_v005-source-revised/fc/cartridge/board/konami-vrc4.cpp
index a9988af..d16cc20 100644
--- a/../../../git/Emulator/bsnes/bsnes/fc/cartridge/board/konami-vrc4.cpp
+++ b/nSide_v005-source-revised/fc/cartridge/board/konami-vrc4.cpp
@@ -25,7 +25,7 @@ void prg_write(unsigned addr, uint8 data) {
 
   bool a0 = (addr & settings.pinout.a0);
   bool a1 = (addr & settings.pinout.a1);
-  addr &= 0xfff0;
+  addr &= 0xff00;
   addr |= (a1 << 1) | (a0 << 0);
   return vrc4.reg_write(addr, data);
 }
@@ -54,8 +54,8 @@ void serialize(serializer& s) {
 }
 
 KonamiVRC4(Markup::Node& document) : Board(document), vrc4(*this) {
-  settings.pinout.a0 = 1 << decimal(document["cartridge"]["chip"]["pinout"]["a0"].data);
-  settings.pinout.a1 = 1 << decimal(document["cartridge"]["chip"]["pinout"]["a1"].data);
+  settings.pinout.a0 = 1 << decimal(document["cartridge/chip/pinout/a0"].data);
+  settings.pinout.a1 = 1 << decimal(document["cartridge/chip/pinout/a1"].data);
 }
 
 };
diff --git a/../../../git/Emulator/bsnes/bsnes/fc/cartridge/board/konami-vrc6.cpp b/nSide_v005-source-revised/fc/cartridge/board/konami-vrc6.cpp
index f4e5e95..613808b 100644
--- a/../../../git/Emulator/bsnes/bsnes/fc/cartridge/board/konami-vrc6.cpp
+++ b/nSide_v005-source-revised/fc/cartridge/board/konami-vrc6.cpp
@@ -1,20 +1,29 @@
 struct KonamiVRC6 : Board {
 
+struct Settings {
+  struct Pinout {
+    unsigned a0;
+    unsigned a1;
+  } pinout;
+} settings;
+
 VRC6 vrc6;
 
 uint8 prg_read(unsigned addr) {
-  if((addr & 0xe000) == 0x6000) return vrc6.ram_read(addr);
-  if(addr & 0x8000) return prgrom.read(vrc6.prg_addr(addr));
-  return cpu.mdr();
+  if(addr < 0x6000) return cpu.mdr();
+  if(addr < 0x8000) return vrc6.ram_read(addr);
+  return prgrom.read(vrc6.prg_addr(addr));
 }
 
 void prg_write(unsigned addr, uint8 data) {
-  if((addr & 0xe000) == 0x6000) return vrc6.ram_write(addr, data);
-  if(addr & 0x8000) {
-    addr = (addr & 0xf003);
-    if(prgram.size) addr = (addr & ~3) | ((addr & 2) >> 1) | ((addr & 1) << 1);
-    return vrc6.reg_write(addr, data);
-  }
+  if(addr < 0x6000) return;
+  if(addr < 0x8000) return vrc6.ram_write(addr, data);
+
+  bool a0 = (addr & settings.pinout.a0);
+  bool a1 = (addr & settings.pinout.a1);
+  addr &= 0xf000;
+  addr |= (a1 << 1) | (a0 << 0);
+  return vrc6.reg_write(addr, data);
 }
 
 uint8 chr_read(unsigned addr) {
@@ -37,6 +46,8 @@ void power() { vrc6.power(); }
 void reset() { vrc6.reset(); }
 
 KonamiVRC6(Markup::Node& document) : Board(document), vrc6(*this) {
+  settings.pinout.a0 = 1 << decimal(document["cartridge/chip/pinout/a0"].data);
+  settings.pinout.a1 = 1 << decimal(document["cartridge/chip/pinout/a1"].data);
 }
 
 };
diff --git a/nSide_v005-source-revised/fc/cartridge/board/namco-163.cpp b/nSide_v005-source-revised/fc/cartridge/board/namco-163.cpp
new file mode 100644
index 0000000..5857e44
--- /dev/null
+++ b/nSide_v005-source-revised/fc/cartridge/board/namco-163.cpp
@@ -0,0 +1,133 @@
+struct Namco163 : Board {
+
+uint6 prg_bank[3];
+uint8 chr_bank[12];
+uint15 irq_counter;
+bool irq_enable;
+uint2 mirror;
+uint2 chrram_disable;
+
+uint8 prg_read(unsigned addr) {
+  switch(addr & 0xf800) {
+  case 0x4800: break; // Audio
+  case 0x5000: return irq_counter & 0xff;
+  case 0x5800: return ((irq_counter >> 8) & 0x7f) | (irq_enable << 7);
+  case 0x6000: case 0x6800: case 0x7000: case 0x7800:
+    return prgram.read(addr & 0x1fff);
+  case 0x8000: case 0x8800: case 0x9000: case 0x9800:
+  case 0xa000: case 0xa800: case 0xb000: case 0xb800:
+  case 0xc000: case 0xc800: case 0xd000: case 0xd800:
+    return prgrom.read((prg_bank[(addr & 0x6000) >> 13] << 13) | (addr & 0x1fff));
+  case 0xe000: case 0xe800: case 0xf000: case 0xf800:
+    return prgrom.read((0x3f << 13) | (addr & 0x1fff));
+  default: return cpu.mdr();
+  }
+}
+
+void prg_write(unsigned addr, uint8 data) {
+  switch(addr & 0xf800) {
+  case 0x4800: break; // Audio
+  case 0x5000: // IRQ Low
+    irq_counter = (irq_counter & ~0xff) | data;
+    break;
+  case 0x5800: // IRQ High
+    irq_counter = (irq_counter & 0xff) | ((data & 0x7f) << 8);
+    irq_enable = data & 0x80;
+    break;
+  case 0x6000: case 0x6800: case 0x7000: case 0x7800:
+    prgram.data[addr & 0x1fff] = data;
+    break;
+  case 0x8000: case 0x8800: case 0x9000: case 0x9800: // CHR Select
+  case 0xa000: case 0xa800: case 0xb000: case 0xb800:
+  case 0xc000: case 0xc800: case 0xd000: case 0xd800: // Nametable Select
+    chr_bank[(addr & 0x7800) >> 11] = data;
+    break;
+  case 0xe000: // PRG Select 8000
+    prg_bank[0] = data & 0x3f;
+    mirror = (data & 0xc0) >> 6;
+    break;
+  case 0xe800: // PRG Select A000
+    prg_bank[1] = data & 0x3f;
+    chrram_disable = (data & 0xc0) >> 6;
+    break;
+  case 0xf000: // PRG Select C000
+    prg_bank[2] = data & 0x3f;
+    break;
+  case 0xf800: // Write Protection for External RAM
+    break;
+  }
+}
+
+unsigned ciram_addr(unsigned addr) {
+  bool nt;
+  switch(mirror) {
+  case 0: nt = 0; break;
+  case 1: nt = addr & 0x400; break;
+  case 2: nt = addr & 0x800; break;
+  case 3: nt = 1; break;
+  }
+  return (addr & 0x03ff) | (nt << 10);
+}
+
+uint8 chr_read(unsigned addr) {
+  if(addr & 0x2000) return ppu.ciram_read(ciram_addr(addr));
+  uint8 bank = chr_bank[(addr & 0x1c00) >> 10];
+  if(bank >= 0xe0 && chrram_disable & (1 << ((addr & 0x1000) >> 12))) {
+    if(chrram.size) return chrram.read(addr);
+    else            return ppu.ciram_read(ciram_addr(addr));
+  } else return chrrom.read((bank << 10) | (addr & 0x3ff));
+}
+
+void chr_write(unsigned addr, uint8 data) {
+  if(addr & 0x2000) return ppu.ciram_write(ciram_addr(addr), data);
+  uint8 bank = chr_bank[(addr & 0x1c00) >> 10];
+  if(bank >= 0xe0 && chrram_disable & (1 << ((addr & 0x1000) >> 12))) {
+    if(chrram.size) return chrram.write(addr, data);
+    else            return ppu.ciram_write(ciram_addr(addr), data);
+  }
+}
+
+void serialize(serializer& s) {
+  Board::serialize(s);
+}
+
+void main() {
+  while(true) {
+    if(irq_enable && irq_counter != 0x7fff) {
+      irq_counter++;
+      if(irq_counter == 0x7fff) cpu.set_irq_line(1);
+    }
+
+    tick();
+  }
+}
+
+void power() {
+}
+
+void reset() {
+  prg_bank[0] = 0;
+  prg_bank[1] = 0;
+  prg_bank[2] = 0;
+  chr_bank[0] = 0;
+  chr_bank[1] = 0;
+  chr_bank[2] = 0;
+  chr_bank[3] = 0;
+  chr_bank[4] = 0;
+  chr_bank[5] = 0;
+  chr_bank[6] = 0;
+  chr_bank[7] = 0;
+  chr_bank[8] = 0;
+  chr_bank[9] = 0;
+  chr_bank[10] = 0;
+  chr_bank[11] = 0;
+  irq_counter = 0;
+  irq_enable = false;
+  mirror = 0;
+  chrram_disable = 0;
+}
+
+Namco163(Markup::Node& document) : Board(document) {
+}
+
+};
diff --git a/nSide_v005-source-revised/fc/cartridge/board/namco-34xx.cpp b/nSide_v005-source-revised/fc/cartridge/board/namco-34xx.cpp
new file mode 100644
index 0000000..44590a4
--- /dev/null
+++ b/nSide_v005-source-revised/fc/cartridge/board/namco-34xx.cpp
@@ -0,0 +1,128 @@
+//NAMCOT-3401
+//NAMCOT-3406
+//NAMCOT-3407
+//NAMCOT-3416
+//NAMCOT-3425
+//NAMCOT-3443
+//NAMCOT-3446
+//NAMCOT-3453
+//NES-DEROM
+//NES-DE1ROM
+//NES-DRROM
+
+struct Namco34xx : Board {
+
+enum class Revision : unsigned {
+  Namco3401, // bankswitching used even if PRG is 32KB (バベルの塔/Tower of Babel)
+  Namco3406,
+  Namco3407,
+  Namco3416,
+  Namco3425,
+  Namco3443,
+  Namco3446,
+  Namco3453,
+  DEROM,
+  DE1ROM,
+  DRROM,
+} revision;
+
+struct Settings {
+  bool mirror;  //0 = vertical, 1 = horizontal
+} settings;
+
+Namco108 namco108;
+
+bool nametable; // for Namco3453, used only by Devil Man
+
+unsigned prg_addr(unsigned addr) {
+  if(revision == Revision::Namco3401 || prgrom.size > 0x8000) return namco108.prg_addr(addr);
+  else return addr & 0x7fff;
+}
+
+uint8 prg_read(unsigned addr) {
+  if(addr & 0x8000) return prgrom.read(prg_addr(addr));
+  return cpu.mdr();
+}
+
+void prg_write(unsigned addr, uint8 data) {
+  if(addr & 0x8000) {
+    namco108.reg_write(addr, data);
+    if(revision == Revision::Namco3453) nametable = data & 0x40;
+  }
+}
+
+unsigned chr_addr(unsigned addr) {
+  switch(revision) {
+  case Revision::Namco3443:
+  case Revision::Namco3453:
+    return namco108.chr_addr(addr) | ((addr & 0x1000) << 4);
+  case Revision::Namco3446:
+    if(addr <= 0x07ff) return (namco108.chr_addr(0x1000) << 1) | (addr & 0x07ff);
+    if(addr <= 0x0fff) return (namco108.chr_addr(0x1400) << 1) | (addr & 0x07ff);
+    if(addr <= 0x17ff) return (namco108.chr_addr(0x1800) << 1) | (addr & 0x07ff);
+    if(addr <= 0x1fff) return (namco108.chr_addr(0x1c00) << 1) | (addr & 0x07ff);
+  default:
+    return namco108.chr_addr(addr);
+  }
+}
+
+uint8 chr_read(unsigned addr) {
+  if(revision == Revision::DRROM) {
+    if(addr & 0x2000) return chrram.data[mirror(addr & 0x0FFF, chrram.size)];
+    return chrrom.data[mirror(namco108.chr_addr(addr), chrrom.size)];
+  }
+  if(addr & 0x2000) return ppu.ciram_read(ciram_addr(addr));
+  return Board::chr_read(chr_addr(addr));
+}
+
+void chr_write(unsigned addr, uint8 data) {
+  if(revision == Revision::DRROM) {
+    if(addr & 0x2000) chrram.data[mirror(addr & 0x0FFF, chrram.size)] = data;
+    return;
+  }
+  if(addr & 0x2000) return ppu.ciram_write(ciram_addr(addr), data);
+  return Board::chr_write(chr_addr(addr), data);
+}
+
+unsigned ciram_addr(unsigned addr) const {
+  switch(revision) {
+  case Revision::Namco3425:
+    return ((namco108.chr_addr(addr) & 0x8000) >> 5) | (addr & 0x03ff);
+  case Revision::Namco3453:
+    return (addr & 0x03ff) | (nametable ? 0x0400 : 0x0000);
+  default:
+    if(settings.mirror == 0) return ((addr & 0x0400) >> 0) | (addr & 0x03ff);
+    if(settings.mirror == 1) return ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+  }
+}
+
+void reset() {
+  nametable = 0;
+}
+
+void serialize(serializer& s) {
+  Board::serialize(s);
+}
+
+Namco34xx(Markup::Node& document) : Board(document), namco108(*this, document) {
+  string type = document["cartridge/board/type"].data;
+  if(type.match("*3401*")) revision = Revision::Namco3401;
+  if(type.match("*3406*")) revision = Revision::Namco3406;
+  if(type.match("*3407*")) revision = Revision::Namco3407;
+  if(type.match("*3416*")) revision = Revision::Namco3416;
+  if(type.match("*3425*")) revision = Revision::Namco3425;
+  if(type.match("*3443*")) revision = Revision::Namco3443;
+  if(type.match("*3446*")) revision = Revision::Namco3446;
+  if(type.match("*3453*")) revision = Revision::Namco3453;
+  if(type.match("*DEROM*")) revision = Revision::DEROM;
+  if(type.match("*DE1ROM*")) revision = Revision::DE1ROM;
+  if(type.match("*DRROM*")) revision = Revision::DRROM;
+  if(type.match("*TENGEN-800002*")) revision = Revision::DEROM;
+  if(type.match("*TENGEN-800030*")) revision = Revision::DE1ROM;
+  if(type.match("*TENGEN-800004*")) revision = Revision::DRROM;
+
+  if(revision != Revision::Namco3425 && revision != Revision::Namco3453)
+    settings.mirror = document["cartridge/mirror/mode"].data == "horizontal";
+}
+
+};
diff --git a/../../../git/Emulator/bsnes/bsnes/fc/cartridge/board/nes-axrom.cpp b/nSide_v005-source-revised/fc/cartridge/board/nes-axrom.cpp
index 6d468cf..afb9c51 100644
--- a/../../../git/Emulator/bsnes/bsnes/fc/cartridge/board/nes-axrom.cpp
+++ b/nSide_v005-source-revised/fc/cartridge/board/nes-axrom.cpp
@@ -5,6 +5,13 @@
 
 struct NES_AxROM : Board {
 
+enum class Revision : unsigned {
+  AMROM,
+  ANROM,
+  AN1ROM,
+  AOROM,
+} revision;
+
 uint4 prg_bank;
 bool mirror_select;
 
@@ -15,6 +22,8 @@ uint8 prg_read(unsigned addr) {
 
 void prg_write(unsigned addr, uint8 data) {
   if(addr & 0x8000) {
+    // Bus conflicts
+    if(revision == Revision::AMROM) data &= prg_read(addr);
     prg_bank = data & 0x0f;
     mirror_select = data & 0x10;
   }
@@ -46,6 +55,11 @@ void serialize(serializer& s) {
 }
 
 NES_AxROM(Markup::Node& document) : Board(document) {
+  string type = document["cartridge/board/type"].data;
+  if(type.match("*AMROM*" )) revision = Revision::AMROM;
+  if(type.match("*ANROM*" )) revision = Revision::ANROM;
+  if(type.match("*AN1ROM*")) revision = Revision::AN1ROM;
+  if(type.match("*AOROM*" )) revision = Revision::AOROM;
 }
 
 };
diff --git a/../../../git/Emulator/bsnes/bsnes/fc/cartridge/board/nes-bnrom.cpp b/nSide_v005-source-revised/fc/cartridge/board/nes-bnrom.cpp
index 41723c1..156e0c1 100644
--- a/../../../git/Emulator/bsnes/bsnes/fc/cartridge/board/nes-bnrom.cpp
+++ b/nSide_v005-source-revised/fc/cartridge/board/nes-bnrom.cpp
@@ -1,9 +1,10 @@
-//NES-BN-ROM-01
+//IREM-BNROM
+//NES-BNROM
 
 struct NES_BNROM : Board {
 
 struct Settings {
-  bool mirror;  //0 = horizontal, 1 = vertical
+  bool mirror;  //0 = vertical, 1 = horizontal
 } settings;
 
 uint2 prg_bank;
@@ -14,12 +15,16 @@ uint8 prg_read(unsigned addr) {
 }
 
 void prg_write(unsigned addr, uint8 data) {
-  if(addr & 0x8000) prg_bank = data & 0x03;
+  if(addr & 0x8000) {
+    // Bus conflicts
+    data &= prg_read(addr);
+    prg_bank = data & 0x03;
+  }
 }
 
 uint8 chr_read(unsigned addr) {
   if(addr & 0x2000) {
-    if(settings.mirror == 0) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    if(settings.mirror == 1) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
     return ppu.ciram_read(addr);
   }
   return Board::chr_read(addr);
@@ -27,7 +32,7 @@ uint8 chr_read(unsigned addr) {
 
 void chr_write(unsigned addr, uint8 data) {
   if(addr & 0x2000) {
-    if(settings.mirror == 0) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    if(settings.mirror == 1) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
     return ppu.ciram_write(addr, data);
   }
   return Board::chr_write(addr, data);
@@ -46,7 +51,7 @@ void serialize(serializer& s) {
 }
 
 NES_BNROM(Markup::Node& document) : Board(document) {
-  settings.mirror = document["cartridge"]["mirror"]["mode"].data == "vertical" ? 1 : 0;
+  settings.mirror = document["cartridge/mirror/mode"].data == "horizontal";
 }
 
 };
diff --git a/../../../git/Emulator/bsnes/bsnes/fc/cartridge/board/nes-cnrom.cpp b/../../../git/Emulator/bsnes/bsnes/fc/cartridge/board/nes-cnrom.cpp
deleted file mode 100644
index aafc7bd..0000000
--- a/../../../git/Emulator/bsnes/bsnes/fc/cartridge/board/nes-cnrom.cpp
+++ /dev/null
@@ -1,54 +0,0 @@
-//NES-CNROM
-
-struct NES_CNROM : Board {
-
-struct Settings {
-  bool mirror;  //0 = horizontal, 1 = vertical
-} settings;
-
-uint2 chr_bank;
-
-uint8 prg_read(unsigned addr) {
-  if(addr & 0x8000) return prgrom.read(addr & 0x7fff);
-  return cpu.mdr();
-}
-
-void prg_write(unsigned addr, uint8 data) {
-  if(addr & 0x8000) chr_bank = data & 0x03;
-}
-
-uint8 chr_read(unsigned addr) {
-  if(addr & 0x2000) {
-    if(settings.mirror == 0) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
-    return ppu.ciram_read(addr & 0x07ff);
-  }
-  addr = (chr_bank * 0x2000) + (addr & 0x1fff);
-  return Board::chr_read(addr);
-}
-
-void chr_write(unsigned addr, uint8 data) {
-  if(addr & 0x2000) {
-    if(settings.mirror == 0) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
-    return ppu.ciram_write(addr & 0x07ff, data);
-  }
-  addr = (chr_bank * 0x2000) + (addr & 0x1fff);
-  Board::chr_write(addr, data);
-}
-
-void power() {
-}
-
-void reset() {
-  chr_bank = 0;
-}
-
-void serialize(serializer& s) {
-  Board::serialize(s);
-  s.integer(chr_bank);
-}
-
-NES_CNROM(Markup::Node& document) : Board(document) {
-  settings.mirror = document["cartridge"]["mirror"]["mode"].data == "vertical" ? 1 : 0;
-}
-
-};
diff --git a/nSide_v005-source-revised/fc/cartridge/board/nes-cxrom.cpp b/nSide_v005-source-revised/fc/cartridge/board/nes-cxrom.cpp
new file mode 100644
index 0000000..1ffdaa0
--- /dev/null
+++ b/nSide_v005-source-revised/fc/cartridge/board/nes-cxrom.cpp
@@ -0,0 +1,92 @@
+//NES-CNROM
+//NES-CPROM
+
+struct NES_CxROM : Board {
+
+enum class Revision : unsigned {
+  CNROM,
+  CPROM,
+} revision;
+
+struct Settings {
+  bool mirror;  //0 = vertical, 1 = horizontal
+  bool security;
+  uint2 pass;
+} settings;
+
+uint2 chr_bank;
+
+uint8 prg_read(unsigned addr) {
+  if(addr & 0x8000) return prgrom.read(addr & 0x7fff);
+  return cpu.mdr();
+}
+
+void prg_write(unsigned addr, uint8 data) {
+  if(addr & 0x8000) {
+    data &= prg_read(addr); // Bus conflicts
+    chr_bank = data & 0x03;
+  }
+}
+
+uint8 chr_read(unsigned addr) {
+  if(addr & 0x2000) {
+    if(settings.mirror == 1) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    return ppu.ciram_read(addr & 0x07ff);
+  }
+  if(settings.security) {
+    if(chr_bank != settings.pass) return ppu.status.mdr;
+  }
+  switch(revision) {
+  case Revision::CNROM:
+    addr = (chr_bank * 0x2000) + (addr & 0x1fff);
+    break;
+  case Revision::CPROM:
+    if(addr < 0x1000) addr = addr & 0x1fff;
+    else              addr = (chr_bank * 0x1000) + (addr & 0x0fff);
+    break;
+  }
+  return Board::chr_read(addr);
+}
+
+void chr_write(unsigned addr, uint8 data) {
+  if(addr & 0x2000) {
+    if(settings.mirror == 1) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    return ppu.ciram_write(addr & 0x07ff, data);
+  }
+  switch(revision) {
+  case Revision::CNROM:
+    addr = (chr_bank * 0x2000) + (addr & 0x1fff);
+    break;
+  case Revision::CPROM:
+    if(addr < 0x1000) addr = addr & 0x1fff;
+    else              addr = (chr_bank * 0x1000) + (addr & 0x0fff);
+    break;
+  }
+  Board::chr_write(addr, data);
+}
+
+void power() {
+}
+
+void reset() {
+  chr_bank = 0;
+}
+
+void serialize(serializer& s) {
+  Board::serialize(s);
+  s.integer(chr_bank);
+}
+
+NES_CxROM(Markup::Node& document) : Board(document) {
+  string type = document["cartridge/board/type"].data;
+  if(type.match("*CNROM*")) revision = Revision::CNROM;
+  if(type.match("*CPROM*")) revision = Revision::CPROM;
+
+  settings.mirror = document["cartridge/mirror/mode"].data == "horizontal";
+  settings.security = document["cartridge/board/security"].exists();
+  if(settings.security) {
+    settings.pass = document["cartridge/board/security/pass"].integer();
+  }
+}
+
+};
diff --git a/../../../git/Emulator/bsnes/bsnes/fc/cartridge/board/nes-exrom.cpp b/nSide_v005-source-revised/fc/cartridge/board/nes-exrom.cpp
index 42bd56c..78d5943 100644
--- a/../../../git/Emulator/bsnes/bsnes/fc/cartridge/board/nes-exrom.cpp
+++ b/nSide_v005-source-revised/fc/cartridge/board/nes-exrom.cpp
@@ -46,8 +46,12 @@ void serialize(serializer& s) {
   mmc5.serialize(s);
 }
 
-NES_ExROM(Markup::Node& document) : Board(document), mmc5(*this) {
-  revision = Revision::ELROM;
+NES_ExROM(Markup::Node& document) : Board(document), mmc5(*this, document) {
+  string type = document["cartridge/board/type"].data;
+  if(type.match("*EKROM*")) revision = Revision::EKROM;
+  if(type.match("*ELROM*")) revision = Revision::ELROM;
+  if(type.match("*ETROM*")) revision = Revision::ETROM;
+  if(type.match("*EWROM*")) revision = Revision::EWROM;
 }
 
 };
diff --git a/../../../git/Emulator/bsnes/bsnes/fc/cartridge/board/nes-fxrom.cpp b/nSide_v005-source-revised/fc/cartridge/board/nes-fxrom.cpp
index 2c79e50..d6f342a 100644
--- a/../../../git/Emulator/bsnes/bsnes/fc/cartridge/board/nes-fxrom.cpp
+++ b/nSide_v005-source-revised/fc/cartridge/board/nes-fxrom.cpp
@@ -85,7 +85,9 @@ void serialize(serializer& s) {
 }
 
 NES_FxROM(Markup::Node& document) : Board(document) {
-  revision = Revision::FKROM;
+  string type = document["cartridge/board/type"].data;
+  if(type.match("*FJROM*" )) revision = Revision::FJROM;
+  if(type.match("*FKROM*" )) revision = Revision::FKROM;
 }
 
 };
diff --git a/../../../git/Emulator/bsnes/bsnes/fc/cartridge/board/nes-gxrom.cpp b/nSide_v005-source-revised/fc/cartridge/board/nes-gxrom.cpp
index 36548d1..48eb93d 100644
--- a/../../../git/Emulator/bsnes/bsnes/fc/cartridge/board/nes-gxrom.cpp
+++ b/nSide_v005-source-revised/fc/cartridge/board/nes-gxrom.cpp
@@ -4,7 +4,7 @@
 struct NES_GxROM : Board {
 
 struct Settings {
-  bool mirror;  //0 = horizontal, 1 = vertical
+  bool mirror;  //0 = vertical, 1 = horizontal
 } settings;
 
 uint2 prg_bank;
@@ -17,6 +17,8 @@ uint8 prg_read(unsigned addr) {
 
 void prg_write(unsigned addr, uint8 data) {
   if(addr & 0x8000) {
+    // Bus conflicts
+    data &= prg_read(addr);
     prg_bank = (data & 0x30) >> 4;
     chr_bank = (data & 0x03) >> 0;
   }
@@ -24,7 +26,7 @@ void prg_write(unsigned addr, uint8 data) {
 
 uint8 chr_read(unsigned addr) {
   if(addr & 0x2000) {
-    if(settings.mirror == 0) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    if(settings.mirror == 1) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
     return ppu.ciram_read(addr & 0x07ff);
   }
   addr = (chr_bank * 0x2000) + (addr & 0x1fff);
@@ -33,7 +35,7 @@ uint8 chr_read(unsigned addr) {
 
 void chr_write(unsigned addr, uint8 data) {
   if(addr & 0x2000) {
-    if(settings.mirror == 0) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    if(settings.mirror == 1) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
     return ppu.ciram_write(addr & 0x07ff, data);
   }
   addr = (chr_bank * 0x2000) + (addr & 0x1fff);
@@ -55,7 +57,7 @@ void serialize(serializer& s) {
 }
 
 NES_GxROM(Markup::Node& document) : Board(document) {
-  settings.mirror = document["cartridge"]["mirror"]["mode"].data == "vertical" ? 1 : 0;
+  settings.mirror = document["cartridge/mirror/mode"].data == "horizontal";
 }
 
 };
diff --git a/../../../git/Emulator/bsnes/bsnes/fc/cartridge/board/nes-nrom.cpp b/nSide_v005-source-revised/fc/cartridge/board/nes-nrom.cpp
index 490d209..a04bb47 100644
--- a/../../../git/Emulator/bsnes/bsnes/fc/cartridge/board/nes-nrom.cpp
+++ b/nSide_v005-source-revised/fc/cartridge/board/nes-nrom.cpp
@@ -1,23 +1,44 @@
+//NES-FAMILYBASIC
+//NES-HROM
 //NES-NROM-128
 //NES-NROM-256
+//NES-RROM
+//NES-RROM-128
+//NES-RTROM
+//NES-SROM
+//NES-STROM
 
 struct NES_NROM : Board {
 
+enum class Revision : unsigned {
+  FAMILYBASIC,
+  HROM,
+  NROM,
+  RROM,
+  RTROM,
+  SROM,
+  STROM,
+} revision;
+
 struct Settings {
-  bool mirror;  //0 = horizontal, 1 = vertical
+  bool mirror;  //0 = vertical, 1 = horizontal
 } settings;
 
 uint8 prg_read(unsigned addr) {
-  if(addr & 0x8000) return prgrom.read(addr);
+  if((addr & 0x8000) == 0x8000) return prgrom.read(addr);
+  if(revision == Revision::FAMILYBASIC && (addr & 0xe000) == 0x6000)
+    return prgram.read(addr);
   return cpu.mdr();
 }
 
 void prg_write(unsigned addr, uint8 data) {
+  if(revision == Revision::FAMILYBASIC && (addr & 0xe000) == 0x6000)
+    prgram.write(addr, data);
 }
 
 uint8 chr_read(unsigned addr) {
   if(addr & 0x2000) {
-    if(settings.mirror == 0) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    if(settings.mirror == 1) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
     return ppu.ciram_read(addr & 0x07ff);
   }
   if(chrram.size) return chrram.read(addr);
@@ -26,7 +47,7 @@ uint8 chr_read(unsigned addr) {
 
 void chr_write(unsigned addr, uint8 data) {
   if(addr & 0x2000) {
-    if(settings.mirror == 0) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    if(settings.mirror == 1) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
     return ppu.ciram_write(addr & 0x07ff, data);
   }
   if(chrram.size) return chrram.write(addr, data);
@@ -37,7 +58,15 @@ void serialize(serializer& s) {
 }
 
 NES_NROM(Markup::Node& document) : Board(document) {
-  settings.mirror = document["cartridge"]["mirror"]["mode"].data == "vertical" ? 1 : 0;
+  string type = document["cartridge/board/type"].data;
+  if(type.match("*FAMILYBASIC*")) revision = Revision::FAMILYBASIC;
+  if(type.match("*HROM*"       )) revision = Revision::HROM;
+  if(type.match("*RROM*"       )) revision = Revision::RROM;
+  if(type.match("*SROM*"       )) revision = Revision::SROM;
+  if(revision == Revision::HROM)
+    settings.mirror = 0;
+  else
+    settings.mirror = document["cartridge/mirror/mode"].data == "horizontal";
 }
 
 };
diff --git a/../../../git/Emulator/bsnes/bsnes/fc/cartridge/board/nes-pxrom.cpp b/nSide_v005-source-revised/fc/cartridge/board/nes-pxrom.cpp
index f6b0510..ca4c89b 100644
--- a/../../../git/Emulator/bsnes/bsnes/fc/cartridge/board/nes-pxrom.cpp
+++ b/nSide_v005-source-revised/fc/cartridge/board/nes-pxrom.cpp
@@ -91,7 +91,9 @@ void serialize(serializer& s) {
 }
 
 NES_PxROM(Markup::Node& document) : Board(document) {
-  revision = Revision::PNROM;
+  string type = document["cartridge/board/type"].data;
+  if(type.match("*PEEOROM*")) revision = Revision::PEEOROM;
+  if(type.match("*PNROM*"  )) revision = Revision::PNROM;
 }
 
 };
diff --git a/../../../git/Emulator/bsnes/bsnes/fc/cartridge/board/nes-sxrom.cpp b/nSide_v005-source-revised/fc/cartridge/board/nes-sxrom.cpp
index 7f51a6b..27f71a0 100644
--- a/../../../git/Emulator/bsnes/bsnes/fc/cartridge/board/nes-sxrom.cpp
+++ b/nSide_v005-source-revised/fc/cartridge/board/nes-sxrom.cpp
@@ -7,6 +7,7 @@ enum class Revision : unsigned {
   SC1ROM,
   SEROM,
   SFROM,
+  SFEXPROM,
   SGROM,
   SHROM,
   SH1ROM,
@@ -20,6 +21,7 @@ enum class Revision : unsigned {
   SLRROM,
   SMROM,
   SNROM,
+  SNWEPROM,
   SOROM,
   SUROM,
   SXROM,
@@ -27,8 +29,10 @@ enum class Revision : unsigned {
 
 MMC1 mmc1;
 
+bool last_chr_bank;
+
 void main() {
-  return mmc1.main();
+  mmc1.main();
 }
 
 unsigned ram_addr(unsigned addr) {
@@ -42,16 +46,24 @@ unsigned ram_addr(unsigned addr) {
 uint8 prg_read(unsigned addr) {
   if((addr & 0xe000) == 0x6000) {
     if(revision == Revision::SNROM) {
-      if(mmc1.chr_bank[0] & 0x10) return cpu.mdr();
+      if(mmc1.chr_bank[last_chr_bank] & 0x10) return cpu.mdr();
     }
     if(mmc1.ram_disable) return 0x00;
-    return prgram.read(ram_addr(addr));
+    if(prgram.size > 0) return prgram.read(ram_addr(addr));
   }
 
   if(addr & 0x8000) {
-    addr = mmc1.prg_addr(addr);
-    if(revision == Revision::SXROM) {
-      addr |= ((mmc1.chr_bank[0] & 0x10) >> 4) << 18;
+    switch(revision) {
+      case Revision::SEROM:
+      case Revision::SHROM:
+      case Revision::SH1ROM:
+        break;
+      default:
+        addr = mmc1.prg_addr(addr);
+        if(revision == Revision::SUROM || revision == Revision::SXROM) {
+          addr |= ((mmc1.chr_bank[last_chr_bank] & 0x10) >> 4) << 18;
+        }
+        break;
     }
     return prgrom.read(addr);
   }
@@ -65,7 +77,7 @@ void prg_write(unsigned addr, uint8 data) {
       if(mmc1.chr_bank[0] & 0x10) return;
     }
     if(mmc1.ram_disable) return;
-    return prgram.write(ram_addr(addr), data);
+    if(prgram.size > 0) return prgram.write(ram_addr(addr), data);
   }
 
   if(addr & 0x8000) return mmc1.mmio_write(addr, data);
@@ -73,11 +85,13 @@ void prg_write(unsigned addr, uint8 data) {
 
 uint8 chr_read(unsigned addr) {
   if(addr & 0x2000) return ppu.ciram_read(mmc1.ciram_addr(addr));
+  last_chr_bank = mmc1.chr_mode ? ((addr & 0x1000) >> 12) : 0;
   return Board::chr_read(mmc1.chr_addr(addr));
 }
 
 void chr_write(unsigned addr, uint8 data) {
   if(addr & 0x2000) return ppu.ciram_write(mmc1.ciram_addr(addr), data);
+  last_chr_bank = mmc1.chr_mode ? ((addr & 0x1000) >> 12) : 0;
   return Board::chr_write(mmc1.chr_addr(addr), data);
 }
 
@@ -92,10 +106,35 @@ void reset() {
 void serialize(serializer& s) {
   Board::serialize(s);
   mmc1.serialize(s);
+  s.integer(last_chr_bank);
 }
 
-NES_SxROM(Markup::Node& document) : Board(document), mmc1(*this) {
-  revision = Revision::SXROM;
+NES_SxROM(Markup::Node& document) : Board(document), mmc1(*this, document) {
+  string type = document["cartridge/board/type"].data;
+  if(type.match("*SAROM*"   )) revision = Revision::SAROM;
+  if(type.match("*SBROM*"   )) revision = Revision::SBROM;
+  if(type.match("*SCROM*"   )) revision = Revision::SCROM;
+  if(type.match("*SC1ROM*"  )) revision = Revision::SC1ROM;
+  if(type.match("*SEROM*"   )) revision = Revision::SEROM;
+  if(type.match("*SFROM*"   )) revision = Revision::SFROM;
+  if(type.match("*SFEXPROM*")) revision = Revision::SFEXPROM;
+  if(type.match("*SGROM*"   )) revision = Revision::SGROM;
+  if(type.match("*SHROM*"   )) revision = Revision::SHROM;
+  if(type.match("*SH1ROM*"  )) revision = Revision::SH1ROM;
+  if(type.match("*SIROM*"   )) revision = Revision::SIROM;
+  if(type.match("*SJROM*"   )) revision = Revision::SJROM;
+  if(type.match("*SKROM*"   )) revision = Revision::SKROM;
+  if(type.match("*SLROM*"   )) revision = Revision::SLROM;
+  if(type.match("*SL1ROM*"  )) revision = Revision::SL1ROM;
+  if(type.match("*SL2ROM*"  )) revision = Revision::SL2ROM;
+  if(type.match("*SL3ROM*"  )) revision = Revision::SL3ROM;
+  if(type.match("*SLRROM*"  )) revision = Revision::SLRROM;
+  if(type.match("*SMROM*"   )) revision = Revision::SMROM;
+  if(type.match("*SNROM*"   )) revision = Revision::SNROM;
+  if(type.match("*SNWEPROM*")) revision = Revision::SNWEPROM;
+  if(type.match("*SOROM*"   )) revision = Revision::SOROM;
+  if(type.match("*SUROM*"   )) revision = Revision::SUROM;
+  if(type.match("*SXROM*"   )) revision = Revision::SXROM;
 }
 
 };
diff --git a/../../../git/Emulator/bsnes/bsnes/fc/cartridge/board/nes-txrom.cpp b/nSide_v005-source-revised/fc/cartridge/board/nes-txrom.cpp
index ee36d55..964fe91 100644
--- a/../../../git/Emulator/bsnes/bsnes/fc/cartridge/board/nes-txrom.cpp
+++ b/nSide_v005-source-revised/fc/cartridge/board/nes-txrom.cpp
@@ -16,6 +16,7 @@ enum class Revision : unsigned {
   TR1ROM,
   TSROM,
   TVROM,
+  MCACC,
 } revision;
 
 MMC3 mmc3;
@@ -25,28 +26,52 @@ void main() {
 }
 
 uint8 prg_read(unsigned addr) {
-  if((addr & 0xe000) == 0x6000) return mmc3.ram_read(addr);
+  if((addr & 0xe000) == 0x6000 && prgram.size > 0) return mmc3.ram_read(addr);
   if(addr & 0x8000) return prgrom.read(mmc3.prg_addr(addr));
   return cpu.mdr();
 }
 
 void prg_write(unsigned addr, uint8 data) {
-  if((addr & 0xe000) == 0x6000) return mmc3.ram_write(addr, data);
+  if((addr & 0xe000) == 0x6000 && prgram.size > 0) return mmc3.ram_write(addr, data);
   if(addr & 0x8000) return mmc3.reg_write(addr, data);
 }
 
 uint8 chr_read(unsigned addr) {
   mmc3.irq_test(addr);
-  if(addr & 0x2000) return ppu.ciram_read(mmc3.ciram_addr(addr));
+  if(revision == Revision::TR1ROM || revision == Revision::TVROM) {
+    if(addr & 0x2000) return chrram.data[mirror(addr & 0x0FFF, chrram.size)];
+    return chrrom.data[mirror(mmc3.chr_addr(addr), chrrom.size)];
+  }
+  if(addr & 0x2000) return ppu.ciram_read(ciram_addr(addr));
+  if(revision == Revision::TQROM) {
+    if(mmc3.chr_addr(addr) & (0x40 << 10))
+      return chrram.data[mirror(mmc3.chr_addr(addr), chrram.size)];
+    else
+      return chrrom.data[mirror(mmc3.chr_addr(addr), chrrom.size)];
+  }
   return Board::chr_read(mmc3.chr_addr(addr));
 }
 
 void chr_write(unsigned addr, uint8 data) {
   mmc3.irq_test(addr);
-  if(addr & 0x2000) return ppu.ciram_write(mmc3.ciram_addr(addr), data);
+  if(revision == Revision::TR1ROM || revision == Revision::TVROM) {
+    if(addr & 0x2000) chrram.data[mirror(addr & 0x0FFF, chrram.size)] = data;
+    return;
+  }
+  if(addr & 0x2000) return ppu.ciram_write(ciram_addr(addr), data);
   return Board::chr_write(mmc3.chr_addr(addr), data);
 }
 
+unsigned ciram_addr(unsigned addr) {
+  switch(revision) {
+  default:
+    return mmc3.ciram_addr(addr);
+  case Revision::TKSROM:
+  case Revision::TLSROM:
+    return ((mmc3.chr_addr(addr & 0xfff) & 0x20000) >> 7) | (addr & 0x3ff);
+  }
+}
+
 void power() {
   mmc3.power();
 }
@@ -60,8 +85,24 @@ void serialize(serializer& s) {
   mmc3.serialize(s);
 }
 
-NES_TxROM(Markup::Node& document) : Board(document), mmc3(*this) {
-  revision = Revision::TLROM;
+NES_TxROM(Markup::Node& document) : Board(document), mmc3(*this, document) {
+  string type = document["cartridge/board/type"].data;
+  if(type.match("*TBROM*" )) revision = Revision::TBROM;
+  if(type.match("*TEROM*" )) revision = Revision::TEROM;
+  if(type.match("*TFROM*" )) revision = Revision::TFROM;
+  if(type.match("*TGROM*" )) revision = Revision::TGROM;
+  if(type.match("*TKROM*" )) revision = Revision::TKROM;
+  if(type.match("*TKSROM*")) revision = Revision::TKSROM;
+  if(type.match("*TLROM*" )) revision = Revision::TLROM;
+  if(type.match("*TL1ROM*")) revision = Revision::TL1ROM;
+  if(type.match("*TL2ROM*")) revision = Revision::TL2ROM;
+  if(type.match("*TLSROM*")) revision = Revision::TLSROM;
+  if(type.match("*TNROM*" )) revision = Revision::TNROM;
+  if(type.match("*TQROM*" )) revision = Revision::TQROM;
+  if(type.match("*TR1ROM*")) revision = Revision::TR1ROM;
+  if(type.match("*TSROM*" )) revision = Revision::TSROM;
+  if(type.match("*TVROM*" )) revision = Revision::TVROM;
+  if(type.match("*MC-ACC*")) revision = Revision::MCACC;
 }
 
 };
diff --git a/../../../git/Emulator/bsnes/bsnes/fc/cartridge/board/nes-uxrom.cpp b/nSide_v005-source-revised/fc/cartridge/board/nes-uxrom.cpp
index 7aced28..a9436af 100644
--- a/../../../git/Emulator/bsnes/bsnes/fc/cartridge/board/nes-uxrom.cpp
+++ b/nSide_v005-source-revised/fc/cartridge/board/nes-uxrom.cpp
@@ -4,24 +4,35 @@
 struct NES_UxROM : Board {
 
 struct Settings {
-  bool mirror;  //0 = horizontal, 1 = vertical
+  bool mirror;    //0 = vertical, 1 = horizontal
+  bool chip_type; //0 = 74HC32, 1 = 74HC08
 } settings;
 
 uint4 prg_bank;
 
 uint8 prg_read(unsigned addr) {
-  if((addr & 0xc000) == 0x8000) return prgrom.read((prg_bank << 14) | (addr & 0x3fff));
-  if((addr & 0xc000) == 0xc000) return prgrom.read((    0x0f << 14) | (addr & 0x3fff));
-  return cpu.mdr();
+  if((addr & 0x8000) == 0x0000) return cpu.mdr();
+  switch(settings.chip_type) {
+  case 0:
+    if((addr & 0xc000) == 0x8000) return prgrom.read((prg_bank << 14) | (addr & 0x3fff));
+    else                          return prgrom.read((    0x0f << 14) | (addr & 0x3fff));
+  case 1:
+    if((addr & 0xc000) == 0x8000) return prgrom.read((    0x00 << 14) | (addr & 0x3fff));
+    else                          return prgrom.read((prg_bank << 14) | (addr & 0x3fff));
+  }
 }
 
 void prg_write(unsigned addr, uint8 data) {
-  if(addr & 0x8000) prg_bank = data & 0x0f;
+  if(addr & 0x8000) {
+    // Bus conflicts
+    data &= prg_read(addr);
+    prg_bank = data & 0x0f;
+  }
 }
 
 uint8 chr_read(unsigned addr) {
   if(addr & 0x2000) {
-    if(settings.mirror == 0) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    if(settings.mirror == 1) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
     return ppu.ciram_read(addr);
   }
   return Board::chr_read(addr);
@@ -29,7 +40,7 @@ uint8 chr_read(unsigned addr) {
 
 void chr_write(unsigned addr, uint8 data) {
   if(addr & 0x2000) {
-    if(settings.mirror == 0) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    if(settings.mirror == 1) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
     return ppu.ciram_write(addr, data);
   }
   return Board::chr_write(addr, data);
@@ -49,7 +60,8 @@ void serialize(serializer& s) {
 }
 
 NES_UxROM(Markup::Node& document) : Board(document) {
-  settings.mirror = document["cartridge"]["mirror"]["mode"].data == "vertical" ? 1 : 0;
+  settings.mirror = document["cartridge/mirror/mode"].data == "horizontal";
+  settings.chip_type = document["cartridge/chip/type"].data == "74HC08" ? 1 : 0;
 }
 
 };
diff --git a/nSide_v005-source-revised/fc/cartridge/board/sunsoft-4.cpp b/nSide_v005-source-revised/fc/cartridge/board/sunsoft-4.cpp
new file mode 100644
index 0000000..13e9a4f
--- /dev/null
+++ b/nSide_v005-source-revised/fc/cartridge/board/sunsoft-4.cpp
@@ -0,0 +1,87 @@
+//SUNSOFT-4
+
+struct Sunsoft4 : Board {
+
+uint8 chr_bank[4];
+uint7 ntrom_bank[2];
+uint2 mirror;
+bool nametable_mode;
+uint8 prg_bank;
+
+uint8 prg_read(unsigned addr) {
+  if((addr & 0xc000) == 0x8000) return prgrom.read((prg_bank << 14) | (addr & 0x3fff));
+  if((addr & 0xc000) == 0xc000) return prgrom.read((    0xff << 14) | (addr & 0x3fff));
+  return cpu.mdr();
+}
+
+void prg_write(unsigned addr, uint8 data) {
+  switch(addr & 0xf000) {
+  case 0x8000: chr_bank[0] = data; break;
+  case 0x9000: chr_bank[1] = data; break;
+  case 0xa000: chr_bank[2] = data; break;
+  case 0xb000: chr_bank[3] = data; break;
+  case 0xc000: ntrom_bank[0] = data | 0x80; break;
+  case 0xd000: ntrom_bank[1] = data | 0x80; break;
+  case 0xe000:
+    mirror = data & 0x03;
+    nametable_mode = data & 0x10;
+    break;
+  case 0xf000: prg_bank = data; break;
+  }
+}
+
+unsigned ciram_addr(unsigned addr) {
+  switch(mirror) {
+  case 0: return ((addr & 0x0400) >> 0) | (addr & 0x03ff);
+  case 1: return ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+  case 2: return 0x0000 | (addr & 0x03ff);
+  case 3: return 0x0400 | (addr & 0x03ff);
+  }
+}
+
+uint8 chr_read(unsigned addr) {
+  if(addr & 0x2000) {
+    addr = ciram_addr(addr);
+    if(nametable_mode) return Board::chr_read(((ntrom_bank[(addr & 0x0400) >> 10] | 0x80) << 10) | (addr & 0x03FF));
+    else               return ppu.ciram_read(addr);
+  }
+  addr = (chr_bank[(addr & 0x1800) >> 11] << 11) | (addr & 0x07ff);
+  return Board::chr_read(addr);
+}
+
+void chr_write(unsigned addr, uint8 data) {
+  if(addr & 0x2000) {
+    if(nametable_mode == 0) return ppu.ciram_write(ciram_addr(addr), data);
+  } else {
+    return Board::chr_write(addr, data);
+  }
+}
+
+void power() {
+}
+
+void reset() {
+  chr_bank[0] = 0;
+  chr_bank[1] = 0;
+  chr_bank[2] = 0;
+  chr_bank[3] = 0;
+  ntrom_bank[0] = 0;
+  ntrom_bank[1] = 0;
+  mirror = 0;
+  nametable_mode = 0;
+  prg_bank = 0;
+}
+
+void serialize(serializer& s) {
+  Board::serialize(s);
+  s.array(chr_bank);
+  s.array(ntrom_bank);
+  s.integer(mirror);
+  s.integer(nametable_mode);
+  s.integer(prg_bank);
+}
+
+Sunsoft4(Markup::Node& document) : Board(document) {
+}
+
+};
diff --git a/nSide_v005-source-revised/fc/cartridge/board/unlicensed/camerica.cpp b/nSide_v005-source-revised/fc/cartridge/board/unlicensed/camerica.cpp
new file mode 100644
index 0000000..c559060
--- /dev/null
+++ b/nSide_v005-source-revised/fc/cartridge/board/unlicensed/camerica.cpp
@@ -0,0 +1,105 @@
+struct Camerica : Board {
+
+enum class Revision : unsigned {
+  ALGN, // Aladdin Game Enhancer
+  ALGQ, // Aladdin Game Enhancer (Quattro Multicarts)
+  BF9093,
+  BF9096,
+  BF9097,
+} revision;
+
+struct Settings {
+  bool mirror;    //0 = vertical, 1 = horizontal
+} settings;
+
+uint4 prg_bank;
+uint2 prg_block; // for ALGQ and BF9096
+bool nametable; // for BF9097
+
+uint8 prg_read(unsigned addr) {
+  if((addr & 0x8000) == 0x0000) return cpu.mdr();
+  if((addr & 0xc000) == 0x8000) {
+    return prgrom.read((prg_block << 16) | (prg_bank << 14) | (addr & 0x3fff));
+  } else {
+    if(revision != Revision::ALGQ && revision != Revision::BF9096)
+      return prgrom.read((0x0f << 14) | (addr & 0x3fff));
+    else
+      return prgrom.read((prg_block << 16) | (0x03 << 14) | (addr & 0x3fff));
+  }
+}
+
+void prg_write(unsigned addr, uint8 data) {
+  switch(revision) {
+  case Revision::ALGQ:
+  case Revision::BF9096:
+    if((addr & 0xc000) == 0x8000) {
+      prg_block = (data & 0x18) >> 3;
+    }
+    break;
+  case Revision::BF9097:
+    if((addr & 0xe000) == 0x8000) {
+      nametable = data & 0x10;
+    }
+    break;
+  }
+  if((addr & 0xc000) == 0xc000) {
+    switch(revision) {
+    case Revision::ALGN:
+    case Revision::BF9093: prg_bank = data & 0x0f; break;
+    case Revision::ALGQ:
+    case Revision::BF9096: prg_bank = data & 0x03; break;
+    case Revision::BF9097: prg_bank = data & 0x07; break;
+    }
+  }
+}
+
+uint8 chr_read(unsigned addr) {
+  if(addr & 0x2000) return ppu.ciram_read(ciram_addr(addr));
+  return Board::chr_read(addr);
+}
+
+void chr_write(unsigned addr, uint8 data) {
+  if(addr & 0x2000) return ppu.ciram_write(ciram_addr(addr), data);
+  return Board::chr_write(addr, data);
+}
+
+unsigned ciram_addr(unsigned addr) const {
+  if(revision != Revision::BF9097) {
+    switch(settings.mirror) {
+    case 0: return ((addr & 0x0400) >> 0) | (addr & 0x03ff);
+    case 1: return ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    }
+  } else {
+    return (addr & 0x03ff) | (nametable << 10);
+  }
+}
+
+void power() {
+}
+
+void reset() {
+  prg_bank = 0;
+  prg_block = 0;
+  nametable = 0;
+}
+
+void serialize(serializer& s) {
+  Board::serialize(s);
+
+  s.integer(prg_bank);
+  s.integer(prg_block);
+  s.integer(nametable);
+}
+
+Camerica(Markup::Node& document) : Board(document) {
+  string type = document["cartridge/board/type"].data;
+  if(type.match("*ALGN*"  )) revision = Revision::ALGN;
+  if(type.match("*ALGQ*"  )) revision = Revision::ALGQ;
+  if(type.match("*BF9093*")) revision = Revision::BF9093;
+  if(type.match("*BF9096*")) revision = Revision::BF9096;
+  if(type.match("*BF9097*")) revision = Revision::BF9097;
+
+  settings.mirror = document["cartridge/mirror/mode"].data == "horizontal";
+}
+
+};
diff --git a/nSide_v005-source-revised/fc/cartridge/board/unlicensed/colordreams-74377.cpp b/nSide_v005-source-revised/fc/cartridge/board/unlicensed/colordreams-74377.cpp
new file mode 100644
index 0000000..68e1e24
--- /dev/null
+++ b/nSide_v005-source-revised/fc/cartridge/board/unlicensed/colordreams-74377.cpp
@@ -0,0 +1,64 @@
+//COLORDREAMS-74*377
+
+struct ColorDreams74377 : Board {
+
+struct Settings {
+  bool mirror;  //0 = vertical, 1 = horizontal
+} settings;
+
+uint2 prg_bank;
+uint4 chr_bank;
+
+uint8 prg_read(unsigned addr) {
+  if(addr & 0x8000) return prgrom.read((prg_bank << 15) | (addr & 0x7fff));
+  return cpu.mdr();
+}
+
+void prg_write(unsigned addr, uint8 data) {
+  if(addr & 0x8000) {
+    // Bus conflicts
+    data &= prg_read(addr);
+    // PRG and CHR bits are swapped relative to NES-GxROM.
+    // Additionally, up to 16 CHR banks are available instead of 4.
+    prg_bank = (data & 0x03) >> 0;
+    chr_bank = (data & 0xf0) >> 4;
+  }
+}
+
+uint8 chr_read(unsigned addr) {
+  if(addr & 0x2000) {
+    if(settings.mirror == 1) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    return ppu.ciram_read(addr & 0x07ff);
+  }
+  addr = (chr_bank * 0x2000) + (addr & 0x1fff);
+  return Board::chr_read(addr);
+}
+
+void chr_write(unsigned addr, uint8 data) {
+  if(addr & 0x2000) {
+    if(settings.mirror == 1) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    return ppu.ciram_write(addr & 0x07ff, data);
+  }
+  addr = (chr_bank * 0x2000) + (addr & 0x1fff);
+  Board::chr_write(addr, data);
+}
+
+void power() {
+}
+
+void reset() {
+  prg_bank = 0;
+  chr_bank = 0;
+}
+
+void serialize(serializer& s) {
+  Board::serialize(s);
+  s.integer(prg_bank);
+  s.integer(chr_bank);
+}
+
+ColorDreams74377(Markup::Node& document) : Board(document) {
+  settings.mirror = document["cartridge/mirror/mode"].data == "horizontal";
+}
+
+};
diff --git a/nSide_v005-source-revised/fc/cartridge/board/unlicensed/mlt-action52.cpp b/nSide_v005-source-revised/fc/cartridge/board/unlicensed/mlt-action52.cpp
new file mode 100644
index 0000000..a79d0e7
--- /dev/null
+++ b/nSide_v005-source-revised/fc/cartridge/board/unlicensed/mlt-action52.cpp
@@ -0,0 +1,82 @@
+//MLT-ACTION52
+
+struct MLT_Action52 : Board {
+
+struct Settings {
+  uint4 connected_chips;
+  uint2 chip_map[4];
+} settings;
+
+bool mirror;
+uint2 prg_chip;
+uint5 prg_bank;
+bool prg_mode;
+uint6 chr_bank;
+
+uint8 prg_read(unsigned addr) {
+  if(addr & 0x8000 && settings.connected_chips & (1 << prg_chip)) {
+    unsigned target_bank = prg_bank;
+    target_bank |= settings.chip_map[prg_chip] << 5;
+    if(prg_mode) return prgrom.read((target_bank << 14) | (addr & 0x3fff));
+    else         return prgrom.read((target_bank << 14) | (addr & 0x7fff));
+  }
+  return cpu.mdr();
+}
+
+void prg_write(unsigned addr, uint8 data) {
+  if(addr & 0x8000) {
+    mirror = (addr & 0x2000) >> 13;
+    prg_chip = (addr & 0x1800) >> 11;
+    prg_bank = (addr & 0x07c0) >> 6;
+    prg_mode = (addr & 0x0020) >> 5;
+    chr_bank = ((addr & 0x000f) << 2) + (data & 0x03);
+  }
+}
+
+uint8 chr_read(unsigned addr) {
+  if(addr & 0x2000) {
+    if(mirror) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    return ppu.ciram_read(addr & 0x07ff);
+  }
+  addr = (chr_bank * 0x2000) + (addr & 0x1fff);
+  return Board::chr_read(addr);
+}
+
+void chr_write(unsigned addr, uint8 data) {
+  if(addr & 0x2000) {
+    if(mirror) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    return ppu.ciram_write(addr & 0x07ff, data);
+  }
+  addr = (chr_bank * 0x2000) + (addr & 0x1fff);
+  Board::chr_write(addr, data);
+}
+
+void power() {
+}
+
+void reset() {
+  mirror = 0;
+  prg_chip = 0;
+  prg_bank = 0;
+  prg_mode = 0;
+  chr_bank = 0;
+}
+
+void serialize(serializer &s) {
+  Board::serialize(s);
+  s.integer(mirror);
+  s.integer(prg_chip);
+  s.integer(prg_bank);
+  s.integer(prg_mode);
+  s.integer(chr_bank);
+}
+
+MLT_Action52(Markup::Node &document) : Board(document) {
+  settings.connected_chips = numeral(document["cartridge/board/connected-chips"].data);
+  uint2 chip_block = 0;
+  for(unsigned chip_id = 0; chip_id < 4; chip_id++) {
+    if(settings.connected_chips & (0x1 << chip_id)) settings.chip_map[chip_id] = chip_block++;
+  }
+}
+
+};
diff --git a/nSide_v005-source-revised/fc/cartridge/board/unlicensed/nina.cpp b/nSide_v005-source-revised/fc/cartridge/board/unlicensed/nina.cpp
new file mode 100644
index 0000000..32559df
--- /dev/null
+++ b/nSide_v005-source-revised/fc/cartridge/board/unlicensed/nina.cpp
@@ -0,0 +1,94 @@
+//AVE-NINA-01
+//AVE-NINA-02
+//AVE-NINA-03
+//AVE-NINA-06
+
+struct Nina : Board {
+
+unsigned revision;
+
+struct Settings {
+  bool mirror;  //0 = vertical, 1 = horizontal
+} settings;
+
+bool prg_bank;
+uint4 chr_bank[2];
+
+uint8 prg_read(unsigned addr) {
+  if(addr & 0x8000) return prgrom.read((prg_bank << 15) | (addr & 0x7fff));
+  if((addr & 0xe000) == 0x6000) {
+    if(prgram.size > 0) return prgram.read(addr);
+  }
+  return cpu.mdr();
+}
+
+void prg_write(unsigned addr, uint8 data) {
+  switch(revision) {
+  case  1:
+  case  2:
+    switch(addr) {
+    case 0x7ffd: prg_bank    = data & 0x01; break;
+    case 0x7ffe: chr_bank[0] = data & 0x0f; break;
+    case 0x7fff: chr_bank[1] = data & 0x0f; break;
+    }
+    break;
+  case  3:
+  case  6:
+    if((addr & 0xe100) == 0x4100) {
+      prg_bank    = (data & 0x08) >> 3;
+      chr_bank[0] = ((data & 0x07) << 1) | 0;
+      chr_bank[1] = ((data & 0x07) << 1) | 1;
+    }
+    break;
+  }
+  if((addr & 0xe000) == 0x6000 && prgram.size > 0) prgram.write(addr, data);
+}
+
+uint8 chr_read(unsigned addr) {
+  if(addr & 0x2000) {
+    if(settings.mirror == 1) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    return ppu.ciram_read(addr);
+  }
+  return Board::chr_read((addr & 0x0fff) | (chr_bank[(addr & 0x1000) >> 12] << 12));
+}
+
+void chr_write(unsigned addr, uint8 data) {
+  if(addr & 0x2000) {
+    if(settings.mirror == 1) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    return ppu.ciram_write(addr, data);
+  }
+  return Board::chr_write((addr & 0x0fff) | (chr_bank[(addr & 0x1000) >> 12] << 12), data);
+}
+
+void power() {
+  reset();
+}
+
+void reset() {
+  prg_bank = 0;
+  chr_bank[0] = 0;
+  chr_bank[1] = 0;
+}
+
+void serialize(serializer& s) {
+  Board::serialize(s);
+  s.integer(prg_bank);
+  s.array(chr_bank);
+}
+
+Nina(Markup::Node& document) : Board(document) {
+  string type = document["cartridge/board/type"].data;
+  if(type.match("*NINA-01*")) revision =  1;
+  if(type.match("*NINA-02*")) revision =  2;
+  if(type.match("*NINA-03*")) revision =  3;
+  if(type.match("*NINA-06*")) revision =  6;
+
+  print("Revision: 0", revision, "\n");
+  if(revision ==  1 || revision ==  2) {
+    settings.mirror = 1;
+  } else {
+    settings.mirror = document["cartridge/mirror/mode"].data == "horizontal";
+  }
+}
+
+};
diff --git a/nSide_v005-source-revised/fc/cartridge/board/unlicensed/noconflicts-cnrom.cpp b/nSide_v005-source-revised/fc/cartridge/board/unlicensed/noconflicts-cnrom.cpp
new file mode 100644
index 0000000..83a8173
--- /dev/null
+++ b/nSide_v005-source-revised/fc/cartridge/board/unlicensed/noconflicts-cnrom.cpp
@@ -0,0 +1,56 @@
+// This board is intended for homebrew games that do not account for bus
+// conflicts. Many Sachen and Panesian games require this board, but they were
+// not the reason for its inclusion.
+
+struct NoConflicts_CNROM : Board {
+
+struct Settings {
+  bool mirror;  //0 = vertical, 1 = horizontal
+} settings;
+
+uint2 chr_bank;
+
+uint8 prg_read(unsigned addr) {
+  if(addr & 0x8000) return prgrom.read(addr & 0x7fff);
+  return cpu.mdr();
+}
+
+void prg_write(unsigned addr, uint8 data) {
+  if(addr & 0x8000) chr_bank = data & 0x03;
+}
+
+uint8 chr_read(unsigned addr) {
+  if(addr & 0x2000) {
+    if(settings.mirror == 1) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    return ppu.ciram_read(addr & 0x07ff);
+  }
+  addr = (chr_bank * 0x2000) + (addr & 0x1fff);
+  return Board::chr_read(addr);
+}
+
+void chr_write(unsigned addr, uint8 data) {
+  if(addr & 0x2000) {
+    if(settings.mirror == 1) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    return ppu.ciram_write(addr & 0x07ff, data);
+  }
+  addr = (chr_bank * 0x2000) + (addr & 0x1fff);
+  Board::chr_write(addr, data);
+}
+
+void power() {
+}
+
+void reset() {
+  chr_bank = 0;
+}
+
+void serialize(serializer& s) {
+  Board::serialize(s);
+  s.integer(chr_bank);
+}
+
+NoConflicts_CNROM(Markup::Node& document) : Board(document) {
+  settings.mirror = document["cartridge/mirror/mode"].data == "horizontal";
+}
+
+};
diff --git a/nSide_v005-source-revised/fc/cartridge/board/unlicensed/single-chip.cpp b/nSide_v005-source-revised/fc/cartridge/board/unlicensed/single-chip.cpp
new file mode 100644
index 0000000..05a8679
--- /dev/null
+++ b/nSide_v005-source-revised/fc/cartridge/board/unlicensed/single-chip.cpp
@@ -0,0 +1,49 @@
+struct SingleChip : Board {
+
+struct Settings {
+  uint4 va10;  //10 = vertical, 11 = horizontal, 12 = BLK0, 13 = BLK1
+} settings;
+
+uint8 prg_read(unsigned addr) {
+  if(addr & 0x8000) return prgrom.read(addr);
+  return cpu.mdr();
+}
+
+void prg_write(unsigned addr, uint8 data) {
+}
+
+uint8 chr_read(unsigned addr) {
+  if(addr & 0x2000) {
+    switch(settings.va10) {
+    case 10: addr = (addr & 0x07ff);
+    case 11: addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    case 12: addr = (addr & 0x03ff);
+    case 13: addr = (addr & 0x03ff) | 0x0400;
+    }
+    return ppu.ciram_read(addr & 0x07ff);
+  }
+  return ppu.ciram_read(addr & 0x07ff);
+}
+
+void chr_write(unsigned addr, uint8 data) {
+  if(addr & 0x2000) {
+    switch(settings.va10) {
+    case 10: addr = (addr & 0x07ff);
+    case 11: addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    case 12: addr = (addr & 0x03ff);
+    case 13: addr = (addr & 0x03ff) | 0x0400;
+    }
+    return ppu.ciram_write(addr & 0x07ff, data);
+  }
+  return ppu.ciram_write(addr & 0x07ff, data);
+}
+
+void serialize(serializer& s) {
+  Board::serialize(s);
+}
+
+SingleChip(Markup::Node& document) : Board(document) {
+  settings.va10 = numeral(document["cartridge/board/va10"].data);
+}
+
+};
diff --git a/nSide_v005-source-revised/fc/cartridge/board/vs.cpp b/nSide_v005-source-revised/fc/cartridge/board/vs.cpp
new file mode 100644
index 0000000..9f5f985
--- /dev/null
+++ b/nSide_v005-source-revised/fc/cartridge/board/vs.cpp
@@ -0,0 +1,49 @@
+//VS
+
+struct VS : Board {
+
+bool bank;
+
+uint8 prg_read(unsigned addr) {
+  if((addr & 0xe000) == 0x6000) return prgram.read(addr);
+  if(addr & 0x8000) {
+    if(prgrom.size <= 0x8000 || (addr & 0xe000) > 0x8000 || bank == 0) {
+      return prgrom.read(addr & 0x7fff);
+    } else {
+      return prgrom.read((addr & 0x1fff) | 0x8000);
+    }
+  }
+  return cpu.mdr();
+}
+
+void prg_write(unsigned addr, uint8 data) {
+  if(addr == 0x4016) bank = (data & 0x04) >> 2;
+  if((addr & 0xe000) == 0x6000) prgram.write(addr, data);
+}
+
+uint8 chr_read(unsigned addr) {
+  if(addr & 0x2000) return chrram.read(addr & 0x0fff);
+  if(bank && chrrom.size < 0x2000) return ppu.status.mdr;
+  return chrrom.read((bank * 0x2000) + (addr & 0x1fff));
+}
+
+void chr_write(unsigned addr, uint8 data) {
+  if(addr & 0x2000) return chrram.write(addr & 0x0fff, data);
+}
+
+void power() {
+}
+
+void reset() {
+  bank = 0;
+}
+
+void serialize(serializer& s) {
+  Board::serialize(s);
+  s.integer(bank);
+}
+
+VS(Markup::Node& document) : Board(document) {
+}
+
+};
diff --git a/../../../git/Emulator/bsnes/bsnes/fc/cartridge/cartridge.cpp b/nSide_v005-source-revised/fc/cartridge/cartridge.cpp
index 57dc723..184974d 100644
--- a/../../../git/Emulator/bsnes/bsnes/fc/cartridge/cartridge.cpp
+++ b/nSide_v005-source-revised/fc/cartridge/cartridge.cpp
@@ -18,9 +18,34 @@ void Cartridge::main() {
   board->main();
 }
 
-void Cartridge::load() {
+void Cartridge::load(System::Revision revision) {
+  unload();
+
+  region = Region::NTSC;
+  system.revision = revision;
   interface->loadRequest(ID::Manifest, "manifest.bml");
 
+  if(revision == System::Revision::VSSystem) {
+    auto document = Markup::Document(information.markup);
+    cpu.status.vs_dip = interface->dipSettings(document["cartridge/vs"]);
+    string ppu_revision = document["cartridge/vs/ppu/revision"].data;
+    if(ppu_revision == "RP2C02C")     ppu.revision = PPU::Revision::RP2C02C;
+    if(ppu_revision == "RP2C02G")     ppu.revision = PPU::Revision::RP2C02G;
+    if(ppu_revision == "RP2C03B")     ppu.revision = PPU::Revision::RP2C03B;
+    if(ppu_revision == "RP2C03G")     ppu.revision = PPU::Revision::RP2C03G;
+    if(ppu_revision == "RP2C04-0001") ppu.revision = PPU::Revision::RP2C04_0001;
+    if(ppu_revision == "RP2C04-0002") ppu.revision = PPU::Revision::RP2C04_0002;
+    if(ppu_revision == "RP2C04-0003") ppu.revision = PPU::Revision::RP2C04_0003;
+    if(ppu_revision == "RP2C04-0004") ppu.revision = PPU::Revision::RP2C04_0004;
+    if(ppu_revision == "RC2C03B")     ppu.revision = PPU::Revision::RC2C03B;
+    if(ppu_revision == "RC2C03C")     ppu.revision = PPU::Revision::RC2C03C;
+    if(ppu_revision == "RC2C05-01")   ppu.revision = PPU::Revision::RC2C05_01;
+    if(ppu_revision == "RC2C05-02")   ppu.revision = PPU::Revision::RC2C05_02;
+    if(ppu_revision == "RC2C05-03")   ppu.revision = PPU::Revision::RC2C05_03;
+    if(ppu_revision == "RC2C05-04")   ppu.revision = PPU::Revision::RC2C05_04;
+    if(ppu_revision == "RC2C05-05")   ppu.revision = PPU::Revision::RC2C05_05;
+  }
+
   Board::load(information.markup);  //this call will set Cartridge::board if successful
   if(board == nullptr) return;
 
@@ -35,7 +60,7 @@ void Cartridge::load() {
   for(auto& byte : hash) result.append(hex<2>(byte));
   sha256 = result;
 
-  system.load();
+  system.load(revision);
   loaded = true;
 }
 
@@ -50,7 +75,7 @@ void Cartridge::power() {
 }
 
 void Cartridge::reset() {
-  create(Cartridge::Main, 21477272);
+  create(Cartridge::Main, system.cpu_frequency);
   board->reset();
 }
 
diff --git a/../../../git/Emulator/bsnes/bsnes/fc/cartridge/cartridge.hpp b/nSide_v005-source-revised/fc/cartridge/cartridge.hpp
index 4c0c50c..8e7114e 100644
--- a/../../../git/Emulator/bsnes/bsnes/fc/cartridge/cartridge.hpp
+++ b/nSide_v005-source-revised/fc/cartridge/cartridge.hpp
@@ -2,10 +2,15 @@
 #include "board/board.hpp"
 
 struct Cartridge : Thread, property<Cartridge> {
+  enum class Region : unsigned {
+    NTSC,
+    PAL,
+  };
+
   static void Main();
   void main();
 
-  void load();
+  void load(System::Revision revision);
   void unload();
 
   void power();
@@ -14,6 +19,8 @@ struct Cartridge : Thread, property<Cartridge> {
   readonly<bool> loaded;
   readonly<string> sha256;
 
+  Region region;
+
   struct Information {
     string markup;
     string title;
diff --git a/../../../git/Emulator/bsnes/bsnes/fc/cartridge/chip/chip.cpp b/nSide_v005-source-revised/fc/cartridge/chip/chip.cpp
index e3cabdc..44f003a 100644
--- a/../../../git/Emulator/bsnes/bsnes/fc/cartridge/chip/chip.cpp
+++ b/nSide_v005-source-revised/fc/cartridge/chip/chip.cpp
@@ -1,7 +1,9 @@
+#include "fcg.cpp"
 #include "mmc1.cpp"
 #include "mmc3.cpp"
 #include "mmc5.cpp"
 #include "mmc6.cpp"
+#include "namco-108.cpp"
 #include "vrc1.cpp"
 #include "vrc2.cpp"
 #include "vrc3.cpp"
diff --git a/nSide_v005-source-revised/fc/cartridge/chip/fcg.cpp b/nSide_v005-source-revised/fc/cartridge/chip/fcg.cpp
new file mode 100644
index 0000000..28e8228
--- /dev/null
+++ b/nSide_v005-source-revised/fc/cartridge/chip/fcg.cpp
@@ -0,0 +1,136 @@
+struct FCG : Chip {
+
+enum class Revision : unsigned {
+  FCG1,
+  FCG2,
+  LZ93D50,
+} revision;
+
+enum class EEPROM : unsigned {
+  None,
+  _24C01,
+  _24C02
+} eeprom;
+
+uint8 chr_bank[8];
+uint8 prg_bank;
+uint2 mirror;
+bool irq_counter_enable;
+uint16 irq_counter;
+uint16 irq_latch;
+bool eeprom_i2c_scl; // When using SRAM, enables RAM chip
+bool eeprom_enable_read;
+
+void main() {
+  while(true) {
+    if(scheduler.sync == Scheduler::SynchronizeMode::All) {
+      scheduler.exit(Scheduler::ExitReason::SynchronizeEvent);
+    }
+
+    if(irq_counter_enable) {
+      if(--irq_counter == 0xffff) {
+        cpu.set_irq_line(1);
+        irq_counter_enable = false;
+      }
+    }
+
+    tick();
+  }
+}
+
+unsigned prg_addr(unsigned addr) const {
+  bool region = addr & 0x4000;
+  return ((region == 0 ? prg_bank : 15) << 14) | (addr & 0x3fff);
+}
+
+unsigned chr_addr(unsigned addr) const {
+  return (chr_bank[addr >> 10] << 10) | (addr & 0x03ff);
+}
+
+unsigned ciram_addr(unsigned addr) const {
+  switch(mirror) {
+  case 0: return ((addr & 0x0400) >> 0) | (addr & 0x03ff);
+  case 1: return ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+  case 2: return 0x0000 | (addr & 0x03ff);
+  case 3: return 0x0400 | (addr & 0x03ff);
+  }
+}
+
+uint8 ram_read(unsigned addr) {
+  return board.prgram.data[addr & 0x1fff];
+}
+
+void ram_write(unsigned addr, uint8 data) {
+  board.prgram.data[addr & 0x1fff] = data;
+}
+
+void reg_write(unsigned addr, uint8 data) {
+  switch(addr & 0x0f) {
+  case 0x00: case 0x01: case 0x02: case 0x03:
+  case 0x04: case 0x05: case 0x06: case 0x07:
+    chr_bank[addr & 7] = data;
+    break;
+  case 0x08:
+    prg_bank = data & 0x0f;
+    break;
+  case 0x09:
+    mirror = data & 0x03;
+    break;
+  case 0x0a:
+    cpu.set_irq_line(0);
+    irq_counter_enable = data & 0x01;
+    irq_counter = irq_latch;
+    break;
+  case 0x0b:
+    irq_latch = (irq_latch & 0xff00) | (data << 0);
+    break;
+  case 0x0c:
+    irq_latch = (irq_latch & 0x00ff) | (data << 8);
+    break;
+  case 0x0d:
+    //TODO: serial EEPROM support
+    eeprom_i2c_scl = data & 0x20;
+    eeprom_enable_read = data & 0x80;
+    break;
+  }
+}
+
+void power() {
+  reset();
+}
+
+void reset() {
+  for(auto &n : chr_bank) n = 0;
+  prg_bank = 0;
+  mirror = 0;
+  irq_counter_enable = 0;
+  irq_counter = 0;
+  irq_latch = 0;
+  eeprom_i2c_scl = 0;
+  eeprom_enable_read = 0;
+}
+
+void serialize(serializer& s) {
+  s.array(chr_bank);
+  s.integer(prg_bank);
+  s.integer(mirror);
+  s.integer(irq_counter_enable);
+  s.integer(irq_counter);
+  s.integer(irq_latch);
+  s.integer(eeprom_i2c_scl);
+  s.integer(eeprom_enable_read);
+}
+
+FCG(Board& board, Markup::Node& document) : Chip(board) {
+  string type = document["cartridge/chip[0]/type"].data;
+  if(type.match("*FCG-1*"  )) revision = Revision::FCG1;
+  if(type.match("*FCG-2*"  )) revision = Revision::FCG2;
+  if(type.match("*LZ93D50*")) revision = Revision::LZ93D50;
+
+  eeprom = EEPROM::None;
+  type = document["cartridge/chip[1]/type"].data;
+  if(type.match("*24C01*"  )) eeprom = EEPROM::_24C01;
+  if(type.match("*24C02*"  )) eeprom = EEPROM::_24C02;
+}
+
+};
diff --git a/../../../git/Emulator/bsnes/bsnes/fc/cartridge/chip/mmc1.cpp b/nSide_v005-source-revised/fc/cartridge/chip/mmc1.cpp
index 3983bda..a1e5c44 100644
--- a/../../../git/Emulator/bsnes/bsnes/fc/cartridge/chip/mmc1.cpp
+++ b/nSide_v005-source-revised/fc/cartridge/chip/mmc1.cpp
@@ -89,7 +89,7 @@ void mmio_write(unsigned addr, uint8 data) {
         break;
 
       case 3:
-        ram_disable = (shiftdata & 0x10);
+        ram_disable = ((shiftdata & 0x10) && revision != Revision::MMC1 && revision != Revision::MMC1A);
         prg_bank = (shiftdata & 0x0f);
         break;
       }
@@ -111,7 +111,7 @@ void reset() {
   mirror = 0;
   chr_bank[0] = 0;
   chr_bank[1] = 1;
-  ram_disable = 0;
+  ram_disable = revision == Revision::MMC1C;
   prg_bank = 0;
 }
 
@@ -129,8 +129,15 @@ void serialize(serializer& s) {
   s.integer(prg_bank);
 }
 
-MMC1(Board& board) : Chip(board) {
-  revision = Revision::MMC1B2;
+MMC1(Board& board, Markup::Node& document) : Chip(board) {
+  string type = document["cartridge/chip/type"].data;
+
+  if(type.match("*MMC1*"  )) revision = Revision::MMC1;
+  if(type.match("*MMC1A*" )) revision = Revision::MMC1A;
+  if(type.match("*MMC1B1*")) revision = Revision::MMC1B1;
+  if(type.match("*MMC1B2*")) revision = Revision::MMC1B2;
+  if(type.match("*MMC1B3*")) revision = Revision::MMC1B3;
+  if(type.match("*MMC1C*" )) revision = Revision::MMC1C;
 }
 
 };
diff --git a/../../../git/Emulator/bsnes/bsnes/fc/cartridge/chip/mmc3.cpp b/nSide_v005-source-revised/fc/cartridge/chip/mmc3.cpp
index a051d91..6e93fba 100644
--- a/../../../git/Emulator/bsnes/bsnes/fc/cartridge/chip/mmc3.cpp
+++ b/nSide_v005-source-revised/fc/cartridge/chip/mmc3.cpp
@@ -1,5 +1,13 @@
 struct MMC3 : Chip {
 
+enum class Revision : unsigned {
+  MMC3,
+  MMC3A,
+  MMC3B,
+  MMC3C,
+  MCACC,
+} revision;
+
 bool chr_mode;
 bool prg_mode;
 uint3 bank_select;
@@ -38,6 +46,7 @@ void irq_test(unsigned addr) {
       }
     }
     irq_delay = 6;
+    //if(revision == Revision::MCACC) irq_delay += 88;
   }
   chr_abus = addr;
 }
@@ -183,7 +192,13 @@ void serialize(serializer& s) {
   s.integer(chr_abus);
 }
 
-MMC3(Board& board) : Chip(board) {
+MMC3(Board& board, Markup::Node& document) : Chip(board) {
+  string type = document["cartridge/chip/type"].data;
+  if(type.match("*MMC3*"  )) revision = Revision::MMC3;
+  if(type.match("*MMC3A*" )) revision = Revision::MMC3A;
+  if(type.match("*MMC3B*" )) revision = Revision::MMC3B;
+  if(type.match("*MMC3C*" )) revision = Revision::MMC3C;
+  if(type.match("*MC-ACC*")) revision = Revision::MCACC;
 }
 
 };
diff --git a/../../../git/Emulator/bsnes/bsnes/fc/cartridge/chip/mmc5.cpp b/nSide_v005-source-revised/fc/cartridge/chip/mmc5.cpp
index 5cd94fa..1029b59 100644
--- a/../../../git/Emulator/bsnes/bsnes/fc/cartridge/chip/mmc5.cpp
+++ b/nSide_v005-source-revised/fc/cartridge/chip/mmc5.cpp
@@ -279,13 +279,13 @@ unsigned chr_sprite_addr(unsigned addr) {
 }
 
 unsigned chr_bg_addr(unsigned addr) {
-  addr &= 0x0fff;
-
   if(chr_mode == 0) {
     auto bank = chr_bg_bank[3];
-    return (bank * 0x2000) + (addr & 0x0fff);
+    return (bank * 0x2000) + (addr & 0x1fff);
   }
 
+  addr &= 0x0fff;
+
   if(chr_mode == 1) {
     auto bank = chr_bg_bank[3];
     return (bank * 0x1000) + (addr & 0x0fff);
@@ -490,8 +490,11 @@ void serialize(serializer& s) {
   s.integer(vs_hpos);
 }
 
-MMC5(Board& board) : Chip(board) {
-  revision = Revision::MMC5;
+MMC5(Board& board, Markup::Node& document) : Chip(board) {
+  string type = document["cartridge/chip/type"].data;
+
+  if(type.match("*MMC5*" )) revision = Revision::MMC5;
+  if(type.match("*MMC5B*")) revision = Revision::MMC5B;
 }
 
 };
diff --git a/nSide_v005-source-revised/fc/cartridge/chip/namco-108.cpp b/nSide_v005-source-revised/fc/cartridge/chip/namco-108.cpp
new file mode 100644
index 0000000..3cb0abe
--- /dev/null
+++ b/nSide_v005-source-revised/fc/cartridge/chip/namco-108.cpp
@@ -0,0 +1,83 @@
+struct Namco108 : Chip {
+
+enum class Revision : unsigned {
+  Namco108,
+  Namco109,
+  Namco118,
+  Namco119,
+} revision;
+
+uint3 bank_select;
+uint8 prg_bank[2];
+uint8 chr_bank[6];
+
+unsigned prg_addr(unsigned addr) const {
+  switch((addr >> 13) & 3) {
+  case 0: return (prg_bank[0] << 13) | (addr & 0x1fff);
+  case 1: return (prg_bank[1] << 13) | (addr & 0x1fff);
+  case 2: return (0x0e << 13) | (addr & 0x1fff);
+  case 3: return (0x0f << 13) | (addr & 0x1fff);
+  }
+}
+
+unsigned chr_addr(unsigned addr) const {
+  if(addr <= 0x07ff) return (chr_bank[0] << 10) | (addr & 0x07ff);
+  if(addr <= 0x0fff) return (chr_bank[1] << 10) | (addr & 0x07ff);
+  if(addr <= 0x13ff) return (chr_bank[2] << 10) | (addr & 0x03ff);
+  if(addr <= 0x17ff) return (chr_bank[3] << 10) | (addr & 0x03ff);
+  if(addr <= 0x1bff) return (chr_bank[4] << 10) | (addr & 0x03ff);
+  if(addr <= 0x1fff) return (chr_bank[5] << 10) | (addr & 0x03ff);
+}
+
+void reg_write(unsigned addr, uint8 data) {
+  switch(addr & 0x8001) {
+  case 0x8000:
+    bank_select = data & 0x07;
+    break;
+
+  case 0x8001:
+    switch(bank_select) {
+    case 0: chr_bank[0] = data & 0x3e; break;
+    case 1: chr_bank[1] = data & 0x3e; break;
+    case 2: chr_bank[2] = data & 0x3f; break;
+    case 3: chr_bank[3] = data & 0x3f; break;
+    case 4: chr_bank[4] = data & 0x3f; break;
+    case 5: chr_bank[5] = data & 0x3f; break;
+    case 6: prg_bank[0] = data & 0x0f; break;
+    case 7: prg_bank[1] = data & 0x0f; break;
+    }
+    break;
+  }
+}
+
+void power() {
+}
+
+void reset() {
+  bank_select = 0;
+  prg_bank[0] = 0;
+  prg_bank[1] = 0;
+  chr_bank[0] = 0;
+  chr_bank[1] = 0;
+  chr_bank[2] = 0;
+  chr_bank[3] = 0;
+  chr_bank[4] = 0;
+  chr_bank[5] = 0;
+}
+
+void serialize(serializer& s) {
+  s.integer(bank_select);
+  s.array(prg_bank);
+  s.array(chr_bank);
+}
+
+Namco108(Board& board, Markup::Node& document) : Chip(board) {
+  string type = document["cartridge/chip/type"].data;
+
+  if(type.match("*108*")) revision = Revision::Namco108;
+  if(type.match("*109*")) revision = Revision::Namco109;
+  if(type.match("*118*")) revision = Revision::Namco118;
+  if(type.match("*119*")) revision = Revision::Namco119;
+}
+
+};
diff --git a/../../../git/Emulator/bsnes/bsnes/fc/cheat/cheat.cpp b/nSide_v005-source-revised/fc/cheat/cheat.cpp
index 3d1e1f5..7385455 100644
--- a/../../../git/Emulator/bsnes/bsnes/fc/cheat/cheat.cpp
+++ b/nSide_v005-source-revised/fc/cheat/cheat.cpp
@@ -16,13 +16,13 @@ void Cheat::append(unsigned addr, unsigned comp, unsigned data) {
   codes.append({addr, comp, data});
 }
 
-maybe<unsigned> Cheat::find(unsigned addr, unsigned comp) {
+optional<unsigned> Cheat::find(unsigned addr, unsigned comp) {
   for(auto& code : codes) {
     if(code.addr == addr && (code.comp == Unused || code.comp == comp)) {
-      return code.data;
+      return {true, code.data};
     }
   }
-  return nothing;
+  return false;
 }
 
 }
diff --git a/../../../git/Emulator/bsnes/bsnes/fc/cheat/cheat.hpp b/nSide_v005-source-revised/fc/cheat/cheat.hpp
index 43f2d05..c1cb490 100644
--- a/../../../git/Emulator/bsnes/bsnes/fc/cheat/cheat.hpp
+++ b/nSide_v005-source-revised/fc/cheat/cheat.hpp
@@ -11,7 +11,7 @@ struct Cheat {
   void reset();
   void append(unsigned addr, unsigned data);
   void append(unsigned addr, unsigned comp, unsigned data);
-  maybe<unsigned> find(unsigned addr, unsigned comp);
+  optional<unsigned> find(unsigned addr, unsigned comp);
 };
 
 extern Cheat cheat;
diff --git a/nSide_v005-source-revised/fc/controller/beamgun/beamgun.cpp b/nSide_v005-source-revised/fc/controller/beamgun/beamgun.cpp
new file mode 100644
index 0000000..cc69a43
--- /dev/null
+++ b/nSide_v005-source-revised/fc/controller/beamgun/beamgun.cpp
@@ -0,0 +1,70 @@
+#ifdef CONTROLLER_CPP
+
+void BeamGun::enter() {
+  unsigned prev = 0;
+  while(true) {
+    unsigned next = ppu.status.ly * 341 + ppu.status.lx;
+
+    if(offscreen == false) {
+      unsigned target = y * 341 + x + 6;
+      if(next >= target && prev < target) {
+        //CRT raster detected
+        light = read_light();
+      }
+    }
+
+    if(next < prev) {
+      //Vcounter wrapped back to zero; update cursor coordinates for start of new frame
+      int nx = interface->inputPoll(port, (unsigned)Input::Device::BeamGun, (unsigned)Input::BeamGunID::X);
+      int ny = interface->inputPoll(port, (unsigned)Input::Device::BeamGun, (unsigned)Input::BeamGunID::Y);
+      nx += x;
+      ny += y;
+      x = max(-16, min(256 + 16, nx));
+      y = max(-16, min(240 + 16, ny));
+      offscreen = (x < 0 || y < 0 || x >= 256 || y >= 240);
+    }
+
+    prev = next;
+    step(2);
+  }
+}
+
+uint5 BeamGun::data() {
+  bool trigger = interface->inputPoll(port, (unsigned)Input::Device::BeamGun, (unsigned)Input::BeamGunID::Trigger);
+
+  return (trigger << 4) | ((!light) << 3);
+}
+
+uint2 BeamGun::data1() {
+  return 0;
+}
+
+uint5 BeamGun::data2() {
+  return data();
+}
+
+bool BeamGun::read_light() {
+  if(offscreen) return false;
+  //print("Begin Beam Gun Light Report\n");
+  //print(ppu.status.ly >= 240, "\n");
+  uint32 color = ppu.buffer[y * 256 + x];
+  //print("0x", hex(color), " -> 0x", hex(color & 0x3F), "\n");
+  //print("\n");
+  return ((color & 0x20) && ((color & 0x0F) < 0x0D));
+}
+
+void BeamGun::latch(bool data) {
+  if(latched == data) return;
+  latched = data;
+}
+
+BeamGun::BeamGun(uint2 port) : Controller(port) {
+  create(Controller::Enter, system.cpu_frequency);
+  latched = 0;
+
+  //center cursor onscreen
+  x = 256 / 2;
+  y = 240 / 2;
+}
+
+#endif
diff --git a/nSide_v005-source-revised/fc/controller/beamgun/beamgun.hpp b/nSide_v005-source-revised/fc/controller/beamgun/beamgun.hpp
new file mode 100644
index 0000000..dbea8fe
--- /dev/null
+++ b/nSide_v005-source-revised/fc/controller/beamgun/beamgun.hpp
@@ -0,0 +1,17 @@
+struct BeamGun : Controller {
+  void enter();
+  uint5 data();
+  uint2 data1();
+  uint5 data2();
+  bool read_light();
+  void latch(bool data);
+  BeamGun(uint2 port);
+
+//private:
+  bool latched;
+
+  signed x, y;
+
+  bool light;
+  bool offscreen;
+};
diff --git a/nSide_v005-source-revised/fc/controller/controller.cpp b/nSide_v005-source-revised/fc/controller/controller.cpp
new file mode 100644
index 0000000..ffcc8f4
--- /dev/null
+++ b/nSide_v005-source-revised/fc/controller/controller.cpp
@@ -0,0 +1,40 @@
+#include <fc/fc.hpp>
+
+#define CONTROLLER_CPP
+namespace Famicom {
+
+#include "gamepad/gamepad.cpp"
+#include "fourplayers/fourplayers.cpp"
+#include "fourscore/fourscore.cpp"
+#include "beamgun/beamgun.cpp"
+#include "familytrainer/familytrainer.cpp"
+#include "vspanel/vspanel.cpp"
+
+void Controller::Enter() {
+  if(co_active() == input.port1->thread) input.port1->enter();
+  if(co_active() == input.port2->thread) input.port2->enter();
+  if(co_active() == input.expansion->thread) input.expansion->enter();
+}
+
+void Controller::enter() {
+  while(true) step(1);
+}
+
+void Controller::step(unsigned clocks) {
+  clock += clocks * (uint64)cpu.frequency;
+  synchronize_cpu();
+}
+
+void Controller::synchronize_cpu() {
+  if(CPU::Threaded == true) {
+    if(clock >= 0 && scheduler.sync != Scheduler::SynchronizeMode::All) co_switch(cpu.thread);
+  } else {
+    while(clock >= 0) cpu.enter();
+  }
+}
+
+Controller::Controller(unsigned port) : port(port) {
+  if(!thread) create(Controller::Enter, 1);
+}
+
+}
diff --git a/nSide_v005-source-revised/fc/controller/controller.hpp b/nSide_v005-source-revised/fc/controller/controller.hpp
new file mode 100644
index 0000000..c4839e1
--- /dev/null
+++ b/nSide_v005-source-revised/fc/controller/controller.hpp
@@ -0,0 +1,38 @@
+// NES controller port pinout:
+// ┌────
+// │(7)  \
+// │(2)(1)│
+// │(3)(5)│
+// │(4)(6)│
+// └──────┘
+// pin    name     port1                            port2
+//  1:    +5v
+//  2:    clock    $4016 read                       $4017 read
+//  3:    latch    $4016.d0 write                   $4016.d0 write
+//  4:    data0    $4016.d0 read                    $4017.d0 read
+//  5:    data3    $4016.d3 read                    $4017.d3 read
+//  6:    data4    $4016.d4 read                    $4017.d4 read
+//  7:    gnd
+
+struct Controller : Thread {
+  enum : unsigned { Port1 = 0, Port2 = 1, ExpansionPort = 2 };
+  const uint2 port;
+
+  static void Enter();
+  virtual void enter();
+  void step(unsigned clocks);
+  void synchronize_cpu();
+
+  virtual uint5 data() { return 0; }
+  virtual uint2 data1() { return 0; }
+  virtual uint5 data2() { return 0; }
+  virtual void latch(bool data) {}
+  Controller(unsigned port);
+};
+
+#include "gamepad/gamepad.hpp"
+#include "fourplayers/fourplayers.hpp"
+#include "fourscore/fourscore.hpp"
+#include "beamgun/beamgun.hpp"
+#include "familytrainer/familytrainer.hpp"
+#include "vspanel/vspanel.hpp"
diff --git a/nSide_v005-source-revised/fc/controller/familytrainer/familytrainer.cpp b/nSide_v005-source-revised/fc/controller/familytrainer/familytrainer.cpp
new file mode 100644
index 0000000..980ab72
--- /dev/null
+++ b/nSide_v005-source-revised/fc/controller/familytrainer/familytrainer.cpp
@@ -0,0 +1,57 @@
+#ifdef CONTROLLER_CPP
+
+uint5 FamilyTrainer::data() {
+  if(counter >= 8) return 0x18;
+  if(latched == 1) return (b2 << 3) | (b4 << 4);
+
+  switch(counter++) {
+  case  0: return (b2  << 3) | (b4  << 4);
+  case  1: return (b1  << 3) | (b3  << 4);
+  case  2: return (b5  << 3) | (b12 << 4);
+  case  3: return (b9  << 3) | (b8  << 4);
+  case  4: return (b6  << 3) | 0x10;
+  case  5: return (b10 << 3) | 0x10;
+  case  6: return (b11 << 3) | 0x10;
+  case  7: return (b7  << 3) | 0x10;
+  }
+}
+
+uint2 FamilyTrainer::data1() {
+  return 0;
+}
+
+uint5 FamilyTrainer::data2() {
+  return data();
+}
+
+void FamilyTrainer::latch(bool data) {
+  if(latched == data) return;
+  latched = data;
+  counter = 0;
+
+  if(latched == 0) {
+    b1  = interface->inputPoll(port, (unsigned)Input::Device::FamilyTrainer,  0);
+    b2  = interface->inputPoll(port, (unsigned)Input::Device::FamilyTrainer,  1);
+    b3  = interface->inputPoll(port, (unsigned)Input::Device::FamilyTrainer,  2);
+    b4  = interface->inputPoll(port, (unsigned)Input::Device::FamilyTrainer,  3);
+    b5  = interface->inputPoll(port, (unsigned)Input::Device::FamilyTrainer,  4);
+    b6  = interface->inputPoll(port, (unsigned)Input::Device::FamilyTrainer,  5);
+    b7  = interface->inputPoll(port, (unsigned)Input::Device::FamilyTrainer,  6);
+    b8  = interface->inputPoll(port, (unsigned)Input::Device::FamilyTrainer,  7);
+    b9  = interface->inputPoll(port, (unsigned)Input::Device::FamilyTrainer,  8);
+    b10 = interface->inputPoll(port, (unsigned)Input::Device::FamilyTrainer,  9);
+    b11 = interface->inputPoll(port, (unsigned)Input::Device::FamilyTrainer, 10);
+    b12 = interface->inputPoll(port, (unsigned)Input::Device::FamilyTrainer, 11);
+  }
+}
+
+FamilyTrainer::FamilyTrainer(uint2 port) : Controller(port) {
+  latched = 0;
+  counter = 0;
+
+  b1 = b2 = b3 = b4 = 0;
+  b5 = b6 = b7 = b8 = 0;
+  b9 = b10 = b11 = b12 = 0;
+}
+
+#endif
diff --git a/nSide_v005-source-revised/fc/controller/familytrainer/familytrainer.hpp b/nSide_v005-source-revised/fc/controller/familytrainer/familytrainer.hpp
new file mode 100644
index 0000000..2b97aea
--- /dev/null
+++ b/nSide_v005-source-revised/fc/controller/familytrainer/familytrainer.hpp
@@ -0,0 +1,15 @@
+struct FamilyTrainer : Controller {
+  uint5 data();
+  uint2 data1();
+  uint5 data2();
+  void latch(bool data);
+  FamilyTrainer(uint2 port);
+
+private:
+  bool latched;
+  unsigned counter;
+
+  bool b1, b2, b3, b4;
+  bool b5, b6, b7, b8;
+  bool b9, b10, b11, b12;
+};
diff --git a/nSide_v005-source-revised/fc/controller/fourplayers/fourplayers.cpp b/nSide_v005-source-revised/fc/controller/fourplayers/fourplayers.cpp
new file mode 100644
index 0000000..9651d34
--- /dev/null
+++ b/nSide_v005-source-revised/fc/controller/fourplayers/fourplayers.cpp
@@ -0,0 +1,30 @@
+#ifdef CONTROLLER_CPP
+
+uint2 FourPlayers::data1() {
+  if(counter1 >= 8) return 2;
+  if(latched) return interface->inputPoll(port, (unsigned)Input::Device::FourPlayers, 0) << 1;
+
+  return interface->inputPoll(port, (unsigned)Input::Device::FourPlayers, counter1++) << 1;
+}
+
+uint5 FourPlayers::data2() {
+  if(counter2 >= 8) return 2;
+  if(latched) return interface->inputPoll(port, (unsigned)Input::Device::FourPlayers, 8) << 1;
+
+  return interface->inputPoll(port, (unsigned)Input::Device::FourPlayers, (counter2++) + 8) << 1;
+}
+
+void FourPlayers::latch(bool data) {
+  if(latched == data) return;
+  latched = data;
+  counter1 = 0;
+  counter2 = 0;
+}
+
+FourPlayers::FourPlayers(uint2 port) : Controller(port) {
+  latched = 0;
+  counter1 = 0;
+  counter2 = 0;
+}
+
+#endif
diff --git a/nSide_v005-source-revised/fc/controller/fourplayers/fourplayers.hpp b/nSide_v005-source-revised/fc/controller/fourplayers/fourplayers.hpp
new file mode 100644
index 0000000..0341b4e
--- /dev/null
+++ b/nSide_v005-source-revised/fc/controller/fourplayers/fourplayers.hpp
@@ -0,0 +1,11 @@
+struct FourPlayers : Controller {
+  uint2 data1();
+  uint5 data2();
+  void latch(bool data);
+  FourPlayers(uint2 port);
+
+private:
+  bool latched;
+  unsigned counter1;
+  unsigned counter2;
+};
diff --git a/nSide_v005-source-revised/fc/controller/fourscore/fourscore.cpp b/nSide_v005-source-revised/fc/controller/fourscore/fourscore.cpp
new file mode 100644
index 0000000..5be00fc
--- /dev/null
+++ b/nSide_v005-source-revised/fc/controller/fourscore/fourscore.cpp
@@ -0,0 +1,26 @@
+#ifdef CONTROLLER_CPP
+
+uint5 FourScore::data() {
+  if(counter >= 24) return 1;
+  if(latched) return interface->inputPoll(port, (unsigned)Input::Device::FourScore, 0);
+  uint5 data = 0;
+
+  if(counter >= 16) data = counter == (19 - port);
+  else data = interface->inputPoll(port, (unsigned)Input::Device::FourScore, counter);
+  counter++;
+
+  return data;
+}
+
+void FourScore::latch(bool data) {
+  if(latched == data) return;
+  latched = data;
+  counter = 0;
+}
+
+FourScore::FourScore(uint2 port) : Controller(port) {
+  latched = 0;
+  counter = 0;
+}
+
+#endif
diff --git a/nSide_v005-source-revised/fc/controller/fourscore/fourscore.hpp b/nSide_v005-source-revised/fc/controller/fourscore/fourscore.hpp
new file mode 100644
index 0000000..bcff081
--- /dev/null
+++ b/nSide_v005-source-revised/fc/controller/fourscore/fourscore.hpp
@@ -0,0 +1,9 @@
+struct FourScore : Controller {
+  uint5 data();
+  void latch(bool data);
+  FourScore(uint2 port);
+
+private:
+  bool latched;
+  unsigned counter;
+};
diff --git a/nSide_v005-source-revised/fc/controller/gamepad/gamepad.cpp b/nSide_v005-source-revised/fc/controller/gamepad/gamepad.cpp
new file mode 100644
index 0000000..1156e3a
--- /dev/null
+++ b/nSide_v005-source-revised/fc/controller/gamepad/gamepad.cpp
@@ -0,0 +1,59 @@
+#ifdef CONTROLLER_CPP
+
+uint5 Gamepad::data() {
+  if(counter >= 8) return 1;
+  if(latched == 1) return interface->inputPoll(port, (unsigned)Input::Device::Joypad, (unsigned)Input::JoypadID::A);
+
+  //note: D-pad physically prevents up+down and left+right from being pressed at the same time
+  switch(counter++) {
+  case  0: return a;
+  case  1: return b;
+  case  2: return select;
+  case  3: return start;
+  case  4: return up & !down;
+  case  5: return down & !up;
+  case  6: return left & !right;
+  case  7: return right & !left;
+  }
+}
+
+uint2 Gamepad::data1() {
+  return ((data() << 1) & 0x02);
+}
+
+uint5 Gamepad::data2() {
+  return 0;
+}
+
+void Gamepad::latch(bool data) {
+  if(latched == data) return;
+  latched = data;
+  counter = 0;
+
+  if(latched == 0) {
+    unsigned id = (unsigned)Input::Device::Joypad;
+    a      = interface->inputPoll(port, id,  0);
+    b      = interface->inputPoll(port, id,  1);
+    if(!system.vs()) {
+      select = interface->inputPoll(port, id,  2);
+      start  = interface->inputPoll(port, id,  3);
+    } else {
+      select = 0;
+      start  = 0;
+    }
+    up     = interface->inputPoll(port, id,  4);
+    down   = interface->inputPoll(port, id,  5);
+    left   = interface->inputPoll(port, id,  6);
+    right  = interface->inputPoll(port, id,  7);
+  }
+}
+
+Gamepad::Gamepad(uint2 port) : Controller(port) {
+  latched = 0;
+  counter = 0;
+
+  a = b = select = start = 0;
+  up = down = left = right = 0;
+}
+
+#endif
diff --git a/nSide_v005-source-revised/fc/controller/gamepad/gamepad.hpp b/nSide_v005-source-revised/fc/controller/gamepad/gamepad.hpp
new file mode 100644
index 0000000..086e0d7
--- /dev/null
+++ b/nSide_v005-source-revised/fc/controller/gamepad/gamepad.hpp
@@ -0,0 +1,14 @@
+struct Gamepad : Controller {
+  uint5 data();
+  uint2 data1();
+  uint5 data2();
+  void latch(bool data);
+  Gamepad(uint2 port);
+
+private:
+  bool latched;
+  unsigned counter;
+
+  bool a, b, select, start;
+  bool up, down, left, right;
+};
diff --git a/nSide_v005-source-revised/fc/controller/vspanel/vspanel.cpp b/nSide_v005-source-revised/fc/controller/vspanel/vspanel.cpp
new file mode 100644
index 0000000..c0ff571
--- /dev/null
+++ b/nSide_v005-source-revised/fc/controller/vspanel/vspanel.cpp
@@ -0,0 +1,54 @@
+#ifdef CONTROLLER_CPP
+
+uint5 VSPanel::data() {
+  unsigned data = 0x00;
+  if(interface->inputPoll(port, (unsigned)Input::Device::VSPanel, 4)) data |= 0x01; // service button
+  if(interface->inputPoll(port, (unsigned)Input::Device::VSPanel, 5)) data |= 0x08; // coin 1
+  if(interface->inputPoll(port, (unsigned)Input::Device::VSPanel, 6)) data |= 0x10; // coin 2
+  // data will be left-shifted twice and OR'd into $4016 in CPU
+  return data;
+}
+
+uint2 VSPanel::data1() {
+  if(counter1 >= 8) return 1;
+  if(latched == 1) return 0;
+
+  switch(counter1++) { default: return 0;
+  case 2: return b1;
+  case 3: return b3;
+  }
+}
+
+uint5 VSPanel::data2() {
+  if(counter2 >= 8) return 1;
+  if(latched == 1) return 0;
+
+  switch(counter2++) { default: return 0;
+  case 2: return b2;
+  case 3: return b4;
+  }
+}
+
+void VSPanel::latch(bool data) {
+  if(latched == data) return;
+  latched = data;
+  counter1 = 0;
+  counter2 = 0;
+
+  if(latched == 0) {
+    b1 = interface->inputPoll(port, (unsigned)Input::Device::VSPanel, 0);
+    b2 = interface->inputPoll(port, (unsigned)Input::Device::VSPanel, 1);
+    b3 = interface->inputPoll(port, (unsigned)Input::Device::VSPanel, 2);
+    b4 = interface->inputPoll(port, (unsigned)Input::Device::VSPanel, 3);
+  }
+}
+
+VSPanel::VSPanel(uint2 port) : Controller(port) {
+  latched = 0;
+  counter1 = 0;
+  counter2 = 0;
+
+  b1 = b2 = b3 = b4 = 0;
+}
+
+#endif
diff --git a/nSide_v005-source-revised/fc/controller/vspanel/vspanel.hpp b/nSide_v005-source-revised/fc/controller/vspanel/vspanel.hpp
new file mode 100644
index 0000000..4d29370
--- /dev/null
+++ b/nSide_v005-source-revised/fc/controller/vspanel/vspanel.hpp
@@ -0,0 +1,14 @@
+struct VSPanel : Controller {
+  uint5 data();
+  uint2 data1();
+  uint5 data2();
+  void latch(bool data);
+  VSPanel(uint2 port);
+
+private:
+  bool latched;
+  unsigned counter1;
+  unsigned counter2;
+
+  bool b1, b2, b3, b4;
+};
diff --git a/../../../git/Emulator/bsnes/bsnes/fc/cpu/cpu.cpp b/nSide_v005-source-revised/fc/cpu/cpu.cpp
index 652e138..3ebd34f 100644
--- a/../../../git/Emulator/bsnes/bsnes/fc/cpu/cpu.cpp
+++ b/nSide_v005-source-revised/fc/cpu/cpu.cpp
@@ -2,11 +2,35 @@
 
 namespace Famicom {
 
-#include "timing.cpp"
 #include "serialization.cpp"
+#include "timing/timing.cpp"
 CPU cpu;
 
-void CPU::Enter() {
+void CPU::step(unsigned clocks) {
+  apu.clock -= clocks;
+  if(apu.clock < 0 && scheduler.sync != Scheduler::SynchronizeMode::All) co_switch(apu.thread);
+
+  ppu.clock -= clocks;
+  if(ppu.clock < 0 && scheduler.sync != Scheduler::SynchronizeMode::All) co_switch(ppu.thread);
+
+  cartridge.clock -= clocks;
+  if(cartridge.clock < 0 && scheduler.sync != Scheduler::SynchronizeMode::All) co_switch(cartridge.thread);
+
+  input.port1->clock -= clocks * (uint64)input.port1->frequency;
+  input.port2->clock -= clocks * (uint64)input.port2->frequency;
+  input.expansion->clock -= clocks * (uint64)input.expansion->frequency;
+  synchronize_controllers();
+}
+
+void CPU::synchronize_controllers() {
+  if(input.port1->clock < 0) co_switch(input.port1->thread);
+  if(input.port2->clock < 0) co_switch(input.port2->thread);
+  if(input.expansion->clock < 0) co_switch(input.expansion->thread);
+}
+
+void CPU::Enter() { cpu.enter(); }
+
+void CPU::enter() {
   while(true) {
     if(scheduler.sync == Scheduler::SynchronizeMode::All) {
       scheduler.exit(Scheduler::ExitReason::SynchronizeEvent);
@@ -25,17 +49,6 @@ void CPU::main() {
   exec();
 }
 
-void CPU::add_clocks(unsigned clocks) {
-  apu.clock -= clocks;
-  if(apu.clock < 0 && scheduler.sync != Scheduler::SynchronizeMode::All) co_switch(apu.thread);
-
-  ppu.clock -= clocks;
-  if(ppu.clock < 0 && scheduler.sync != Scheduler::SynchronizeMode::All) co_switch(ppu.thread);
-
-  cartridge.clock -= clocks;
-  if(cartridge.clock < 0 && scheduler.sync != Scheduler::SynchronizeMode::All) co_switch(cartridge.thread);
-}
-
 void CPU::power() {
   R6502::power();
 
@@ -48,7 +61,7 @@ void CPU::power() {
 
 void CPU::reset() {
   R6502::reset();
-  create(CPU::Enter, 21477272);
+  create(CPU::Enter, system.cpu_frequency);
 
   regs.pc  = bus.read(0xfffc) << 0;
   regs.pc |= bus.read(0xfffd) << 8;
@@ -84,12 +97,36 @@ void CPU::ram_write(uint16 addr, uint8 data) {
 }
 
 uint8 CPU::read(uint16 addr) {
-  if(addr == 0x4016) {
-    return (mdr() & 0xc0) | input.data(0);
-  }
+  if(system.revision != System::Revision::VSSystem) {
+    if(addr == 0x4016) {
+      return (mdr() & 0xe0) | input.port1->data() | input.expansion->data1();
+    }
 
-  if(addr == 0x4017) {
-    return (mdr() & 0xc0) | input.data(1);
+    if(addr == 0x4017) {
+      return (mdr() & 0xe0) | input.port2->data() | input.expansion->data2();
+    }
+  } else { // if using VS. System
+    uint8 data;
+    if(addr == 0x4016) {
+      data = 0x80; // 0x00 for slave CPU, 0x80 for master CPU
+      data |= input.port2->data() & 0x03;
+      data |= input.expansion->data1(); // buttons 1 and 3
+      data |= (status.vs_dip & 0x03) << 3;
+      data |= input.expansion->data() << 2; // Service button and coins
+      return data;
+    }
+
+    if(addr == 0x4017) {
+      data = 0x00;
+      data |= input.port1->data() & 0x03;
+      data |= input.expansion->data2(); // buttons 2 and 4
+      data |= status.vs_dip & 0xfc;
+      return data;
+    }
+
+    if(addr >= 0x4020 && addr <= 0x5fff) {
+      write(addr, cpu.mdr());
+    }
   }
 
   return apu.read(addr);
@@ -101,8 +138,22 @@ void CPU::write(uint16 addr, uint8 data) {
     status.oam_dma_pending = true;
   }
 
-  if(addr == 0x4016) {
-    input.latch(data & 0x01);
+  if(system.revision != System::Revision::VSSystem) {
+    if(addr == 0x4016) {
+      input.port1->latch(data & 1);
+      input.port2->latch(data & 1);
+      input.expansion->latch(data & 1);
+    }
+  } else { // if using VS. System
+    if(addr == 0x4016) {
+      input.port1->latch(data & 1);
+      input.port2->latch(data & 1);
+      input.expansion->latch(data & 1);
+    }
+
+    //if(addr >= 0x4020 && addr <= 0x5fff) {
+      // increment coin counter
+    //}
   }
 
   return apu.write(addr, data);
diff --git a/../../../git/Emulator/bsnes/bsnes/fc/cpu/cpu.hpp b/nSide_v005-source-revised/fc/cpu/cpu.hpp
index b265292..fd0ac04 100644
--- a/../../../git/Emulator/bsnes/bsnes/fc/cpu/cpu.hpp
+++ b/nSide_v005-source-revised/fc/cpu/cpu.hpp
@@ -1,6 +1,28 @@
 struct CPU : Processor::R6502, Thread {
   uint8 ram[0x0800];
 
+  enum : bool { Threaded = true };
+  alwaysinline void step(unsigned clocks);
+  void synchronize_controllers();
+
+  void enter();
+  void main();
+  void power();
+  void reset();
+
+  uint8 debugger_read(uint16 addr);
+
+  uint8 ram_read(uint16 addr);
+  void ram_write(uint16 addr, uint8 data);
+
+  uint8 read(uint16 addr);
+  void write(uint16 addr, uint8 data);
+
+  void serialize(serializer&);
+
+//privileged:
+  #include "timing/timing.hpp"
+
   struct Status {
     bool interrupt_pending;
     bool nmi_pending;
@@ -18,39 +40,10 @@ struct CPU : Processor::R6502, Thread {
     bool controller_latch;
     unsigned controller_port0;
     unsigned controller_port1;
+    uint8 vs_dip;
   } status;
 
   static void Enter();
-  void main();
-  void add_clocks(unsigned clocks);
-
-  void power();
-  void reset();
-
-  uint8 debugger_read(uint16 addr);
-
-  uint8 ram_read(uint16 addr);
-  void ram_write(uint16 addr, uint8 data);
-
-  uint8 read(uint16 addr);
-  void write(uint16 addr, uint8 data);
-
-  void serialize(serializer&);
-
-  //timing.cpp
-  uint8 op_read(uint16 addr);
-  void op_write(uint16 addr, uint8 data);
-  void last_cycle();
-  void nmi(uint16 &vector);
-
-  void oam_dma();
-
-  void set_nmi_line(bool);
-  void set_irq_line(bool);
-  void set_irq_apu_line(bool);
-
-  void set_rdy_line(bool);
-  void set_rdy_addr(bool valid, uint16 value = 0);
 };
 
 extern CPU cpu;
diff --git a/nSide_v005-source-revised/fc/cpu/timing/timing.cpp b/nSide_v005-source-revised/fc/cpu/timing/timing.cpp
new file mode 100644
index 0000000..cfe21c7
--- /dev/null
+++ b/nSide_v005-source-revised/fc/cpu/timing/timing.cpp
@@ -0,0 +1,68 @@
+void CPU::add_clocks(unsigned clocks) {
+  step(clocks);
+}
+
+uint8 CPU::op_read(uint16 addr) {
+  if(status.oam_dma_pending) {
+    status.oam_dma_pending = false;
+    op_read(addr);
+    oam_dma();
+  }
+
+  while(status.rdy_line == 0) {
+    regs.mdr = bus.read(status.rdy_addr_valid ? status.rdy_addr_value : addr);
+    add_clocks(system.region == System::Region::NTSC ? 12 : 16);
+  }
+
+  regs.mdr = bus.read(addr);
+  add_clocks(system.region == System::Region::NTSC ? 12 : 16);
+  return regs.mdr;
+}
+
+void CPU::op_write(uint16 addr, uint8 data) {
+  bus.write(addr, regs.mdr = data);
+  add_clocks(system.region == System::Region::NTSC ? 12 : 16);
+}
+
+void CPU::last_cycle() {
+  status.interrupt_pending = ((status.irq_line | status.irq_apu_line) & ~regs.p.i) | status.nmi_pending;
+}
+
+void CPU::nmi(uint16 &vector) {
+  if(status.nmi_pending) {
+    status.nmi_pending = false;
+    vector = 0xfffa;
+  }
+}
+
+void CPU::oam_dma() {
+  for(unsigned n = 0; n < 256; n++) {
+    uint8 data = op_read((status.oam_dma_page << 8) + n);
+    op_write(0x2004, data);
+  }
+}
+
+void CPU::set_nmi_line(bool line) {
+  //edge-sensitive (0->1)
+  if(!status.nmi_line && line) status.nmi_pending = true;
+  status.nmi_line = line;
+}
+
+void CPU::set_irq_line(bool line) {
+  //level-sensitive
+  status.irq_line = line;
+}
+
+void CPU::set_irq_apu_line(bool line) {
+  //level-sensitive
+  status.irq_apu_line = line;
+}
+
+void CPU::set_rdy_line(bool line) {
+  status.rdy_line = line;
+}
+
+void CPU::set_rdy_addr(bool valid, uint16 value) {
+  status.rdy_addr_valid = valid;
+  status.rdy_addr_value = value;
+}
diff --git a/nSide_v005-source-revised/fc/cpu/timing/timing.hpp b/nSide_v005-source-revised/fc/cpu/timing/timing.hpp
new file mode 100644
index 0000000..fbe3b8f
--- /dev/null
+++ b/nSide_v005-source-revised/fc/cpu/timing/timing.hpp
@@ -0,0 +1,14 @@
+void add_clocks(unsigned clocks);
+uint8 op_read(uint16 addr);
+void op_write(uint16 addr, uint8 data);
+void last_cycle();
+void nmi(uint16 &vector);
+
+void oam_dma();
+
+void set_nmi_line(bool);
+void set_irq_line(bool);
+void set_irq_apu_line(bool);
+
+void set_rdy_line(bool);
+void set_rdy_addr(bool valid, uint16 value = 0);
\ No newline at end of file
diff --git a/../../../git/Emulator/bsnes/bsnes/fc/cpu/timing.cpp b/../../../git/Emulator/bsnes/bsnes/fc/cpu/timing.cpp
deleted file mode 100644
index 8654710..0000000
--- a/../../../git/Emulator/bsnes/bsnes/fc/cpu/timing.cpp
+++ /dev/null
@@ -1,64 +0,0 @@
-uint8 CPU::op_read(uint16 addr) {
-  if(status.oam_dma_pending) {
-    status.oam_dma_pending = false;
-    op_read(addr);
-    oam_dma();
-  }
-
-  while(status.rdy_line == 0) {
-    regs.mdr = bus.read(status.rdy_addr_valid ? status.rdy_addr_value : addr);
-    add_clocks(12);
-  }
-
-  regs.mdr = bus.read(addr);
-  add_clocks(12);
-  return regs.mdr;
-}
-
-void CPU::op_write(uint16 addr, uint8 data) {
-  bus.write(addr, regs.mdr = data);
-  add_clocks(12);
-}
-
-void CPU::last_cycle() {
-  status.interrupt_pending = ((status.irq_line | status.irq_apu_line) & ~regs.p.i) | status.nmi_pending;
-}
-
-void CPU::nmi(uint16 &vector) {
-  if(status.nmi_pending) {
-    status.nmi_pending = false;
-    vector = 0xfffa;
-  }
-}
-
-void CPU::oam_dma() {
-  for(unsigned n = 0; n < 256; n++) {
-    uint8 data = op_read((status.oam_dma_page << 8) + n);
-    op_write(0x2004, data);
-  }
-}
-
-void CPU::set_nmi_line(bool line) {
-  //edge-sensitive (0->1)
-  if(!status.nmi_line && line) status.nmi_pending = true;
-  status.nmi_line = line;
-}
-
-void CPU::set_irq_line(bool line) {
-  //level-sensitive
-  status.irq_line = line;
-}
-
-void CPU::set_irq_apu_line(bool line) {
-  //level-sensitive
-  status.irq_apu_line = line;
-}
-
-void CPU::set_rdy_line(bool line) {
-  status.rdy_line = line;
-}
-
-void CPU::set_rdy_addr(bool valid, uint16 value) {
-  status.rdy_addr_valid = valid;
-  status.rdy_addr_value = value;
-}
diff --git a/../../../git/Emulator/bsnes/bsnes/fc/fc.hpp b/nSide_v005-source-revised/fc/fc.hpp
index 3fce8b0..d4cb2d5 100644
--- a/../../../git/Emulator/bsnes/bsnes/fc/fc.hpp
+++ b/nSide_v005-source-revised/fc/fc.hpp
@@ -6,16 +6,18 @@
 
 namespace Famicom {
   namespace Info {
-    static const char Name[] = "bnes";
-    static const unsigned SerializerVersion = 2;
+    static const char Name[] = "higan-fc";
+    static const unsigned SerializerVersion = 127;
   }
 }
 
 /*
-  bnes - Famicom emulator
+  higan-fc - Famicom emulator
+  based on higan/bnes by byuu and Ryphecha.
   authors: byuu, Ryphecha
+  contributors: hex_usr
   license: GPLv3
-  project started: 2011-09-05
+  original project started: 2011-09-05
 */
 
 #include <libco/libco.h>
@@ -46,16 +48,14 @@ namespace Famicom {
     }
   };
 
-  #include <fc/system/system.hpp>
-  #include <fc/scheduler/scheduler.hpp>
-  #include <fc/input/input.hpp>
   #include <fc/memory/memory.hpp>
-  #include <fc/cartridge/cartridge.hpp>
   #include <fc/cpu/cpu.hpp>
   #include <fc/apu/apu.hpp>
   #include <fc/ppu/ppu.hpp>
+  #include <fc/controller/controller.hpp>
+  #include <fc/system/system.hpp>
+  #include <fc/cartridge/cartridge.hpp>
   #include <fc/cheat/cheat.hpp>
-  #include <fc/video/video.hpp>
   #include <fc/interface/interface.hpp>
 }
 
diff --git a/../../../git/Emulator/bsnes/bsnes/fc/input/input.cpp b/../../../git/Emulator/bsnes/bsnes/fc/input/input.cpp
deleted file mode 100644
index 31c6b15..0000000
--- a/../../../git/Emulator/bsnes/bsnes/fc/input/input.cpp
+++ /dev/null
@@ -1,53 +0,0 @@
-#include <fc/fc.hpp>
-
-namespace Famicom {
-
-#include "serialization.cpp"
-Input input;
-
-void Input::latch(bool data) {
-  latchdata = data;
-
-  if(latchdata == 1) {
-    counter1 = 0;
-    counter2 = 0;
-  }
-}
-
-bool Input::data(bool port) {
-  bool result = 0;
-
-  if(port == 0) {
-    if(port1 == Device::Joypad) {
-      if(counter1 >= 8) return 1;
-      result = interface->inputPoll(0, 0u, counter1);
-      if(latchdata == 0) counter1++;
-    }
-  }
-
-  if(port == 1) {
-    if(port2 == Device::Joypad) {
-      if(counter2 >= 8) return 1;
-      result = interface->inputPoll(1, 0u, counter2);
-      if(latchdata == 0) counter2++;
-    }
-  }
-
-  return result;
-}
-
-void Input::connect(bool port, Device device) {
-  if(port == 0) port1 = device, counter1 = 0;
-  if(port == 1) port2 = device, counter2 = 0;
-}
-
-void Input::power() {
-}
-
-void Input::reset() {
-  latchdata = 0;
-  counter1 = 0;
-  counter2 = 0;
-}
-
-}
diff --git a/../../../git/Emulator/bsnes/bsnes/fc/input/input.hpp b/../../../git/Emulator/bsnes/bsnes/fc/input/input.hpp
deleted file mode 100644
index 8e42476..0000000
--- a/../../../git/Emulator/bsnes/bsnes/fc/input/input.hpp
+++ /dev/null
@@ -1,25 +0,0 @@
-struct Input {
-  enum class Device : unsigned {
-    Joypad,
-    None,
-  };
-
-  void latch(bool data);
-  bool data(bool port);
-  void connect(bool port, Device device);
-
-  void power();
-  void reset();
-
-  void serialize(serializer&);
-
-private:
-  Device port1;
-  Device port2;
-
-  bool latchdata;
-  unsigned counter1;
-  unsigned counter2;
-};
-
-extern Input input;
diff --git a/../../../git/Emulator/bsnes/bsnes/fc/input/serialization.cpp b/../../../git/Emulator/bsnes/bsnes/fc/input/serialization.cpp
deleted file mode 100644
index c0eb132..0000000
--- a/../../../git/Emulator/bsnes/bsnes/fc/input/serialization.cpp
+++ /dev/null
@@ -1,8 +0,0 @@
-void Input::serialize(serializer& s) {
-  s.integer((unsigned&)port1);
-  s.integer((unsigned&)port2);
-
-  s.integer(latchdata);
-  s.integer(counter1);
-  s.integer(counter2);
-}
diff --git a/../../../git/Emulator/bsnes/bsnes/fc/interface/interface.cpp b/nSide_v005-source-revised/fc/interface/interface.cpp
index 1d38d2b..2d779cc 100644
--- a/../../../git/Emulator/bsnes/bsnes/fc/interface/interface.cpp
+++ b/nSide_v005-source-revised/fc/interface/interface.cpp
@@ -9,11 +9,17 @@ string Interface::title() {
 }
 
 double Interface::videoFrequency() {
-  return 21477272.0 / (262.0 * 1364.0 - 4.0);
+  switch(system.region) { default:
+  case System::Region::NTSC: return 21477272.0 / (262.0 * 1364.0 - 4.0);
+  case System::Region::PAL:  return 26601712.0 / (312.0 * 1705.0);
+  }
 }
 
 double Interface::audioFrequency() {
-  return 21477272.0 / 12.0;
+  switch(system.region) { default:
+  case System::Region::NTSC: return 21477272.0 / 12.0;
+  case System::Region::PAL:  return 26601712.0 / 16.0;
+  }
 }
 
 bool Interface::loaded() {
@@ -31,14 +37,22 @@ unsigned Interface::group(unsigned id) {
   case ID::ProgramRAM:
   case ID::CharacterROM:
   case ID::CharacterRAM:
-    return 1;
+    switch(system.revision) {
+    case System::Revision::Famicom:      return ID::Famicom;
+    case System::Revision::PlayChoice10: return ID::PlayChoice10;
+    case System::Revision::VSSystem:     return ID::VSSystem;
+    }
   }
 
   throw;
 }
 
 void Interface::load(unsigned id) {
-  cartridge.load();
+  switch(id) {
+  case ID::Famicom:      cartridge.load(System::Revision::Famicom);      break;
+  case ID::PlayChoice10: cartridge.load(System::Revision::PlayChoice10); break;
+  case ID::VSSystem:     cartridge.load(System::Revision::VSSystem);     break;
+  }
 }
 
 void Interface::save() {
@@ -82,6 +96,10 @@ void Interface::unload() {
   cartridge.unload();
 }
 
+void Interface::connect(unsigned port, unsigned device) {
+  input.connect(port, (Input::Device)device);
+}
+
 void Interface::power() {
   system.power();
 }
@@ -119,6 +137,16 @@ void Interface::paletteUpdate(PaletteMode mode) {
   video.generate_palette(mode);
 }
 
+void Interface::exportMemory() {
+  string pathname = {path(group(ID::ProgramROM)), "debug/"};
+  directory::create(pathname);
+
+  file::write({pathname, "work.ram"}, cpu.ram, 0x0800);
+  file::write({pathname, "video.ram"}, ppu.ciram, 2048);
+  file::write({pathname, "palette.ram"}, ppu.cgram, 4 * 4 * 2);
+  file::write({pathname, "sprite.ram"}, ppu.oam, 4 * 64);
+}
+
 Interface::Interface() {
   interface = this;
 
@@ -131,10 +159,16 @@ Interface::Interface() {
   information.capability.states = true;
   information.capability.cheats = true;
 
-  media.append({ID::Famicom, "Famicom", "fc", true});
+  media.append({ID::Famicom,      "Famicom",       "fc",   true});
+  media.append({ID::PlayChoice10, "PlayChoice-10", "pc10", true});
+  media.append({ID::VSSystem,     "VS. System",    "vs",   true});
 
   {
-    Device device{0, ID::Port1 | ID::Port2, "Controller"};
+    Device device{
+      (unsigned)Input::Device::Joypad,
+      ID::Port1 | ID::Port2 | ID::ExpansionPort,
+      "Controller"
+    };
     device.input.append({0, 0, "A"     });
     device.input.append({1, 0, "B"     });
     device.input.append({2, 0, "Select"});
@@ -147,8 +181,150 @@ Interface::Interface() {
     this->device.append(device);
   }
 
+  {
+    Device device{
+      (unsigned)Input::Device::FourPlayers,
+      ID::ExpansionPort,
+      "4-Players Adaptor"
+    };
+    for(unsigned p = 3, n = 0; p <= 4; p += 1, n += 8) {
+      device.input.append({n + 0, 0, {"Port ", p, " - ", "A"     }});
+      device.input.append({n + 1, 0, {"Port ", p, " - ", "B"     }});
+      device.input.append({n + 2, 0, {"Port ", p, " - ", "Select"}});
+      device.input.append({n + 3, 0, {"Port ", p, " - ", "Start" }});
+      device.input.append({n + 4, 0, {"Port ", p, " - ", "Up"    }});
+      device.input.append({n + 5, 0, {"Port ", p, " - ", "Down"  }});
+      device.input.append({n + 6, 0, {"Port ", p, " - ", "Left"  }});
+      device.input.append({n + 7, 0, {"Port ", p, " - ", "Right" }});
+      device.order.append(n + 4, n + 5, n + 6, n + 7);
+      device.order.append(n + 1, n + 0, n + 2, n + 3);
+    }
+    this->device.append(device);
+  }
+
+  {
+    Device device{
+      (unsigned)Input::Device::FourScore,
+      ID::Port1,
+      "Four Score"
+    };
+    for(unsigned p = 1, n = 0; p <= 4; p += 2, n += 8) {
+      device.input.append({n + 0, 0, {"Port ", p, " - ", "A"     }});
+      device.input.append({n + 1, 0, {"Port ", p, " - ", "B"     }});
+      device.input.append({n + 2, 0, {"Port ", p, " - ", "Select"}});
+      device.input.append({n + 3, 0, {"Port ", p, " - ", "Start" }});
+      device.input.append({n + 4, 0, {"Port ", p, " - ", "Up"    }});
+      device.input.append({n + 5, 0, {"Port ", p, " - ", "Down"  }});
+      device.input.append({n + 6, 0, {"Port ", p, " - ", "Left"  }});
+      device.input.append({n + 7, 0, {"Port ", p, " - ", "Right" }});
+      device.order.append(n + 4, n + 5, n + 6, n + 7);
+      device.order.append(n + 1, n + 0, n + 2, n + 3);
+    }
+    this->device.append(device);
+  }
+
+  {
+    Device device{
+      (unsigned)Input::Device::FourScore,
+      ID::Port2,
+      "Four Score"
+    };
+    for(unsigned p = 2, n = 0; p <= 4; p += 2, n += 8) {
+      device.input.append({n + 0, 0, {"Port ", p, " - ", "A"     }});
+      device.input.append({n + 1, 0, {"Port ", p, " - ", "B"     }});
+      device.input.append({n + 2, 0, {"Port ", p, " - ", "Select"}});
+      device.input.append({n + 3, 0, {"Port ", p, " - ", "Start" }});
+      device.input.append({n + 4, 0, {"Port ", p, " - ", "Up"    }});
+      device.input.append({n + 5, 0, {"Port ", p, " - ", "Down"  }});
+      device.input.append({n + 6, 0, {"Port ", p, " - ", "Left"  }});
+      device.input.append({n + 7, 0, {"Port ", p, " - ", "Right" }});
+      device.order.append(n + 4, n + 5, n + 6, n + 7);
+      device.order.append(n + 1, n + 0, n + 2, n + 3);
+    }
+    this->device.append(device);
+  }
+
+  {
+    Device device{
+      (unsigned)Input::Device::BeamGun,
+      ID::ExpansionPort,
+      "Beam Gun"
+    };
+    device.input.append({0, 1, "X-axis" });
+    device.input.append({1, 1, "Y-axis" });
+    device.input.append({2, 0, "Trigger"});
+    device.order = {0, 1, 2};
+    this->device.append(device);
+  }
+
+  {
+    Device device{
+      (unsigned)Input::Device::BeamGun,
+      ID::Port2,
+      "Zapper"
+    };
+    device.input.append({0, 1, "X-axis" });
+    device.input.append({1, 1, "Y-axis" });
+    device.input.append({2, 0, "Trigger"});
+    device.order = {0, 1, 2};
+    this->device.append(device);
+  }
+
+  {
+    Device device{
+      (unsigned)Input::Device::FamilyTrainer,
+      ID::ExpansionPort,
+      "Family Trainer"
+    };
+    for(unsigned n = 0; n <= 11; n++) {
+      device.input.append({n, 0, {"Button ", n + 1}});
+    }
+    device.order = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};
+    this->device.append(device);
+  }
+
+  {
+    Device device{
+      (unsigned)Input::Device::FamilyTrainer,
+      ID::Port2,
+      "Power Pad"
+    };
+    for(unsigned n = 0; n <= 11; n++) {
+      device.input.append({n, 0, {"Button ", n + 1}});
+    }
+    device.order = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};
+    this->device.append(device);
+  }
+
+  {
+    Device device{
+      (unsigned)Input::Device::VSPanel,
+      ID::ExpansionPort,
+      "VS. Panel"
+    };
+    device.input.append({0, 0, "Button 1"      });
+    device.input.append({1, 0, "Button 2"      });
+    device.input.append({2, 0, "Button 3"      });
+    device.input.append({3, 0, "Button 4"      });
+    device.input.append({4, 0, "Service Button"});
+    device.input.append({5, 0, "Coin 1"        });
+    device.input.append({6, 0, "Coin 2"        });
+    device.order = {0, 1, 2, 3, 4, 5, 6};
+    this->device.append(device);
+  }
+
+  {
+    Device device{
+      (unsigned)Input::Device::None,
+      ID::Port1 | ID::Port2 | ID::ExpansionPort,
+      "None"
+    };
+    this->device.append(device);
+  }
+
   port.append({0, "Port 1"});
   port.append({1, "Port 2"});
+  port.append({2, "Expansion Port"});
 
   for(auto& device : this->device) {
     for(auto& port : this->port) {
diff --git a/../../../git/Emulator/bsnes/bsnes/fc/interface/interface.hpp b/nSide_v005-source-revised/fc/interface/interface.hpp
index 63e9194..9cd73ea 100644
--- a/../../../git/Emulator/bsnes/bsnes/fc/interface/interface.hpp
+++ b/nSide_v005-source-revised/fc/interface/interface.hpp
@@ -6,6 +6,8 @@ struct ID {
   enum : unsigned {
     System,
     Famicom,
+    PlayChoice10,
+    VSSystem,
   };
 
   enum : unsigned {
@@ -19,6 +21,7 @@ struct ID {
   enum : unsigned {
     Port1 = 1,
     Port2 = 2,
+    ExpansionPort = 4,
   };
 };
 
@@ -36,6 +39,7 @@ struct Interface : Emulator::Interface {
   void save(unsigned id, const stream& stream);
   void unload();
 
+  void connect(unsigned port, unsigned device);
   void power();
   void reset();
   void run();
@@ -47,6 +51,9 @@ struct Interface : Emulator::Interface {
 
   void paletteUpdate(PaletteMode mode);
 
+  //debugger functions
+  void exportMemory();
+
   Interface();
 
 private:
diff --git a/../../../git/Emulator/bsnes/bsnes/fc/ppu/ppu.cpp b/nSide_v005-source-revised/fc/ppu/ppu.cpp
index b4de38a..501586e 100644
--- a/../../../git/Emulator/bsnes/bsnes/fc/ppu/ppu.cpp
+++ b/nSide_v005-source-revised/fc/ppu/ppu.cpp
@@ -24,13 +24,24 @@ void PPU::tick() {
   if(status.ly == 241 && status.lx ==   0) status.nmi_flag = status.nmi_hold;
   if(status.ly == 241 && status.lx ==   2) cpu.set_nmi_line(status.nmi_enable && status.nmi_flag);
 
-  if(status.ly == 260 && status.lx == 340) status.sprite_zero_hit = 0, status.sprite_overflow = 0;
+  switch(system.region) {
+  case System::Region::NTSC:
+    if(status.ly == 260 && status.lx == 340) status.sprite_zero_hit = 0, status.sprite_overflow = 0;
 
-  if(status.ly == 260 && status.lx == 340) status.nmi_hold = 0;
-  if(status.ly == 261 && status.lx ==   0) status.nmi_flag = status.nmi_hold;
-  if(status.ly == 261 && status.lx ==   2) cpu.set_nmi_line(status.nmi_enable && status.nmi_flag);
+    if(status.ly == 260 && status.lx == 340) status.nmi_hold = 0;
+    if(status.ly == 261 && status.lx ==   0) status.nmi_flag = status.nmi_hold;
+    if(status.ly == 261 && status.lx ==   2) cpu.set_nmi_line(status.nmi_enable && status.nmi_flag);
+    break;
+  case System::Region::PAL:
+    if(status.ly == 310 && status.lx == 340) status.sprite_zero_hit = 0, status.sprite_overflow = 0;
+
+    if(status.ly == 310 && status.lx == 340) status.nmi_hold = 0;
+    if(status.ly == 311 && status.lx ==   0) status.nmi_flag = status.nmi_hold;
+    if(status.ly == 311 && status.lx ==   2) cpu.set_nmi_line(status.nmi_enable && status.nmi_flag);
+    break;
+  }
 
-  clock += 4;
+  clock += (system.region == System::Region::NTSC ? 4 : 5);
   if(clock >= 0) co_switch(cpu.thread);
 
   status.lx++;
@@ -38,7 +49,7 @@ void PPU::tick() {
 
 void PPU::scanline() {
   status.lx = 0;
-  if(++status.ly == 262) {
+  if(++status.ly == (system.region == System::Region::NTSC ? 262 : 312)) {
     status.ly = 0;
     frame();
   }
@@ -54,7 +65,7 @@ void PPU::power() {
 }
 
 void PPU::reset() {
-  create(PPU::Main, 21477272);
+  create(PPU::Main, system.cpu_frequency);
 
   status.mdr = 0x00;
   status.field = 0;
@@ -106,17 +117,27 @@ uint8 PPU::read(uint16 addr) {
     result |= status.nmi_flag << 7;
     result |= status.sprite_zero_hit << 6;
     result |= status.sprite_overflow << 5;
-    result |= status.mdr & 0x1f;
+    switch(revision) {
+    default:                  result |= status.mdr & 0x1f; break;
+    case Revision::RC2C05_02: result |= 0x1d; break;
+    case Revision::RC2C05_03: result |= 0x1c; break;
+    case Revision::RC2C05_04: result |= 0x1b; break;
+    }
     status.address_latch = 0;
     status.nmi_hold = 0;
     cpu.set_nmi_line(status.nmi_flag = 0);
     break;
   case 4:  //OAMDATA
-    result = oam[status.oam_addr];
-    if((status.oam_addr & 3) == 3) result &= 0xe3;
+    switch(revision) {
+    case Revision::RP2C02C: result = status.mdr; break;
+    default:                result = oam[status.oam_addr]; break;
+    }
+    //if((status.oam_addr & 3) == 3) result &= 0xe3;
     break;
   case 7:  //PPUDATA
-    if(raster_enable() && (status.ly <= 240 || status.ly == 261)) return 0x00;
+    if(raster_enable() && (status.ly <= 240 || status.ly == (system.region == System::Region::NTSC ? 261 : 311))) {
+      return 0x00;
+    }
 
     addr = status.vaddr & 0x3fff;
     if(addr <= 0x1fff) {
@@ -139,6 +160,14 @@ uint8 PPU::read(uint16 addr) {
 void PPU::write(uint16 addr, uint8 data) {
   status.mdr = data;
 
+  switch(revision) {
+  case Revision::RC2C05_01:
+  case Revision::RC2C05_02:
+  case Revision::RC2C05_03:
+  case Revision::RC2C05_04:
+  case Revision::RC2C05_05: if(addr & 6 == 0) addr ^= 1; break;
+  }
+
   switch(addr & 7) {
   case 0:  //PPUCTRL
     status.nmi_enable = data & 0x80;
@@ -161,6 +190,14 @@ void PPU::write(uint16 addr, uint8 data) {
   case 2:  //PPUSTATUS
     return;
   case 3:  //OAMADDR
+    if(revision != Revision::RP2C07) {
+      // below corruption code only applies for preferred CPU-PPU alignment.
+      // on an actual Famicom/NES, waiting a while after writing to OAM will
+      // make this corruption happen because the OAM will have decayed at the
+      // spot being written to.
+      for(int i = 0; i < 8; i++)
+        oam[((addr & 0xf800) >> 8) + i] = oam[(status.oam_addr & 0xf8) + i];
+    }
     status.oam_addr = data;
     return;
   case 4:  //OAMDATA
@@ -185,7 +222,9 @@ void PPU::write(uint16 addr, uint8 data) {
     status.address_latch ^= 1;
     return;
   case 7:  //PPUDATA
-    if(raster_enable() && (status.ly <= 240 || status.ly == 261)) return;
+    if(raster_enable() && (status.ly <= 240 || status.ly == (system.region == System::Region::NTSC ? 261 : 311))) {
+      return;
+    }
 
     addr = status.vaddr & 0x3fff;
     if(addr <= 0x1fff) {
@@ -331,7 +370,7 @@ void PPU::raster_sprite() {
   if(raster_enable() == false) return;
 
   unsigned n = raster.oam_iterator++;
-  signed ly = (status.ly == 261 ? -1 : status.ly);
+  signed ly = (status.ly == (system.region == System::Region::NTSC ? 261 : 311) ? -1 : status.ly);
   unsigned y = ly - oam[(n * 4) + 0];
 
   if(y >= sprite_height()) return;
@@ -349,7 +388,7 @@ void PPU::raster_sprite() {
 }
 
 void PPU::raster_scanline() {
-  if((status.ly >= 240 && status.ly <= 260)) {
+  if((status.ly >= 240 && status.ly <= (system.region == System::Region::NTSC ? 260 : 310))) {
     for(unsigned x = 0; x < 341; x++) tick();
     return scanline();
   }
@@ -437,7 +476,7 @@ void PPU::raster_scanline() {
     tick();
     tick();
 
-    if(raster_enable() && sprite == 6 && status.ly == 261) status.vaddr = status.taddr;  //304
+    if(raster_enable() && sprite == 6 && status.ly == (system.region == System::Region::NTSC ? 261 : 311)) status.vaddr = status.taddr;  //304
   }
 
   for(unsigned tile = 0; tile < 2; tile++) {  //320-335
@@ -471,7 +510,7 @@ void PPU::raster_scanline() {
   //336-339
   chr_load(0x2000 | (status.vaddr & 0x0fff));
   tick();
-  bool skip = (raster_enable() && status.field == 1 && status.ly == 261);
+  bool skip = (raster_enable() && status.field == 1 && status.ly == (system.region == System::Region::NTSC ? 261 : 311));
   tick();
 
   chr_load(0x2000 | (status.vaddr & 0x0fff));
@@ -484,4 +523,41 @@ void PPU::raster_scanline() {
   return scanline();
 }
 
+//
+
+const uint9_t PPU::RP2C03[16 * 4] = {
+  0333,0014,0006,0326,0403,0503,0510,0420,0320,0120,0031,0040,0022,0000,0000,0000,
+  0555,0036,0027,0407,0507,0704,0700,0630,0430,0140,0040,0053,0044,0000,0000,0000,
+  0777,0357,0447,0637,0707,0737,0740,0750,0660,0360,0070,0276,0077,0000,0000,0000,
+  0777,0567,0657,0757,0747,0755,0764,0772,0773,0572,0473,0276,0467,0000,0000,0000,
+};
+
+const uint9_t PPU::RP2C04_0001[16 * 4] = {
+  0755,0637,0700,0447,0044,0120,0222,0704,0777,0333,0750,0503,0403,0660,0320,0777,
+  0357,0653,0310,0360,0467,0657,0764,0027,0760,0276,0000,0200,0666,0444,0707,0014,
+  0003,0567,0757,0070,0077,0022,0053,0507,0000,0420,0747,0510,0407,0006,0740,0000,
+  0000,0140,0555,0031,0572,0326,0770,0630,0020,0036,0040,0111,0773,0737,0430,0473,
+};
+
+const uint9_t PPU::RP2C04_0002[16 * 4] = {
+  0000,0750,0430,0572,0473,0737,0044,0567,0700,0407,0773,0747,0777,0637,0467,0040,
+  0020,0357,0510,0666,0053,0360,0200,0447,0222,0707,0003,0276,0657,0320,0000,0326,
+  0403,0764,0740,0757,0036,0310,0555,0006,0507,0760,0333,0120,0027,0000,0660,0777,
+  0653,0111,0070,0630,0022,0014,0704,0140,0000,0077,0420,0770,0755,0503,0031,0444,
+};
+
+const uint9_t PPU::RP2C04_0003[16 * 4] = {
+  0507,0737,0473,0555,0040,0777,0567,0120,0014,0000,0764,0320,0704,0666,0653,0467,
+  0447,0044,0503,0027,0140,0430,0630,0053,0333,0326,0000,0006,0700,0510,0747,0755,
+  0637,0020,0003,0770,0111,0750,0740,0777,0360,0403,0357,0707,0036,0444,0000,0310,
+  0077,0200,0572,0757,0420,0070,0660,0222,0031,0000,0657,0773,0407,0276,0760,0022,
+};
+
+const uint9_t PPU::RP2C04_0004[16 * 4] = {
+  0430,0326,0044,0660,0000,0755,0014,0630,0555,0310,0070,0003,0764,0770,0040,0572,
+  0737,0200,0027,0747,0000,0222,0510,0740,0653,0053,0447,0140,0403,0000,0473,0357,
+  0503,0031,0420,0006,0407,0507,0333,0704,0022,0666,0036,0020,0111,0773,0444,0707,
+  0757,0777,0320,0700,0760,0276,0777,0467,0000,0750,0637,0567,0360,0657,0077,0120,
+};
+
 }
diff --git a/../../../git/Emulator/bsnes/bsnes/fc/ppu/ppu.hpp b/nSide_v005-source-revised/fc/ppu/ppu.hpp
index 0a7cca0..1482a13 100644
--- a/../../../git/Emulator/bsnes/bsnes/fc/ppu/ppu.hpp
+++ b/nSide_v005-source-revised/fc/ppu/ppu.hpp
@@ -1,4 +1,28 @@
 struct PPU : Thread {
+  uint32 buffer[256 * 262];
+  uint8 ciram[2048];
+  uint8 cgram[32];
+  uint8 oam[256];
+
+  enum class Revision : unsigned {
+    RP2C02C,
+    RP2C02G,
+    RP2C07,
+    RP2C03B,
+    RP2C03G,
+    RP2C04_0001,
+    RP2C04_0002,
+    RP2C04_0003,
+    RP2C04_0004,
+    RC2C03B,
+    RC2C03C,
+    RC2C05_01,
+    RC2C05_02,
+    RC2C05_03,
+    RC2C05_04,
+    RC2C05_05,
+  } revision;
+
   static void Main();
   void main();
   void tick();
@@ -33,6 +57,12 @@ struct PPU : Thread {
   void raster_sprite();
   void raster_scanline();
 
+  static const uint9_t RP2C03[16 * 4];
+  static const uint9_t RP2C04_0001[16 * 4];
+  static const uint9_t RP2C04_0002[16 * 4];
+  static const uint9_t RP2C04_0003[16 * 4];
+  static const uint9_t RP2C04_0004[16 * 4];
+
   void serialize(serializer&);
 
   struct Status {
@@ -97,11 +127,6 @@ struct PPU : Thread {
       uint8 tiledatahi;
     } oam[8], soam[8];
   } raster;
-
-  uint32 buffer[256 * 262];
-  uint8 ciram[2048];
-  uint8 cgram[32];
-  uint8 oam[256];
 };
 
 extern PPU ppu;
diff --git a/../../../git/Emulator/bsnes/bsnes/fc/scheduler/scheduler.cpp b/nSide_v005-source-revised/fc/scheduler/scheduler.cpp
index ee565a2..2ad3b82 100644
--- a/../../../git/Emulator/bsnes/bsnes/fc/scheduler/scheduler.cpp
+++ b/nSide_v005-source-revised/fc/scheduler/scheduler.cpp
@@ -1,6 +1,4 @@
-#include <fc/fc.hpp>
-
-namespace Famicom {
+#ifdef SYSTEM_CPP
 
 Scheduler scheduler;
 
@@ -15,14 +13,16 @@ void Scheduler::exit(ExitReason reason) {
   co_switch(host_thread);
 }
 
-void Scheduler::power() {
-}
-
-void Scheduler::reset() {
+void Scheduler::init() {
   host_thread = co_active();
   thread = cpu.thread;
   sync = SynchronizeMode::None;
-  exit_reason = ExitReason::UnknownEvent;
 }
 
+Scheduler::Scheduler() {
+  host_thread = nullptr;
+  thread = nullptr;
+  exit_reason = ExitReason::UnknownEvent;
 }
+
+#endif
diff --git a/../../../git/Emulator/bsnes/bsnes/fc/scheduler/scheduler.hpp b/nSide_v005-source-revised/fc/scheduler/scheduler.hpp
index 518a5d4..7842e09 100644
--- a/../../../git/Emulator/bsnes/bsnes/fc/scheduler/scheduler.hpp
+++ b/nSide_v005-source-revised/fc/scheduler/scheduler.hpp
@@ -9,8 +9,8 @@ struct Scheduler : property<Scheduler> {
   void enter();
   void exit(ExitReason);
 
-  void power();
-  void reset();
+  void init();
+  Scheduler();
 };
 
 extern Scheduler scheduler;
diff --git a/nSide_v005-source-revised/fc/system/input.cpp b/nSide_v005-source-revised/fc/system/input.cpp
new file mode 100644
index 0000000..2bea75f
--- /dev/null
+++ b/nSide_v005-source-revised/fc/system/input.cpp
@@ -0,0 +1,75 @@
+#ifdef SYSTEM_CPP
+
+Input input;
+
+void Input::connect(uint2 port, Device id) {
+  // Don't allow switching away from VS. Panel
+  if(system.vs() && port == 2 && id != Device::VSPanel) return;
+  if(!system.vs() && id == Device::VSPanel) id = Device::None;
+
+  Controller*& controller = (
+    port == Controller::Port1 ? port1 :
+    port == Controller::Port2 ? port2 :
+                                expansion
+  );
+  if(controller) {
+    delete controller;
+    controller = nullptr;
+  }
+
+  if(port < 2) {
+    switch(id) { default:
+    case Device::None: controller = new Controller(port); break;
+    case Device::Joypad: controller = new Gamepad(port); break;
+    case Device::FourScore: controller = new FourScore(port); break;
+    case Device::BeamGun: controller = new BeamGun(port); break;
+    case Device::FamilyTrainer: controller = new FamilyTrainer(port); break;
+    }
+  } else {
+    switch(id) { default:
+    case Device::None: controller = new Controller(port); break;
+    case Device::Joypad: controller = new Gamepad(port); break;
+    case Device::FourPlayers: controller = new FourPlayers(port); break;
+    case Device::BeamGun: controller = new BeamGun(port); break;
+    case Device::FamilyTrainer: controller = new FamilyTrainer(port); break;
+    case Device::VSPanel: controller = new VSPanel(port); break;
+    }
+  }
+
+  switch(port) {
+  case Controller::Port1: configuration.controller_port1 = id; break;
+  case Controller::Port2: configuration.controller_port2 = id; break;
+  case Controller::ExpansionPort: configuration.expansion_port = id; break;
+  }
+
+  /*switch(port) {
+  case Controller::Port1:
+    if(id == Device::FourScore && configuration.controller_port2 != Device::FourScore) {
+      connect(Controller::Port2, Device::FourScore);
+    } else if(id != Device::FourScore && configuration.controller_port2 == Device::FourScore) {
+      connect(Controller::Port2, Device::None);
+    }
+    break;
+  case Controller::Port2:
+    if(id == Device::FourScore && configuration.controller_port1 != Device::FourScore) {
+      connect(Controller::Port1, Device::FourScore);
+    } else if(id != Device::FourScore && configuration.controller_port1 == Device::FourScore) {
+      connect(Controller::Port1, Device::None);
+    }
+    break;
+  }*/
+}
+
+Input::Input() {
+  connect(Controller::Port1, Input::Device::Joypad);
+  connect(Controller::Port2, Input::Device::Joypad);
+  connect(Controller::ExpansionPort, Input::Device::Joypad);
+}
+
+Input::~Input() {
+  if(port1) delete port1;
+  if(port2) delete port2;
+  if(expansion) delete expansion;
+}
+
+#endif
diff --git a/nSide_v005-source-revised/fc/system/input.hpp b/nSide_v005-source-revised/fc/system/input.hpp
new file mode 100644
index 0000000..d57beb8
--- /dev/null
+++ b/nSide_v005-source-revised/fc/system/input.hpp
@@ -0,0 +1,31 @@
+struct Input {
+  enum class Device : unsigned {
+    // shared
+    Joypad        = 0,
+    FourPlayers   = 1,
+    FourScore     = 1,
+    BeamGun       = 2,
+    FamilyTrainer = 3,
+    VSPanel       = 4,
+    None          = 5,
+  };
+
+  enum class JoypadID : unsigned {
+    A  =  0, B    =  1, Select =  2, Start =  3,
+    Up =  4, Down =  5, Left   =  6, Right =  7,
+  };
+
+  enum class BeamGunID : unsigned {
+    X = 0, Y = 1, Trigger = 2,
+  };
+
+  Controller* port1 = nullptr;
+  Controller* port2 = nullptr;
+  Controller* expansion = nullptr;
+
+  void connect(uint2 port, Device device);
+  Input();
+  ~Input();
+};
+
+extern Input input;
diff --git a/../../../git/Emulator/bsnes/bsnes/fc/system/serialization.cpp b/nSide_v005-source-revised/fc/system/serialization.cpp
index 1d2c750..5c73e8a 100644
--- a/../../../git/Emulator/bsnes/bsnes/fc/system/serialization.cpp
+++ b/nSide_v005-source-revised/fc/system/serialization.cpp
@@ -33,12 +33,12 @@ bool System::unserialize(serializer& s) {
 }
 
 void System::serialize(serializer& s) {
+  s.integer((unsigned&)region);
 }
 
 void System::serialize_all(serializer& s) {
-  system.serialize(s);
-  input.serialize(s);
   cartridge.serialize(s);
+  system.serialize(s);
   cpu.serialize(s);
   apu.serialize(s);
   ppu.serialize(s);
diff --git a/../../../git/Emulator/bsnes/bsnes/fc/system/system.cpp b/nSide_v005-source-revised/fc/system/system.cpp
index 4a86bea..c6f2459 100644
--- a/../../../git/Emulator/bsnes/bsnes/fc/system/system.cpp
+++ b/nSide_v005-source-revised/fc/system/system.cpp
@@ -1,14 +1,23 @@
 #include <fc/fc.hpp>
 
+#define SYSTEM_CPP
 namespace Famicom {
 
-#include "serialization.cpp"
 System system;
+Configuration configuration;
+
+#include "video.cpp"
+#include "input.cpp"
+#include "serialization.cpp"
+
+#include <fc/scheduler/scheduler.cpp>
 
 void System::run() {
+  scheduler.sync = Scheduler::SynchronizeMode::None;
+
   scheduler.enter();
   if(scheduler.exit_reason() == Scheduler::ExitReason::FrameEvent) {
-    interface->videoRefresh(video.palette, ppu.buffer, 4 * 256, 256, 240);
+    video.update();
   }
 }
 
@@ -36,15 +45,48 @@ void System::runthreadtosave() {
     scheduler.enter();
     if(scheduler.exit_reason() == Scheduler::ExitReason::SynchronizeEvent) break;
     if(scheduler.exit_reason() == Scheduler::ExitReason::FrameEvent) {
-      interface->videoRefresh(video.palette, ppu.buffer, 4 * 256, 256, 240);
+      video.update();
     }
   }
 }
 
-void System::load() {
+void System::init() {
+  assert(interface != nullptr);
+  input.connect(0, configuration.controller_port1);
+  input.connect(1, configuration.controller_port1);
+  input.connect(2, configuration.expansion_port);
+}
+
+void System::term() {
+}
+
+void System::load(Revision revision) {
+  this->revision = revision;
   string manifest = string::read({interface->path(ID::System), "manifest.bml"});
   auto document = Markup::Document(manifest);
 
+  region = Region::Autodetect;
+  if(region == Region::Autodetect) {
+    region = (cartridge.region == Cartridge::Region::NTSC ? Region::NTSC : Region::PAL);
+  }
+
+  cpu_frequency = region == Region::NTSC ? 21477272 : 26601712;
+
+  switch(revision) {
+  case Revision::Famicom:
+    // most Famicoms use a PPU with open bus OAMDATA (read).
+    // For now, we use an NES PPU where OAMDATA (read) is defined.
+    if(region == Region::NTSC) ppu.revision = PPU::Revision::RP2C02G;
+    if(region == Region::PAL)  ppu.revision = PPU::Revision::RP2C07;
+    break;
+  case Revision::PlayChoice10:
+    ppu.revision = PPU::Revision::RP2C03B;
+    break;
+  case Revision::VSSystem:
+    input.connect(2, Input::Device::VSPanel);
+    // PPU revision is set within cartridge.load().
+  }
+
   serialize_init();
 }
 
@@ -53,8 +95,6 @@ void System::power() {
   cpu.power();
   apu.power();
   ppu.power();
-  input.reset();
-  scheduler.power();
   reset();
 }
 
@@ -62,18 +102,24 @@ void System::reset() {
   cartridge.reset();
   cpu.reset();
   apu.reset();
+  // Only the Famicom's PPU will reset. The NES's PPU will not.
   ppu.reset();
-  input.reset();
-  scheduler.reset();
+  scheduler.init();
+  input.connect(0, configuration.controller_port1);
+  input.connect(1, configuration.controller_port2);
+  input.connect(2, configuration.expansion_port);
 }
 
-void System::init() {
-  assert(interface != 0);
-  input.connect(0, Input::Device::Joypad);
-  input.connect(1, Input::Device::None);
+void System::scanline() {
+  video.scanline();
+  if(ppu.status.ly == 241) scheduler.exit(Scheduler::ExitReason::FrameEvent);
 }
 
-void System::term() {
+void System::frame() {
+}
+
+System::System() {
+  region = Region::Autodetect;
 }
 
 }
diff --git a/../../../git/Emulator/bsnes/bsnes/fc/system/system.hpp b/nSide_v005-source-revised/fc/system/system.hpp
index 88b73c5..1f8be84 100644
--- a/../../../git/Emulator/bsnes/bsnes/fc/system/system.hpp
+++ b/nSide_v005-source-revised/fc/system/system.hpp
@@ -1,22 +1,65 @@
 struct System {
+  enum class Region : unsigned { NTSC = 0, PAL = 1, Autodetect = 2 };
+  enum class Revision : unsigned {
+    Famicom,
+    PlayChoice10,
+    VSSystem,
+  } revision;
+
+  inline bool fc()   const { return revision == Revision::Famicom; }
+  inline bool pc10() const { return revision == Revision::PlayChoice10; }
+  inline bool vs()   const { return revision == Revision::VSSystem; }
+
   void run();
   void runtosave();
-  void runthreadtosave();
 
-  void load();
+  void init();
+  void term();
+  void load(Revision);
   void power();
   void reset();
 
-  void init();
-  void term();
+  void frame();
+  void scanline();
+
+  //return *active* system information (settings are cached upon power-on)
+  //readonly<Region> region;
+  //readonly<unsigned> cpu_frequency;
+  //readonly<unsigned> serialize_size;
+  Region region;
+  unsigned cpu_frequency;
+  unsigned serialize_size;
 
   serializer serialize();
   bool unserialize(serializer&);
 
+  System();
+
+private:
+  void runthreadtosave();
+
   void serialize(serializer&);
   void serialize_all(serializer&);
   void serialize_init();
-  unsigned serialize_size;
+
+  friend class Cartridge;
+  friend class Video;
+  friend class Input;
 };
 
 extern System system;
+
+#include "video.hpp"
+#include "input.hpp"
+
+#include <fc/scheduler/scheduler.hpp>
+
+struct Configuration {
+  Input::Device controller_port1 = Input::Device::Joypad;
+  Input::Device controller_port2 = Input::Device::Joypad;
+  Input::Device expansion_port = Input::Device::FourPlayers;
+  System::Region region = System::Region::Autodetect;
+  bool random = true;
+};
+
+extern Configuration configuration;
diff --git a/nSide_v005-source-revised/fc/system/video.cpp b/nSide_v005-source-revised/fc/system/video.cpp
new file mode 100644
index 0000000..188f9bd
--- /dev/null
+++ b/nSide_v005-source-revised/fc/system/video.cpp
@@ -0,0 +1,189 @@
+#ifdef SYSTEM_CPP
+
+Video video;
+
+void Video::generate_palette(Emulator::Interface::PaletteMode mode) {
+  unsigned emphasis;
+  unsigned luma;
+  unsigned chroma;
+  for(unsigned color = 0; color < (1 << 9); color++) {
+    if(mode == Emulator::Interface::PaletteMode::Literal) {
+      palette[color] = color;
+      continue;
+    }
+    switch(ppu.revision) {
+    case PPU::Revision::RP2C02C:
+    case PPU::Revision::RP2C02G:
+    case PPU::Revision::RP2C07:
+      if(mode == Emulator::Interface::PaletteMode::Standard) {
+        palette[color] = generate_color(color, 2.0, 0.0, 1.0, 1.0, 2.2);
+      } else if(mode == Emulator::Interface::PaletteMode::Channel) {
+        emphasis = image::normalize((color >> 6) &  7, 3, 16);
+        luma     = image::normalize((color >> 4) &  3, 2, 16);
+        chroma   = image::normalize((color >> 0) & 15, 4, 16);
+        palette[color] = interface->videoColor(color, 0, emphasis, luma, chroma);
+      } else if(mode == Emulator::Interface::PaletteMode::Emulation) {
+        palette[color] = generate_color(color, 2.0, 0.0, 1.0, 1.0, 1.8);
+      }
+      break;
+    case PPU::Revision::RP2C03B:
+    case PPU::Revision::RP2C03G:
+    case PPU::Revision::RC2C03B:
+    case PPU::Revision::RC2C03C:
+    case PPU::Revision::RC2C05_01:
+    case PPU::Revision::RC2C05_02:
+    case PPU::Revision::RC2C05_03:
+    case PPU::Revision::RC2C05_04:
+    case PPU::Revision::RC2C05_05:
+      palette[color] = interface->videoColor(color, 0,
+        uclamp<16>(((PPU::RP2C03[color & 63] >> 6) & 7) * 9362.25),
+        uclamp<16>(((PPU::RP2C03[color & 63] >> 3) & 7) * 9362.25),
+        uclamp<16>(((PPU::RP2C03[color & 63] >> 0) & 7) * 9362.25)
+      );
+      break;
+    case PPU::Revision::RP2C04_0001:
+      palette[color] = interface->videoColor(color, 0,
+        uclamp<16>(((PPU::RP2C04_0001[color & 63] >> 6) & 7) * 9362.25),
+        uclamp<16>(((PPU::RP2C04_0001[color & 63] >> 3) & 7) * 9362.25),
+        uclamp<16>(((PPU::RP2C04_0001[color & 63] >> 0) & 7) * 9362.25)
+      );
+      break;
+    case PPU::Revision::RP2C04_0002:
+      palette[color] = interface->videoColor(color, 0,
+        uclamp<16>(((PPU::RP2C04_0002[color & 63] >> 6) & 7) * 9362.25),
+        uclamp<16>(((PPU::RP2C04_0002[color & 63] >> 3) & 7) * 9362.25),
+        uclamp<16>(((PPU::RP2C04_0002[color & 63] >> 0) & 7) * 9362.25)
+      );
+      break;
+    case PPU::Revision::RP2C04_0003:
+      palette[color] = interface->videoColor(color, 0,
+        uclamp<16>(((PPU::RP2C04_0003[color & 63] >> 6) & 7) * 9362.25),
+        uclamp<16>(((PPU::RP2C04_0003[color & 63] >> 3) & 7) * 9362.25),
+        uclamp<16>(((PPU::RP2C04_0003[color & 63] >> 0) & 7) * 9362.25)
+      );
+      break;
+    case PPU::Revision::RP2C04_0004:
+      palette[color] = interface->videoColor(color, 0,
+        uclamp<16>(((PPU::RP2C04_0004[color & 63] >> 6) & 7) * 9362.25),
+        uclamp<16>(((PPU::RP2C04_0004[color & 63] >> 3) & 7) * 9362.25),
+        uclamp<16>(((PPU::RP2C04_0004[color & 63] >> 0) & 7) * 9362.25)
+      );
+      break;
+    } 
+  }
+}
+
+Video::Video() {
+  palette = new uint32_t[1 << 9]();
+}
+
+Video::~Video() {
+  delete[] palette;
+}
+
+//internal
+
+const uint8_t Video::cursor[15 * 15] = {
+  0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,
+  0,0,0,0,1,1,2,2,2,1,1,0,0,0,0,
+  0,0,0,1,2,2,1,2,1,2,2,1,0,0,0,
+  0,0,1,2,1,1,0,1,0,1,1,2,1,0,0,
+  0,1,2,1,0,0,0,1,0,0,0,1,2,1,0,
+  0,1,2,1,0,0,1,2,1,0,0,1,2,1,0,
+  1,2,1,0,0,1,1,2,1,1,0,0,1,2,1,
+  1,2,2,1,1,2,2,2,2,2,1,1,2,2,1,
+  1,2,1,0,0,1,1,2,1,1,0,0,1,2,1,
+  0,1,2,1,0,0,1,2,1,0,0,1,2,1,0,
+  0,1,2,1,0,0,0,1,0,0,0,1,2,1,0,
+  0,0,1,2,1,1,0,1,0,1,1,2,1,0,0,
+  0,0,0,1,2,2,1,2,1,2,2,1,0,0,0,
+  0,0,0,0,1,1,2,2,2,1,1,0,0,0,0,
+  0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,
+};
+
+void Video::draw_cursor(uint16_t color, int x, int y) {
+  uint32_t* data = (uint32_t*)ppu.buffer;
+
+  for(int cy = 0; cy < 15; cy++) {
+    int vy = y + cy - 7;
+    if(vy <= 0 || vy >= 240) continue;  //do not draw offscreen
+
+    for(int cx = 0; cx < 15; cx++) {
+      int vx = x + cx - 7;
+      if(vx < 0 || vx >= 256) continue;  //do not draw offscreen
+      uint8_t pixel = cursor[cy * 15 + cx];
+      if(pixel == 0) continue;
+      uint32_t pixelcolor = (pixel == 1) ? 0x0f : color;
+
+      *((uint32_t*)data + vy * 256 + vx) = pixelcolor;
+    }
+  }
+}
+
+void Video::update() {
+  if(configuration.controller_port2 == Input::Device::BeamGun) {
+    BeamGun &device = (BeamGun&)*input.port2;
+    draw_cursor(0x27, device.x, device.y);
+  }
+  if(configuration.expansion_port == Input::Device::BeamGun) {
+    BeamGun &device = (BeamGun&)*input.expansion;
+    draw_cursor(0x2D, device.x, device.y);
+  }
+
+  interface->videoRefresh(video.palette, ppu.buffer, 4 * 256, 256, 240);
+}
+
+void Video::scanline() {
+  unsigned y = ppu.status.ly;
+  if(y >= 240) return;
+}
+
+uint32_t Video::generate_color(
+  unsigned n, double saturation, double hue,
+  double contrast, double brightness, double gamma
+) {
+  signed color = (n & 0x0f), level = color < 0xe ? (n >> 4) & 3 : 1;
+
+  static const double black = 0.518, white = 1.962, attenuation = 0.746;
+  static const double levels[8] = {
+    0.350, 0.518, 0.962, 1.550,
+    1.094, 1.506, 1.962, 1.962,
+  };
+
+  double lo_and_hi[2] = {
+    levels[level + 4 * (color == 0x0)],
+    levels[level + 4 * (color <  0xd)],
+  };
+
+  double y = 0.0, i = 0.0, q = 0.0;
+  auto wave = [](signed p, signed color) { return (color + p + 8) % 12 < 6; };
+  for(signed p = 0; p < 12; p++) {
+    double spot = lo_and_hi[wave(p, color)];
+
+    if(((n & 0x040) && wave(p, 12))
+    || ((n & 0x080) && wave(p,  4))
+    || ((n & 0x100) && wave(p,  8))
+    ) spot *= attenuation;
+
+    double v = (spot - black) / (white - black);
+
+    v = (v - 0.5) * contrast + 0.5;
+    v *= brightness / 12.0;
+
+    y += v;
+    i += v * std::cos((3.141592653 / 6.0) * (p + hue));
+    q += v * std::sin((3.141592653 / 6.0) * (p + hue));
+  }
+
+  i *= saturation;
+  q *= saturation;
+
+  auto gammaAdjust = [=](double f) { return f < 0.0 ? 0.0 : std::pow(f, 2.2 / gamma); };
+  unsigned r = 65535.0 * gammaAdjust(y +  0.946882 * i +  0.623557 * q);
+  unsigned g = 65535.0 * gammaAdjust(y + -0.274788 * i + -0.635691 * q);
+  unsigned b = 65535.0 * gammaAdjust(y + -1.108545 * i +  1.709007 * q);
+
+  return interface->videoColor(n, 0, uclamp<16>(r), uclamp<16>(g), uclamp<16>(b));
+}
+
+#endif
diff --git a/nSide_v005-source-revised/fc/system/video.hpp b/nSide_v005-source-revised/fc/system/video.hpp
new file mode 100644
index 0000000..967154f
--- /dev/null
+++ b/nSide_v005-source-revised/fc/system/video.hpp
@@ -0,0 +1,17 @@
+struct Video {
+  uint32_t* palette;
+  void generate_palette(Emulator::Interface::PaletteMode mode);
+  Video();
+  ~Video();
+
+private:
+  void update();
+  void scanline();
+  uint32_t generate_color(unsigned, double, double, double, double, double);
+  static const uint8_t cursor[15 * 15];
+  void draw_cursor(uint16_t color, int x, int y);
+
+  friend class System;
+};
+
+extern Video video;
diff --git a/../../../git/Emulator/bsnes/bsnes/fc/video/video.cpp b/../../../git/Emulator/bsnes/bsnes/fc/video/video.cpp
deleted file mode 100644
index bdb476a..0000000
--- a/../../../git/Emulator/bsnes/bsnes/fc/video/video.cpp
+++ /dev/null
@@ -1,85 +0,0 @@
-#include <fc/fc.hpp>
-#include <cmath>
-
-#define VIDEO_CPP
-namespace Famicom {
-
-Video video;
-
-void Video::generate_palette(Emulator::Interface::PaletteMode mode) {
-  for(unsigned color = 0; color < (1 << 9); color++) {
-    if(mode == Emulator::Interface::PaletteMode::Literal) {
-      palette[color] = color;
-    } else if(mode == Emulator::Interface::PaletteMode::Channel) {
-      unsigned emphasis = (color >> 6) &  7;
-      unsigned luma     = (color >> 4) &  3;
-      unsigned chroma   = (color >> 0) & 15;
-      emphasis = image::normalize(emphasis, 3, 16);
-      luma     = image::normalize(luma,     2, 16);
-      chroma   = image::normalize(chroma,   4, 16);
-      palette[color] = interface->videoColor(color, 0, emphasis, luma, chroma);
-    } else if(mode == Emulator::Interface::PaletteMode::Standard) {
-      palette[color] = generate_color(color, 2.0, 0.0, 1.0, 1.0, 2.2);
-    } else if(mode == Emulator::Interface::PaletteMode::Emulation) {
-      palette[color] = generate_color(color, 2.0, 0.0, 1.0, 1.0, 1.8);
-    }
-  }
-}
-
-Video::Video() {
-  palette = new uint32_t[1 << 9]();
-}
-
-Video::~Video() {
-  delete[] palette;
-}
-
-uint32_t Video::generate_color(
-  unsigned n, double saturation, double hue,
-  double contrast, double brightness, double gamma
-) {
-  signed color = (n & 0x0f), level = color < 0xe ? (n >> 4) & 3 : 1;
-
-  static const double black = 0.518, white = 1.962, attenuation = 0.746;
-  static const double levels[8] = {
-    0.350, 0.518, 0.962, 1.550,
-    1.094, 1.506, 1.962, 1.962,
-  };
-
-  double lo_and_hi[2] = {
-    levels[level + 4 * (color == 0x0)],
-    levels[level + 4 * (color <  0xd)],
-  };
-
-  double y = 0.0, i = 0.0, q = 0.0;
-  auto wave = [](signed p, signed color) { return (color + p + 8) % 12 < 6; };
-  for(signed p = 0; p < 12; p++) {
-    double spot = lo_and_hi[wave(p, color)];
-
-    if(((n & 0x040) && wave(p, 12))
-    || ((n & 0x080) && wave(p,  4))
-    || ((n & 0x100) && wave(p,  8))
-    ) spot *= attenuation;
-
-    double v = (spot - black) / (white - black);
-
-    v = (v - 0.5) * contrast + 0.5;
-    v *= brightness / 12.0;
-
-    y += v;
-    i += v * std::cos((3.141592653 / 6.0) * (p + hue));
-    q += v * std::sin((3.141592653 / 6.0) * (p + hue));
-  }
-
-  i *= saturation;
-  q *= saturation;
-
-  auto gammaAdjust = [=](double f) { return f < 0.0 ? 0.0 : std::pow(f, 2.2 / gamma); };
-  unsigned r = 65535.0 * gammaAdjust(y +  0.946882 * i +  0.623557 * q);
-  unsigned g = 65535.0 * gammaAdjust(y + -0.274788 * i + -0.635691 * q);
-  unsigned b = 65535.0 * gammaAdjust(y + -1.108545 * i +  1.709007 * q);
-
-  return interface->videoColor(n, 0, uclamp<16>(r), uclamp<16>(g), uclamp<16>(b));
-}
-
-}
diff --git a/../../../git/Emulator/bsnes/bsnes/fc/video/video.hpp b/../../../git/Emulator/bsnes/bsnes/fc/video/video.hpp
deleted file mode 100644
index f49930b..0000000
--- a/../../../git/Emulator/bsnes/bsnes/fc/video/video.hpp
+++ /dev/null
@@ -1,12 +0,0 @@
-struct Video {
-  uint32_t* palette = nullptr;
-  void generate_palette(Emulator::Interface::PaletteMode mode);
-
-  Video();
-  ~Video();
-
-private:
-  uint32_t generate_color(unsigned, double, double, double, double, double);
-};
-
-extern Video video;
diff --git a/../../../git/Emulator/bsnes/bsnes/gb/cheat/cheat.cpp b/nSide_v005-source-revised/gb/cheat/cheat.cpp
index 7b45725..3457d56 100644
--- a/../../../git/Emulator/bsnes/bsnes/gb/cheat/cheat.cpp
+++ b/nSide_v005-source-revised/gb/cheat/cheat.cpp
@@ -16,13 +16,13 @@ void Cheat::append(unsigned addr, unsigned comp, unsigned data) {
   codes.append({addr, comp, data});
 }
 
-maybe<unsigned> Cheat::find(unsigned addr, unsigned comp) {
+optional<unsigned> Cheat::find(unsigned addr, unsigned comp) {
   for(auto& code : codes) {
     if(code.addr == addr && (code.comp == Unused || code.comp == comp)) {
-      return code.data;
+      return {true, code.data};
     }
   }
-  return nothing;
+  return false;
 }
 
 }
diff --git a/../../../git/Emulator/bsnes/bsnes/gb/cheat/cheat.hpp b/nSide_v005-source-revised/gb/cheat/cheat.hpp
index 43f2d05..c1cb490 100644
--- a/../../../git/Emulator/bsnes/bsnes/gb/cheat/cheat.hpp
+++ b/nSide_v005-source-revised/gb/cheat/cheat.hpp
@@ -11,7 +11,7 @@ struct Cheat {
   void reset();
   void append(unsigned addr, unsigned data);
   void append(unsigned addr, unsigned comp, unsigned data);
-  maybe<unsigned> find(unsigned addr, unsigned comp);
+  optional<unsigned> find(unsigned addr, unsigned comp);
 };
 
 extern Cheat cheat;
diff --git a/../../../git/Emulator/bsnes/bsnes/gb/cpu/mmio.cpp b/nSide_v005-source-revised/gb/cpu/mmio.cpp
index 1eba8ad..7c54d49 100644
--- a/../../../git/Emulator/bsnes/bsnes/gb/cpu/mmio.cpp
+++ b/nSide_v005-source-revised/gb/cpu/mmio.cpp
@@ -20,12 +20,9 @@ void CPU::mmio_joyp_poll() {
   dpad |= interface->inputPoll(0, 0, (unsigned)Input::Left) << 1;
   dpad |= interface->inputPoll(0, 0, (unsigned)Input::Right) << 0;
 
-  if(system.revision != System::Revision::SuperGameBoy) {
-    //D-pad pivot makes it impossible to press opposing directions at the same time
-    //however, Super Game Boy BIOS is able to set these bits together
-    if(dpad & 4) dpad &= ~8;  //disallow up+down
-    if(dpad & 2) dpad &= ~1;  //disallow left+right
-  }
+  //D-pad pivot makes it impossible to press opposing directions at the same time
+  if(dpad & 4) dpad &= ~8;  //disallow up+down
+  if(dpad & 2) dpad &= ~1;  //disallow left+right
 
   status.joyp = 0x0f;
   if(status.p15 == 1 && status.p14 == 1) status.joyp -= status.mlt_req;
diff --git a/../../../git/Emulator/bsnes/bsnes/gb/gb.hpp b/nSide_v005-source-revised/gb/gb.hpp
index 10980cf..b8a24e7 100644
--- a/../../../git/Emulator/bsnes/bsnes/gb/gb.hpp
+++ b/nSide_v005-source-revised/gb/gb.hpp
@@ -6,16 +6,17 @@
 
 namespace GameBoy {
   namespace Info {
-    static const char Name[] = "bgb";
+    static const char Name[] = "higan-gb";
     static const unsigned SerializerVersion = 4;
   }
 }
 
 /*
-  bgb - Game Boy, Super Game Boy, and Game Boy Color emulator
+  higan-gb - Game Boy, Super Game Boy, and Game Boy Color emulator
+  based on higan/bgb by byuu.
   author: byuu
   license: GPLv3
-  project started: 2010-12-27
+  original project started: 2010-12-27
 */
 
 #include <libco/libco.h>
diff --git a/../../../git/Emulator/bsnes/bsnes/gb/interface/interface.cpp b/nSide_v005-source-revised/gb/interface/interface.cpp
index fdddfc6..6d11d2d 100644
--- a/../../../git/Emulator/bsnes/bsnes/gb/interface/interface.cpp
+++ b/nSide_v005-source-revised/gb/interface/interface.cpp
@@ -8,10 +8,6 @@ void Interface::lcdScanline() {
   if(hook) hook->lcdScanline();
 }
 
-void Interface::lcdOutput(uint2 color) {
-  if(hook) hook->lcdOutput(color);
-}
-
 void Interface::joypWrite(bool p15, bool p14) {
   if(hook) hook->joypWrite(p15, p14);
 }
@@ -139,6 +135,28 @@ void Interface::paletteUpdate(PaletteMode mode) {
   video.generate_palette(mode);
 }
 
+void Interface::exportMemory() {
+  string pathname = {path(group(ID::ROM)), "debug/"};
+  directory::create(pathname);
+
+  file::write({pathname, "work.ram"}, cpu.wram, system.cgb() ? 32768 : 8192);
+  file::write({pathname, "internal.ram"}, cpu.hram, 128);
+  file::write({pathname, "video.ram"}, ppu.vram, system.cgb() ? 16384 : 8192);
+  file fp;
+  if(fp.open({pathname, "palette.ram"}, file::mode::write)) {
+    if(!system.cgb()) { // Game Boy
+      fp.write(ppu.bgp, 4);
+      fp.write(ppu.obp[0], 4);
+      fp.write(ppu.obp[1], 4);
+    } else {            // Game Boy Color
+      fp.write(ppu.bgpd, 2 * 4 * 8);
+      fp.write(ppu.obpd, 2 * 4 * 8);
+    }
+  }
+  fp.close();
+  file::write({pathname, "sprite.ram"}, ppu.oam, 4 * 40);
+}
+
 Interface::Interface() {
   interface = this;
   hook = nullptr;
diff --git a/../../../git/Emulator/bsnes/bsnes/gb/interface/interface.hpp b/nSide_v005-source-revised/gb/interface/interface.hpp
index 822eb1f..3a55326 100644
--- a/../../../git/Emulator/bsnes/bsnes/gb/interface/interface.hpp
+++ b/nSide_v005-source-revised/gb/interface/interface.hpp
@@ -29,13 +29,11 @@ struct Interface : Emulator::Interface {
   //Super Game Boy bindings
   struct Hook {
     virtual void lcdScanline() {}
-    virtual void lcdOutput(uint2 color) {}
     virtual void joypWrite(bool p15, bool p14) {}
   };
   Hook* hook = nullptr;
 
   void lcdScanline();
-  void lcdOutput(uint2 color);
   void joypWrite(bool p15, bool p14);
 
   string title();
@@ -62,6 +60,9 @@ struct Interface : Emulator::Interface {
 
   void paletteUpdate(PaletteMode mode);
 
+  //debugger functions
+  void exportMemory();
+
   Interface();
 
 private:
diff --git a/../../../git/Emulator/bsnes/bsnes/gb/ppu/dmg.cpp b/nSide_v005-source-revised/gb/ppu/dmg.cpp
index 2d9b39b..6b8905d 100644
--- a/../../../git/Emulator/bsnes/bsnes/gb/ppu/dmg.cpp
+++ b/nSide_v005-source-revised/gb/ppu/dmg.cpp
@@ -79,7 +79,6 @@ void PPU::dmg_run() {
 
   uint32* output = screen + status.ly * 160 + px++;
   *output = color;
-  interface->lcdOutput(color);  //Super Game Boy notification
 }
 
 void PPU::dmg_run_bg() {
diff --git a/../../../git/Emulator/bsnes/bsnes/gb/ppu/ppu.cpp b/nSide_v005-source-revised/gb/ppu/ppu.cpp
index ecba6e8..27ddc00 100644
--- a/../../../git/Emulator/bsnes/bsnes/gb/ppu/ppu.cpp
+++ b/nSide_v005-source-revised/gb/ppu/ppu.cpp
@@ -25,8 +25,6 @@ void PPU::main() {
       scheduler.exit(Scheduler::ExitReason::SynchronizeEvent);
     }
 
-    interface->lcdScanline();  //Super Game Boy notification
-
     if(status.display_enable && status.ly < 144) {
       if(status.interrupt_oam) cpu.interrupt_raise(CPU::Interrupt::Stat);
       add_clocks(92);
@@ -58,6 +56,7 @@ void PPU::scanline() {
   if(++status.ly == 154) frame();
 
   if(status.ly < 144) {
+    interface->lcdScanline();  //Super Game Boy rendering notification
     system.cgb() ? cgb_scanline() : dmg_scanline();
   }
 
diff --git a/../../../git/Emulator/bsnes/bsnes/gba/gba.hpp b/nSide_v005-source-revised/gba/gba.hpp
index db5c97f..42a74da 100644
--- a/../../../git/Emulator/bsnes/bsnes/gba/gba.hpp
+++ b/nSide_v005-source-revised/gba/gba.hpp
@@ -6,16 +6,17 @@
 
 namespace GameBoyAdvance {
   namespace Info {
-    static const char Name[] = "bgba";
+    static const char Name[] = "higan-gba";
     static const unsigned SerializerVersion = 2;
   }
 }
 
 /*
-  bgba - Game Boy Advance emulator
+  higan-gba - Game Boy Advance emulator
+  based on higan/bgba by byuu and Cydrak.
   authors: byuu, Cydrak
   license: GPLv3
-  project started: 2012-03-19
+  original project started: 2012-03-19
 */
 
 #include <libco/libco.h>
diff --git a/../../../git/Emulator/bsnes/bsnes/gba/interface/interface.cpp b/nSide_v005-source-revised/gba/interface/interface.cpp
index e5618a5..e5fe42c 100644
--- a/../../../git/Emulator/bsnes/bsnes/gba/interface/interface.cpp
+++ b/nSide_v005-source-revised/gba/interface/interface.cpp
@@ -113,6 +113,21 @@ void Interface::paletteUpdate(PaletteMode mode) {
   video.generate_palette(mode);
 }
 
+void Interface::exportMemory() {
+  string pathname = {path(group(ID::ROM)), "debug/"};
+  directory::create(pathname);
+
+  file::write({pathname, "i-work.ram"}, cpu.iwram, 32 * 1024);
+  //file::write({pathname, "e-work.ram"}, cpu.ewram, 256 * 1024);
+  file::write({pathname, "video.ram"}, ppu.vram, 96 * 1024);
+  uint8 pal_data[1024];
+  for(unsigned color_id = 0; color_id < 512; color_id++) {
+    pal_data[(color_id << 1) + 0] = (ppu.pram[color_id] >> 0) & 0xFF;
+    pal_data[(color_id << 1) + 1] = (ppu.pram[color_id] >> 8) & 0x7F;
+  }
+  file::write({pathname, "palette.ram"}, pal_data, 1024);
+}
+
 Interface::Interface() {
   interface = this;
 
diff --git a/../../../git/Emulator/bsnes/bsnes/gba/interface/interface.hpp b/nSide_v005-source-revised/gba/interface/interface.hpp
index 8553e19..8277e01 100644
--- a/../../../git/Emulator/bsnes/bsnes/gba/interface/interface.hpp
+++ b/nSide_v005-source-revised/gba/interface/interface.hpp
@@ -45,6 +45,8 @@ struct Interface : Emulator::Interface {
 
   void paletteUpdate(PaletteMode mode);
 
+  void exportMemory();
+
   Interface();
 
 private:
diff --git a/../../../git/Emulator/bsnes/bsnes/gba/player/player.cpp b/nSide_v005-source-revised/gba/player/player.cpp
index 4248b91..a122953 100644
--- a/../../../git/Emulator/bsnes/bsnes/gba/player/player.cpp
+++ b/nSide_v005-source-revised/gba/player/player.cpp
@@ -56,20 +56,21 @@ void Player::frame() {
   }
 }
 
-maybe<uint16> Player::keyinput() {
-  if(status.logoDetected) {
-    switch(status.logoCounter) {
-    case 0: return 0x03ff;
-    case 1: return 0x03ff;
-    case 2: return 0x030f;
-    }
+optional<uint16> Player::keyinput() {
+  if(status.logoDetected == false) return false;
+
+  switch(status.logoCounter) {
+  case 0: return {true, 0x03ff};
+  case 1: return {true, 0x03ff};
+  case 2: return {true, 0x030f};
   }
-  return nothing;
+  unreachable;
 }
 
-maybe<uint32> Player::read() {
-  if(status.enable) return status.send;
-  return nothing;
+optional<uint32> Player::read() {
+  if(status.enable == false) return false;
+
+  return {true, status.send};
 }
 
 void Player::write(uint8 byte, uint2 addr) {
diff --git a/../../../git/Emulator/bsnes/bsnes/gba/player/player.hpp b/nSide_v005-source-revised/gba/player/player.hpp
index 8b73da1..c928062 100644
--- a/../../../git/Emulator/bsnes/bsnes/gba/player/player.hpp
+++ b/nSide_v005-source-revised/gba/player/player.hpp
@@ -14,8 +14,8 @@ struct Player {
   void power();
   void frame();
 
-  maybe<uint16> keyinput();
-  maybe<uint32> read();
+  optional<uint16> keyinput();
+  optional<uint32> read();
   void write(uint8 byte, uint2 addr);
 
   void serialize(serializer& s);
diff --git a/../../../git/Emulator/bsnes/bsnes/nall/Makefile b/nSide_v005-source-revised/nall/Makefile
index 9697bcd..bee3d22 100644
--- a/../../../git/Emulator/bsnes/bsnes/nall/Makefile
+++ b/nSide_v005-source-revised/nall/Makefile
@@ -34,45 +34,29 @@ ifeq ($(platform),)
   endif
 endif
 
-cflags := -x c -std=c99
-objcflags := -x objective-c -std=c99
-cppflags := -x c++ -std=c++11
-objcppflags := -x objective-c++ -std=c++11
-flags :=
-link :=
-
 # compiler detection
 ifeq ($(compiler),)
   ifeq ($(platform),windows)
     compiler := g++
+    flags :=
+    link :=
   else ifeq ($(platform),macosx)
     compiler := clang++
+    flags := -w -stdlib=libc++
+    link := -lc++ -lobjc
   else ifeq ($(platform),bsd)
-    compiler := g++47
+    compiler := clang++
+    flags := -w -I/usr/local/include
   else
     compiler := g++
+    flags :=
+    link :=
   endif
-endif
-
-# gcc settings
-ifeq ($(findstring g++,$(compiler)),g++)
-  flags += -fwrapv
-endif
-
-# clang settings
-ifeq ($(findstring clang++,$(compiler)),clang++)
-  flags += -fwrapv -w
-endif
-
-# macosx settings
-ifeq ($(platform),macosx)
-  flags += -stdlib=libc++
-  link += -lc++ -lobjc
-endif
 
-# bsd settings
-ifeq ($(platform),bsd)
-  flags += -I/usr/local/include
+  cflags := -x c -std=c99
+  objcflags := -x objective-c -std=c99
+  cppflags := -x c++ -std=c++11
+  objcppflags := -x objective-c++ -std=c++11
 endif
 
 # cross-compilation support
diff --git a/../../../git/Emulator/bsnes/bsnes/nall/bitvector.hpp b/../../../git/Emulator/bsnes/bsnes/nall/bitvector.hpp
deleted file mode 100644
index 0294b11..0000000
--- a/../../../git/Emulator/bsnes/bsnes/nall/bitvector.hpp
+++ /dev/null
@@ -1,118 +0,0 @@
-#ifndef NALL_BITVECTOR_HPP
-#define NALL_BITVECTOR_HPP
-
-namespace nall {
-
-struct bitvector {
-protected:
-  uint8_t* pool = nullptr;
-  unsigned bits = 0;
-
-public:
-  bitvector() {}
-  bitvector(unsigned size) { resize(size); }
-  bitvector(const bitvector& source) { operator=(source); }
-  bitvector(bitvector&& source) { operator=(std::move(source)); }
-  ~bitvector() { reset(); }
-
-  bitvector& operator=(const bitvector& source) {
-    bits = source.bits;
-    pool = (uint8_t*)realloc(pool, bytes());
-    memcpy(pool, source.pool, bytes());
-    return *this;
-  }
-
-  bitvector& operator=(bitvector&& source) {
-    pool = source.pool;
-    bits = source.bits;
-    source.pool = nullptr;
-    source.bits = 0;
-    return *this;
-  }
-
-  explicit operator bool() const { return bits > 0; }
-  bool empty() const { return bits == 0; }
-  unsigned size() const { return bits; }
-  unsigned bytes() const { return (bits + 7) / 8; }
-  uint8_t* data() { return pool; }
-  const uint8_t* data() const { return pool; }
-
-  void reset() {
-    if(pool) free(pool);
-    pool = nullptr;
-    bits = 0;
-  }
-
-  void resize(unsigned size) {
-    unsigned from = bits;
-    bits = size;
-    for(unsigned n = size; n < from; n++) clear(n);  //on reduce
-    pool = (uint8_t*)realloc(pool, bytes());
-    for(unsigned n = from; n < size; n++) clear(n);  //on expand
-  }
-
-  bool get(unsigned position) const {
-    return pool[position >> 3] & (0x80 >> (position & 7));
-  }
-
-  void clear() {
-    memset(pool, 0x00, bytes());
-  }
-
-  void set() {
-    memset(pool, 0xff, bytes());
-    for(unsigned n = bits; n < bytes() * 8; n++) clear(n);
-  }
-
-  void clear(unsigned position) {
-    pool[position >> 3] &= ~(0x80 >> (position & 7));
-  }
-
-  void set(unsigned position) {
-    pool[position >> 3] |=  (0x80 >> (position & 7));
-  }
-
-  void invert(unsigned position) {
-    get(position) ? clear(position) : set(position);
-  }
-
-  void set(unsigned position, bool value) {
-    value ? set(position) : clear(position);
-  }
-
-  struct reference {
-    reference(bitvector& self, unsigned position) : self(self), position(position) {}
-    operator bool() const { return self.get(position); }
-    void operator=(bool value) { self.set(position, value); }
-
-  protected:
-    bitvector& self;
-    unsigned position;
-  };
-
-  reference operator[](unsigned position) {
-    return reference(*this, position);
-  }
-
-  bool operator[](unsigned position) const {
-    return get(position);
-  }
-
-  struct iterator {
-    iterator(bitvector& self, unsigned position) : self(self), position(position) {}
-    bool operator!=(const iterator& source) const { return position != source.position; }
-    iterator& operator++() { position++; return *this; }
-    reference operator*() { return self.operator[](position); }
-
-  protected:
-    bitvector& self;
-    unsigned position;
-  };
-
-  iterator begin() { return iterator(*this, 0); }
-  iterator end() { return iterator(*this, bits); }
-};
-
-}
-
-#endif
diff --git a/../../../git/Emulator/bsnes/bsnes/nall/compositor.hpp b/nSide_v005-source-revised/nall/compositor.hpp
index fa83480..d895b81 100644
--- a/../../../git/Emulator/bsnes/bsnes/nall/compositor.hpp
+++ b/nSide_v005-source-revised/nall/compositor.hpp
@@ -9,7 +9,7 @@ struct compositor {
   inline static bool enabled();
   inline static bool enable(bool status);
 
-  #if defined(PLATFORM_XORG)
+  #if defined(PLATFORM_X)
   enum class Compositor : unsigned { Unknown, Metacity, Xfwm4 };
   inline static Compositor detect();
 
@@ -21,7 +21,7 @@ struct compositor {
   #endif
 };
 
-#if defined(PLATFORM_XORG)
+#if defined(PLATFORM_X)
 
 //Metacity
 
diff --git a/../../../git/Emulator/bsnes/bsnes/nall/dl.hpp b/nSide_v005-source-revised/nall/dl.hpp
index d0d0151..e61b45b 100644
--- a/../../../git/Emulator/bsnes/bsnes/nall/dl.hpp
+++ b/nSide_v005-source-revised/nall/dl.hpp
@@ -8,7 +8,7 @@
 #include <nall/string.hpp>
 #include <nall/utility.hpp>
 
-#if defined(PLATFORM_XORG) || defined(PLATFORM_MACOSX)
+#if defined(PLATFORM_X) || defined(PLATFORM_MACOSX)
   #include <dlfcn.h>
 #elif defined(PLATFORM_WINDOWS)
   #include <windows.h>
@@ -35,7 +35,7 @@ private:
   uintptr_t handle = 0;
 };
 
-#if defined(PLATFORM_XORG)
+#if defined(PLATFORM_X)
 inline bool library::open(const string& name, const string& path) {
   if(handle) close();
   handle = (uintptr_t)dlopen(string(path, !path.empty() && !path.endsWith("/") ? "/" : "", "lib", name, ".so"), RTLD_LAZY);
diff --git a/../../../git/Emulator/bsnes/bsnes/nall/dsp/core.hpp b/nSide_v005-source-revised/nall/dsp/core.hpp
index 9a00f63..ee730ab 100644
--- a/../../../git/Emulator/bsnes/bsnes/nall/dsp/core.hpp
+++ b/nSide_v005-source-revised/nall/dsp/core.hpp
@@ -19,7 +19,6 @@ struct Resampler {
   virtual void clear() = 0;
   virtual void sample() = 0;
   Resampler(DSP& dsp) : dsp(dsp) {}
-  virtual ~Resampler() {}
 };
 
 struct DSP {
diff --git a/../../../git/Emulator/bsnes/bsnes/nall/file.hpp b/nSide_v005-source-revised/nall/file.hpp
index 2cd28a1..721253d 100644
--- a/../../../git/Emulator/bsnes/bsnes/nall/file.hpp
+++ b/nSide_v005-source-revised/nall/file.hpp
@@ -188,7 +188,7 @@ struct file : varint {
     if(!fp) return;  //file not open
     buffer_flush();
 
-    intmax_t req_offset = file_offset;
+    uintmax_t req_offset = file_offset;
     switch(index_) {
     case index::absolute: req_offset  = offset; break;
     case index::relative: req_offset += offset; break;
diff --git a/../../../git/Emulator/bsnes/bsnes/nall/hashset.hpp b/nSide_v005-source-revised/nall/hashset.hpp
index 58bc136..3f51199 100644
--- a/../../../git/Emulator/bsnes/bsnes/nall/hashset.hpp
+++ b/nSide_v005-source-revised/nall/hashset.hpp
@@ -88,19 +88,19 @@ public:
     length = size;
   }
 
-  maybe<T&> find(const T& value) {
-    if(!pool) return nothing;
+  optional<T&> find(const T& value) {
+    if(!pool) return false;
 
     unsigned hash = value.hash() & (length - 1);
     while(pool[hash]) {
-      if(value == *pool[hash]) return *pool[hash];
+      if(value == *pool[hash]) return {true, *pool[hash]};
       if(++hash >= length) hash = 0;
     }
 
-    return nothing;
+    return false;
   }
 
-  maybe<T&> insert(const T& value) {
+  optional<T&> insert(const T& value) {
     if(!pool) pool = new T*[length]();
 
     //double pool size when load is >= 50%
@@ -111,7 +111,7 @@ public:
     while(pool[hash]) if(++hash >= length) hash = 0;
     pool[hash] = new T(value);
 
-    return *pool[hash];
+    return {true, *pool[hash]};
   }
 
   bool remove(const T& value) {
diff --git a/../../../git/Emulator/bsnes/bsnes/nall/hid.hpp b/nSide_v005-source-revised/nall/hid.hpp
index 77e6706..dc70888 100644
--- a/../../../git/Emulator/bsnes/bsnes/nall/hid.hpp
+++ b/nSide_v005-source-revised/nall/hid.hpp
@@ -23,11 +23,11 @@ namespace HID {
       input.append({name});
     }
 
-    maybe<unsigned> find(const string& name) {
+    optional<unsigned> find(const string& name) {
       for(unsigned id = 0; id < input.size(); id++) {
-        if(input[id].name == name) return id;
+        if(input[id].name == name) return {true, id};
       }
-      return nothing;
+      return false;
     }
   };
 
@@ -50,11 +50,11 @@ namespace HID {
       group.append({name});
     }
 
-    maybe<unsigned> find(const string& name) {
+    optional<unsigned> find(const string& name) {
       for(unsigned id = 0; id < group.size(); id++) {
-        if(group[id].name == name) return id;
+        if(group[id].name == name) return {true, id};
       }
-      return nothing;
+      return false;
     }
   };
 
diff --git a/../../../git/Emulator/bsnes/bsnes/nall/intrinsics.hpp b/nSide_v005-source-revised/nall/intrinsics.hpp
index da41094..2d6a43e 100644
--- a/../../../git/Emulator/bsnes/bsnes/nall/intrinsics.hpp
+++ b/nSide_v005-source-revised/nall/intrinsics.hpp
@@ -4,8 +4,8 @@
 namespace nall {
 
 struct Intrinsics {
-  enum class Compiler : unsigned { Clang, GCC, CL, Unknown };
-  enum class Platform : unsigned { Windows, MacOSX, Linux, BSD, Unknown };
+  enum class Compiler : unsigned { Clang, GCC, VisualCPP, Unknown };
+  enum class Platform : unsigned { Windows, MacOSX, X, Unknown };  //X = Linux, BSD, etc
   enum class Architecture : unsigned { x86, amd64, Unknown };
   enum class Endian : unsigned { LSB, MSB, Unknown };
 
@@ -20,20 +20,12 @@ struct Intrinsics {
 #if defined(__clang__)
   #define COMPILER_CLANG
   Intrinsics::Compiler Intrinsics::compiler() { return Intrinsics::Compiler::Clang; }
-
-  #pragma clang diagnostic ignored "-Wempty-body"
-  #pragma clang diagnostic ignored "-Wparentheses"
-  #pragma clang diagnostic ignored "-Wreturn-type"
-  #pragma clang diagnostic ignored "-Wswitch"
-  #pragma clang diagnostic ignored "-Wtautological-compare"
 #elif defined(__GNUC__)
   #define COMPILER_GCC
   Intrinsics::Compiler Intrinsics::compiler() { return Intrinsics::Compiler::GCC; }
 #elif defined(_MSC_VER)
-  #define COMPILER_CL
-  Intrinsics::Compiler Intrinsics::compiler() { return Intrinsics::Compiler::CL; }
-
-  #pragma warning(disable:4996)  //disable libc "deprecation" warnings
+  #define COMPILER_VISUALCPP
+  Intrinsics::Compiler Intrinsics::compiler() { return Intrinsics::Compiler::VisualCPP; }
 #else
   #warning "unable to detect compiler"
   #define COMPILER_UNKNOWN
@@ -48,14 +40,9 @@ struct Intrinsics {
 #elif defined(__APPLE__)
   #define PLATFORM_MACOSX
   Intrinsics::Platform Intrinsics::platform() { return Intrinsics::Platform::MacOSX; }
-#elif defined(linux) || defined(__linux__)
-  #define PLATFORM_LINUX
-  #define PLATFORM_XORG
-  Intrinsics::Platform Intrinsics::platform() { return Intrinsics::Platform::Linux; }
-#elif defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__NetBSD__) || defined(__OpenBSD__)
-  #define PLATFORM_BSD
-  #define PLATFORM_XORG
-  Intrinsics::Platform Intrinsics::platform() { return Intrinsics::Platform::BSD; }
+#elif defined(linux) || defined(__linux__) || defined(__sun__) || defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__NetBSD__) || defined(__OpenBSD__) || defined(__GNU__)
+  #define PLATFORM_X
+  Intrinsics::Platform Intrinsics::platform() { return Intrinsics::Platform::X; }
 #else
   #warning "unable to detect platform"
   #define PLATFORM_UNKNOWN
@@ -64,14 +51,6 @@ struct Intrinsics {
 
 /* Architecture Detection */
 
-#if defined(PLATFORM_MACOSX)
-  #include <machine/endian.h>
-#elif defined(PLATFORM_LINUX)
-  #include <endian.h>
-#elif defined(PLATFORM_BSD)
-  #include <sys/endian.h>
-#endif
-
 #if defined(__i386__) || defined(_M_IX86)
   #define ARCH_X86
   Intrinsics::Architecture Intrinsics::architecture() { return Intrinsics::Architecture::x86; }
diff --git a/../../../git/Emulator/bsnes/bsnes/nall/invoke.hpp b/nSide_v005-source-revised/nall/invoke.hpp
index 078f7f5..3e6d29c 100644
--- a/../../../git/Emulator/bsnes/bsnes/nall/invoke.hpp
+++ b/nSide_v005-source-revised/nall/invoke.hpp
@@ -27,7 +27,7 @@ template<typename... Args> inline void invoke(const string& name, Args&&... args
   ShellExecuteW(NULL, NULL, utf16_t(name), utf16_t(arguments), NULL, SW_SHOWNORMAL);
 }
 
-#elif defined(PLATFORM_XORG)
+#elif defined(PLATFORM_X)
 
 template<typename... Args> inline void invoke(const string& name, Args&&... args) {
   pid_t pid = fork();
diff --git a/nSide_v005-source-revised/nall/ips.hpp b/nSide_v005-source-revised/nall/ips.hpp
new file mode 100644
index 0000000..1159dee
--- /dev/null
+++ b/nSide_v005-source-revised/nall/ips.hpp
@@ -0,0 +1,100 @@
+#ifndef NALL_IPS_HPP
+#define NALL_IPS_HPP
+
+#include <nall/file.hpp>
+#include <nall/stdint.hpp>
+#include <nall/string.hpp>
+
+namespace nall {
+
+struct ips {
+  inline bool apply();
+  inline void source(const uint8_t* data, unsigned size);
+  inline void modify(const uint8_t* data, unsigned size);
+  inline ips();
+  inline ~ips();
+
+  uint8_t* data = nullptr;
+  unsigned size = 0;
+  const uint8_t* sourceData = nullptr;
+  unsigned sourceSize = 0;
+  const uint8_t* modifyData = nullptr;
+  unsigned modifySize = 0;
+};
+
+bool ips::apply() {
+  if(modifySize < 8) return false;
+  if(modifyData[0] != 'P') return false;
+  if(modifyData[1] != 'A') return false;
+  if(modifyData[2] != 'T') return false;
+  if(modifyData[3] != 'C') return false;
+  if(modifyData[4] != 'H') return false;
+
+  if(data) delete[] data;
+  data = new uint8_t[16 * 1024 * 1024 + 65536]();  //maximum size of IPS patch + single-tag padding
+  size = sourceSize;
+  memcpy(data, sourceData, sourceSize);
+  unsigned offset = 5;
+
+  while(true) {
+    unsigned address, length;
+
+    if(offset > modifySize - 3) break;
+    address  = modifyData[offset++] << 16;
+    address |= modifyData[offset++] <<  8;
+    address |= modifyData[offset++] <<  0;
+
+    if(address == 0x454f46) {  //EOF
+      if(offset == modifySize) return true;
+      if(offset == modifySize - 3) {
+        size  = modifyData[offset++] << 16;
+        size |= modifyData[offset++] <<  8;
+        size |= modifyData[offset++] <<  0;
+        return true;
+      }
+    }
+
+    if(offset > modifySize - 2) break;
+    length  = modifyData[offset++] << 8;
+    length |= modifyData[offset++] << 0;
+
+    if(length) {  //Copy
+      if(offset > modifySize - length) break;
+      while(length--) data[address++] = modifyData[offset++];
+    } else {  //RLE
+      if(offset > modifySize - 3) break;
+      length  = modifyData[offset++] << 8;
+      length |= modifyData[offset++] << 0;
+      if(length == 0) break;  //illegal
+      while(length--) data[address++] = modifyData[offset];
+      offset++;
+    }
+
+    size = max(size, address);
+  }
+
+  delete[] data;
+  data = nullptr;
+  return false;
+}
+
+void ips::source(const uint8_t* data, unsigned size) {
+  sourceData = data, sourceSize = size;
+}
+
+void ips::modify(const uint8_t* data, unsigned size) {
+  modifyData = data, modifySize = size;
+}
+
+ips::ips() {
+}
+
+ips::~ips() {
+  if(data) delete[] data;
+  if(sourceData) delete[] sourceData;
+  if(modifyData) delete[] modifyData;
+}
+
+}
+
+#endif
diff --git a/../../../git/Emulator/bsnes/bsnes/nall/map.hpp b/nSide_v005-source-revised/nall/map.hpp
index 72c99ea..56e4b5c 100644
--- a/../../../git/Emulator/bsnes/bsnes/nall/map.hpp
+++ b/nSide_v005-source-revised/nall/map.hpp
@@ -16,9 +16,9 @@ template<typename T, typename U> struct map {
     node_t(const T& key, const U& value) : key(key), value(value) {}
   };
 
-  maybe<U&> find(const T& key) const {
-    if(auto node = root.find({key})) return node().value;
-    return nothing;
+  optional<U> find(const T& key) const {
+    if(auto node = root.find({key})) return {true, node().value};
+    return false;
   }
 
   void insert(const T& key, const U& value) { root.insert({key, value}); }
@@ -36,8 +36,8 @@ protected:
 };
 
 template<typename T, typename U> struct bimap {
-  maybe<U&> find(const T& key) const { return tmap.find(key); }
-  maybe<T&> find(const U& key) const { return umap.find(key); }
+  optional<U> find(const T& key) const { return tmap.find(key); }
+  optional<T> find(const U& key) const { return umap.find(key); }
   void insert(const T& key, const U& value) { tmap.insert(key, value); umap.insert(value, key); }
   void remove(const T& key) { if(auto p = tmap.find(key)) { umap.remove(p().value); tmap.remove(key); } }
   void remove(const U& key) { if(auto p = umap.find(key)) { tmap.remove(p().value); umap.remove(key); } }
diff --git a/../../../git/Emulator/bsnes/bsnes/nall/maybe.hpp b/../../../git/Emulator/bsnes/bsnes/nall/maybe.hpp
deleted file mode 100644
index 4f806da..0000000
--- a/../../../git/Emulator/bsnes/bsnes/nall/maybe.hpp
+++ /dev/null
@@ -1,76 +0,0 @@
-#ifndef NALL_MAYBE_HPP
-#define NALL_MAYBE_HPP
-
-namespace nall {
-
-struct nothing_t {};
-static nothing_t nothing;
-
-template<typename T>
-class maybe {
-  T* value = nullptr;
-
-public:
-  maybe() {}
-  maybe(nothing_t) {}
-  maybe(const T& source) { operator=(source); }
-  maybe(const maybe& source) { operator=(source); }
-  maybe(maybe&& source) { operator=(std::move(source)); }
-  ~maybe() { reset(); }
-
-  maybe& operator=(nothing_t) { reset(); return *this; }
-  maybe& operator=(const T& source) { reset(); value = new T(source); return *this; }
-  maybe& operator=(const maybe& source) { reset(); if(source) value = new T(source()); return *this; }
-  maybe& operator=(maybe&& source) { reset(); value = source.value; source.value = nullptr; return *this; }
-
-  bool operator==(const maybe& source) const {
-    if(value && source.value) return *value == *source.value;
-    return !value && !source.value;
-  }
-  bool operator!=(const maybe& source) const { return !operator==(source); }
-
-  explicit operator bool() const { return value; }
-  T& operator()() { assert(value); return *value; }
-  const T& operator()() const { assert(value); return *value; }
-  const T& operator()(const T& invalid) const { if(value) return *value; return invalid; }
-
-  bool empty() const { return value == nullptr; }
-  void reset() { if(value) { delete value; value = nullptr; } }
-  void swap(maybe& source) { std::swap(value, source.value); }
-};
-
-template<typename T>
-class maybe<T&> {
-  T* value = nullptr;
-
-public:
-  maybe() {}
-  maybe(nothing_t) {}
-  maybe(const T& source) { operator=(source); }
-  maybe(const maybe& source) { operator=(source); }
-  maybe(maybe&& source) { operator=(std::move(source)); }
-
-  maybe& operator=(nothing_t) { value = nullptr; return *this; }
-  maybe& operator=(const T& source) { value = (T*)&source; return *this; }
-  maybe& operator=(const maybe& source) { value = source.value; return *this; }
-  maybe& operator=(maybe&& source) { value = source.value; source.value = nullptr; return *this; }
-
-  bool operator==(const maybe& source) const {
-    if(value && source.value) return *value == *source.value;
-    return !value && !source.value;
-  }
-  bool operator!=(const maybe& source) const { return !operator==(source); }
-
-  explicit operator bool() const { return value; }
-  T& operator()() { assert(value); return *value; }
-  const T& operator()() const { assert(value); return *value; }
-  const T& operator()(const T& invalid) const { if(value) return *value; return invalid; }
-
-  bool empty() const { return value == nullptr; }
-  void reset() { value = nullptr; }
-  void swap(maybe& source) { std::swap(value, source.value); }
-};
-
-}
-
-#endif
diff --git a/../../../git/Emulator/bsnes/bsnes/nall/nall.hpp b/nSide_v005-source-revised/nall/nall.hpp
index 3898aa6..f021e13 100644
--- a/../../../git/Emulator/bsnes/bsnes/nall/nall.hpp
+++ b/nSide_v005-source-revised/nall/nall.hpp
@@ -11,7 +11,6 @@
 #include <nall/atoi.hpp>
 #include <nall/base64.hpp>
 #include <nall/bit.hpp>
-#include <nall/bitvector.hpp>
 #include <nall/bmp.hpp>
 #include <nall/config.hpp>
 #include <nall/crc16.hpp>
@@ -34,7 +33,6 @@
 #include <nall/invoke.hpp>
 #include <nall/map.hpp>
 #include <nall/matrix.hpp>
-#include <nall/maybe.hpp>
 #include <nall/png.hpp>
 #include <nall/property.hpp>
 #include <nall/random.hpp>
@@ -58,7 +56,7 @@
   #include <nall/windows/utf8.hpp>
 #endif
 
-#if defined(PLATFORM_XORG)
+#if defined(PLATFORM_X)
   #include <nall/serial.hpp>
 #endif
 
diff --git a/../../../git/Emulator/bsnes/bsnes/nall/platform.hpp b/nSide_v005-source-revised/nall/platform.hpp
index d6d85da..2457679 100644
--- a/../../../git/Emulator/bsnes/bsnes/nall/platform.hpp
+++ b/nSide_v005-source-revised/nall/platform.hpp
@@ -1,20 +1,22 @@
 #ifndef NALL_PLATFORM_HPP
 #define NALL_PLATFORM_HPP
 
-#include <nall/intrinsics.hpp>
-
 namespace Math {
   static const long double e  = 2.71828182845904523536;
   static const long double Pi = 3.14159265358979323846;
 }
 
-#if defined(PLATFORM_WINDOWS)
+#if defined(_WIN32)
   //minimum version needed for _wstat64, etc
   #undef  __MSVCRT_VERSION__
   #define __MSVCRT_VERSION__ 0x0601
   #include <nall/windows/utf8.hpp>
 #endif
 
+//=========================
+//standard platform headers
+//=========================
+
 #include <limits>
 #include <utility>
 
@@ -31,7 +33,7 @@ namespace Math {
 #include <sys/types.h>
 #include <sys/stat.h>
 
-#if defined(PLATFORM_WINDOWS)
+#if defined(_WIN32)
   #include <io.h>
   #include <direct.h>
   #include <shlobj.h>
@@ -39,17 +41,22 @@ namespace Math {
   #undef interface
   #define dllexport __declspec(dllexport)
 #else
-  #include <dlfcn.h>
+  #include <endian.h>
   #include <unistd.h>
   #include <pwd.h>
   #define dllexport
 #endif
 
-#if defined(COMPILER_CL)
+//==========
+//Visual C++
+//==========
+
+#if defined(_MSC_VER)
+  #pragma warning(disable:4996)  //disable libc "deprecation" warnings
   #define va_copy(dest, src) ((dest) = (src))
 #endif
 
-#if defined(PLATFORM_WINDOWS)
+#if defined(_WIN32)
   __declspec(dllimport) int _fileno(FILE*);
 
   inline int access(const char* path, int amode) { return _waccess(nall::utf16_t(path), amode); }
@@ -61,18 +68,26 @@ namespace Math {
   inline void usleep(unsigned milliseconds) { Sleep(milliseconds / 1000); }
 #endif
 
-#if defined(COMPILER_CLANG) || defined(COMPILER_GCC)
-  #define neverinline   __attribute__((noinline))
+//================
+//inline expansion
+//================
+
+#if defined(__clang__) || defined(__GNUC__)
+  #define noinline      __attribute__((noinline))
   #define alwaysinline  inline __attribute__((always_inline))
-#elif defined(COMPILER_CL)
-  #define neverinline   __declspec(noinline)
+#elif defined(_MSC_VER)
+  #define noinline      __declspec(noinline)
   #define alwaysinline  inline __forceinline
 #else
-  #define neverinline
+  #define noinline
   #define alwaysinline  inline
 #endif
 
-#if defined(COMPILER_CLANG) || defined(COMPILER_GCC)
+//===========
+//unreachable
+//===========
+
+#if defined(__clang__) || defined(__GNUC__)
   #define unreachable __builtin_unreachable()
 #else
   #define unreachable throw
diff --git a/../../../git/Emulator/bsnes/bsnes/nall/serial.hpp b/nSide_v005-source-revised/nall/serial.hpp
index 63f9f0b..ce6bcf8 100644
--- a/../../../git/Emulator/bsnes/bsnes/nall/serial.hpp
+++ b/nSide_v005-source-revised/nall/serial.hpp
@@ -5,7 +5,7 @@
 #include <nall/stdint.hpp>
 #include <nall/string.hpp>
 
-#if !defined(PLATFORM_XORG) && !defined(PLATFORM_MACOSX)
+#if !defined(PLATFORM_X) && !defined(PLATFORM_MACOSX)
   #error "nall/serial: unsupported platform"
 #endif
 
diff --git a/../../../git/Emulator/bsnes/bsnes/nall/set.hpp b/nSide_v005-source-revised/nall/set.hpp
index d463296..c8003ec 100644
--- a/../../../git/Emulator/bsnes/bsnes/nall/set.hpp
+++ b/nSide_v005-source-revised/nall/set.hpp
@@ -45,22 +45,22 @@ template<typename T> struct set {
     nodes = 0;
   }
 
-  maybe<T&> find(const T& value) {
+  optional<T&> find(const T& value) {
     if(node_t* node = find(root, value)) return node->value;
-    return nothing;
+    return false;
   }
 
-  maybe<const T&> find(const T& value) const {
+  optional<const T&> find(const T& value) const {
     if(node_t* node = find(root, value)) return node->value;
-    return nothing;
+    return false;
   }
 
-  maybe<T&> insert(const T& value) {
+  optional<T&> insert(const T& value) {
     unsigned count = size();
     node_t* v = insert(root, value);
     root->red = 0;
-    if(size() == count) return nothing;
-    return v->value;
+    if(size() == count) return false;
+    return {true, v->value};
   }
 
   template<typename... Args> bool insert(const T& value, Args&&... args) {
diff --git a/../../../git/Emulator/bsnes/bsnes/nall/string/base.hpp b/nSide_v005-source-revised/nall/string/base.hpp
index 8da9d88..284c231 100644
--- a/../../../git/Emulator/bsnes/bsnes/nall/string/base.hpp
+++ b/nSide_v005-source-revised/nall/string/base.hpp
@@ -107,10 +107,10 @@ public:
 
   inline string& strip();
 
-  inline maybe<unsigned> find(rstring key) const;
-  inline maybe<unsigned> ifind(rstring key) const;
-  inline maybe<unsigned> qfind(rstring key) const;
-  inline maybe<unsigned> iqfind(rstring key) const;
+  inline optional<unsigned> find(rstring key) const;
+  inline optional<unsigned> ifind(rstring key) const;
+  inline optional<unsigned> qfind(rstring key) const;
+  inline optional<unsigned> iqfind(rstring key) const;
 
   //core.hpp
   inline explicit operator bool() const;
@@ -155,7 +155,7 @@ public:
 
 //list.hpp
 struct lstring : vector<string> {
-  inline maybe<unsigned> find(rstring) const;
+  inline optional<unsigned> find(rstring) const;
   inline string merge(const string&) const;
   inline lstring& isort();
   inline lstring& strip();
@@ -201,7 +201,6 @@ template<signed precision = 0, char padchar = '0'> inline string binary(uintmax_
 //platform.hpp
 inline string activepath();
 inline string realpath(const string& name);
-inline string programpath();
 inline string userpath();
 inline string configpath();
 inline string sharedpath();
diff --git a/../../../git/Emulator/bsnes/bsnes/nall/string/char/base.hpp b/nSide_v005-source-revised/nall/string/char/base.hpp
index 49b2fc2..0a029b2 100644
--- a/../../../git/Emulator/bsnes/bsnes/nall/string/char/base.hpp
+++ b/nSide_v005-source-revised/nall/string/char/base.hpp
@@ -36,11 +36,11 @@ inline bool strccat(char* target, const char* source, unsigned length);
 inline void strpcpy(char*& target, const char* source, unsigned& length);
 
 //strpos.hpp
-inline maybe<unsigned> strpos(const char* str, const char* key);
-inline maybe<unsigned> istrpos(const char* str, const char* key);
-inline maybe<unsigned> qstrpos(const char* str, const char* key);
-inline maybe<unsigned> iqstrpos(const char* str, const char* key);
-template<bool Insensitive = false, bool Quoted = false> inline maybe<unsigned> ustrpos(const char* str, const char* key);
+inline optional<unsigned> strpos(const char* str, const char* key);
+inline optional<unsigned> istrpos(const char* str, const char* key);
+inline optional<unsigned> qstrpos(const char* str, const char* key);
+inline optional<unsigned> iqstrpos(const char* str, const char* key);
+template<bool Insensitive = false, bool Quoted = false> inline optional<unsigned> ustrpos(const char* str, const char* key);
 
 //trim.hpp
 template<unsigned Limit = 0> inline char* ltrim(char* str, const char* key = " ");
diff --git a/../../../git/Emulator/bsnes/bsnes/nall/string/char/convert.hpp b/nSide_v005-source-revised/nall/string/char/convert.hpp
index aa003a4..72e30a1 100644
--- a/../../../git/Emulator/bsnes/bsnes/nall/string/char/convert.hpp
+++ b/nSide_v005-source-revised/nall/string/char/convert.hpp
@@ -24,26 +24,22 @@ char* strupper(char* str) {
 
 char* qstrlower(char* s) {
   if(!s) return nullptr;
-  char* base = s;
   bool quoted = false;
   while(*s) {
     if(*s == '\"' || *s == '\'') quoted ^= 1;
     if(quoted == false && *s >= 'A' && *s <= 'Z') *s += 0x20;
     s++;
   }
-  return base;
 }
 
 char* qstrupper(char* s) {
   if(!s) return nullptr;
-  char* base = s;
   bool quoted = false;
   while(*s) {
     if(*s == '\"' || *s == '\'') quoted ^= 1;
     if(quoted == false && *s >= 'a' && *s <= 'z') *s -= 0x20;
     s++;
   }
-  return base;
 }
 
 char* strtr(char* dest, const char* before, const char* after) {
diff --git a/../../../git/Emulator/bsnes/bsnes/nall/string/char/strpos.hpp b/nSide_v005-source-revised/nall/string/char/strpos.hpp
index 8c0baa4..19c2321 100644
--- a/../../../git/Emulator/bsnes/bsnes/nall/string/char/strpos.hpp
+++ b/nSide_v005-source-revised/nall/string/char/strpos.hpp
@@ -7,26 +7,26 @@
 namespace nall {
 
 template<bool Insensitive, bool Quoted>
-maybe<unsigned> ustrpos(const char* str, const char* key) {
+optional<unsigned> ustrpos(const char* str, const char* key) {
   const char* base = str;
 
   while(*str) {
     if(quoteskip<Quoted>(str)) continue;
     for(unsigned n = 0;; n++) {
-      if(key[n] == 0) return (unsigned)(str - base);
-      if(str[n] == 0) return nothing;
+      if(key[n] == 0) return {true, (unsigned)(str - base)};
+      if(str[n] == 0) return false;
       if(!chrequal<Insensitive>(str[n], key[n])) break;
     }
     str++;
   }
 
-  return nothing;
+  return false;
 }
 
-maybe<unsigned> strpos(const char* str, const char* key) { return ustrpos<false, false>(str, key); }
-maybe<unsigned> istrpos(const char* str, const char* key) { return ustrpos<true, false>(str, key); }
-maybe<unsigned> qstrpos(const char* str, const char* key) { return ustrpos<false, true>(str, key); }
-maybe<unsigned> iqstrpos(const char* str, const char* key) { return ustrpos<true, true>(str, key); }
+optional<unsigned> strpos(const char* str, const char* key) { return ustrpos<false, false>(str, key); }
+optional<unsigned> istrpos(const char* str, const char* key) { return ustrpos<true, false>(str, key); }
+optional<unsigned> qstrpos(const char* str, const char* key) { return ustrpos<false, true>(str, key); }
+optional<unsigned> iqstrpos(const char* str, const char* key) { return ustrpos<true, true>(str, key); }
 
 }
 
diff --git a/../../../git/Emulator/bsnes/bsnes/nall/string/eval/evaluator.hpp b/nSide_v005-source-revised/nall/string/eval/evaluator.hpp
index 8957a30..49ac851 100644
--- a/../../../git/Emulator/bsnes/bsnes/nall/string/eval/evaluator.hpp
+++ b/nSide_v005-source-revised/nall/string/eval/evaluator.hpp
@@ -93,16 +93,16 @@ inline int64_t evaluateInteger(Node* node) {
   throw "invalid operator";
 }
 
-inline maybe<int64_t> integer(const string& expression) {
+inline optional<int64_t> integer(const string& expression) {
   try {
     auto tree = new Node;
     const char* p = expression;
     parse(tree, p, 0);
     auto result = evaluateInteger(tree);
     delete tree;
-    return result;
+    return {true, result};
   } catch(const char*) {
-    return nothing;
+    return false;
   }
 }
 
@@ -138,16 +138,16 @@ inline long double evaluateReal(Node* node) {
   throw "invalid operator";
 }
 
-inline maybe<long double> real(const string& expression) {
+inline optional<long double> real(const string& expression) {
   try {
     auto tree = new Node;
     const char* p = expression;
     parse(tree, p, 0);
     auto result = evaluateReal(tree);
     delete tree;
-    return result;
+    return {true, result};
   } catch(const char*) {
-    return nothing;
+    return false;
   }
 }
 
diff --git a/../../../git/Emulator/bsnes/bsnes/nall/string/list.hpp b/nSide_v005-source-revised/nall/string/list.hpp
index 55b2e76..196a7a5 100644
--- a/../../../git/Emulator/bsnes/bsnes/nall/string/list.hpp
+++ b/nSide_v005-source-revised/nall/string/list.hpp
@@ -2,11 +2,11 @@
 
 namespace nall {
 
-maybe<unsigned> lstring::find(rstring key) const {
+optional<unsigned> lstring::find(rstring key) const {
   for(unsigned i = 0; i < size(); i++) {
-    if(operator[](i) == key) return i;
+    if(operator[](i) == key) return {true, i};
   }
-  return nothing;
+  return false;
 }
 
 string lstring::merge(const string& separator) const {
diff --git a/../../../git/Emulator/bsnes/bsnes/nall/string/platform.hpp b/nSide_v005-source-revised/nall/string/platform.hpp
index d80060f..e71bd32 100644
--- a/../../../git/Emulator/bsnes/bsnes/nall/string/platform.hpp
+++ b/nSide_v005-source-revised/nall/string/platform.hpp
@@ -22,20 +22,6 @@ string realpath(const string& name) {
   return result;
 }
 
-string programpath() {
-  #if defined(PLATFORM_WINDOWS)
-  int argc = 0;
-  wchar_t** argv = CommandLineToArgvW(GetCommandLine(), &argc);
-  string argv0 = (const char*)utf8_t(argv[0]);
-  LocalFree(argv);
-  return realpath(argv0);
-  #else
-  Dl_info info;
-  dladdr((void*)&programpath, &info);
-  return realpath(info.dli_fname);
-  #endif
-}
-
 // /home/username/
 // c:/users/username/
 string userpath() {
diff --git a/../../../git/Emulator/bsnes/bsnes/nall/string/wrapper.hpp b/nSide_v005-source-revised/nall/string/wrapper.hpp
index 0eadf3d..0422ecd 100644
--- a/../../../git/Emulator/bsnes/bsnes/nall/string/wrapper.hpp
+++ b/nSide_v005-source-revised/nall/string/wrapper.hpp
@@ -114,10 +114,10 @@ string& string::strip() {
   return *this;
 }
 
-maybe<unsigned> string::find(rstring key) const { return strpos(data(), key); }
-maybe<unsigned> string::ifind(rstring key) const { return istrpos(data(), key); }
-maybe<unsigned> string::qfind(rstring key) const { return qstrpos(data(), key); }
-maybe<unsigned> string::iqfind(rstring key) const { return iqstrpos(data(), key); }
+optional<unsigned> string::find(rstring key) const { return strpos(data(), key); }
+optional<unsigned> string::ifind(rstring key) const { return istrpos(data(), key); }
+optional<unsigned> string::qfind(rstring key) const { return qstrpos(data(), key); }
+optional<unsigned> string::iqfind(rstring key) const { return iqstrpos(data(), key); }
 
 }
 
diff --git a/../../../git/Emulator/bsnes/bsnes/nall/thread.hpp b/nSide_v005-source-revised/nall/thread.hpp
index 5cd2846..96536df 100644
--- a/../../../git/Emulator/bsnes/bsnes/nall/thread.hpp
+++ b/nSide_v005-source-revised/nall/thread.hpp
@@ -5,9 +5,8 @@
 #include <nall/function.hpp>
 #include <nall/intrinsics.hpp>
 
-#if defined(PLATFORM_XORG) || defined(PLATFORM_MACOSX)
-
-#include <pthread.h>
+#if defined(PLATFORM_X) || defined(PLATFORM_MACOSX)
+  #include <pthread.h>
 
 namespace nall {
 
@@ -65,9 +64,7 @@ void* thread_entry_point(void* parameter) {
 }
 
 }
-
 #elif defined(PLATFORM_WINDOWS)
-
 namespace nall {
 
 inline DWORD WINAPI thread_entry_point(LPVOID);
@@ -125,7 +122,6 @@ inline DWORD WINAPI thread_entry_point(LPVOID parameter) {
 }
 
 }
-
 #endif
 
 #endif
diff --git a/nSide_v005-source-revised/nall/ups.hpp b/nSide_v005-source-revised/nall/ups.hpp
new file mode 100644
index 0000000..d26a651
--- /dev/null
+++ b/nSide_v005-source-revised/nall/ups.hpp
@@ -0,0 +1,225 @@
+#ifndef NALL_UPS_HPP
+#define NALL_UPS_HPP
+
+#include <nall/crc32.hpp>
+#include <nall/file.hpp>
+#include <nall/function.hpp>
+#include <nall/stdint.hpp>
+
+namespace nall {
+
+struct ups {
+  enum class result : unsigned {
+    unknown,
+    success,
+    patch_unwritable,
+    patch_invalid,
+    source_invalid,
+    target_invalid,
+    target_too_small,
+    patch_checksum_invalid,
+    source_checksum_invalid,
+    target_checksum_invalid,
+  };
+
+  function<void (unsigned offset, unsigned length)> progress;
+
+  result create(
+    const uint8_t* sourcedata, unsigned sourcelength,
+    const uint8_t* targetdata, unsigned targetlength,
+    const char* patchfilename
+  ) {
+    source_data = (uint8_t*)sourcedata, target_data = (uint8_t*)targetdata;
+    source_length = sourcelength, target_length = targetlength;
+    source_offset = target_offset = 0;
+    source_checksum = target_checksum = patch_checksum = ~0;
+
+    if(patch_file.open(patchfilename, file::mode::write) == false) return result::patch_unwritable;
+
+    patch_write('U');
+    patch_write('P');
+    patch_write('S');
+    patch_write('1');
+    encode(source_length);
+    encode(target_length);
+
+    unsigned output_length = source_length > target_length ? source_length : target_length;
+    unsigned relative = 0;
+    for(unsigned offset = 0; offset < output_length;) {
+      uint8_t x = source_read();
+      uint8_t y = target_read();
+
+      if(x == y) {
+        offset++;
+        continue;
+      }
+
+      encode(offset++ - relative);
+      patch_write(x ^ y);
+
+      while(true) {
+        if(offset >= output_length) {
+          patch_write(0x00);
+          break;
+        }
+
+        x = source_read();
+        y = target_read();
+        offset++;
+        patch_write(x ^ y);
+        if(x == y) break;
+      }
+
+      relative = offset;
+    }
+
+    source_checksum = ~source_checksum;
+    target_checksum = ~target_checksum;
+    for(unsigned i = 0; i < 4; i++) patch_write(source_checksum >> (i * 8));
+    for(unsigned i = 0; i < 4; i++) patch_write(target_checksum >> (i * 8));
+    uint32_t patch_result_checksum = ~patch_checksum;
+    for(unsigned i = 0; i < 4; i++) patch_write(patch_result_checksum >> (i * 8));
+
+    patch_file.close();
+    return result::success;
+  }
+
+  result apply(
+    const uint8_t* patchdata, unsigned patchlength,
+    const uint8_t* sourcedata, unsigned sourcelength,
+    uint8_t* targetdata, unsigned& targetlength
+  ) {
+    patch_data = (uint8_t*)patchdata, source_data = (uint8_t*)sourcedata, target_data = targetdata;
+    patch_length = patchlength, source_length = sourcelength, target_length = targetlength;
+    patch_offset = source_offset = target_offset = 0;
+    patch_checksum = source_checksum = target_checksum = ~0;
+
+    if(patch_length < 18) return result::patch_invalid;
+    if(patch_read() != 'U') return result::patch_invalid;
+    if(patch_read() != 'P') return result::patch_invalid;
+    if(patch_read() != 'S') return result::patch_invalid;
+    if(patch_read() != '1') return result::patch_invalid;
+
+    unsigned source_read_length = decode();
+    unsigned target_read_length = decode();
+
+    if(source_length != source_read_length && source_length != target_read_length) return result::source_invalid;
+    targetlength = (source_length == source_read_length ? target_read_length : source_read_length);
+    if(target_length < targetlength) return result::target_too_small;
+    target_length = targetlength;
+
+    while(patch_offset < patch_length - 12) {
+      unsigned length = decode();
+      while(length--) target_write(source_read());
+      while(true) {
+        uint8_t patch_xor = patch_read();
+        target_write(patch_xor ^ source_read());
+        if(patch_xor == 0) break;
+      }
+    }
+    while(source_offset < source_length) target_write(source_read());
+    while(target_offset < target_length) target_write(source_read());
+
+    uint32_t patch_read_checksum = 0, source_read_checksum = 0, target_read_checksum = 0;
+    for(unsigned i = 0; i < 4; i++) source_read_checksum |= patch_read() << (i * 8);
+    for(unsigned i = 0; i < 4; i++) target_read_checksum |= patch_read() << (i * 8);
+    uint32_t patch_result_checksum = ~patch_checksum;
+    source_checksum = ~source_checksum;
+    target_checksum = ~target_checksum;
+    for(unsigned i = 0; i < 4; i++) patch_read_checksum  |= patch_read() << (i * 8);
+
+    if(patch_result_checksum != patch_read_checksum) return result::patch_invalid;
+    if(source_checksum == source_read_checksum && source_length == source_read_length) {
+      if(target_checksum == target_read_checksum && target_length == target_read_length) return result::success;
+      return result::target_invalid;
+    } else if(source_checksum == target_read_checksum && source_length == target_read_length) {
+      if(target_checksum == source_read_checksum && target_length == source_read_length) return result::success;
+      return result::target_invalid;
+    } else {
+      return result::source_invalid;
+    }
+  }
+
+private:
+  uint8_t* patch_data = nullptr;
+  uint8_t* source_data = nullptr;
+  uint8_t* target_data = nullptr;
+  unsigned patch_length, source_length, target_length;
+  unsigned patch_offset, source_offset, target_offset;
+  unsigned patch_checksum, source_checksum, target_checksum;
+  file patch_file;
+
+  uint8_t patch_read() {
+    if(patch_offset < patch_length) {
+      uint8_t n = patch_data[patch_offset++];
+      patch_checksum = crc32_adjust(patch_checksum, n);
+      return n;
+    }
+    return 0x00;
+  }
+
+  uint8_t source_read() {
+    if(source_offset < source_length) {
+      uint8_t n = source_data[source_offset++];
+      source_checksum = crc32_adjust(source_checksum, n);
+      return n;
+    }
+    return 0x00;
+  }
+
+  uint8_t target_read() {
+    uint8_t result = 0x00;
+    if(target_offset < target_length) {
+      result = target_data[target_offset];
+      target_checksum = crc32_adjust(target_checksum, result);
+    }
+    if(((target_offset++ & 255) == 0) && progress) {
+      progress(target_offset, source_length > target_length ? source_length : target_length);
+    }
+    return result;
+  }
+
+  void patch_write(uint8_t n) {
+    patch_file.write(n);
+    patch_checksum = crc32_adjust(patch_checksum, n);
+  }
+
+  void target_write(uint8_t n) {
+    if(target_offset < target_length) {
+      target_data[target_offset] = n;
+      target_checksum = crc32_adjust(target_checksum, n);
+    }
+    if(((target_offset++ & 255) == 0) && progress) {
+      progress(target_offset, source_length > target_length ? source_length : target_length);
+    }
+  }
+
+  void encode(uint64_t offset) {
+    while(true) {
+      uint64_t x = offset & 0x7f;
+      offset >>= 7;
+      if(offset == 0) {
+        patch_write(0x80 | x);
+        break;
+      }
+      patch_write(x);
+      offset--;
+    }
+  }
+
+  uint64_t decode() {
+    uint64_t offset = 0, shift = 1;
+    while(true) {
+      uint8_t x = patch_read();
+      offset += (x & 0x7f) * shift;
+      if(x & 0x80) break;
+      shift <<= 7;
+      offset += shift;
+    }
+    return offset;
+  }
+};
+
+}
+
+#endif
diff --git a/../../../git/Emulator/bsnes/bsnes/nall/utility.hpp b/nSide_v005-source-revised/nall/utility.hpp
index f574a76..0447b94 100644
--- a/../../../git/Emulator/bsnes/bsnes/nall/utility.hpp
+++ b/nSide_v005-source-revised/nall/utility.hpp
@@ -1,7 +1,9 @@
 #ifndef NALL_UTILITY_HPP
 #define NALL_UTILITY_HPP
 
+#include <type_traits>
 #include <utility>
+#include <nall/any.hpp>
 
 namespace nall {
 
@@ -10,6 +12,121 @@ template<typename T> struct base_from_member {
   base_from_member(T value) : value(value) {}
 };
 
+template<typename T> struct ref {
+  T& operator*() {
+    if(type == Type::Reference) return *any_cast<T*>(value);
+    return any_cast<T&>(value);
+  }
+
+  operator T&() { return operator*(); }
+
+  ref(T& value) : type(Type::Reference), value(&value) {}
+  ref(T&& value) : type(Type::Temporary), value(value) {}
+
+protected:
+  enum class Type : unsigned { Reference, Temporary } type;
+  any value;
+};
+
+template<typename TT> struct optional {
+  typedef typename std::remove_reference<TT>::type T;
+  static const bool isConst = std::is_const<TT>::value;
+  static const bool isReference = std::is_reference<TT>::value;
+  struct optional_value_not_valid{};
+
+  bool valid = false;
+  T* value = nullptr;
+
+  operator bool() const { return valid; }
+
+  void reset() {
+    valid = false;
+    if(value) {
+      if(!isReference) delete value;
+      value = nullptr;
+    }
+  }
+
+  template<typename = typename std::enable_if<!isConst>::type>
+  T& operator*() {
+    if(!valid) throw optional_value_not_valid{};
+    return *value;
+  }
+
+  template<typename = typename std::enable_if<!isConst>::type>
+  T& operator()() {
+    if(!valid) throw optional_value_not_valid{};
+    return *value;
+  }
+
+  const T& operator*() const {
+    if(!valid) throw optional_value_not_valid{};
+    return *value;
+  }
+
+  const T& operator()() const {
+    if(!valid) throw optional_value_not_valid{};
+    return *value;
+  }
+
+  const T& operator()(const T& alternate) const {
+    if(!valid) return alternate;
+    return *value;
+  }
+
+  const bool operator==(const optional& source) const {
+    if(valid && source.valid) return *value == *source.value;
+    if(!valid && !source.valid) return true;
+    return false;
+  }
+
+  const bool operator!=(const optional& source) const {
+    return !operator==(source);
+  }
+
+  optional& operator=(const T& source) {
+    reset();
+    valid = true;
+    if(isReference) value = (T*)&source;
+    else value = new T(source);
+    return *this;
+  }
+
+  optional& operator=(T&& source) {
+    reset();
+    valid = true;
+    if(isReference) value = &source;
+    else value = new T(std::move(source));
+    return *this;
+  }
+
+  optional& operator=(const optional& source) {
+    reset();
+    valid = source.valid;
+    if(valid) operator=(source);
+    return *this;
+  }
+
+  optional& operator=(optional&& source) {
+    reset();
+    valid = source.valid;
+    value = source.value;
+    source.valid = false;
+    source.value = nullptr;
+    return *this;
+  }
+
+  optional() = default;
+  optional(bool valid) : valid(valid) {}
+  optional(const T& value) { operator=(value); }
+  optional(T&& value) { operator=(std::move(value)); }
+  optional(bool valid, const T& value) : valid(valid) { if(valid) operator=(value); }
+  optional(bool valid, T&& value) : valid(valid) { if(valid) operator=(std::move(value)); }
+  optional(const optional& source) { operator=(source); }
+  optional(optional&& source) { operator=(std::move(source)); }
+  ~optional() { reset(); }
+};
+
 template<typename T> inline T* allocate(unsigned size, const T& value) {
   T* array = new T[size];
   for(unsigned i = 0; i < size; i++) array[i] = value;
diff --git a/../../../git/Emulator/bsnes/bsnes/nall/vector.hpp b/nSide_v005-source-revised/nall/vector.hpp
index d1da089..7ccb53d 100644
--- a/../../../git/Emulator/bsnes/bsnes/nall/vector.hpp
+++ b/nSide_v005-source-revised/nall/vector.hpp
@@ -7,7 +7,6 @@
 #include <utility>
 #include <nall/algorithm.hpp>
 #include <nall/bit.hpp>
-#include <nall/maybe.hpp>
 #include <nall/sort.hpp>
 #include <nall/utility.hpp>
 
@@ -165,9 +164,9 @@ public:
     nall::sort(pool + poolbase, objectsize, lessthan);
   }
 
-  maybe<unsigned> find(const T& data) {
-    for(unsigned n = 0; n < objectsize; n++) if(pool[poolbase + n] == data) return n;
-    return nothing;
+  optional<unsigned> find(const T& data) {
+    for(unsigned n = 0; n < objectsize; n++) if(pool[poolbase + n] == data) return {true, n};
+    return false;
   }
 
   T& first() {
diff --git a/../../../git/Emulator/bsnes/bsnes/nall/windows/guid.hpp b/nSide_v005-source-revised/nall/windows/guid.hpp
index da664bc..adee891 100644
--- a/../../../git/Emulator/bsnes/bsnes/nall/windows/guid.hpp
+++ b/nSide_v005-source-revised/nall/windows/guid.hpp
@@ -8,7 +8,7 @@ namespace nall {
 
 //generate unique GUID
 inline string guid() {
-  LinearFeedbackShiftRegisterGenerator lfsr;
+  random_lfsr lfsr;
   lfsr.seed(time(nullptr));
   for(unsigned n = 0; n < 256; n++) lfsr();
 
diff --git a/../../../git/Emulator/bsnes/bsnes/phoenix/cocoa/widget/console.cpp b/nSide_v005-source-revised/phoenix/cocoa/widget/console.cpp
index 0e983e5..6a8823b 100644
--- a/../../../git/Emulator/bsnes/bsnes/phoenix/cocoa/widget/console.cpp
+++ b/nSide_v005-source-revised/phoenix/cocoa/widget/console.cpp
@@ -17,15 +17,6 @@ void pConsole::print(string text) {
 void pConsole::reset() {
 }
 
-void pConsole::setBackgroundColor(Color color) {
-}
-
-void pConsole::setForegroundColor(Color color) {
-}
-
-void pConsole::setPrompt(string prompt) {
-}
-
 void pConsole::constructor() {
   @autoreleasepool {
     cocoaView = cocoaConsole = [[CocoaConsole alloc] initWith:console];
diff --git a/../../../git/Emulator/bsnes/bsnes/phoenix/cocoa/widget/console.hpp b/nSide_v005-source-revised/phoenix/cocoa/widget/console.hpp
index 65391e2..c22596d 100644
--- a/../../../git/Emulator/bsnes/bsnes/phoenix/cocoa/widget/console.hpp
+++ b/nSide_v005-source-revised/phoenix/cocoa/widget/console.hpp
@@ -13,9 +13,6 @@ struct pConsole : public pWidget {
 
   void print(string text);
   void reset();
-  void setBackgroundColor(Color color);
-  void setForegroundColor(Color color);
-  void setPrompt(string prompt);
 
   pConsole(Console& console) : pWidget(console), console(console) {}
   void constructor();
diff --git a/../../../git/Emulator/bsnes/bsnes/phoenix/cocoa/widget/hex-edit.cpp b/nSide_v005-source-revised/phoenix/cocoa/widget/hex-edit.cpp
index 65e5070..12f1103 100644
--- a/../../../git/Emulator/bsnes/bsnes/phoenix/cocoa/widget/hex-edit.cpp
+++ b/nSide_v005-source-revised/phoenix/cocoa/widget/hex-edit.cpp
@@ -11,15 +11,9 @@
 
 namespace phoenix {
 
-void pHexEdit::setBackgroundColor(Color color) {
-}
-
 void pHexEdit::setColumns(unsigned columns) {
 }
 
-void pHexEdit::setForegroundColor(Color color) {
-}
-
 void pHexEdit::setLength(unsigned length) {
 }
 
diff --git a/../../../git/Emulator/bsnes/bsnes/phoenix/cocoa/widget/hex-edit.hpp b/nSide_v005-source-revised/phoenix/cocoa/widget/hex-edit.hpp
index e144c5e..d3744ba 100644
--- a/../../../git/Emulator/bsnes/bsnes/phoenix/cocoa/widget/hex-edit.hpp
+++ b/nSide_v005-source-revised/phoenix/cocoa/widget/hex-edit.hpp
@@ -11,9 +11,7 @@ struct pHexEdit : public pWidget {
   HexEdit& hexEdit;
   CocoaHexEdit* cocoaHexEdit = nullptr;
 
-  void setBackgroundColor(Color color);
   void setColumns(unsigned columns);
-  void setForegroundColor(Color color);
   void setLength(unsigned length);
   void setOffset(unsigned offset);
   void setRows(unsigned rows);
diff --git a/../../../git/Emulator/bsnes/bsnes/phoenix/cocoa/widget/line-edit.cpp b/nSide_v005-source-revised/phoenix/cocoa/widget/line-edit.cpp
index 8538ab3..296eea6 100644
--- a/../../../git/Emulator/bsnes/bsnes/phoenix/cocoa/widget/line-edit.cpp
+++ b/nSide_v005-source-revised/phoenix/cocoa/widget/line-edit.cpp
@@ -31,18 +31,12 @@ Size pLineEdit::minimumSize() {
   return {size.width + 10, size.height + 8};
 }
 
-void pLineEdit::setBackgroundColor(Color color) {
-}
-
 void pLineEdit::setEditable(bool editable) {
   @autoreleasepool {
     [cocoaView setEditable:editable];
   }
 }
 
-void pLineEdit::setForegroundColor(Color color) {
-}
-
 void pLineEdit::setText(string text) {
   @autoreleasepool {
     [cocoaView setStringValue:[NSString stringWithUTF8String:text]];
diff --git a/../../../git/Emulator/bsnes/bsnes/phoenix/cocoa/widget/line-edit.hpp b/nSide_v005-source-revised/phoenix/cocoa/widget/line-edit.hpp
index ab98530..ad10427 100644
--- a/../../../git/Emulator/bsnes/bsnes/phoenix/cocoa/widget/line-edit.hpp
+++ b/nSide_v005-source-revised/phoenix/cocoa/widget/line-edit.hpp
@@ -14,9 +14,7 @@ struct pLineEdit : public pWidget {
   CocoaLineEdit* cocoaLineEdit = nullptr;
 
   Size minimumSize();
-  void setBackgroundColor(Color color);
   void setEditable(bool editable);
-  void setForegroundColor(Color color);
   void setText(string text);
   string text();
 
diff --git a/../../../git/Emulator/bsnes/bsnes/phoenix/cocoa/widget/list-view.cpp b/nSide_v005-source-revised/phoenix/cocoa/widget/list-view.cpp
index 3a78321..a3cfcc5 100644
--- a/../../../git/Emulator/bsnes/bsnes/phoenix/cocoa/widget/list-view.cpp
+++ b/nSide_v005-source-revised/phoenix/cocoa/widget/list-view.cpp
@@ -250,9 +250,6 @@ void pListView::reset() {
   }
 }
 
-void pListView::setBackgroundColor(Color color) {
-}
-
 void pListView::setCheckable(bool checkable) {
   @autoreleasepool {
     [cocoaView reloadColumns];
@@ -271,9 +268,6 @@ void pListView::setFont(string font) {
   }
 }
 
-void pListView::setForegroundColor(Color color) {
-}
-
 void pListView::setHeaderText(const lstring& text) {
   @autoreleasepool {
     [cocoaView reloadColumns];
diff --git a/../../../git/Emulator/bsnes/bsnes/phoenix/cocoa/widget/list-view.hpp b/nSide_v005-source-revised/phoenix/cocoa/widget/list-view.hpp
index 5d03074..be63171 100644
--- a/../../../git/Emulator/bsnes/bsnes/phoenix/cocoa/widget/list-view.hpp
+++ b/nSide_v005-source-revised/phoenix/cocoa/widget/list-view.hpp
@@ -44,11 +44,9 @@ struct pListView : public pWidget {
   void autoSizeColumns();
   void remove(unsigned selection);
   void reset();
-  void setBackgroundColor(Color color);
   void setCheckable(bool checkable);
   void setChecked(unsigned selection, bool checked);
   void setFont(string font);
-  void setForegroundColor(Color color);
   void setHeaderText(const lstring& text);
   void setHeaderVisible(bool visible);
   void setImage(unsigned selection, unsigned position, const image& image);
diff --git a/../../../git/Emulator/bsnes/bsnes/phoenix/cocoa/widget/text-edit.cpp b/nSide_v005-source-revised/phoenix/cocoa/widget/text-edit.cpp
index 108221e..77dbce0 100644
--- a/../../../git/Emulator/bsnes/bsnes/phoenix/cocoa/widget/text-edit.cpp
+++ b/nSide_v005-source-revised/phoenix/cocoa/widget/text-edit.cpp
@@ -43,9 +43,6 @@
 
 namespace phoenix {
 
-void pTextEdit::setBackgroundColor(Color color) {
-}
-
 void pTextEdit::setCursorPosition(unsigned position) {
   @autoreleasepool {
     string text = [[[cocoaView content] string] UTF8String];
@@ -66,9 +63,6 @@ void pTextEdit::setFont(string font) {
   }
 }
 
-void pTextEdit::setForegroundColor(Color color) {
-}
-
 void pTextEdit::setText(string text) {
   @autoreleasepool {
     [[cocoaView content] setString:[NSString stringWithUTF8String:text]];
diff --git a/../../../git/Emulator/bsnes/bsnes/phoenix/cocoa/widget/text-edit.hpp b/nSide_v005-source-revised/phoenix/cocoa/widget/text-edit.hpp
index b2d3b9e..432efac 100644
--- a/../../../git/Emulator/bsnes/bsnes/phoenix/cocoa/widget/text-edit.hpp
+++ b/nSide_v005-source-revised/phoenix/cocoa/widget/text-edit.hpp
@@ -15,11 +15,9 @@ struct pTextEdit : public pWidget {
   TextEdit& textEdit;
   CocoaTextEdit* cocoaTextEdit = nullptr;
 
-  void setBackgroundColor(Color color);
   void setCursorPosition(unsigned position);
   void setEditable(bool editable);
   void setFont(string font);
-  void setForegroundColor(Color color);
   void setText(string text);
   void setWordWrap(bool wordWrap);
   string text();
diff --git a/../../../git/Emulator/bsnes/bsnes/phoenix/core/core.cpp b/nSide_v005-source-revised/phoenix/core/core.cpp
index ac4cd54..15190a3 100644
--- a/../../../git/Emulator/bsnes/bsnes/phoenix/core/core.cpp
+++ b/nSide_v005-source-revised/phoenix/core/core.cpp
@@ -1217,41 +1217,14 @@ ComboButton::~ComboButton() {
 //Console
 //=======
 
-Color Console::backgroundColor() const {
-  return state.backgroundColor;
-}
-
-Color Console::foregroundColor() const {
-  return state.foregroundColor;
-}
-
 void Console::print(const string& text) {
   return p.print(text);
 }
 
-string Console::prompt() const {
-  return state.prompt;
-}
-
 void Console::reset() {
   return p.reset();
 }
 
-void Console::setBackgroundColor(Color color) {
-  state.backgroundColor = color;
-  return p.setBackgroundColor(color);
-}
-
-void Console::setForegroundColor(Color color) {
-  state.foregroundColor = color;
-  return p.setForegroundColor(color);
-}
-
-void Console::setPrompt(const string& prompt) {
-  state.prompt = prompt;
-  return p.setPrompt(prompt);
-}
-
 Console::Console():
 state(*new State),
 base_from_member<pConsole&>(*new pConsole(*this)),
@@ -1306,18 +1279,10 @@ Frame::~Frame() {
 //HexEdit
 //=======
 
-Color HexEdit::backgroundColor() const {
-  return state.backgroundColor;
-}
-
 unsigned HexEdit::columns() const {
   return state.columns;
 }
 
-Color HexEdit::foregroundColor() const {
-  return state.foregroundColor;
-}
-
 unsigned HexEdit::length() const {
   return state.length;
 }
@@ -1330,21 +1295,11 @@ unsigned HexEdit::rows() const {
   return state.rows;
 }
 
-void HexEdit::setBackgroundColor(Color color) {
-  state.backgroundColor = color;
-  return p.setBackgroundColor(color);
-}
-
 void HexEdit::setColumns(unsigned columns) {
   state.columns = columns;
   return p.setColumns(columns);
 }
 
-void HexEdit::setForegroundColor(Color color) {
-  state.foregroundColor = color;
-  return p.setForegroundColor(color);
-}
-
 void HexEdit::setLength(unsigned length) {
   state.length = length;
   return p.setLength(length);
@@ -1473,33 +1428,15 @@ Label::~Label() {
 //LineEdit
 //========
 
-Color LineEdit::backgroundColor() const {
-  return state.backgroundColor;
-}
-
 bool LineEdit::editable() const {
   return state.editable;
 }
 
-Color LineEdit::foregroundColor() const {
-  return state.foregroundColor;
-}
-
-void LineEdit::setBackgroundColor(Color color) {
-  state.backgroundColor = color;
-  return p.setBackgroundColor(color);
-}
-
 void LineEdit::setEditable(bool editable) {
   state.editable = editable;
   return p.setEditable(editable);
 }
 
-void LineEdit::setForegroundColor(Color color) {
-  state.foregroundColor = color;
-  return p.setForegroundColor(color);
-}
-
 void LineEdit::setText(const string& text) {
   state.text = text;
   return p.setText(text);
@@ -1536,10 +1473,6 @@ void ListView::autoSizeColumns() {
   return p.autoSizeColumns();
 }
 
-Color ListView::backgroundColor() const {
-  return state.backgroundColor;
-}
-
 bool ListView::checkable() const {
   return state.checkable;
 }
@@ -1553,10 +1486,6 @@ unsigned ListView::columns() const {
   return max(1u, state.headerText.size());
 }
 
-Color ListView::foregroundColor() const {
-  return state.foregroundColor;
-}
-
 bool ListView::headerVisible() const {
   return state.headerVisible;
 }
@@ -1595,11 +1524,6 @@ unsigned ListView::selection() const {
   return state.selection;
 }
 
-void ListView::setBackgroundColor(Color color) {
-  state.backgroundColor = color;
-  return p.setBackgroundColor(color);
-}
-
 void ListView::setCheckable(bool checkable) {
   state.checkable = checkable;
   return p.setCheckable(checkable);
@@ -1611,11 +1535,6 @@ void ListView::setChecked(unsigned selection, bool checked) {
   return p.setChecked(selection, checked);
 }
 
-void ListView::setForegroundColor(Color color) {
-  state.foregroundColor = color;
-  return p.setForegroundColor(color);
-}
-
 void ListView::setHeaderText(const lstring& text) {
   state.headerText = text;
   return p.setHeaderText(text);
@@ -1883,23 +1802,10 @@ TabFrame::~TabFrame() {
 //TextEdit
 //========
 
-Color TextEdit::backgroundColor() const {
-  return state.backgroundColor;
-}
-
 bool TextEdit::editable() const {
   return state.editable;
 }
 
-Color TextEdit::foregroundColor() const {
-  return state.foregroundColor;
-}
-
-void TextEdit::setBackgroundColor(Color color) {
-  state.backgroundColor = color;
-  return p.setBackgroundColor(color);
-}
-
 void TextEdit::setCursorPosition(unsigned position) {
   state.cursorPosition = position;
   return p.setCursorPosition(position);
@@ -1910,11 +1816,6 @@ void TextEdit::setEditable(bool editable) {
   return p.setEditable(editable);
 }
 
-void TextEdit::setForegroundColor(Color color) {
-  state.foregroundColor = color;
-  return p.setForegroundColor(color);
-}
-
 void TextEdit::setText(const string& text) {
   state.text = text;
   return p.setText(text);
diff --git a/../../../git/Emulator/bsnes/bsnes/phoenix/core/core.hpp b/nSide_v005-source-revised/phoenix/core/core.hpp
index cc25c5b..68e516a 100644
--- a/../../../git/Emulator/bsnes/bsnes/phoenix/core/core.hpp
+++ b/nSide_v005-source-revised/phoenix/core/core.hpp
@@ -524,14 +524,8 @@ struct Console : private nall::base_from_member<pConsole&>, Widget {
 
   template<typename... Args> void print(Args&&... args) { print({args...}); }
 
-  Color backgroundColor() const;
-  Color foregroundColor() const;
   void print(const nall::string& text);
-  nall::string prompt() const;
   void reset();
-  void setBackgroundColor(Color color);
-  void setForegroundColor(Color color);
-  void setPrompt(const nall::string& prompt);
 
   Console();
   ~Console();
@@ -557,15 +551,11 @@ struct HexEdit : private nall::base_from_member<pHexEdit&>, Widget {
   nall::function<uint8_t (unsigned)> onRead;
   nall::function<void (unsigned, uint8_t)> onWrite;
 
-  Color backgroundColor() const;
   unsigned columns() const;
-  Color foregroundColor() const;
   unsigned length() const;
   unsigned offset() const;
   unsigned rows() const;
-  void setBackgroundColor(Color color);
   void setColumns(unsigned columns);
-  void setForegroundColor(Color color);
   void setLength(unsigned length);
   void setOffset(unsigned offset);
   void setRows(unsigned rows);
@@ -623,12 +613,8 @@ struct LineEdit : private nall::base_from_member<pLineEdit&>, Widget {
   nall::function<void ()> onActivate;
   nall::function<void ()> onChange;
 
-  Color backgroundColor() const;
   bool editable() const;
-  Color foregroundColor() const;
-  void setBackgroundColor(Color color);
   void setEditable(bool editable = true);
-  void setForegroundColor(Color color);
   void setText(const nall::string& text);
   nall::string text();
 
@@ -646,11 +632,9 @@ struct ListView : private nall::base_from_member<pListView&>, Widget {
 
   void append(const nall::lstring& text);
   void autoSizeColumns();
-  Color backgroundColor() const;
   bool checkable() const;
   bool checked(unsigned selection) const;
   unsigned columns() const;
-  Color foregroundColor() const;
   bool headerVisible() const;
   nall::image image(unsigned selection, unsigned position) const;
   void remove(unsigned selection);
@@ -658,10 +642,8 @@ struct ListView : private nall::base_from_member<pListView&>, Widget {
   unsigned rows() const;
   bool selected() const;
   unsigned selection() const;
-  void setBackgroundColor(Color color);
   void setCheckable(bool checkable = true);
   void setChecked(unsigned selection, bool checked = true);
-  void setForegroundColor(Color color);
   void setHeaderText(const nall::lstring& text);
   void setHeaderVisible(bool visible = true);
   void setImage(unsigned selection, unsigned position, const nall::image& image = nall::image{});
@@ -752,13 +734,9 @@ struct TabFrame : private nall::base_from_member<pTabFrame&>, Widget {
 struct TextEdit : private nall::base_from_member<pTextEdit&>, Widget {
   nall::function<void ()> onChange;
 
-  Color backgroundColor() const;
   bool editable() const;
-  Color foregroundColor() const;
-  void setBackgroundColor(Color color);
   void setCursorPosition(unsigned position);
   void setEditable(bool editable = true);
-  void setForegroundColor(Color color);
   void setText(const nall::string& text);
   void setWordWrap(bool wordWrap = true);
   nall::string text();
diff --git a/../../../git/Emulator/bsnes/bsnes/phoenix/core/state.hpp b/nSide_v005-source-revised/phoenix/core/state.hpp
index 3a48de8..a650c84 100644
--- a/../../../git/Emulator/bsnes/bsnes/phoenix/core/state.hpp
+++ b/nSide_v005-source-revised/phoenix/core/state.hpp
@@ -24,7 +24,7 @@ struct MessageWindow::State {
 
 struct Window::State {
   bool backgroundColorOverride = false;
-  Color backgroundColor = {0, 0, 0};
+  Color backgroundColor = {0, 0, 0, 255};
   bool droppable = false;
   bool fullScreen = false;
   Geometry geometry = {128, 128, 256, 256};
@@ -125,9 +125,6 @@ struct ComboButton::State {
 };
 
 struct Console::State {
-  Color backgroundColor = {255, 255, 255};
-  Color foregroundColor = {0, 0, 0};
-  string prompt;
 };
 
 struct Frame::State {
@@ -136,9 +133,7 @@ struct Frame::State {
 };
 
 struct HexEdit::State {
-  Color backgroundColor = {255, 255, 255};
   unsigned columns = 16;
-  Color foregroundColor = {0, 0, 0};
   unsigned length = 0;
   unsigned offset = 0;
   unsigned rows = 16;
@@ -159,17 +154,13 @@ struct Label::State {
 };
 
 struct LineEdit::State {
-  Color backgroundColor = {255, 255, 255};
   bool editable = true;
-  Color foregroundColor = {0, 0, 0};
   string text;
 };
 
 struct ListView::State {
-  Color backgroundColor = {255, 255, 255};
   bool checkable = false;
   vector<bool> checked;
-  Color foregroundColor = {0, 0, 0};
   lstring headerText;
   bool headerVisible = false;
   vector<vector<nall::image>> image;
@@ -204,10 +195,8 @@ struct TabFrame::State {
 };
 
 struct TextEdit::State {
-  Color backgroundColor = {255, 255, 255};
   unsigned cursorPosition = 0;
   bool editable = true;
-  Color foregroundColor = {0, 0, 0};
   string text;
   bool wordWrap = true;
 };
diff --git a/../../../git/Emulator/bsnes/bsnes/phoenix/gtk/font.cpp b/nSide_v005-source-revised/phoenix/gtk/font.cpp
index 41232cb..750d47d 100644
--- a/../../../git/Emulator/bsnes/bsnes/phoenix/gtk/font.cpp
+++ b/nSide_v005-source-revised/phoenix/gtk/font.cpp
@@ -36,8 +36,8 @@ PangoFontDescription* pFont::create(string description) {
 
   if(part[0] != "") family = part[0];
   if(part.size() >= 2) size = decimal(part[1]);
-  if(part.size() >= 3) bold = (bool)part[2].find("Bold");
-  if(part.size() >= 3) italic = (bool)part[2].find("Italic");
+  if(part.size() >= 3) bold = part[2].find("Bold");
+  if(part.size() >= 3) italic = part[2].find("Italic");
 
   PangoFontDescription* font = pango_font_description_new();
   pango_font_description_set_family(font, family);
diff --git a/../../../git/Emulator/bsnes/bsnes/phoenix/gtk/platform.hpp b/nSide_v005-source-revised/phoenix/gtk/platform.hpp
index ead42f2..b724e50 100644
--- a/../../../git/Emulator/bsnes/bsnes/phoenix/gtk/platform.hpp
+++ b/nSide_v005-source-revised/phoenix/gtk/platform.hpp
@@ -347,23 +347,17 @@ struct pConsole : public pWidget {
   Console& console;
   GtkWidget* subWidget;
   GtkTextBuffer* textBuffer;
-  string previousPrompt;
-  lstring history;
-  unsigned historyOffset = 0;
+  string command;
 
   void print(string text);
   void reset();
-  void setBackgroundColor(Color color);
-  void setForegroundColor(Color color);
-  void setPrompt(string prompt);
 
   pConsole(Console& console) : pWidget(console), console(console) {}
   void constructor();
   void destructor();
   void orphan();
   bool keyPress(unsigned scancode, unsigned mask);
-  void seekToEnd();
-  void seekToMark();
+  void seekCursorToEnd();
 };
 
 struct pFrame : public pWidget {
@@ -391,9 +385,7 @@ struct pHexEdit : public pWidget {
   GtkTextMark* textCursor;
 
   bool focused();
-  void setBackgroundColor(Color color);
   void setColumns(unsigned columns);
-  void setForegroundColor(Color color);
   void setLength(unsigned length);
   void setOffset(unsigned offset);
   void setRows(unsigned rows);
@@ -455,9 +447,7 @@ struct pLineEdit : public pWidget {
   LineEdit& lineEdit;
 
   Size minimumSize();
-  void setBackgroundColor(Color color);
   void setEditable(bool editable);
-  void setForegroundColor(Color color);
   void setText(string text);
   string text();
 
@@ -485,10 +475,8 @@ struct pListView : public pWidget {
   bool focused();
   void remove(unsigned selection);
   void reset();
-  void setBackgroundColor(Color color);
   void setCheckable(bool checkable);
   void setChecked(unsigned selection, bool checked);
-  void setForegroundColor(Color color);
   void setHeaderText(const lstring& text);
   void setHeaderVisible(bool visible);
   void setImage(unsigned selection, unsigned position, const image& image);
@@ -585,10 +573,8 @@ struct pTextEdit : public pWidget {
   GtkTextBuffer* textBuffer;
 
   bool focused();
-  void setBackgroundColor(Color color);
   void setCursorPosition(unsigned position);
   void setEditable(bool editable);
-  void setForegroundColor(Color color);
   void setText(string text);
   void setWordWrap(bool wordWrap);
   string text();
diff --git a/../../../git/Emulator/bsnes/bsnes/phoenix/gtk/widget/console.cpp b/nSide_v005-source-revised/phoenix/gtk/widget/console.cpp
index 722f138..1750392 100644
--- a/../../../git/Emulator/bsnes/bsnes/phoenix/gtk/widget/console.cpp
+++ b/nSide_v005-source-revised/phoenix/gtk/widget/console.cpp
@@ -5,38 +5,14 @@ static bool Console_keyPress(GtkWidget* widget, GdkEventKey* event, Console* sel
 }
 
 void pConsole::print(string text) {
-  //insert text before prompt and command
-  GtkTextIter iter;
-  gtk_text_buffer_get_iter_at_line_offset(textBuffer, &iter, gtk_text_buffer_get_line_count(textBuffer), 0);
-  gtk_text_buffer_insert(textBuffer, &iter, text, -1);
-  seekToEnd();
+  seekCursorToEnd();
+  gtk_text_buffer_insert_at_cursor(textBuffer, text, -1);
+  GtkTextMark* mark = gtk_text_buffer_get_mark(textBuffer, "insert");
+  gtk_text_view_scroll_mark_onscreen(GTK_TEXT_VIEW(subWidget), mark);
 }
 
 void pConsole::reset() {
-  //flush history and redraw prompt
-  gtk_text_buffer_set_text(textBuffer, console.prompt(), -1);
-  seekToEnd();
-}
-
-void pConsole::setBackgroundColor(Color color) {
-  GdkColor gdkColor = CreateColor(color.red, color.green, color.blue);
-  gtk_widget_modify_base(subWidget, GTK_STATE_NORMAL, &gdkColor);
-}
-
-void pConsole::setForegroundColor(Color color) {
-  GdkColor gdkColor = CreateColor(color.red, color.green, color.blue);
-  gtk_widget_modify_text(subWidget, GTK_STATE_NORMAL, &gdkColor);
-}
-
-void pConsole::setPrompt(string prompt) {
-  //erase previous prompt and replace it with new prompt
-  GtkTextIter lhs, rhs;
-  gtk_text_buffer_get_iter_at_line_offset(textBuffer, &lhs, gtk_text_buffer_get_line_count(textBuffer), 0);
-  gtk_text_buffer_get_iter_at_line_offset(textBuffer, &rhs, gtk_text_buffer_get_line_count(textBuffer), previousPrompt.size());
-  gtk_text_buffer_delete(textBuffer, &lhs, &rhs);
-  gtk_text_buffer_get_iter_at_line_offset(textBuffer, &lhs, gtk_text_buffer_get_line_count(textBuffer), 0);
-  gtk_text_buffer_insert(textBuffer, &lhs, previousPrompt = prompt, -1);
-  seekToEnd();
+  gtk_text_buffer_set_text(textBuffer, "", -1);
 }
 
 void pConsole::constructor() {
@@ -51,6 +27,11 @@ void pConsole::constructor() {
 
   textBuffer = gtk_text_view_get_buffer(GTK_TEXT_VIEW(subWidget));
 
+  GdkColor background = CreateColor(48, 24, 24);
+  gtk_widget_modify_base(subWidget, GTK_STATE_NORMAL, &background);
+  GdkColor foreground = CreateColor(255, 255, 255);
+  gtk_widget_modify_text(subWidget, GTK_STATE_NORMAL, &foreground);
+
   g_signal_connect(G_OBJECT(subWidget), "key-press-event", G_CALLBACK(Console_keyPress), (gpointer)&console);
 
   gtk_widget_show(subWidget);
@@ -69,118 +50,39 @@ void pConsole::orphan() {
 bool pConsole::keyPress(unsigned scancode, unsigned mask) {
   if(mask & (GDK_CONTROL_MASK | GDK_MOD1_MASK | GDK_SUPER_MASK)) return false;  //allow actions such as Ctrl+C (copy)
 
-  GtkTextMark* mark = gtk_text_buffer_get_mark(textBuffer, "insert");
-  GtkTextIter start, cursor, end;
-  gtk_text_buffer_get_iter_at_line_offset(textBuffer, &start, gtk_text_buffer_get_line_count(textBuffer), console.prompt().size());
-  gtk_text_buffer_get_iter_at_mark(textBuffer, &cursor, mark);
-  gtk_text_buffer_get_end_iter(textBuffer, &end);
-
   if(scancode == GDK_KEY_Return || scancode == GDK_KEY_KP_Enter) {
-    char* temp = gtk_text_buffer_get_text(textBuffer, &start, &end, true);
-    string s = temp;
-    g_free(temp);
-    gtk_text_buffer_insert(textBuffer, &end, string{"\n", console.prompt()}, -1);
-    if(console.onActivate) console.onActivate(s);
-    if(s) history.prepend(s);
-    if(history.size() > 128) history.removeLast();
-    historyOffset = 0;
-    seekToEnd();
-    return true;
-  }
-
-  if(scancode == GDK_KEY_Up) {
-    gtk_text_buffer_delete(textBuffer, &start, &end);
-    gtk_text_buffer_get_end_iter(textBuffer, &end);
-    if(historyOffset < history.size()) {
-      gtk_text_buffer_insert(textBuffer, &end, history[historyOffset++], -1);
-    }
-    seekToEnd();
-    return true;
-  }
-
-  if(scancode == GDK_KEY_Down) {
-    gtk_text_buffer_delete(textBuffer, &start, &end);
-    gtk_text_buffer_get_end_iter(textBuffer, &end);
-    if(historyOffset > 0) {
-      gtk_text_buffer_insert(textBuffer, &end, history[--historyOffset], -1);
-    }
-    seekToEnd();
-    return true;
-  }
-
-  if(scancode == GDK_KEY_Left) {
-    if(gtk_text_iter_get_offset(&cursor) <= gtk_text_iter_get_offset(&start)) {
-      gtk_text_buffer_place_cursor(textBuffer, &start);
-    } else {
-      gtk_text_iter_set_offset(&cursor, gtk_text_iter_get_offset(&cursor) - 1);
-      gtk_text_buffer_place_cursor(textBuffer, &cursor);
-    }
-    seekToMark();
-    return true;
-  }
-
-  if(scancode == GDK_KEY_Right) {
-    if(gtk_text_iter_get_offset(&cursor) < gtk_text_iter_get_offset(&start)) {
-      gtk_text_buffer_place_cursor(textBuffer, &end);
-    } else if(gtk_text_iter_get_offset(&cursor) < gtk_text_iter_get_offset(&end)) {
-      gtk_text_iter_set_offset(&cursor, gtk_text_iter_get_offset(&cursor) + 1);
-      gtk_text_buffer_place_cursor(textBuffer, &cursor);
-    }
-    seekToMark();
-    return true;
-  }
-
-  if(scancode == GDK_KEY_Home) {
-    gtk_text_buffer_place_cursor(textBuffer, &start);
-    seekToMark();
-    return true;
-  }
-
-  if(scancode == GDK_KEY_End) {
-    gtk_text_buffer_place_cursor(textBuffer, &end);
-    seekToMark();
+    print("\n");
+    if(console.onActivate) console.onActivate(command);
+    command.reset();
     return true;
   }
 
   if(scancode == GDK_KEY_BackSpace) {
-    if(gtk_text_iter_get_offset(&cursor) <= gtk_text_iter_get_offset(&start)) return true;
-    GtkTextIter lhs = cursor;
-    gtk_text_iter_set_offset(&lhs, gtk_text_iter_get_offset(&cursor) - 1);
-    gtk_text_buffer_delete(textBuffer, &lhs, &cursor);
-    seekToMark();
-    return true;
-  }
-
-  if(scancode == GDK_KEY_Delete) {
-    if(gtk_text_iter_get_offset(&cursor) < gtk_text_iter_get_offset(&start)) return true;
-    if(gtk_text_iter_get_offset(&cursor) == gtk_text_iter_get_offset(&end)) return true;
-    GtkTextIter rhs = cursor;
-    gtk_text_iter_set_offset(&rhs, gtk_text_iter_get_offset(&cursor) + 1);
-    gtk_text_buffer_delete(textBuffer, &cursor, &rhs);
-    seekToMark();
+    if(command.size()) {
+      command.resize(command.size() - 1);
+      GtkTextIter lhs, rhs;
+      gtk_text_buffer_get_end_iter(textBuffer, &lhs);
+      gtk_text_buffer_get_end_iter(textBuffer, &rhs);
+      gtk_text_iter_set_offset(&lhs, gtk_text_iter_get_offset(&lhs) - 1);
+      gtk_text_buffer_delete(textBuffer, &lhs, &rhs);
+      seekCursorToEnd();
+    }
     return true;
   }
 
   if(scancode >= 0x20 && scancode <= 0x7e) {
-    if(gtk_text_iter_get_offset(&cursor) < gtk_text_iter_get_offset(&start)) return true;
-    gtk_text_buffer_insert(textBuffer, &cursor, string{(char)scancode}, -1);
-    seekToMark();
+    print({(char)scancode});
+    command.append((char)scancode);
     return true;
   }
 
   return false;
 }
 
-void pConsole::seekToEnd() {
+void pConsole::seekCursorToEnd() {
   GtkTextIter iter;
   gtk_text_buffer_get_end_iter(textBuffer, &iter);
   gtk_text_buffer_place_cursor(textBuffer, &iter);
-  seekToMark();
-}
-
-void pConsole::seekToMark() {
-  GtkTextMark* mark = gtk_text_buffer_get_mark(textBuffer, "insert");
-  gtk_text_view_scroll_mark_onscreen(GTK_TEXT_VIEW(subWidget), mark);
 }
 
 }
diff --git a/../../../git/Emulator/bsnes/bsnes/phoenix/gtk/widget/hex-edit.cpp b/nSide_v005-source-revised/phoenix/gtk/widget/hex-edit.cpp
index 08c10a7..ce961db 100644
--- a/../../../git/Emulator/bsnes/bsnes/phoenix/gtk/widget/hex-edit.cpp
+++ b/nSide_v005-source-revised/phoenix/gtk/widget/hex-edit.cpp
@@ -27,21 +27,11 @@ bool pHexEdit::focused() {
   return GTK_WIDGET_HAS_FOCUS(subWidget) || GTK_WIDGET_HAS_FOCUS(scrollBar);
 }
 
-void pHexEdit::setBackgroundColor(Color color) {
-  GdkColor gdkColor = CreateColor(color.red, color.green, color.blue);
-  gtk_widget_modify_base(subWidget, GTK_STATE_NORMAL, &gdkColor);
-}
-
 void pHexEdit::setColumns(unsigned columns) {
   setScroll();
   update();
 }
 
-void pHexEdit::setForegroundColor(Color color) {
-  GdkColor gdkColor = CreateColor(color.red, color.green, color.blue);
-  gtk_widget_modify_text(subWidget, GTK_STATE_NORMAL, &gdkColor);
-}
-
 void pHexEdit::setLength(unsigned length) {
   setScroll();
   update();
diff --git a/../../../git/Emulator/bsnes/bsnes/phoenix/gtk/widget/line-edit.cpp b/nSide_v005-source-revised/phoenix/gtk/widget/line-edit.cpp
index 642e693..77226e6 100644
--- a/../../../git/Emulator/bsnes/bsnes/phoenix/gtk/widget/line-edit.cpp
+++ b/nSide_v005-source-revised/phoenix/gtk/widget/line-edit.cpp
@@ -14,20 +14,10 @@ Size pLineEdit::minimumSize() {
   return {size.width + 10, size.height + 10};
 }
 
-void pLineEdit::setBackgroundColor(Color color) {
-  GdkColor gdkColor = CreateColor(color.red, color.green, color.blue);
-  gtk_widget_modify_base(gtkWidget, GTK_STATE_NORMAL, &gdkColor);
-}
-
 void pLineEdit::setEditable(bool editable) {
   gtk_editable_set_editable(GTK_EDITABLE(gtkWidget), editable);
 }
 
-void pLineEdit::setForegroundColor(Color color) {
-  GdkColor gdkColor = CreateColor(color.red, color.green, color.blue);
-  gtk_widget_modify_text(gtkWidget, GTK_STATE_NORMAL, &gdkColor);
-}
-
 void pLineEdit::setText(string text) {
   locked = true;
   gtk_entry_set_text(GTK_ENTRY(gtkWidget), text);
diff --git a/../../../git/Emulator/bsnes/bsnes/phoenix/gtk/widget/list-view.cpp b/nSide_v005-source-revised/phoenix/gtk/widget/list-view.cpp
index 8fa77c6..88cba71 100644
--- a/../../../git/Emulator/bsnes/bsnes/phoenix/gtk/widget/list-view.cpp
+++ b/nSide_v005-source-revised/phoenix/gtk/widget/list-view.cpp
@@ -61,11 +61,6 @@ void pListView::reset() {
   gtk_scrolled_window_set_vadjustment(GTK_SCROLLED_WINDOW(gtkWidget), 0);
 }
 
-void pListView::setBackgroundColor(Color color) {
-  GdkColor gdkColor = CreateColor(color.red, color.green, color.blue);
-  gtk_widget_modify_base(subWidget, GTK_STATE_NORMAL, &gdkColor);
-}
-
 void pListView::setCheckable(bool checkable) {
   gtk_cell_renderer_set_visible(column(0).checkbutton, checkable);
 }
@@ -77,11 +72,6 @@ void pListView::setChecked(unsigned selection, bool checked) {
   gtk_list_store_set(GTK_LIST_STORE(model), &iter, 0, checked, -1);
 }
 
-void pListView::setForegroundColor(Color color) {
-  GdkColor gdkColor = CreateColor(color.red, color.green, color.blue);
-  gtk_widget_modify_text(subWidget, GTK_STATE_NORMAL, &gdkColor);
-}
-
 void pListView::setHeaderText(const lstring& text) {
   destructor();
   constructor();
diff --git a/../../../git/Emulator/bsnes/bsnes/phoenix/gtk/widget/text-edit.cpp b/nSide_v005-source-revised/phoenix/gtk/widget/text-edit.cpp
index 49ee4df..b4583b4 100644
--- a/../../../git/Emulator/bsnes/bsnes/phoenix/gtk/widget/text-edit.cpp
+++ b/nSide_v005-source-revised/phoenix/gtk/widget/text-edit.cpp
@@ -9,11 +9,6 @@ bool pTextEdit::focused() {
   return GTK_WIDGET_HAS_FOCUS(subWidget);
 }
 
-void pTextEdit::setBackgroundColor(Color color) {
-  GdkColor gdkColor = CreateColor(color.red, color.green, color.blue);
-  gtk_widget_modify_base(subWidget, GTK_STATE_NORMAL, &gdkColor);
-}
-
 void pTextEdit::setCursorPosition(unsigned position) {
   GtkTextMark* mark = gtk_text_buffer_get_mark(textBuffer, "insert");
   GtkTextIter iter;
@@ -27,11 +22,6 @@ void pTextEdit::setEditable(bool editable) {
   gtk_text_view_set_editable(GTK_TEXT_VIEW(subWidget), editable);
 }
 
-void pTextEdit::setForegroundColor(Color color) {
-  GdkColor gdkColor = CreateColor(color.red, color.green, color.blue);
-  gtk_widget_modify_text(subWidget, GTK_STATE_NORMAL, &gdkColor);
-}
-
 void pTextEdit::setText(string text) {
   locked = true;
   gtk_text_buffer_set_text(textBuffer, text, -1);
diff --git a/../../../git/Emulator/bsnes/bsnes/phoenix/gtk/window.cpp b/nSide_v005-source-revised/phoenix/gtk/window.cpp
index 573972b..3f95a57 100644
--- a/../../../git/Emulator/bsnes/bsnes/phoenix/gtk/window.cpp
+++ b/nSide_v005-source-revised/phoenix/gtk/window.cpp
@@ -331,7 +331,7 @@ void pWindow::constructor() {
     if(file::exists(filename)) {
       //maximum image size supported by GTK+ is 256x256; so we must scale larger images ourselves
       nall::image icon(filename);
-      icon.scale(min(256u, icon.width), min(256u, icon.height), true);
+      icon.scale(min(256u, icon.width), min(256u, icon.height), Interpolation::Hermite);
       GdkPixbuf* pixbuf = CreatePixbuf(icon);
       gtk_window_set_icon(GTK_WINDOW(widget), pixbuf);
       g_object_unref(G_OBJECT(pixbuf));
diff --git a/../../../git/Emulator/bsnes/bsnes/phoenix/qt/font.cpp b/nSide_v005-source-revised/phoenix/qt/font.cpp
index 3c6fe57..ce1a683 100644
--- a/../../../git/Emulator/bsnes/bsnes/phoenix/qt/font.cpp
+++ b/nSide_v005-source-revised/phoenix/qt/font.cpp
@@ -34,8 +34,8 @@ QFont pFont::create(string description) {
 
   if(part[0] != "") family = part[0];
   if(part.size() >= 2) size = decimal(part[1]);
-  if(part.size() >= 3) bold = (bool)part[2].find("Bold");
-  if(part.size() >= 3) italic = (bool)part[2].find("Italic");
+  if(part.size() >= 3) bold = part[2].find("Bold");
+  if(part.size() >= 3) italic = part[2].find("Italic");
 
   QFont qtFont;
   qtFont.setFamily(family);
diff --git a/../../../git/Emulator/bsnes/bsnes/phoenix/qt/platform.moc b/nSide_v005-source-revised/phoenix/qt/platform.moc
index ccf22d3..63e93e9 100644
--- a/../../../git/Emulator/bsnes/bsnes/phoenix/qt/platform.moc
+++ b/nSide_v005-source-revised/phoenix/qt/platform.moc
@@ -1,7 +1,7 @@
 /****************************************************************************
 ** Meta object code from reading C++ file 'platform.moc.hpp'
 **
-** Created: Fri Feb 14 13:37:55 2014
+** Created: Mon Jan 20 01:11:54 2014
 **      by: The Qt Meta Object Compiler version 63 (Qt 4.8.2)
 **
 ** WARNING! All changes made in this file will be lost!
diff --git a/../../../git/Emulator/bsnes/bsnes/phoenix/qt/platform.moc.hpp b/nSide_v005-source-revised/phoenix/qt/platform.moc.hpp
index 7a8a567..935da45 100644
--- a/../../../git/Emulator/bsnes/bsnes/phoenix/qt/platform.moc.hpp
+++ b/nSide_v005-source-revised/phoenix/qt/platform.moc.hpp
@@ -432,9 +432,6 @@ public:
 
   void print(string text);
   void reset();
-  void setBackgroundColor(Color color);
-  void setForegroundColor(Color color);
-  void setPrompt(string prompt);
 
   pConsole(Console& console) : pWidget(console), console(console) {}
   void constructor();
@@ -482,9 +479,7 @@ public:
   QHBoxLayout* qtLayout;
   QtHexEditScrollBar* qtScroll;
 
-  void setBackgroundColor(Color color);
   void setColumns(unsigned columns);
-  void setForegroundColor(Color color);
   void setLength(unsigned length);
   void setOffset(unsigned offset);
   void setRows(unsigned rows);
@@ -564,9 +559,7 @@ public:
   QLineEdit* qtLineEdit;
 
   Size minimumSize();
-  void setBackgroundColor(Color color);
   void setEditable(bool editable);
-  void setForegroundColor(Color color);
   void setText(string text);
   string text();
 
@@ -591,10 +584,8 @@ public:
   void autoSizeColumns();
   void remove(unsigned selection);
   void reset();
-  void setBackgroundColor(Color color);
   void setCheckable(bool checkable);
   void setChecked(unsigned selection, bool checked);
-  void setForegroundColor(Color color);
   void setHeaderText(const lstring& text);
   void setHeaderVisible(bool visible);
   void setImage(unsigned selection, unsigned position, const image& image);
@@ -707,10 +698,8 @@ public:
   TextEdit& textEdit;
   QTextEdit* qtTextEdit;
 
-  void setBackgroundColor(Color color);
   void setCursorPosition(unsigned position);
   void setEditable(bool editable);
-  void setForegroundColor(Color color);
   void setText(string text);
   void setWordWrap(bool wordWrap);
   string text();
diff --git a/../../../git/Emulator/bsnes/bsnes/phoenix/qt/widget/console.cpp b/nSide_v005-source-revised/phoenix/qt/widget/console.cpp
index 22a3d81..2db6b7f 100644
--- a/../../../git/Emulator/bsnes/bsnes/phoenix/qt/widget/console.cpp
+++ b/nSide_v005-source-revised/phoenix/qt/widget/console.cpp
@@ -6,15 +6,6 @@ void pConsole::print(string text) {
 void pConsole::reset() {
 }
 
-void pConsole::setBackgroundColor(Color color) {
-}
-
-void pConsole::setForegroundColor(Color color) {
-}
-
-void pConsole::setPrompt(string prompt) {
-}
-
 void pConsole::constructor() {
   qtWidget = qtConsole = new QtConsole(*this);
 
diff --git a/../../../git/Emulator/bsnes/bsnes/phoenix/qt/widget/hex-edit.cpp b/nSide_v005-source-revised/phoenix/qt/widget/hex-edit.cpp
index f0883e3..2feed39 100644
--- a/../../../git/Emulator/bsnes/bsnes/phoenix/qt/widget/hex-edit.cpp
+++ b/nSide_v005-source-revised/phoenix/qt/widget/hex-edit.cpp
@@ -1,15 +1,9 @@
 namespace phoenix {
 
-void pHexEdit::setBackgroundColor(Color color) {
-}
-
 void pHexEdit::setColumns(unsigned columns) {
   update();
 }
 
-void pHexEdit::setForegroundColor(Color color) {
-}
-
 void pHexEdit::setLength(unsigned length) {
   //add one if last row is not equal to column length (eg only part of the row is present)
   bool indivisible = hexEdit.state.columns == 0 || (hexEdit.state.length % hexEdit.state.columns) != 0;
diff --git a/../../../git/Emulator/bsnes/bsnes/phoenix/qt/widget/line-edit.cpp b/nSide_v005-source-revised/phoenix/qt/widget/line-edit.cpp
index 3142c8a..f5d610b 100644
--- a/../../../git/Emulator/bsnes/bsnes/phoenix/qt/widget/line-edit.cpp
+++ b/nSide_v005-source-revised/phoenix/qt/widget/line-edit.cpp
@@ -5,16 +5,10 @@ Size pLineEdit::minimumSize() {
   return {size.width + 12, size.height + 12};
 }
 
-void pLineEdit::setBackgroundColor(Color color) {
-}
-
 void pLineEdit::setEditable(bool editable) {
   qtLineEdit->setReadOnly(!editable);
 }
 
-void pLineEdit::setForegroundColor(Color color) {
-}
-
 void pLineEdit::setText(string text) {
   qtLineEdit->setText(QString::fromUtf8(text));
 }
diff --git a/../../../git/Emulator/bsnes/bsnes/phoenix/qt/widget/list-view.cpp b/nSide_v005-source-revised/phoenix/qt/widget/list-view.cpp
index 7d5fd5d..036f3f6 100644
--- a/../../../git/Emulator/bsnes/bsnes/phoenix/qt/widget/list-view.cpp
+++ b/nSide_v005-source-revised/phoenix/qt/widget/list-view.cpp
@@ -29,9 +29,6 @@ void pListView::reset() {
   qtListView->clear();
 }
 
-void pListView::setBackgroundColor(Color color) {
-}
-
 void pListView::setCheckable(bool checkable) {
   if(checkable) {
     auto items = qtListView->findItems("", Qt::MatchContains);
@@ -46,9 +43,6 @@ void pListView::setChecked(unsigned selection, bool checked) {
   locked = false;
 }
 
-void pListView::setForegroundColor(Color color) {
-}
-
 void pListView::setHeaderText(const lstring& text) {
   QStringList labels;
   for(auto& column : text) labels << QString::fromUtf8(column);
diff --git a/../../../git/Emulator/bsnes/bsnes/phoenix/qt/widget/text-edit.cpp b/nSide_v005-source-revised/phoenix/qt/widget/text-edit.cpp
index ec70573..485d27a 100644
--- a/../../../git/Emulator/bsnes/bsnes/phoenix/qt/widget/text-edit.cpp
+++ b/nSide_v005-source-revised/phoenix/qt/widget/text-edit.cpp
@@ -1,8 +1,5 @@
 namespace phoenix {
 
-void pTextEdit::setBackgroundColor(Color color) {
-}
-
 void pTextEdit::setCursorPosition(unsigned position) {
   QTextCursor cursor = qtTextEdit->textCursor();
   unsigned lastCharacter = strlen(qtTextEdit->toPlainText().toUtf8().constData());
@@ -14,9 +11,6 @@ void pTextEdit::setEditable(bool editable) {
   qtTextEdit->setTextInteractionFlags(editable ? Qt::TextEditorInteraction : Qt::TextSelectableByKeyboard | Qt::TextSelectableByMouse);
 }
 
-void pTextEdit::setForegroundColor(Color color) {
-}
-
 void pTextEdit::setText(string text) {
   qtTextEdit->setPlainText(QString::fromUtf8(text));
 }
diff --git a/../../../git/Emulator/bsnes/bsnes/phoenix/reference/widget/console.cpp b/nSide_v005-source-revised/phoenix/reference/widget/console.cpp
index fc27bcf..2df09f9 100644
--- a/../../../git/Emulator/bsnes/bsnes/phoenix/reference/widget/console.cpp
+++ b/nSide_v005-source-revised/phoenix/reference/widget/console.cpp
@@ -6,15 +6,6 @@ void pConsole::print(string text) {
 void pConsole::reset() {
 }
 
-void pConsole::setBackgroundColor(Color color) {
-}
-
-void pConsole::setForegroundColor(Color color) {
-}
-
-void pConsole::setPrompt(string prompt) {
-}
-
 void pConsole::constructor() {
 }
 
diff --git a/../../../git/Emulator/bsnes/bsnes/phoenix/reference/widget/console.hpp b/nSide_v005-source-revised/phoenix/reference/widget/console.hpp
index 50d2ce0..dbb2692 100644
--- a/../../../git/Emulator/bsnes/bsnes/phoenix/reference/widget/console.hpp
+++ b/nSide_v005-source-revised/phoenix/reference/widget/console.hpp
@@ -5,9 +5,6 @@ struct pConsole : public pWidget {
 
   void print(string text);
   void reset();
-  void setBackgroundColor(Color color);
-  void setForegroundColor(Color color);
-  void setPrompt(string prompt);
 
   pConsole(Console& console) : pWidget(console), console(console) {}
   void constructor();
diff --git a/../../../git/Emulator/bsnes/bsnes/phoenix/reference/widget/hex-edit.cpp b/nSide_v005-source-revised/phoenix/reference/widget/hex-edit.cpp
index b816cbc..4d2ea5e 100644
--- a/../../../git/Emulator/bsnes/bsnes/phoenix/reference/widget/hex-edit.cpp
+++ b/nSide_v005-source-revised/phoenix/reference/widget/hex-edit.cpp
@@ -1,14 +1,8 @@
 namespace phoenix {
 
-void pHexEdit::setBackgroundColor(Color color) {
-}
-
 void pHexEdit::setColumns(unsigned columns) {
 }
 
-void pHexEdit::setForegroundColor(Color color) {
-}
-
 void pHexEdit::setLength(unsigned length) {
 }
 
diff --git a/../../../git/Emulator/bsnes/bsnes/phoenix/reference/widget/hex-edit.hpp b/nSide_v005-source-revised/phoenix/reference/widget/hex-edit.hpp
index e79b929..c777e3d 100644
--- a/../../../git/Emulator/bsnes/bsnes/phoenix/reference/widget/hex-edit.hpp
+++ b/nSide_v005-source-revised/phoenix/reference/widget/hex-edit.hpp
@@ -3,9 +3,7 @@ namespace phoenix {
 struct pHexEdit : public pWidget {
   HexEdit& hexEdit;
 
-  void setBackgroundColor(Color color);
   void setColumns(unsigned columns);
-  void setForegroundColor(Color color);
   void setLength(unsigned length);
   void setOffset(unsigned offset);
   void setRows(unsigned rows);
diff --git a/../../../git/Emulator/bsnes/bsnes/phoenix/reference/widget/line-edit.cpp b/nSide_v005-source-revised/phoenix/reference/widget/line-edit.cpp
index 2ccdb29..35ae2eb 100644
--- a/../../../git/Emulator/bsnes/bsnes/phoenix/reference/widget/line-edit.cpp
+++ b/nSide_v005-source-revised/phoenix/reference/widget/line-edit.cpp
@@ -1,14 +1,8 @@
 namespace phoenix {
 
-void pLineEdit::setBackgroundColor(Color color) {
-}
-
 void pLineEdit::setEditable(bool editable) {
 }
 
-void pLineEdit::setForegroundColor(Color color) {
-}
-
 void pLineEdit::setText(string text) {
 }
 
diff --git a/../../../git/Emulator/bsnes/bsnes/phoenix/reference/widget/line-edit.hpp b/nSide_v005-source-revised/phoenix/reference/widget/line-edit.hpp
index bf1c319..9eb621e 100644
--- a/../../../git/Emulator/bsnes/bsnes/phoenix/reference/widget/line-edit.hpp
+++ b/nSide_v005-source-revised/phoenix/reference/widget/line-edit.hpp
@@ -3,9 +3,7 @@ namespace phoenix {
 struct pLineEdit : public pWidget {
   LineEdit& lineEdit;
 
-  void setBackgroundColor(Color color);
   void setEditable(bool editable);
-  void setForegroundColor(Color color);
   void setText(string text);
   string text();
 
diff --git a/../../../git/Emulator/bsnes/bsnes/phoenix/reference/widget/list-view.cpp b/nSide_v005-source-revised/phoenix/reference/widget/list-view.cpp
index e882907..d90683b 100644
--- a/../../../git/Emulator/bsnes/bsnes/phoenix/reference/widget/list-view.cpp
+++ b/nSide_v005-source-revised/phoenix/reference/widget/list-view.cpp
@@ -12,18 +12,12 @@ void pListView::remove(unsigned selection) {
 void pListView::reset() {
 }
 
-void pListView::setBackgroundColor(Color color) {
-}
-
 void pListView::setCheckable(bool checkable) {
 }
 
 void pListView::setChecked(unsigned selection, bool checked) {
 }
 
-void pListView::setForegroundColor(Color color) {
-}
-
 void pListView::setHeaderText(const lstring& text) {
 }
 
diff --git a/../../../git/Emulator/bsnes/bsnes/phoenix/reference/widget/list-view.hpp b/nSide_v005-source-revised/phoenix/reference/widget/list-view.hpp
index 8a97a95..2177015 100644
--- a/../../../git/Emulator/bsnes/bsnes/phoenix/reference/widget/list-view.hpp
+++ b/nSide_v005-source-revised/phoenix/reference/widget/list-view.hpp
@@ -7,10 +7,8 @@ struct pListView : public pWidget {
   void autoSizeColumns();
   void remove(unsigned selection);
   void reset();
-  void setBackgroundColor(Color color);
   void setCheckable(bool checkable);
   void setChecked(unsigned selection, bool checked);
-  void setForegroundColor(Color color);
   void setHeaderText(const lstring& text);
   void setHeaderVisible(bool visible);
   void setImage(unsigned selection, unsigned position, const image& image);
diff --git a/../../../git/Emulator/bsnes/bsnes/phoenix/reference/widget/text-edit.cpp b/nSide_v005-source-revised/phoenix/reference/widget/text-edit.cpp
index 064e304..d1dcca7 100644
--- a/../../../git/Emulator/bsnes/bsnes/phoenix/reference/widget/text-edit.cpp
+++ b/nSide_v005-source-revised/phoenix/reference/widget/text-edit.cpp
@@ -1,17 +1,11 @@
 namespace phoenix {
 
-void pTextEdit::setBackgroundColor(Color color) {
-}
-
 void pTextEdit::setCursorPosition(unsigned position) {
 }
 
 void pTextEdit::setEditable(bool editable) {
 }
 
-void pTextEdit::setForegroundColor(Color color) {
-}
-
 void pTextEdit::setText(string text) {
 }
 
diff --git a/../../../git/Emulator/bsnes/bsnes/phoenix/reference/widget/text-edit.hpp b/nSide_v005-source-revised/phoenix/reference/widget/text-edit.hpp
index 8d4cf77..0bca068 100644
--- a/../../../git/Emulator/bsnes/bsnes/phoenix/reference/widget/text-edit.hpp
+++ b/nSide_v005-source-revised/phoenix/reference/widget/text-edit.hpp
@@ -3,10 +3,8 @@ namespace phoenix {
 struct pTextEdit : public pWidget {
   TextEdit& textEdit;
 
-  void setBackgroundColor(Color color);
   void setCursorPosition(unsigned position);
   void setEditable(bool editable);
-  void setForegroundColor(Color color);
   void setText(string text);
   void setWordWrap(bool wordWrap);
   string text();
diff --git a/../../../git/Emulator/bsnes/bsnes/phoenix/windows/font.cpp b/nSide_v005-source-revised/phoenix/windows/font.cpp
index 94db0ec..1978114 100644
--- a/../../../git/Emulator/bsnes/bsnes/phoenix/windows/font.cpp
+++ b/nSide_v005-source-revised/phoenix/windows/font.cpp
@@ -37,8 +37,8 @@ HFONT pFont::create(string description) {
 
   if(part[0] != "") family = part[0];
   if(part.size() >= 2) size = decimal(part[1]);
-  if(part.size() >= 3) bold = (bool)part[2].find("Bold");
-  if(part.size() >= 3) italic = (bool)part[2].find("Italic");
+  if(part.size() >= 3) bold = part[2].find("Bold");
+  if(part.size() >= 3) italic = part[2].find("Italic");
 
   return CreateFont(
     -(size * 96.0 / 72.0 + 0.5),
diff --git a/../../../git/Emulator/bsnes/bsnes/phoenix/windows/platform.hpp b/nSide_v005-source-revised/phoenix/windows/platform.hpp
index 06378f5..91dbd42 100644
--- a/../../../git/Emulator/bsnes/bsnes/phoenix/windows/platform.hpp
+++ b/nSide_v005-source-revised/phoenix/windows/platform.hpp
@@ -363,9 +363,6 @@ struct pConsole : public pWidget {
 
   void print(string text);
   void reset();
-  void setBackgroundColor(Color color);
-  void setForegroundColor(Color color);
-  void setPrompt(string prompt);
 
   pConsole(Console& console) : pWidget(console), console(console) {}
   void constructor();
@@ -393,9 +390,7 @@ struct pHexEdit : public pWidget {
   WindowProc windowProc = nullptr;
   HWND scrollBar = nullptr;
 
-  void setBackgroundColor(Color color);
   void setColumns(unsigned columns);
-  void setForegroundColor(Color color);
   void setLength(unsigned length);
   void setOffset(unsigned offset);
   void setRows(unsigned rows);
@@ -458,9 +453,7 @@ struct pLineEdit : public pWidget {
   LineEdit& lineEdit;
 
   Size minimumSize();
-  void setBackgroundColor(Color color);
   void setEditable(bool editable);
-  void setForegroundColor(Color color);
   void setText(string text);
   string text();
 
@@ -483,10 +476,8 @@ struct pListView : public pWidget {
   void autoSizeColumns();
   void remove(unsigned selection);
   void reset();
-  void setBackgroundColor(Color color);
   void setCheckable(bool checkable);
   void setChecked(unsigned selection, bool checked);
-  void setForegroundColor(Color color);
   void setGeometry(Geometry geometry);
   void setHeaderText(const lstring& text);
   void setHeaderVisible(bool visible);
@@ -581,10 +572,8 @@ struct pTabFrame : public pWidget {
 struct pTextEdit : public pWidget {
   TextEdit& textEdit;
 
-  void setBackgroundColor(Color color);
   void setCursorPosition(unsigned position);
   void setEditable(bool editable);
-  void setForegroundColor(Color color);
   void setText(string text);
   void setWordWrap(bool wordWrap);
   string text();
diff --git a/../../../git/Emulator/bsnes/bsnes/phoenix/windows/widget/console.cpp b/nSide_v005-source-revised/phoenix/windows/widget/console.cpp
index 812fdfa..74fe1b1 100644
--- a/../../../git/Emulator/bsnes/bsnes/phoenix/windows/widget/console.cpp
+++ b/nSide_v005-source-revised/phoenix/windows/widget/console.cpp
@@ -14,15 +14,6 @@ void pConsole::print(string text) {
 void pConsole::reset() {
 }
 
-void pConsole::setBackgroundColor(Color color) {
-}
-
-void pConsole::setForegroundColor(Color color) {
-}
-
-void pConsole::setPrompt(string prompt) {
-}
-
 void pConsole::constructor() {
   hwnd = CreateWindowEx(
     WS_EX_CLIENTEDGE, L"EDIT", L"",
diff --git a/../../../git/Emulator/bsnes/bsnes/phoenix/windows/widget/hex-edit.cpp b/nSide_v005-source-revised/phoenix/windows/widget/hex-edit.cpp
index 3dace06..8f5ea1b 100644
--- a/../../../git/Emulator/bsnes/bsnes/phoenix/windows/widget/hex-edit.cpp
+++ b/nSide_v005-source-revised/phoenix/windows/widget/hex-edit.cpp
@@ -49,16 +49,10 @@ static LRESULT CALLBACK HexEdit_windowProc(HWND hwnd, UINT msg, WPARAM wparam, L
   return hexEdit.p.windowProc(hwnd, msg, wparam, lparam);
 }
 
-void pHexEdit::setBackgroundColor(Color color) {
-}
-
 void pHexEdit::setColumns(unsigned columns) {
   update();
 }
 
-void pHexEdit::setForegroundColor(Color color) {
-}
-
 void pHexEdit::setLength(unsigned length) {
   SetScrollRange(scrollBar, SB_CTL, 0, rowsScrollable(), TRUE);
   EnableWindow(scrollBar, rowsScrollable() > 0);
diff --git a/../../../git/Emulator/bsnes/bsnes/phoenix/windows/widget/line-edit.cpp b/nSide_v005-source-revised/phoenix/windows/widget/line-edit.cpp
index 0b38313..fd25b81 100644
--- a/../../../git/Emulator/bsnes/bsnes/phoenix/windows/widget/line-edit.cpp
+++ b/nSide_v005-source-revised/phoenix/windows/widget/line-edit.cpp
@@ -5,16 +5,10 @@ Size pLineEdit::minimumSize() {
   return {size.width + 12, size.height + 10};
 }
 
-void pLineEdit::setBackgroundColor(Color color) {
-}
-
 void pLineEdit::setEditable(bool editable) {
   SendMessage(hwnd, EM_SETREADONLY, editable == false, 0);
 }
 
-void pLineEdit::setForegroundColor(Color color) {
-}
-
 void pLineEdit::setText(string text) {
   locked = true;
   SetWindowText(hwnd, utf16_t(text));
diff --git a/../../../git/Emulator/bsnes/bsnes/phoenix/windows/widget/list-view.cpp b/nSide_v005-source-revised/phoenix/windows/widget/list-view.cpp
index 465a9fe..efcbb20 100644
--- a/../../../git/Emulator/bsnes/bsnes/phoenix/windows/widget/list-view.cpp
+++ b/nSide_v005-source-revised/phoenix/windows/widget/list-view.cpp
@@ -56,9 +56,6 @@ void pListView::reset() {
   buildImageList();  //free previously allocated images
 }
 
-void pListView::setBackgroundColor(Color color) {
-}
-
 void pListView::setCheckable(bool checkable) {
   ListView_SetExtendedListViewStyle(hwnd, LVS_EX_FULLROWSELECT | LVS_EX_SUBITEMIMAGES | (checkable ? LVS_EX_CHECKBOXES : 0));
 }
@@ -69,9 +66,6 @@ void pListView::setChecked(unsigned selection, bool checked) {
   locked = false;
 }
 
-void pListView::setForegroundColor(Color color) {
-}
-
 void pListView::setGeometry(Geometry geometry) {
   pWidget::setGeometry(geometry);
   autoSizeColumns();
diff --git a/../../../git/Emulator/bsnes/bsnes/phoenix/windows/widget/text-edit.cpp b/nSide_v005-source-revised/phoenix/windows/widget/text-edit.cpp
index 509897f..ae3e8ce 100644
--- a/../../../git/Emulator/bsnes/bsnes/phoenix/windows/widget/text-edit.cpp
+++ b/nSide_v005-source-revised/phoenix/windows/widget/text-edit.cpp
@@ -1,8 +1,5 @@
 namespace phoenix {
 
-void pTextEdit::setBackgroundColor(Color color) {
-}
-
 void pTextEdit::setCursorPosition(unsigned position) {
   if(position == ~0) position >>= 1;  //Edit_SetSel takes signed type
   Edit_SetSel(hwnd, position, position);
@@ -13,9 +10,6 @@ void pTextEdit::setEditable(bool editable) {
   SendMessage(hwnd, EM_SETREADONLY, editable == false, (LPARAM)0);
 }
 
-void pTextEdit::setForegroundColor(Color color) {
-}
-
 void pTextEdit::setText(string text) {
   locked = true;
   string output = text;
diff --git a/../../../git/Emulator/bsnes/bsnes/processor/r6502/instructions.cpp b/nSide_v005-source-revised/processor/r6502/instructions.cpp
index 9d551c0..95942e3 100644
--- a/../../../git/Emulator/bsnes/bsnes/processor/r6502/instructions.cpp
+++ b/nSide_v005-source-revised/processor/r6502/instructions.cpp
@@ -32,7 +32,7 @@ void R6502::opf_bit() {
 void R6502::opf_cmp() {
   signed r = regs.a - rd;
   regs.p.n = (r & 0x80);
-  regs.p.z = (uint8)(r == 0);
+  regs.p.z = ((uint8)r == 0);
   regs.p.c = (r >= 0);
 }
 
@@ -323,7 +323,7 @@ L op_readpc();
   call(op);
 }
 
-void R6502::opi_store_absolute(uint8& r) {
+void R6502::opi_store_absolute(uint8 r) {
   abs.l = op_readpci();
   abs.h = op_readpci();
 L op_write(abs.w, r);
@@ -343,7 +343,7 @@ void R6502::opi_store_absolute_y(uint8& r) {
 L op_write(abs.w + regs.y, r);
 }
 
-void R6502::opi_store_indirect_zero_page_x(uint8& r) {
+void R6502::opi_store_indirect_zero_page_x(uint8 r) {
   zp = op_readpci();
   op_readzp(zp);
   abs.l = op_readzp(zp++ + regs.x);
@@ -359,7 +359,7 @@ void R6502::opi_store_indirect_zero_page_y(uint8& r) {
 L op_write(abs.w + regs.y, r);
 }
 
-void R6502::opi_store_zero_page(uint8& r) {
+void R6502::opi_store_zero_page(uint8 r) {
   zp = op_readpci();
 L op_writezp(zp, r);
 }
@@ -370,7 +370,7 @@ void R6502::opi_store_zero_page_x(uint8& r) {
 L op_writezp(zp + regs.x, r);
 }
 
-void R6502::opi_store_zero_page_y(uint8& r) {
+void R6502::opi_store_zero_page_y(uint8 r) {
   zp = op_readpci();
   op_readzp(zp);
 L op_writezp(zp + regs.y, r);
@@ -391,11 +391,12 @@ void R6502::op_brk() {
   op_readpci();
   op_writesp(regs.pc >> 8);
   op_writesp(regs.pc >> 0);
+  uint16 vector = 0xfffe;
+  nmi(vector);
   op_writesp(regs.p | 0x30);
-  abs.l = op_read(0xfffe);
+  abs.l = op_read(vector + 0);
   regs.p.i = 1;
-  regs.p.d = 0;
-L abs.h = op_read(0xffff);
+L abs.h = op_read(vector + 1);
   regs.pc = abs.w;
 }
 
@@ -456,9 +457,118 @@ L op_readpc();
   regs.pc = ++abs.w;
 }
 
+//illegal opcode functions
+//========================
+
+void R6502::opillf_dcp() {
+  opf_dec();
+  opf_cmp();
+}
+
+void R6502::opillf_lax() {
+  opf_lda();
+  regs.x = regs.a;
+}
+
+//illegal opcode implementations
+//==============================
+
+template<void (R6502::*opw)(),void (R6502::*opr)()>
+void R6502::opilli_rmwr_absolute() {
+  abs.l = op_readpci();
+  abs.h = op_readpci();
+  rd = op_read(abs.w);
+  op_write(abs.w, rd);
+  call(opw);
+L op_write(abs.w, rd);
+  call(opr);
+}
+
+template<void (R6502::*opw)(),void (R6502::*opr)()>
+void R6502::opilli_rmwr_absolute_x() {
+  abs.l = op_readpci();
+  abs.h = op_readpci();
+  op_page_always(abs.w, abs.w + regs.x);
+  rd = op_read(abs.w + regs.x);
+  op_write(abs.w + regs.x, rd);
+  call(opw);
+L op_write(abs.w + regs.x, rd);
+  call(opr);
+}
+
+template<void (R6502::*opw)(),void (R6502::*opr)()>
+void R6502::opilli_rmwr_absolute_y() {
+  abs.l = op_readpci();
+  abs.h = op_readpci();
+  op_page_always(abs.w, abs.w + regs.y);
+  rd = op_read(abs.w + regs.y);
+  op_write(abs.w + regs.y, rd);
+  call(opw);
+L op_write(abs.w + regs.y, rd);
+  call(opr);
+}
+
+template<void (R6502::*opw)(),void (R6502::*opr)()>
+void R6502::opilli_rmwr_indirect_zero_page_x() {
+  zp = op_readpci();
+  op_readzp(zp);
+  abs.l = op_readzp(zp++ + regs.x);
+  abs.h = op_readzp(zp++ + regs.x);
+  rd = op_read(abs.w);
+  op_write(abs.w, rd);
+  call(opw);
+L op_write(abs.w, rd);
+  call(opr);
+}
+
+template<void (R6502::*opw)(),void (R6502::*opr)()>
+void R6502::opilli_rmwr_indirect_zero_page_y() {
+  rd = op_readpci();
+  abs.l = op_readzp(rd++);
+  abs.h = op_readzp(rd++);
+  op_page(abs.w, abs.w + regs.y);
+  rd = op_read(abs.w + regs.y);
+  op_write(abs.w + regs.y, rd);
+  call(opw);
+L op_write(abs.w + regs.y, rd);
+  call(opr);
+}
+
+template<void (R6502::*opw)(),void (R6502::*opr)()>
+void R6502::opilli_rmwr_zero_page() {
+  zp = op_readpci();
+  rd = op_readzp(zp);
+  op_writezp(zp, rd);
+  call(opw);
+L op_writezp(zp, rd);
+  call(opr);
+}
+
+template<void (R6502::*opw)(),void (R6502::*opr)()>
+void R6502::opilli_rmwr_zero_page_x() {
+  zp = op_readpci();
+  op_readzp(zp);
+  rd = op_readzp(zp + regs.x);
+  op_writezp(zp + regs.x, rd);
+  call(opw);
+L op_writezp(zp + regs.x, rd);
+  call(opr);
+}
+
 //illegal opcodes
 //===============
 
+void R6502::opill_alr_immediate() {
+  opi_read_immediate<&R6502::opf_and>();
+  opf_sra();
+}
+
+void R6502::opill_anc_immediate() {
+L rd = op_readpci();
+  opf_and();
+  regs.p.c = regs.p.n;
+}
+
 void R6502::opill_arr_immediate() {
 L rd = op_readpci();
   regs.a &= rd;
@@ -469,6 +579,62 @@ L rd = op_readpci();
   regs.p.v = regs.p.c ^ ((regs.a >> 5) & 1);
 }
 
+void R6502::opill_axs_immediate() {
+L rd = op_readpci();
+  signed r = (regs.a & regs.x) - rd;
+  regs.p.n = (r & 0x80);
+  regs.p.z = ((uint8)r == 0);
+  regs.p.c = (r >= 0);
+  regs.x = r;
+}
+
+void R6502::opill_dcp_absolute_y() {
+  abs.l = op_readpci();
+  abs.h = op_readpci();
+  op_page_always(abs.w, abs.w + regs.y);
+  rd = op_read(abs.w + regs.y);
+  op_write(abs.w + regs.y, rd);
+  opf_dec();
+  opf_cmp();
+L op_write(abs.w + regs.y, rd);
+}
+
+void R6502::opill_dcp_indirect_zero_page_x() {
+  zp = op_readpci();
+  op_readzp(zp);
+  abs.l = op_readzp(zp++ + regs.x);
+  abs.h = op_readzp(zp++ + regs.x);
+  rd = op_read(abs.w);
+  op_write(abs.w, rd);
+  opf_dec();
+  opf_cmp();
+L op_write(abs.w, rd);
+}
+
+void R6502::opill_dcp_indirect_zero_page_y() {
+  rd = op_readpci();
+  abs.l = op_readzp(rd++);
+  abs.h = op_readzp(rd++);
+  op_page(abs.w, abs.w + regs.y);
+  rd = op_read(abs.w + regs.y);
+  op_write(abs.w + regs.y, rd);
+  opf_dec();
+  opf_cmp();
+L op_write(abs.w + regs.y, rd);
+}
+
+void R6502::opill_stp() {
+  while(true) op_readpc();
+}
+
+// line noise on the data bus interferes with LAX #i.
+void R6502::opill_lax_immediate() {
+  //regs.x = regs.a | 0xee;
+  opi_read_immediate<&R6502::opf_lda>();
+  //regs.a = regs.a & regs.x;
+  regs.x = regs.a;
+}
+
 void R6502::opill_nop_absolute() {
   abs.l = op_readpci();
   abs.h = op_readpci();
@@ -483,7 +649,7 @@ L op_readpc();
 }
 
 void R6502::opill_nop_immediate() {
-L rd = op_readpc();
+L rd = op_readpci();
 }
 
 void R6502::opill_nop_implied() {
@@ -500,3 +666,17 @@ void R6502::opill_nop_zero_page_x() {
   op_readzp(zp);
 L op_readzp(zp + regs.x);
 }
+
+void R6502::opill_shx_absolute_y() {
+  abs.l = op_readpci();
+  abs.h = op_readpci();
+  op_page_always(abs.w, abs.w + regs.y);
+L op_write(abs.w + regs.y, regs.x & (abs.h + 1));
+}
+
+void R6502::opill_shy_absolute_x() {
+  abs.l = op_readpci();
+  abs.h = op_readpci();
+  op_page_always(abs.w, abs.w + regs.x);
+L op_write(abs.w + regs.x, regs.y & (abs.h + 1));
+}
diff --git a/../../../git/Emulator/bsnes/bsnes/processor/r6502/r6502.cpp b/nSide_v005-source-revised/processor/r6502/r6502.cpp
index b560059..e1df7ad 100644
--- a/../../../git/Emulator/bsnes/bsnes/processor/r6502/r6502.cpp
+++ b/nSide_v005-source-revised/processor/r6502/r6502.cpp
@@ -50,75 +50,108 @@ void R6502::exec() {
   switch(opcode) {
   case 0x00: return op_brk();
   case 0x01: return opi_read_indirect_zero_page_x<&R6502::opf_ora>();
+I case 0x02: return opill_stp();
+I case 0x03: return opilli_rmwr_indirect_zero_page_x<&R6502::opf_asl,&R6502::opf_ora>();
 I case 0x04: return opill_nop_zero_page();
   case 0x05: return opi_read_zero_page<&R6502::opf_ora>();
   case 0x06: return opi_rmw_zero_page<&R6502::opf_asl>();
+I case 0x07: return opilli_rmwr_zero_page<&R6502::opf_asl,&R6502::opf_ora>();
   case 0x08: return op_php();
   case 0x09: return opi_read_immediate<&R6502::opf_ora>();
   case 0x0a: return opi_shift<&R6502::opf_sla>();
+I case 0x0b: return opill_anc_immediate();
 I case 0x0c: return opill_nop_absolute();
   case 0x0d: return opi_read_absolute<&R6502::opf_ora>();
   case 0x0e: return opi_rmw_absolute<&R6502::opf_asl>();
+I case 0x0f: return opilli_rmwr_absolute<&R6502::opf_asl,&R6502::opf_ora>();
   case 0x10: return opi_branch(regs.p.n == 0);
   case 0x11: return opi_read_indirect_zero_page_y<&R6502::opf_ora>();
+I case 0x12: return opill_stp();
+I case 0x13: return opilli_rmwr_indirect_zero_page_y<&R6502::opf_asl,&R6502::opf_ora>();
 I case 0x14: return opill_nop_zero_page_x();
   case 0x15: return opi_read_zero_page_x<&R6502::opf_ora>();
   case 0x16: return opi_rmw_zero_page_x<&R6502::opf_asl>();
+I case 0x17: return opilli_rmwr_zero_page_x<&R6502::opf_asl,&R6502::opf_ora>();
   case 0x18: return opi_clear_flag(regs.p.c);
   case 0x19: return opi_read_absolute_y<&R6502::opf_ora>();
 I case 0x1a: return opill_nop_implied();
+I case 0x1b: return opilli_rmwr_absolute_y<&R6502::opf_asl,&R6502::opf_ora>();
 I case 0x1c: return opill_nop_absolute_x();
   case 0x1d: return opi_read_absolute_x<&R6502::opf_ora>();
   case 0x1e: return opi_rmw_absolute_x<&R6502::opf_asl>();
+I case 0x1f: return opilli_rmwr_absolute_x<&R6502::opf_asl,&R6502::opf_ora>();
   case 0x20: return op_jsr_absolute();
   case 0x21: return opi_read_indirect_zero_page_x<&R6502::opf_and>();
+I case 0x22: return opill_stp();
+I case 0x23: return opilli_rmwr_indirect_zero_page_x<&R6502::opf_rol,&R6502::opf_and>();
   case 0x24: return opi_read_zero_page<&R6502::opf_bit>();
   case 0x25: return opi_read_zero_page<&R6502::opf_and>();
   case 0x26: return opi_rmw_zero_page<&R6502::opf_rol>();
+I case 0x27: return opilli_rmwr_zero_page<&R6502::opf_rol,&R6502::opf_and>();
   case 0x28: return op_plp();
   case 0x29: return opi_read_immediate<&R6502::opf_and>();
   case 0x2a: return opi_shift<&R6502::opf_rla>();
+I case 0x2b: return opill_anc_immediate();
   case 0x2c: return opi_read_absolute<&R6502::opf_bit>();
   case 0x2d: return opi_read_absolute<&R6502::opf_and>();
   case 0x2e: return opi_rmw_absolute<&R6502::opf_rol>();
+I case 0x2f: return opilli_rmwr_absolute<&R6502::opf_rol,&R6502::opf_and>();
   case 0x30: return opi_branch(regs.p.n == 1);
   case 0x31: return opi_read_indirect_zero_page_y<&R6502::opf_and>();
+I case 0x32: return opill_stp();
+I case 0x33: return opilli_rmwr_indirect_zero_page_y<&R6502::opf_rol,&R6502::opf_and>();
 I case 0x34: return opill_nop_zero_page_x();
   case 0x35: return opi_read_zero_page_x<&R6502::opf_and>();
   case 0x36: return opi_rmw_zero_page_x<&R6502::opf_rol>();
+I case 0x37: return opilli_rmwr_zero_page_x<&R6502::opf_rol,&R6502::opf_and>();
   case 0x38: return opi_set_flag(regs.p.c);
   case 0x39: return opi_read_absolute_y<&R6502::opf_and>();
 I case 0x3a: return opill_nop_implied();
+I case 0x3b: return opilli_rmwr_absolute_y<&R6502::opf_rol,&R6502::opf_and>();
 I case 0x3c: return opill_nop_absolute_x();
   case 0x3d: return opi_read_absolute_x<&R6502::opf_and>();
   case 0x3e: return opi_rmw_absolute_x<&R6502::opf_rol>();
+I case 0x3f: return opilli_rmwr_absolute_x<&R6502::opf_rol,&R6502::opf_and>();
   case 0x40: return op_rti();
   case 0x41: return opi_read_indirect_zero_page_x<&R6502::opf_eor>();
+I case 0x42: return opill_stp();
+I case 0x43: return opilli_rmwr_indirect_zero_page_x<&R6502::opf_lsr,&R6502::opf_eor>();
 I case 0x44: return opill_nop_zero_page();
   case 0x45: return opi_read_zero_page<&R6502::opf_eor>();
   case 0x46: return opi_rmw_zero_page<&R6502::opf_lsr>();
+I case 0x47: return opilli_rmwr_zero_page<&R6502::opf_lsr,&R6502::opf_eor>();
   case 0x48: return opi_push(regs.a);
   case 0x49: return opi_read_immediate<&R6502::opf_eor>();
   case 0x4a: return opi_shift<&R6502::opf_sra>();
+I case 0x4b: return opill_alr_immediate();
   case 0x4c: return op_jmp_absolute();
   case 0x4d: return opi_read_absolute<&R6502::opf_eor>();
   case 0x4e: return opi_rmw_absolute<&R6502::opf_lsr>();
+I case 0x4f: return opilli_rmwr_absolute<&R6502::opf_lsr,&R6502::opf_eor>();
   case 0x50: return opi_branch(regs.p.v == 0);
   case 0x51: return opi_read_indirect_zero_page_y<&R6502::opf_eor>();
+I case 0x52: return opill_stp();
+I case 0x53: return opilli_rmwr_indirect_zero_page_y<&R6502::opf_lsr,&R6502::opf_eor>();
 I case 0x54: return opill_nop_zero_page_x();
   case 0x55: return opi_read_zero_page_x<&R6502::opf_eor>();
   case 0x56: return opi_rmw_zero_page_x<&R6502::opf_lsr>();
+I case 0x57: return opilli_rmwr_zero_page_x<&R6502::opf_lsr,&R6502::opf_eor>();
   case 0x58: return opi_clear_flag(regs.p.i);
   case 0x59: return opi_read_absolute_y<&R6502::opf_eor>();
 I case 0x5a: return opill_nop_implied();
+I case 0x5b: return opilli_rmwr_absolute_y<&R6502::opf_lsr,&R6502::opf_eor>();
 I case 0x5c: return opill_nop_absolute_x();
   case 0x5d: return opi_read_absolute_x<&R6502::opf_eor>();
   case 0x5e: return opi_rmw_absolute_x<&R6502::opf_lsr>();
+I case 0x5f: return opilli_rmwr_absolute_x<&R6502::opf_lsr,&R6502::opf_eor>();
   case 0x60: return op_rts();
   case 0x61: return opi_read_indirect_zero_page_x<&R6502::opf_adc>();
+I case 0x62: return opill_stp();
+I case 0x63: return opilli_rmwr_indirect_zero_page_x<&R6502::opf_ror,&R6502::opf_adc>();
 I case 0x64: return opill_nop_zero_page();
   case 0x65: return opi_read_zero_page<&R6502::opf_adc>();
   case 0x66: return opi_rmw_zero_page<&R6502::opf_ror>();
+I case 0x67: return opilli_rmwr_zero_page<&R6502::opf_ror,&R6502::opf_adc>();
   case 0x68: return opi_pull(regs.a);
   case 0x69: return opi_read_immediate<&R6502::opf_adc>();
   case 0x6a: return opi_shift<&R6502::opf_rra>();
@@ -126,90 +159,122 @@ I case 0x6b: return opill_arr_immediate();
   case 0x6c: return op_jmp_indirect_absolute();
   case 0x6d: return opi_read_absolute<&R6502::opf_adc>();
   case 0x6e: return opi_rmw_absolute<&R6502::opf_ror>();
+I case 0x6f: return opilli_rmwr_absolute<&R6502::opf_ror,&R6502::opf_adc>();
   case 0x70: return opi_branch(regs.p.v == 1);
-I case 0x74: return opill_nop_zero_page_x();
   case 0x71: return opi_read_indirect_zero_page_y<&R6502::opf_adc>();
+I case 0x72: return opill_stp();
+I case 0x73: return opilli_rmwr_indirect_zero_page_y<&R6502::opf_ror,&R6502::opf_adc>();
+I case 0x74: return opill_nop_zero_page_x();
   case 0x75: return opi_read_zero_page_x<&R6502::opf_adc>();
   case 0x76: return opi_rmw_zero_page_x<&R6502::opf_ror>();
+I case 0x77: return opilli_rmwr_zero_page_x<&R6502::opf_ror,&R6502::opf_adc>();
   case 0x78: return opi_set_flag(regs.p.i);
   case 0x79: return opi_read_absolute_y<&R6502::opf_adc>();
 I case 0x7a: return opill_nop_implied();
+I case 0x7b: return opilli_rmwr_absolute_y<&R6502::opf_ror,&R6502::opf_adc>();
 I case 0x7c: return opill_nop_absolute_x();
   case 0x7d: return opi_read_absolute_x<&R6502::opf_adc>();
   case 0x7e: return opi_rmw_absolute_x<&R6502::opf_ror>();
-I case 0x80: return opill_nop_absolute();
+I case 0x7f: return opilli_rmwr_absolute_x<&R6502::opf_ror,&R6502::opf_adc>();
+I case 0x80: return opill_nop_immediate(); // regs.y
   case 0x81: return opi_store_indirect_zero_page_x(regs.a);
-I case 0x82: return opill_nop_immediate();
+I case 0x82: return opill_nop_immediate(); // regs.x
+I case 0x83: return opi_store_indirect_zero_page_x(regs.a & regs.x);
   case 0x84: return opi_store_zero_page(regs.y);
   case 0x85: return opi_store_zero_page(regs.a);
   case 0x86: return opi_store_zero_page(regs.x);
+I case 0x87: return opi_store_zero_page(regs.a & regs.x);
   case 0x88: return opi_decrement(regs.y);
-I case 0x89: return opill_nop_immediate();
+I case 0x89: return opill_nop_immediate(); // regs.a
   case 0x8a: return opi_transfer(regs.x, regs.a, 1);
   case 0x8c: return opi_store_absolute(regs.y);
   case 0x8d: return opi_store_absolute(regs.a);
   case 0x8e: return opi_store_absolute(regs.x);
+I case 0x8f: return opi_store_absolute(regs.a & regs.x);
   case 0x90: return opi_branch(regs.p.c == 0);
   case 0x91: return opi_store_indirect_zero_page_y(regs.a);
+I case 0x92: return opill_stp();
   case 0x94: return opi_store_zero_page_x(regs.y);
   case 0x95: return opi_store_zero_page_x(regs.a);
   case 0x96: return opi_store_zero_page_y(regs.x);
+I case 0x97: return opi_store_zero_page_y(regs.a & regs.x);
   case 0x98: return opi_transfer(regs.y, regs.a, 1);
   case 0x99: return opi_store_absolute_y(regs.a);
   case 0x9a: return opi_transfer(regs.x, regs.s, 0);
+I case 0x9c: return opill_shy_absolute_x();
   case 0x9d: return opi_store_absolute_x(regs.a);
+I case 0x9e: return opill_shx_absolute_y();
   case 0xa0: return opi_read_immediate<&R6502::opf_ldy>();
   case 0xa1: return opi_read_indirect_zero_page_x<&R6502::opf_lda>();
   case 0xa2: return opi_read_immediate<&R6502::opf_ldx>();
+I case 0xa3: return opi_read_indirect_zero_page_x<&R6502::opillf_lax>();
   case 0xa4: return opi_read_zero_page<&R6502::opf_ldy>();
   case 0xa5: return opi_read_zero_page<&R6502::opf_lda>();
   case 0xa6: return opi_read_zero_page<&R6502::opf_ldx>();
+I case 0xa7: return opi_read_zero_page<&R6502::opillf_lax>();
   case 0xa8: return opi_transfer(regs.a, regs.y, 1);
   case 0xa9: return opi_read_immediate<&R6502::opf_lda>();
   case 0xaa: return opi_transfer(regs.a, regs.x, 1);
+I case 0xab: return opill_lax_immediate();
   case 0xac: return opi_read_absolute<&R6502::opf_ldy>();
   case 0xad: return opi_read_absolute<&R6502::opf_lda>();
   case 0xae: return opi_read_absolute<&R6502::opf_ldx>();
+I case 0xaf: return opi_read_absolute<&R6502::opillf_lax>();
   case 0xb0: return opi_branch(regs.p.c == 1);
   case 0xb1: return opi_read_indirect_zero_page_y<&R6502::opf_lda>();
+I case 0xb2: return opill_stp();
+I case 0xb3: return opi_read_indirect_zero_page_y<&R6502::opillf_lax>();
   case 0xb4: return opi_read_zero_page_x<&R6502::opf_ldy>();
   case 0xb5: return opi_read_zero_page_x<&R6502::opf_lda>();
   case 0xb6: return opi_read_zero_page_y<&R6502::opf_ldx>();
+I case 0xb7: return opi_read_zero_page_y<&R6502::opillf_lax>();
   case 0xb8: return opi_clear_flag(regs.p.v);
   case 0xb9: return opi_read_absolute_y<&R6502::opf_lda>();
   case 0xba: return opi_transfer(regs.s, regs.x, 1);
   case 0xbc: return opi_read_absolute_x<&R6502::opf_ldy>();
   case 0xbd: return opi_read_absolute_x<&R6502::opf_lda>();
   case 0xbe: return opi_read_absolute_y<&R6502::opf_ldx>();
+I case 0xbf: return opi_read_absolute_y<&R6502::opillf_lax>();
   case 0xc0: return opi_read_immediate<&R6502::opf_cpy>();
   case 0xc1: return opi_read_indirect_zero_page_x<&R6502::opf_cmp>();
 I case 0xc2: return opill_nop_immediate();
+I case 0xc3: return opill_dcp_indirect_zero_page_x();
   case 0xc4: return opi_read_zero_page<&R6502::opf_cpy>();
   case 0xc5: return opi_read_zero_page<&R6502::opf_cmp>();
   case 0xc6: return opi_rmw_zero_page<&R6502::opf_dec>();
+I case 0xc7: return opi_rmw_zero_page<&R6502::opillf_dcp>();
   case 0xc8: return opi_increment(regs.y);
   case 0xc9: return opi_read_immediate<&R6502::opf_cmp>();
   case 0xca: return opi_decrement(regs.x);
+I case 0xcb: return opill_axs_immediate();
   case 0xcc: return opi_read_absolute<&R6502::opf_cpy>();
   case 0xcd: return opi_read_absolute<&R6502::opf_cmp>();
   case 0xce: return opi_rmw_absolute<&R6502::opf_dec>();
+I case 0xcf: return opi_rmw_absolute<&R6502::opillf_dcp>();
   case 0xd0: return opi_branch(regs.p.z == 0);
   case 0xd1: return opi_read_indirect_zero_page_y<&R6502::opf_cmp>();
+I case 0xd2: return opill_stp();
+I case 0xd3: return opill_dcp_indirect_zero_page_y();
 I case 0xd4: return opill_nop_zero_page_x();
   case 0xd5: return opi_read_zero_page_x<&R6502::opf_cmp>();
   case 0xd6: return opi_rmw_zero_page_x<&R6502::opf_dec>();
+I case 0xd7: return opi_rmw_zero_page_x<&R6502::opillf_dcp>();
   case 0xd8: return opi_clear_flag(regs.p.d);
   case 0xd9: return opi_read_absolute_y<&R6502::opf_cmp>();
 I case 0xda: return opill_nop_implied();
+I case 0xdb: return opill_dcp_absolute_y();
 I case 0xdc: return opill_nop_absolute_x();
   case 0xdd: return opi_read_absolute_x<&R6502::opf_cmp>();
   case 0xde: return opi_rmw_absolute_x<&R6502::opf_dec>();
+I case 0xdf: return opi_rmw_absolute_x<&R6502::opillf_dcp>();
   case 0xe0: return opi_read_immediate<&R6502::opf_cpx>();
   case 0xe1: return opi_read_indirect_zero_page_x<&R6502::opf_sbc>();
 I case 0xe2: return opill_nop_immediate();
+I case 0xe3: return opilli_rmwr_indirect_zero_page_x<&R6502::opf_inc,&R6502::opf_sbc>();
   case 0xe4: return opi_read_zero_page<&R6502::opf_cpx>();
   case 0xe5: return opi_read_zero_page<&R6502::opf_sbc>();
   case 0xe6: return opi_rmw_zero_page<&R6502::opf_inc>();
+I case 0xe7: return opilli_rmwr_zero_page<&R6502::opf_inc,&R6502::opf_sbc>();
   case 0xe8: return opi_increment(regs.x);
   case 0xe9: return opi_read_immediate<&R6502::opf_sbc>();
   case 0xea: return op_nop();
@@ -217,17 +282,23 @@ I case 0xeb: return opi_read_immediate<&R6502::opf_sbc>();
   case 0xec: return opi_read_absolute<&R6502::opf_cpx>();
   case 0xed: return opi_read_absolute<&R6502::opf_sbc>();
   case 0xee: return opi_rmw_absolute<&R6502::opf_inc>();
+I case 0xef: return opilli_rmwr_absolute<&R6502::opf_inc,&R6502::opf_sbc>();
   case 0xf0: return opi_branch(regs.p.z == 1);
   case 0xf1: return opi_read_indirect_zero_page_y<&R6502::opf_sbc>();
+I case 0xf2: return opill_stp();
+I case 0xf3: return opilli_rmwr_indirect_zero_page_y<&R6502::opf_inc,&R6502::opf_sbc>();
 I case 0xf4: return opill_nop_zero_page_x();
   case 0xf5: return opi_read_zero_page_x<&R6502::opf_sbc>();
   case 0xf6: return opi_rmw_zero_page_x<&R6502::opf_inc>();
+I case 0xf7: return opilli_rmwr_zero_page_x<&R6502::opf_inc,&R6502::opf_sbc>();
   case 0xf8: return opi_set_flag(regs.p.d);
   case 0xf9: return opi_read_absolute_y<&R6502::opf_sbc>();
 I case 0xfa: return opill_nop_implied();
+I case 0xfb: return opilli_rmwr_absolute_y<&R6502::opf_inc,&R6502::opf_sbc>();
 I case 0xfc: return opill_nop_absolute_x();
   case 0xfd: return opi_read_absolute_x<&R6502::opf_sbc>();
   case 0xfe: return opi_rmw_absolute_x<&R6502::opf_inc>();
+I case 0xff: return opilli_rmwr_absolute_x<&R6502::opf_inc,&R6502::opf_sbc>();
   }
 
   //unimplemented opcode
diff --git a/../../../git/Emulator/bsnes/bsnes/processor/r6502/r6502.hpp b/nSide_v005-source-revised/processor/r6502/r6502.hpp
index e6d5dad..c0233ba 100644
--- a/../../../git/Emulator/bsnes/bsnes/processor/r6502/r6502.hpp
+++ b/nSide_v005-source-revised/processor/r6502/r6502.hpp
@@ -81,14 +81,14 @@ struct R6502 {
   template<void (R6502::*op)()> void opi_rmw_zero_page_x();
   void opi_set_flag(bool& flag);
   template<void (R6502::*op)()> void opi_shift();
-  void opi_store_absolute(uint8& r);
+  void opi_store_absolute(uint8 r);
   void opi_store_absolute_x(uint8& r);
   void opi_store_absolute_y(uint8& r);
-  void opi_store_indirect_zero_page_x(uint8& r);
+  void opi_store_indirect_zero_page_x(uint8 r);
   void opi_store_indirect_zero_page_y(uint8& r);
-  void opi_store_zero_page(uint8& r);
+  void opi_store_zero_page(uint8 r);
   void opi_store_zero_page_x(uint8& r);
-  void opi_store_zero_page_y(uint8& r);
+  void opi_store_zero_page_y(uint8 r);
   void opi_transfer(uint8& s, uint8& d, bool flag);
 
   void op_brk();
@@ -101,13 +101,41 @@ struct R6502 {
   void op_rti();
   void op_rts();
 
+  void opillf_dcp();
+  void opillf_lax();
+
+  template<void (R6502::*opw)(),void (R6502::*opr)()>
+  void opilli_rmwr_absolute();
+  template<void (R6502::*opw)(),void (R6502::*opr)()>
+  void opilli_rmwr_absolute_x();
+  template<void (R6502::*opw)(),void (R6502::*opr)()>
+  void opilli_rmwr_absolute_y();
+  template<void (R6502::*opw)(),void (R6502::*opr)()>
+  void opilli_rmwr_indirect_zero_page_x();
+  template<void (R6502::*opw)(),void (R6502::*opr)()>
+  void opilli_rmwr_indirect_zero_page_y();
+  template<void (R6502::*opw)(),void (R6502::*opr)()>
+  void opilli_rmwr_zero_page();
+  template<void (R6502::*opw)(),void (R6502::*opr)()>
+  void opilli_rmwr_zero_page_x();
+
+  void opill_alr_immediate();
+  void opill_anc_immediate();
   void opill_arr_immediate();
+  void opill_axs_immediate();
+  void opill_dcp_absolute_y();
+  void opill_dcp_indirect_zero_page_x();
+  void opill_dcp_indirect_zero_page_y();
+  void opill_stp();
+  void opill_lax_immediate();
   void opill_nop_absolute();
   void opill_nop_absolute_x();
   void opill_nop_immediate();
   void opill_nop_implied();
   void opill_nop_zero_page();
   void opill_nop_zero_page_x();
+  void opill_shx_absolute_y();
+  void opill_shy_absolute_x();
 
   //disassembler.cpp
   string disassemble();
diff --git a/../../../git/Emulator/bsnes/bsnes/processor/r65816/disassembler.cpp b/nSide_v005-source-revised/processor/r65816/disassembler.cpp
index f164ee1..38d05d3 100644
--- a/../../../git/Emulator/bsnes/bsnes/processor/r65816/disassembler.cpp
+++ b/nSide_v005-source-revised/processor/r65816/disassembler.cpp
@@ -102,11 +102,7 @@ uint32 R65816::decode(uint8 offset_type, uint32 addr) {
   return(r & 0xffffff);
 }
 
-void R65816::disassemble_opcode(char* output) {
-  return disassemble_opcode(output, regs.pc.d, regs.e, regs.p.m, regs.p.x);
-}
-
-void R65816::disassemble_opcode(char* output, uint32 addr, bool e, bool m, bool x) {
+void R65816::disassemble_opcode(char* output, uint32 addr) {
   static reg24_t pc;
   char t[256];
   char* s = output;
@@ -127,8 +123,8 @@ void R65816::disassemble_opcode(char* output, uint32 addr, bool e, bool m, bool
   #define op8  ((op0))
   #define op16 ((op0) | (op1 << 8))
   #define op24 ((op0) | (op1 << 8) | (op2 << 16))
-  #define a8   (e || m)
-  #define x8   (e || x)
+  #define a8   (regs.e || regs.p.m)
+  #define x8   (regs.e || regs.p.x)
 
   switch(op) {
   case 0x00: sprintf(t, "brk #$%.2x              ", op8); break;
diff --git a/../../../git/Emulator/bsnes/bsnes/processor/r65816/disassembler.hpp b/nSide_v005-source-revised/processor/r65816/disassembler.hpp
index 7b5d9c2..a6732bd 100644
--- a/../../../git/Emulator/bsnes/bsnes/processor/r65816/disassembler.hpp
+++ b/nSide_v005-source-revised/processor/r65816/disassembler.hpp
@@ -22,8 +22,7 @@ enum : unsigned {
   OPTYPE_RELW,      //relw
 };
 
-void disassemble_opcode(char* output);
-void disassemble_opcode(char* output, uint32 addr, bool e, bool m, bool x);
+void disassemble_opcode(char* output, uint32 addr);
 uint8 dreadb(uint32 addr);
 uint16 dreadw(uint32 addr);
 uint32 dreadl(uint32 addr);
diff --git a/../../../git/Emulator/bsnes/bsnes/processor/spc700/disassembler.cpp b/nSide_v005-source-revised/processor/spc700/disassembler.cpp
index fbbde16..9c95d2e 100644
--- a/../../../git/Emulator/bsnes/bsnes/processor/spc700/disassembler.cpp
+++ b/nSide_v005-source-revised/processor/spc700/disassembler.cpp
@@ -1,4 +1,4 @@
-string SPC700::disassemble_opcode(uint16 addr, bool p) {
+string SPC700::disassemble_opcode(uint16 addr) {
   auto read = [&](uint16 addr) -> uint8 {
     return disassembler_read(addr);
   };
@@ -11,7 +11,7 @@ string SPC700::disassemble_opcode(uint16 addr, bool p) {
   auto a = [&] { return hex<4>((read(addr + 1) << 0) + (read(addr + 2) << 8)); };
   auto b = [&](unsigned n) { return hex<2>(read(addr + 1 + n)); };
   auto r = [&](unsigned r, unsigned n = 0) { return hex<4>(addr + r + (int8)read(addr + 1 + n)); };
-  auto dp = [&](unsigned n) { return hex<3>((p << 8) + read(addr + 1 + n)); };
+  auto dp = [&](unsigned n) { return hex<3>((regs.p.p << 8) + read(addr + 1 + n)); };
   auto ab = [&] {
     unsigned n = (read(addr + 1) << 0) + (read(addr + 2) << 8);
     return string{ hex<4>(n & 0x1fff), ":", hex<1>(n >> 13) };
diff --git a/../../../git/Emulator/bsnes/bsnes/processor/spc700/spc700.hpp b/nSide_v005-source-revised/processor/spc700/spc700.hpp
index 68ee7a8..5ff3a40 100644
--- a/../../../git/Emulator/bsnes/bsnes/processor/spc700/spc700.hpp
+++ b/nSide_v005-source-revised/processor/spc700/spc700.hpp
@@ -19,7 +19,7 @@ struct SPC700 {
   uint8 opcode;
 
   void serialize(serializer&);
-  string disassemble_opcode(uint16 addr, bool p);
+  string disassemble_opcode(uint16 addr);
 
 protected:
   uint8 op_adc(uint8, uint8);
diff --git a/nSide_v005-source-revised/profile/PlayChoice-10.sys/manifest.bml b/nSide_v005-source-revised/profile/PlayChoice-10.sys/manifest.bml
new file mode 100644
index 0000000..7295b84
--- /dev/null
+++ b/nSide_v005-source-revised/profile/PlayChoice-10.sys/manifest.bml
@@ -0,0 +1,3 @@
+system name:PlayChoice-10
+  pc10
+    rom name=bios-dual.rom size=16384
diff --git a/nSide_v005-source-revised/purge.bat b/nSide_v005-source-revised/purge.bat
new file mode 100644
index 0000000..d4c3d60
--- /dev/null
+++ b/nSide_v005-source-revised/purge.bat
@@ -0,0 +1 @@
+@mingw32-make clean
diff --git a/../../../git/Emulator/bsnes/bsnes/ruby/audio/xaudio2.cpp b/nSide_v005-source-revised/ruby/audio/xaudio2.cpp
index 9ee6ef5..19add18 100644
--- a/../../../git/Emulator/bsnes/bsnes/ruby/audio/xaudio2.cpp
+++ b/nSide_v005-source-revised/ruby/audio/xaudio2.cpp
@@ -1,3 +1,8 @@
+/*
+  audio.xaudio2 (2010-08-14)
+  author: OV2
+*/
+
 #include "xaudio2.hpp"
 #include <windows.h>
 
@@ -127,19 +132,7 @@ public:
       return false;
     }
 
-    unsigned deviceCount = 0;
-    pXAudio2->GetDeviceCount(&deviceCount);
-    if(deviceCount == 0) { term(); return false; }
-
-    unsigned deviceID = 0;
-    for(unsigned deviceIndex = 0; deviceIndex < deviceCount; deviceIndex++) {
-      XAUDIO2_DEVICE_DETAILS deviceDetails;
-      memset(&deviceDetails, 0, sizeof(XAUDIO2_DEVICE_DETAILS));
-      pXAudio2->GetDeviceDetails(deviceIndex, &deviceDetails);
-      if(deviceDetails.Role & DefaultGameDevice) deviceID = deviceIndex;
-    }
-
-    if(FAILED(hr = pXAudio2->CreateMasteringVoice(&pMasterVoice, 2, settings.frequency, 0, deviceID, NULL))) {
+    if(FAILED(hr = pXAudio2->CreateMasteringVoice( &pMasterVoice, 2, settings.frequency, 0, 0 , NULL))) {
       return false;
     }
 
@@ -152,7 +145,7 @@ public:
     wfx.nAvgBytesPerSec = wfx.nSamplesPerSec * wfx.nBlockAlign;
     wfx.cbSize = 0;
 
-    if(FAILED(hr = pXAudio2->CreateSourceVoice(&pSourceVoice, (WAVEFORMATEX*)&wfx, XAUDIO2_VOICE_NOSRC, XAUDIO2_DEFAULT_FREQ_RATIO, this, NULL, NULL))) {
+    if(FAILED(hr = pXAudio2->CreateSourceVoice(&pSourceVoice, (WAVEFORMATEX*)&wfx, XAUDIO2_VOICE_NOSRC , XAUDIO2_DEFAULT_FREQ_RATIO, this, NULL, NULL))) {
       return false;
     }
 
diff --git a/../../../git/Emulator/bsnes/bsnes/ruby/implementation.cpp b/nSide_v005-source-revised/ruby/implementation.cpp
index 4bc78a0..f33cb33 100644
--- a/../../../git/Emulator/bsnes/bsnes/ruby/implementation.cpp
+++ b/nSide_v005-source-revised/ruby/implementation.cpp
@@ -1,6 +1,6 @@
 /* Global Headers */
 
-#if defined(PLATFORM_XORG)
+#if defined(PLATFORM_X)
   #include <X11/Xlib.h>
   #include <X11/Xutil.h>
   #include <X11/Xatom.h>
diff --git a/../../../git/Emulator/bsnes/bsnes/ruby/input/carbon.cpp b/nSide_v005-source-revised/ruby/input/carbon.cpp
index 329f4a6..2ca5f55 100644
--- a/../../../git/Emulator/bsnes/bsnes/ruby/input/carbon.cpp
+++ b/nSide_v005-source-revised/ruby/input/carbon.cpp
@@ -35,21 +35,18 @@ struct pInputCarbon {
     group.input[inputID].value = value;
   }
 
-  vector<HID::Device*> poll() {
-    vector<HID::Device*> devices;
-
+  void poll(vector<HID::Device*>& devices) {
     KeyMap keymap;
     GetKeys(keymap);
     uint8_t* buffer = (uint8_t*)keymap;
 
     unsigned inputID = 0;
     for(auto& key : keys) {
-      bool value = buffer[key.id >> 3] & (1 << (key.id & 7));
+      bool value = buffer[key.id >> 3] & (1 << (key.id & 7)));
       assign(kb.hid, HID::Keyboard::GroupID::Button, inputID++, value);
     }
 
     devices.append(&kb.hid);
-    return devices;
   }
 
   bool rumble(uint64_t id, bool enable) {
diff --git a/../../../git/Emulator/bsnes/bsnes/ruby/input/joypad/directinput.cpp b/nSide_v005-source-revised/ruby/input/joypad/directinput.cpp
index 1ffbc55..345045b 100644
--- a/../../../git/Emulator/bsnes/bsnes/ruby/input/joypad/directinput.cpp
+++ b/nSide_v005-source-revised/ruby/input/joypad/directinput.cpp
@@ -107,6 +107,11 @@ struct InputJoypadDirectInput {
     Joypad jp;
     jp.vendorID = instance->guidProduct.Data1 >> 0;
     jp.productID = instance->guidProduct.Data1 >> 16;
+
+    //so the official way to check for XInput devices is to find "IG_" in the GUID/Path.
+    //we can't get that with DirectInput until we open the device handle, and I want to avoid
+    //any potential for conflicts if XInput already has the device open
+    //it won't really matter if we pick the wrong GUID/Path, so long as VID/PID matches here
     jp.isXInputDevice = false;
     if(auto device = rawinput.find(jp.vendorID, jp.productID)) {
       jp.isXInputDevice = device().isXInputDevice;
diff --git a/../../../git/Emulator/bsnes/bsnes/ruby/input.hpp b/nSide_v005-source-revised/ruby/input.hpp
index e36043a..2582ccd 100644
--- a/../../../git/Emulator/bsnes/bsnes/ruby/input.hpp
+++ b/nSide_v005-source-revised/ruby/input.hpp
@@ -14,7 +14,7 @@ struct Input {
   virtual bool acquired() { return false; }
 
   virtual nall::vector<nall::HID::Device*> poll() { return {}; }
-  virtual bool rumble(uint64_t id, bool enable) { return false; }
+  virtual bool rumble(uint64_t id, bool enable) {}
   virtual bool init() { return true; }
   virtual void term() {}
 
diff --git a/../../../git/Emulator/bsnes/bsnes/ruby/video/cgl.cpp b/nSide_v005-source-revised/ruby/video/cgl.cpp
index b1f4fd1..dca80c0 100644
--- a/../../../git/Emulator/bsnes/bsnes/ruby/video/cgl.cpp
+++ b/nSide_v005-source-revised/ruby/video/cgl.cpp
@@ -15,12 +15,13 @@ namespace ruby {
 namespace ruby {
 
 struct pVideoCGL : OpenGL {
-  RubyVideoCGL* view = nullptr;
+  RubyVideoCGL* view;
 
   struct {
-    NSView* handle = nullptr;
-    bool synchronize = false;
-    unsigned filter = 0;
+    NSView* handle;
+
+    bool synchronize;
+    unsigned filter;
     string shader;
   } settings;
 
@@ -156,6 +157,14 @@ struct pVideoCGL : OpenGL {
     }
   }
 
+  pVideoCGL() {
+    view = nil;
+
+    settings.handle = nil;
+    settings.synchronize = false;
+    settings.filter = 0;
+  }
+
   ~pVideoCGL() {
     term();
   }
diff --git a/../../../git/Emulator/bsnes/bsnes/ruby/video/opengl/main.hpp b/nSide_v005-source-revised/ruby/video/opengl/main.hpp
index 829fda6..1213645 100644
--- a/../../../git/Emulator/bsnes/bsnes/ruby/video/opengl/main.hpp
+++ b/nSide_v005-source-revised/ruby/video/opengl/main.hpp
@@ -200,13 +200,11 @@ bool OpenGL::init() {
   glrLinkProgram(program);
 
   shader(nullptr);
-  return initialized = true;
+  return true;
 }
 
 void OpenGL::term() {
-  if(initialized == false) return;
   shader(nullptr);  //release shader resources (eg frame[] history)
   OpenGLSurface::release();
   if(buffer) { delete[] buffer; buffer = nullptr; }
-  initialized = false;
 }
diff --git a/../../../git/Emulator/bsnes/bsnes/ruby/video/opengl/opengl.hpp b/nSide_v005-source-revised/ruby/video/opengl/opengl.hpp
index 0d50f01..4bbc473 100644
--- a/../../../git/Emulator/bsnes/bsnes/ruby/video/opengl/opengl.hpp
+++ b/nSide_v005-source-revised/ruby/video/opengl/opengl.hpp
@@ -1,4 +1,4 @@
-#if defined(PLATFORM_XORG)
+#if defined(PLATFORM_X)
   #include <GL/gl.h>
   #include <GL/glx.h>
   #define glGetProcAddress(name) (*glXGetProcAddress)((const GLubyte*)(name))
@@ -79,7 +79,6 @@ struct OpenGL : OpenGLProgram {
     Setting(const string& name, const string& value) : name(name), value(value) {}
   };
   set<Setting> settings;
-  bool initialized = false;
 
   void shader(const char* pathname);
   void allocateHistory(unsigned size);
diff --git a/../../../git/Emulator/bsnes/bsnes/sfc/alt/ppu-balanced/ppu.cpp b/nSide_v005-source-revised/sfc/alt/ppu-balanced/ppu.cpp
index ad4fd13..da90980 100644
--- a/../../../git/Emulator/bsnes/bsnes/sfc/alt/ppu-balanced/ppu.cpp
+++ b/nSide_v005-source-revised/sfc/alt/ppu-balanced/ppu.cpp
@@ -368,6 +368,36 @@ void PPU::reset() {
   regs.bg_y[3] = 0;
 }
 
+void PPU::exportRegisters(string &markup) {
+  markup.append("ppu\n");
+  // 2105
+  markup.append("  bgmode:       ", regs.bg_mode,      "\n");
+  markup.append("  bg3-priority: ", regs.bg3_priority, "\n");
+  // 2133
+  markup.append("  pseudo-hires: ", regs.pseudo_hires, "\n");
+  markup.append("  overscan:     ", regs.overscan,     "\n");
+  // individual backgrounds
+  unsigned bg;
+  for(unsigned bg_id = 1; bg_id <= 4; bg_id++) {
+    switch(bg_id) {
+      case 1: bg = BG1; break;
+      case 2: bg = BG2; break;
+      case 3: bg = BG3; break;
+      case 4: bg = BG4; break;
+    }
+    markup.append("  bg\n");
+    markup.append("    tile-size:     ",   regs.bg_tilesize[bg],       "\n");
+    markup.append("    mosaic:        ",   regs.mosaic_enabled[bg],    "\n");
+    markup.append("    screen-addr:   0x", hex<4>(regs.bg_scaddr[bg]), "\n");
+    markup.append("    screen-size:   ",   regs.bg_scsize[bg],         "\n");
+    markup.append("    tiledata-addr: 0x", hex<4>(regs.bg_tdaddr[bg]), "\n");
+    markup.append("    hoffset:       0x", hex<4>(regs.bg_hofs[bg]),   "\n");
+    markup.append("    voffset:       0x", hex<4>(regs.bg_vofs[bg]),   "\n");
+    markup.append("    main-enable:   ",   regs.bg_enabled[bg],        "\n");
+    markup.append("    sub-enable:    ",   regs.bgsub_enabled[bg],     "\n");
+  }
+}
+
 void PPU::layer_enable(unsigned layer, unsigned priority, bool enable) {
   switch(layer * 4 + priority) {
   case  0: layer_enabled[BG1][0] = enable; break;
diff --git a/../../../git/Emulator/bsnes/bsnes/sfc/alt/ppu-balanced/ppu.hpp b/nSide_v005-source-revised/sfc/alt/ppu-balanced/ppu.hpp
index 106780f..932c8d5 100644
--- a/../../../git/Emulator/bsnes/bsnes/sfc/alt/ppu-balanced/ppu.hpp
+++ b/nSide_v005-source-revised/sfc/alt/ppu-balanced/ppu.hpp
@@ -62,6 +62,8 @@ struct PPU : Thread, public PPUcounter {
   void power();
   void reset();
 
+  void exportRegisters(string &markup);
+
   bool layer_enabled[5][4];
   void layer_enable(unsigned layer, unsigned priority, bool enable);
   unsigned frameskip;
diff --git a/../../../git/Emulator/bsnes/bsnes/sfc/alt/ppu-performance/ppu.cpp b/nSide_v005-source-revised/sfc/alt/ppu-performance/ppu.cpp
index b598cc7..da38ce7 100644
--- a/../../../git/Emulator/bsnes/bsnes/sfc/alt/ppu-performance/ppu.cpp
+++ b/nSide_v005-source-revised/sfc/alt/ppu-performance/ppu.cpp
@@ -105,6 +105,9 @@ void PPU::reset() {
   display.overscan = false;
 }
 
+void PPU::exportRegisters(string &markup) {
+}
+
 void PPU::layer_enable(unsigned layer, unsigned priority, bool enable) {
   switch(layer * 4 + priority) {
   case  0: bg1.priority0_enable = enable; break;
diff --git a/../../../git/Emulator/bsnes/bsnes/sfc/alt/ppu-performance/ppu.hpp b/nSide_v005-source-revised/sfc/alt/ppu-performance/ppu.hpp
index b3427e2..a3dd1b2 100644
--- a/../../../git/Emulator/bsnes/bsnes/sfc/alt/ppu-performance/ppu.hpp
+++ b/nSide_v005-source-revised/sfc/alt/ppu-performance/ppu.hpp
@@ -12,12 +12,14 @@ struct PPU : Thread, public PPUcounter {
   bool overscan() const;
   bool hires() const;
 
+  void scanline();
+  void frame();
   void enter();
   void enable();
   void power();
   void reset();
-  void scanline();
-  void frame();
+
+  void exportRegisters(string &markup);
 
   void layer_enable(unsigned layer, unsigned priority, bool enable);
   void set_frameskip(unsigned frameskip);
diff --git a/../../../git/Emulator/bsnes/bsnes/sfc/cheat/cheat.cpp b/nSide_v005-source-revised/sfc/cheat/cheat.cpp
index 8eee902..9dcdd54 100644
--- a/../../../git/Emulator/bsnes/bsnes/sfc/cheat/cheat.cpp
+++ b/nSide_v005-source-revised/sfc/cheat/cheat.cpp
@@ -17,16 +17,16 @@ void Cheat::append(unsigned addr, unsigned comp, unsigned data) {
   codes.append({addr, comp, data});
 }
 
-maybe<unsigned> Cheat::find(unsigned addr, unsigned comp) {
+optional<unsigned> Cheat::find(unsigned addr, unsigned comp) {
   //WRAM mirroring: $00-3f,80-bf:0000-1fff -> $7e:0000-1fff
   if((addr & 0x40e000) == 0x000000) addr = 0x7e0000 | (addr & 0x1fff);
 
   for(auto& code : codes) {
     if(code.addr == addr && (code.comp == Unused || code.comp == comp)) {
-      return code.data;
+      return {true, code.data};
     }
   }
-  return nothing;
+  return false;
 }
 
 }
diff --git a/../../../git/Emulator/bsnes/bsnes/sfc/cheat/cheat.hpp b/nSide_v005-source-revised/sfc/cheat/cheat.hpp
index 43f2d05..c1cb490 100644
--- a/../../../git/Emulator/bsnes/bsnes/sfc/cheat/cheat.hpp
+++ b/nSide_v005-source-revised/sfc/cheat/cheat.hpp
@@ -11,7 +11,7 @@ struct Cheat {
   void reset();
   void append(unsigned addr, unsigned data);
   void append(unsigned addr, unsigned comp, unsigned data);
-  maybe<unsigned> find(unsigned addr, unsigned comp);
+  optional<unsigned> find(unsigned addr, unsigned comp);
 };
 
 extern Cheat cheat;
diff --git a/../../../git/Emulator/bsnes/bsnes/sfc/chip/event/event.cpp b/nSide_v005-source-revised/sfc/chip/event/event.cpp
index b727629..3dca4a2 100644
--- a/../../../git/Emulator/bsnes/bsnes/sfc/chip/event/event.cpp
+++ b/nSide_v005-source-revised/sfc/chip/event/event.cpp
@@ -76,7 +76,7 @@ void Event::submitScore() {
     string content = {
       "username:", username, "\n",
       "password:", password, "\n",
-      "emulator:bsnes\n",
+      "emulator:higan-sfc\n",
       "sha256:", interface->sha256(), "\n",
       "\n",
       data
diff --git a/../../../git/Emulator/bsnes/bsnes/sfc/chip/hsu1/hsu1.cpp b/nSide_v005-source-revised/sfc/chip/hsu1/hsu1.cpp
index 5feaebf..586cbcb 100644
--- a/../../../git/Emulator/bsnes/bsnes/sfc/chip/hsu1/hsu1.cpp
+++ b/nSide_v005-source-revised/sfc/chip/hsu1/hsu1.cpp
@@ -68,7 +68,7 @@ void HSU1::write(unsigned addr, uint8 data) {
         string header {
           "username:", username, "\n",
           "password:", password, "\n",
-          "emulator:bsnes\n",
+          "emulator:higan-sfc\n",
           "sha256:", interface->sha256(), "\n",
           "\n"
         };
diff --git a/../../../git/Emulator/bsnes/bsnes/sfc/chip/icd2/icd2.cpp b/nSide_v005-source-revised/sfc/chip/icd2/icd2.cpp
index b16be86..02ba74a 100644
--- a/../../../git/Emulator/bsnes/bsnes/sfc/chip/icd2/icd2.cpp
+++ b/nSide_v005-source-revised/sfc/chip/icd2/icd2.cpp
@@ -52,19 +52,20 @@ void ICD2::power() {
 void ICD2::reset() {
   create(ICD2::Enter, cpu.frequency / 5);
 
+  r6000_ly = 0x00;
+  r6000_row = 0x00;
   r6003 = 0x00;
   r6004 = 0xff;
   r6005 = 0xff;
   r6006 = 0xff;
   r6007 = 0xff;
   for(auto& r : r7000) r = 0x00;
+  r7800 = 0x0000;
   mlt_req = 0;
 
-  for(auto& n : output) n = 0xff;
-  read_bank = 0;
-  read_addr = 0;
-  write_bank = 0;
-  write_addr = 0;
+  for(auto& n : lcd.buffer) n = 0;
+  for(auto& n : lcd.output) n = 0;
+  lcd.row = 0;
 
   packetsize = 0;
   joyp_id = 3;
diff --git a/../../../git/Emulator/bsnes/bsnes/sfc/chip/icd2/icd2.hpp b/nSide_v005-source-revised/sfc/chip/icd2/icd2.hpp
index 433d9d4..377a175 100644
--- a/../../../git/Emulator/bsnes/bsnes/sfc/chip/icd2/icd2.hpp
+++ b/nSide_v005-source-revised/sfc/chip/icd2/icd2.hpp
@@ -16,8 +16,8 @@ struct ICD2 : Emulator::Interface::Bind, GameBoy::Interface::Hook, Coprocessor {
   void serialize(serializer&);
 
 private:
-  Emulator::Interface::Bind* bind = nullptr;
-  GameBoy::Interface::Hook* hook = nullptr;
+  Emulator::Interface::Bind* bind;
+  GameBoy::Interface::Hook* hook;
   #include "interface/interface.hpp"
   #include "mmio/mmio.hpp"
 };
diff --git a/../../../git/Emulator/bsnes/bsnes/sfc/chip/icd2/interface/interface.cpp b/nSide_v005-source-revised/sfc/chip/icd2/interface/interface.cpp
index 187429a..27d7462 100644
--- a/../../../git/Emulator/bsnes/bsnes/sfc/chip/icd2/interface/interface.cpp
+++ b/nSide_v005-source-revised/sfc/chip/icd2/interface/interface.cpp
@@ -1,20 +1,13 @@
 #ifdef ICD2_CPP
 
+//called on rendered lines 0-143 (not on Vblank lines 144-153)
 void ICD2::lcdScanline() {
-  if(GameBoy::ppu.status.ly > 143) return;  //Vblank
   if((GameBoy::ppu.status.ly & 7) == 0) {
-    write_bank = (write_bank + 1) & 3;
-    write_addr = 0;
+    lcd.row = (lcd.row + 1) & 3;
   }
-}
 
-void ICD2::lcdOutput(uint2 color) {
-  unsigned y = write_addr / 160;
-  unsigned x = write_addr % 160;
-  unsigned addr = write_bank * 512 + y * 2 + x / 8 * 16;
-  output[addr + 0] = (output[addr + 0] << 1) | (bool)(color & 1);
-  output[addr + 1] = (output[addr + 1] << 1) | (bool)(color & 2);
-  write_addr = (write_addr + 1) % 1280;
+  unsigned offset = (lcd.row * 160 * 8) + ((GameBoy::ppu.status.ly & 7) * 160);
+  memcpy(lcd.buffer + offset, GameBoy::ppu.screen + GameBoy::ppu.status.ly * 160, 160 * sizeof(uint32));
 }
 
 void ICD2::joypWrite(bool p15, bool p14) {
diff --git a/../../../git/Emulator/bsnes/bsnes/sfc/chip/icd2/interface/interface.hpp b/nSide_v005-source-revised/sfc/chip/icd2/interface/interface.hpp
index 3f2278d..205adff 100644
--- a/../../../git/Emulator/bsnes/bsnes/sfc/chip/icd2/interface/interface.hpp
+++ b/nSide_v005-source-revised/sfc/chip/icd2/interface/interface.hpp
@@ -1,5 +1,4 @@
 void lcdScanline();
-void lcdOutput(uint2 color);
 void joypWrite(bool p15, bool p14);
 
 uint32_t videoColor(unsigned source, uint16_t red, uint16_t green, uint16_t blue);
diff --git a/../../../git/Emulator/bsnes/bsnes/sfc/chip/icd2/mmio/mmio.cpp b/nSide_v005-source-revised/sfc/chip/icd2/mmio/mmio.cpp
index 64f61e1..0847264 100644
--- a/../../../git/Emulator/bsnes/bsnes/sfc/chip/icd2/mmio/mmio.cpp
+++ b/nSide_v005-source-revised/sfc/chip/icd2/mmio/mmio.cpp
@@ -1,12 +1,27 @@
 #ifdef ICD2_CPP
 
+//convert linear pixel data to 2bpp planar tiledata
+void ICD2::render(const uint32* source) {
+  memset(lcd.output, 0x00, 320 * sizeof(uint16));
+
+  for(unsigned y = 0; y < 8; y++) {
+    for(unsigned x = 0; x < 160; x++) {
+      unsigned pixel = *source++;
+      unsigned addr = y * 2 + (x / 8 * 16);
+      lcd.output[addr + 0] |= ((pixel & 1) >> 0) << (7 - (x & 7));
+      lcd.output[addr + 1] |= ((pixel & 2) >> 1) << (7 - (x & 7));
+    }
+  }
+}
+
 uint8 ICD2::read(unsigned addr) {
   addr &= 0xffff;
 
   //LY counter
   if(addr == 0x6000) {
-    unsigned y = min(143u, GameBoy::ppu.status.ly);
-    return (y & ~7) | write_bank;
+    r6000_ly = GameBoy::ppu.status.ly;
+    r6000_row = lcd.row;
+    return r6000_ly;
   }
 
   //command ready port
@@ -32,8 +47,8 @@ uint8 ICD2::read(unsigned addr) {
 
   //VRAM port
   if(addr == 0x7800) {
-    uint8 data = output[read_bank * 512 + read_addr];
-    read_addr = (read_addr + 1) & 511;
+    uint8 data = lcd.output[r7800];
+    r7800 = (r7800 + 1) % 320;
     return data;
   }
 
@@ -45,8 +60,12 @@ void ICD2::write(unsigned addr, uint8 data) {
 
   //VRAM port
   if(addr == 0x6001) {
-    read_bank = data & 3;
-    read_addr = 0;
+    r6001 = data;
+    r7800 = 0;
+
+    unsigned offset = (r6000_row - (4 - (r6001 - (r6000_ly & 3)))) & 3;
+    render(lcd.buffer + offset * 160 * 8);
+
     return;
   }
 
diff --git a/../../../git/Emulator/bsnes/bsnes/sfc/chip/icd2/mmio/mmio.hpp b/nSide_v005-source-revised/sfc/chip/icd2/mmio/mmio.hpp
index f7edbc4..df7ab07 100644
--- a/../../../git/Emulator/bsnes/bsnes/sfc/chip/icd2/mmio/mmio.hpp
+++ b/nSide_v005-source-revised/sfc/chip/icd2/mmio/mmio.hpp
@@ -1,13 +1,19 @@
+void render(const uint32* source);
+
+uint8 r6000_ly;   //SGB BIOS' cache of LY
+uint8 r6000_row;  //SGB BIOS' cache of ROW
+uint8 r6001;      //VRAM conversion
 uint8 r6003;      //control port
 uint8 r6004;      //joypad 1
 uint8 r6005;      //joypad 2
 uint8 r6006;      //joypad 3
 uint8 r6007;      //joypad 4
 uint8 r7000[16];  //JOYP packet data
+unsigned r7800;   //VRAM offset
 uint8 mlt_req;    //number of active joypads
 
-uint8 output[4 * 512];
-unsigned read_bank;
-unsigned read_addr;
-unsigned write_bank;
-unsigned write_addr;
+struct LCD {
+  uint32 buffer[4 * 160 * 8];  //four tile rows of linear video data
+  uint16 output[320];          //one tile row of 2bpp video data
+  unsigned row;                //active ICD2 rendering tile row
+} lcd;
diff --git a/../../../git/Emulator/bsnes/bsnes/sfc/chip/icd2/serialization.cpp b/nSide_v005-source-revised/sfc/chip/icd2/serialization.cpp
index 72dfc13..d0a1649 100644
--- a/../../../git/Emulator/bsnes/bsnes/sfc/chip/icd2/serialization.cpp
+++ b/nSide_v005-source-revised/sfc/chip/icd2/serialization.cpp
@@ -18,19 +18,21 @@ void ICD2::serialize(serializer& s) {
   s.integer(bitdata);
   s.integer(bitoffset);
 
+  s.integer(r6000_ly);
+  s.integer(r6000_row);
+  s.integer(r6001);
   s.integer(r6003);
   s.integer(r6004);
   s.integer(r6005);
   s.integer(r6006);
   s.integer(r6007);
   s.array(r7000);
+  s.integer(r7800);
   s.integer(mlt_req);
 
-  s.array(output);
-  s.integer(read_bank);
-  s.integer(read_addr);
-  s.integer(write_bank);
-  s.integer(write_addr);
+  s.array(lcd.buffer);
+  s.array(lcd.output);
+  s.integer(lcd.row);
 }
 
 #endif
diff --git a/../../../git/Emulator/bsnes/bsnes/sfc/chip/msu1/msu1.cpp b/nSide_v005-source-revised/sfc/chip/msu1/msu1.cpp
index e6fdf86..8e8011d 100644
--- a/../../../git/Emulator/bsnes/bsnes/sfc/chip/msu1/msu1.cpp
+++ b/nSide_v005-source-revised/sfc/chip/msu1/msu1.cpp
@@ -10,6 +10,11 @@ MSU1 msu1;
 void MSU1::Enter() { msu1.enter(); }
 
 void MSU1::enter() {
+  if(boot == true) {
+    boot = false;
+    for(unsigned addr = 0x2000; addr <= 0x2007; addr++) mmio_write(addr, 0x00);
+  }
+
   while(true) {
     if(scheduler.sync == Scheduler::SynchronizeMode::All) {
       scheduler.exit(Scheduler::ExitReason::SynchronizeEvent);
@@ -22,12 +27,12 @@ void MSU1::enter() {
         if(audiofile.end()) {
           if(!mmio.audio_repeat) {
             mmio.audio_play = false;
-            audiofile.seek(mmio.audio_play_offset = 8);
+            audiofile.seek(mmio.audio_offset = 8);
           } else {
-            audiofile.seek(mmio.audio_play_offset = mmio.audio_loop_offset);
+            audiofile.seek(mmio.audio_offset = mmio.audio_loop_offset);
           }
         } else {
-          mmio.audio_play_offset += 4;
+          mmio.audio_offset += 4;
           left  = audiofile.readl(2);
           right = audiofile.readl(2);
         }
@@ -52,6 +57,7 @@ void MSU1::init() {
 }
 
 void MSU1::load() {
+  data_open();
 }
 
 void MSU1::unload() {
@@ -66,24 +72,17 @@ void MSU1::power() {
 
 void MSU1::reset() {
   create(MSU1::Enter, 44100);
-
-  mmio.data_seek_offset = 0;
-  mmio.data_read_offset = 0;
-
-  mmio.audio_play_offset = 0;
-  mmio.audio_loop_offset = 0;
-
-  mmio.audio_track = 0;
-  mmio.audio_volume = 0;
-
-  mmio.data_busy = false;
-  mmio.audio_busy = false;
+  boot = true;
+
+  mmio.data_offset  = 0;
+  mmio.audio_offset = 0;
+  mmio.audio_track  = 0;
+  mmio.audio_volume = 255;
+  mmio.data_busy    = true;
+  mmio.audio_busy   = true;
   mmio.audio_repeat = false;
-  mmio.audio_play = false;
-  mmio.audio_error = false;
-
-  data_open();
-  audio_open();
+  mmio.audio_play   = false;
+  mmio.audio_error  = false;
 }
 
 void MSU1::data_open() {
@@ -92,7 +91,7 @@ void MSU1::data_open() {
   string name = document["cartridge/msu1/rom/name"].data;
   if(name.empty()) name = "msu1.rom";
   if(datafile.open({interface->path(ID::SuperFamicom), name}, file::mode::read)) {
-    datafile.seek(mmio.data_read_offset);
+    datafile.seek(mmio.data_offset);
   }
 }
 
@@ -106,19 +105,8 @@ void MSU1::audio_open() {
     break;
   }
   if(audiofile.open({interface->path(ID::SuperFamicom), name}, file::mode::read)) {
-    if(audiofile.size() >= 8) {
-      uint32 header = audiofile.readm(4);
-      if(header == 0x4d535531) {  //"MSU1"
-        mmio.audio_loop_offset = 8 + audiofile.readl(4) * 4;
-        if(mmio.audio_loop_offset > audiofile.size()) mmio.audio_loop_offset = 8;
-        mmio.audio_error = false;
-        audiofile.seek(mmio.audio_play_offset);
-        return;
-      }
-    }
-    audiofile.close();
+    audiofile.seek(mmio.audio_offset);
   }
-  mmio.audio_error = true;
 }
 
 uint8 MSU1::mmio_read(unsigned addr) {
@@ -135,9 +123,9 @@ uint8 MSU1::mmio_read(unsigned addr) {
          | (Revision          << 0);
   case 0x2001:
     if(mmio.data_busy) return 0x00;
-    if(datafile.end()) return 0x00;
-    mmio.data_read_offset++;
-    return datafile.read();
+    mmio.data_offset++;
+    if(datafile.open()) return datafile.read();
+    return 0x00;
   case 0x2002: return 'S';
   case 0x2003: return '-';
   case 0x2004: return 'M';
@@ -152,22 +140,35 @@ void MSU1::mmio_write(unsigned addr, uint8 data) {
   addr = 0x2000 | (addr & 7);
 
   switch(addr) {
-  case 0x2000: mmio.data_seek_offset = (mmio.data_seek_offset & 0xffffff00) | (data <<  0); break;
-  case 0x2001: mmio.data_seek_offset = (mmio.data_seek_offset & 0xffff00ff) | (data <<  8); break;
-  case 0x2002: mmio.data_seek_offset = (mmio.data_seek_offset & 0xff00ffff) | (data << 16); break;
-  case 0x2003: mmio.data_seek_offset = (mmio.data_seek_offset & 0x00ffffff) | (data << 24);
-    mmio.data_read_offset = mmio.data_seek_offset;
-    data_open();
+  case 0x2000: mmio.data_offset = (mmio.data_offset & 0xffffff00) | (data <<  0); break;
+  case 0x2001: mmio.data_offset = (mmio.data_offset & 0xffff00ff) | (data <<  8); break;
+  case 0x2002: mmio.data_offset = (mmio.data_offset & 0xff00ffff) | (data << 16); break;
+  case 0x2003: mmio.data_offset = (mmio.data_offset & 0x00ffffff) | (data << 24);
+    if(datafile.open()) datafile.seek(mmio.data_offset);
+    mmio.data_busy = false;
     break;
   case 0x2004: mmio.audio_track = (mmio.audio_track & 0xff00) | (data << 0); break;
   case 0x2005: mmio.audio_track = (mmio.audio_track & 0x00ff) | (data << 8);
-    mmio.audio_play_offset = 8;
+    mmio.audio_offset = 0;
     audio_open();
+    if(audiofile.open()) {
+      uint32 header = audiofile.readm(4);
+      if(header != 0x4d535531) {  //verify 'MSU1' header
+        audiofile.close();
+      } else {
+        mmio.audio_loop_offset = 8 + audiofile.readl(4) * 4;
+        mmio.audio_offset = 8;
+      }
+    }
+    mmio.audio_busy   = false;
+    mmio.audio_repeat = false;
+    mmio.audio_play   = false;
+    mmio.audio_error  = !audiofile.open();
+    break;
+  case 0x2006:
+    mmio.audio_volume = data;
     break;
-  case 0x2006: mmio.audio_volume = data; break;
   case 0x2007:
-    if(mmio.audio_busy) break;
-    if(mmio.audio_error) break;
     mmio.audio_repeat = data & 2;
     mmio.audio_play   = data & 1;
     break;
diff --git a/../../../git/Emulator/bsnes/bsnes/sfc/chip/msu1/msu1.hpp b/nSide_v005-source-revised/sfc/chip/msu1/msu1.hpp
index c1b35d4..9cb7d94 100644
--- a/../../../git/Emulator/bsnes/bsnes/sfc/chip/msu1/msu1.hpp
+++ b/nSide_v005-source-revised/sfc/chip/msu1/msu1.hpp
@@ -16,10 +16,11 @@ struct MSU1 : Coprocessor {
   void serialize(serializer&);
 
 private:
+  bool boot;
   file datafile;
   file audiofile;
 
-  enum Flag : unsigned {
+  enum Flag {
     DataBusy       = 0x80,
     AudioBusy      = 0x40,
     AudioRepeating = 0x20,
@@ -29,10 +30,8 @@ private:
   };
 
   struct MMIO {
-    uint32 data_seek_offset;
-    uint32 data_read_offset;
-
-    uint32 audio_play_offset;
+    uint32 data_offset;
+    uint32 audio_offset;
     uint32 audio_loop_offset;
 
     uint16 audio_track;
diff --git a/../../../git/Emulator/bsnes/bsnes/sfc/chip/msu1/serialization.cpp b/nSide_v005-source-revised/sfc/chip/msu1/serialization.cpp
index 3a78702..0de5ce8 100644
--- a/../../../git/Emulator/bsnes/bsnes/sfc/chip/msu1/serialization.cpp
+++ b/nSide_v005-source-revised/sfc/chip/msu1/serialization.cpp
@@ -3,10 +3,10 @@
 void MSU1::serialize(serializer& s) {
   Thread::serialize(s);
 
-  s.integer(mmio.data_seek_offset);
-  s.integer(mmio.data_read_offset);
+  s.integer(boot);
 
-  s.integer(mmio.audio_play_offset);
+  s.integer(mmio.data_offset);
+  s.integer(mmio.audio_offset);
   s.integer(mmio.audio_loop_offset);
 
   s.integer(mmio.audio_track);
diff --git a/../../../git/Emulator/bsnes/bsnes/sfc/chip/sdd1/decomp.cpp b/nSide_v005-source-revised/sfc/chip/sdd1/decomp.cpp
index 72039a7..bfb38f2 100644
--- a/../../../git/Emulator/bsnes/bsnes/sfc/chip/sdd1/decomp.cpp
+++ b/nSide_v005-source-revised/sfc/chip/sdd1/decomp.cpp
@@ -2,9 +2,9 @@
 //original code written by Andreas Naive (public domain license)
 //bsnes port written by byuu
 
-//note: decompression module does not need to be serialized with bsnes
-//this is because decompression only runs during DMA, and bsnes will complete
-//any pending DMA transfers prior to serialization.
+//note: decompression module does not need to be serialized
+//this is because decompression only runs during DMA, and any pending DMA
+//transfers will be completed prior to serialization.
 
 //input manager
 
diff --git a/../../../git/Emulator/bsnes/bsnes/sfc/cpu/cpu.cpp b/nSide_v005-source-revised/sfc/cpu/cpu.cpp
index 4aa60e8..852755d 100644
--- a/../../../git/Emulator/bsnes/bsnes/sfc/cpu/cpu.cpp
+++ b/nSide_v005-source-revised/sfc/cpu/cpu.cpp
@@ -86,6 +86,12 @@ void CPU::enter() {
 
 void CPU::op_step() {
   debugger.op_exec(regs.pc.d);
+  if(interface->tracer.open()) {
+    char text[4096];
+    disassemble_opcode(text, regs.pc.d);
+    interface->tracer.print(text, "\n");
+  }
+
   (this->*opcode_table[op_readpc()])();
 }
 
diff --git a/../../../git/Emulator/bsnes/bsnes/sfc/cpu/cpu.hpp b/nSide_v005-source-revised/sfc/cpu/cpu.hpp
index d4bb26f..ed2c51f 100644
--- a/../../../git/Emulator/bsnes/bsnes/sfc/cpu/cpu.hpp
+++ b/nSide_v005-source-revised/sfc/cpu/cpu.hpp
@@ -136,7 +136,7 @@ privileged:
 
   struct Debugger {
     hook<void (uint24)> op_exec;
-    hook<void (uint24, uint8)> op_read;
+    hook<void (uint24)> op_read;
     hook<void (uint24, uint8)> op_write;
     hook<void ()> op_nmi;
     hook<void ()> op_irq;
diff --git a/../../../git/Emulator/bsnes/bsnes/sfc/cpu/memory/memory.cpp b/nSide_v005-source-revised/sfc/cpu/memory/memory.cpp
index 97aa6bb..f47d320 100644
--- a/../../../git/Emulator/bsnes/bsnes/sfc/cpu/memory/memory.cpp
+++ b/nSide_v005-source-revised/sfc/cpu/memory/memory.cpp
@@ -11,23 +11,25 @@ void CPU::op_io() {
 }
 
 uint8 CPU::op_read(uint32 addr) {
+  debugger.op_read(addr);
+
   status.clock_count = speed(addr);
   dma_edge();
   add_clocks(status.clock_count - 4);
   regs.mdr = bus.read(addr);
   add_clocks(4);
   alu_edge();
-  debugger.op_read(addr, regs.mdr);
   return regs.mdr;
 }
 
 void CPU::op_write(uint32 addr, uint8 data) {
+  debugger.op_write(addr, data);
+
   alu_edge();
   status.clock_count = speed(addr);
   dma_edge();
   add_clocks(status.clock_count);
   bus.write(addr, regs.mdr = data);
-  debugger.op_write(addr, regs.mdr);
 }
 
 unsigned CPU::speed(unsigned addr) const {
diff --git a/../../../git/Emulator/bsnes/bsnes/sfc/interface/interface.cpp b/nSide_v005-source-revised/sfc/interface/interface.cpp
index 66b7c64..f9c6e4b 100644
--- a/../../../git/Emulator/bsnes/bsnes/sfc/interface/interface.cpp
+++ b/nSide_v005-source-revised/sfc/interface/interface.cpp
@@ -270,6 +270,7 @@ void Interface::save(unsigned id, const stream& stream) {
 void Interface::unload() {
   save();
   cartridge.unload();
+  tracerEnable(false);
 }
 
 void Interface::connect(unsigned port, unsigned device) {
@@ -340,6 +341,51 @@ void Interface::paletteUpdate(PaletteMode mode) {
   video.generate_palette(mode);
 }
 
+bool Interface::tracerEnable(bool trace) {
+  string pathname = {path(group(ID::ROM)), "debug/"};
+  if(trace == true) directory::create(pathname);
+
+  if(trace == true && !tracer.open()) {
+    for(unsigned n = 0; n <= 999; n++) {
+      string filename = {pathname, "trace-", format<3, '0'>(n), ".log"};
+      if(file::exists(filename)) continue;
+      tracer.open(filename, file::mode::write);
+      return true;
+    }
+  }
+
+  if(trace == false && tracer.open()) {
+    tracer.close();
+    return true;
+  }
+
+  return false;
+}
+
+void Interface::exportMemory() {
+  string pathname = {path(group(ID::ROM)), "debug/"};
+  directory::create(pathname);
+
+  // Registers
+  string markup = "";
+  ppu.exportRegisters(markup);
+  file::write({pathname, "registers.bml"}, markup);
+
+  file::write({pathname, "work.ram"}, cpu.wram, 128 * 1024);
+  file::write({pathname, "video.ram"}, ppu.vram, 64 * 1024);
+  file::write({pathname, "sprite.ram"}, ppu.oam, 544);
+  file::write({pathname, "palette.ram"}, ppu.cgram, 512);
+  file::write({pathname, "apu.ram"}, smp.apuram, 64 * 1024);
+  if(cartridge.has_sa1())
+    file::write({pathname, "sa1.internal.ram"}, sa1.iram.data(), sa1.iram.size());
+  if(cartridge.has_armdsp())
+    file::write({pathname, "st018.program.ram"}, armdsp.programRAM, sizeof(armdsp.programRAM));
+  if(cartridge.has_hitachidsp())
+    file::write({pathname, "cx4.data.ram"}, hitachidsp.ram.data(), hitachidsp.ram.size());
+  //if(cartridge.has_necdsp())
+  //  file::write({pathname, "dsp.data.ram"}, necdsp.dataRAM, sizeof(necdsp.dataRAM));
+}
+
 Interface::Interface() {
   interface = this;
   system.init();
diff --git a/../../../git/Emulator/bsnes/bsnes/sfc/interface/interface.hpp b/nSide_v005-source-revised/sfc/interface/interface.hpp
index e4f0f6d..8494ef6 100644
--- a/../../../git/Emulator/bsnes/bsnes/sfc/interface/interface.hpp
+++ b/nSide_v005-source-revised/sfc/interface/interface.hpp
@@ -117,8 +117,13 @@ struct Interface : Emulator::Interface {
 
   void paletteUpdate(PaletteMode mode);
 
+  //debugger functions
+  bool tracerEnable(bool);
+  void exportMemory();
+
   Interface();
 
+  file tracer;
   vector<Device> device;
 };
 
diff --git a/../../../git/Emulator/bsnes/bsnes/sfc/memory/memory-inline.hpp b/nSide_v005-source-revised/sfc/memory/memory-inline.hpp
index 067a075..7f2e301 100644
--- a/../../../git/Emulator/bsnes/bsnes/sfc/memory/memory-inline.hpp
+++ b/nSide_v005-source-revised/sfc/memory/memory-inline.hpp
@@ -56,28 +56,31 @@ MappedRAM::MappedRAM() : data_(nullptr), size_(0), write_protect_(false) {}
 //Bus
 
 unsigned Bus::mirror(unsigned addr, unsigned size) {
-  if(size == 0) return 0;
   unsigned base = 0;
-  unsigned mask = 1 << 23;
-  while(addr >= size) {
-    while(!(addr & mask)) mask >>= 1;
-    addr -= mask;
-    if(size > mask) {
-      size -= mask;
-      base += mask;
+  if(size) {
+    unsigned mask = 1 << 23;
+    while(addr >= size) {
+      while(!(addr & mask)) mask >>= 1;
+      addr -= mask;
+      if(size > mask) {
+        size -= mask;
+        base += mask;
+      }
+      mask >>= 1;
     }
-    mask >>= 1;
+    base += addr;
   }
-  return base + addr;
+  return base;
 }
 
 unsigned Bus::reduce(unsigned addr, unsigned mask) {
-  while(mask) {
-    unsigned bits = (mask & -mask) - 1;
-    addr = ((addr >> 1) & ~bits) | (addr & bits);
-    mask = (mask & (mask - 1)) >> 1;
+  unsigned result = 0, length = 0;
+  for(unsigned n = 0; n < 24; n++) {
+    unsigned bit = 1 << n;
+    if(mask & bit) continue;
+    result |= (bool)(addr & bit) << length++;
   }
-  return addr;
+  return result;
 }
 
 uint8 Bus::read(unsigned addr) {
diff --git a/../../../git/Emulator/bsnes/bsnes/sfc/ppu/mmio/mmio.cpp b/nSide_v005-source-revised/sfc/ppu/mmio/mmio.cpp
index e1add8f..0178b86 100644
--- a/../../../git/Emulator/bsnes/bsnes/sfc/ppu/mmio/mmio.cpp
+++ b/nSide_v005-source-revised/sfc/ppu/mmio/mmio.cpp
@@ -31,42 +31,45 @@ uint16 PPU::get_vram_address() {
 }
 
 uint8 PPU::vram_read(unsigned addr) {
-  uint8 data = 0x00;
+  debugger.vram_read(addr);
+
   if(regs.display_disable || vcounter() >= (!regs.overscan ? 225 : 240)) {
-    data = vram[addr];
-    debugger.vram_read(addr, data);
+    return vram[addr];
   }
-  return data;
+  return 0x00;
 }
 
 void PPU::vram_write(unsigned addr, uint8 data) {
+  debugger.vram_write(addr, data);
+
   if(regs.display_disable || vcounter() >= (!regs.overscan ? 225 : 240)) {
     vram[addr] = data;
-    debugger.vram_write(addr, data);
   }
 }
 
 uint8 PPU::oam_read(unsigned addr) {
-  uint8 data = oam[addr];
-  debugger.oam_read(addr, data);
-  return data;
+  debugger.oam_read(addr);
+
+  return oam[addr];
 }
 
 void PPU::oam_write(unsigned addr, uint8 data) {
+  debugger.oam_write(addr, data);
+
   oam[addr] = data;
   sprite.update(addr, data);
-  debugger.oam_write(addr, data);
 }
 
 uint8 PPU::cgram_read(unsigned addr) {
-  uint8 data = cgram[addr];
-  debugger.cgram_read(addr, data);
-  return data;
+  debugger.cgram_read(addr);
+
+  return cgram[addr];
 }
 
 void PPU::cgram_write(unsigned addr, uint8 data) {
-  cgram[addr] = data;
   debugger.cgram_write(addr, data);
+
+  cgram[addr] = data;
 }
 
 void PPU::mmio_update_video_mode() {
diff --git a/../../../git/Emulator/bsnes/bsnes/sfc/ppu/ppu.cpp b/nSide_v005-source-revised/sfc/ppu/ppu.cpp
index 4ed7389..481ed4c 100644
--- a/../../../git/Emulator/bsnes/bsnes/sfc/ppu/ppu.cpp
+++ b/nSide_v005-source-revised/sfc/ppu/ppu.cpp
@@ -109,6 +109,36 @@ void PPU::reset() {
   frame();
 }
 
+void PPU::exportRegisters(string &markup) {
+  markup.append("ppu\n");
+  // 2105
+  markup.append("  bgmode:       ", regs.bgmode,       "\n");
+  markup.append("  bg3-priority: ", regs.bg3_priority, "\n");
+  // 2133
+  markup.append("  pseudo-hires: ", regs.pseudo_hires, "\n");
+  markup.append("  overscan:     ", regs.overscan,     "\n");
+  // individual backgrounds
+  auto bg = &bg1;
+  for(unsigned bg_id = 1; bg_id <= 4; bg_id++) {
+    switch(bg_id) {
+      case 1: bg = &bg1; break;
+      case 2: bg = &bg2; break;
+      case 3: bg = &bg3; break;
+      case 4: bg = &bg4; break;
+    }
+    markup.append("  bg\n");
+    markup.append("    tile-size:     ",   bg->regs.tile_size,             "\n");
+    markup.append("    mosaic:        ",   bg->regs.mosaic,                "\n");
+    markup.append("    screen-addr:   0x", hex<4>(bg->regs.screen_addr),   "\n");
+    markup.append("    screen-size:   ",   bg->regs.screen_size,           "\n");
+    markup.append("    tiledata-addr: 0x", hex<4>(bg->regs.tiledata_addr), "\n");
+    markup.append("    hoffset:       0x", hex<3>(bg->regs.hoffset),       "\n");
+    markup.append("    voffset:       0x", hex<3>(bg->regs.voffset),       "\n");
+    markup.append("    main-enable:   ",   bg->regs.main_enable,           "\n");
+    markup.append("    sub-enable:    ",   bg->regs.sub_enable,            "\n");
+  }
+}
+
 void PPU::scanline() {
   if(vcounter() == 0) {
     frame();
diff --git a/../../../git/Emulator/bsnes/bsnes/sfc/ppu/ppu.hpp b/nSide_v005-source-revised/sfc/ppu/ppu.hpp
index f6cd80b..94c062b 100644
--- a/../../../git/Emulator/bsnes/bsnes/sfc/ppu/ppu.hpp
+++ b/nSide_v005-source-revised/sfc/ppu/ppu.hpp
@@ -17,6 +17,8 @@ struct PPU : Thread, public PPUcounter {
   void power();
   void reset();
 
+  void exportRegisters(string &markup);
+
   void serialize(serializer&);
   PPU();
   ~PPU();
@@ -60,9 +62,9 @@ privileged:
   friend class Video;
 
   struct Debugger {
-    hook<void (uint16, uint8)> vram_read;
-    hook<void (uint16, uint8)> oam_read;
-    hook<void (uint16, uint8)> cgram_read;
+    hook<void (uint16)> vram_read;
+    hook<void (uint16)> oam_read;
+    hook<void (uint16)> cgram_read;
     hook<void (uint16, uint8)> vram_write;
     hook<void (uint16, uint8)> oam_write;
     hook<void (uint16, uint8)> cgram_write;
diff --git a/../../../git/Emulator/bsnes/bsnes/sfc/profile-performance.hpp b/nSide_v005-source-revised/sfc/profile-performance.hpp
index da48b14..4e8a0f2 100644
--- a/../../../git/Emulator/bsnes/bsnes/sfc/profile-performance.hpp
+++ b/nSide_v005-source-revised/sfc/profile-performance.hpp
@@ -1,5 +1,5 @@
 #if defined(DEBUGGER)
-  #error "bsnes: debugger not supported with performance profile."
+  #error "higan-sfc: debugger not supported with performance profile."
 #endif
 
 #include <sfc/alt/cpu/cpu.hpp>
diff --git a/../../../git/Emulator/bsnes/bsnes/sfc/sfc.hpp b/nSide_v005-source-revised/sfc/sfc.hpp
index a9d4b51..cabb0e3 100644
--- a/../../../git/Emulator/bsnes/bsnes/sfc/sfc.hpp
+++ b/nSide_v005-source-revised/sfc/sfc.hpp
@@ -11,16 +11,17 @@
 
 namespace SuperFamicom {
   namespace Info {
-    static const char Name[] = "bsnes";
-    static const unsigned SerializerVersion = 28;
+    static const char Name[] = "higan-sfc";
+    static const unsigned SerializerVersion = 27;
   }
 }
 
 /*
-  bsnes - Super Famicom emulator
+  higan-sfc - Super Famicom emulator
+  based on higan/bsnes by byuu. Balanced/Performance DSP by blargg.
   author: byuu
   license: GPLv3
-  project started: 2004-10-14
+  original project started: 2004-10-14
 */
 
 #include <libco/libco.h>
diff --git a/../../../git/Emulator/bsnes/bsnes/sfc/smp/memory.cpp b/nSide_v005-source-revised/sfc/smp/memory.cpp
index 1ed07ea..5827809 100644
--- a/../../../git/Emulator/bsnes/bsnes/sfc/smp/memory.cpp
+++ b/nSide_v005-source-revised/sfc/smp/memory.cpp
@@ -181,19 +181,21 @@ void SMP::op_io() {
 }
 
 uint8 SMP::op_read(uint16 addr) {
+  debugger.op_read(addr);
+
   add_clocks(12);
-  uint8 data = op_busread(addr);
+  uint8 r = op_busread(addr);
   add_clocks(12);
   cycle_edge();
-  debugger.op_read(addr, data);
-  return data;
+  return r;
 }
 
 void SMP::op_write(uint16 addr, uint8 data) {
+  debugger.op_write(addr, data);
+
   add_clocks(24);
   op_buswrite(addr, data);
   cycle_edge();
-  debugger.op_write(addr, data);
 }
 
 uint8 SMP::disassembler_read(uint16 addr) {
diff --git a/../../../git/Emulator/bsnes/bsnes/sfc/smp/smp.hpp b/nSide_v005-source-revised/sfc/smp/smp.hpp
index 1583971..f1299cd 100644
--- a/../../../git/Emulator/bsnes/bsnes/sfc/smp/smp.hpp
+++ b/nSide_v005-source-revised/sfc/smp/smp.hpp
@@ -50,7 +50,7 @@ privileged:
 
   struct Debugger {
     hook<void (uint16)> op_exec;
-    hook<void (uint16, uint8)> op_read;
+    hook<void (uint16)> op_read;
     hook<void (uint16, uint8)> op_write;
   } debugger;
 
diff --git a/../../../git/Emulator/bsnes/bsnes/sfc/system/audio.cpp b/nSide_v005-source-revised/sfc/system/audio.cpp
index fb5ade7..3734d3f 100644
--- a/../../../git/Emulator/bsnes/bsnes/sfc/system/audio.cpp
+++ b/nSide_v005-source-revised/sfc/system/audio.cpp
@@ -60,8 +60,8 @@ void Audio::flush() {
     signed cop_right = (int16)(cop_sample >> 16);
 
     interface->audioSample(
-      sclamp<16>(dsp_left  + cop_left ),
-      sclamp<16>(dsp_right + cop_right)
+      sclamp<16>((dsp_left  + cop_left ) / 2),
+      sclamp<16>((dsp_right + cop_right) / 2)
     );
   }
 }
diff --git a/../../../git/Emulator/bsnes/bsnes/target-higan/Makefile b/nSide_v005-source-revised/target-higan/Makefile
index 6e726ce..7457aa0 100644
--- a/../../../git/Emulator/bsnes/bsnes/target-higan/Makefile
+++ b/nSide_v005-source-revised/target-higan/Makefile
@@ -25,11 +25,11 @@ else ifeq ($(platform),macosx)
 else ifeq ($(platform),linux)
   ruby := video.glx video.xv video.xshm video.sdl
   ruby += audio.alsa audio.openal audio.oss audio.pulseaudio audio.pulseaudiosimple audio.ao
-  ruby += input.udev input.sdl input.xlib
+  ruby += input.udev input.sdl input.x
 else ifeq ($(platform),bsd)
   ruby := video.glx
   ruby += audio.openal audio.oss
-  ruby += input.xlib
+  ruby += input.x
 endif
 
 # phoenix
@@ -54,10 +54,10 @@ obj/ui-general.o: $(ui)/general/general.cpp $(call rwildcard,$(ui)/)
 obj/ui-settings.o: $(ui)/settings/settings.cpp $(call rwildcard,$(ui)/)
 obj/ui-tools.o: $(ui)/tools/tools.cpp $(call rwildcard,$(ui)/)
 
-obj/ruby.o: ruby/ruby.cpp $(call rwildcard,ruby/)
+obj/ruby.o: ruby/ruby.cpp $(call rwildcard,ruby/*)
 	$(compiler) $(rubyflags) -c $< -o $@
 
-obj/phoenix.o: phoenix/phoenix.cpp $(call rwildcard,phoenix/)
+obj/phoenix.o: phoenix/phoenix.cpp $(call rwildcard,phoenix/*)
 	$(compiler) $(phoenixflags) -c $< -o $@
 
 obj/resource.o: $(ui)/resource.rc
@@ -89,29 +89,26 @@ resource:
 	sourcery $(ui)/resource/resource.bml $(ui)/resource/resource.cpp $(ui)/resource/resource.hpp
 
 install:
-ifneq ($(shell id -un),root)
-	$(error "make install must be run as root")
-else ifeq ($(platform),windows)
+ifeq ($(platform),windows)
 else ifeq ($(platform),macosx)
-	mkdir -p /Library/Application\ Support/$(name)
-	cp -R profile/* /Library/Application\ Support/$(name)
-	cp data/cheats.bml /Library/Application\ Support/$(name)/cheats.bml
-	chmod -R 777 /Library/Application\ Support/$(name)
+	sudo mkdir -p /Library/Application\ Support/$(name)
+	sudo cp -R profile/* /Library/Application\ Support/$(name)
+	sudo cp data/cheats.bml /Library/Application\ Support/$(name)/cheats.bml
+	sudo chmod -R 777 /Library/Application\ Support/$(name)
 else
-	cp out/$(name) $(prefix)/bin/$(name)
-	cp data/$(name).png $(prefix)/share/pixmaps/$(name).png
-	cp data/$(name).desktop $(prefix)/share/applications/$(name).desktop
-	mkdir -p /usr/share/$(name)
-	cp -R profile/* /usr/share/$(name)
-	cp data/cheats.bml /usr/share/$(name)/cheats.bml
-	chmod -R 777 /usr/share/$(name)
+	sudo install -D -m 755 out/$(name) $(DESTDIR)$(prefix)/bin/$(name)
+	sudo install -D -m 644 data/$(name).png $(DESTDIR)$(prefix)/share/pixmaps/$(name).png
+	sudo install -D -m 644 data/$(name).desktop $(DESTDIR)$(prefix)/share/applications/$(name).desktop
+
+	sudo mkdir -p /usr/share/$(name)
+	sudo cp -R profile/* /usr/share/$(name)
+	sudo cp data/cheats.bml /usr/share/$(name)/cheats.bml
+	sudo chmod -R 777 /usr/share/$(name)
 endif
 
 uninstall:
-ifneq ($(shell id -un),root)
-	$(error "make uninstall must be run as root")
-else ifeq ($(platform),windows)
+ifeq ($(platform),windows)
 else ifeq ($(platform),macosx)
 else
-	rm $(prefix)/bin/$(name)
+	sudo rm $(DESTDIR)$(prefix)/bin/$(name)
 endif
diff --git a/../../../git/Emulator/bsnes/bsnes/target-higan/general/library.cpp b/nSide_v005-source-revised/target-higan/general/library.cpp
index 3ce6723..72c3ea9 100644
--- a/../../../git/Emulator/bsnes/bsnes/target-higan/general/library.cpp
+++ b/nSide_v005-source-revised/target-higan/general/library.cpp
@@ -84,7 +84,7 @@ void LibraryBrowser::setMode() {
 LibraryImport::LibraryImport() {
   setMargin(5);
   information.setText({
-    "higan manages games in a library. To play a game, you must first import the game.\n"
+    "higan, like higan, manages games in a library. To play a game, you must first import the game.\n"
     "After doing so, the game will appear inside your library, and can then be loaded and played."
   });
   importButton.setText("Import Game ...");
@@ -96,7 +96,10 @@ LibraryImport::LibraryImport() {
 
 void LibraryImport::onImportActivate() {
   if(program->ananke.open() == false) {
-    MessageWindow().setText("ananke must be installed to use this feature").warning();
+    MessageWindow().setText({
+      "ananke must be installed to use this feature.\n",
+      "ananke will not work."
+    }).warning();
     return;
   }
   function<string ()> browse = program->ananke.sym("ananke_browse");
@@ -167,7 +170,7 @@ LibraryManager::LibraryManager() {
   libraryFrame.onChange = {&LibraryManager::onChange, this};
   loadButton.onActivate = {&LibraryManager::onLoad, this};
 
-  //initial config value of -1 defaults to import tab on first launch of higan
+  //initial config value of -1 defaults to import tab on first launch
   if(config->library.selection < 0) config->library.selection = browsers.size();
   libraryFrame.setSelection(config->library.selection);
 
diff --git a/../../../git/Emulator/bsnes/bsnes/target-higan/higan.cpp b/nSide_v005-source-revised/target-higan/higan.cpp
index 0d8fce7..157e79e 100644
--- a/../../../git/Emulator/bsnes/bsnes/target-higan/higan.cpp
+++ b/nSide_v005-source-revised/target-higan/higan.cpp
@@ -45,7 +45,7 @@ Program::Program(int argc, char** argv) {
   pause = false;
   autopause = false;
 
-  basepath = nall::programpath();
+  basepath = dir(realpath(argv[0]));
   userpath = {nall::configpath(), "higan/"};
   sharedpath = {nall::sharedpath(), "higan/"};
   directory::create(userpath);
@@ -142,10 +142,12 @@ int main(int argc, char** argv) {
     .setTitle({"About ", Emulator::Name})
     .setText({
       Emulator::Name, " v", Emulator::Version, "\n",
-      Emulator::Profile, " Profile\n",
-      "Author: ", Emulator::Author, "\n",
+      "Based on ", Emulator::OriginalName, " v", Emulator::FromVersion, "\n",
+      "higan-sfc Profile: ", Emulator::Profile, "\n",
+      "Original Author: ", Emulator::Author, "\n",
+      "Contributors: ", Emulator::Contributors, "\n",
       "License: ", Emulator::License, "\n",
-      "Website: ", Emulator::Website
+      "Website of ", Emulator::OriginalName, ": ", Emulator::Website
     })
     .information();
   };
diff --git a/../../../git/Emulator/bsnes/bsnes/target-higan/input/hotkeys.cpp b/nSide_v005-source-revised/target-higan/input/hotkeys.cpp
index 0df7255..d73ab27 100644
--- a/../../../git/Emulator/bsnes/bsnes/target-higan/input/hotkeys.cpp
+++ b/nSide_v005-source-revised/target-higan/input/hotkeys.cpp
@@ -129,6 +129,28 @@ void InputManager::appendHotkeys() {
     };
   }
 
+  {
+    auto hotkey = new HotkeyInput;
+    hotkey->name    = "Toggle Tracer";
+    hotkey->mapping = "None";
+
+    hotkey->press = [&] {
+      utility->tracerToggle();
+    };
+  }
+
+  {
+    auto hotkey = new HotkeyInput;
+    hotkey->name    = "Export Memory";
+    hotkey->mapping = "None";
+
+    hotkey->press = [&] {
+      if(program->active == nullptr) return;
+      system().exportMemory();
+      utility->showMessage("Memory exported");
+    };
+  }
+
   Configuration::Node node;
   for(auto& hotkey : hotkeyMap) {
     node.append(hotkey->mapping, string{hotkey->name}.replace(" ", ""));
diff --git a/../../../git/Emulator/bsnes/bsnes/target-higan/settings/advanced.cpp b/nSide_v005-source-revised/target-higan/settings/advanced.cpp
index 508c11a..feb46ef 100644
--- a/../../../git/Emulator/bsnes/bsnes/target-higan/settings/advanced.cpp
+++ b/nSide_v005-source-revised/target-higan/settings/advanced.cpp
@@ -18,10 +18,12 @@ AdvancedSettings::AdvancedSettings() {
   infoLabel.setFont(program->boldFont);
   infoLabel.setText({
     Emulator::Name, " v", Emulator::Version, "\n",
-    "  ", Emulator::Profile, " Profile\n",
-    "  Author: ", Emulator::Author, "\n",
+    "Based on ", Emulator::OriginalName, " v", Emulator::FromVersion, "\n",
+    "  higan-sfc Profile: ", Emulator::Profile, "\n",
+    "  Original Author: ", Emulator::Author, "\n",
+    "  Contributors: ", Emulator::Contributors, "\n",
     "  License: ", Emulator::License, "\n",
-    "  Website: ", Emulator::Website
+    "  Website of ", Emulator::OriginalName, ": ", Emulator::Website
   });
 
   lstring list;
diff --git a/../../../git/Emulator/bsnes/bsnes/target-higan/tools/state-manager.cpp b/nSide_v005-source-revised/target-higan/tools/state-manager.cpp
index fde3cb9..8ce38a8 100644
--- a/../../../git/Emulator/bsnes/bsnes/target-higan/tools/state-manager.cpp
+++ b/nSide_v005-source-revised/target-higan/tools/state-manager.cpp
@@ -109,8 +109,6 @@ bool StateManager::save(string filename, unsigned revision) {
       fp.write(slot.data(), slot.capacity());
     }
   }
-
-  return true;
 }
 
 void StateManager::slotLoad() {
diff --git a/../../../git/Emulator/bsnes/bsnes/target-higan/utility/utility.cpp b/nSide_v005-source-revised/target-higan/utility/utility.cpp
index 2645092..460cf81 100644
--- a/../../../git/Emulator/bsnes/bsnes/target-higan/utility/utility.cpp
+++ b/nSide_v005-source-revised/target-higan/utility/utility.cpp
@@ -101,6 +101,7 @@ void Utility::load() {
 
 void Utility::unload() {
   if(program->active == nullptr) return;
+  if(tracerEnable) tracerToggle();
 
   cheatEditor->save({pathname[0], "cheats.bml"});
   stateManager->save({pathname[0], "higan/states.bsa"}, 1);
@@ -138,6 +139,16 @@ void Utility::loadState(unsigned slot) {
   showMessage({"Loaded from slot ", slot});
 }
 
+void Utility::tracerToggle() {
+  if(program->active == nullptr) return;
+  tracerEnable = !tracerEnable;
+  bool result = system().tracerEnable(tracerEnable);
+  if( tracerEnable &&  result) return utility->showMessage("Tracer activated");
+  if( tracerEnable && !result) return tracerEnable = false, utility->showMessage("Unable to activate tracer");
+  if(!tracerEnable &&  result) return utility->showMessage("Tracer deactivated");
+  if(!tracerEnable && !result) return utility->showMessage("Unable to deactivate tracer");
+}
+
 void Utility::synchronizeDSP() {
   if(program->active == nullptr) return;
 
@@ -312,3 +323,8 @@ string Utility::libraryPath() {
   if(path.endsWith("/") == false) path.append("/");
   return path;
 }
+
+Utility::Utility() {
+  tracerEnable = false;
+  statusTime = 0;
+}
diff --git a/../../../git/Emulator/bsnes/bsnes/target-higan/utility/utility.hpp b/nSide_v005-source-revised/target-higan/utility/utility.hpp
index 5b3fb92..8249080 100644
--- a/../../../git/Emulator/bsnes/bsnes/target-higan/utility/utility.hpp
+++ b/nSide_v005-source-revised/target-higan/utility/utility.hpp
@@ -17,6 +17,8 @@ struct Utility {
   void saveState(unsigned slot);
   void loadState(unsigned slot);
 
+  void tracerToggle();
+
   void synchronizeDSP();
   void synchronizeRuby();
   void updatePalette();
@@ -30,13 +32,16 @@ struct Utility {
 
   string libraryPath();
 
+  Utility();
+
   lstring path;
   lstring pathname;
 
 private:
+  bool tracerEnable;
   string statusText;
   string statusMessage;
-  time_t statusTime = 0;
+  time_t statusTime;
 };
 
 extern Utility* utility;

