diff --git a/.gitignore b/.gitignore
index 1a53358..3fbc1b5 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1 +1,2 @@
 ananke/libananke.so
+*.orig
diff --git a/Makefile b/Makefile
index c524133..a275f5c 100644
--- a/Makefile
+++ b/Makefile
@@ -5,9 +5,13 @@ sfc := sfc
 gb  := gb
 gba := gba
 
-profile := accuracy
-target := higan
-# target := loki
+ifndef profile
+  profile := accuracy
+endif
+
+ifndef target
+  target := higan
+endif
 
 ifeq ($(target),loki)
   options += debugger
@@ -29,7 +33,8 @@ ifeq ($(pgo),instrument)
   flags += -fprofile-generate
   link += -lgcov
 else ifeq ($(pgo),optimize)
-  flags += -fprofile-use
+  flags += -fprofile-use -fprofile-correction
+  link += -lgcov
 endif
 
 # platform
diff --git a/ananke/Makefile b/ananke/Makefile
index 7eb377b..8c2ba0c 100644
--- a/ananke/Makefile
+++ b/ananke/Makefile
@@ -1,7 +1,14 @@
 include ../nall/Makefile
 include ../phoenix/Makefile
 
-path := /usr/local/lib
+ifndef DESTDIR
+  DESTDIR := /
+endif
+
+ifndef prefix
+  prefix := /usr/local/lib
+endif
+
 flags := $(flags) -O3 -fomit-frame-pointer -I..
 
 all:
@@ -27,23 +34,25 @@ clean:
 install: uninstall
 ifeq ($(platform),windows)
 else ifeq ($(platform),macosx)
-	if [ ! -d ~/Library/Application\ Support/ananke ]; then mkdir ~/Library/Application\ Support/ananke; fi
-	sudo cp libananke.dylib $(path)/libananke.1.dylib
-	sudo ln -s $(path)/libananke.1.dylib $(path)/libananke.dylib
+	#if [ ! -d ~/Library/Application\ Support/ananke ]; then install -d ~/Library/Application\ Support/ananke; fi
+	install -d $(DESTDIR)$(path)
+	cp libananke.dylib $(DESTDIR)$(prefix)/libananke.1.dylib
+	ln -s $(path)/libananke.1.dylib $(DESTDIR)$(prefix)/libananke.dylib
 else
-	if [ ! -d ~/.config/ananke ]; then mkdir ~/.config/ananke; fi
-	sudo cp libananke.so $(path)/libananke.so.1
-	sudo ln -s $(path)/libananke.so.1 $(path)/libananke.so
+	#if [ ! -d ~/.config/ananke ]; then install -d ~/.config/ananke; fi
+	install -d $(DESTDIR)$(prefix)
+	cp libananke.so $(DESTDIR)$(prefix)/libananke.so.1
+	ln -s $(DESTDIR)$(path)/libananke.so.1 $(DESTDIR)$(prefix)/libananke.so
 endif
 
 uninstall:
 ifeq ($(platform),windows)
 else ifeq ($(platform),macosx)
-	if [ -f $(path)/libananke.dylib ]; then sudo rm $(path)/libananke.dylib; fi
-	if [ -f $(path)/libananke.1.dylib ]; then sudo rm $(path)/libananke.1.dylib; fi
+	if [ -f $(DESTDIR)$(path)/libananke.dylib ]; then rm $(DESTDIR)$(prefix)/libananke.dylib; fi
+	if [ -f $(DESTDIR)$(path)/libananke.1.dylib ]; then rm $(DESTDIR)$(prefix)/libananke.1.dylib; fi
 else
-	if [ -f $(path)/libananke.so ]; then sudo rm $(path)/libananke.so; fi
-	if [ -f $(path)/libananke.so.1 ]; then sudo rm $(path)/libananke.so.1; fi
+	if [ -f $(DESTDIR)$(path)/libananke.so ]; then rm $(DESTDIR)$(prefix)/libananke.so; fi
+	if [ -f $(DESTDIR)$(path)/libananke.so.1 ]; then rm $(DESTDIR)$(prefix)/libananke.so.1; fi
 endif
 
 force:
diff --git a/ananke/ananke.cpp b/ananke/ananke.cpp
index 51be602..9060c30 100644
--- a/ananke/ananke.cpp
+++ b/ananke/ananke.cpp
@@ -10,6 +10,7 @@ using namespace nall;
 using namespace phoenix;
 
 namespace Database {
+  #include "database/famicom.hpp"
   #include "database/super-famicom.hpp"
   #include "database/sufami-turbo.hpp"
   #include "database/bsx-satellaview.hpp"
@@ -37,6 +38,7 @@ struct Ananke {
 
   //famicom.cpp
   void copyFamicomSaves(const string &pathname);
+  string createFamicomDatabase(vector<uint8_t> &buffer, Markup::Node &document, const string &manifest);
   string createFamicomHeuristic(vector<uint8_t> &buffer);
   string openFamicom(vector<uint8_t> &buffer);
   string syncFamicom(const string &pathname);
diff --git a/ananke/database/famicom.hpp b/ananke/database/famicom.hpp
new file mode 100644
index 0000000..79a4746
--- /dev/null
+++ b/ananke/database/famicom.hpp
@@ -0,0 +1,1113 @@
+string Famicom = R"(
+
+database revision=2012-10-22
+
+release
+  cartridge region=NTSC
+    board type=HVC-TLSROM
+    chip type=MMC3B
+    prg
+      rom name=program.rom size=0x40000
+    chr
+      rom name=character.rom size=0x20000
+  information
+    title:    アルマジロ
+    name:     Armadillo
+    region:   JP
+    revision: 1.0
+    board:    HVC-TLSROM-01
+    serial:   IGS-9T
+    sha256:   54526dc9444c0eb4b0e5814f98b5e522bcb9881a6f2c0644fc7a21ca8c03502b
+    configuration
+      rom name=program.rom size=0x40000
+      rom name=character.rom size=0x20000
+
+release
+  cartridge region=NTSC
+    board type=NAMCOT-3401
+    mirror mode=horizontal
+    prg
+      rom name=program.rom size=0x8000
+    chr
+      rom name=character.rom size=0x8000
+  information
+    title:    バベルの塔
+    name:     Babel no Tou
+    region:   JP
+    revision: 1.0
+    board:    3401
+    serial:   NAM-NBL-3900-16
+    sha256:   a9d7e89bd4ea28cfd169e32c4516ef5d059e19afb9dfa4ede8412f2373dfb0a7
+    configuration
+      rom name=program.rom size=0x8000
+      rom name=character.rom size=0x8000
+
+release
+  cartridge region=NTSC
+    board type=HVC-CNROM
+      security pass=0x3
+    mirror mode=horizontal
+    prg
+      rom name=program.rom size=0x8000
+    chr
+      rom name=character.rom size=0x2000
+  information
+    title:    B-ワイング
+    name:     B-Wings
+    region:   JP
+    revision: 1.0
+    board:    HVC-CNROM-256K-01
+    serial:   DFC-BW
+    sha256:   2b4ac20082e2f45a8f8fd4922a0e995829719a523e118a9eec891c3206adf25b
+    configuration
+      rom name=program.rom size=0x8000
+      rom name=character.rom size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=HVC-CNROM
+      security pass=0x3
+    mirror mode=vertical
+    prg
+      rom name=program.rom size=0x4000
+    chr
+      rom name=character.rom size=0x2000
+  information
+    title:    バード・ウィーク
+    name:     Bird Week
+    region:   JP
+    revision: 1.0
+    board:    HVC-CNROM-256K-01
+    serial:   TFS-BK
+    sha256:   acf054b0886a2ca74a0280fc36bc1d55e9845acc29759f1893c1da4c1389f9c2
+    configuration
+      rom name=program.rom size=0x4000
+      rom name=character.rom size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=KONAMI-VRC-2
+    chip type=VRC2
+      pinout a0=0 a1=1
+    prg
+      rom name=program.rom size=0x20000
+    chr
+      rom name=character.rom size=0x20000
+  information
+    title:    コントラ 魂斗羅
+    name:     Contra
+    region:   JP
+    revision: 1.0
+    board:    LROG009-00
+    serial:   KON-RC826
+    sha256:   62c9d4e0578cb1e615ce9bb2c8ebc15b1e8de4c928c5c07ba9a85c11aa36ae4d
+    configuration
+      rom name=program.rom size=0x20000
+      rom name=character.rom size=0x20000
+
+release
+  cartridge region=NTSC
+    board type=HVC-UNROM
+    chip type=74HC08
+    mirror mode=horizontal
+    prg
+      rom name=program.rom size=0x20000
+    chr
+      ram size=0x2000
+  information
+    title:    クレイジークライマー
+    name:     Crazy Climber
+    region:   JP
+    revision: 1.0
+    board:    HVC-UNROM-02
+    serial:   NBF-CY (04)
+    sha256:   e24d3c754dce20e27046afeacb2dfc217950d4be766ded80c20283392cb3891e
+    configuration
+      rom name=program.rom size=0x20000
+      ram name=character.ram size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=NAMCOT-3453
+    chip type=118
+    prg
+      rom name=program.rom size=0x20000
+    chr
+      rom name=character.rom size=0x20000
+  information
+    title:    デビルマン
+    name:     Devil Man
+    region:   JP
+    revision: 1.0
+    board:    UNK-NAMCOT-DM
+    serial:   NAM-DM-5500
+    sha256:   d2140fc2e6354a9f4d0154dabac757e5559890edba4885799c1c979d8b7a8b20
+    configuration
+      rom name=program.rom size=0x20000
+      rom name=character.rom size=0x20000
+
+release
+  cartridge region=NTSC
+    board type=HVC-HROM
+    prg
+      rom name=program.rom size=0x4000
+    chr
+      rom name=character.rom size=0x2000
+  information
+    title:    ドンキーコングJr
+    name:     Donkey Kong Jr.
+    region:   JP
+    revision: 1.0
+    board:    HVC-HROM-01
+    serial:   HVC-JR
+    sha256:   950ebe68e7f74219b9e5e104200b03165d59c24264f02e32c12be967fd311ac2
+    configuration
+      rom name=program.rom size=0x4000
+      rom name=character.rom size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=HVC-RROM
+    mirror mode=vertical
+    prg
+      rom name=program.rom size=0x4000
+    chr
+      rom name=character.rom size=0x2000
+  information
+    title:    ダックハント
+    name:     Duck Hunt
+    region:   JP
+    revision: 1.0
+    board:    HVC-RROM-05
+    serial:   HVC-DH
+    sha256:   7026334a7e8742b61b450f4b3b182922c6a69fc723d7cd19c83db365f15e45ba
+    configuration
+      rom name=program.rom size=0x4000
+      rom name=character.rom size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=FDS
+    prg
+      rom name=program.rom size=0x2000
+      ram size=0x8000
+    chr
+      ram size=0x2000
+  information
+    title:    Famicom Disk System
+    name:     Famicom Disk System
+    region:   JP
+    revision: 1.0
+    board:    Famicom Disk System
+    serial:   N/A
+    sha256:   99c18490ed9002d9c6d999b9d8d15be5c051bdfa7cc7e73318053c9a994b0178
+    configuration
+      rom name=program.rom size=0x2000
+      ram name=work.ram size=0x8000
+      ram name=character.ram size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=BANDAI-JUMP2
+    chip type=LZ93D50
+    prg
+      rom name=program.rom size=0x80000
+      ram name=save.ram size=0x2000
+    chr
+      ram size=0x2000
+  information
+    title:    ファミコンジャンプII 最強の7人
+    name:     Famicom Jump II - Saikyou no 7 Nin
+    region:   JP
+    revision: 1.0
+    board:    BA-JUMP2
+    serial:   BA-FJ2
+    sha256:   dd031b72924e1d080f8758412c73224a274ae5e5a50d90310d578975df74101f
+    configuration
+      rom name=program.rom size=0x80000
+      ram name=save.ram size=0x2000
+      ram name=character.ram size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=NAMCOT-3301
+    mirror mode=horizontal
+    prg
+      rom name=program.rom size=0x4000
+    chr
+      rom name=character.rom size=0x2000
+  information
+    title:    ギャラガ
+    name:     Galaga
+    region:   JP
+    revision: 1.0
+    board:    3301
+    serial:   NAM-NGG-4500-05
+    sha256:   e6fe68b9f12578e74ba016ca146aaf8232b20475fb675c7d32e0ea4e47eb1cc8
+    configuration
+      rom name=program.rom size=0x4000
+      rom name=character.rom size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=NAMCOT-3301
+    mirror mode=horizontal
+    prg
+      rom name=program.rom size=0x2000
+    chr
+      rom name=character.rom size=0x2000
+  information
+    title:    ギャラクシアン
+    name:     Galaxian
+    region:   JP
+    revision: 1.0
+    board:    3301
+    serial:   NAM-NGX-4500-01
+    sha256:   50178a2856f8ed3574b4e7fd45b9d1ec44c660d51fe9783d0012a19df5892cce
+    configuration
+      rom name=program.rom size=0x2000
+      rom name=character.rom size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=SUNSOFT-5B
+    chip type=Sunsoft-5B
+    prg
+      rom name=program.rom size=0x40000
+    chr
+      rom name=character.rom size=0x20000
+  information
+    title:    ギミック!
+    name:     Gimmick!
+    region:   JP
+    revision: 1.0
+    board:    FC-GMK
+    serial:   SUN-GMK-6200
+    sha256:   1bbe4b3e20a004a4f741018e31e6ae291772b8876d6fb6f01494c9c5b0917c6c
+    configuration
+      rom name=program.rom size=0x40000
+      rom name=character.rom size=0x20000
+
+release
+  cartridge region=NTSC
+    board type=HVC-SROM
+    mirror mode=vertical
+    prg
+      rom name=program.rom size=0x4000
+    chr
+      rom name=character.rom size=0x2000
+  information
+    title:    ホーガンズアレイ
+    name:     Hogan's Alley
+    region:   JP
+    revision: 1.0
+    board:    HVC-SROM-03
+    serial:   HVC-HA
+    sha256:   8e4a04076b6a728a7e65a09737776dcb9defed7922bf0437d9a89bbe8c724b55
+    configuration
+      rom name=program.rom size=0x4000
+      rom name=character.rom size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=HVC-TLROM
+    chip type=MMC3C
+    prg
+      rom name=program.rom size=0x20000
+    chr
+      rom name=character.rom size=0x20000
+  information
+    title:    熱血格闘伝説
+    name:     Nekketsu Kakutou Densetsu
+    region:   JP
+    revision: 1.0
+    board:    HVC-TLROM-04
+    serial:   TJC-NA
+    sha256:   3c419e3ecf328c03364afbcf5bd15bf0029a525db9e8f74379ae1cce4062b3c3
+    configuration
+      rom name=program.rom size=0x20000
+      rom name=character.rom size=0x20000
+
+release
+  cartridge region=NTSC
+    board type=NAMCOT-3416
+    chip type=118
+    mirror mode=vertical
+    prg
+      rom name=program.rom size=0x20000
+    chr
+      rom name=character.rom size=0x10000
+  information
+    title:    カイの冒険: The Quest of Ki
+    name:     Quest of Ki, The
+    region:   JP
+    revision: 1.0
+    serial:   NAM-QK-3900
+    sha256:   67123fe28cf5fbadeafc77400a0812f0135ab36706ec7d1267f84931d044e71d
+    configuration
+      rom name=program.rom size=0x20000
+      rom name=character.rom size=0x10000
+
+release
+  cartridge region=NTSC
+    board type=HVC-CNROM
+      security pass=0x1
+    mirror mode=vertical
+    prg
+      rom name=program.rom size=0x8000
+    chr
+      rom name=character.rom size=0x2000
+  information
+    title:    スパイVSスパイ
+    name:     Spy vs. Spy
+    region:   JP
+    revision: 1.0
+    board:    HVC-CNROM-256K-01
+    serial:   KSC-SP
+    sha256:   a9cf92ec1a080faa195d0b3dcb48fbb5ee3362f0f2f14e14e4257def48ac4346
+    configuration
+      rom name=program.rom size=0x8000
+      rom name=character.rom size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=HVC-NROM-256
+    mirror mode=vertical
+    prg
+      rom name=program.rom size=0x8000
+    chr
+      rom name=character.rom size=0x2000
+  information
+    title:    スーパーマリオブラザーズ
+    name:     Super Mario Bros.
+    region:   JP
+    revision: 1.0
+    board:    HVC-NROM-256K-02
+    serial:   HVC-SM
+    sha256:   fcb6a0ef3a20c19b356005fbb21dc8009563b1cb5a9aaebc8e9386b4a8c5912e
+    configuration
+      rom name=program.rom size=0x8000
+      rom name=character.rom size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=HVC-NROM-256
+    mirror mode=horizontal
+    prg
+      rom name=program.rom size=0x8000
+    chr
+      rom name=character.rom size=0x2000
+  information
+    title:    テグザー
+    name:     Thexder
+    region:   JP
+    revision: 1.0
+    board:    HVC-NROM-256K-02S
+    serial:   SQF-TX
+    sha256:   18d41a2dc65d8afce295eaf29c391539a69d7cfe6dd32503713ae13d4495a545
+    configuration
+      rom name=program.rom size=0x8000
+      rom name=character.rom size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=FDS
+    prg
+      rom name=program.rom size=0x2000
+      ram size=0x8000
+    chr
+      ram size=0x2000
+  information
+    title:    Twin Famicom Disk System
+    name:     Twin Famicom Disk System
+    region:   JP
+    revision: 1.0
+    board:    Famicom Disk System
+    serial:   N/A
+    sha256:   a0a9d57cbace21bf9c85c2b85e86656317f0768d7772acc90c7411ab1dbff2bf
+    configuration
+      rom name=program.rom size=0x2000
+      ram name=work.ram size=0x8000
+      ram name=character.ram size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=HVC-NROM-128
+    mirror mode=vertical
+    prg
+      rom name=program.rom size=0x4000
+    chr
+      rom name=character.rom size=0x2000
+  information
+    title:    Wild Gunman
+    name:     Wild Gunman
+    region:   JP
+    revision: 1.1
+    board:    2I
+    serial:   HVC-WG
+    sha256:   adff304553b64384f86f6c2b63571f43972b9d087f92359a1b9b93b54d523542
+    configuration
+      rom name=program.rom size=0x4000
+      rom name=character.rom size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=NES-SGROM
+    chip type=MMC1A
+    prg
+      rom name=program.rom size=0x40000
+    chr
+      ram size=0x2000
+  information
+    title:    Bionic Commando
+    name:     Bionic Commando
+    region:   NA
+    revision: 1.0
+    board:    NES-SGROM-03
+    serial:   NES-CM-USA
+    sha256:   aeb61fd5cf5a5ed73344c46a43f8a8d539f601ff57e8f56c49bc1caea4ab3d9e
+    configuration
+      rom name=program.rom size=0x40000
+      ram name=character.ram size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=NES-SLROM
+    chip type=MMC1B2
+    prg
+      rom name=program.rom size=0x20000
+    chr
+      rom name=character.rom size=0x20000
+  information
+    title:    Clash at Demonhead
+    name:     Clash at Demonhead
+    region:   NA
+    revision: 1.0
+    board:    NES-SLROM-05
+    serial:   NES-B6-USA
+    sha256:   cf226f0d9486103bbaa19ee124b673d47aa2b3766334b6b7587d704c03e6649e
+    configuration
+      rom name=program.rom size=0x20000
+      rom name=character.rom size=0x20000
+
+release
+  cartridge region=NTSC
+    board type=NES-CNROM
+    mirror mode=vertical
+    prg
+      rom name=program.rom size=0x8000
+    chr
+      rom name=character.rom size=0x8000
+  information
+    title:    Cybernoid: The Fighting Machine
+    name:     Cybernoid - The Fighting Machine
+    region:   NA
+    revision: 1.0
+    serial:   NES-YN-USA
+    sha256:   ad1e14d08657d99c8b70f779931f62524b4beb529090b82b368925d8b642e40c
+    configuration
+      rom name=program.rom size=0x8000
+      rom name=character.rom size=0x8000
+
+release
+  cartridge region=NTSC
+    board type=NES-BNROM
+    mirror mode=horizontal
+    prg
+      rom name=program.rom size=0x20000
+    chr
+      ram size=0x2000
+  information
+    title:    Deadly Towers
+    name:     Deadly Towers
+    region:   NA
+    revision: 1.0
+    board:    NES-BN-ROM-01
+    serial:   NES-DE-USA
+    sha256:   0115356b0791cc8ddcb7d3163d6ef7aa664f3ff4e68dba561ffffb79eefcbca9
+    configuration
+      rom name=program.rom size=0x20000
+      ram name=character.ram size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=NES-SNROM
+    chip type=MMC1B2
+    prg
+      rom name=program.rom size=0x40000
+      ram name=save.ram size=0x2000
+    chr
+      ram size=0x2000
+  information
+    title:    Destiny of an Emperor
+    name:     Destiny of an Emperor
+    region:   NA
+    revision: 1.0
+    serial:   NES-YZ-USA
+    sha256:   6d082c801942ce6787b471428ab4c8a6acb3e21f3f38fa197f2aeb698d9a2d7e
+    configuration
+      rom name=program.rom size=0x40000
+      ram name=save.ram size=0x2000
+      ram name=character.ram size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=NES-NROM-128
+    mirror mode=vertical
+    prg
+      rom name=program.rom size=0x4000
+    chr
+      rom name=character.rom size=0x2000
+  information
+    title:    Donkey Kong Jr.
+    name:     Donkey Kong Jr.
+    region:   NA
+    revision: 1.0
+    board:    NES-NROM-128-03
+    serial:   NES-JR-USA
+    sha256:   950ebe68e7f74219b9e5e104200b03165d59c24264f02e32c12be967fd311ac2
+    configuration
+      rom name=program.rom size=0x4000
+      rom name=character.rom size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=NES-NROM-128
+    mirror mode=vertical
+    prg
+      rom name=program.rom size=0x4000
+    chr
+      rom name=character.rom size=0x2000
+  information
+    title:    Duck Hunt
+    name:     Duck Hunt
+    region:   NA
+    revision: 1.0
+    board:    NES-NROM-128-03
+    serial:   NES-DH-USA
+    serial:   NES-DH-CAN
+    sha256:   7026334a7e8742b61b450f4b3b182922c6a69fc723d7cd19c83db365f15e45ba
+    configuration
+      rom name=program.rom size=0x4000
+      rom name=character.rom size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=NES-UNROM
+    chip type=74HC32
+    mirror mode=vertical
+    prg
+      rom name=program.rom size=0x20000
+    chr
+      ram size=0x2000
+  information
+    title:    Disney's DuckTales
+    name:     DuckTales
+    region:   NA
+    revision: 1.0
+    board:    NES-UNROM-09
+    serial:   NES-UK-USA
+    sha256:   8ba8baed01a9fbaf1e9ff29e0c9825db1963ac2aff211d6f1f3bcfd3839e2013
+    configuration
+      rom name=program.rom size=0x20000
+      ram name=character.ram size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=NES-UNROM
+    chip type=74HC32
+    mirror mode=vertical
+    prg
+      rom name=program.rom size=0x20000
+    chr
+      ram size=0x2000
+  information
+    title:    Disney's DuckTales 2
+    name:     DuckTales 2
+    region:   NA
+    revision: 1.0
+    board:    NES-UNROM-10
+    serial:   NES-DL-USA
+    sha256:   54c70628739c9cfab40b8d79555e9076adae34127ef369988ca91635b4a688bf
+    configuration
+      rom name=program.rom size=0x20000
+      ram name=character.ram size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=NES-GNROM
+    mirror mode=vertical
+    prg
+      rom name=program.rom size=0x20000
+    chr
+      rom name=character.rom size=0x8000
+  information
+    title:    Gumshoe
+    name:     Gumshoe
+    region:   NA
+    revision: 1.0
+    board:    NES-GN-ROM-01
+    serial:   NES-GS-USA
+    sha256:   4628f32db9b826d19fe5dd8e2c45a9f70e1041f15b7b44b06dee2f01731566e8
+    configuration
+      rom name=program.rom size=0x20000
+      rom name=character.rom size=0x8000
+
+release
+  cartridge region=NTSC
+    board type=NES-TQROM
+    chip type=MMC3B
+    prg
+      rom name=program.rom size=0x20000
+    chr
+      rom name=character.rom size=0x10000
+      ram size=0x2000
+  information
+    title:    High Speed
+    name:     High Speed
+    region:   NA
+    revision: 1.0
+    serial:   NES-8H-USA
+    sha256:   710e907230bbd82143286b40a56a298b25cf326697a9f07bfd8e043c1936a4b1
+    configuration
+      rom name=program.rom size=0x20000
+      rom name=character.rom size=0x10000
+      rom name=nametable.ram size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=NES-NROM-128
+    mirror mode=vertical
+    prg
+      rom name=program.rom size=0x4000
+    chr
+      rom name=character.rom size=0x2000
+  information
+    title:    Hogan's Alley
+    name:     Hogan's Alley
+    region:   NA
+    revision: 1.0
+    board:    NES-NROM-128-04
+    serial:   NES-HA-USA
+    sha256:   8e4a04076b6a728a7e65a09737776dcb9defed7922bf0437d9a89bbe8c724b55
+    configuration
+      rom name=program.rom size=0x4000
+      rom name=character.rom size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=NES-SNROM
+    chip type=MMC1B2
+    prg
+      rom name=program.rom size=0x20000
+      ram name=save.ram size=0x2000
+    chr
+      ram size=0x2000
+  information
+    title:    The Legend of Zelda
+    name:     Legend of Zelda, The
+    region:   NA
+    revision: 1.1
+    serial:   NES-ZL-USA
+    serial:   ec0d4ebf6d2fcecd1d95fef7329954efe79676959bc281ea908b226459bc6dc2
+    configuration
+      rom name=program.rom size=0x20000
+      ram name=save.ram size=0x2000
+      ram name=character.ram size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=NES-TLROM
+    chip type=MMC3C
+    prg
+      rom name=program.rom size=0x40000
+    chr
+      rom name=character.rom size=0x20000
+  information
+    title:    Little Samson
+    name:     Little Samson
+    region:   NA
+    revision: 1.0
+    board:    NES-TLROM-03
+    serial:   NES-LT-USA
+    sha256:   a5165565263eaf8bdc45a8e6a615704f9bf271cd6d547d22c098c80cbaffd879
+    configuration
+      rom name=program.rom size=0x40000
+      rom name=character.rom size=0x20000
+
+release
+  cartridge region=NTSC
+    board type=NES-SGROM
+    chip type=MMC1B2
+    prg
+      rom name=program.rom size=0x40000
+    chr
+      ram size=0x2000
+  information
+    title:    Mega Man 2
+    name:     Mega Man 2
+    region:   NA
+    revision: 1.0
+    sha256:   1e588d435e75d80c5c0b578b4fa8d196f2cf4346c11c9a7b7e435d768828ad01
+    configuration
+      rom name=program.rom size=0x40000
+      ram name=character.ram size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=NES-TQROM
+    chip type=MMC3A
+    prg
+      rom name=program.rom size=0x20000
+    chr
+      rom name=character.rom size=0x10000
+      ram size=0x2000
+  information
+    title:    Pin-Bot
+    name:     Pin-Bot
+    region:   NA
+    revision: 1.0
+    serial:   NES-IO-USA
+    sha256:   f4ddb0f1a02f823ebed30b55547344de3c8fb9d87254ff993584373ecadd9141
+    configuration
+      rom name=program.rom size=0x20000
+      rom name=character.rom size=0x10000
+      rom name=nametable.ram size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=NES-CNROM
+    mirror mode=horizontal
+    prg
+      rom name=program.rom size=0x8000
+    chr
+      rom name=character.rom size=0x8000
+  information
+    title:    Puzznic
+    name:     Puzznic
+    region:   NA
+    revision: 1.0
+    board:    NES-CNROM-07
+    serial:   NES-ZP-USA
+    sha256:   0cf2fc17a59a0932ce43e6b2e9ea4e2570f03139784b5c9df429a499e734b92e
+    configuration
+      rom name=program.rom size=0x8000
+      rom name=character.rom size=0x8000
+
+release
+  cartridge region=NTSC
+    board type=NES-HKROM
+    chip type=MMC6B
+    prg
+      rom name=program.rom size=0x40000
+      ram name=save.ram size=0x400
+    chr
+      rom name=character.rom size=0x40000
+  information
+    title:    StarTropics
+    name:     StarTropics
+    region:   NA
+    revision: 1.0
+    serial:   NES-OC-USA
+    sha256:   69de2c7552fa81ca5921da0e457abf1be35f18ffbad159788a76141be59c9f6b
+    configuration
+      rom name=program.rom size=0x40000
+      ram name=save.ram size=0x400
+      rom name=character.rom size=0x40000
+
+release
+  cartridge region=NTSC
+    board type=NES-NROM-256
+    mirror mode=vertical
+    prg
+      rom name=program.rom size=0x8000
+    chr
+      rom name=character.rom size=0x2000
+  information
+    title:    Super Mario Bros.
+    name:     Super Mario Bros.
+    region:   NA
+    revision: 1.0
+    board:    NES-NROM-256-04
+    serial:   NES-SM-USA
+    sha256:   fcb6a0ef3a20c19b356005fbb21dc8009563b1cb5a9aaebc8e9386b4a8c5912e
+    configuration
+      rom name=program.rom size=0x8000
+      rom name=character.rom size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=NES-MHROM
+    mirror mode=vertical
+    prg
+      rom name=program.rom size=0x10000
+    chr
+      rom name=character.rom size=0x4000
+  information
+    title:    Super Mario Bros. / Duck Hunt
+    name:     Super Mario Bros. + Duck Hunt
+    region:   NA
+    revision: 1.0
+    board:    NES-MHROM-04
+    serial:   NES-MH-USA
+    sha256:   5dde385041aa7364c78205f2ba49615f416c701b6025e38aa1d7b9c4f99a62db
+    configuration
+      rom name=program.rom size=0x10000
+      rom name=character.rom size=0x4000
+
+release
+  cartridge region=NTSC
+    board type=NES-TSROM
+    chip type=MMC3B
+    prg
+      rom name=program.rom size=0x20000
+      ram size=0x2000
+    chr
+      rom name=character.rom size=0x20000
+  information
+    title:    Super Mario Bros. 2
+    name:     Super Mario Bros. 2
+    region:   NA
+    revision: 1.1
+    board:    NES-TSROM-08
+    serial:   NES-MW-USA
+    serial:   NES-MW-CAN
+    sha256:   728d0ca6751b0c039fc3e34f2e7f27a870afcab30f5e270244ac40979c5f69ca
+    configuration
+      rom name=program.rom size=0x20000
+      ram name=work.ram size=0x2000
+      rom name=character.rom size=0x20000
+
+release
+  cartridge region=NTSC
+    board type=NES-TSROM
+    chip type=MMC3B
+    prg
+      rom name=program.rom size=0x40000
+      ram size=0x2000
+    chr
+      rom name=character.rom size=0x20000
+  information
+    title:    Super Mario Bros. 3
+    name:     Super Mario Bros. 3
+    region:   NA
+    revision: 1.0
+    board:    NES-TSROM-06
+    serial:   NES-UM-USA
+    sha256:   d77d17d34af24871d7ce1160ccd3330555835c8e940b7100e095ac38973d927a
+    configuration
+      rom name=program.rom size=0x40000
+      ram name=work.ram size=0x2000
+      rom name=character.rom size=0x20000
+
+release
+  cartridge region=NTSC
+    board type=NES-TSROM
+    chip type=MMC3B
+    prg
+      rom name=program.rom size=0x40000
+      ram size=0x2000
+    chr
+      rom name=character.rom size=0x20000
+  information
+    title:    Super Mario Bros. 3
+    name:     Super Mario Bros. 3
+    region:   NA
+    revision: 1.1
+    board:    NES-TSROM-07
+    serial:   NES-UM-USA
+    serial:   NES-UM-CAN
+    sha256:   959fdd32c71735d6fb2bd16a646d39f4ee65623273dd035e6a968e991bd13ef8
+    configuration
+      rom name=program.rom size=0x40000
+      ram name=work.ram size=0x2000
+      rom name=character.rom size=0x20000
+
+release
+  cartridge region=NTSC
+    board type=NES-SEROM
+    chip type=MMC1B2
+    prg
+      rom name=program.rom size=0x8000
+    chr
+      rom name=character.rom size=0x4000
+  information
+    title:    Tetris
+    name:     Tetris
+    region:   NA
+    revision: 1.0
+    board:    NES-SEROM-04
+    serial:   NES-EI-USA
+    serial:   NES-EI-CAN
+    sha256:   2ae5fb18a1bf841077e3872ba05060f030ea0bfc573994b2f8fe2fb570dc7853
+    configuration
+      rom name=program.rom size=0x8000
+      rom name=character.rom size=0x4000
+
+release
+  cartridge region=NTSC
+    board type=NES-TKROM
+    chip type=MMC3C
+    prg
+      rom name=program.rom size=0x40000
+      ram name=save.ram size=0x2000
+    chr
+      rom name=character.rom size=0x40000
+  information
+    title:    Wario's Woods
+    name:     Wario's Woods
+    region:   NA
+    revision: 1.0
+    board:    NES-TKROM-10
+    serial:   NES-WB-USA
+    sha256:   c12771e8155b030eff0081bfabd98e57a162d6592899f29dd16f141f0e6e08a3
+    configuration
+      rom name=program.rom size=0x40000
+      ram name=save.ram size=0x2000
+      rom name=character.rom size=0x40000
+
+release
+  cartridge region=NTSC
+    board type=NES-NROM-128
+    mirror mode=vertical
+    prg
+      rom name=program.rom size=0x4000
+    chr
+      rom name=character.rom size=0x2000
+  information
+    title:    Wild Gunman
+    name:     Wild Gunman
+    region:   NA
+    revision: 1.0
+    board:    NES-NROM-128-01
+    serial:   NES-WG-USA
+    sha256:   62aec65696ecf24a487b7cdd19bad5cbd19f4229a89a7888634d468c67da378a
+    configuration
+      rom name=program.rom size=0x4000
+      rom name=character.rom size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=NES-NROM-128
+    mirror mode=vertical
+    prg
+      rom name=program.rom size=0x4000
+    chr
+      rom name=character.rom size=0x2000
+  information
+    title:    Wild Gunman
+    name:     Wild Gunman
+    region:   NA
+    revision: 1.1
+    board:    NES-NROM-128-04
+    serial:   NES-WG-USA
+    sha256:   adff304553b64384f86f6c2b63571f43972b9d087f92359a1b9b93b54d523542
+    configuration
+      rom name=program.rom size=0x4000
+      rom name=character.rom size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=NES-CNROM
+    mirror mode=horizontal
+    prg
+      rom name=program.rom size=0x8000
+    chr
+      rom name=character.rom size=0x8000
+  information
+    title:    World Class Track Meet
+    name:     World Class Track Meet
+    region:   NA
+    revision: 1.1
+    serial:   NES-WT-USA
+    sha256:   ac766a8d99bfd8e95c02b9a9c68279c72ba5b3307b78edc67b52781ed185fa89
+    configuration
+      rom name=program.rom size=0x8000
+      rom name=character.rom size=0x8000
+
+release
+  cartridge region=NTSC
+    board type=NES-HKROM
+    chip type=MMC6B
+    prg
+      rom name=program.rom size=0x40000
+      ram name=save.ram size=0x400
+    chr
+      rom name=character.rom size=0x40000
+  information
+    title:    Zoda's Revenge: StarTropics 2
+    name:     Zoda's Revenge - StarTropics 2
+    region:   NA
+    revision: 1.0
+    board:    NES-HKROM-02
+    serial:   NES-6C-USA
+    sha256:   d0850075065ecbd125a33accc952de5d012527be45aa14a1b8223a9adf1643ae
+    configuration
+      rom name=program.rom size=0x40000
+      ram name=save.ram size=0x400
+      rom name=character.rom size=0x40000
+
+release
+  cartridge region=PAL
+    board type=NES-NROM-128
+    mirror mode=vertical
+    prg
+      rom name=program.rom size=0x4000
+    chr
+      rom name=character.rom size=0x2000
+  information
+    title:    Hogan's Alley
+    name:     Hogan's Alley
+    region:   EU
+    revision: 1.0
+    board:    NES-NROM-128-03
+    serial:   NES-HA-EEC
+    sha256:   8e4a04076b6a728a7e65a09737776dcb9defed7922bf0437d9a89bbe8c724b55
+    configuration
+      rom name=program.rom size=0x4000
+      rom name=character.rom size=0x2000
+
+release
+  cartridge region=PAL
+    board type=NES-TSROM
+    chip type=MMC3C
+    prg
+      rom name=program.rom size=0x20000
+      ram size=0x2000
+    chr
+      rom name=character.rom size=0x20000
+  information
+    title:    Noah's Ark
+    name:     Noah's Ark
+    region:   EU
+    revision: 1.0
+    serial:   NES-NH-NOE
+    sha256:   6157c99fe7a214025c65fd3649e4afe9cd2d38c333e65af028b935e49fbeb500
+    configuration
+      rom name=program.rom size=0x20000
+      ram name=work.ram size=0x2000
+      rom name=character.rom size=0x20000
+
+release
+  cartridge region=PAL
+    board type=NES-TKROM
+    chip type=MMC3C
+    prg
+      rom name=program.rom size=0x40000
+      ram name=save.ram size=0x2000
+    chr
+      rom name=character.rom size=0x40000
+  information
+    title:    Wario's Woods
+    name:     Wario's Woods
+    region:   EU
+    revision: 1.0
+    board:    NES-TKROM-10
+    serial:   NES-WB-NOE
+    sha256:   9fe815d8fd175ef9ef03fb010638f2b6b7aa9d11d5a40eda2476450918543e6f
+    configuration
+      rom name=program.rom size=0x40000
+      ram name=save.ram size=0x2000
+      rom name=character.rom size=0x40000
+
+)";
diff --git a/ananke/database/playchoice-10.hpp b/ananke/database/playchoice-10.hpp
new file mode 100644
index 0000000..4096187
--- /dev/null
+++ b/ananke/database/playchoice-10.hpp
@@ -0,0 +1,30 @@
+string Famicom = R"(
+
+database revision=2012-10-22
+
+release
+  cartridge region=NTSC
+    board type=NES-NROM-256
+    mirror mode=vertical
+    prg
+      rom name=program.rom size=0x8000
+    chr
+      rom name=character.rom size=0x2000
+    pc10
+      rom name=instructions.rom size=0x2000
+      rom name=key1.rom size=0x10
+      rom name=key2.rom size=0x10
+  information
+    title:    Super Mario Bros.
+    name:     Super Mario Bros.
+    region:   NA
+    revision: 1.0
+    sha256:   fd8652394c0c9cba34c35a5f8c0ed6ab155e2c99aa4180fc940bdf1e25a0132d
+    configuration
+      rom name=program.rom size=0x8000
+      rom name=character.rom size=0x2000
+      rom name=instructions.rom size=0x2000
+      rom name=key1.rom size=0x10
+      rom name=key2.rom size=0x10
+
+)";
diff --git a/ananke/famicom.cpp b/ananke/famicom.cpp
index a54039c..f4083ba 100644
--- a/ananke/famicom.cpp
+++ b/ananke/famicom.cpp
@@ -1,11 +1,42 @@
 void Ananke::copyFamicomSaves(const string &pathname) {
   if(!file::exists({pathname, "save.ram"})) {
     if(file::exists({information.path, nall::basename(information.name), ".sav"})) {
-      file::copy({information.path, nall::basename(information.name), ".srm"}, {pathname, "save.ram"});
+      file::copy({information.path, nall::basename(information.name), ".sav"}, {pathname, "save.ram"});
     }
   }
 }
 
+string Ananke::createFamicomDatabase(vector<uint8_t> &buffer, Markup::Node &document, const string &manifest) {
+  string pathname = {
+    libraryPath, "Famicom/",
+    document["release/information/name"].text(),
+    " (", document["release/information/region"].text(), ")",
+    " (", document["release/information/revision"].text(), ")",
+    ".fc/"
+  };
+  directory::create(pathname);
+
+  //strip "release" root node from database entry (since a single game manifest isn't part of a database)
+  string markup = manifest;
+  markup.replace("\n  ", "\n");
+  markup.replace("information", "\ninformation");
+  markup.ltrim<1>("release\n");
+
+  file::write({pathname, "manifest.bml"}, markup);
+
+  unsigned offset = 0;
+  for(auto &node : document["release/information/configuration"]) {
+    if(node.name != "rom") continue;
+    string name = node["name"].text();
+    unsigned size = node["size"].decimal();
+    file::write({pathname, name}, buffer.data() + offset, size);
+    offset += size;
+  }
+
+  copyFamicomSaves(pathname);
+  return pathname;
+}
+
 string Ananke::createFamicomHeuristic(vector<uint8_t> &buffer) {
   string pathname = {
     libraryPath, "Famicom/",
@@ -16,7 +47,7 @@ string Ananke::createFamicomHeuristic(vector<uint8_t> &buffer) {
 
   FamicomCartridge info(buffer.data(), buffer.size());
   string markup = {"unverified\n\n", info.markup};
-  markup.append("\ninformation\n  title: ", nall::basename(information.name), "\n");
+  markup.append("\ninformation\n  title: ", nall::basename(information.name));
   if(!information.manifest.empty()) markup = information.manifest;  //override with embedded beat manifest, if one exists
 
   file::write({pathname, "manifest.bml"}, markup);
@@ -28,6 +59,33 @@ string Ananke::createFamicomHeuristic(vector<uint8_t> &buffer) {
 }
 
 string Ananke::openFamicom(vector<uint8_t> &buffer) {
+  bool ines = true;
+  ines = ines && buffer.data()[0] == 'N';
+  ines = ines && buffer.data()[1] == 'E';
+  ines = ines && buffer.data()[2] == 'S';
+  ines = ines && buffer.data()[3] == 0x1A;
+  if(ines && buffer.data()[4] == 0x01) {
+    string sha256_1 = nall::sha256(buffer.data() + 0x0010, 0x2000);
+    string sha256_2 = nall::sha256(buffer.data() + 0x2010, 0x2000);
+    if(sha256_1 == sha256_2) {
+      buffer.remove(16,0x2000);
+    }
+  }
+  string sha256 = nall::sha256(buffer.data() + (ines ? 16 : 0), buffer.size() - (ines ? 16 : 0));
+
+  string databaseText = string::read({configpath(), "ananke/database/Famicom.bml"}).strip();
+  if(databaseText.empty()) databaseText = string{Database::Famicom}.strip();
+  lstring databaseItem = databaseText.split("\n\n");
+
+  for(auto &item : databaseItem) {
+    auto document = Markup::Document(item);
+
+    if(document["release/information/sha256"].text() == sha256) {
+      if(ines) buffer.remove(0, 16);
+      return createFamicomDatabase(buffer, document, item);
+    }
+  }
+
   return createFamicomHeuristic(buffer);
 }
 
@@ -35,5 +93,32 @@ string Ananke::openFamicom(vector<uint8_t> &buffer) {
 //game folders discard iNES header required for heuristic detection
 //a games database of all commercial Famicom software will be required
 string Ananke::syncFamicom(const string &pathname) {
-  return "";
+  vector<uint8_t> buffer;
+
+  auto append = [&](string filename) {
+    filename = {pathname, filename};
+    auto data = file::read(filename);
+    if(data.size() == 0) return;  //file does not exist
+
+    unsigned position = buffer.size();
+    buffer.resize(buffer.size() + data.size());
+    memcpy(buffer.data() + position, data.data(), data.size());
+  };
+
+  append("program.rom");
+  append("character.rom");
+
+  if(buffer.size() == 0) return "";
+
+  auto save = file::read({pathname, "save.ram"});
+  if(save.size() == 0) save = file::read({pathname, "save.rwm"});
+
+  directory::remove(pathname);
+  information.path = pathname;
+  information.name = notdir(string{pathname}.rtrim<1>("/"));
+  string outputPath = openFamicom(buffer);
+
+  if(save.size()) file::write({outputPath, "save.ram"}, save);
+
+  return outputPath;
 }
diff --git a/ananke/heuristics/famicom.hpp b/ananke/heuristics/famicom.hpp
index 08d243a..756a3bd 100644
--- a/ananke/heuristics/famicom.hpp
+++ b/ananke/heuristics/famicom.hpp
@@ -17,62 +17,126 @@ struct FamicomCartridge {
   unsigned prgram;
   unsigned chrrom;
   unsigned chrram;
+  bool     battery;
+  bool     region;
+  bool     vs;
+  // NES 2.0
+  bool     pc10;
+  bool     nes2;
+  unsigned submapper;
 };
 
 FamicomCartridge::FamicomCartridge(const uint8_t *data, unsigned size) {
   markup = "";
   if(size < 16) return;
-  if(data[0] != 'N') return;
-  if(data[1] != 'E') return;
-  if(data[2] != 'S') return;
-  if(data[3] !=  26) return;
+  if(data[0] != 'N' ) return;
+  if(data[1] != 'E' ) return;
+  if(data[2] != 'S' ) return;
+  if(data[3] != 0x1A) return;
 
-  mapper = ((data[7] >> 4) << 4) | (data[6] >> 4);
-  mirror = ((data[6] & 0x08) >> 2) | (data[6] & 0x01);
-  prgrom = data[4] * 0x4000;
-  chrrom = data[5] * 0x2000;
-  prgram = 0u;
-  chrram = chrrom == 0u ? 8192u : 0u;
+  mapper  = ((data[7] >> 4) << 4) | (data[6] >> 4);
+  prgrom  = data[4] * 0x4000;
+  chrrom  = data[5] * 0x2000;
+  prgram  = 0u;
+  chrram  = chrrom == 0u ? 8192u : 0u;
+  mirror  = ((data[6] & 0x08) >> 2) | (data[6] & 0x01);
+  battery = data[6] & 0x02;
+  vs      = data[7] & 0x01;
+  nes2    = data[7] & 0x0c == 0x08;
+  if(!nes2) {
+    // ignore the last 9 bytes of headers that have "DiskDude!" or other
+    // messages written there
+    if(data[12] == 0 && data[13] == 0 && data[14] == 0 && data[15] == 0) {
+      prgram = data[8] * 0x2000;
+      region = data[9] & 0x01;
+    } else {
+      mapper &= 0x0f;
+      vs = false;
+      pc10 = false;
+    }
+  } else {
+    pc10 = data[7] & 0x02;
+    mapper |= (data[8] & 0x0f) << 8;
+    submapper |= data[8] >> 4;
+    prgrom += (data[9] & 0x0f) * 0x400000;
+    chrrom += (data[9] >> 4) * 0x200000;
+    prgram = (data[10] & 0x0f == 0 ? 0 : 64) << (data[10] & 0x0f); // no battery
+    prgram += (data[10] >> 4 == 0 ? 0 : 64) << (data[10] >> 4); // battery
+    chrram = (data[11] & 0x0f == 0 ? 0 : 64) << (data[11] & 0x0f); // no battery
+    chrram += (data[11] >> 4 == 0 ? 0 : 64) << (data[11] >> 4); // battery
+    region = data[12] & 0x01;
+  }
+
+  // Galaxian has its PRG ROM doubled to fit within iNES's constraints.
+  if(prgrom == 0x4000 && (prgrom + chrrom + 0x10 == size + 0x2000)) prgrom = 0x2000;
 
-  markup.append("cartridge\n");
+  markup.append("cartridge region=", region == 0 ? "NTSC" : "PAL", "\n");
 
   switch(mapper) {
   default:
-    markup.append("  board type=NES-NROM-256\n");
+    if(prgrom <= 8192) {
+      markup.append("  board type=NAMCOT-3301\n");
+    } else if(prgrom <= 16384) {
+      markup.append("  board type=NES-NROM-128\n");
+    } else {
+      markup.append("  board type=NES-NROM-256\n");
+    }
     markup.append("  mirror mode=", mirror == 0 ? "horizontal" : "vertical", "\n");
     break;
 
   case   1:
-    markup.append("  board type=NES-SXROM\n");
-    markup.append("  chip type=MMC1B2\n");
-    prgram = 8192;
+  case 155:
+    if(prgram <= 8192) {
+      markup.append("  board type=NES-SUROM\n");
+    } else {
+      markup.append("  board type=NES-SXROM\n");
+    }
+    markup.append("  chip type=MMC1", mapper != 155 ? "B2" : "A", "\n");
+    if(!nes2 && !prgram) prgram = 8192;
     break;
 
   case   2:
-    markup.append("  board type=NES-UOROM\n");
+  case 180:
+    if(prgrom <= 131072) markup.append("  board type=NES-UNROM\n");
+    else                 markup.append("  board type=NES-UOROM\n");
+    markup.append("  chip type=74HC", mapper != 180 ? "32" : "08", "\n");
     markup.append("  mirror mode=", mirror == 0 ? "horizontal" : "vertical", "\n");
     break;
 
   case   3:
+  case 185:
     markup.append("  board type=NES-CNROM\n");
+    if(mapper == 185) {
+      markup.append("    security pass=0x", hex(submapper & 3), "\n");
+    }
     markup.append("  mirror mode=", mirror == 0 ? "horizontal" : "vertical", "\n");
     break;
 
   case   4:
-    //MMC3
-    markup.append("  board type=NES-TLROM\n");
-    markup.append("  chip type=MMC3B\n");
-    prgram = 8192;
-    //MMC6
-  //markup.append("  board type=NES-HKROM\n");
-  //markup.append("  chip type=MMC6n");
-  //prgram = 1024;
+  case 118:
+  case 119:
+    if(prgram != 0x400) {
+      switch(mapper) {
+      case   4:
+        if(mirror & 2) markup.append("  board type=NES-TR1ROM\n");
+        else           markup.append("  board type=NES-TLROM\n");
+        break;
+      case 118: markup.append("  board type=NES-TLSROM\n"); break;
+      case 119: markup.append("  board type=NES-TQROM\n"); break;
+      }
+      markup.append("  chip type=MMC3B\n");
+    } else {
+      markup.append("  board type=NES-HKROM\n");
+      markup.append("  chip type=MMC6n");
+    }
+    if(!nes2 && !prgram) prgram = 8192;
+    if(mapper == 119 && !nes2 && !chrram) chrram = 0x2000;
     break;
 
   case   5:
     markup.append("  board type=NES-ELROM\n");
     markup.append("  chip type=MMC5\n");
-    prgram = 65536;
+    if(!nes2 && !prgram) prgram = 32768;
     break;
 
   case   7:
@@ -82,46 +146,83 @@ FamicomCartridge::FamicomCartridge(const uint8_t *data, unsigned size) {
   case   9:
     markup.append("  board type=NES-PNROM\n");
     markup.append("  chip type=MMC2\n");
-    prgram = 8192;
+    if(!nes2 && !prgram) prgram = 8192;
     break;
 
   case  10:
     markup.append("  board type=NES-FKROM\n");
     markup.append("  chip type=MMC4\n");
-    prgram = 8192;
+    if(!nes2 && !prgram) prgram = 8192;
+    break;
+
+  case  13:
+    markup.append("  board type=NES-CPROM\n");
+    markup.append("  mirror mode=", mirror == 0 ? "horizontal" : "vertical", "\n");
     break;
 
   case  16:
-    markup.append("  board type=BANDAI-FCG\n");
-    markup.append("  chip type=LZ93D50\n");
+  case 153:
+  case 159:
+    switch(mapper) {
+    case  16:
+      markup.append("  board type=BANDAI-FCG\n");
+      markup.append("  chip type=LZ93D50\n");
+      markup.append("  chip type=24C02\n");
+      break;
+    case 153:
+      markup.append("  board type=BANDAI-JUMP2\n");
+      markup.append("  chip type=LZ93D50\n");
+      if(!nes2 && !prgram) prgram = 8192;
+      break;
+    case 159:
+      markup.append("  board type=BANDAI-LZ93D50\n");
+      markup.append("  chip type=LZ93D50\n");
+      markup.append("  chip type=24C01\n");
+      break;
+    }
     break;
 
-  case  21:
-  case  23:
-  case  25:
-    //VRC4
+  case  21: //VRC4a,VRC4c
+  case  23: //VRC4e,VRC4f,VRC2b
+  case  25: //VRC4b,VRC4d,VRC2c
     markup.append("  board type=KONAMI-VRC-4\n");
-    markup.append("  chip type=VRC4\n");
-    markup.append("    pinout a0=1 a1=0\n");
-    prgram = 8192;
+    markup.append("  chip type=", submapper == 15 ? "VRC2" : "VRC4", "\n");
+    if(submapper == 0) {
+      switch(mapper) {
+      case 21: markup.append("    pinout a0=1 a1=2\n"); break;
+      case 23: markup.append("    pinout a0=0 a1=1\n"); break;
+      case 25: markup.append("    pinout a0=1 a1=0\n"); break;
+      }
+    } else if(submapper == 15) {
+      markup.append("    pinout",
+        " a0=", submapper == 25,
+        " a1=", submapper == 23,
+      "\n");
+    } else {
+      markup.append("    pinout",
+        " a0=", submapper & 7,
+        " a1=", (submapper & 7) + (((submapper & 8) >> 2) - 1),
+      "\n");
+    }
+    if(!nes2 && !prgram) prgram = 8192;
     break;
 
   case  22:
-    //VRC2
+    //VRC2a
     markup.append("  board type=KONAMI-VRC-2\n");
     markup.append("  chip type=VRC2\n");
-    markup.append("    pinout a0=0 a1=1\n");
+    markup.append("    pinout a0=1 a1=0\n");
     break;
 
   case  24:
-    markup.append("  board type=KONAMI-VRC-6\n");
-    markup.append("  chip type=VRC6\n");
-    break;
-
   case  26:
     markup.append("  board type=KONAMI-VRC-6\n");
     markup.append("  chip type=VRC6\n");
-    prgram = 8192;
+    switch(mapper) {
+    case 24: markup.append("    pinout a0=0 a1=1\n"); break;
+    case 26: markup.append("    pinout a0=1 a1=0\n"); break;
+    }
+    if(!nes2 && !prgram) prgram = 8192;
     break;
 
   case  34:
@@ -137,14 +238,14 @@ FamicomCartridge::FamicomCartridge(const uint8_t *data, unsigned size) {
   case  69:
     markup.append("  board type=SUNSOFT-5B\n");
     markup.append("  chip type=5B\n");
-    prgram = 8192;
+    if(!nes2 && !prgram) prgram = 8192;
     break;
 
   case  73:
     markup.append("  board type=KONAMI-VRC-3\n");
     markup.append("  chip type=VRC3\n");
     markup.append("  mirror mode=", mirror == 0 ? "horizontal" : "vertical", "\n");
-    prgram = 8192;
+    if(!nes2 && !prgram) prgram = 8192;
     break;
 
   case  75:
@@ -155,13 +256,35 @@ FamicomCartridge::FamicomCartridge(const uint8_t *data, unsigned size) {
   case  85:
     markup.append("  board type=KONAMI-VRC-7\n");
     markup.append("  chip type=VRC7\n");
-    prgram = 8192;
+    if(!nes2 && !prgram) prgram = 8192;
+    break;
+
+  case  76:
+  case  88:
+  case  95:
+  case 154:
+  case 206:
+    switch(mapper) {
+    case  76: markup.append("  board type=NAMCOT-3446\n"); break;
+    case  88: markup.append("  board type=NAMCOT-3443\n"); break;
+    case  95: markup.append("  board type=NAMCOT-3425\n"); break;
+    case 154: markup.append("  board type=NAMCOT-3453\n"); break;
+    case 206: markup.append("  board type=NAMCOT-3401\n"); break;
+    // Normally 3416, but バベルの塔 (Babel no Tou) uses bankswitching despite
+    // fitting entirely in the memory map, and other 32KB programs are not
+    // broken by having it enabled.
+    }
+    markup.append("  chip type=Namcot108\n");
+    markup.append("  mirror mode=", mirror == 0 ? "horizontal" : "vertical", "\n");
     break;
   }
 
   markup.append("  prg\n");
   if(prgrom) markup.append("    rom name=program.rom size=0x", hex(prgrom), "\n");
-  if(prgram) markup.append("    ram name=save.ram size=0x", hex(prgram), "\n");
+  if(prgram) {
+    if(battery) markup.append("    ram name=save.ram size=0x", hex(prgram), "\n");
+    else        markup.append("    ram size=0x", hex(prgram), "\n");
+  }
 
   markup.append("  chr\n");
   if(chrrom) markup.append("    rom name=character.rom size=0x", hex(chrrom), "\n");
diff --git a/data/higan.desktop b/data/higan.desktop
index 70a2242..a71bfb3 100644
--- a/data/higan.desktop
+++ b/data/higan.desktop
@@ -1,6 +1,6 @@
 [Desktop Entry]
 Name=higan
-Comment=SNES emulator
+Comment=NES, SNES, Game Boy, Game Boy Advance emulator
 Exec=higan
 Icon=higan
 Terminal=false
diff --git a/emulator/emulator.hpp b/emulator/emulator.hpp
index 8b59706..9ea815c 100644
--- a/emulator/emulator.hpp
+++ b/emulator/emulator.hpp
@@ -10,6 +10,8 @@ namespace Emulator {
 
   #if defined(PROFILE_ACCURACY)
   static const char Profile[] = "Accuracy";
+  #elif defined(PROFILE_ACCURACYFAST)
+  static const char Profile[] = "Accuracyfast";
   #elif defined(PROFILE_BALANCED)
   static const char Profile[] = "Balanced";
   #elif defined(PROFILE_PERFORMANCE)
diff --git a/emulator/interface.hpp b/emulator/interface.hpp
index b46fdfe..89a81a6 100644
--- a/emulator/interface.hpp
+++ b/emulator/interface.hpp
@@ -89,6 +89,7 @@ struct Interface {
   virtual void save() {}
   virtual void load(unsigned id, const stream& memory) {}
   virtual void save(unsigned id, const stream& memory) {}
+  virtual void savemempak() {}
   virtual void unload() {}
 
   //system interface
@@ -111,6 +112,9 @@ struct Interface {
   //utility functions
   enum class PaletteMode : unsigned { Literal, Channel, Standard, Emulation };
   virtual void paletteUpdate(PaletteMode mode) {}
+
+  //debugger functions
+  virtual void exportMemory() {}
 };
 
 }
diff --git a/fc/Makefile b/fc/Makefile
index ce5bad5..0c1421d 100644
--- a/fc/Makefile
+++ b/fc/Makefile
@@ -1,16 +1,17 @@
-fc_objects := fc-interface fc-system fc-scheduler fc-input
-fc_objects += fc-memory fc-cartridge fc-cpu fc-apu fc-ppu
-fc_objects += fc-cheat fc-video
+fc_objects := fc-interface fc-system fc-controller
+fc_objects += fc-cartridge fc-cheat
+fc_objects += fc-memory fc-cpu fc-apu fc-ppu
+fc_objects += fc-vsarcade
 objects += $(fc_objects)
 
 obj/fc-interface.o: $(fc)/interface/interface.cpp $(call rwildcard,$(fc)/interface/)
 obj/fc-system.o: $(fc)/system/system.cpp $(call rwildcard,$(fc)/system/)
-obj/fc-scheduler.o: $(fc)/scheduler/scheduler.cpp $(call rwildcard,$(fc)/scheduler/)
-obj/fc-input.o: $(fc)/input/input.cpp $(call rwildcard,$(fc)/input/)
-obj/fc-memory.o: $(fc)/memory/memory.cpp $(call rwildcard,$(fc)/memory/)
+obj/fc-controller.o: $(fc)/controller/controller.cpp $(call rwildcard,$(fc)/controller/)
 obj/fc-cartridge.o: $(fc)/cartridge/cartridge.cpp $(call rwildcard,$(fc)/cartridge/)
+obj/fc-cheat.o: $(fc)/cheat/cheat.cpp $(call rwildcard,$(fc)/cheat/)
+obj/fc-memory.o: $(fc)/memory/memory.cpp $(call rwildcard,$(fc)/memory/)
 obj/fc-cpu.o: $(fc)/cpu/cpu.cpp $(call rwildcard,$(fc)/cpu/)
 obj/fc-apu.o: $(fc)/apu/apu.cpp $(call rwildcard,$(fc)/apu/)
 obj/fc-ppu.o: $(fc)/ppu/ppu.cpp $(call rwildcard,$(fc)/ppu/)
-obj/fc-cheat.o: $(fc)/cheat/cheat.cpp $(call rwildcard,$(fc)/cheat/)
-obj/fc-video.o: $(fc)/video/video.cpp $(call rwildcard,$(fc)/video/)
+
+obj/fc-vsarcade.o: $(fc)/arcade/vs/vs.cpp $(call rwildcard,$(fc)/arcade/vs/)
diff --git a/fc/apu/apu.cpp b/fc/apu/apu.cpp
index 9c38b39..05ae976 100644
--- a/fc/apu/apu.cpp
+++ b/fc/apu/apu.cpp
@@ -1,6 +1,9 @@
 #include <fc/fc.hpp>
 
+#define APU_CPP
 namespace Famicom {
+  
+APU apu;
 
 #include "envelope.cpp"
 #include "sweep.cpp"
@@ -9,7 +12,6 @@ namespace Famicom {
 #include "noise.cpp"
 #include "dmc.cpp"
 #include "serialization.cpp"
-APU apu;
 
 const uint8 APU::length_counter_table[32] = {
   0x0a, 0xfe, 0x14, 0x02, 0x28, 0x04, 0x50, 0x06, 0xa0, 0x08, 0x3c, 0x0a, 0x0e, 0x0c, 0x1a, 0x0e,
@@ -67,7 +69,7 @@ void APU::main() {
 }
 
 void APU::tick() {
-  clock += 12;
+  clock += (system.region() == System::Region::NTSC ? 12 : 16);
   if(clock >= 0 && scheduler.sync != Scheduler::SynchronizeMode::All) co_switch(cpu.thread);
 }
 
@@ -92,7 +94,7 @@ void APU::power() {
 }
 
 void APU::reset() {
-  create(APU::Main, 21477272);
+  create(APU::Main, system.cpu_frequency());
 
   pulse[0].reset();
   pulse[1].reset();
@@ -249,7 +251,10 @@ void APU::write(uint16 addr, uint8 data) {
       frame.irq_pending = false;
       set_irq_line();
     }
-    frame.divider = FrameCounter::NtscPeriod;
+    if(system.region() == System::Region::NTSC)
+      frame.divider = FrameCounter::NtscPeriod;
+    else
+      frame.divider = FrameCounter::PalPeriod;
     break;
   }
 }
@@ -287,7 +292,12 @@ void APU::clock_frame_counter() {
   noise.envelope.clock();
 
   if(frame.counter == 0) {
-    if(frame.mode & 2) frame.divider += FrameCounter::NtscPeriod;
+    if(frame.mode & 2) {
+      if(system.region() == System::Region::NTSC)
+        frame.divider += FrameCounter::NtscPeriod;
+      else
+        frame.divider += FrameCounter::PalPeriod;
+    }
     if(frame.mode == 0) {
       frame.irq_pending = true;
       set_irq_line();
@@ -299,7 +309,10 @@ void APU::clock_frame_counter_divider() {
   frame.divider -= 2;
   if(frame.divider <= 0) {
     clock_frame_counter();
-    frame.divider += FrameCounter::NtscPeriod;
+    if(system.region() == System::Region::NTSC)
+      frame.divider += FrameCounter::NtscPeriod;
+    else
+      frame.divider += FrameCounter::PalPeriod;
   }
 }
 
diff --git a/fc/apu/apu.hpp b/fc/apu/apu.hpp
index a0ea128..1dad293 100644
--- a/fc/apu/apu.hpp
+++ b/fc/apu/apu.hpp
@@ -35,7 +35,10 @@ struct APU : Thread {
   #include "dmc.hpp"
 
   struct FrameCounter {
-    enum : unsigned { NtscPeriod = 14915 };  //~(21.477MHz / 6 / 240hz)
+    enum : unsigned {
+      NtscPeriod = 14915,  //~(21.477MHz / 6 / 240hz)
+      PalPeriod = 18473, // conjectural
+    };
 
     bool irq_pending;
 
diff --git a/fc/apu/dmc.cpp b/fc/apu/dmc.cpp
index ffe221f..502394f 100644
--- a/fc/apu/dmc.cpp
+++ b/fc/apu/dmc.cpp
@@ -1,3 +1,5 @@
+#ifdef APU_CPP
+
 void APU::DMC::start() {
   if(length_counter == 0) {
     read_addr = 0x4000 + (addr_latch << 6);
@@ -57,7 +59,10 @@ uint8 APU::DMC::clock() {
       }
     }
 
-    period_counter = ntsc_dmc_period_table[period];
+    if(system.region() == System::Region::NTSC)
+      period_counter = ntsc_dmc_period_table[period];
+    else
+      period_counter = pal_dmc_period_table[period];
   }
 
   if(length_counter > 0 && have_dma_buffer == false && dma_delay_counter == 0) {
@@ -115,3 +120,5 @@ void APU::DMC::serialize(serializer& s) {
   s.integer(have_sample);
   s.integer(sample);
 }
+
+#endif
diff --git a/fc/apu/envelope.cpp b/fc/apu/envelope.cpp
index 8d0dbc7..a04d92f 100644
--- a/fc/apu/envelope.cpp
+++ b/fc/apu/envelope.cpp
@@ -1,3 +1,5 @@
+#ifdef APU_CPP
+
 unsigned APU::Envelope::volume() const {
   return use_speed_as_volume ? speed : decay_volume;
 }
@@ -37,3 +39,5 @@ void APU::Envelope::serialize(serializer& s) {
   s.integer(decay_counter);
   s.integer(decay_volume);
 }
+
+#endif
diff --git a/fc/apu/noise.cpp b/fc/apu/noise.cpp
index 65eee58..41f8c8c 100644
--- a/fc/apu/noise.cpp
+++ b/fc/apu/noise.cpp
@@ -1,3 +1,5 @@
+#ifdef APU_CPP
+
 void APU::Noise::clock_length() {
   if(envelope.loop_mode == 0) {
     if(length_counter > 0) length_counter--;
@@ -19,7 +21,10 @@ uint8 APU::Noise::clock() {
     }
 
     lfsr = (lfsr >> 1) | (feedback << 14);
-    period_counter = apu.ntsc_noise_period_table[period];
+    if(system.region() == System::Region::NTSC)
+      period_counter = apu.ntsc_noise_period_table[period];
+    else
+      period_counter = apu.pal_noise_period_table[period];
   }
 
   return result;
@@ -55,3 +60,5 @@ void APU::Noise::serialize(serializer& s) {
   s.integer(short_mode);
   s.integer(lfsr);
 }
+
+#endif
diff --git a/fc/apu/pulse.cpp b/fc/apu/pulse.cpp
index 5f8abbc..cd6d522 100644
--- a/fc/apu/pulse.cpp
+++ b/fc/apu/pulse.cpp
@@ -1,3 +1,5 @@
+#ifdef APU_CPP
+
 void APU::Pulse::clock_length() {
   if(envelope.loop_mode == 0) {
     if(length_counter) length_counter--;
@@ -49,3 +51,5 @@ void APU::Pulse::serialize(serializer& s) {
   s.integer(period);
   s.integer(period_counter);
 }
+
+#endif
diff --git a/fc/apu/serialization.cpp b/fc/apu/serialization.cpp
index 5968a9c..43a5474 100644
--- a/fc/apu/serialization.cpp
+++ b/fc/apu/serialization.cpp
@@ -1,3 +1,5 @@
+#ifdef APU_CPP
+
 void APU::serialize(serializer& s) {
   Thread::serialize(s);
 
@@ -26,3 +28,5 @@ void APU::FrameCounter::serialize(serializer& s) {
   s.integer(counter);
   s.integer(divider);
 }
+
+#endif
diff --git a/fc/apu/sweep.cpp b/fc/apu/sweep.cpp
index 333ccae..4955538 100644
--- a/fc/apu/sweep.cpp
+++ b/fc/apu/sweep.cpp
@@ -1,3 +1,5 @@
+#ifdef APU_CPP
+
 bool APU::Sweep::check_period() {
   if(pulse_period > 0x7ff) return false;
 
@@ -51,3 +53,5 @@ void APU::Sweep::serialize(serializer& s) {
   s.integer(reload);
   s.integer(pulse_period);
 }
+
+#endif
diff --git a/fc/apu/triangle.cpp b/fc/apu/triangle.cpp
index 1249b38..d1c9123 100644
--- a/fc/apu/triangle.cpp
+++ b/fc/apu/triangle.cpp
@@ -1,3 +1,5 @@
+#ifdef APU_CPP
+
 void APU::Triangle::clock_length() {
   if(halt_length_counter == 0) {
     if(length_counter > 0) length_counter--;
@@ -56,3 +58,5 @@ void APU::Triangle::serialize(serializer& s) {
   s.integer(linear_length_counter);
   s.integer(reload_linear);
 }
+
+#endif
diff --git a/fc/arcade/arcade.hpp b/fc/arcade/arcade.hpp
new file mode 100644
index 0000000..090f493
--- /dev/null
+++ b/fc/arcade/arcade.hpp
@@ -0,0 +1 @@
+#include <fc/arcade/vs/vs.hpp>
diff --git a/fc/arcade/vs/serialization.cpp b/fc/arcade/vs/serialization.cpp
new file mode 100644
index 0000000..503f919
--- /dev/null
+++ b/fc/arcade/vs/serialization.cpp
@@ -0,0 +1,8 @@
+#ifdef VS_ARCADE_BOARD_CPP
+
+void VSArcadeBoard::serialize(serializer& s) {
+  s.integer(swap_controllers);
+  s.integer(dip);
+}
+
+#endif
diff --git a/fc/arcade/vs/vs.cpp b/fc/arcade/vs/vs.cpp
new file mode 100644
index 0000000..b8d9c32
--- /dev/null
+++ b/fc/arcade/vs/vs.cpp
@@ -0,0 +1,74 @@
+#include <fc/fc.hpp>
+
+#define VS_ARCADE_BOARD_CPP
+namespace Famicom {
+
+VSArcadeBoard vsarcadeboard;
+
+#include "serialization.cpp"
+
+void VSArcadeBoard::init() {
+}
+
+void VSArcadeBoard::load() {
+}
+
+void VSArcadeBoard::unload() {
+}
+
+void VSArcadeBoard::power() {
+}
+
+void VSArcadeBoard::reset() {
+}
+
+void VSArcadeBoard::set_dip(uint16 dip) {
+  this->dip = dip;
+}
+
+uint8 VSArcadeBoard::read(uint16 addr) {
+  if(addr == 0x4016) return r4016();
+  if(addr == 0x4017) return r4017();
+  if(addr >= 0x4020 && addr <= 0x5fff) return r4020();
+}
+
+void VSArcadeBoard::write(uint16 addr, uint8 data) {
+  if(addr == 0x4016) w4016(data);
+  if(addr >= 0x4020 && addr <= 0x5fff) w4020(data);
+}
+
+uint8 VSArcadeBoard::r4016() {
+  uint8 data = 0x80; // 0x00 for slave CPU, 0x80 for master CPU
+  if(!swap_controllers) data |= input.port1->data() & 0x03;
+  else                  data |= input.port2->data() & 0x03;
+  data |= input.expansion->data1(); // buttons 1 and 3
+  data |= (dip & 0x03) << 3;
+  data |= input.expansion->data() << 2; // Service button and coins
+  return data;
+}
+
+uint8 VSArcadeBoard::r4017() {
+  uint8 data = 0x00;
+  if(!swap_controllers) data |= input.port2->data() & 0x03;
+  else                  data |= input.port1->data() & 0x03;
+  data |= input.expansion->data2(); // buttons 2 and 4
+  data |= dip & 0xfc;
+  return data;
+}
+
+uint8 VSArcadeBoard::r4020() {
+  write(0x4020, cpu.mdr());
+  return cpu.mdr();
+}
+
+void VSArcadeBoard::w4016(uint8 data) {
+  input.port1->latch(data & 1);
+  input.port2->latch(data & 1);
+  input.expansion->latch(data & 1);
+}
+
+void VSArcadeBoard::w4020(uint8 data) {
+  // increment coin counter
+}
+
+}
diff --git a/fc/arcade/vs/vs.hpp b/fc/arcade/vs/vs.hpp
new file mode 100644
index 0000000..11f14d0
--- /dev/null
+++ b/fc/arcade/vs/vs.hpp
@@ -0,0 +1,25 @@
+struct VSArcadeBoard {
+  bool swap_controllers;
+  uint16 dip; // 16-bit for DualSystem games
+
+  void init();
+  void load();
+  void unload();
+  void power();
+  void reset();
+
+  void set_dip(uint16 dip);
+  uint8 read(uint16 addr);
+  void write(uint16 addr, uint8 data);
+
+  void serialize(serializer& s);
+
+private:
+  uint8 r4016();
+  uint8 r4017();
+  uint8 r4020();
+  void w4016(uint8 data);
+  void w4020(uint8 data);
+};
+
+extern VSArcadeBoard vsarcadeboard;
diff --git a/fc/cartridge/board/bandai-fcg.cpp b/fc/cartridge/board/bandai-fcg.cpp
index a23ad2a..4342b4e 100644
--- a/fc/cartridge/board/bandai-fcg.cpp
+++ b/fc/cartridge/board/bandai-fcg.cpp
@@ -1,117 +1,105 @@
 //BANDAI-FCG
+//BANDAI-FCG-1
+//BANDAI-FCG-2
+//BANDAI-JUMP2
+//BANDAI-LZ93D50
 
 struct BandaiFCG : Board {
 
-uint8 chr_bank[8];
-uint8 prg_bank;
-uint2 mirror;
-bool irq_counter_enable;
-uint16 irq_counter;
-uint16 irq_latch;
+enum class Revision : unsigned {
+  FCGAll,
+  FCG1,
+  FCG2,
+  JUMP2,
+  LZ93D50,
+} revision;
 
-void main() {
-  while(true) {
-    if(scheduler.sync == Scheduler::SynchronizeMode::All) {
-      scheduler.exit(Scheduler::ExitReason::SynchronizeEvent);
-    }
+FCG fcg;
 
-    if(irq_counter_enable) {
-      if(--irq_counter == 0xffff) {
-        cpu.set_irq_line(1);
-        irq_counter_enable = false;
-      }
-    }
-
-    tick();
-  }
-}
+uint2 last_chr_bank;
 
-unsigned ciram_addr(unsigned addr) const {
-  switch(mirror) {
-  case 0: return ((addr & 0x0400) >> 0) | (addr & 0x03ff);
-  case 1: return ((addr & 0x0800) >> 1) | (addr & 0x03ff);
-  case 2: return 0x0000 | (addr & 0x03ff);
-  case 3: return 0x0400 | (addr & 0x03ff);
-  }
+void main() {
+  fcg.main();
 }
 
 uint8 prg_read(unsigned addr) {
-  if(addr & 0x8000) {
-    bool region = addr & 0x4000;
-    unsigned bank = (region == 0 ? prg_bank : 0x0f);
-    return prgrom.read((bank << 14) | (addr & 0x3fff));
+  if((addr & 0xe000) == 0x6000) {
+    switch(revision) {
+    case Revision::LZ93D50:
+      //TODO: serial EEPROM support
+      return 0x00 | (cpu.mdr() & 0xef);
+    case Revision::JUMP2:
+      return fcg.eeprom_i2c_scl ? fcg.ram_read(addr) : cpu.mdr();
+    }
+  }
+  if((addr & 0x8000) == 0x8000) {
+    if(revision != Revision::JUMP2)
+      return prgrom.read(fcg.prg_addr(addr));
+    else
+      return prgrom.read(fcg.prg_addr(addr) | ((fcg.chr_bank[last_chr_bank] & 1) << 18));
   }
   return cpu.mdr();
 }
 
 void prg_write(unsigned addr, uint8 data) {
-  if(addr >= 0x6000) {
-    switch(addr & 15) {
-    case 0x00: case 0x01: case 0x02: case 0x03:
-    case 0x04: case 0x05: case 0x06: case 0x07:
-      chr_bank[addr & 7] = data;
-      break;
-    case 0x08:
-      prg_bank = data & 0x0f;
-      break;
-    case 0x09:
-      mirror = data & 0x03;
-      break;
-    case 0x0a:
-      cpu.set_irq_line(0);
-      irq_counter_enable = data & 0x01;
-      irq_counter = irq_latch;
-      break;
-    case 0x0b:
-      irq_latch = (irq_latch & 0xff00) | (data << 0);
-      break;
-    case 0x0c:
-      irq_latch = (irq_latch & 0x00ff) | (data << 8);
-      break;
-    case 0x0d:
+  if((addr & 0xe000) == 0x6000) {
+    switch(revision) {
+    case Revision::FCGAll:
+    case Revision::FCG1:
+    case Revision::FCG2:
+      return fcg.reg_write(addr, data);
+    case Revision::LZ93D50:
       //TODO: serial EEPROM support
       break;
+    case Revision::JUMP2:
+      if(fcg.eeprom_i2c_scl) return fcg.ram_write(addr, data);
+      else                   break;
+    }
+  }
+  if((addr & 0x8000) == 0x8000) {
+    switch(revision) {
+    case Revision::FCGAll:
+    case Revision::LZ93D50:
+    case Revision::JUMP2:
+      return fcg.reg_write(addr, data);
     }
   }
 }
 
 uint8 chr_read(unsigned addr) {
-  if(addr & 0x2000) return ppu.ciram_read(ciram_addr(addr));
-  addr = (chr_bank[addr >> 10] << 10) | (addr & 0x03ff);
-  return Board::chr_read(addr);
+  if(addr & 0x2000) return ppu.ciram_read(fcg.ciram_addr(addr));
+  last_chr_bank = 0;(addr & 0x0c00) >> 10;
+  if(chrrom.size) return Board::chr_read(fcg.chr_addr(addr));
+  if(chrram.size) return Board::chr_read(addr);
 }
 
 void chr_write(unsigned addr, uint8 data) {
-  if(addr & 0x2000) return ppu.ciram_write(ciram_addr(addr), data);
-  addr = (chr_bank[addr >> 10] << 10) | (addr & 0x03ff);
-  return Board::chr_write(addr, data);
+  if(addr & 0x2000) return ppu.ciram_write(fcg.ciram_addr(addr), data);
+  last_chr_bank = 0;(addr & 0x0c00) >> 10;
+  if(chrram.size) Board::chr_write(addr, data);
 }
 
 void power() {
-  reset();
+  fcg.power();
 }
 
 void reset() {
-  for(auto &n : chr_bank) n = 0;
-  prg_bank = 0;
-  mirror = 0;
-  irq_counter_enable = 0;
-  irq_counter = 0;
-  irq_latch = 0;
+  fcg.reset();
 }
 
 void serialize(serializer& s) {
   Board::serialize(s);
-
-  s.array(chr_bank);
-  s.integer(prg_bank);
-  s.integer(mirror);
-  s.integer(irq_counter_enable);
-  s.integer(irq_counter);
-  s.integer(irq_latch);
+  fcg.serialize(s);
+  s.integer(last_chr_bank);
 }
 
-BandaiFCG(Markup::Node& document) : Board(document) {
+BandaiFCG(Markup::Node& cartridge) : Board(cartridge), fcg(*this, cartridge) {
+  string type = cartridge["board/type"].data;
+  revision = Revision::FCGAll;
+  if(type.match("*FCG-1*"  )) revision = Revision::FCG1;
+  if(type.match("*FCG-2*"  )) revision = Revision::FCG2;
+  if(type.match("*JUMP2*"  )) revision = Revision::JUMP2;
+  if(type.match("*LZ93D50*")) revision = Revision::LZ93D50;
 }
 
 };
diff --git a/fc/cartridge/board/board.cpp b/fc/cartridge/board/board.cpp
index 383ebc8..0034a12 100644
--- a/fc/cartridge/board/board.cpp
+++ b/fc/cartridge/board/board.cpp
@@ -5,9 +5,11 @@
 #include "konami-vrc4.cpp"
 #include "konami-vrc6.cpp"
 #include "konami-vrc7.cpp"
+#include "namco-163.cpp"
+#include "namco-34xx.cpp"
 #include "nes-axrom.cpp"
 #include "nes-bnrom.cpp"
-#include "nes-cnrom.cpp"
+#include "nes-cxrom.cpp"
 #include "nes-exrom.cpp"
 #include "nes-fxrom.cpp"
 #include "nes-gxrom.cpp"
@@ -17,7 +19,18 @@
 #include "nes-sxrom.cpp"
 #include "nes-txrom.cpp"
 #include "nes-uxrom.cpp"
+#include "sunsoft-4.cpp"
 #include "sunsoft-5b.cpp"
+#include "fds.cpp"
+#include "vs.cpp"
+
+// Unlicensed board definitions; feel free to remove
+#include "unlicensed/camerica.cpp"
+#include "unlicensed/colordreams-74377.cpp"
+#include "unlicensed/mlt-action52.cpp"
+#include "unlicensed/nina.cpp"
+#include "unlicensed/noconflicts-cnrom.cpp"
+#include "unlicensed/single-chip.cpp"
 
 uint8 Board::Memory::read(unsigned addr) const {
   return data[mirror(addr, size)];
@@ -51,13 +64,13 @@ void Board::main() {
       scheduler.exit(Scheduler::ExitReason::SynchronizeEvent);
     }
 
-    cartridge.clock += 12 * 4095;
+    cartridge.clock += (system.region() == System::Region::NTSC ? 12 : 16) * 4095;
     tick();
   }
 }
 
 void Board::tick() {
-  cartridge.clock += 12;
+  cartridge.clock += (system.region() == System::Region::NTSC ? 12 : 16);
   if(cartridge.clock >= 0 && scheduler.sync != Scheduler::SynchronizeMode::All) co_switch(cpu.thread);
 }
 
@@ -82,9 +95,8 @@ void Board::serialize(serializer& s) {
   if(chrram.size) s.array(chrram.data, chrram.size);
 }
 
-Board::Board(Markup::Node& document) {
-  cartridge.board = this;
-  auto cartridge = document["cartridge"];
+Board::Board(Markup::Node& cartridge) {
+  Famicom::cartridge.board = this;
 
   information.type = cartridge["board/type"].data;
   information.battery = cartridge["prg/ram/name"].exists();
@@ -119,94 +131,183 @@ Board::Board(Markup::Node& document) {
 Board::~Board() {
 }
 
-Board* Board::load(string manifest) {
-  auto document = Markup::Document(manifest);
-  cartridge.information.title = document["information/title"].text();
-
-  string type = document["cartridge/board/type"].text();
-
-  if(type == "BANDAI-FCG"  ) return new BandaiFCG(document);
-
-  if(type == "KONAMI-VRC-1") return new KonamiVRC1(document);
-  if(type == "KONAMI-VRC-2") return new KonamiVRC2(document);
-  if(type == "KONAMI-VRC-3") return new KonamiVRC3(document);
-  if(type == "KONAMI-VRC-4") return new KonamiVRC4(document);
-  if(type == "KONAMI-VRC-6") return new KonamiVRC6(document);
-  if(type == "KONAMI-VRC-7") return new KonamiVRC7(document);
-
-  if(type == "NES-AMROM"   ) return new NES_AxROM(document);
-  if(type == "NES-ANROM"   ) return new NES_AxROM(document);
-  if(type == "NES-AN1ROM"  ) return new NES_AxROM(document);
-  if(type == "NES-AOROM"   ) return new NES_AxROM(document);
-
-  if(type == "NES-BNROM"   ) return new NES_BNROM(document);
-
-  if(type == "NES-CNROM"   ) return new NES_CNROM(document);
-
-  if(type == "NES-EKROM"   ) return new NES_ExROM(document);
-  if(type == "NES-ELROM"   ) return new NES_ExROM(document);
-  if(type == "NES-ETROM"   ) return new NES_ExROM(document);
-  if(type == "NES-EWROM"   ) return new NES_ExROM(document);
-
-  if(type == "NES-FJROM"   ) return new NES_FxROM(document);
-  if(type == "NES-FKROM"   ) return new NES_FxROM(document);
-
-  if(type == "NES-GNROM"   ) return new NES_GxROM(document);
-  if(type == "NES-MHROM"   ) return new NES_GxROM(document);
-
-  if(type == "NES-HKROM"   ) return new NES_HKROM(document);
-
-  if(type == "NES-NROM"    ) return new NES_NROM(document);
-  if(type == "NES-NROM-128") return new NES_NROM(document);
-  if(type == "NES-NROM-256") return new NES_NROM(document);
-
-  if(type == "NES-PEEOROM" ) return new NES_PxROM(document);
-  if(type == "NES-PNROM"   ) return new NES_PxROM(document);
-
-  if(type == "NES-SAROM"   ) return new NES_SxROM(document);
-  if(type == "NES-SBROM"   ) return new NES_SxROM(document);
-  if(type == "NES-SCROM"   ) return new NES_SxROM(document);
-  if(type == "NES-SC1ROM"  ) return new NES_SxROM(document);
-  if(type == "NES-SEROM"   ) return new NES_SxROM(document);
-  if(type == "NES-SFROM"   ) return new NES_SxROM(document);
-  if(type == "NES-SFEXPROM") return new NES_SxROM(document);
-  if(type == "NES-SGROM"   ) return new NES_SxROM(document);
-  if(type == "NES-SHROM"   ) return new NES_SxROM(document);
-  if(type == "NES-SH1ROM"  ) return new NES_SxROM(document);
-  if(type == "NES-SIROM"   ) return new NES_SxROM(document);
-  if(type == "NES-SJROM"   ) return new NES_SxROM(document);
-  if(type == "NES-SKROM"   ) return new NES_SxROM(document);
-  if(type == "NES-SLROM"   ) return new NES_SxROM(document);
-  if(type == "NES-SL1ROM"  ) return new NES_SxROM(document);
-  if(type == "NES-SL2ROM"  ) return new NES_SxROM(document);
-  if(type == "NES-SL3ROM"  ) return new NES_SxROM(document);
-  if(type == "NES-SLRROM"  ) return new NES_SxROM(document);
-  if(type == "NES-SMROM"   ) return new NES_SxROM(document);
-  if(type == "NES-SNROM"   ) return new NES_SxROM(document);
-  if(type == "NES-SOROM"   ) return new NES_SxROM(document);
-  if(type == "NES-SUROM"   ) return new NES_SxROM(document);
-  if(type == "NES-SXROM"   ) return new NES_SxROM(document);
-
-  if(type == "NES-TBROM"   ) return new NES_TxROM(document);
-  if(type == "NES-TEROM"   ) return new NES_TxROM(document);
-  if(type == "NES-TFROM"   ) return new NES_TxROM(document);
-  if(type == "NES-TGROM"   ) return new NES_TxROM(document);
-  if(type == "NES-TKROM"   ) return new NES_TxROM(document);
-  if(type == "NES-TKSROM"  ) return new NES_TxROM(document);
-  if(type == "NES-TLROM"   ) return new NES_TxROM(document);
-  if(type == "NES-TL1ROM"  ) return new NES_TxROM(document);
-  if(type == "NES-TL2ROM"  ) return new NES_TxROM(document);
-  if(type == "NES-TLSROM"  ) return new NES_TxROM(document);
-  if(type == "NES-TNROM"   ) return new NES_TxROM(document);
-  if(type == "NES-TQROM"   ) return new NES_TxROM(document);
-  if(type == "NES-TR1ROM"  ) return new NES_TxROM(document);
-  if(type == "NES-TSROM"   ) return new NES_TxROM(document);
-  if(type == "NES-TVROM"   ) return new NES_TxROM(document);
-
-  if(type == "NES-UNROM"   ) return new NES_UxROM(document);
-  if(type == "NES-UOROM"   ) return new NES_UxROM(document);
-
-  if(type == "SUNSOFT-5B"  ) return new Sunsoft5B(document);
+Board* Board::load(Markup::Node cartridge) {
+  string type = cartridge["board/type"].text();
+
+  if(substr(type,0,4) == "HVC-" || substr(type,0,4) == "NES-") {
+    type = substr(type,4);
+    if(type == "AMROM"   ) return new NES_AxROM(cartridge);
+    if(type == "ANROM"   ) return new NES_AxROM(cartridge);
+    if(type == "AN1ROM"  ) return new NES_AxROM(cartridge);
+    if(type == "AOROM"   ) return new NES_AxROM(cartridge);
+
+    if(type == "BNROM"   ) return new NES_BNROM(cartridge);
+
+    if(type == "BTR"     ) return new Sunsoft5B(cartridge);
+
+    if(type == "CNROM"   ) return new NES_CxROM(cartridge);
+    if(type == "CPROM"   ) return new NES_CxROM(cartridge);
+
+    if(type == "DEROM"   ) return new Namco34xx(cartridge);
+    if(type == "DE1ROM"  ) return new Namco34xx(cartridge);
+    if(type == "DRROM"   ) return new Namco34xx(cartridge);
+
+    if(type == "EKROM"   ) return new NES_ExROM(cartridge);
+    if(type == "ELROM"   ) return new NES_ExROM(cartridge);
+    if(type == "ETROM"   ) return new NES_ExROM(cartridge);
+    if(type == "EWROM"   ) return new NES_ExROM(cartridge);
+
+    if(type == "FJROM"   ) return new NES_FxROM(cartridge);
+    if(type == "FKROM"   ) return new NES_FxROM(cartridge);
+
+    if(type == "GNROM"   ) return new NES_GxROM(cartridge);
+    if(type == "MHROM"   ) return new NES_GxROM(cartridge);
+
+    if(type == "HKROM"   ) return new NES_HKROM(cartridge);
+
+    if(type == "JLROM"   ) return new Sunsoft5B(cartridge);
+    if(type == "JSROM"   ) return new Sunsoft5B(cartridge);
+
+    if(type == "NROM"    ) return new NES_NROM(cartridge);
+    if(type == "NROM-128") return new NES_NROM(cartridge);
+    if(type == "NROM-256") return new NES_NROM(cartridge);
+    if(type == "HROM"    ) return new NES_NROM(cartridge);
+    if(type == "RROM"    ) return new NES_NROM(cartridge);
+    if(type == "RROM-128") return new NES_NROM(cartridge);
+    if(type == "RTROM"   ) return new NES_NROM(cartridge);
+    if(type == "SROM"    ) return new NES_NROM(cartridge);
+    if(type == "STROM"   ) return new NES_NROM(cartridge);
+
+    if(type == "PEEOROM" ) return new NES_PxROM(cartridge);
+    if(type == "PNROM"   ) return new NES_PxROM(cartridge);
+
+    if(type == "SAROM"   ) return new NES_SxROM(cartridge);
+    if(type == "SBROM"   ) return new NES_SxROM(cartridge);
+    if(type == "SCROM"   ) return new NES_SxROM(cartridge);
+    if(type == "SC1ROM"  ) return new NES_SxROM(cartridge);
+    if(type == "SEROM"   ) return new NES_SxROM(cartridge);
+    if(type == "SFROM"   ) return new NES_SxROM(cartridge);
+    if(type == "SFEXPROM") return new NES_SxROM(cartridge);
+    if(type == "SGROM"   ) return new NES_SxROM(cartridge);
+    if(type == "SHROM"   ) return new NES_SxROM(cartridge);
+    if(type == "SH1ROM"  ) return new NES_SxROM(cartridge);
+    if(type == "SIROM"   ) return new NES_SxROM(cartridge);
+    if(type == "SJROM"   ) return new NES_SxROM(cartridge);
+    if(type == "SKROM"   ) return new NES_SxROM(cartridge);
+    if(type == "SLROM"   ) return new NES_SxROM(cartridge);
+    if(type == "SL1ROM"  ) return new NES_SxROM(cartridge);
+    if(type == "SL2ROM"  ) return new NES_SxROM(cartridge);
+    if(type == "SL3ROM"  ) return new NES_SxROM(cartridge);
+    if(type == "SLRROM"  ) return new NES_SxROM(cartridge);
+    if(type == "SMROM"   ) return new NES_SxROM(cartridge);
+    if(type == "SNROM"   ) return new NES_SxROM(cartridge);
+    if(type == "SNWEPROM") return new NES_SxROM(cartridge);
+    if(type == "SOROM"   ) return new NES_SxROM(cartridge);
+    if(type == "SUROM"   ) return new NES_SxROM(cartridge);
+    if(type == "SXROM"   ) return new NES_SxROM(cartridge);
+
+    if(type == "TBROM"   ) return new NES_TxROM(cartridge);
+    if(type == "TEROM"   ) return new NES_TxROM(cartridge);
+    if(type == "TFROM"   ) return new NES_TxROM(cartridge);
+    if(type == "TGROM"   ) return new NES_TxROM(cartridge);
+    if(type == "TKROM"   ) return new NES_TxROM(cartridge);
+    if(type == "TKSROM"  ) return new NES_TxROM(cartridge);
+    if(type == "TLROM"   ) return new NES_TxROM(cartridge);
+    if(type == "TL1ROM"  ) return new NES_TxROM(cartridge);
+    if(type == "TL2ROM"  ) return new NES_TxROM(cartridge);
+    if(type == "TLSROM"  ) return new NES_TxROM(cartridge);
+    if(type == "TNROM"   ) return new NES_TxROM(cartridge);
+    if(type == "TQROM"   ) return new NES_TxROM(cartridge);
+    if(type == "TR1ROM"  ) return new NES_TxROM(cartridge);
+    if(type == "TSROM"   ) return new NES_TxROM(cartridge);
+    if(type == "TVROM"   ) return new NES_TxROM(cartridge);
+
+    if(type == "UNROM"   ) return new NES_UxROM(cartridge);
+    if(type == "UOROM"   ) return new NES_UxROM(cartridge);
+  }
+
+  if(type == "ACCLAIM-MC-ACC") return new NES_TxROM(cartridge);
+
+  if(type == "AVE-NINA-01") return new Nina(cartridge);
+  if(type == "AVE-NINA-02") return new Nina(cartridge);
+  if(type == "AVE-NINA-03") return new Nina(cartridge);
+  if(type == "AVE-NINA-06") return new Nina(cartridge);
+
+  if(type == "BANDAI-74*161/32") return new NES_CxROM(cartridge);
+  if(type == "BANDAI-CNROM"    ) return new NES_CxROM(cartridge);
+  if(type == "BANDAI-FCG"      ) return new BandaiFCG(cartridge);
+  if(type == "BANDAI-FCG-1"    ) return new BandaiFCG(cartridge);
+  if(type == "BANDAI-FCG-2"    ) return new BandaiFCG(cartridge);
+  if(type == "BANDAI-GNROM"    ) return new NES_GxROM(cartridge);
+  if(type == "BANDAI-JUMP2"    ) return new BandaiFCG(cartridge);
+  if(type == "BANDAI-LZ93D50"  ) return new BandaiFCG(cartridge);
+  if(type == "BANDAI-NROM-128" ) return new NES_NROM(cartridge);
+  if(type == "BANDAI-NROM-256" ) return new NES_NROM(cartridge);
+  if(type == "BANDAI-PT-544"   ) return new NES_CxROM(cartridge);
+
+  if(type == "IREM-BNROM"   ) return new NES_BNROM(cartridge);
+  if(type == "IREM-FCG-1"   ) return new BandaiFCG(cartridge);
+  if(type == "IREM-NROM-128") return new NES_NROM(cartridge);
+  if(type == "IREM-NROM-256") return new NES_NROM(cartridge);
+  if(type == "IREM-UNROM"   ) return new NES_UxROM(cartridge);
+  //TODO:
+  //IREM-G101 (iNES 032)
+  //IREM-H3001 (iNES 065)
+  //IREM-74*161/161/21/138 (iNES 077)
+  //IREM-HOLYDIVER (iNES 078)
+  //IREM-TAM-S1 (iNES 097)
+
+  if(type == "KONAMI-CNROM"   ) return new NES_CxROM(cartridge);
+  if(type == "KONAMI-NROM-128") return new NES_NROM(cartridge);
+  if(type == "KONAMI-SLROM"   ) return new NES_SxROM(cartridge);
+  if(type == "KONAMI-TLROM"   ) return new NES_TxROM(cartridge);
+  if(type == "KONAMI-UNROM"   ) return new NES_UxROM(cartridge);
+  if(type == "KONAMI-VRC-1"   ) return new KonamiVRC1(cartridge);
+  if(type == "KONAMI-VRC-2"   ) return new KonamiVRC2(cartridge);
+  if(type == "KONAMI-VRC-3"   ) return new KonamiVRC3(cartridge);
+  if(type == "KONAMI-VRC-4"   ) return new KonamiVRC4(cartridge);
+  if(type == "KONAMI-VRC-6"   ) return new KonamiVRC6(cartridge);
+  if(type == "KONAMI-VRC-7"   ) return new KonamiVRC7(cartridge);
+
+  if(type == "NAMCOT-163" ) return new Namco163(cartridge);
+  if(type == "NAMCOT-3301") return new NES_NROM(cartridge);
+  if(type == "NAMCOT-3302") return new NES_NROM(cartridge);
+  if(type == "NAMCOT-3305") return new NES_NROM(cartridge);
+  if(type == "NAMCOT-3311") return new NES_NROM(cartridge);
+  if(type == "NAMCOT-3312") return new NES_NROM(cartridge);
+  if(type == "NAMCOT-3401") return new Namco34xx(cartridge);
+  if(type == "NAMCOT-3406") return new Namco34xx(cartridge);
+  if(type == "NAMCOT-3407") return new Namco34xx(cartridge);
+  if(type == "NAMCOT-3416") return new Namco34xx(cartridge);
+  if(type == "NAMCOT-3417") return new Namco34xx(cartridge);
+  if(type == "NAMCOT-3443") return new Namco34xx(cartridge);
+  if(type == "NAMCOT-3446") return new Namco34xx(cartridge);
+  if(type == "NAMCOT-3453") return new Namco34xx(cartridge);
+
+  if(type == "SUNSOFT-4" ) return new Sunsoft4(cartridge);
+  if(type == "SUNSOFT-5B") return new Sunsoft5B(cartridge);
+
+  if(type == "FDS") return new FDS(cartridge);
+  if(type == "VS" ) return new VS(cartridge);
+
+  // Unlicensed boards below; feel free to remove
+  if(type == "CAMERICA-ALGN"     ) return new Camerica(cartridge);
+  if(type == "CAMERICA-ALGQ"     ) return new Camerica(cartridge);
+  if(type == "CAMERICA-BF9093"   ) return new Camerica(cartridge);
+  if(type == "CAMERICA-BF9096"   ) return new Camerica(cartridge);
+  if(type == "CAMERICA-BF9097"   ) return new Camerica(cartridge);
+  if(type == "CODEMASTERS-NR8N"  ) return new Camerica(cartridge);
+  if(type == "COLORDREAMS-74*377") return new ColorDreams74377(cartridge);
+  if(type == "MLT-ACTION52"      ) return new MLT_Action52(cartridge);
+  if(type == "TENGEN-800002"     ) return new Namco34xx(cartridge);
+  if(type == "TENGEN-800003"     ) return new NES_NROM(cartridge);
+  if(type == "TENGEN-800004"     ) return new Namco34xx(cartridge);
+  if(type == "TENGEN-800008"     ) return new NES_CxROM(cartridge);
+  if(type == "TENGEN-800030"     ) return new Namco34xx(cartridge);
+  if(type == "TENGEN-800042"     ) return new Sunsoft4(cartridge);
+  // Homebrew boards; feel free to remove
+  if(type == "NoConflicts-CNROM") return new NoConflicts_CNROM(cartridge);
+  if(type == "SingleChip") return new SingleChip(cartridge);
 
   return nullptr;
 }
diff --git a/fc/cartridge/board/board.hpp b/fc/cartridge/board/board.hpp
index 8910631..29ec610 100644
--- a/fc/cartridge/board/board.hpp
+++ b/fc/cartridge/board/board.hpp
@@ -29,10 +29,10 @@ struct Board {
   virtual void reset();
 
   virtual void serialize(serializer&);
-  Board(Markup::Node& document);
+  Board(Markup::Node& cartridge);
   virtual ~Board();
 
-  static Board* load(string manifest);
+  static Board* load(Markup::Node cartridge);
 
   struct Information {
     string type;
diff --git a/fc/cartridge/board/fds.cpp b/fc/cartridge/board/fds.cpp
new file mode 100644
index 0000000..5e97922
--- /dev/null
+++ b/fc/cartridge/board/fds.cpp
@@ -0,0 +1,67 @@
+struct FDS : Board {
+
+uint16 irq_timer = 0x0000;
+uint8 fds_control = 0x2E;
+bool irq_enable = false;
+uint2 io_enable = 0b00;
+
+uint8 prg_read(unsigned addr) {
+  switch(addr) {
+  case 0x4032:
+    // 0x01: 0=Disk inserted;       1=Disk ejected
+    // 0x02: 0=Disk ready;          1=Disk not ready
+    // 0x04: 0=Not write protected; 1=Write protected (on if disk ejected)
+    return 0x07;
+  case 0x4033: return 0x00; // 7-bit expansion input; 0x80 means low battery
+  }
+  switch(addr & 0xe000) {
+  case 0x6000:
+  case 0x8000:
+  case 0xa000:
+  case 0xc000: return prgram.read(addr);
+  case 0xe000: return prgrom.read(addr);
+  }
+  return cpu.mdr();
+}
+
+void prg_write(unsigned addr, uint8 data) {
+  switch(addr) {
+  case 0x4020: irq_timer &= 0xff00 | data;
+  case 0x4021: irq_timer &= 0x00ff | (data << 8);
+  case 0x4022: irq_enable = data & 0x02;
+  case 0x4023: io_enable = data & 0x03;
+  case 0x4025: fds_control = data;
+  }
+  switch(addr & 0xe000) {
+  case 0x6000:
+  case 0x8000:
+  case 0xa000:
+  case 0xc000: prgram.write(addr,data); break;
+  }
+}
+
+uint8 chr_read(unsigned addr) {
+  if(addr & 0x2000) {
+    if(fds_control & 0x08) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    return ppu.ciram_read(addr & 0x07ff);
+  }
+  if(chrram.size) return chrram.read(addr);
+  return chrrom.read(addr);
+}
+
+void chr_write(unsigned addr, uint8 data) {
+  if(addr & 0x2000) {
+    if(fds_control & 0x08) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    return ppu.ciram_write(addr & 0x07ff, data);
+  }
+  if(chrram.size) return chrram.write(addr, data);
+}
+
+void serialize(serializer& s) {
+  Board::serialize(s);
+}
+
+FDS(Markup::Node& cartridge) : Board(cartridge) {
+}
+
+};
diff --git a/fc/cartridge/board/konami-vrc1.cpp b/fc/cartridge/board/konami-vrc1.cpp
index b91c2d8..6fe2256 100644
--- a/fc/cartridge/board/konami-vrc1.cpp
+++ b/fc/cartridge/board/konami-vrc1.cpp
@@ -34,7 +34,7 @@ void serialize(serializer& s) {
   vrc1.serialize(s);
 }
 
-KonamiVRC1(Markup::Node& document) : Board(document), vrc1(*this) {
+KonamiVRC1(Markup::Node& cartridge) : Board(cartridge), vrc1(*this) {
 }
 
 };
diff --git a/fc/cartridge/board/konami-vrc2.cpp b/fc/cartridge/board/konami-vrc2.cpp
index 826ac31..0363d62 100644
--- a/fc/cartridge/board/konami-vrc2.cpp
+++ b/fc/cartridge/board/konami-vrc2.cpp
@@ -4,6 +4,7 @@ struct Settings {
   struct Pinout {
     unsigned a0;
     unsigned a1;
+    unsigned chr_shift;
   } pinout;
 } settings;
 
@@ -28,7 +29,9 @@ void prg_write(unsigned addr, uint8 data) {
 
 uint8 chr_read(unsigned addr) {
   if(addr & 0x2000) return ppu.ciram_read(vrc2.ciram_addr(addr));
-  return Board::chr_read(vrc2.chr_addr(addr));
+  addr = vrc2.chr_addr(addr);
+  addr = ((addr >> settings.pinout.chr_shift) & ~0x3ff) | (addr & 0x3ff);
+  return Board::chr_read(addr);
 }
 
 void chr_write(unsigned addr, uint8 data) {
@@ -49,9 +52,10 @@ void serialize(serializer& s) {
   vrc2.serialize(s);
 }
 
-KonamiVRC2(Markup::Node& document) : Board(document), vrc2(*this) {
-  settings.pinout.a0 = 1 << decimal(document["cartridge"]["chip"]["pinout"]["a0"].data);
-  settings.pinout.a1 = 1 << decimal(document["cartridge"]["chip"]["pinout"]["a1"].data);
+KonamiVRC2(Markup::Node& cartridge) : Board(cartridge), vrc2(*this) {
+  settings.pinout.a0 = 1 << decimal(cartridge["chip/pinout/a0"].data);
+  settings.pinout.a1 = 1 << decimal(cartridge["chip/pinout/a1"].data);
+  settings.pinout.chr_shift = decimal(cartridge["chip/pinout/chr-shift"].data);
 }
 
 };
diff --git a/fc/cartridge/board/konami-vrc3.cpp b/fc/cartridge/board/konami-vrc3.cpp
index accda1a..e03f27f 100644
--- a/fc/cartridge/board/konami-vrc3.cpp
+++ b/fc/cartridge/board/konami-vrc3.cpp
@@ -50,8 +50,8 @@ void serialize(serializer& s) {
   vrc3.serialize(s);
 }
 
-KonamiVRC3(Markup::Node& document) : Board(document), vrc3(*this) {
-  settings.mirror = document["cartridge"]["mirror"]["mode"].data == "vertical" ? 1 : 0;
+KonamiVRC3(Markup::Node& cartridge) : Board(cartridge), vrc3(*this) {
+  settings.mirror = cartridge["mirror/mode"].data == "vertical" ? 1 : 0;
 }
 
 };
diff --git a/fc/cartridge/board/konami-vrc4.cpp b/fc/cartridge/board/konami-vrc4.cpp
index a9988af..fe48132 100644
--- a/fc/cartridge/board/konami-vrc4.cpp
+++ b/fc/cartridge/board/konami-vrc4.cpp
@@ -25,7 +25,7 @@ void prg_write(unsigned addr, uint8 data) {
 
   bool a0 = (addr & settings.pinout.a0);
   bool a1 = (addr & settings.pinout.a1);
-  addr &= 0xfff0;
+  addr &= 0xff00;
   addr |= (a1 << 1) | (a0 << 0);
   return vrc4.reg_write(addr, data);
 }
@@ -53,9 +53,9 @@ void serialize(serializer& s) {
   vrc4.serialize(s);
 }
 
-KonamiVRC4(Markup::Node& document) : Board(document), vrc4(*this) {
-  settings.pinout.a0 = 1 << decimal(document["cartridge"]["chip"]["pinout"]["a0"].data);
-  settings.pinout.a1 = 1 << decimal(document["cartridge"]["chip"]["pinout"]["a1"].data);
+KonamiVRC4(Markup::Node& cartridge) : Board(cartridge), vrc4(*this) {
+  settings.pinout.a0 = 1 << decimal(cartridge["chip/pinout/a0"].data);
+  settings.pinout.a1 = 1 << decimal(cartridge["chip/pinout/a1"].data);
 }
 
 };
diff --git a/fc/cartridge/board/konami-vrc6.cpp b/fc/cartridge/board/konami-vrc6.cpp
index f4e5e95..36132a2 100644
--- a/fc/cartridge/board/konami-vrc6.cpp
+++ b/fc/cartridge/board/konami-vrc6.cpp
@@ -1,20 +1,29 @@
 struct KonamiVRC6 : Board {
 
+struct Settings {
+  struct Pinout {
+    unsigned a0;
+    unsigned a1;
+  } pinout;
+} settings;
+
 VRC6 vrc6;
 
 uint8 prg_read(unsigned addr) {
-  if((addr & 0xe000) == 0x6000) return vrc6.ram_read(addr);
-  if(addr & 0x8000) return prgrom.read(vrc6.prg_addr(addr));
-  return cpu.mdr();
+  if(addr < 0x6000) return cpu.mdr();
+  if(addr < 0x8000) return vrc6.ram_read(addr);
+  return prgrom.read(vrc6.prg_addr(addr));
 }
 
 void prg_write(unsigned addr, uint8 data) {
-  if((addr & 0xe000) == 0x6000) return vrc6.ram_write(addr, data);
-  if(addr & 0x8000) {
-    addr = (addr & 0xf003);
-    if(prgram.size) addr = (addr & ~3) | ((addr & 2) >> 1) | ((addr & 1) << 1);
-    return vrc6.reg_write(addr, data);
-  }
+  if(addr < 0x6000) return;
+  if(addr < 0x8000) return vrc6.ram_write(addr, data);
+
+  bool a0 = (addr & settings.pinout.a0);
+  bool a1 = (addr & settings.pinout.a1);
+  addr &= 0xf000;
+  addr |= (a1 << 1) | (a0 << 0);
+  return vrc6.reg_write(addr, data);
 }
 
 uint8 chr_read(unsigned addr) {
@@ -36,7 +45,9 @@ void main() { vrc6.main(); }
 void power() { vrc6.power(); }
 void reset() { vrc6.reset(); }
 
-KonamiVRC6(Markup::Node& document) : Board(document), vrc6(*this) {
+KonamiVRC6(Markup::Node& cartridge) : Board(cartridge), vrc6(*this) {
+  settings.pinout.a0 = 1 << decimal(cartridge["chip/pinout/a0"].data);
+  settings.pinout.a1 = 1 << decimal(cartridge["chip/pinout/a1"].data);
 }
 
 };
diff --git a/fc/cartridge/board/konami-vrc7.cpp b/fc/cartridge/board/konami-vrc7.cpp
index 8c72a3f..9664fa3 100644
--- a/fc/cartridge/board/konami-vrc7.cpp
+++ b/fc/cartridge/board/konami-vrc7.cpp
@@ -41,7 +41,7 @@ void serialize(serializer& s) {
   vrc7.serialize(s);
 }
 
-KonamiVRC7(Markup::Node& document) : Board(document), vrc7(*this) {
+KonamiVRC7(Markup::Node& cartridge) : Board(cartridge), vrc7(*this) {
 }
 
 };
diff --git a/fc/cartridge/board/namco-163.cpp b/fc/cartridge/board/namco-163.cpp
new file mode 100644
index 0000000..1706cd7
--- /dev/null
+++ b/fc/cartridge/board/namco-163.cpp
@@ -0,0 +1,133 @@
+struct Namco163 : Board {
+
+uint6 prg_bank[3];
+uint8 chr_bank[12];
+uint15 irq_counter;
+bool irq_enable;
+uint2 mirror;
+uint2 chrram_disable;
+
+uint8 prg_read(unsigned addr) {
+  switch(addr & 0xf800) {
+  case 0x4800: break; // Audio
+  case 0x5000: return irq_counter & 0xff;
+  case 0x5800: return ((irq_counter >> 8) & 0x7f) | (irq_enable << 7);
+  case 0x6000: case 0x6800: case 0x7000: case 0x7800:
+    return prgram.read(addr & 0x1fff);
+  case 0x8000: case 0x8800: case 0x9000: case 0x9800:
+  case 0xa000: case 0xa800: case 0xb000: case 0xb800:
+  case 0xc000: case 0xc800: case 0xd000: case 0xd800:
+    return prgrom.read((prg_bank[(addr & 0x6000) >> 13] << 13) | (addr & 0x1fff));
+  case 0xe000: case 0xe800: case 0xf000: case 0xf800:
+    return prgrom.read((0x3f << 13) | (addr & 0x1fff));
+  default: return cpu.mdr();
+  }
+}
+
+void prg_write(unsigned addr, uint8 data) {
+  switch(addr & 0xf800) {
+  case 0x4800: break; // Audio
+  case 0x5000: // IRQ Low
+    irq_counter = (irq_counter & ~0xff) | data;
+    break;
+  case 0x5800: // IRQ High
+    irq_counter = (irq_counter & 0xff) | ((data & 0x7f) << 8);
+    irq_enable = data & 0x80;
+    break;
+  case 0x6000: case 0x6800: case 0x7000: case 0x7800:
+    prgram.data[addr & 0x1fff] = data;
+    break;
+  case 0x8000: case 0x8800: case 0x9000: case 0x9800: // CHR Select
+  case 0xa000: case 0xa800: case 0xb000: case 0xb800:
+  case 0xc000: case 0xc800: case 0xd000: case 0xd800: // Nametable Select
+    chr_bank[(addr & 0x7800) >> 11] = data;
+    break;
+  case 0xe000: // PRG Select 8000
+    prg_bank[0] = data & 0x3f;
+    mirror = (data & 0xc0) >> 6;
+    break;
+  case 0xe800: // PRG Select A000
+    prg_bank[1] = data & 0x3f;
+    chrram_disable = (data & 0xc0) >> 6;
+    break;
+  case 0xf000: // PRG Select C000
+    prg_bank[2] = data & 0x3f;
+    break;
+  case 0xf800: // Write Protection for External RAM
+    break;
+  }
+}
+
+unsigned ciram_addr(unsigned addr) {
+  bool nt;
+  switch(mirror) {
+  case 0: nt = 0; break;
+  case 1: nt = addr & 0x400; break;
+  case 2: nt = addr & 0x800; break;
+  case 3: nt = 1; break;
+  }
+  return (addr & 0x03ff) | (nt << 10);
+}
+
+uint8 chr_read(unsigned addr) {
+  if(addr & 0x2000) return ppu.ciram_read(ciram_addr(addr));
+  uint8 bank = chr_bank[(addr & 0x1c00) >> 10];
+  if(bank >= 0xe0 && chrram_disable & (1 << ((addr & 0x1000) >> 12))) {
+    if(chrram.size) return chrram.read(addr);
+    else            return ppu.ciram_read(ciram_addr(addr));
+  } else return chrrom.read((bank << 10) | (addr & 0x3ff));
+}
+
+void chr_write(unsigned addr, uint8 data) {
+  if(addr & 0x2000) return ppu.ciram_write(ciram_addr(addr), data);
+  uint8 bank = chr_bank[(addr & 0x1c00) >> 10];
+  if(bank >= 0xe0 && chrram_disable & (1 << ((addr & 0x1000) >> 12))) {
+    if(chrram.size) return chrram.write(addr, data);
+    else            return ppu.ciram_write(ciram_addr(addr), data);
+  }
+}
+
+void serialize(serializer& s) {
+  Board::serialize(s);
+}
+
+void main() {
+  while(true) {
+    if(irq_enable && irq_counter != 0x7fff) {
+      irq_counter++;
+      if(irq_counter == 0x7fff) cpu.set_irq_line(1);
+    }
+
+    tick();
+  }
+}
+
+void power() {
+}
+
+void reset() {
+  prg_bank[0] = 0;
+  prg_bank[1] = 0;
+  prg_bank[2] = 0;
+  chr_bank[0] = 0;
+  chr_bank[1] = 0;
+  chr_bank[2] = 0;
+  chr_bank[3] = 0;
+  chr_bank[4] = 0;
+  chr_bank[5] = 0;
+  chr_bank[6] = 0;
+  chr_bank[7] = 0;
+  chr_bank[8] = 0;
+  chr_bank[9] = 0;
+  chr_bank[10] = 0;
+  chr_bank[11] = 0;
+  irq_counter = 0;
+  irq_enable = false;
+  mirror = 0;
+  chrram_disable = 0;
+}
+
+Namco163(Markup::Node& cartridge) : Board(cartridge) {
+}
+
+};
diff --git a/fc/cartridge/board/namco-34xx.cpp b/fc/cartridge/board/namco-34xx.cpp
new file mode 100644
index 0000000..55d3fa0
--- /dev/null
+++ b/fc/cartridge/board/namco-34xx.cpp
@@ -0,0 +1,128 @@
+//NAMCOT-3401
+//NAMCOT-3406
+//NAMCOT-3407
+//NAMCOT-3416
+//NAMCOT-3425
+//NAMCOT-3443
+//NAMCOT-3446
+//NAMCOT-3453
+//NES-DEROM
+//NES-DE1ROM
+//NES-DRROM
+
+struct Namco34xx : Board {
+
+enum class Revision : unsigned {
+  Namco3401, // bankswitching used even if PRG is 32KB (バベルの塔/Tower of Babel)
+  Namco3406,
+  Namco3407,
+  Namco3416,
+  Namco3425,
+  Namco3443,
+  Namco3446,
+  Namco3453,
+  DEROM,
+  DE1ROM,
+  DRROM,
+} revision;
+
+struct Settings {
+  bool mirror;  //0 = vertical, 1 = horizontal
+} settings;
+
+Namco108 namco108;
+
+bool nametable; // for Namco3453, used only by Devil Man
+
+unsigned prg_addr(unsigned addr) {
+  if(revision == Revision::Namco3401 || prgrom.size > 0x8000) return namco108.prg_addr(addr);
+  else return addr & 0x7fff;
+}
+
+uint8 prg_read(unsigned addr) {
+  if(addr & 0x8000) return prgrom.read(prg_addr(addr));
+  return cpu.mdr();
+}
+
+void prg_write(unsigned addr, uint8 data) {
+  if(addr & 0x8000) {
+    namco108.reg_write(addr, data);
+    if(revision == Revision::Namco3453) nametable = data & 0x40;
+  }
+}
+
+unsigned chr_addr(unsigned addr) {
+  switch(revision) {
+  case Revision::Namco3443:
+  case Revision::Namco3453:
+    return namco108.chr_addr(addr) | ((addr & 0x1000) << 4);
+  case Revision::Namco3446:
+    if(addr <= 0x07ff) return (namco108.chr_addr(0x1000) << 1) | (addr & 0x07ff);
+    if(addr <= 0x0fff) return (namco108.chr_addr(0x1400) << 1) | (addr & 0x07ff);
+    if(addr <= 0x17ff) return (namco108.chr_addr(0x1800) << 1) | (addr & 0x07ff);
+    if(addr <= 0x1fff) return (namco108.chr_addr(0x1c00) << 1) | (addr & 0x07ff);
+  default:
+    return namco108.chr_addr(addr);
+  }
+}
+
+uint8 chr_read(unsigned addr) {
+  if(revision == Revision::DRROM) {
+    if(addr & 0x2000) return chrram.data[mirror(addr & 0x0FFF, chrram.size)];
+    return chrrom.data[mirror(namco108.chr_addr(addr), chrrom.size)];
+  }
+  if(addr & 0x2000) return ppu.ciram_read(ciram_addr(addr));
+  return Board::chr_read(chr_addr(addr));
+}
+
+void chr_write(unsigned addr, uint8 data) {
+  if(revision == Revision::DRROM) {
+    if(addr & 0x2000) chrram.data[mirror(addr & 0x0FFF, chrram.size)] = data;
+    return;
+  }
+  if(addr & 0x2000) return ppu.ciram_write(ciram_addr(addr), data);
+  return Board::chr_write(chr_addr(addr), data);
+}
+
+unsigned ciram_addr(unsigned addr) const {
+  switch(revision) {
+  case Revision::Namco3425:
+    return ((namco108.chr_addr(addr) & 0x8000) >> 5) | (addr & 0x03ff);
+  case Revision::Namco3453:
+    return (addr & 0x03ff) | (nametable ? 0x0400 : 0x0000);
+  default:
+    if(settings.mirror == 0) return ((addr & 0x0400) >> 0) | (addr & 0x03ff);
+    if(settings.mirror == 1) return ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+  }
+}
+
+void reset() {
+  nametable = 0;
+}
+
+void serialize(serializer& s) {
+  Board::serialize(s);
+}
+
+Namco34xx(Markup::Node& cartridge) : Board(cartridge), namco108(*this, cartridge) {
+  string type = cartridge["board/type"].data;
+  if(type.match("*3401*")) revision = Revision::Namco3401;
+  if(type.match("*3406*")) revision = Revision::Namco3406;
+  if(type.match("*3407*")) revision = Revision::Namco3407;
+  if(type.match("*3416*")) revision = Revision::Namco3416;
+  if(type.match("*3425*")) revision = Revision::Namco3425;
+  if(type.match("*3443*")) revision = Revision::Namco3443;
+  if(type.match("*3446*")) revision = Revision::Namco3446;
+  if(type.match("*3453*")) revision = Revision::Namco3453;
+  if(type.match("*DEROM*")) revision = Revision::DEROM;
+  if(type.match("*DE1ROM*")) revision = Revision::DE1ROM;
+  if(type.match("*DRROM*")) revision = Revision::DRROM;
+  if(type.match("*TENGEN-800002*")) revision = Revision::DEROM;
+  if(type.match("*TENGEN-800030*")) revision = Revision::DE1ROM;
+  if(type.match("*TENGEN-800004*")) revision = Revision::DRROM;
+
+  if(revision != Revision::Namco3425 && revision != Revision::Namco3453)
+    settings.mirror = cartridge["mirror/mode"].data == "horizontal";
+}
+
+};
diff --git a/fc/cartridge/board/nes-axrom.cpp b/fc/cartridge/board/nes-axrom.cpp
index 6d468cf..34dc46a 100644
--- a/fc/cartridge/board/nes-axrom.cpp
+++ b/fc/cartridge/board/nes-axrom.cpp
@@ -5,6 +5,13 @@
 
 struct NES_AxROM : Board {
 
+enum class Revision : unsigned {
+  AMROM,
+  ANROM,
+  AN1ROM,
+  AOROM,
+} revision;
+
 uint4 prg_bank;
 bool mirror_select;
 
@@ -15,6 +22,8 @@ uint8 prg_read(unsigned addr) {
 
 void prg_write(unsigned addr, uint8 data) {
   if(addr & 0x8000) {
+    // Bus conflicts
+    if(revision == Revision::AMROM) data &= prg_read(addr);
     prg_bank = data & 0x0f;
     mirror_select = data & 0x10;
   }
@@ -45,7 +54,12 @@ void serialize(serializer& s) {
   s.integer(mirror_select);
 }
 
-NES_AxROM(Markup::Node& document) : Board(document) {
+NES_AxROM(Markup::Node& cartridge) : Board(cartridge) {
+  string type = cartridge["board/type"].data;
+  if(type.match("*AMROM*" )) revision = Revision::AMROM;
+  if(type.match("*ANROM*" )) revision = Revision::ANROM;
+  if(type.match("*AN1ROM*")) revision = Revision::AN1ROM;
+  if(type.match("*AOROM*" )) revision = Revision::AOROM;
 }
 
 };
diff --git a/fc/cartridge/board/nes-bnrom.cpp b/fc/cartridge/board/nes-bnrom.cpp
index 41723c1..9b61bbf 100644
--- a/fc/cartridge/board/nes-bnrom.cpp
+++ b/fc/cartridge/board/nes-bnrom.cpp
@@ -1,9 +1,10 @@
-//NES-BN-ROM-01
+//IREM-BNROM
+//NES-BNROM
 
 struct NES_BNROM : Board {
 
 struct Settings {
-  bool mirror;  //0 = horizontal, 1 = vertical
+  bool mirror;  //0 = vertical, 1 = horizontal
 } settings;
 
 uint2 prg_bank;
@@ -14,12 +15,16 @@ uint8 prg_read(unsigned addr) {
 }
 
 void prg_write(unsigned addr, uint8 data) {
-  if(addr & 0x8000) prg_bank = data & 0x03;
+  if(addr & 0x8000) {
+    // Bus conflicts
+    data &= prg_read(addr);
+    prg_bank = data & 0x03;
+  }
 }
 
 uint8 chr_read(unsigned addr) {
   if(addr & 0x2000) {
-    if(settings.mirror == 0) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    if(settings.mirror == 1) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
     return ppu.ciram_read(addr);
   }
   return Board::chr_read(addr);
@@ -27,7 +32,7 @@ uint8 chr_read(unsigned addr) {
 
 void chr_write(unsigned addr, uint8 data) {
   if(addr & 0x2000) {
-    if(settings.mirror == 0) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    if(settings.mirror == 1) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
     return ppu.ciram_write(addr, data);
   }
   return Board::chr_write(addr, data);
@@ -45,8 +50,8 @@ void serialize(serializer& s) {
   s.integer(prg_bank);
 }
 
-NES_BNROM(Markup::Node& document) : Board(document) {
-  settings.mirror = document["cartridge"]["mirror"]["mode"].data == "vertical" ? 1 : 0;
+NES_BNROM(Markup::Node& cartridge) : Board(cartridge) {
+  settings.mirror = cartridge["mirror/mode"].data == "horizontal";
 }
 
 };
diff --git a/fc/cartridge/board/nes-cnrom.cpp b/fc/cartridge/board/nes-cnrom.cpp
deleted file mode 100644
index aafc7bd..0000000
--- a/fc/cartridge/board/nes-cnrom.cpp
+++ /dev/null
@@ -1,54 +0,0 @@
-//NES-CNROM
-
-struct NES_CNROM : Board {
-
-struct Settings {
-  bool mirror;  //0 = horizontal, 1 = vertical
-} settings;
-
-uint2 chr_bank;
-
-uint8 prg_read(unsigned addr) {
-  if(addr & 0x8000) return prgrom.read(addr & 0x7fff);
-  return cpu.mdr();
-}
-
-void prg_write(unsigned addr, uint8 data) {
-  if(addr & 0x8000) chr_bank = data & 0x03;
-}
-
-uint8 chr_read(unsigned addr) {
-  if(addr & 0x2000) {
-    if(settings.mirror == 0) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
-    return ppu.ciram_read(addr & 0x07ff);
-  }
-  addr = (chr_bank * 0x2000) + (addr & 0x1fff);
-  return Board::chr_read(addr);
-}
-
-void chr_write(unsigned addr, uint8 data) {
-  if(addr & 0x2000) {
-    if(settings.mirror == 0) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
-    return ppu.ciram_write(addr & 0x07ff, data);
-  }
-  addr = (chr_bank * 0x2000) + (addr & 0x1fff);
-  Board::chr_write(addr, data);
-}
-
-void power() {
-}
-
-void reset() {
-  chr_bank = 0;
-}
-
-void serialize(serializer& s) {
-  Board::serialize(s);
-  s.integer(chr_bank);
-}
-
-NES_CNROM(Markup::Node& document) : Board(document) {
-  settings.mirror = document["cartridge"]["mirror"]["mode"].data == "vertical" ? 1 : 0;
-}
-
-};
diff --git a/fc/cartridge/board/nes-cxrom.cpp b/fc/cartridge/board/nes-cxrom.cpp
new file mode 100644
index 0000000..239a629
--- /dev/null
+++ b/fc/cartridge/board/nes-cxrom.cpp
@@ -0,0 +1,92 @@
+//NES-CNROM
+//NES-CPROM
+
+struct NES_CxROM : Board {
+
+enum class Revision : unsigned {
+  CNROM,
+  CPROM,
+} revision;
+
+struct Settings {
+  bool mirror;  //0 = vertical, 1 = horizontal
+  bool security;
+  uint2 pass;
+} settings;
+
+uint2 chr_bank;
+
+uint8 prg_read(unsigned addr) {
+  if(addr & 0x8000) return prgrom.read(addr & 0x7fff);
+  return cpu.mdr();
+}
+
+void prg_write(unsigned addr, uint8 data) {
+  if(addr & 0x8000) {
+    data &= prg_read(addr); // Bus conflicts
+    chr_bank = data & 0x03;
+  }
+}
+
+uint8 chr_read(unsigned addr) {
+  if(addr & 0x2000) {
+    if(settings.mirror == 1) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    return ppu.ciram_read(addr & 0x07ff);
+  }
+  if(settings.security) {
+    if(chr_bank != settings.pass) return ppu.status.mdr;
+  }
+  switch(revision) {
+  case Revision::CNROM:
+    addr = (chr_bank * 0x2000) + (addr & 0x1fff);
+    break;
+  case Revision::CPROM:
+    if(addr < 0x1000) addr = addr & 0x1fff;
+    else              addr = (chr_bank * 0x1000) + (addr & 0x0fff);
+    break;
+  }
+  return Board::chr_read(addr);
+}
+
+void chr_write(unsigned addr, uint8 data) {
+  if(addr & 0x2000) {
+    if(settings.mirror == 1) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    return ppu.ciram_write(addr & 0x07ff, data);
+  }
+  switch(revision) {
+  case Revision::CNROM:
+    addr = (chr_bank * 0x2000) + (addr & 0x1fff);
+    break;
+  case Revision::CPROM:
+    if(addr < 0x1000) addr = addr & 0x1fff;
+    else              addr = (chr_bank * 0x1000) + (addr & 0x0fff);
+    break;
+  }
+  Board::chr_write(addr, data);
+}
+
+void power() {
+}
+
+void reset() {
+  chr_bank = 0;
+}
+
+void serialize(serializer& s) {
+  Board::serialize(s);
+  s.integer(chr_bank);
+}
+
+NES_CxROM(Markup::Node& cartridge) : Board(cartridge) {
+  string type = cartridge["board/type"].data;
+  if(type.match("*CNROM*")) revision = Revision::CNROM;
+  if(type.match("*CPROM*")) revision = Revision::CPROM;
+
+  settings.mirror = cartridge["mirror/mode"].data == "horizontal";
+  settings.security = cartridge["board/security"].exists();
+  if(settings.security) {
+    settings.pass = cartridge["board/security/pass"].integer();
+  }
+}
+
+};
diff --git a/fc/cartridge/board/nes-exrom.cpp b/fc/cartridge/board/nes-exrom.cpp
index 42bd56c..b94e38e 100644
--- a/fc/cartridge/board/nes-exrom.cpp
+++ b/fc/cartridge/board/nes-exrom.cpp
@@ -46,8 +46,12 @@ void serialize(serializer& s) {
   mmc5.serialize(s);
 }
 
-NES_ExROM(Markup::Node& document) : Board(document), mmc5(*this) {
-  revision = Revision::ELROM;
+NES_ExROM(Markup::Node& cartridge) : Board(cartridge), mmc5(*this, cartridge) {
+  string type = cartridge["board/type"].data;
+  if(type.match("*EKROM*")) revision = Revision::EKROM;
+  if(type.match("*ELROM*")) revision = Revision::ELROM;
+  if(type.match("*ETROM*")) revision = Revision::ETROM;
+  if(type.match("*EWROM*")) revision = Revision::EWROM;
 }
 
 };
diff --git a/fc/cartridge/board/nes-fxrom.cpp b/fc/cartridge/board/nes-fxrom.cpp
index 2c79e50..916397b 100644
--- a/fc/cartridge/board/nes-fxrom.cpp
+++ b/fc/cartridge/board/nes-fxrom.cpp
@@ -84,8 +84,10 @@ void serialize(serializer& s) {
   s.array(latch);
 }
 
-NES_FxROM(Markup::Node& document) : Board(document) {
-  revision = Revision::FKROM;
+NES_FxROM(Markup::Node& cartridge) : Board(cartridge) {
+  string type = cartridge["board/type"].data;
+  if(type.match("*FJROM*" )) revision = Revision::FJROM;
+  if(type.match("*FKROM*" )) revision = Revision::FKROM;
 }
 
 };
diff --git a/fc/cartridge/board/nes-gxrom.cpp b/fc/cartridge/board/nes-gxrom.cpp
index 36548d1..57099e9 100644
--- a/fc/cartridge/board/nes-gxrom.cpp
+++ b/fc/cartridge/board/nes-gxrom.cpp
@@ -4,7 +4,7 @@
 struct NES_GxROM : Board {
 
 struct Settings {
-  bool mirror;  //0 = horizontal, 1 = vertical
+  bool mirror;  //0 = vertical, 1 = horizontal
 } settings;
 
 uint2 prg_bank;
@@ -17,6 +17,8 @@ uint8 prg_read(unsigned addr) {
 
 void prg_write(unsigned addr, uint8 data) {
   if(addr & 0x8000) {
+    // Bus conflicts
+    data &= prg_read(addr);
     prg_bank = (data & 0x30) >> 4;
     chr_bank = (data & 0x03) >> 0;
   }
@@ -24,7 +26,7 @@ void prg_write(unsigned addr, uint8 data) {
 
 uint8 chr_read(unsigned addr) {
   if(addr & 0x2000) {
-    if(settings.mirror == 0) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    if(settings.mirror == 1) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
     return ppu.ciram_read(addr & 0x07ff);
   }
   addr = (chr_bank * 0x2000) + (addr & 0x1fff);
@@ -33,7 +35,7 @@ uint8 chr_read(unsigned addr) {
 
 void chr_write(unsigned addr, uint8 data) {
   if(addr & 0x2000) {
-    if(settings.mirror == 0) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    if(settings.mirror == 1) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
     return ppu.ciram_write(addr & 0x07ff, data);
   }
   addr = (chr_bank * 0x2000) + (addr & 0x1fff);
@@ -54,8 +56,8 @@ void serialize(serializer& s) {
   s.integer(chr_bank);
 }
 
-NES_GxROM(Markup::Node& document) : Board(document) {
-  settings.mirror = document["cartridge"]["mirror"]["mode"].data == "vertical" ? 1 : 0;
+NES_GxROM(Markup::Node& cartridge) : Board(cartridge) {
+  settings.mirror = cartridge["mirror/mode"].data == "horizontal";
 }
 
 };
diff --git a/fc/cartridge/board/nes-hkrom.cpp b/fc/cartridge/board/nes-hkrom.cpp
index 660785e..ec98ed7 100644
--- a/fc/cartridge/board/nes-hkrom.cpp
+++ b/fc/cartridge/board/nes-hkrom.cpp
@@ -42,7 +42,7 @@ void serialize(serializer& s) {
   mmc6.serialize(s);
 }
 
-NES_HKROM(Markup::Node& document) : Board(document), mmc6(*this) {
+NES_HKROM(Markup::Node& cartridge) : Board(cartridge), mmc6(*this) {
 }
 
 };
diff --git a/fc/cartridge/board/nes-nrom.cpp b/fc/cartridge/board/nes-nrom.cpp
index 490d209..f01084c 100644
--- a/fc/cartridge/board/nes-nrom.cpp
+++ b/fc/cartridge/board/nes-nrom.cpp
@@ -1,23 +1,44 @@
+//NES-FAMILYBASIC
+//NES-HROM
 //NES-NROM-128
 //NES-NROM-256
+//NES-RROM
+//NES-RROM-128
+//NES-RTROM
+//NES-SROM
+//NES-STROM
 
 struct NES_NROM : Board {
 
+enum class Revision : unsigned {
+  FAMILYBASIC,
+  HROM,
+  NROM,
+  RROM,
+  RTROM,
+  SROM,
+  STROM,
+} revision;
+
 struct Settings {
-  bool mirror;  //0 = horizontal, 1 = vertical
+  bool mirror;  //0 = vertical, 1 = horizontal
 } settings;
 
 uint8 prg_read(unsigned addr) {
-  if(addr & 0x8000) return prgrom.read(addr);
+  if((addr & 0x8000) == 0x8000) return prgrom.read(addr);
+  if(revision == Revision::FAMILYBASIC && (addr & 0xe000) == 0x6000)
+    return prgram.read(addr);
   return cpu.mdr();
 }
 
 void prg_write(unsigned addr, uint8 data) {
+  if(revision == Revision::FAMILYBASIC && (addr & 0xe000) == 0x6000)
+    prgram.write(addr, data);
 }
 
 uint8 chr_read(unsigned addr) {
   if(addr & 0x2000) {
-    if(settings.mirror == 0) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    if(settings.mirror == 1) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
     return ppu.ciram_read(addr & 0x07ff);
   }
   if(chrram.size) return chrram.read(addr);
@@ -26,7 +47,7 @@ uint8 chr_read(unsigned addr) {
 
 void chr_write(unsigned addr, uint8 data) {
   if(addr & 0x2000) {
-    if(settings.mirror == 0) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    if(settings.mirror == 1) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
     return ppu.ciram_write(addr & 0x07ff, data);
   }
   if(chrram.size) return chrram.write(addr, data);
@@ -36,8 +57,16 @@ void serialize(serializer& s) {
   Board::serialize(s);
 }
 
-NES_NROM(Markup::Node& document) : Board(document) {
-  settings.mirror = document["cartridge"]["mirror"]["mode"].data == "vertical" ? 1 : 0;
+NES_NROM(Markup::Node& cartridge) : Board(cartridge) {
+  string type = cartridge["board/type"].data;
+  if(type.match("*FAMILYBASIC*")) revision = Revision::FAMILYBASIC;
+  if(type.match("*HROM*"       )) revision = Revision::HROM;
+  if(type.match("*RROM*"       )) revision = Revision::RROM;
+  if(type.match("*SROM*"       )) revision = Revision::SROM;
+  if(revision == Revision::HROM)
+    settings.mirror = 0;
+  else
+    settings.mirror = cartridge["mirror/mode"].data == "horizontal";
 }
 
 };
diff --git a/fc/cartridge/board/nes-pxrom.cpp b/fc/cartridge/board/nes-pxrom.cpp
index f6b0510..f46b668 100644
--- a/fc/cartridge/board/nes-pxrom.cpp
+++ b/fc/cartridge/board/nes-pxrom.cpp
@@ -90,8 +90,10 @@ void serialize(serializer& s) {
   s.array(latch);
 }
 
-NES_PxROM(Markup::Node& document) : Board(document) {
-  revision = Revision::PNROM;
+NES_PxROM(Markup::Node& cartridge) : Board(cartridge) {
+  string type = cartridge["board/type"].data;
+  if(type.match("*PEEOROM*")) revision = Revision::PEEOROM;
+  if(type.match("*PNROM*"  )) revision = Revision::PNROM;
 }
 
 };
diff --git a/fc/cartridge/board/nes-sxrom.cpp b/fc/cartridge/board/nes-sxrom.cpp
index 7f51a6b..34dd0dc 100644
--- a/fc/cartridge/board/nes-sxrom.cpp
+++ b/fc/cartridge/board/nes-sxrom.cpp
@@ -7,6 +7,7 @@ enum class Revision : unsigned {
   SC1ROM,
   SEROM,
   SFROM,
+  SFEXPROM,
   SGROM,
   SHROM,
   SH1ROM,
@@ -20,6 +21,7 @@ enum class Revision : unsigned {
   SLRROM,
   SMROM,
   SNROM,
+  SNWEPROM,
   SOROM,
   SUROM,
   SXROM,
@@ -27,8 +29,10 @@ enum class Revision : unsigned {
 
 MMC1 mmc1;
 
+bool last_chr_bank;
+
 void main() {
-  return mmc1.main();
+  mmc1.main();
 }
 
 unsigned ram_addr(unsigned addr) {
@@ -42,16 +46,24 @@ unsigned ram_addr(unsigned addr) {
 uint8 prg_read(unsigned addr) {
   if((addr & 0xe000) == 0x6000) {
     if(revision == Revision::SNROM) {
-      if(mmc1.chr_bank[0] & 0x10) return cpu.mdr();
+      if(mmc1.chr_bank[last_chr_bank] & 0x10) return cpu.mdr();
     }
     if(mmc1.ram_disable) return 0x00;
-    return prgram.read(ram_addr(addr));
+    if(prgram.size > 0) return prgram.read(ram_addr(addr));
   }
 
   if(addr & 0x8000) {
-    addr = mmc1.prg_addr(addr);
-    if(revision == Revision::SXROM) {
-      addr |= ((mmc1.chr_bank[0] & 0x10) >> 4) << 18;
+    switch(revision) {
+      case Revision::SEROM:
+      case Revision::SHROM:
+      case Revision::SH1ROM:
+        break;
+      default:
+        addr = mmc1.prg_addr(addr);
+        if(revision == Revision::SUROM || revision == Revision::SXROM) {
+          addr |= ((mmc1.chr_bank[last_chr_bank] & 0x10) >> 4) << 18;
+        }
+        break;
     }
     return prgrom.read(addr);
   }
@@ -65,7 +77,7 @@ void prg_write(unsigned addr, uint8 data) {
       if(mmc1.chr_bank[0] & 0x10) return;
     }
     if(mmc1.ram_disable) return;
-    return prgram.write(ram_addr(addr), data);
+    if(prgram.size > 0) return prgram.write(ram_addr(addr), data);
   }
 
   if(addr & 0x8000) return mmc1.mmio_write(addr, data);
@@ -73,11 +85,13 @@ void prg_write(unsigned addr, uint8 data) {
 
 uint8 chr_read(unsigned addr) {
   if(addr & 0x2000) return ppu.ciram_read(mmc1.ciram_addr(addr));
+  last_chr_bank = mmc1.chr_mode ? ((addr & 0x1000) >> 12) : 0;
   return Board::chr_read(mmc1.chr_addr(addr));
 }
 
 void chr_write(unsigned addr, uint8 data) {
   if(addr & 0x2000) return ppu.ciram_write(mmc1.ciram_addr(addr), data);
+  last_chr_bank = mmc1.chr_mode ? ((addr & 0x1000) >> 12) : 0;
   return Board::chr_write(mmc1.chr_addr(addr), data);
 }
 
@@ -92,10 +106,35 @@ void reset() {
 void serialize(serializer& s) {
   Board::serialize(s);
   mmc1.serialize(s);
+  s.integer(last_chr_bank);
 }
 
-NES_SxROM(Markup::Node& document) : Board(document), mmc1(*this) {
-  revision = Revision::SXROM;
+NES_SxROM(Markup::Node& cartridge) : Board(cartridge), mmc1(*this, cartridge) {
+  string type = cartridge["board/type"].data;
+  if(type.match("*SAROM*"   )) revision = Revision::SAROM;
+  if(type.match("*SBROM*"   )) revision = Revision::SBROM;
+  if(type.match("*SCROM*"   )) revision = Revision::SCROM;
+  if(type.match("*SC1ROM*"  )) revision = Revision::SC1ROM;
+  if(type.match("*SEROM*"   )) revision = Revision::SEROM;
+  if(type.match("*SFROM*"   )) revision = Revision::SFROM;
+  if(type.match("*SFEXPROM*")) revision = Revision::SFEXPROM;
+  if(type.match("*SGROM*"   )) revision = Revision::SGROM;
+  if(type.match("*SHROM*"   )) revision = Revision::SHROM;
+  if(type.match("*SH1ROM*"  )) revision = Revision::SH1ROM;
+  if(type.match("*SIROM*"   )) revision = Revision::SIROM;
+  if(type.match("*SJROM*"   )) revision = Revision::SJROM;
+  if(type.match("*SKROM*"   )) revision = Revision::SKROM;
+  if(type.match("*SLROM*"   )) revision = Revision::SLROM;
+  if(type.match("*SL1ROM*"  )) revision = Revision::SL1ROM;
+  if(type.match("*SL2ROM*"  )) revision = Revision::SL2ROM;
+  if(type.match("*SL3ROM*"  )) revision = Revision::SL3ROM;
+  if(type.match("*SLRROM*"  )) revision = Revision::SLRROM;
+  if(type.match("*SMROM*"   )) revision = Revision::SMROM;
+  if(type.match("*SNROM*"   )) revision = Revision::SNROM;
+  if(type.match("*SNWEPROM*")) revision = Revision::SNWEPROM;
+  if(type.match("*SOROM*"   )) revision = Revision::SOROM;
+  if(type.match("*SUROM*"   )) revision = Revision::SUROM;
+  if(type.match("*SXROM*"   )) revision = Revision::SXROM;
 }
 
 };
diff --git a/fc/cartridge/board/nes-txrom.cpp b/fc/cartridge/board/nes-txrom.cpp
index ee36d55..82bc359 100644
--- a/fc/cartridge/board/nes-txrom.cpp
+++ b/fc/cartridge/board/nes-txrom.cpp
@@ -16,6 +16,7 @@ enum class Revision : unsigned {
   TR1ROM,
   TSROM,
   TVROM,
+  MCACC,
 } revision;
 
 MMC3 mmc3;
@@ -25,28 +26,52 @@ void main() {
 }
 
 uint8 prg_read(unsigned addr) {
-  if((addr & 0xe000) == 0x6000) return mmc3.ram_read(addr);
+  if((addr & 0xe000) == 0x6000 && prgram.size > 0) return mmc3.ram_read(addr);
   if(addr & 0x8000) return prgrom.read(mmc3.prg_addr(addr));
   return cpu.mdr();
 }
 
 void prg_write(unsigned addr, uint8 data) {
-  if((addr & 0xe000) == 0x6000) return mmc3.ram_write(addr, data);
+  if((addr & 0xe000) == 0x6000 && prgram.size > 0) return mmc3.ram_write(addr, data);
   if(addr & 0x8000) return mmc3.reg_write(addr, data);
 }
 
 uint8 chr_read(unsigned addr) {
   mmc3.irq_test(addr);
-  if(addr & 0x2000) return ppu.ciram_read(mmc3.ciram_addr(addr));
+  if(revision == Revision::TR1ROM || revision == Revision::TVROM) {
+    if(addr & 0x2000) return chrram.data[mirror(addr & 0x0FFF, chrram.size)];
+    return chrrom.data[mirror(mmc3.chr_addr(addr), chrrom.size)];
+  }
+  if(addr & 0x2000) return ppu.ciram_read(ciram_addr(addr));
+  if(revision == Revision::TQROM) {
+    if(mmc3.chr_addr(addr) & (0x40 << 10))
+      return chrram.data[mirror(mmc3.chr_addr(addr), chrram.size)];
+    else
+      return chrrom.data[mirror(mmc3.chr_addr(addr), chrrom.size)];
+  }
   return Board::chr_read(mmc3.chr_addr(addr));
 }
 
 void chr_write(unsigned addr, uint8 data) {
   mmc3.irq_test(addr);
-  if(addr & 0x2000) return ppu.ciram_write(mmc3.ciram_addr(addr), data);
+  if(revision == Revision::TR1ROM || revision == Revision::TVROM) {
+    if(addr & 0x2000) chrram.data[mirror(addr & 0x0FFF, chrram.size)] = data;
+    return;
+  }
+  if(addr & 0x2000) return ppu.ciram_write(ciram_addr(addr), data);
   return Board::chr_write(mmc3.chr_addr(addr), data);
 }
 
+unsigned ciram_addr(unsigned addr) {
+  switch(revision) {
+  default:
+    return mmc3.ciram_addr(addr);
+  case Revision::TKSROM:
+  case Revision::TLSROM:
+    return ((mmc3.chr_addr(addr & 0xfff) & 0x20000) >> 7) | (addr & 0x3ff);
+  }
+}
+
 void power() {
   mmc3.power();
 }
@@ -60,8 +85,24 @@ void serialize(serializer& s) {
   mmc3.serialize(s);
 }
 
-NES_TxROM(Markup::Node& document) : Board(document), mmc3(*this) {
-  revision = Revision::TLROM;
+NES_TxROM(Markup::Node& cartridge) : Board(cartridge), mmc3(*this, cartridge) {
+  string type = cartridge["board/type"].data;
+  if(type.match("*TBROM*" )) revision = Revision::TBROM;
+  if(type.match("*TEROM*" )) revision = Revision::TEROM;
+  if(type.match("*TFROM*" )) revision = Revision::TFROM;
+  if(type.match("*TGROM*" )) revision = Revision::TGROM;
+  if(type.match("*TKROM*" )) revision = Revision::TKROM;
+  if(type.match("*TKSROM*")) revision = Revision::TKSROM;
+  if(type.match("*TLROM*" )) revision = Revision::TLROM;
+  if(type.match("*TL1ROM*")) revision = Revision::TL1ROM;
+  if(type.match("*TL2ROM*")) revision = Revision::TL2ROM;
+  if(type.match("*TLSROM*")) revision = Revision::TLSROM;
+  if(type.match("*TNROM*" )) revision = Revision::TNROM;
+  if(type.match("*TQROM*" )) revision = Revision::TQROM;
+  if(type.match("*TR1ROM*")) revision = Revision::TR1ROM;
+  if(type.match("*TSROM*" )) revision = Revision::TSROM;
+  if(type.match("*TVROM*" )) revision = Revision::TVROM;
+  if(type.match("*MC-ACC*")) revision = Revision::MCACC;
 }
 
 };
diff --git a/fc/cartridge/board/nes-uxrom.cpp b/fc/cartridge/board/nes-uxrom.cpp
index 7aced28..83f1acd 100644
--- a/fc/cartridge/board/nes-uxrom.cpp
+++ b/fc/cartridge/board/nes-uxrom.cpp
@@ -4,24 +4,35 @@
 struct NES_UxROM : Board {
 
 struct Settings {
-  bool mirror;  //0 = horizontal, 1 = vertical
+  bool mirror;    //0 = vertical, 1 = horizontal
+  bool chip_type; //0 = 74HC32, 1 = 74HC08
 } settings;
 
 uint4 prg_bank;
 
 uint8 prg_read(unsigned addr) {
-  if((addr & 0xc000) == 0x8000) return prgrom.read((prg_bank << 14) | (addr & 0x3fff));
-  if((addr & 0xc000) == 0xc000) return prgrom.read((    0x0f << 14) | (addr & 0x3fff));
-  return cpu.mdr();
+  if((addr & 0x8000) == 0x0000) return cpu.mdr();
+  switch(settings.chip_type) {
+  case 0:
+    if((addr & 0xc000) == 0x8000) return prgrom.read((prg_bank << 14) | (addr & 0x3fff));
+    else                          return prgrom.read((    0x0f << 14) | (addr & 0x3fff));
+  case 1:
+    if((addr & 0xc000) == 0x8000) return prgrom.read((    0x00 << 14) | (addr & 0x3fff));
+    else                          return prgrom.read((prg_bank << 14) | (addr & 0x3fff));
+  }
 }
 
 void prg_write(unsigned addr, uint8 data) {
-  if(addr & 0x8000) prg_bank = data & 0x0f;
+  if(addr & 0x8000) {
+    // Bus conflicts
+    data &= prg_read(addr);
+    prg_bank = data & 0x0f;
+  }
 }
 
 uint8 chr_read(unsigned addr) {
   if(addr & 0x2000) {
-    if(settings.mirror == 0) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    if(settings.mirror == 1) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
     return ppu.ciram_read(addr);
   }
   return Board::chr_read(addr);
@@ -29,7 +40,7 @@ uint8 chr_read(unsigned addr) {
 
 void chr_write(unsigned addr, uint8 data) {
   if(addr & 0x2000) {
-    if(settings.mirror == 0) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    if(settings.mirror == 1) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
     return ppu.ciram_write(addr, data);
   }
   return Board::chr_write(addr, data);
@@ -48,8 +59,9 @@ void serialize(serializer& s) {
   s.integer(prg_bank);
 }
 
-NES_UxROM(Markup::Node& document) : Board(document) {
-  settings.mirror = document["cartridge"]["mirror"]["mode"].data == "vertical" ? 1 : 0;
+NES_UxROM(Markup::Node& cartridge) : Board(cartridge) {
+  settings.mirror = cartridge["mirror/mode"].data == "horizontal";
+  settings.chip_type = cartridge["chip/type"].data == "74HC08" ? 1 : 0;
 }
 
 };
diff --git a/fc/cartridge/board/sunsoft-4.cpp b/fc/cartridge/board/sunsoft-4.cpp
new file mode 100644
index 0000000..15f5727
--- /dev/null
+++ b/fc/cartridge/board/sunsoft-4.cpp
@@ -0,0 +1,87 @@
+//SUNSOFT-4
+
+struct Sunsoft4 : Board {
+
+uint8 chr_bank[4];
+uint7 ntrom_bank[2];
+uint2 mirror;
+bool nametable_mode;
+uint8 prg_bank;
+
+uint8 prg_read(unsigned addr) {
+  if((addr & 0xc000) == 0x8000) return prgrom.read((prg_bank << 14) | (addr & 0x3fff));
+  if((addr & 0xc000) == 0xc000) return prgrom.read((    0xff << 14) | (addr & 0x3fff));
+  return cpu.mdr();
+}
+
+void prg_write(unsigned addr, uint8 data) {
+  switch(addr & 0xf000) {
+  case 0x8000: chr_bank[0] = data; break;
+  case 0x9000: chr_bank[1] = data; break;
+  case 0xa000: chr_bank[2] = data; break;
+  case 0xb000: chr_bank[3] = data; break;
+  case 0xc000: ntrom_bank[0] = data | 0x80; break;
+  case 0xd000: ntrom_bank[1] = data | 0x80; break;
+  case 0xe000:
+    mirror = data & 0x03;
+    nametable_mode = data & 0x10;
+    break;
+  case 0xf000: prg_bank = data; break;
+  }
+}
+
+unsigned ciram_addr(unsigned addr) {
+  switch(mirror) {
+  case 0: return ((addr & 0x0400) >> 0) | (addr & 0x03ff);
+  case 1: return ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+  case 2: return 0x0000 | (addr & 0x03ff);
+  case 3: return 0x0400 | (addr & 0x03ff);
+  }
+}
+
+uint8 chr_read(unsigned addr) {
+  if(addr & 0x2000) {
+    addr = ciram_addr(addr);
+    if(nametable_mode) return Board::chr_read(((ntrom_bank[(addr & 0x0400) >> 10] | 0x80) << 10) | (addr & 0x03FF));
+    else               return ppu.ciram_read(addr);
+  }
+  addr = (chr_bank[(addr & 0x1800) >> 11] << 11) | (addr & 0x07ff);
+  return Board::chr_read(addr);
+}
+
+void chr_write(unsigned addr, uint8 data) {
+  if(addr & 0x2000) {
+    if(nametable_mode == 0) return ppu.ciram_write(ciram_addr(addr), data);
+  } else {
+    return Board::chr_write(addr, data);
+  }
+}
+
+void power() {
+}
+
+void reset() {
+  chr_bank[0] = 0;
+  chr_bank[1] = 0;
+  chr_bank[2] = 0;
+  chr_bank[3] = 0;
+  ntrom_bank[0] = 0;
+  ntrom_bank[1] = 0;
+  mirror = 0;
+  nametable_mode = 0;
+  prg_bank = 0;
+}
+
+void serialize(serializer& s) {
+  Board::serialize(s);
+  s.array(chr_bank);
+  s.array(ntrom_bank);
+  s.integer(mirror);
+  s.integer(nametable_mode);
+  s.integer(prg_bank);
+}
+
+Sunsoft4(Markup::Node& cartridge) : Board(cartridge) {
+}
+
+};
diff --git a/fc/cartridge/board/sunsoft-5b.cpp b/fc/cartridge/board/sunsoft-5b.cpp
index bbfc418..2216539 100644
--- a/fc/cartridge/board/sunsoft-5b.cpp
+++ b/fc/cartridge/board/sunsoft-5b.cpp
@@ -220,7 +220,7 @@ void serialize(serializer& s) {
   pulse[2].serialize(s);
 }
 
-Sunsoft5B(Markup::Node& document) : Board(document) {
+Sunsoft5B(Markup::Node& cartridge) : Board(cartridge) {
 }
 
 };
diff --git a/fc/cartridge/board/unlicensed/camerica.cpp b/fc/cartridge/board/unlicensed/camerica.cpp
new file mode 100644
index 0000000..da7fe6a
--- /dev/null
+++ b/fc/cartridge/board/unlicensed/camerica.cpp
@@ -0,0 +1,105 @@
+struct Camerica : Board {
+
+enum class Revision : unsigned {
+  ALGN, // Aladdin Game Enhancer
+  ALGQ, // Aladdin Game Enhancer (Quattro Multicarts)
+  BF9093,
+  BF9096,
+  BF9097,
+} revision;
+
+struct Settings {
+  bool mirror;    //0 = vertical, 1 = horizontal
+} settings;
+
+uint4 prg_bank;
+uint2 prg_block; // for ALGQ and BF9096
+bool nametable; // for BF9097
+
+uint8 prg_read(unsigned addr) {
+  if((addr & 0x8000) == 0x0000) return cpu.mdr();
+  if((addr & 0xc000) == 0x8000) {
+    return prgrom.read((prg_block << 16) | (prg_bank << 14) | (addr & 0x3fff));
+  } else {
+    if(revision != Revision::ALGQ && revision != Revision::BF9096)
+      return prgrom.read((0x0f << 14) | (addr & 0x3fff));
+    else
+      return prgrom.read((prg_block << 16) | (0x03 << 14) | (addr & 0x3fff));
+  }
+}
+
+void prg_write(unsigned addr, uint8 data) {
+  switch(revision) {
+  case Revision::ALGQ:
+  case Revision::BF9096:
+    if((addr & 0xc000) == 0x8000) {
+      prg_block = (data & 0x18) >> 3;
+    }
+    break;
+  case Revision::BF9097:
+    if((addr & 0xe000) == 0x8000) {
+      nametable = data & 0x10;
+    }
+    break;
+  }
+  if((addr & 0xc000) == 0xc000) {
+    switch(revision) {
+    case Revision::ALGN:
+    case Revision::BF9093: prg_bank = data & 0x0f; break;
+    case Revision::ALGQ:
+    case Revision::BF9096: prg_bank = data & 0x03; break;
+    case Revision::BF9097: prg_bank = data & 0x07; break;
+    }
+  }
+}
+
+uint8 chr_read(unsigned addr) {
+  if(addr & 0x2000) return ppu.ciram_read(ciram_addr(addr));
+  return Board::chr_read(addr);
+}
+
+void chr_write(unsigned addr, uint8 data) {
+  if(addr & 0x2000) return ppu.ciram_write(ciram_addr(addr), data);
+  return Board::chr_write(addr, data);
+}
+
+unsigned ciram_addr(unsigned addr) const {
+  if(revision != Revision::BF9097) {
+    switch(settings.mirror) {
+    case 0: return ((addr & 0x0400) >> 0) | (addr & 0x03ff);
+    case 1: return ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    }
+  } else {
+    return (addr & 0x03ff) | (nametable << 10);
+  }
+}
+
+void power() {
+}
+
+void reset() {
+  prg_bank = 0;
+  prg_block = 0;
+  nametable = 0;
+}
+
+void serialize(serializer& s) {
+  Board::serialize(s);
+
+  s.integer(prg_bank);
+  s.integer(prg_block);
+  s.integer(nametable);
+}
+
+Camerica(Markup::Node& cartridge) : Board(cartridge) {
+  string type = cartridge["board/type"].data;
+  if(type.match("*ALGN*"  )) revision = Revision::ALGN;
+  if(type.match("*ALGQ*"  )) revision = Revision::ALGQ;
+  if(type.match("*BF9093*")) revision = Revision::BF9093;
+  if(type.match("*BF9096*")) revision = Revision::BF9096;
+  if(type.match("*BF9097*")) revision = Revision::BF9097;
+
+  settings.mirror = cartridge["mirror/mode"].data == "horizontal";
+}
+
+};
diff --git a/fc/cartridge/board/unlicensed/colordreams-74377.cpp b/fc/cartridge/board/unlicensed/colordreams-74377.cpp
new file mode 100644
index 0000000..62fc472
--- /dev/null
+++ b/fc/cartridge/board/unlicensed/colordreams-74377.cpp
@@ -0,0 +1,64 @@
+//COLORDREAMS-74*377
+
+struct ColorDreams74377 : Board {
+
+struct Settings {
+  bool mirror;  //0 = vertical, 1 = horizontal
+} settings;
+
+uint2 prg_bank;
+uint4 chr_bank;
+
+uint8 prg_read(unsigned addr) {
+  if(addr & 0x8000) return prgrom.read((prg_bank << 15) | (addr & 0x7fff));
+  return cpu.mdr();
+}
+
+void prg_write(unsigned addr, uint8 data) {
+  if(addr & 0x8000) {
+    // Bus conflicts
+    data &= prg_read(addr);
+    // PRG and CHR bits are swapped relative to NES-GxROM.
+    // Additionally, up to 16 CHR banks are available instead of 4.
+    prg_bank = (data & 0x03) >> 0;
+    chr_bank = (data & 0xf0) >> 4;
+  }
+}
+
+uint8 chr_read(unsigned addr) {
+  if(addr & 0x2000) {
+    if(settings.mirror == 1) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    return ppu.ciram_read(addr & 0x07ff);
+  }
+  addr = (chr_bank * 0x2000) + (addr & 0x1fff);
+  return Board::chr_read(addr);
+}
+
+void chr_write(unsigned addr, uint8 data) {
+  if(addr & 0x2000) {
+    if(settings.mirror == 1) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    return ppu.ciram_write(addr & 0x07ff, data);
+  }
+  addr = (chr_bank * 0x2000) + (addr & 0x1fff);
+  Board::chr_write(addr, data);
+}
+
+void power() {
+}
+
+void reset() {
+  prg_bank = 0;
+  chr_bank = 0;
+}
+
+void serialize(serializer& s) {
+  Board::serialize(s);
+  s.integer(prg_bank);
+  s.integer(chr_bank);
+}
+
+ColorDreams74377(Markup::Node& cartridge) : Board(cartridge) {
+  settings.mirror = cartridge["mirror/mode"].data == "horizontal";
+}
+
+};
diff --git a/fc/cartridge/board/unlicensed/mlt-action52.cpp b/fc/cartridge/board/unlicensed/mlt-action52.cpp
new file mode 100644
index 0000000..1bc6567
--- /dev/null
+++ b/fc/cartridge/board/unlicensed/mlt-action52.cpp
@@ -0,0 +1,82 @@
+//MLT-ACTION52
+
+struct MLT_Action52 : Board {
+
+struct Settings {
+  uint4 connected_chips;
+  uint2 chip_map[4];
+} settings;
+
+bool mirror;
+uint2 prg_chip;
+uint5 prg_bank;
+bool prg_mode;
+uint6 chr_bank;
+
+uint8 prg_read(unsigned addr) {
+  if(addr & 0x8000 && settings.connected_chips & (1 << prg_chip)) {
+    unsigned target_bank = prg_bank;
+    target_bank |= settings.chip_map[prg_chip] << 5;
+    if(prg_mode) return prgrom.read((target_bank << 14) | (addr & 0x3fff));
+    else         return prgrom.read((target_bank << 14) | (addr & 0x7fff));
+  }
+  return cpu.mdr();
+}
+
+void prg_write(unsigned addr, uint8 data) {
+  if(addr & 0x8000) {
+    mirror = (addr & 0x2000) >> 13;
+    prg_chip = (addr & 0x1800) >> 11;
+    prg_bank = (addr & 0x07c0) >> 6;
+    prg_mode = (addr & 0x0020) >> 5;
+    chr_bank = ((addr & 0x000f) << 2) + (data & 0x03);
+  }
+}
+
+uint8 chr_read(unsigned addr) {
+  if(addr & 0x2000) {
+    if(mirror) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    return ppu.ciram_read(addr & 0x07ff);
+  }
+  addr = (chr_bank * 0x2000) + (addr & 0x1fff);
+  return Board::chr_read(addr);
+}
+
+void chr_write(unsigned addr, uint8 data) {
+  if(addr & 0x2000) {
+    if(mirror) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    return ppu.ciram_write(addr & 0x07ff, data);
+  }
+  addr = (chr_bank * 0x2000) + (addr & 0x1fff);
+  Board::chr_write(addr, data);
+}
+
+void power() {
+}
+
+void reset() {
+  mirror = 0;
+  prg_chip = 0;
+  prg_bank = 0;
+  prg_mode = 0;
+  chr_bank = 0;
+}
+
+void serialize(serializer &s) {
+  Board::serialize(s);
+  s.integer(mirror);
+  s.integer(prg_chip);
+  s.integer(prg_bank);
+  s.integer(prg_mode);
+  s.integer(chr_bank);
+}
+
+MLT_Action52(Markup::Node& cartridge) : Board(cartridge) {
+  settings.connected_chips = numeral(cartridge["board/connected-chips"].data);
+  uint2 chip_block = 0;
+  for(unsigned chip_id = 0; chip_id < 4; chip_id++) {
+    if(settings.connected_chips & (0x1 << chip_id)) settings.chip_map[chip_id] = chip_block++;
+  }
+}
+
+};
diff --git a/fc/cartridge/board/unlicensed/nina.cpp b/fc/cartridge/board/unlicensed/nina.cpp
new file mode 100644
index 0000000..a053268
--- /dev/null
+++ b/fc/cartridge/board/unlicensed/nina.cpp
@@ -0,0 +1,94 @@
+//AVE-NINA-01
+//AVE-NINA-02
+//AVE-NINA-03
+//AVE-NINA-06
+
+struct Nina : Board {
+
+unsigned revision;
+
+struct Settings {
+  bool mirror;  //0 = vertical, 1 = horizontal
+} settings;
+
+bool prg_bank;
+uint4 chr_bank[2];
+
+uint8 prg_read(unsigned addr) {
+  if(addr & 0x8000) return prgrom.read((prg_bank << 15) | (addr & 0x7fff));
+  if((addr & 0xe000) == 0x6000) {
+    if(prgram.size > 0) return prgram.read(addr);
+  }
+  return cpu.mdr();
+}
+
+void prg_write(unsigned addr, uint8 data) {
+  switch(revision) {
+  case  1:
+  case  2:
+    switch(addr) {
+    case 0x7ffd: prg_bank    = data & 0x01; break;
+    case 0x7ffe: chr_bank[0] = data & 0x0f; break;
+    case 0x7fff: chr_bank[1] = data & 0x0f; break;
+    }
+    break;
+  case  3:
+  case  6:
+    if((addr & 0xe100) == 0x4100) {
+      prg_bank    = (data & 0x08) >> 3;
+      chr_bank[0] = ((data & 0x07) << 1) | 0;
+      chr_bank[1] = ((data & 0x07) << 1) | 1;
+    }
+    break;
+  }
+  if((addr & 0xe000) == 0x6000 && prgram.size > 0) prgram.write(addr, data);
+}
+
+uint8 chr_read(unsigned addr) {
+  if(addr & 0x2000) {
+    if(settings.mirror == 1) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    return ppu.ciram_read(addr);
+  }
+  return Board::chr_read((addr & 0x0fff) | (chr_bank[(addr & 0x1000) >> 12] << 12));
+}
+
+void chr_write(unsigned addr, uint8 data) {
+  if(addr & 0x2000) {
+    if(settings.mirror == 1) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    return ppu.ciram_write(addr, data);
+  }
+  return Board::chr_write((addr & 0x0fff) | (chr_bank[(addr & 0x1000) >> 12] << 12), data);
+}
+
+void power() {
+  reset();
+}
+
+void reset() {
+  prg_bank = 0;
+  chr_bank[0] = 0;
+  chr_bank[1] = 0;
+}
+
+void serialize(serializer& s) {
+  Board::serialize(s);
+  s.integer(prg_bank);
+  s.array(chr_bank);
+}
+
+Nina(Markup::Node& cartridge) : Board(cartridge) {
+  string type = cartridge["board/type"].data;
+  if(type.match("*NINA-01*")) revision =  1;
+  if(type.match("*NINA-02*")) revision =  2;
+  if(type.match("*NINA-03*")) revision =  3;
+  if(type.match("*NINA-06*")) revision =  6;
+
+  print("Revision: 0", revision, "\n");
+  if(revision ==  1 || revision ==  2) {
+    settings.mirror = 1;
+  } else {
+    settings.mirror = cartridge["mirror/mode"].data == "horizontal";
+  }
+}
+
+};
diff --git a/fc/cartridge/board/unlicensed/noconflicts-cnrom.cpp b/fc/cartridge/board/unlicensed/noconflicts-cnrom.cpp
new file mode 100644
index 0000000..82c6983
--- /dev/null
+++ b/fc/cartridge/board/unlicensed/noconflicts-cnrom.cpp
@@ -0,0 +1,56 @@
+// This board is intended for homebrew games that do not account for bus
+// conflicts. Many Sachen and Panesian games require this board, but they were
+// not the reason for its inclusion.
+
+struct NoConflicts_CNROM : Board {
+
+struct Settings {
+  bool mirror;  //0 = vertical, 1 = horizontal
+} settings;
+
+uint2 chr_bank;
+
+uint8 prg_read(unsigned addr) {
+  if(addr & 0x8000) return prgrom.read(addr & 0x7fff);
+  return cpu.mdr();
+}
+
+void prg_write(unsigned addr, uint8 data) {
+  if(addr & 0x8000) chr_bank = data & 0x03;
+}
+
+uint8 chr_read(unsigned addr) {
+  if(addr & 0x2000) {
+    if(settings.mirror == 1) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    return ppu.ciram_read(addr & 0x07ff);
+  }
+  addr = (chr_bank * 0x2000) + (addr & 0x1fff);
+  return Board::chr_read(addr);
+}
+
+void chr_write(unsigned addr, uint8 data) {
+  if(addr & 0x2000) {
+    if(settings.mirror == 1) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    return ppu.ciram_write(addr & 0x07ff, data);
+  }
+  addr = (chr_bank * 0x2000) + (addr & 0x1fff);
+  Board::chr_write(addr, data);
+}
+
+void power() {
+}
+
+void reset() {
+  chr_bank = 0;
+}
+
+void serialize(serializer& s) {
+  Board::serialize(s);
+  s.integer(chr_bank);
+}
+
+NoConflicts_CNROM(Markup::Node& cartridge) : Board(cartridge) {
+  settings.mirror = cartridge["mirror/mode"].data == "horizontal";
+}
+
+};
diff --git a/fc/cartridge/board/unlicensed/single-chip.cpp b/fc/cartridge/board/unlicensed/single-chip.cpp
new file mode 100644
index 0000000..e1f80ff
--- /dev/null
+++ b/fc/cartridge/board/unlicensed/single-chip.cpp
@@ -0,0 +1,49 @@
+struct SingleChip : Board {
+
+struct Settings {
+  uint4 va10;  //10 = vertical, 11 = horizontal, 12 = BLK0, 13 = BLK1
+} settings;
+
+uint8 prg_read(unsigned addr) {
+  if(addr & 0x8000) return prgrom.read(addr);
+  return cpu.mdr();
+}
+
+void prg_write(unsigned addr, uint8 data) {
+}
+
+uint8 chr_read(unsigned addr) {
+  if(addr & 0x2000) {
+    switch(settings.va10) {
+    case 10: addr = (addr & 0x07ff);
+    case 11: addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    case 12: addr = (addr & 0x03ff);
+    case 13: addr = (addr & 0x03ff) | 0x0400;
+    }
+    return ppu.ciram_read(addr & 0x07ff);
+  }
+  return ppu.ciram_read(addr & 0x07ff);
+}
+
+void chr_write(unsigned addr, uint8 data) {
+  if(addr & 0x2000) {
+    switch(settings.va10) {
+    case 10: addr = (addr & 0x07ff);
+    case 11: addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    case 12: addr = (addr & 0x03ff);
+    case 13: addr = (addr & 0x03ff) | 0x0400;
+    }
+    return ppu.ciram_write(addr & 0x07ff, data);
+  }
+  return ppu.ciram_write(addr & 0x07ff, data);
+}
+
+void serialize(serializer& s) {
+  Board::serialize(s);
+}
+
+SingleChip(Markup::Node& cartridge) : Board(cartridge) {
+  settings.va10 = numeral(cartridge["board/va10"].data);
+}
+
+};
diff --git a/fc/cartridge/board/vs.cpp b/fc/cartridge/board/vs.cpp
new file mode 100644
index 0000000..80ac9c6
--- /dev/null
+++ b/fc/cartridge/board/vs.cpp
@@ -0,0 +1,49 @@
+//VS
+
+struct VS : Board {
+
+bool bank;
+
+uint8 prg_read(unsigned addr) {
+  if((addr & 0xe000) == 0x6000) return prgram.read(addr);
+  if(addr & 0x8000) {
+    if(prgrom.size <= 0x8000 || (addr & 0xe000) > 0x8000 || bank == 0) {
+      return prgrom.read(addr & 0x7fff);
+    } else {
+      return prgrom.read((addr & 0x1fff) | 0x8000);
+    }
+  }
+  return cpu.mdr();
+}
+
+void prg_write(unsigned addr, uint8 data) {
+  if(addr == 0x4016) bank = (data & 0x04) >> 2;
+  if((addr & 0xe000) == 0x6000) prgram.write(addr, data);
+}
+
+uint8 chr_read(unsigned addr) {
+  if(addr & 0x2000) return chrram.read(addr & 0x0fff);
+  if(bank && chrrom.size < 0x2000) return ppu.status.mdr;
+  return chrrom.read((bank * 0x2000) + (addr & 0x1fff));
+}
+
+void chr_write(unsigned addr, uint8 data) {
+  if(addr & 0x2000) return chrram.write(addr & 0x0fff, data);
+}
+
+void power() {
+}
+
+void reset() {
+  bank = 0;
+}
+
+void serialize(serializer& s) {
+  Board::serialize(s);
+  s.integer(bank);
+}
+
+VS(Markup::Node& cartridge) : Board(cartridge) {
+}
+
+};
diff --git a/fc/cartridge/cartridge.cpp b/fc/cartridge/cartridge.cpp
index 57dc723..91ecea8 100644
--- a/fc/cartridge/cartridge.cpp
+++ b/fc/cartridge/cartridge.cpp
@@ -1,13 +1,19 @@
 #include <fc/fc.hpp>
 
+#define CARTRIDGE_CPP
 namespace Famicom {
 
+#include "markup.cpp"
 #include "chip/chip.cpp"
 #include "board/board.cpp"
 Cartridge cartridge;
 
 string Cartridge::title() {
-  return information.title;
+  //if(information.title.famicomDiskSystem.empty() == false) {
+  //  return {information.title.cartridge, " + ", information.title.famicomDiskSystem};
+  //}
+
+  return information.title.cartridge;
 }
 
 void Cartridge::Main() {
@@ -18,29 +24,43 @@ void Cartridge::main() {
   board->main();
 }
 
-void Cartridge::load() {
+void Cartridge::load(System::Revision revision) {
+  region = Region::NTSC;
+  system.revision = revision;
+
+  information.markup.cartridge         = "";
+  //information.markup.famicomDiskSystem = "";
+
+  information.title.cartridge         = "";
+  //information.title.famicomDiskSystem = "";
+
   interface->loadRequest(ID::Manifest, "manifest.bml");
+  parse_markup(information.markup.cartridge);
 
-  Board::load(information.markup);  //this call will set Cartridge::board if successful
   if(board == nullptr) return;
 
   sha256_ctx sha;
   uint8 hash[32];
   sha256_init(&sha);
+  //hash each ROM image that exists; any with size() == 0 is ignored by sha256_chunk()
   sha256_chunk(&sha, board->prgrom.data, board->prgrom.size);
   sha256_chunk(&sha, board->chrrom.data, board->chrrom.size);
+  //finalize hash
   sha256_final(&sha);
   sha256_hash(&sha, hash);
   string result;
   for(auto& byte : hash) result.append(hex<2>(byte));
   sha256 = result;
 
-  system.load();
+  system.load(system.revision);
   loaded = true;
 }
 
 void Cartridge::unload() {
   if(loaded == false) return;
+
+  system.unload();
+
   loaded = false;
   memory.reset();
 }
@@ -50,7 +70,7 @@ void Cartridge::power() {
 }
 
 void Cartridge::reset() {
-  create(Cartridge::Main, 21477272);
+  create(Cartridge::Main, system.cpu_frequency());
   board->reset();
 }
 
@@ -58,6 +78,10 @@ Cartridge::Cartridge() {
   loaded = false;
 }
 
+Cartridge::~Cartridge() {
+  unload();
+}
+
 uint8 Cartridge::prg_read(unsigned addr) {
   return board->prg_read(addr);
 }
diff --git a/fc/cartridge/cartridge.hpp b/fc/cartridge/cartridge.hpp
index 4c0c50c..792f4dd 100644
--- a/fc/cartridge/cartridge.hpp
+++ b/fc/cartridge/cartridge.hpp
@@ -2,24 +2,18 @@
 #include "board/board.hpp"
 
 struct Cartridge : Thread, property<Cartridge> {
+  enum class Region : unsigned {
+    NTSC,
+    PAL,
+  };
+
   static void Main();
   void main();
 
-  void load();
-  void unload();
-
-  void power();
-  void reset();
-
   readonly<bool> loaded;
   readonly<string> sha256;
 
-  struct Information {
-    string markup;
-    string title;
-  } information;
-
-  string title();
+  readonly<Region> region;
 
   struct Memory {
     unsigned id;
@@ -27,8 +21,29 @@ struct Cartridge : Thread, property<Cartridge> {
   };
   vector<Memory> memory;
 
+  struct Information {
+    struct Markup {
+      string cartridge;
+      //string famicomDiskSystem;
+    } markup;
+
+    struct Title {
+      string cartridge;
+      //string famicomDiskSystem;
+    } title;
+  } information;
+
+  string title();
+
+  void load(System::Revision revision);
+  void unload();
+
+  void power();
+  void reset();
+
   void serialize(serializer&);
   Cartridge();
+  ~Cartridge();
 
 //privileged:
   Board *board;
@@ -42,6 +57,9 @@ struct Cartridge : Thread, property<Cartridge> {
   //scanline() is for debugging purposes only:
   //boards must detect scanline edges on their own
   void scanline(unsigned y);
+
+private:
+  void parse_markup(const char*);
 };
 
 extern Cartridge cartridge;
diff --git a/fc/cartridge/chip/chip.cpp b/fc/cartridge/chip/chip.cpp
index e3cabdc..44f003a 100644
--- a/fc/cartridge/chip/chip.cpp
+++ b/fc/cartridge/chip/chip.cpp
@@ -1,7 +1,9 @@
+#include "fcg.cpp"
 #include "mmc1.cpp"
 #include "mmc3.cpp"
 #include "mmc5.cpp"
 #include "mmc6.cpp"
+#include "namco-108.cpp"
 #include "vrc1.cpp"
 #include "vrc2.cpp"
 #include "vrc3.cpp"
diff --git a/fc/cartridge/chip/fcg.cpp b/fc/cartridge/chip/fcg.cpp
new file mode 100644
index 0000000..f2447ed
--- /dev/null
+++ b/fc/cartridge/chip/fcg.cpp
@@ -0,0 +1,136 @@
+struct FCG : Chip {
+
+enum class Revision : unsigned {
+  FCG1,
+  FCG2,
+  LZ93D50,
+} revision;
+
+enum class EEPROM : unsigned {
+  None,
+  _24C01,
+  _24C02
+} eeprom;
+
+uint8 chr_bank[8];
+uint8 prg_bank;
+uint2 mirror;
+bool irq_counter_enable;
+uint16 irq_counter;
+uint16 irq_latch;
+bool eeprom_i2c_scl; // When using SRAM, enables RAM chip
+bool eeprom_enable_read;
+
+void main() {
+  while(true) {
+    if(scheduler.sync == Scheduler::SynchronizeMode::All) {
+      scheduler.exit(Scheduler::ExitReason::SynchronizeEvent);
+    }
+
+    if(irq_counter_enable) {
+      if(--irq_counter == 0xffff) {
+        cpu.set_irq_line(1);
+        irq_counter_enable = false;
+      }
+    }
+
+    tick();
+  }
+}
+
+unsigned prg_addr(unsigned addr) const {
+  bool region = addr & 0x4000;
+  return ((region == 0 ? prg_bank : 15) << 14) | (addr & 0x3fff);
+}
+
+unsigned chr_addr(unsigned addr) const {
+  return (chr_bank[addr >> 10] << 10) | (addr & 0x03ff);
+}
+
+unsigned ciram_addr(unsigned addr) const {
+  switch(mirror) {
+  case 0: return ((addr & 0x0400) >> 0) | (addr & 0x03ff);
+  case 1: return ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+  case 2: return 0x0000 | (addr & 0x03ff);
+  case 3: return 0x0400 | (addr & 0x03ff);
+  }
+}
+
+uint8 ram_read(unsigned addr) {
+  return board.prgram.data[addr & 0x1fff];
+}
+
+void ram_write(unsigned addr, uint8 data) {
+  board.prgram.data[addr & 0x1fff] = data;
+}
+
+void reg_write(unsigned addr, uint8 data) {
+  switch(addr & 0x0f) {
+  case 0x00: case 0x01: case 0x02: case 0x03:
+  case 0x04: case 0x05: case 0x06: case 0x07:
+    chr_bank[addr & 7] = data;
+    break;
+  case 0x08:
+    prg_bank = data & 0x0f;
+    break;
+  case 0x09:
+    mirror = data & 0x03;
+    break;
+  case 0x0a:
+    cpu.set_irq_line(0);
+    irq_counter_enable = data & 0x01;
+    irq_counter = irq_latch;
+    break;
+  case 0x0b:
+    irq_latch = (irq_latch & 0xff00) | (data << 0);
+    break;
+  case 0x0c:
+    irq_latch = (irq_latch & 0x00ff) | (data << 8);
+    break;
+  case 0x0d:
+    //TODO: serial EEPROM support
+    eeprom_i2c_scl = data & 0x20;
+    eeprom_enable_read = data & 0x80;
+    break;
+  }
+}
+
+void power() {
+  reset();
+}
+
+void reset() {
+  for(auto &n : chr_bank) n = 0;
+  prg_bank = 0;
+  mirror = 0;
+  irq_counter_enable = 0;
+  irq_counter = 0;
+  irq_latch = 0;
+  eeprom_i2c_scl = 0;
+  eeprom_enable_read = 0;
+}
+
+void serialize(serializer& s) {
+  s.array(chr_bank);
+  s.integer(prg_bank);
+  s.integer(mirror);
+  s.integer(irq_counter_enable);
+  s.integer(irq_counter);
+  s.integer(irq_latch);
+  s.integer(eeprom_i2c_scl);
+  s.integer(eeprom_enable_read);
+}
+
+FCG(Board& board, Markup::Node& cartridge) : Chip(board) {
+  string type = cartridge["chip[0]/type"].data;
+  if(type.match("*FCG-1*"  )) revision = Revision::FCG1;
+  if(type.match("*FCG-2*"  )) revision = Revision::FCG2;
+  if(type.match("*LZ93D50*")) revision = Revision::LZ93D50;
+
+  eeprom = EEPROM::None;
+  type = cartridge["chip[1]/type"].data;
+  if(type.match("*24C01*"  )) eeprom = EEPROM::_24C01;
+  if(type.match("*24C02*"  )) eeprom = EEPROM::_24C02;
+}
+
+};
diff --git a/fc/cartridge/chip/mmc1.cpp b/fc/cartridge/chip/mmc1.cpp
index 3983bda..59409f2 100644
--- a/fc/cartridge/chip/mmc1.cpp
+++ b/fc/cartridge/chip/mmc1.cpp
@@ -89,7 +89,7 @@ void mmio_write(unsigned addr, uint8 data) {
         break;
 
       case 3:
-        ram_disable = (shiftdata & 0x10);
+        ram_disable = ((shiftdata & 0x10) && revision != Revision::MMC1 && revision != Revision::MMC1A);
         prg_bank = (shiftdata & 0x0f);
         break;
       }
@@ -111,7 +111,7 @@ void reset() {
   mirror = 0;
   chr_bank[0] = 0;
   chr_bank[1] = 1;
-  ram_disable = 0;
+  ram_disable = revision == Revision::MMC1C;
   prg_bank = 0;
 }
 
@@ -129,8 +129,15 @@ void serialize(serializer& s) {
   s.integer(prg_bank);
 }
 
-MMC1(Board& board) : Chip(board) {
-  revision = Revision::MMC1B2;
+MMC1(Board& board, Markup::Node& cartridge) : Chip(board) {
+  string type = cartridge["chip/type"].data;
+
+  if(type.match("*MMC1*"  )) revision = Revision::MMC1;
+  if(type.match("*MMC1A*" )) revision = Revision::MMC1A;
+  if(type.match("*MMC1B1*")) revision = Revision::MMC1B1;
+  if(type.match("*MMC1B2*")) revision = Revision::MMC1B2;
+  if(type.match("*MMC1B3*")) revision = Revision::MMC1B3;
+  if(type.match("*MMC1C*" )) revision = Revision::MMC1C;
 }
 
 };
diff --git a/fc/cartridge/chip/mmc3.cpp b/fc/cartridge/chip/mmc3.cpp
index a051d91..3b397a9 100644
--- a/fc/cartridge/chip/mmc3.cpp
+++ b/fc/cartridge/chip/mmc3.cpp
@@ -1,5 +1,13 @@
 struct MMC3 : Chip {
 
+enum class Revision : unsigned {
+  MMC3,
+  MMC3A,
+  MMC3B,
+  MMC3C,
+  MCACC,
+} revision;
+
 bool chr_mode;
 bool prg_mode;
 uint3 bank_select;
@@ -38,6 +46,7 @@ void irq_test(unsigned addr) {
       }
     }
     irq_delay = 6;
+    //if(revision == Revision::MCACC) irq_delay += 88;
   }
   chr_abus = addr;
 }
@@ -183,7 +192,13 @@ void serialize(serializer& s) {
   s.integer(chr_abus);
 }
 
-MMC3(Board& board) : Chip(board) {
+MMC3(Board& board, Markup::Node& cartridge) : Chip(board) {
+  string type = cartridge["chip/type"].data;
+  if(type.match("*MMC3*"  )) revision = Revision::MMC3;
+  if(type.match("*MMC3A*" )) revision = Revision::MMC3A;
+  if(type.match("*MMC3B*" )) revision = Revision::MMC3B;
+  if(type.match("*MMC3C*" )) revision = Revision::MMC3C;
+  if(type.match("*MC-ACC*")) revision = Revision::MCACC;
 }
 
 };
diff --git a/fc/cartridge/chip/mmc5.cpp b/fc/cartridge/chip/mmc5.cpp
index 5cd94fa..8c23c05 100644
--- a/fc/cartridge/chip/mmc5.cpp
+++ b/fc/cartridge/chip/mmc5.cpp
@@ -279,13 +279,13 @@ unsigned chr_sprite_addr(unsigned addr) {
 }
 
 unsigned chr_bg_addr(unsigned addr) {
-  addr &= 0x0fff;
-
   if(chr_mode == 0) {
     auto bank = chr_bg_bank[3];
-    return (bank * 0x2000) + (addr & 0x0fff);
+    return (bank * 0x2000) + (addr & 0x1fff);
   }
 
+  addr &= 0x0fff;
+
   if(chr_mode == 1) {
     auto bank = chr_bg_bank[3];
     return (bank * 0x1000) + (addr & 0x0fff);
@@ -490,8 +490,11 @@ void serialize(serializer& s) {
   s.integer(vs_hpos);
 }
 
-MMC5(Board& board) : Chip(board) {
-  revision = Revision::MMC5;
+MMC5(Board& board, Markup::Node& cartridge) : Chip(board) {
+  string type = cartridge["chip/type"].data;
+
+  if(type.match("*MMC5*" )) revision = Revision::MMC5;
+  if(type.match("*MMC5B*")) revision = Revision::MMC5B;
 }
 
 };
diff --git a/fc/cartridge/chip/namco-108.cpp b/fc/cartridge/chip/namco-108.cpp
new file mode 100644
index 0000000..8f333c1
--- /dev/null
+++ b/fc/cartridge/chip/namco-108.cpp
@@ -0,0 +1,83 @@
+struct Namco108 : Chip {
+
+enum class Revision : unsigned {
+  Namco108,
+  Namco109,
+  Namco118,
+  Namco119,
+} revision;
+
+uint3 bank_select;
+uint8 prg_bank[2];
+uint8 chr_bank[6];
+
+unsigned prg_addr(unsigned addr) const {
+  switch((addr >> 13) & 3) {
+  case 0: return (prg_bank[0] << 13) | (addr & 0x1fff);
+  case 1: return (prg_bank[1] << 13) | (addr & 0x1fff);
+  case 2: return (0x0e << 13) | (addr & 0x1fff);
+  case 3: return (0x0f << 13) | (addr & 0x1fff);
+  }
+}
+
+unsigned chr_addr(unsigned addr) const {
+  if(addr <= 0x07ff) return (chr_bank[0] << 10) | (addr & 0x07ff);
+  if(addr <= 0x0fff) return (chr_bank[1] << 10) | (addr & 0x07ff);
+  if(addr <= 0x13ff) return (chr_bank[2] << 10) | (addr & 0x03ff);
+  if(addr <= 0x17ff) return (chr_bank[3] << 10) | (addr & 0x03ff);
+  if(addr <= 0x1bff) return (chr_bank[4] << 10) | (addr & 0x03ff);
+  if(addr <= 0x1fff) return (chr_bank[5] << 10) | (addr & 0x03ff);
+}
+
+void reg_write(unsigned addr, uint8 data) {
+  switch(addr & 0x8001) {
+  case 0x8000:
+    bank_select = data & 0x07;
+    break;
+
+  case 0x8001:
+    switch(bank_select) {
+    case 0: chr_bank[0] = data & 0x3e; break;
+    case 1: chr_bank[1] = data & 0x3e; break;
+    case 2: chr_bank[2] = data & 0x3f; break;
+    case 3: chr_bank[3] = data & 0x3f; break;
+    case 4: chr_bank[4] = data & 0x3f; break;
+    case 5: chr_bank[5] = data & 0x3f; break;
+    case 6: prg_bank[0] = data & 0x0f; break;
+    case 7: prg_bank[1] = data & 0x0f; break;
+    }
+    break;
+  }
+}
+
+void power() {
+}
+
+void reset() {
+  bank_select = 0;
+  prg_bank[0] = 0;
+  prg_bank[1] = 0;
+  chr_bank[0] = 0;
+  chr_bank[1] = 0;
+  chr_bank[2] = 0;
+  chr_bank[3] = 0;
+  chr_bank[4] = 0;
+  chr_bank[5] = 0;
+}
+
+void serialize(serializer& s) {
+  s.integer(bank_select);
+  s.array(prg_bank);
+  s.array(chr_bank);
+}
+
+Namco108(Board& board, Markup::Node& cartridge) : Chip(board) {
+  string type = cartridge["chip/type"].data;
+
+  if(type.match("*108*")) revision = Revision::Namco108;
+  if(type.match("*109*")) revision = Revision::Namco109;
+  if(type.match("*118*")) revision = Revision::Namco118;
+  if(type.match("*119*")) revision = Revision::Namco119;
+}
+
+};
diff --git a/fc/cartridge/markup.cpp b/fc/cartridge/markup.cpp
new file mode 100644
index 0000000..4ddab84
--- /dev/null
+++ b/fc/cartridge/markup.cpp
@@ -0,0 +1,46 @@
+#ifdef CARTRIDGE_CPP
+
+void Cartridge::parse_markup(const char* markup) {
+  auto document = Markup::Document(markup);
+  information.title.cartridge = document["information/title"].text();
+
+  auto cartridge = document["cartridge"];
+  region = cartridge["region"].data != "PAL" ? Region::NTSC : Region::PAL;
+  if(system.revision == System::Revision::VSSystem) {
+    vsarcadeboard.swap_controllers = cartridge["vs/controller[0]/port"].integer() == 2;
+    //string device1 = cartridge["vs/controller(port=1)/device"].text();
+    //string device2 = cartridge["vs/controller(port=2)/device"].text();
+    //if(device1 == "joypad") {
+    //  input.connect(vsarcadeboard.swap_controllers, Input::Device::Joypad);
+    //} else if(device1 == "none") {
+    //  input.connect(vsarcadeboard.swap_controllers, Input::Device::None);
+    //}
+    //if(device2 == "joypad") {
+    //  input.connect(!vsarcadeboard.swap_controllers, Input::Device::Joypad);
+    //} else if(device2 == "beamgun") {
+    //  input.connect(!vsarcadeboard.swap_controllers, Input::Device::BeamGun);
+    //} else if(device2 == "none") {
+    //  input.connect(!vsarcadeboard.swap_controllers, Input::Device::None);
+    //}
+    vsarcadeboard.set_dip(interface->dipSettings(cartridge["vs"]));
+    string ppu_revision = cartridge["vs/ppu/revision"].data;
+    if(ppu_revision == "RP2C02C")     ppu.revision = PPU::Revision::RP2C02C;
+    if(ppu_revision == "RP2C02G")     ppu.revision = PPU::Revision::RP2C02G;
+    if(ppu_revision == "RP2C03B")     ppu.revision = PPU::Revision::RP2C03B;
+    if(ppu_revision == "RP2C03G")     ppu.revision = PPU::Revision::RP2C03G;
+    if(ppu_revision == "RP2C04-0001") ppu.revision = PPU::Revision::RP2C04_0001;
+    if(ppu_revision == "RP2C04-0002") ppu.revision = PPU::Revision::RP2C04_0002;
+    if(ppu_revision == "RP2C04-0003") ppu.revision = PPU::Revision::RP2C04_0003;
+    if(ppu_revision == "RP2C04-0004") ppu.revision = PPU::Revision::RP2C04_0004;
+    if(ppu_revision == "RC2C03B")     ppu.revision = PPU::Revision::RC2C03B;
+    if(ppu_revision == "RC2C03C")     ppu.revision = PPU::Revision::RC2C03C;
+    if(ppu_revision == "RC2C05-01")   ppu.revision = PPU::Revision::RC2C05_01;
+    if(ppu_revision == "RC2C05-02")   ppu.revision = PPU::Revision::RC2C05_02;
+    if(ppu_revision == "RC2C05-03")   ppu.revision = PPU::Revision::RC2C05_03;
+    if(ppu_revision == "RC2C05-04")   ppu.revision = PPU::Revision::RC2C05_04;
+    if(ppu_revision == "RC2C05-05")   ppu.revision = PPU::Revision::RC2C05_05;
+  }
+  Board::load(cartridge);  //this call will set Cartridge::board if successful
+}
+
+#endif
diff --git a/fc/cheat.cpp b/fc/cheat.cpp
new file mode 100644
index 0000000..7385455
--- /dev/null
+++ b/fc/cheat.cpp
@@ -0,0 +1,28 @@
+#include <fc/fc.hpp>
+
+namespace Famicom {
+
+Cheat cheat;
+
+void Cheat::reset() {
+  codes.reset();
+}
+
+void Cheat::append(unsigned addr, unsigned data) {
+  codes.append({addr, Unused, data});
+}
+
+void Cheat::append(unsigned addr, unsigned comp, unsigned data) {
+  codes.append({addr, comp, data});
+}
+
+optional<unsigned> Cheat::find(unsigned addr, unsigned comp) {
+  for(auto& code : codes) {
+    if(code.addr == addr && (code.comp == Unused || code.comp == comp)) {
+      return {true, code.data};
+    }
+  }
+  return false;
+}
+
+}
diff --git a/fc/controller/beamgun/beamgun.cpp b/fc/controller/beamgun/beamgun.cpp
new file mode 100644
index 0000000..b5f579d
--- /dev/null
+++ b/fc/controller/beamgun/beamgun.cpp
@@ -0,0 +1,76 @@
+#ifdef CONTROLLER_CPP
+
+void BeamGun::enter() {
+  unsigned prev = 0;
+  while(true) {
+    unsigned next = ppu.status.ly * 341 + ppu.status.lx;
+
+    if(light > 0) light -= 1;
+
+    if(!offscreen) {
+      unsigned target = y * 341 + x + 3;
+      if(next >= target && prev < target) {
+        //CRT raster detected
+        //light remains in the gun for 10-25 scanlines
+        if(read_light()) light = 341 * 16;
+      }
+    }
+
+    if(next < prev) {
+      if(triggertime > 0) triggertime -= 1;
+      //Vcounter wrapped back to zero; update cursor coordinates for start of new frame
+      int nx = interface->inputPoll(port, (unsigned)Input::Device::BeamGun, (unsigned)Input::BeamGunID::X);
+      int ny = interface->inputPoll(port, (unsigned)Input::Device::BeamGun, (unsigned)Input::BeamGunID::Y);
+      nx += x;
+      ny += y;
+      x = max(-16, min(256 + 16, nx));
+      y = max(-16, min(240 + 16, ny));
+      offscreen = (x < 0 || y < 0 || x >= 256 || y >= 240);
+    }
+
+    prev = next;
+    step(2);
+  }
+}
+
+uint5 BeamGun::data() {
+  bool newtrigger = interface->inputPoll(port, (unsigned)Input::Device::BeamGun, (unsigned)Input::BeamGunID::Trigger);
+  if(newtrigger && !triggerlock) {
+    triggertime = 2;
+    triggerlock = true;
+  } else if(!newtrigger) {
+    triggerlock = false;
+  }
+
+  return ((triggertime > 0) << 4) | ((light == 0) << 3);
+}
+
+uint2 BeamGun::data1() {
+  return 0;
+}
+
+uint5 BeamGun::data2() {
+  return data();
+}
+
+bool BeamGun::read_light() {
+  if(offscreen) return false;
+  uint32 color = ppu.buffer[y * 256 + x];
+  return ((color & 0x20) && ((color & 0x0F) < 0x0D));
+}
+
+void BeamGun::latch(bool data) {
+  if(latched == data) return;
+  latched = data;
+}
+
+BeamGun::BeamGun(unsigned port) : Controller(port) {
+  create(Controller::Enter, system.cpu_frequency());
+  latched = 0;
+
+  //center cursor onscreen
+  x = 256 / 2;
+  y = 240 / 2;
+}
+
+#endif
diff --git a/fc/controller/beamgun/beamgun.hpp b/fc/controller/beamgun/beamgun.hpp
new file mode 100644
index 0000000..f1f8f84
--- /dev/null
+++ b/fc/controller/beamgun/beamgun.hpp
@@ -0,0 +1,20 @@
+struct BeamGun : Controller {
+  void enter();
+  uint5 data();
+  uint2 data1();
+  uint5 data2();
+  bool read_light();
+  void latch(bool data);
+  BeamGun(unsigned port);
+
+//private:
+  bool latched;
+
+  signed x, y;
+  unsigned light;
+  unsigned triggertime;
+
+  bool offscreen;
+
+  bool triggerlock;
+};
diff --git a/fc/controller/controller.cpp b/fc/controller/controller.cpp
new file mode 100644
index 0000000..fae691a
--- /dev/null
+++ b/fc/controller/controller.cpp
@@ -0,0 +1,41 @@
+#include <fc/fc.hpp>
+
+#define CONTROLLER_CPP
+namespace Famicom {
+
+#include "gamepad/gamepad.cpp"
+#include "fourplayers/fourplayers.cpp"
+#include "fourscore/fourscore.cpp"
+#include "beamgun/beamgun.cpp"
+#include "vsbeamgun/vsbeamgun.cpp"
+#include "familytrainer/familytrainer.cpp"
+#include "vspanel/vspanel.cpp"
+
+void Controller::Enter() {
+  if(co_active() == input.port1->thread) input.port1->enter();
+  if(co_active() == input.port2->thread) input.port2->enter();
+  if(co_active() == input.expansion->thread) input.expansion->enter();
+}
+
+void Controller::enter() {
+  while(true) step(1);
+}
+
+void Controller::step(unsigned clocks) {
+  clock += clocks * (uint64)cpu.frequency;
+  synchronize_cpu();
+}
+
+void Controller::synchronize_cpu() {
+  if(CPU::Threaded == true) {
+    if(clock >= 0 && scheduler.sync != Scheduler::SynchronizeMode::All) co_switch(cpu.thread);
+  } else {
+    while(clock >= 0) cpu.enter();
+  }
+}
+
+Controller::Controller(unsigned port) : port(port) {
+  if(!thread) create(Controller::Enter, 1);
+}
+
+}
diff --git a/fc/controller/controller.hpp b/fc/controller/controller.hpp
new file mode 100644
index 0000000..83afa9d
--- /dev/null
+++ b/fc/controller/controller.hpp
@@ -0,0 +1,61 @@
+// NES controller port pinout:
+// ┌────
+// │(7)  \
+// │(2)(1)│
+// │(3)(5)│
+// │(4)(6)│
+// └──────┘
+// pin    name     port1                            port2
+//  1:    +5v
+//  2:    clock    $4016 read                       $4017 read
+//  3:    latch    $4016.d0 write                   $4016.d0 write
+//  4:    data0    $4016.d0 read                    $4017.d0 read
+//  5:    data3    $4016.d3 read                    $4017.d3 read
+//  6:    data4    $4016.d4 read                    $4017.d4 read
+//  7:    gnd
+
+// Famicom expansion port pinout:
+// /--------------------------------\
+// \(08)(07)(06)(05)(04)(03)(02)(01)/
+//  \ (15)(14)(13)(12)(11)(10)(09) /
+//   \----------------------------/
+// pin    name     register
+// 01:    gnd
+// 02:    sound
+// 03:    irq
+// 04:    data2.4  $4017.d4 read
+// 05:    data2.3  $4017.d3 read
+// 06:    data2.2  $4017.d2 read
+// 07:    data2.1  $4017.d1 read
+// 08:    data2.0  $4017.d0 read
+// 09:    /oe 2
+// 10:    out 2    $4016.d2 write
+// 11:    out 1    $4016.d1 write
+// 12:    latch    $4016.d0 write
+// 13:    data1.1  $4016.d1 read
+// 14:    /oe 1
+// 15:    +5v
+
+struct Controller : Thread {
+  enum : unsigned { Port1 = 0, Port2 = 1, ExpansionPort = 2 };
+  const unsigned port;
+
+  static void Enter();
+  virtual void enter();
+  void step(unsigned clocks);
+  void synchronize_cpu();
+
+  virtual uint5 data() { return 0; }
+  virtual uint2 data1() { return 0; }
+  virtual uint5 data2() { return 0; }
+  virtual void latch(bool data) {}
+  Controller(unsigned port);
+};
+
+#include "gamepad/gamepad.hpp"
+#include "fourplayers/fourplayers.hpp"
+#include "fourscore/fourscore.hpp"
+#include "beamgun/beamgun.hpp"
+#include "vsbeamgun/vsbeamgun.hpp"
+#include "familytrainer/familytrainer.hpp"
+#include "vspanel/vspanel.hpp"
diff --git a/fc/controller/familytrainer/familytrainer.cpp b/fc/controller/familytrainer/familytrainer.cpp
new file mode 100644
index 0000000..9ad8282
--- /dev/null
+++ b/fc/controller/familytrainer/familytrainer.cpp
@@ -0,0 +1,57 @@
+#ifdef CONTROLLER_CPP
+
+uint5 FamilyTrainer::data() {
+  if(counter >= 8) return 0x18;
+  if(latched == 1) return (b2 << 3) | (b4 << 4);
+
+  switch(counter++) {
+  case  0: return (b2  << 3) | (b4  << 4);
+  case  1: return (b1  << 3) | (b3  << 4);
+  case  2: return (b5  << 3) | (b12 << 4);
+  case  3: return (b9  << 3) | (b8  << 4);
+  case  4: return (b6  << 3) | 0x10;
+  case  5: return (b10 << 3) | 0x10;
+  case  6: return (b11 << 3) | 0x10;
+  case  7: return (b7  << 3) | 0x10;
+  }
+}
+
+uint2 FamilyTrainer::data1() {
+  return 0;
+}
+
+uint5 FamilyTrainer::data2() {
+  return data();
+}
+
+void FamilyTrainer::latch(bool data) {
+  if(latched == data) return;
+  latched = data;
+  counter = 0;
+
+  if(latched == 0) {
+    b1  = interface->inputPoll(port, (unsigned)Input::Device::FamilyTrainer,  0);
+    b2  = interface->inputPoll(port, (unsigned)Input::Device::FamilyTrainer,  1);
+    b3  = interface->inputPoll(port, (unsigned)Input::Device::FamilyTrainer,  2);
+    b4  = interface->inputPoll(port, (unsigned)Input::Device::FamilyTrainer,  3);
+    b5  = interface->inputPoll(port, (unsigned)Input::Device::FamilyTrainer,  4);
+    b6  = interface->inputPoll(port, (unsigned)Input::Device::FamilyTrainer,  5);
+    b7  = interface->inputPoll(port, (unsigned)Input::Device::FamilyTrainer,  6);
+    b8  = interface->inputPoll(port, (unsigned)Input::Device::FamilyTrainer,  7);
+    b9  = interface->inputPoll(port, (unsigned)Input::Device::FamilyTrainer,  8);
+    b10 = interface->inputPoll(port, (unsigned)Input::Device::FamilyTrainer,  9);
+    b11 = interface->inputPoll(port, (unsigned)Input::Device::FamilyTrainer, 10);
+    b12 = interface->inputPoll(port, (unsigned)Input::Device::FamilyTrainer, 11);
+  }
+}
+
+FamilyTrainer::FamilyTrainer(unsigned port) : Controller(port) {
+  latched = 0;
+  counter = 0;
+
+  b1 = b2 = b3 = b4 = 0;
+  b5 = b6 = b7 = b8 = 0;
+  b9 = b10 = b11 = b12 = 0;
+}
+
+#endif
diff --git a/fc/controller/familytrainer/familytrainer.hpp b/fc/controller/familytrainer/familytrainer.hpp
new file mode 100644
index 0000000..f6389f9
--- /dev/null
+++ b/fc/controller/familytrainer/familytrainer.hpp
@@ -0,0 +1,15 @@
+struct FamilyTrainer : Controller {
+  uint5 data();
+  uint2 data1();
+  uint5 data2();
+  void latch(bool data);
+  FamilyTrainer(unsigned port);
+
+private:
+  bool latched;
+  unsigned counter;
+
+  bool b1, b2, b3, b4;
+  bool b5, b6, b7, b8;
+  bool b9, b10, b11, b12;
+};
diff --git a/fc/controller/fourplayers/fourplayers.cpp b/fc/controller/fourplayers/fourplayers.cpp
new file mode 100644
index 0000000..10a97a0
--- /dev/null
+++ b/fc/controller/fourplayers/fourplayers.cpp
@@ -0,0 +1,30 @@
+#ifdef CONTROLLER_CPP
+
+uint2 FourPlayers::data1() {
+  if(counter1 >= 8) return 2;
+  if(latched) return interface->inputPoll(port, (unsigned)Input::Device::FourPlayers, 0) << 1;
+
+  return interface->inputPoll(port, (unsigned)Input::Device::FourPlayers, counter1++) << 1;
+}
+
+uint5 FourPlayers::data2() {
+  if(counter2 >= 8) return 2;
+  if(latched) return interface->inputPoll(port, (unsigned)Input::Device::FourPlayers, 8) << 1;
+
+  return interface->inputPoll(port, (unsigned)Input::Device::FourPlayers, (counter2++) + 8) << 1;
+}
+
+void FourPlayers::latch(bool data) {
+  if(latched == data) return;
+  latched = data;
+  counter1 = 0;
+  counter2 = 0;
+}
+
+FourPlayers::FourPlayers(unsigned port) : Controller(port) {
+  latched = 0;
+  counter1 = 0;
+  counter2 = 0;
+}
+
+#endif
diff --git a/fc/controller/fourplayers/fourplayers.hpp b/fc/controller/fourplayers/fourplayers.hpp
new file mode 100644
index 0000000..2a9ab47
--- /dev/null
+++ b/fc/controller/fourplayers/fourplayers.hpp
@@ -0,0 +1,11 @@
+struct FourPlayers : Controller {
+  uint2 data1();
+  uint5 data2();
+  void latch(bool data);
+  FourPlayers(unsigned port);
+
+private:
+  bool latched;
+  unsigned counter1;
+  unsigned counter2;
+};
diff --git a/fc/controller/fourscore/fourscore.cpp b/fc/controller/fourscore/fourscore.cpp
new file mode 100644
index 0000000..3b33ee5
--- /dev/null
+++ b/fc/controller/fourscore/fourscore.cpp
@@ -0,0 +1,26 @@
+#ifdef CONTROLLER_CPP
+
+uint5 FourScore::data() {
+  if(counter >= 24) return 1;
+  if(latched) return interface->inputPoll(port, (unsigned)Input::Device::FourScore, 0);
+  uint5 data = 0;
+
+  if(counter >= 16) data = counter == (19 - port);
+  else data = interface->inputPoll(port, (unsigned)Input::Device::FourScore, counter);
+  counter++;
+
+  return data;
+}
+
+void FourScore::latch(bool data) {
+  if(latched == data) return;
+  latched = data;
+  counter = 0;
+}
+
+FourScore::FourScore(unsigned port) : Controller(port) {
+  latched = 0;
+  counter = 0;
+}
+
+#endif
diff --git a/fc/controller/fourscore/fourscore.hpp b/fc/controller/fourscore/fourscore.hpp
new file mode 100644
index 0000000..86e7680
--- /dev/null
+++ b/fc/controller/fourscore/fourscore.hpp
@@ -0,0 +1,9 @@
+struct FourScore : Controller {
+  uint5 data();
+  void latch(bool data);
+  FourScore(unsigned port);
+
+private:
+  bool latched;
+  unsigned counter;
+};
diff --git a/fc/controller/gamepad/gamepad.cpp b/fc/controller/gamepad/gamepad.cpp
new file mode 100644
index 0000000..97e6b90
--- /dev/null
+++ b/fc/controller/gamepad/gamepad.cpp
@@ -0,0 +1,59 @@
+#ifdef CONTROLLER_CPP
+
+uint5 Gamepad::data() {
+  if(counter >= 8) return 1;
+  if(latched == 1) return interface->inputPoll(port, (unsigned)Input::Device::Joypad, (unsigned)Input::JoypadID::A);
+
+  //note: D-pad physically prevents up+down and left+right from being pressed at the same time
+  switch(counter++) {
+  case 0: return a;
+  case 1: return b;
+  case 2: return select;
+  case 3: return start;
+  case 4: return up & !down;
+  case 5: return down & !up;
+  case 6: return left & !right;
+  case 7: return right & !left;
+  }
+}
+
+uint2 Gamepad::data1() {
+  return ((data() << 1) & 0x02);
+}
+
+uint5 Gamepad::data2() {
+  return 0;
+}
+
+void Gamepad::latch(bool data) {
+  if(latched == data) return;
+  latched = data;
+  counter = 0;
+
+  if(latched == 0) {
+    unsigned id = (unsigned)Input::Device::Joypad;
+    a      = interface->inputPoll(port, id,  0);
+    b      = interface->inputPoll(port, id,  1);
+    if(!system.vs()) {
+      select = interface->inputPoll(port, id,  2);
+      start  = interface->inputPoll(port, id,  3);
+    } else {
+      select = 0;
+      start  = 0;
+    }
+    up     = interface->inputPoll(port, id,  4);
+    down   = interface->inputPoll(port, id,  5);
+    left   = interface->inputPoll(port, id,  6);
+    right  = interface->inputPoll(port, id,  7);
+  }
+}
+
+Gamepad::Gamepad(unsigned port) : Controller(port) {
+  latched = 0;
+  counter = 0;
+
+  a = b = select = start = 0;
+  up = down = left = right = 0;
+}
+
+#endif
diff --git a/fc/controller/gamepad/gamepad.hpp b/fc/controller/gamepad/gamepad.hpp
new file mode 100644
index 0000000..fe77970
--- /dev/null
+++ b/fc/controller/gamepad/gamepad.hpp
@@ -0,0 +1,14 @@
+struct Gamepad : Controller {
+  uint5 data();
+  uint2 data1();
+  uint5 data2();
+  void latch(bool data);
+  Gamepad(unsigned port);
+
+private:
+  bool latched;
+  unsigned counter;
+
+  bool a, b, select, start;
+  bool up, down, left, right;
+};
diff --git a/fc/controller/mouse/mouse.cpp b/fc/controller/mouse/mouse.cpp
new file mode 100644
index 0000000..b592422
--- /dev/null
+++ b/fc/controller/mouse/mouse.cpp
@@ -0,0 +1,98 @@
+#ifdef CONTROLLER_CPP
+
+uint5 Mouse::data() {
+  if(latched == 1) {
+    speed = (speed + 1) % 3;
+    return 0;
+  }
+
+  if(counter >= 32) return 1;
+
+  switch(counter++) { default:
+  case  0: return 0;
+  case  1: return 0;
+  case  2: return 0;
+  case  3: return 0;
+  case  4: return 0;
+  case  5: return 0;
+  case  6: return 0;
+  case  7: return 0;
+
+  case  8: return r;
+  case  9: return l;
+  case 10: return (speed >> 1) & 1;
+  case 11: return (speed >> 0) & 1;
+
+  case 12: return 0;  //signature
+  case 13: return 0;  // ||
+  case 14: return 0;  // ||
+  case 15: return 1;  // ||
+
+  case 16: return dy;
+  case 17: return (y >> 6) & 1;
+  case 18: return (y >> 5) & 1;
+  case 19: return (y >> 4) & 1;
+  case 20: return (y >> 3) & 1;
+  case 21: return (y >> 2) & 1;
+  case 22: return (y >> 1) & 1;
+  case 23: return (y >> 0) & 1;
+
+  case 24: return dx;
+  case 25: return (x >> 6) & 1;
+  case 26: return (x >> 5) & 1;
+  case 27: return (x >> 4) & 1;
+  case 28: return (x >> 3) & 1;
+  case 29: return (x >> 2) & 1;
+  case 30: return (x >> 1) & 1;
+  case 31: return (x >> 0) & 1;
+  }
+}
+
+uint2 Mouse::data1() {
+  return data() << 1;
+}
+
+uint5 Mouse::data2() {
+  return 0;
+}
+
+void Mouse::latch(bool data) {
+  if(latched == data) return;
+  latched = data;
+  counter = 0;
+
+  x = interface->inputPoll(port, (unsigned)Input::Device::Mouse, 0);  //-n = left, 0 = center, +n = right
+  y = interface->inputPoll(port, (unsigned)Input::Device::Mouse, 1);  //-n = up,   0 = center, +n = down
+  l = interface->inputPoll(port, (unsigned)Input::Device::Mouse, 2);
+  r = interface->inputPoll(port, (unsigned)Input::Device::Mouse, 3);
+
+  dx = x < 0;  //0 = right, 1 = left
+  dy = y < 0;  //0 = down,  1 = up
+
+  if(x < 0) x = -x;  //abs(position_x)
+  if(y < 0) y = -y;  //abs(position_y)
+
+  double multiplier = 1.0;
+  if(speed == 1) multiplier = 1.5;
+  if(speed == 2) multiplier = 2.0;
+  x = (double)x * multiplier;
+  y = (double)y * multiplier;
+
+  x = min(127, x);
+  y = min(127, y);
+}
+
+Mouse::Mouse(unsigned port) : Controller(port) {
+  latched = 0;
+  counter = 0;
+
+  speed = 0;
+  x = 0;
+  y = 0;
+  dx = 0;
+  dy = 0;
+  l = 0;
+  r = 0;
+}
+
+#endif
diff --git a/fc/controller/mouse/mouse.hpp b/fc/controller/mouse/mouse.hpp
new file mode 100644
index 0000000..7efd077
--- /dev/null
+++ b/fc/controller/mouse/mouse.hpp
@@ -0,0 +1,19 @@
+struct Mouse : Controller {
+  uint5 data();
+  uint2 data1();
+  uint5 data2();
+  void latch(bool data);
+  Mouse(unsigned port);
+
+private:
+  bool latched;
+  unsigned counter;
+
+  unsigned speed;  //0 = slow, 1 = normal, 2 = fast
+  signed x;        //x-coordinate
+  signed y;        //y-coordinate
+  bool dx;         //x-direction
+  bool dy;         //y-direction
+  bool l;          //left button
+  bool r;          //right button
+};
diff --git a/fc/controller/sfcgamepad/sfcgamepad.cpp b/fc/controller/sfcgamepad/sfcgamepad.cpp
new file mode 100644
index 0000000..279ca10
--- /dev/null
+++ b/fc/controller/sfcgamepad/sfcgamepad.cpp
@@ -0,0 +1,65 @@
+#ifdef CONTROLLER_CPP
+
+uint5 SFCGamepad::data() {
+  if(counter >= 16) return 1;
+  if(latched == 1) return interface->inputPoll(port, (unsigned)Input::Device::SFCJoypad, (unsigned)Input::JoypadID::A);
+
+  //note: D-pad physically prevents up+down and left+right from being pressed at the same time
+  switch(counter++) {
+  case  0: return b;
+  case  1: return y;
+  case  2: return select;
+  case  3: return start;
+  case  4: return up & !down;
+  case  5: return down & !up;
+  case  6: return left & !right;
+  case  7: return right & !left;
+  case  8: return a;
+  case  9: return x;
+  case 10: return l;
+  case 11: return r;
+  }
+
+  return 0;  //12-15: signature
+}
+
+uint2 SFCGamepad::data1() {
+  return ((data() << 1) & 0x02);
+}
+
+uint5 SFCGamepad::data2() {
+  return 0;
+}
+
+void SFCGamepad::latch(bool data) {
+  if(latched == data) return;
+  latched = data;
+  counter = 0;
+
+  if(latched == 0) {
+    unsigned id = (unsigned)Input::Device::SFCJoypad;
+    b      = interface->inputPoll(port, id,  0);
+    y      = interface->inputPoll(port, id,  1);
+    select = interface->inputPoll(port, id,  2);
+    start  = interface->inputPoll(port, id,  3);
+    up     = interface->inputPoll(port, id,  4);
+    down   = interface->inputPoll(port, id,  5);
+    left   = interface->inputPoll(port, id,  6);
+    right  = interface->inputPoll(port, id,  7);
+    a      = interface->inputPoll(port, id,  8);
+    x      = interface->inputPoll(port, id,  9);
+    l      = interface->inputPoll(port, id, 10);
+    r      = interface->inputPoll(port, id, 11);
+  }
+}
+
+SFCGamepad::SFCGamepad(unsigned port) : Controller(port) {
+  latched = 0;
+  counter = 0;
+
+  b = y = select = start = 0;
+  up = down = left = right = 0;
+  a = x = l = r = 0;
+}
+
+#endif
diff --git a/fc/controller/sfcgamepad/sfcgamepad.hpp b/fc/controller/sfcgamepad/sfcgamepad.hpp
new file mode 100644
index 0000000..7acc3f6
--- /dev/null
+++ b/fc/controller/sfcgamepad/sfcgamepad.hpp
@@ -0,0 +1,15 @@
+struct SFCGamepad : Controller {
+  uint5 data();
+  uint2 data1();
+  uint5 data2();
+  void latch(bool data);
+  SFCGamepad(unsigned port);
+
+private:
+  bool latched;
+  unsigned counter;
+
+  bool b, y, select, start;
+  bool up, down, left, right;
+  bool a, x, l, r;
+};
diff --git a/fc/controller/vsbeamgun/vsbeamgun.cpp b/fc/controller/vsbeamgun/vsbeamgun.cpp
new file mode 100644
index 0000000..f0aa759
--- /dev/null
+++ b/fc/controller/vsbeamgun/vsbeamgun.cpp
@@ -0,0 +1,80 @@
+#ifdef CONTROLLER_CPP
+
+void VSBeamGun::enter() {
+  unsigned prev = 0;
+  while(true) {
+    unsigned next = ppu.status.ly * 341 + ppu.status.lx;
+
+    if(light > 0) light -= 1;
+
+    if(!offscreen) {
+      unsigned target = y * 341 + x + 3;
+      if(next >= target && prev < target) {
+        //CRT raster detected
+        //light remains in the gun for 10-25 scanlines
+        if(read_light()) light = 341 * 16;
+      }
+    }
+
+    if(next < prev) {
+      if(triggertime > 0) triggertime -= 1;
+      //Vcounter wrapped back to zero; update cursor coordinates for start of new frame
+      int nx = interface->inputPoll(port, (unsigned)Input::Device::BeamGun, (unsigned)Input::BeamGunID::X);
+      int ny = interface->inputPoll(port, (unsigned)Input::Device::BeamGun, (unsigned)Input::BeamGunID::Y);
+      nx += x;
+      ny += y;
+      x = max(-16, min(256 + 16, nx));
+      y = max(-16, min(240 + 16, ny));
+      offscreen = (x < 0 || y < 0 || x >= 256 || y >= 240);
+    }
+
+    prev = next;
+    step(2);
+  }
+}
+
+uint5 VSBeamGun::data() {
+  if(counter >= 8) return 1;
+  if(latched == 1) return 0;
+
+  switch(counter++) {
+  case 0: return 0;
+  case 1: return 0;
+  case 2: return 0;
+  case 3: return 0;
+  case 4: return 1; // connected
+  case 5: return 0;
+  case 6: return light == 0;
+  case 7:
+    bool newtrigger = interface->inputPoll(port, (unsigned)Input::Device::BeamGun, (unsigned)Input::BeamGunID::Trigger);
+    if(newtrigger && !triggerlock) {
+      triggertime = 2;
+      triggerlock = true;
+    } else if(!newtrigger) {
+      triggerlock = false;
+    }
+    return triggertime > 0;
+  }
+}
+
+bool VSBeamGun::read_light() {
+  if(offscreen) return false;
+  uint32 color = ppu.buffer[y * 256 + x];
+  return ((color & 0x20) && ((color & 0x0F) < 0x0D));
+}
+
+void VSBeamGun::latch(bool data) {
+  if(latched == data) return;
+  latched = data;
+}
+
+VSBeamGun::VSBeamGun(unsigned port) : Controller(port) {
+  create(Controller::Enter, system.cpu_frequency());
+  latched = 0;
+
+  //center cursor onscreen
+  x = 256 / 2;
+  y = 240 / 2;
+}
+
+#endif
diff --git a/fc/controller/vsbeamgun/vsbeamgun.hpp b/fc/controller/vsbeamgun/vsbeamgun.hpp
new file mode 100644
index 0000000..595a614
--- /dev/null
+++ b/fc/controller/vsbeamgun/vsbeamgun.hpp
@@ -0,0 +1,19 @@
+struct VSBeamGun : Controller {
+  void enter();
+  uint5 data();
+  bool read_light();
+  void latch(bool data);
+  VSBeamGun(unsigned port);
+
+//private:
+  bool latched;
+  unsigned counter;
+
+  signed x, y;
+  unsigned light;
+  unsigned triggertime;
+
+  bool offscreen;
+
+  bool triggerlock;
+};
diff --git a/fc/controller/vspanel/vspanel.cpp b/fc/controller/vspanel/vspanel.cpp
new file mode 100644
index 0000000..2e0fa57
--- /dev/null
+++ b/fc/controller/vspanel/vspanel.cpp
@@ -0,0 +1,54 @@
+#ifdef CONTROLLER_CPP
+
+uint5 VSPanel::data() {
+  unsigned data = 0x00;
+  if(interface->inputPoll(port, (unsigned)Input::Device::VSPanel, 4)) data |= 0x01; // service button
+  if(interface->inputPoll(port, (unsigned)Input::Device::VSPanel, 5)) data |= 0x08; // coin 1
+  if(interface->inputPoll(port, (unsigned)Input::Device::VSPanel, 6)) data |= 0x10; // coin 2
+  // data will be left-shifted twice and OR'd into $4016 in CPU
+  return data;
+}
+
+uint2 VSPanel::data1() {
+  if(counter1 >= 8) return 1;
+  if(latched == 1) return 0;
+
+  switch(counter1++) { default: return 0;
+  case 2: return b1;
+  case 3: return b3;
+  }
+}
+
+uint5 VSPanel::data2() {
+  if(counter2 >= 8) return 1;
+  if(latched == 1) return 0;
+
+  switch(counter2++) { default: return 0;
+  case 2: return b2;
+  case 3: return b4;
+  }
+}
+
+void VSPanel::latch(bool data) {
+  if(latched == data) return;
+  latched = data;
+  counter1 = 0;
+  counter2 = 0;
+
+  if(latched == 0) {
+    b1 = interface->inputPoll(port, (unsigned)Input::Device::VSPanel, 0);
+    b2 = interface->inputPoll(port, (unsigned)Input::Device::VSPanel, 1);
+    b3 = interface->inputPoll(port, (unsigned)Input::Device::VSPanel, 2);
+    b4 = interface->inputPoll(port, (unsigned)Input::Device::VSPanel, 3);
+  }
+}
+
+VSPanel::VSPanel(unsigned port) : Controller(port) {
+  latched = 0;
+  counter1 = 0;
+  counter2 = 0;
+
+  b1 = b2 = b3 = b4 = 0;
+}
+
+#endif
diff --git a/fc/controller/vspanel/vspanel.hpp b/fc/controller/vspanel/vspanel.hpp
new file mode 100644
index 0000000..22d9764
--- /dev/null
+++ b/fc/controller/vspanel/vspanel.hpp
@@ -0,0 +1,14 @@
+struct VSPanel : Controller {
+  uint5 data();
+  uint2 data1();
+  uint5 data2();
+  void latch(bool data);
+  VSPanel(unsigned port);
+
+private:
+  bool latched;
+  unsigned counter1;
+  unsigned counter2;
+
+  bool b1, b2, b3, b4;
+};
diff --git a/fc/cpu/cpu.cpp b/fc/cpu/cpu.cpp
index 652e138..bcf4e96 100644
--- a/fc/cpu/cpu.cpp
+++ b/fc/cpu/cpu.cpp
@@ -1,12 +1,38 @@
 #include <fc/fc.hpp>
 
+#define CPU_CPP
 namespace Famicom {
 
-#include "timing.cpp"
-#include "serialization.cpp"
 CPU cpu;
 
-void CPU::Enter() {
+#include "serialization.cpp"
+#include "timing/timing.cpp"
+
+void CPU::step(unsigned clocks) {
+  apu.clock -= clocks;
+  if(apu.clock < 0 && scheduler.sync != Scheduler::SynchronizeMode::All) co_switch(apu.thread);
+
+  ppu.clock -= clocks;
+  if(ppu.clock < 0 && scheduler.sync != Scheduler::SynchronizeMode::All) co_switch(ppu.thread);
+
+  cartridge.clock -= clocks;
+  if(cartridge.clock < 0 && scheduler.sync != Scheduler::SynchronizeMode::All) co_switch(cartridge.thread);
+
+  input.port1->clock -= clocks * (uint64)input.port1->frequency;
+  input.port2->clock -= clocks * (uint64)input.port2->frequency;
+  input.expansion->clock -= clocks * (uint64)input.expansion->frequency;
+  synchronize_controllers();
+}
+
+void CPU::synchronize_controllers() {
+  if(input.port1->clock < 0) co_switch(input.port1->thread);
+  if(input.port2->clock < 0) co_switch(input.port2->thread);
+  if(input.expansion->clock < 0) co_switch(input.expansion->thread);
+}
+
+void CPU::Enter() { cpu.enter(); }
+
+void CPU::enter() {
   while(true) {
     if(scheduler.sync == Scheduler::SynchronizeMode::All) {
       scheduler.exit(Scheduler::ExitReason::SynchronizeEvent);
@@ -25,17 +51,6 @@ void CPU::main() {
   exec();
 }
 
-void CPU::add_clocks(unsigned clocks) {
-  apu.clock -= clocks;
-  if(apu.clock < 0 && scheduler.sync != Scheduler::SynchronizeMode::All) co_switch(apu.thread);
-
-  ppu.clock -= clocks;
-  if(ppu.clock < 0 && scheduler.sync != Scheduler::SynchronizeMode::All) co_switch(ppu.thread);
-
-  cartridge.clock -= clocks;
-  if(cartridge.clock < 0 && scheduler.sync != Scheduler::SynchronizeMode::All) co_switch(cartridge.thread);
-}
-
 void CPU::power() {
   R6502::power();
 
@@ -48,7 +63,7 @@ void CPU::power() {
 
 void CPU::reset() {
   R6502::reset();
-  create(CPU::Enter, 21477272);
+  create(CPU::Enter, system.cpu_frequency());
 
   regs.pc  = bus.read(0xfffc) << 0;
   regs.pc |= bus.read(0xfffd) << 8;
@@ -66,9 +81,9 @@ void CPU::reset() {
   status.oam_dma_pending = false;
   status.oam_dma_page = 0x00;
 
-  status.controller_latch = false;
-  status.controller_port0 = 0;
-  status.controller_port1 = 0;
+  //status.controller_latch = false;
+  //status.controller_port0 = 0;
+  //status.controller_port1 = 0;
 }
 
 uint8 CPU::debugger_read(uint16 addr) {
@@ -84,12 +99,16 @@ void CPU::ram_write(uint16 addr, uint8 data) {
 }
 
 uint8 CPU::read(uint16 addr) {
-  if(addr == 0x4016) {
-    return (mdr() & 0xc0) | input.data(0);
-  }
+  if(system.revision != System::Revision::VSSystem) {
+    if(addr == 0x4016) {
+      return (mdr() & 0xe0) | input.port1->data() | input.expansion->data1();
+    }
 
-  if(addr == 0x4017) {
-    return (mdr() & 0xc0) | input.data(1);
+    if(addr == 0x4017) {
+      return (mdr() & 0xe0) | input.port2->data() | input.expansion->data2();
+    }
+  } else { // if using VS. System
+    if(addr >= 0x4016 && addr <= 0x5fff) return vsarcadeboard.read(addr);
   }
 
   return apu.read(addr);
@@ -101,8 +120,14 @@ void CPU::write(uint16 addr, uint8 data) {
     status.oam_dma_pending = true;
   }
 
-  if(addr == 0x4016) {
-    input.latch(data & 0x01);
+  if(system.revision != System::Revision::VSSystem) {
+    if(addr == 0x4016) {
+      input.port1->latch(data & 1);
+      input.port2->latch(data & 1);
+      input.expansion->latch(data & 1);
+    }
+  } else { // if using VS. System
+    if(addr >= 0x4016 && addr <= 0x5fff) vsarcadeboard.write(addr, data);
   }
 
   return apu.write(addr, data);
diff --git a/fc/cpu/cpu.hpp b/fc/cpu/cpu.hpp
index b265292..4bdfb15 100644
--- a/fc/cpu/cpu.hpp
+++ b/fc/cpu/cpu.hpp
@@ -1,29 +1,12 @@
 struct CPU : Processor::R6502, Thread {
   uint8 ram[0x0800];
 
-  struct Status {
-    bool interrupt_pending;
-    bool nmi_pending;
-    bool nmi_line;
-    bool irq_line;
-    bool irq_apu_line;
-
-    bool rdy_line;
-    bool rdy_addr_valid;
-    uint16 rdy_addr_value;
-
-    bool oam_dma_pending;
-    uint8 oam_dma_page;
-
-    bool controller_latch;
-    unsigned controller_port0;
-    unsigned controller_port1;
-  } status;
+  enum : bool { Threaded = true };
+  alwaysinline void step(unsigned clocks);
+  void synchronize_controllers();
 
-  static void Enter();
+  void enter();
   void main();
-  void add_clocks(unsigned clocks);
-
   void power();
   void reset();
 
@@ -37,20 +20,29 @@ struct CPU : Processor::R6502, Thread {
 
   void serialize(serializer&);
 
-  //timing.cpp
-  uint8 op_read(uint16 addr);
-  void op_write(uint16 addr, uint8 data);
-  void last_cycle();
-  void nmi(uint16 &vector);
+//privileged:
+  #include "timing/timing.hpp"
+
+  struct Status {
+    bool interrupt_pending;
+    bool nmi_pending;
+    bool nmi_line;
+    bool irq_line;
+    bool irq_apu_line;
+
+    bool rdy_line;
+    bool rdy_addr_valid;
+    uint16 rdy_addr_value;
 
-  void oam_dma();
+    bool oam_dma_pending;
+    uint8 oam_dma_page;
 
-  void set_nmi_line(bool);
-  void set_irq_line(bool);
-  void set_irq_apu_line(bool);
+    //bool controller_latch;
+    //unsigned controller_port0;
+    //unsigned controller_port1;
+  } status;
 
-  void set_rdy_line(bool);
-  void set_rdy_addr(bool valid, uint16 value = 0);
+  static void Enter();
 };
 
 extern CPU cpu;
diff --git a/fc/cpu/serialization.cpp b/fc/cpu/serialization.cpp
index 833453e..d3277d9 100644
--- a/fc/cpu/serialization.cpp
+++ b/fc/cpu/serialization.cpp
@@ -1,3 +1,5 @@
+#ifdef CPU_CPP
+
 void CPU::serialize(serializer& s) {
   R6502::serialize(s);
   Thread::serialize(s);
@@ -17,7 +19,9 @@ void CPU::serialize(serializer& s) {
   s.integer(status.oam_dma_pending);
   s.integer(status.oam_dma_page);
 
-  s.integer(status.controller_latch);
-  s.integer(status.controller_port0);
-  s.integer(status.controller_port1);
+  //s.integer(status.controller_latch);
+  //s.integer(status.controller_port0);
+  //s.integer(status.controller_port1);
 }
+
+#endif
diff --git a/fc/cpu/timing.cpp b/fc/cpu/timing.cpp
deleted file mode 100644
index 8654710..0000000
--- a/fc/cpu/timing.cpp
+++ /dev/null
@@ -1,64 +0,0 @@
-uint8 CPU::op_read(uint16 addr) {
-  if(status.oam_dma_pending) {
-    status.oam_dma_pending = false;
-    op_read(addr);
-    oam_dma();
-  }
-
-  while(status.rdy_line == 0) {
-    regs.mdr = bus.read(status.rdy_addr_valid ? status.rdy_addr_value : addr);
-    add_clocks(12);
-  }
-
-  regs.mdr = bus.read(addr);
-  add_clocks(12);
-  return regs.mdr;
-}
-
-void CPU::op_write(uint16 addr, uint8 data) {
-  bus.write(addr, regs.mdr = data);
-  add_clocks(12);
-}
-
-void CPU::last_cycle() {
-  status.interrupt_pending = ((status.irq_line | status.irq_apu_line) & ~regs.p.i) | status.nmi_pending;
-}
-
-void CPU::nmi(uint16 &vector) {
-  if(status.nmi_pending) {
-    status.nmi_pending = false;
-    vector = 0xfffa;
-  }
-}
-
-void CPU::oam_dma() {
-  for(unsigned n = 0; n < 256; n++) {
-    uint8 data = op_read((status.oam_dma_page << 8) + n);
-    op_write(0x2004, data);
-  }
-}
-
-void CPU::set_nmi_line(bool line) {
-  //edge-sensitive (0->1)
-  if(!status.nmi_line && line) status.nmi_pending = true;
-  status.nmi_line = line;
-}
-
-void CPU::set_irq_line(bool line) {
-  //level-sensitive
-  status.irq_line = line;
-}
-
-void CPU::set_irq_apu_line(bool line) {
-  //level-sensitive
-  status.irq_apu_line = line;
-}
-
-void CPU::set_rdy_line(bool line) {
-  status.rdy_line = line;
-}
-
-void CPU::set_rdy_addr(bool valid, uint16 value) {
-  status.rdy_addr_valid = valid;
-  status.rdy_addr_value = value;
-}
diff --git a/fc/cpu/timing/timing.cpp b/fc/cpu/timing/timing.cpp
new file mode 100644
index 0000000..cb57830
--- /dev/null
+++ b/fc/cpu/timing/timing.cpp
@@ -0,0 +1,72 @@
+#ifdef CPU_CPP
+
+void CPU::add_clocks(unsigned clocks) {
+  step(clocks);
+}
+
+uint8 CPU::op_read(uint16 addr) {
+  if(status.oam_dma_pending) {
+    status.oam_dma_pending = false;
+    op_read(addr);
+    oam_dma();
+  }
+
+  while(status.rdy_line == 0) {
+    regs.mdr = bus.read(status.rdy_addr_valid ? status.rdy_addr_value : addr);
+    add_clocks(system.region() == System::Region::NTSC ? 12 : 16);
+  }
+
+  regs.mdr = bus.read(addr);
+  add_clocks(system.region() == System::Region::NTSC ? 12 : 16);
+  return regs.mdr;
+}
+
+void CPU::op_write(uint16 addr, uint8 data) {
+  bus.write(addr, regs.mdr = data);
+  add_clocks(system.region() == System::Region::NTSC ? 12 : 16);
+}
+
+void CPU::last_cycle() {
+  status.interrupt_pending = ((status.irq_line | status.irq_apu_line) & ~regs.p.i) | status.nmi_pending;
+}
+
+void CPU::nmi(uint16 &vector) {
+  if(status.nmi_pending) {
+    status.nmi_pending = false;
+    vector = 0xfffa;
+  }
+}
+
+void CPU::oam_dma() {
+  for(unsigned n = 0; n < 256; n++) {
+    uint8 data = op_read((status.oam_dma_page << 8) + n);
+    op_write(0x2004, data);
+  }
+}
+
+void CPU::set_nmi_line(bool line) {
+  //edge-sensitive (0->1)
+  if(!status.nmi_line && line) status.nmi_pending = true;
+  status.nmi_line = line;
+}
+
+void CPU::set_irq_line(bool line) {
+  //level-sensitive
+  status.irq_line = line;
+}
+
+void CPU::set_irq_apu_line(bool line) {
+  //level-sensitive
+  status.irq_apu_line = line;
+}
+
+void CPU::set_rdy_line(bool line) {
+  status.rdy_line = line;
+}
+
+void CPU::set_rdy_addr(bool valid, uint16 value) {
+  status.rdy_addr_valid = valid;
+  status.rdy_addr_value = value;
+}
+
+#endif
diff --git a/fc/cpu/timing/timing.hpp b/fc/cpu/timing/timing.hpp
new file mode 100644
index 0000000..4317e6c
--- /dev/null
+++ b/fc/cpu/timing/timing.hpp
@@ -0,0 +1,14 @@
+void add_clocks(unsigned clocks);
+uint8 op_read(uint16 addr);
+void op_write(uint16 addr, uint8 data);
+void last_cycle();
+void nmi(uint16 &vector);
+
+void oam_dma();
+
+void set_nmi_line(bool);
+void set_irq_line(bool);
+void set_irq_apu_line(bool);
+
+void set_rdy_line(bool);
+void set_rdy_addr(bool valid, uint16 value = 0);
diff --git a/fc/fc.hpp b/fc/fc.hpp
index 3fce8b0..ad8d27e 100644
--- a/fc/fc.hpp
+++ b/fc/fc.hpp
@@ -46,16 +46,17 @@ namespace Famicom {
     }
   };
 
-  #include <fc/system/system.hpp>
-  #include <fc/scheduler/scheduler.hpp>
-  #include <fc/input/input.hpp>
   #include <fc/memory/memory.hpp>
-  #include <fc/cartridge/cartridge.hpp>
+
   #include <fc/cpu/cpu.hpp>
   #include <fc/apu/apu.hpp>
   #include <fc/ppu/ppu.hpp>
+
+  #include <fc/controller/controller.hpp>
+  #include <fc/system/system.hpp>
+  #include <fc/arcade/arcade.hpp>
+  #include <fc/cartridge/cartridge.hpp>
   #include <fc/cheat/cheat.hpp>
-  #include <fc/video/video.hpp>
   #include <fc/interface/interface.hpp>
 }
 
diff --git a/fc/input/input.cpp b/fc/input/input.cpp
deleted file mode 100644
index 31c6b15..0000000
--- a/fc/input/input.cpp
+++ /dev/null
@@ -1,53 +0,0 @@
-#include <fc/fc.hpp>
-
-namespace Famicom {
-
-#include "serialization.cpp"
-Input input;
-
-void Input::latch(bool data) {
-  latchdata = data;
-
-  if(latchdata == 1) {
-    counter1 = 0;
-    counter2 = 0;
-  }
-}
-
-bool Input::data(bool port) {
-  bool result = 0;
-
-  if(port == 0) {
-    if(port1 == Device::Joypad) {
-      if(counter1 >= 8) return 1;
-      result = interface->inputPoll(0, 0u, counter1);
-      if(latchdata == 0) counter1++;
-    }
-  }
-
-  if(port == 1) {
-    if(port2 == Device::Joypad) {
-      if(counter2 >= 8) return 1;
-      result = interface->inputPoll(1, 0u, counter2);
-      if(latchdata == 0) counter2++;
-    }
-  }
-
-  return result;
-}
-
-void Input::connect(bool port, Device device) {
-  if(port == 0) port1 = device, counter1 = 0;
-  if(port == 1) port2 = device, counter2 = 0;
-}
-
-void Input::power() {
-}
-
-void Input::reset() {
-  latchdata = 0;
-  counter1 = 0;
-  counter2 = 0;
-}
-
-}
diff --git a/fc/input/input.hpp b/fc/input/input.hpp
deleted file mode 100644
index 8e42476..0000000
--- a/fc/input/input.hpp
+++ /dev/null
@@ -1,25 +0,0 @@
-struct Input {
-  enum class Device : unsigned {
-    Joypad,
-    None,
-  };
-
-  void latch(bool data);
-  bool data(bool port);
-  void connect(bool port, Device device);
-
-  void power();
-  void reset();
-
-  void serialize(serializer&);
-
-private:
-  Device port1;
-  Device port2;
-
-  bool latchdata;
-  unsigned counter1;
-  unsigned counter2;
-};
-
-extern Input input;
diff --git a/fc/input/serialization.cpp b/fc/input/serialization.cpp
deleted file mode 100644
index c0eb132..0000000
--- a/fc/input/serialization.cpp
+++ /dev/null
@@ -1,8 +0,0 @@
-void Input::serialize(serializer& s) {
-  s.integer((unsigned&)port1);
-  s.integer((unsigned&)port2);
-
-  s.integer(latchdata);
-  s.integer(counter1);
-  s.integer(counter2);
-}
diff --git a/fc/interface/interface.cpp b/fc/interface/interface.cpp
index 1d38d2b..d48e4b9 100644
--- a/fc/interface/interface.cpp
+++ b/fc/interface/interface.cpp
@@ -9,11 +9,17 @@ string Interface::title() {
 }
 
 double Interface::videoFrequency() {
-  return 21477272.0 / (262.0 * 1364.0 - 4.0);
+  switch(system.region()) { default:
+  case System::Region::NTSC: return system.cpu_frequency() / (262.0 * 1364.0 - 4.0);
+  case System::Region::PAL:  return system.cpu_frequency() / (312.0 * 1705.0);
+  }
 }
 
 double Interface::audioFrequency() {
-  return 21477272.0 / 12.0;
+  switch(system.region()) { default:
+  case System::Region::NTSC: return system.cpu_frequency() / 12.0;
+  case System::Region::PAL:  return system.cpu_frequency() / 16.0;
+  }
 }
 
 bool Interface::loaded() {
@@ -31,14 +37,22 @@ unsigned Interface::group(unsigned id) {
   case ID::ProgramRAM:
   case ID::CharacterROM:
   case ID::CharacterRAM:
-    return 1;
+    switch(system.revision) {
+    case System::Revision::Famicom:      return ID::Famicom;
+    case System::Revision::PlayChoice10: return ID::PlayChoice10;
+    case System::Revision::VSSystem:     return ID::VSSystem;
+    }
   }
 
   throw;
 }
 
 void Interface::load(unsigned id) {
-  cartridge.load();
+  switch(id) {
+  case ID::Famicom:      cartridge.load(System::Revision::Famicom);      break;
+  case ID::PlayChoice10: cartridge.load(System::Revision::PlayChoice10); break;
+  case ID::VSSystem:     cartridge.load(System::Revision::VSSystem);     break;
+  }
 }
 
 void Interface::save() {
@@ -48,7 +62,7 @@ void Interface::save() {
 }
 
 void Interface::load(unsigned id, const stream& stream) {
-  if(id == ID::Manifest) cartridge.information.markup = stream.text();
+  if(id == ID::Manifest) cartridge.information.markup.cartridge = stream.text();
 
   if(id == ID::ProgramROM) {
     stream.read(cartridge.board->prgrom.data, min(cartridge.board->prgrom.size, stream.size()));
@@ -82,6 +96,18 @@ void Interface::unload() {
   cartridge.unload();
 }
 
+void Interface::connect(unsigned port, unsigned device) {
+  if(!system.vs()) {
+    // Don't allow switching to VS. Panel
+    if(device == (unsigned)Input::Device::VSPanel)
+      device = (unsigned)Input::Device::None;
+    input.connect(port, (Input::Device)device);
+  } else { // When using VS. System
+    // Don't allow switching devices at all
+    if(port == 2 && device != (unsigned)Input::Device::VSPanel) return;
+  }
+}
+
 void Interface::power() {
   system.power();
 }
@@ -105,6 +131,7 @@ bool Interface::unserialize(serializer& s) {
 
 void Interface::cheatSet(const lstring& list) {
   cheat.reset();
+
   for(auto& codeset : list) {
     lstring codes = codeset.split("+");
     for(auto& code : codes) {
@@ -119,8 +146,25 @@ void Interface::paletteUpdate(PaletteMode mode) {
   video.generate_palette(mode);
 }
 
+void Interface::exportMemory() {
+  string pathname = {path(group(ID::ProgramROM)), "debug/"};
+  directory::create(pathname);
+
+  file::write({pathname, "work.ram"}, cpu.ram, 0x0800);
+  file::write({pathname, "video.ram"}, ppu.ciram, 2048);
+  file::write({pathname, "palette.ram"}, ppu.cgram, 32);
+  file::write({pathname, "sprite.ram"}, ppu.oam, 256);
+  if(cartridge.board->prgram.size) {
+    file::write({pathname, "program.ram"}, cartridge.board->prgram.data, cartridge.board->prgram.size);
+  }
+  if(cartridge.board->chrram.size) {
+    file::write({pathname, "character.ram"}, cartridge.board->chrram.data, cartridge.board->chrram.size);
+  }
+}
+
 Interface::Interface() {
   interface = this;
+  system.init();
 
   information.name        = "Famicom";
   information.width       = 256;
@@ -131,10 +175,16 @@ Interface::Interface() {
   information.capability.states = true;
   information.capability.cheats = true;
 
-  media.append({ID::Famicom, "Famicom", "fc", true});
+  media.append({ID::Famicom,      "Famicom",       "fc",   true});
+  media.append({ID::PlayChoice10, "PlayChoice-10", "pc10", true});
+  media.append({ID::VSSystem,     "VS. System",    "vs",   true});
 
   {
-    Device device{0, ID::Port1 | ID::Port2, "Controller"};
+    Device device{
+      (unsigned)Input::Device::Joypad,
+      ID::Port1 | ID::Port2 | ID::ExpansionPort,
+      "Controller"
+    };
     device.input.append({0, 0, "A"     });
     device.input.append({1, 0, "B"     });
     device.input.append({2, 0, "Select"});
@@ -147,8 +197,150 @@ Interface::Interface() {
     this->device.append(device);
   }
 
+  {
+    Device device{
+      (unsigned)Input::Device::FourPlayers,
+      ID::ExpansionPort,
+      "4-Players Adaptor"
+    };
+    for(unsigned p = 3, n = 0; p <= 4; p += 1, n += 8) {
+      device.input.append({n + 0, 0, {"Port ", p, " - ", "A"     }});
+      device.input.append({n + 1, 0, {"Port ", p, " - ", "B"     }});
+      device.input.append({n + 2, 0, {"Port ", p, " - ", "Select"}});
+      device.input.append({n + 3, 0, {"Port ", p, " - ", "Start" }});
+      device.input.append({n + 4, 0, {"Port ", p, " - ", "Up"    }});
+      device.input.append({n + 5, 0, {"Port ", p, " - ", "Down"  }});
+      device.input.append({n + 6, 0, {"Port ", p, " - ", "Left"  }});
+      device.input.append({n + 7, 0, {"Port ", p, " - ", "Right" }});
+      device.order.append(n + 4, n + 5, n + 6, n + 7);
+      device.order.append(n + 1, n + 0, n + 2, n + 3);
+    }
+    this->device.append(device);
+  }
+
+  {
+    Device device{
+      (unsigned)Input::Device::FourScore,
+      ID::Port1,
+      "Four Score"
+    };
+    for(unsigned p = 1, n = 0; p <= 4; p += 2, n += 8) {
+      device.input.append({n + 0, 0, {"Port ", p, " - ", "A"     }});
+      device.input.append({n + 1, 0, {"Port ", p, " - ", "B"     }});
+      device.input.append({n + 2, 0, {"Port ", p, " - ", "Select"}});
+      device.input.append({n + 3, 0, {"Port ", p, " - ", "Start" }});
+      device.input.append({n + 4, 0, {"Port ", p, " - ", "Up"    }});
+      device.input.append({n + 5, 0, {"Port ", p, " - ", "Down"  }});
+      device.input.append({n + 6, 0, {"Port ", p, " - ", "Left"  }});
+      device.input.append({n + 7, 0, {"Port ", p, " - ", "Right" }});
+      device.order.append(n + 4, n + 5, n + 6, n + 7);
+      device.order.append(n + 1, n + 0, n + 2, n + 3);
+    }
+    this->device.append(device);
+  }
+
+  {
+    Device device{
+      (unsigned)Input::Device::FourScore,
+      ID::Port2,
+      "Four Score"
+    };
+    for(unsigned p = 2, n = 0; p <= 4; p += 2, n += 8) {
+      device.input.append({n + 0, 0, {"Port ", p, " - ", "A"     }});
+      device.input.append({n + 1, 0, {"Port ", p, " - ", "B"     }});
+      device.input.append({n + 2, 0, {"Port ", p, " - ", "Select"}});
+      device.input.append({n + 3, 0, {"Port ", p, " - ", "Start" }});
+      device.input.append({n + 4, 0, {"Port ", p, " - ", "Up"    }});
+      device.input.append({n + 5, 0, {"Port ", p, " - ", "Down"  }});
+      device.input.append({n + 6, 0, {"Port ", p, " - ", "Left"  }});
+      device.input.append({n + 7, 0, {"Port ", p, " - ", "Right" }});
+      device.order.append(n + 4, n + 5, n + 6, n + 7);
+      device.order.append(n + 1, n + 0, n + 2, n + 3);
+    }
+    this->device.append(device);
+  }
+
+  {
+    Device device{
+      (unsigned)Input::Device::BeamGun,
+      ID::ExpansionPort,
+      "Beam Gun"
+    };
+    device.input.append({0, 1, "X-axis" });
+    device.input.append({1, 1, "Y-axis" });
+    device.input.append({2, 0, "Trigger"});
+    device.order = {0, 1, 2};
+    this->device.append(device);
+  }
+
+  {
+    Device device{
+      (unsigned)Input::Device::BeamGun,
+      ID::Port2,
+      "Zapper"
+    };
+    device.input.append({0, 1, "X-axis" });
+    device.input.append({1, 1, "Y-axis" });
+    device.input.append({2, 0, "Trigger"});
+    device.order = {0, 1, 2};
+    this->device.append(device);
+  }
+
+  {
+    Device device{
+      (unsigned)Input::Device::FamilyTrainer,
+      ID::ExpansionPort,
+      "Family Trainer"
+    };
+    for(unsigned n = 0; n <= 11; n++) {
+      device.input.append({n, 0, {"Button ", n + 1}});
+    }
+    device.order = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};
+    this->device.append(device);
+  }
+
+  {
+    Device device{
+      (unsigned)Input::Device::FamilyTrainer,
+      ID::Port2,
+      "Power Pad"
+    };
+    for(unsigned n = 0; n <= 11; n++) {
+      device.input.append({n, 0, {"Button ", n + 1}});
+    }
+    device.order = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};
+    this->device.append(device);
+  }
+
+  {
+    Device device{
+      (unsigned)Input::Device::VSPanel,
+      ID::ExpansionPort,
+      "VS. Panel"
+    };
+    device.input.append({0, 0, "Button 1"      });
+    device.input.append({1, 0, "Button 2"      });
+    device.input.append({2, 0, "Button 3"      });
+    device.input.append({3, 0, "Button 4"      });
+    device.input.append({4, 0, "Service Button"});
+    device.input.append({5, 0, "Coin 1"        });
+    device.input.append({6, 0, "Coin 2"        });
+    device.order = {0, 1, 2, 3, 4, 5, 6};
+    this->device.append(device);
+  }
+
+  {
+    Device device{
+      (unsigned)Input::Device::None,
+      ID::Port1 | ID::Port2 | ID::ExpansionPort,
+      "None"
+    };
+    this->device.append(device);
+  }
+
   port.append({0, "Port 1"});
   port.append({1, "Port 2"});
+  port.append({2, "Expansion Port"});
 
   for(auto& device : this->device) {
     for(auto& port : this->port) {
diff --git a/fc/interface/interface.hpp b/fc/interface/interface.hpp
index 63e9194..8c38ea3 100644
--- a/fc/interface/interface.hpp
+++ b/fc/interface/interface.hpp
@@ -4,21 +4,23 @@ namespace Famicom {
 
 struct ID {
   enum : unsigned {
+    //cartridges (folders)
     System,
     Famicom,
-  };
+    PlayChoice10,
+    VSSystem,
 
-  enum : unsigned {
+    //memory (files)
     Manifest,
     ProgramROM,
     ProgramRAM,
     CharacterROM,
     CharacterRAM,
-  };
 
-  enum : unsigned {
+    //controller ports
     Port1 = 1,
     Port2 = 2,
+    ExpansionPort = 4,
   };
 };
 
@@ -36,6 +38,7 @@ struct Interface : Emulator::Interface {
   void save(unsigned id, const stream& stream);
   void unload();
 
+  void connect(unsigned port, unsigned device);
   void power();
   void reset();
   void run();
@@ -47,9 +50,11 @@ struct Interface : Emulator::Interface {
 
   void paletteUpdate(PaletteMode mode);
 
+  //debugger functions
+  void exportMemory();
+
   Interface();
 
-private:
   vector<Device> device;
 };
 
diff --git a/fc/ppu/ppu.cpp b/fc/ppu/ppu.cpp
index b4de38a..7db13c5 100644
--- a/fc/ppu/ppu.cpp
+++ b/fc/ppu/ppu.cpp
@@ -1,10 +1,12 @@
 #include <fc/fc.hpp>
 
+#define PPU_CPP
 namespace Famicom {
 
-#include "serialization.cpp"
 PPU ppu;
 
+#include "serialization.cpp"
+
 void PPU::Main() {
   ppu.main();
 }
@@ -24,13 +26,24 @@ void PPU::tick() {
   if(status.ly == 241 && status.lx ==   0) status.nmi_flag = status.nmi_hold;
   if(status.ly == 241 && status.lx ==   2) cpu.set_nmi_line(status.nmi_enable && status.nmi_flag);
 
-  if(status.ly == 260 && status.lx == 340) status.sprite_zero_hit = 0, status.sprite_overflow = 0;
+  switch(system.region()) {
+  case System::Region::NTSC:
+    if(status.ly == 260 && status.lx == 340) status.sprite_zero_hit = 0, status.sprite_overflow = 0;
+
+    if(status.ly == 260 && status.lx == 340) status.nmi_hold = 0;
+    if(status.ly == 261 && status.lx ==   0) status.nmi_flag = status.nmi_hold;
+    if(status.ly == 261 && status.lx ==   2) cpu.set_nmi_line(status.nmi_enable && status.nmi_flag);
+    break;
+  case System::Region::PAL:
+    if(status.ly == 310 && status.lx == 340) status.sprite_zero_hit = 0, status.sprite_overflow = 0;
 
-  if(status.ly == 260 && status.lx == 340) status.nmi_hold = 0;
-  if(status.ly == 261 && status.lx ==   0) status.nmi_flag = status.nmi_hold;
-  if(status.ly == 261 && status.lx ==   2) cpu.set_nmi_line(status.nmi_enable && status.nmi_flag);
+    if(status.ly == 310 && status.lx == 340) status.nmi_hold = 0;
+    if(status.ly == 311 && status.lx ==   0) status.nmi_flag = status.nmi_hold;
+    if(status.ly == 311 && status.lx ==   2) cpu.set_nmi_line(status.nmi_enable && status.nmi_flag);
+    break;
+  }
 
-  clock += 4;
+  clock += (system.region() == System::Region::NTSC ? 4 : 5);
   if(clock >= 0) co_switch(cpu.thread);
 
   status.lx++;
@@ -38,7 +51,7 @@ void PPU::tick() {
 
 void PPU::scanline() {
   status.lx = 0;
-  if(++status.ly == 262) {
+  if(++status.ly == (system.region() == System::Region::NTSC ? 262 : 312)) {
     status.ly = 0;
     frame();
   }
@@ -54,7 +67,7 @@ void PPU::power() {
 }
 
 void PPU::reset() {
-  create(PPU::Main, 21477272);
+  create(PPU::Main, system.cpu_frequency());
 
   status.mdr = 0x00;
   status.field = 0;
@@ -105,30 +118,39 @@ uint8 PPU::read(uint16 addr) {
   case 2:  //PPUSTATUS
     result |= status.nmi_flag << 7;
     result |= status.sprite_zero_hit << 6;
-    result |= status.sprite_overflow << 5;
-    result |= status.mdr & 0x1f;
+    switch(revision) {
+    default:
+      result |= status.sprite_overflow << 5;
+      result |= status.mdr & 0x1f;
+      break;
+    case Revision::RC2C05_01:
+    case Revision::RC2C05_04: result |= 0x1b; break;
+    case Revision::RC2C05_02: result |= 0x3d; break;
+    case Revision::RC2C05_03: result |= 0x1c; break;
+    }
     status.address_latch = 0;
     status.nmi_hold = 0;
     cpu.set_nmi_line(status.nmi_flag = 0);
     break;
   case 4:  //OAMDATA
-    result = oam[status.oam_addr];
-    if((status.oam_addr & 3) == 3) result &= 0xe3;
+    switch(revision) {
+    case Revision::RP2C02C: result = status.mdr; break;
+    default:                result = oam[status.oam_addr]; break;
+    }
+    //if((status.oam_addr & 3) == 3) result &= 0xe3;
     break;
   case 7:  //PPUDATA
-    if(raster_enable() && (status.ly <= 240 || status.ly == 261)) return 0x00;
+    if(raster_enable() && (status.ly <= 240 || status.ly == (system.region() == System::Region::NTSC ? 261 : 311))) {
+      return 0x00;
+    }
 
     addr = status.vaddr & 0x3fff;
-    if(addr <= 0x1fff) {
-      result = status.bus_data;
-      status.bus_data = cartridge.chr_read(addr);
-    } else if(addr <= 0x3eff) {
+    if(addr <= 0x3eff) {
       result = status.bus_data;
-      status.bus_data = cartridge.chr_read(addr);
     } else if(addr <= 0x3fff) {
       result = cgram_read(addr);
-      status.bus_data = cartridge.chr_read(addr);
     }
+    status.bus_data = cartridge.chr_read(addr);
     status.vaddr += status.vram_increment;
     break;
   }
@@ -139,6 +161,14 @@ uint8 PPU::read(uint16 addr) {
 void PPU::write(uint16 addr, uint8 data) {
   status.mdr = data;
 
+  switch(revision) {
+  case Revision::RC2C05_01:
+  case Revision::RC2C05_02:
+  case Revision::RC2C05_03:
+  case Revision::RC2C05_04:
+  case Revision::RC2C05_05: if(addr & 6 == 0) addr ^= 1; break;
+  }
+
   switch(addr & 7) {
   case 0:  //PPUCTRL
     status.nmi_enable = data & 0x80;
@@ -161,6 +191,14 @@ void PPU::write(uint16 addr, uint8 data) {
   case 2:  //PPUSTATUS
     return;
   case 3:  //OAMADDR
+    if(revision != Revision::RP2C07) {
+      // below corruption code only applies for preferred CPU-PPU alignment.
+      // on an actual Famicom/NES, waiting a while after writing to OAM will
+      // make this corruption happen because the OAM will have decayed at the
+      // spot being written to.
+      for(int i = 0; i < 8; i++)
+        oam[((addr & 0xf800) >> 8) + i] = oam[(status.oam_addr & 0xf8) + i];
+    }
     status.oam_addr = data;
     return;
   case 4:  //OAMDATA
@@ -185,7 +223,9 @@ void PPU::write(uint16 addr, uint8 data) {
     status.address_latch ^= 1;
     return;
   case 7:  //PPUDATA
-    if(raster_enable() && (status.ly <= 240 || status.ly == 261)) return;
+    if(raster_enable() && (status.ly <= 240 || status.ly == (system.region() == System::Region::NTSC ? 261 : 311))) {
+      return;
+    }
 
     addr = status.vaddr & 0x3fff;
     if(addr <= 0x1fff) {
@@ -331,7 +371,7 @@ void PPU::raster_sprite() {
   if(raster_enable() == false) return;
 
   unsigned n = raster.oam_iterator++;
-  signed ly = (status.ly == 261 ? -1 : status.ly);
+  signed ly = (status.ly == (system.region() == System::Region::NTSC ? 261 : 311) ? -1 : status.ly);
   unsigned y = ly - oam[(n * 4) + 0];
 
   if(y >= sprite_height()) return;
@@ -349,7 +389,8 @@ void PPU::raster_sprite() {
 }
 
 void PPU::raster_scanline() {
-  if((status.ly >= 240 && status.ly <= 260)) {
+  unsigned last_scanline = system.region() == System::Region::NTSC ? 261 : 311;
+  if((status.ly >= 240 && status.ly <= last_scanline - 1)) {
     for(unsigned x = 0; x < 341; x++) tick();
     return scanline();
   }
@@ -437,7 +478,7 @@ void PPU::raster_scanline() {
     tick();
     tick();
 
-    if(raster_enable() && sprite == 6 && status.ly == 261) status.vaddr = status.taddr;  //304
+    if(raster_enable() && sprite == 6 && status.ly == last_scanline) status.vaddr = status.taddr;  //304
   }
 
   for(unsigned tile = 0; tile < 2; tile++) {  //320-335
@@ -471,7 +512,7 @@ void PPU::raster_scanline() {
   //336-339
   chr_load(0x2000 | (status.vaddr & 0x0fff));
   tick();
-  bool skip = (raster_enable() && status.field == 1 && status.ly == 261);
+  bool skip = (raster_enable() && status.field == 1 && status.ly == last_scanline);
   tick();
 
   chr_load(0x2000 | (status.vaddr & 0x0fff));
@@ -484,4 +525,41 @@ void PPU::raster_scanline() {
   return scanline();
 }
 
+//
+
+const uint9_t PPU::RP2C03[16 * 4] = {
+  0333,0014,0006,0326,0403,0503,0510,0420,0320,0120,0031,0040,0022,0000,0000,0000,
+  0555,0036,0027,0407,0507,0704,0700,0630,0430,0140,0040,0053,0044,0000,0000,0000,
+  0777,0357,0447,0637,0707,0737,0740,0750,0660,0360,0070,0276,0077,0000,0000,0000,
+  0777,0567,0657,0757,0747,0755,0764,0772,0773,0572,0473,0276,0467,0000,0000,0000,
+};
+
+const uint9_t PPU::RP2C04_0001[16 * 4] = {
+  0755,0637,0700,0447,0044,0120,0222,0704,0777,0333,0750,0503,0403,0660,0320,0777,
+  0357,0653,0310,0360,0467,0657,0764,0027,0760,0276,0000,0200,0666,0444,0707,0014,
+  0003,0567,0757,0070,0077,0022,0053,0507,0000,0420,0747,0510,0407,0006,0740,0000,
+  0000,0140,0555,0031,0572,0326,0770,0630,0020,0036,0040,0111,0773,0737,0430,0473,
+};
+
+const uint9_t PPU::RP2C04_0002[16 * 4] = {
+  0000,0750,0430,0572,0473,0737,0044,0567,0700,0407,0773,0747,0777,0637,0467,0040,
+  0020,0357,0510,0666,0053,0360,0200,0447,0222,0707,0003,0276,0657,0320,0000,0326,
+  0403,0764,0740,0757,0036,0310,0555,0006,0507,0760,0333,0120,0027,0000,0660,0777,
+  0653,0111,0070,0630,0022,0014,0704,0140,0000,0077,0420,0770,0755,0503,0031,0444,
+};
+
+const uint9_t PPU::RP2C04_0003[16 * 4] = {
+  0507,0737,0473,0555,0040,0777,0567,0120,0014,0000,0764,0320,0704,0666,0653,0467,
+  0447,0044,0503,0027,0140,0430,0630,0053,0333,0326,0000,0006,0700,0510,0747,0755,
+  0637,0020,0003,0770,0111,0750,0740,0777,0360,0403,0357,0707,0036,0444,0000,0310,
+  0077,0200,0572,0757,0420,0070,0660,0222,0031,0000,0657,0773,0407,0276,0760,0022,
+};
+
+const uint9_t PPU::RP2C04_0004[16 * 4] = {
+  0430,0326,0044,0660,0000,0755,0014,0630,0555,0310,0070,0003,0764,0770,0040,0572,
+  0737,0200,0027,0747,0000,0222,0510,0740,0653,0053,0447,0140,0403,0000,0473,0357,
+  0503,0031,0420,0006,0407,0507,0333,0704,0022,0666,0036,0020,0111,0773,0444,0707,
+  0757,0777,0320,0700,0760,0276,0777,0467,0000,0750,0637,0567,0360,0657,0077,0120,
+};
+
 }
diff --git a/fc/ppu/ppu.hpp b/fc/ppu/ppu.hpp
index 0a7cca0..1482a13 100644
--- a/fc/ppu/ppu.hpp
+++ b/fc/ppu/ppu.hpp
@@ -1,4 +1,28 @@
 struct PPU : Thread {
+  uint32 buffer[256 * 262];
+  uint8 ciram[2048];
+  uint8 cgram[32];
+  uint8 oam[256];
+
+  enum class Revision : unsigned {
+    RP2C02C,
+    RP2C02G,
+    RP2C07,
+    RP2C03B,
+    RP2C03G,
+    RP2C04_0001,
+    RP2C04_0002,
+    RP2C04_0003,
+    RP2C04_0004,
+    RC2C03B,
+    RC2C03C,
+    RC2C05_01,
+    RC2C05_02,
+    RC2C05_03,
+    RC2C05_04,
+    RC2C05_05,
+  } revision;
+
   static void Main();
   void main();
   void tick();
@@ -33,6 +57,12 @@ struct PPU : Thread {
   void raster_sprite();
   void raster_scanline();
 
+  static const uint9_t RP2C03[16 * 4];
+  static const uint9_t RP2C04_0001[16 * 4];
+  static const uint9_t RP2C04_0002[16 * 4];
+  static const uint9_t RP2C04_0003[16 * 4];
+  static const uint9_t RP2C04_0004[16 * 4];
+
   void serialize(serializer&);
 
   struct Status {
@@ -97,11 +127,6 @@ struct PPU : Thread {
       uint8 tiledatahi;
     } oam[8], soam[8];
   } raster;
-
-  uint32 buffer[256 * 262];
-  uint8 ciram[2048];
-  uint8 cgram[32];
-  uint8 oam[256];
 };
 
 extern PPU ppu;
diff --git a/fc/ppu/serialization.cpp b/fc/ppu/serialization.cpp
index 12b17a8..3a3b5dc 100644
--- a/fc/ppu/serialization.cpp
+++ b/fc/ppu/serialization.cpp
@@ -1,3 +1,5 @@
+#ifdef PPU_CPP
+
 void PPU::serialize(serializer& s) {
   Thread::serialize(s);
 
@@ -72,3 +74,5 @@ void PPU::serialize(serializer& s) {
   s.array(cgram);
   s.array(oam);
 }
+
+#endif
diff --git a/fc/scheduler/scheduler.cpp b/fc/scheduler/scheduler.cpp
index ee565a2..2ad3b82 100644
--- a/fc/scheduler/scheduler.cpp
+++ b/fc/scheduler/scheduler.cpp
@@ -1,6 +1,4 @@
-#include <fc/fc.hpp>
-
-namespace Famicom {
+#ifdef SYSTEM_CPP
 
 Scheduler scheduler;
 
@@ -15,14 +13,16 @@ void Scheduler::exit(ExitReason reason) {
   co_switch(host_thread);
 }
 
-void Scheduler::power() {
-}
-
-void Scheduler::reset() {
+void Scheduler::init() {
   host_thread = co_active();
   thread = cpu.thread;
   sync = SynchronizeMode::None;
-  exit_reason = ExitReason::UnknownEvent;
 }
 
+Scheduler::Scheduler() {
+  host_thread = nullptr;
+  thread = nullptr;
+  exit_reason = ExitReason::UnknownEvent;
 }
+
+#endif
diff --git a/fc/scheduler/scheduler.hpp b/fc/scheduler/scheduler.hpp
index 518a5d4..7842e09 100644
--- a/fc/scheduler/scheduler.hpp
+++ b/fc/scheduler/scheduler.hpp
@@ -9,8 +9,8 @@ struct Scheduler : property<Scheduler> {
   void enter();
   void exit(ExitReason);
 
-  void power();
-  void reset();
+  void init();
+  Scheduler();
 };
 
 extern Scheduler scheduler;
diff --git a/fc/system/input.cpp b/fc/system/input.cpp
new file mode 100644
index 0000000..c9b795c
--- /dev/null
+++ b/fc/system/input.cpp
@@ -0,0 +1,74 @@
+#ifdef SYSTEM_CPP
+
+Input input;
+
+void Input::connect(uint2 port, Device id) {
+  Controller*& controller = (
+    port == Controller::Port1 ? port1 :
+    port == Controller::Port2 ? port2 :
+                                expansion
+  );
+  if(controller) {
+    delete controller;
+    controller = nullptr;
+  }
+
+  if(port < 2) {
+    switch(id) { default:
+    case Device::None: controller = new Controller(port); break;
+    case Device::Joypad: controller = new Gamepad(port); break;
+    case Device::FourScore: controller = new FourScore(port); break;
+    case Device::BeamGun:
+      if(!system.vs()) controller = new BeamGun(port);
+      else             controller = new VSBeamGun(port);
+      break;
+    case Device::FamilyTrainer: controller = new FamilyTrainer(port); break;
+    }
+  } else {
+    switch(id) { default:
+    case Device::None: controller = new Controller(port); break;
+    case Device::Joypad: controller = new Gamepad(port); break;
+    case Device::FourPlayers: controller = new FourPlayers(port); break;
+    case Device::BeamGun: controller = new BeamGun(port); break;
+    case Device::FamilyTrainer: controller = new FamilyTrainer(port); break;
+    case Device::VSPanel: controller = new VSPanel(port); break;
+    }
+  }
+
+  switch(port) {
+  case Controller::Port1: configuration.controller_port1 = id; break;
+  case Controller::Port2: configuration.controller_port2 = id; break;
+  case Controller::ExpansionPort: configuration.expansion_port = id; break;
+  }
+
+  /*switch(port) {
+  case Controller::Port1:
+    if(id == Device::FourScore && configuration.controller_port2 != Device::FourScore) {
+      connect(Controller::Port2, Device::FourScore);
+    } else if(id != Device::FourScore && configuration.controller_port2 == Device::FourScore) {
+      connect(Controller::Port2, Device::None);
+    }
+    break;
+  case Controller::Port2:
+    if(id == Device::FourScore && configuration.controller_port1 != Device::FourScore) {
+      connect(Controller::Port1, Device::FourScore);
+    } else if(id != Device::FourScore && configuration.controller_port1 == Device::FourScore) {
+      connect(Controller::Port1, Device::None);
+    }
+    break;
+  }*/
+}
+
+Input::Input() {
+  connect(Controller::Port1, Input::Device::Joypad);
+  connect(Controller::Port2, Input::Device::Joypad);
+  connect(Controller::ExpansionPort, Input::Device::Joypad);
+}
+
+Input::~Input() {
+  if(port1) delete port1;
+  if(port2) delete port2;
+  if(expansion) delete expansion;
+}
+
+#endif
diff --git a/fc/system/input.hpp b/fc/system/input.hpp
new file mode 100644
index 0000000..0e84001
--- /dev/null
+++ b/fc/system/input.hpp
@@ -0,0 +1,30 @@
+struct Input {
+  enum class Device : unsigned {
+    Joypad        = 0,
+    FourPlayers   = 1,
+    FourScore     = 1,
+    BeamGun       = 2,
+    FamilyTrainer = 3,
+    VSPanel       = 4,
+    None          = 5,
+  };
+
+  enum class JoypadID : unsigned {
+    A  =  0, B    =  1, Select =  2, Start =  3,
+    Up =  4, Down =  5, Left   =  6, Right =  7,
+  };
+
+  enum class BeamGunID : unsigned {
+    X = 0, Y = 1, Trigger = 2,
+  };
+
+  Controller* port1 = nullptr;
+  Controller* port2 = nullptr;
+  Controller* expansion = nullptr;
+
+  void connect(uint2 port, Device device);
+  Input();
+  ~Input();
+};
+
+extern Input input;
diff --git a/fc/system/serialization.cpp b/fc/system/serialization.cpp
index 1d2c750..55d9586 100644
--- a/fc/system/serialization.cpp
+++ b/fc/system/serialization.cpp
@@ -1,3 +1,5 @@
+#ifdef SYSTEM_CPP
+
 serializer System::serialize() {
   serializer s(serialize_size);
 
@@ -32,18 +34,27 @@ bool System::unserialize(serializer& s) {
   return true;
 }
 
+//========
+//internal
+//========
+
 void System::serialize(serializer& s) {
+  s.integer((unsigned&)region);
 }
 
 void System::serialize_all(serializer& s) {
-  system.serialize(s);
-  input.serialize(s);
   cartridge.serialize(s);
+  system.serialize(s);
   cpu.serialize(s);
   apu.serialize(s);
   ppu.serialize(s);
+
+  if(revision == Revision::VSSystem) vsarcadeboard.serialize(s);
 }
 
+//perform dry-run state save:
+//determines exactly how many bytes are needed to save state for this cartridge,
+//as amount varies per game (eg different RAM sizes, etc.)
 void System::serialize_init() {
   serializer s;
 
@@ -58,3 +69,5 @@ void System::serialize_init() {
   serialize_all(s);
   serialize_size = s.size();
 }
+
+#endif
diff --git a/fc/system/system.cpp b/fc/system/system.cpp
index 4a86bea..32224a5 100644
--- a/fc/system/system.cpp
+++ b/fc/system/system.cpp
@@ -1,14 +1,23 @@
 #include <fc/fc.hpp>
 
+#define SYSTEM_CPP
 namespace Famicom {
 
-#include "serialization.cpp"
 System system;
+Configuration configuration;
+
+#include "video.cpp"
+#include "input.cpp"
+#include "serialization.cpp"
+
+#include <fc/scheduler/scheduler.cpp>
 
 void System::run() {
+  scheduler.sync = Scheduler::SynchronizeMode::None;
+
   scheduler.enter();
   if(scheduler.exit_reason() == Scheduler::ExitReason::FrameEvent) {
-    interface->videoRefresh(video.palette, ppu.buffer, 4 * 256, 256, 240);
+    video.update();
   }
 }
 
@@ -36,25 +45,85 @@ void System::runthreadtosave() {
     scheduler.enter();
     if(scheduler.exit_reason() == Scheduler::ExitReason::SynchronizeEvent) break;
     if(scheduler.exit_reason() == Scheduler::ExitReason::FrameEvent) {
-      interface->videoRefresh(video.palette, ppu.buffer, 4 * 256, 256, 240);
+      video.update();
     }
   }
 }
 
-void System::load() {
+void System::init() {
+  assert(interface != nullptr);
+
+  vsarcadeboard.init();
+
+  video.init();
+
+  input.connect(0, configuration.controller_port1);
+  input.connect(1, configuration.controller_port2);
+  input.connect(2, configuration.expansion_port);
+}
+
+void System::term() {
+}
+
+void System::load(Revision revision) {
+  this->revision = revision;
   string manifest = string::read({interface->path(ID::System), "manifest.bml"});
   auto document = Markup::Document(manifest);
 
+  //if(revision == Revision::PlayChoice10) {
+  //  interface->loadRequest(ID::PC10ROM, document["system/pc10/rom/name"].data);
+  //  if(!file::exists({interface->path(ID::System), document["system/pc10/rom/name"].data})) {
+  //    interface->notify("Error: required PlayChoice-10 firmware bios-dual.rom not found.\n");
+  //  }
+  //}
+
+  region = configuration.region;
+  if(region == Region::Autodetect) {
+    region = (cartridge.region() == Cartridge::Region::NTSC ? Region::NTSC : Region::PAL);
+  }
+
+  cpu_frequency = region() == Region::NTSC ? 21477272 : 26601712;
+
+  switch(revision) {
+  case Revision::Famicom:
+    // most Famicoms use a PPU with open bus OAMDATA (read).
+    // For now, we use an NES PPU where OAMDATA (read) is defined.
+    if(region == Region::NTSC) ppu.revision = PPU::Revision::RP2C02G;
+    if(region == Region::PAL)  ppu.revision = PPU::Revision::RP2C07;
+    break;
+  case Revision::PlayChoice10:
+    ppu.revision = PPU::Revision::RP2C03B;
+    break;
+  case Revision::VSSystem:
+    vsarcadeboard.load();
+    input.connect(2, Input::Device::VSPanel);
+    // PPU revision is set within cartridge.load().
+    break;
+  }
+
   serialize_init();
 }
 
+void System::unload() {
+  switch(revision) {
+  case Revision::VSSystem:
+    vsarcadeboard.unload();
+    break;
+  }
+}
+
 void System::power() {
   cartridge.power();
   cpu.power();
   apu.power();
   ppu.power();
-  input.reset();
-  scheduler.power();
+
+  switch(revision) {
+  case Revision::VSSystem:
+    vsarcadeboard.power();
+    break;
+  }
+
   reset();
 }
 
@@ -62,18 +131,31 @@ void System::reset() {
   cartridge.reset();
   cpu.reset();
   apu.reset();
+  // Only the Famicom's PPU will reset. The NES's PPU will not.
   ppu.reset();
-  input.reset();
-  scheduler.reset();
+
+  switch(revision) {
+  case Revision::VSSystem:
+    vsarcadeboard.reset();
+    break;
+  }
+
+  scheduler.init();
+  input.connect(0, configuration.controller_port1);
+  input.connect(1, configuration.controller_port2);
+  input.connect(2, configuration.expansion_port);
 }
 
-void System::init() {
-  assert(interface != 0);
-  input.connect(0, Input::Device::Joypad);
-  input.connect(1, Input::Device::None);
+void System::scanline() {
+  video.scanline();
+  if(ppu.status.ly == 241) scheduler.exit(Scheduler::ExitReason::FrameEvent);
 }
 
-void System::term() {
+void System::frame() {
+}
+
+System::System() {
+  region = Region::Autodetect;
 }
 
 }
diff --git a/fc/system/system.hpp b/fc/system/system.hpp
index 88b73c5..019142a 100644
--- a/fc/system/system.hpp
+++ b/fc/system/system.hpp
@@ -1,22 +1,65 @@
-struct System {
+struct Interface;
+
+struct System : property<System> {
+  enum class Region : unsigned { NTSC = 0, PAL = 1, Autodetect = 2 };
+  enum class Revision : unsigned {
+    Famicom,
+    PlayChoice10,
+    VSSystem,
+  } revision;
+
+  inline bool fc()   const { return revision == Revision::Famicom; }
+  inline bool pc10() const { return revision == Revision::PlayChoice10; }
+  inline bool vs()   const { return revision == Revision::VSSystem; }
+
   void run();
   void runtosave();
-  void runthreadtosave();
 
-  void load();
+  void init();
+  void term();
+  void load(Revision);
+  void unload();
   void power();
   void reset();
 
-  void init();
-  void term();
+  void frame();
+  void scanline();
+
+  //return *active* system information (settings are cached upon power-on)
+  readonly<Region> region;
+  readonly<unsigned> cpu_frequency;
+  readonly<unsigned> serialize_size;
 
   serializer serialize();
   bool unserialize(serializer&);
 
+  System();
+
+private:
+  void runthreadtosave();
+
   void serialize(serializer&);
   void serialize_all(serializer&);
   void serialize_init();
-  unsigned serialize_size;
+
+  friend class Cartridge;
+  friend class Video;
+  friend class Input;
 };
 
 extern System system;
+
+#include "video.hpp"
+#include "input.hpp"
+
+#include <fc/scheduler/scheduler.hpp>
+
+struct Configuration {
+  Input::Device controller_port1 = Input::Device::Joypad;
+  Input::Device controller_port2 = Input::Device::Joypad;
+  Input::Device expansion_port = Input::Device::Joypad;
+  System::Region region = System::Region::Autodetect;
+  bool random = true;
+};
+
+extern Configuration configuration;
diff --git a/fc/system/video.cpp b/fc/system/video.cpp
new file mode 100644
index 0000000..5fe221a
--- /dev/null
+++ b/fc/system/video.cpp
@@ -0,0 +1,183 @@
+#ifdef SYSTEM_CPP
+
+Video video;
+
+void Video::generate_palette(Emulator::Interface::PaletteMode mode) {
+  unsigned emphasis;
+  unsigned luma;
+  unsigned chroma;
+  for(unsigned color = 0; color < (1 << 9); color++) {
+    if(mode == Emulator::Interface::PaletteMode::Literal) {
+      palette[color] = color;
+      continue;
+    }
+    switch(ppu.revision) { default:
+    case PPU::Revision::RP2C02C:
+    case PPU::Revision::RP2C02G:
+    case PPU::Revision::RP2C07:
+      if(mode == Emulator::Interface::PaletteMode::Standard) {
+        palette[color] = generate_color(color, 2.0, 0.0, 1.0, 1.0, 2.2);
+      } else if(mode == Emulator::Interface::PaletteMode::Channel) {
+        emphasis = image::normalize((color >> 6) &  7, 3, 16);
+        luma     = image::normalize((color >> 4) &  3, 2, 16);
+        chroma   = image::normalize((color >> 0) & 15, 4, 16);
+        palette[color] = interface->videoColor(color, 0, emphasis, luma, chroma);
+      } else if(mode == Emulator::Interface::PaletteMode::Emulation) {
+        palette[color] = generate_color(color, 2.0, 0.0, 1.0, 1.0, 1.8);
+      }
+      break;
+    case PPU::Revision::RP2C03B:
+    case PPU::Revision::RP2C03G:
+    case PPU::Revision::RC2C03B:
+    case PPU::Revision::RC2C03C:
+    case PPU::Revision::RC2C05_01:
+    case PPU::Revision::RC2C05_02:
+    case PPU::Revision::RC2C05_03:
+    case PPU::Revision::RC2C05_04:
+    case PPU::Revision::RC2C05_05:
+      palette[color] = retrieve_color(PPU::RP2C03[color & 63], color);
+      break;
+    case PPU::Revision::RP2C04_0001:
+      palette[color] = retrieve_color(PPU::RP2C04_0001[color & 63], color);
+      break;
+    case PPU::Revision::RP2C04_0002:
+      palette[color] = retrieve_color(PPU::RP2C04_0002[color & 63], color);
+      break;
+    case PPU::Revision::RP2C04_0003:
+      palette[color] = retrieve_color(PPU::RP2C04_0003[color & 63], color);
+      break;
+    case PPU::Revision::RP2C04_0004:
+      palette[color] = retrieve_color(PPU::RP2C04_0004[color & 63], color);
+      break;
+    } 
+  }
+}
+
+Video::Video() {
+  palette = new uint32_t[1 << 9]();
+}
+
+Video::~Video() {
+  delete[] palette;
+}
+
+//internal
+
+uint32_t Video::generate_color(
+  unsigned n, double saturation, double hue,
+  double contrast, double brightness, double gamma
+) {
+  signed color = (n & 0x0f), level = color < 0xe ? (n >> 4) & 3 : 1;
+
+  static const double black = 0.518, white = 1.962, attenuation = 0.746;
+  static const double levels[8] = {
+    0.350, 0.518, 0.962, 1.550,
+    1.094, 1.506, 1.962, 1.962,
+  };
+
+  double lo_and_hi[2] = {
+    levels[level + 4 * (color == 0x0)],
+    levels[level + 4 * (color <  0xd)],
+  };
+
+  double y = 0.0, i = 0.0, q = 0.0;
+  auto wave = [](signed p, signed color) { return (color + p + 8) % 12 < 6; };
+  for(signed p = 0; p < 12; p++) {
+    double spot = lo_and_hi[wave(p, color)];
+
+    if(((n & 0x040) && wave(p, 12))
+    || ((n & 0x080) && wave(p,  4))
+    || ((n & 0x100) && wave(p,  8))
+    ) spot *= attenuation;
+
+    double v = (spot - black) / (white - black);
+
+    v = (v - 0.5) * contrast + 0.5;
+    v *= brightness / 12.0;
+
+    y += v;
+    i += v * std::cos((3.141592653 / 6.0) * (p + hue));
+    q += v * std::sin((3.141592653 / 6.0) * (p + hue));
+  }
+
+  i *= saturation;
+  q *= saturation;
+
+  auto gammaAdjust = [=](double f) { return f < 0.0 ? 0.0 : std::pow(f, 2.2 / gamma); };
+  unsigned r = 65535.0 * gammaAdjust(y +  0.946882 * i +  0.623557 * q);
+  unsigned g = 65535.0 * gammaAdjust(y + -0.274788 * i + -0.635691 * q);
+  unsigned b = 65535.0 * gammaAdjust(y + -1.108545 * i +  1.709007 * q);
+
+  return interface->videoColor(n, 0, uclamp<16>(r), uclamp<16>(g), uclamp<16>(b));
+}
+
+uint32_t Video::retrieve_color(uint9_t palette_index, unsigned color) {
+  unsigned em_r = ((color >> 6) & 1) * 7;
+  unsigned em_g = ((color >> 7) & 1) * 7;
+  unsigned em_b = ((color >> 8) & 1) * 7;
+  return interface->videoColor(color, 0,
+    uclamp<16>((((palette_index >> 6) | em_r) & 7) * 9362.25),
+    uclamp<16>((((palette_index >> 3) | em_g) & 7) * 9362.25),
+    uclamp<16>((((palette_index >> 0) | em_b) & 7) * 9362.25)
+  );
+}
+
+const uint8_t Video::cursor[15 * 15] = {
+  0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,
+  0,0,0,0,1,1,2,2,2,1,1,0,0,0,0,
+  0,0,0,1,2,2,1,2,1,2,2,1,0,0,0,
+  0,0,1,2,1,1,0,1,0,1,1,2,1,0,0,
+  0,1,2,1,0,0,0,1,0,0,0,1,2,1,0,
+  0,1,2,1,0,0,1,2,1,0,0,1,2,1,0,
+  1,2,1,0,0,1,1,2,1,1,0,0,1,2,1,
+  1,2,2,1,1,2,2,2,2,2,1,1,2,2,1,
+  1,2,1,0,0,1,1,2,1,1,0,0,1,2,1,
+  0,1,2,1,0,0,1,2,1,0,0,1,2,1,0,
+  0,1,2,1,0,0,0,1,0,0,0,1,2,1,0,
+  0,0,1,2,1,1,0,1,0,1,1,2,1,0,0,
+  0,0,0,1,2,2,1,2,1,2,2,1,0,0,0,
+  0,0,0,0,1,1,2,2,2,1,1,0,0,0,0,
+  0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,
+};
+
+void Video::draw_cursor(uint16_t color, int x, int y) {
+  uint32_t* data = (uint32_t*)ppu.buffer;
+
+  for(int cy = 0; cy < 15; cy++) {
+    int vy = y + cy - 7;
+    if(vy <= 0 || vy >= 240) continue;  //do not draw offscreen
+
+    for(int cx = 0; cx < 15; cx++) {
+      int vx = x + cx - 7;
+      if(vx < 0 || vx >= 256) continue;  //do not draw offscreen
+      uint8_t pixel = cursor[cy * 15 + cx];
+      if(pixel == 0) continue;
+      uint32_t pixelcolor = (pixel == 1) ? 0x0f : color;
+
+      *((uint32_t*)data + vy * 256 + vx) = pixelcolor;
+    }
+  }
+}
+
+void Video::update() {
+  if(configuration.controller_port2 == Input::Device::BeamGun) {
+    BeamGun &device = (BeamGun&)*input.port2;
+    draw_cursor(0x27, device.x, device.y);
+  }
+  if(configuration.expansion_port == Input::Device::BeamGun) {
+    BeamGun &device = (BeamGun&)*input.expansion;
+    draw_cursor(0x2D, device.x, device.y);
+  }
+
+  interface->videoRefresh(video.palette, ppu.buffer, 4 * 256, 256, 240);
+}
+
+void Video::scanline() {
+  unsigned y = ppu.status.ly;
+  if(y >= 240) return;
+}
+
+void Video::init() {
+}
+
+#endif
diff --git a/fc/system/video.hpp b/fc/system/video.hpp
new file mode 100644
index 0000000..8440946
--- /dev/null
+++ b/fc/system/video.hpp
@@ -0,0 +1,20 @@
+struct Video {
+  uint32_t* palette;
+  void generate_palette(Emulator::Interface::PaletteMode mode);
+  Video();
+  ~Video();
+
+private:
+  void update();
+  void scanline();
+  void init();
+
+  uint32_t generate_color(unsigned, double, double, double, double, double);
+  uint32_t retrieve_color(uint9_t, unsigned);
+  static const uint8_t cursor[15 * 15];
+  void draw_cursor(uint16_t color, int x, int y);
+
+  friend class System;
+};
+
+extern Video video;
diff --git a/fc/video/video.cpp b/fc/video/video.cpp
deleted file mode 100644
index bdb476a..0000000
--- a/fc/video/video.cpp
+++ /dev/null
@@ -1,85 +0,0 @@
-#include <fc/fc.hpp>
-#include <cmath>
-
-#define VIDEO_CPP
-namespace Famicom {
-
-Video video;
-
-void Video::generate_palette(Emulator::Interface::PaletteMode mode) {
-  for(unsigned color = 0; color < (1 << 9); color++) {
-    if(mode == Emulator::Interface::PaletteMode::Literal) {
-      palette[color] = color;
-    } else if(mode == Emulator::Interface::PaletteMode::Channel) {
-      unsigned emphasis = (color >> 6) &  7;
-      unsigned luma     = (color >> 4) &  3;
-      unsigned chroma   = (color >> 0) & 15;
-      emphasis = image::normalize(emphasis, 3, 16);
-      luma     = image::normalize(luma,     2, 16);
-      chroma   = image::normalize(chroma,   4, 16);
-      palette[color] = interface->videoColor(color, 0, emphasis, luma, chroma);
-    } else if(mode == Emulator::Interface::PaletteMode::Standard) {
-      palette[color] = generate_color(color, 2.0, 0.0, 1.0, 1.0, 2.2);
-    } else if(mode == Emulator::Interface::PaletteMode::Emulation) {
-      palette[color] = generate_color(color, 2.0, 0.0, 1.0, 1.0, 1.8);
-    }
-  }
-}
-
-Video::Video() {
-  palette = new uint32_t[1 << 9]();
-}
-
-Video::~Video() {
-  delete[] palette;
-}
-
-uint32_t Video::generate_color(
-  unsigned n, double saturation, double hue,
-  double contrast, double brightness, double gamma
-) {
-  signed color = (n & 0x0f), level = color < 0xe ? (n >> 4) & 3 : 1;
-
-  static const double black = 0.518, white = 1.962, attenuation = 0.746;
-  static const double levels[8] = {
-    0.350, 0.518, 0.962, 1.550,
-    1.094, 1.506, 1.962, 1.962,
-  };
-
-  double lo_and_hi[2] = {
-    levels[level + 4 * (color == 0x0)],
-    levels[level + 4 * (color <  0xd)],
-  };
-
-  double y = 0.0, i = 0.0, q = 0.0;
-  auto wave = [](signed p, signed color) { return (color + p + 8) % 12 < 6; };
-  for(signed p = 0; p < 12; p++) {
-    double spot = lo_and_hi[wave(p, color)];
-
-    if(((n & 0x040) && wave(p, 12))
-    || ((n & 0x080) && wave(p,  4))
-    || ((n & 0x100) && wave(p,  8))
-    ) spot *= attenuation;
-
-    double v = (spot - black) / (white - black);
-
-    v = (v - 0.5) * contrast + 0.5;
-    v *= brightness / 12.0;
-
-    y += v;
-    i += v * std::cos((3.141592653 / 6.0) * (p + hue));
-    q += v * std::sin((3.141592653 / 6.0) * (p + hue));
-  }
-
-  i *= saturation;
-  q *= saturation;
-
-  auto gammaAdjust = [=](double f) { return f < 0.0 ? 0.0 : std::pow(f, 2.2 / gamma); };
-  unsigned r = 65535.0 * gammaAdjust(y +  0.946882 * i +  0.623557 * q);
-  unsigned g = 65535.0 * gammaAdjust(y + -0.274788 * i + -0.635691 * q);
-  unsigned b = 65535.0 * gammaAdjust(y + -1.108545 * i +  1.709007 * q);
-
-  return interface->videoColor(n, 0, uclamp<16>(r), uclamp<16>(g), uclamp<16>(b));
-}
-
-}
diff --git a/fc/video/video.hpp b/fc/video/video.hpp
deleted file mode 100644
index f49930b..0000000
--- a/fc/video/video.hpp
+++ /dev/null
@@ -1,12 +0,0 @@
-struct Video {
-  uint32_t* palette = nullptr;
-  void generate_palette(Emulator::Interface::PaletteMode mode);
-
-  Video();
-  ~Video();
-
-private:
-  uint32_t generate_color(unsigned, double, double, double, double, double);
-};
-
-extern Video video;
diff --git a/gba/interface/interface.cpp b/gba/interface/interface.cpp
index e5618a5..e5fe42c 100644
--- a/gba/interface/interface.cpp
+++ b/gba/interface/interface.cpp
@@ -113,6 +113,21 @@ void Interface::paletteUpdate(PaletteMode mode) {
   video.generate_palette(mode);
 }
 
+void Interface::exportMemory() {
+  string pathname = {path(group(ID::ROM)), "debug/"};
+  directory::create(pathname);
+
+  file::write({pathname, "i-work.ram"}, cpu.iwram, 32 * 1024);
+  //file::write({pathname, "e-work.ram"}, cpu.ewram, 256 * 1024);
+  file::write({pathname, "video.ram"}, ppu.vram, 96 * 1024);
+  uint8 pal_data[1024];
+  for(unsigned color_id = 0; color_id < 512; color_id++) {
+    pal_data[(color_id << 1) + 0] = (ppu.pram[color_id] >> 0) & 0xFF;
+    pal_data[(color_id << 1) + 1] = (ppu.pram[color_id] >> 8) & 0x7F;
+  }
+  file::write({pathname, "palette.ram"}, pal_data, 1024);
+}
+
 Interface::Interface() {
   interface = this;
 
diff --git a/gba/interface/interface.hpp b/gba/interface/interface.hpp
index 8553e19..8277e01 100644
--- a/gba/interface/interface.hpp
+++ b/gba/interface/interface.hpp
@@ -45,6 +45,8 @@ struct Interface : Emulator::Interface {
 
   void paletteUpdate(PaletteMode mode);
 
+  void exportMemory();
+
   Interface();
 
 private:
diff --git a/nall/intrinsics.hpp b/nall/intrinsics.hpp
index da41094..137b522 100644
--- a/nall/intrinsics.hpp
+++ b/nall/intrinsics.hpp
@@ -1,6 +1,27 @@
 #ifndef NALL_INTRINSICS_HPP
 #define NALL_INTRINSICS_HPP
 
+/* Platform detection */
+
+#if defined(_WIN32)
+  #define PLATFORM_WINDOWS
+#elif defined(__APPLE__)
+  #define PLATFORM_MACOSX
+  #include <machine/endian.h>
+#elif defined(linux) || defined(__linux__)
+  #define PLATFORM_LINUX
+  #define PLATFORM_XORG
+  #include <endian.h>
+#elif defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__NetBSD__) || defined(__OpenBSD__)
+  #define PLATFORM_BSD
+  #define PLATFORM_XORG
+  #include <sys/endian.h>
+#else
+  #warning "unable to detect platform"
+  #define PLATFORM_UNKNOWN
+  #include <endian.h>
+#endif
+
 namespace nall {
 
 struct Intrinsics {
@@ -15,6 +36,21 @@ struct Intrinsics {
   static inline Endian endian();
 };
 
+/* Intrinsics determination */
+
+#if defined(PLATFORM_WINDOWS)
+  Intrinsics::Platform Intrinsics::platform() { return Intrinsics::Platform::Windows; }
+#elif defined(PLATFORM_MACOSX)
+  Intrinsics::Platform Intrinsics::platform() { return Intrinsics::Platform::MacOSX; }
+#elif defined(PLATFORM_LINUX)
+  Intrinsics::Platform Intrinsics::platform() { return Intrinsics::Platform::Linux; }
+#elif defined(PLATFORM_BSD)
+  Intrinsics::Platform Intrinsics::platform() { return Intrinsics::Platform::BSD; }
+#else
+  #warning "unable to determine platform intrinsics"
+  Intrinsics::Platform Intrinsics::platform() { return Intrinsics::Platform::Unknown; }
+#endif
+
 /* Compiler detection */
 
 #if defined(__clang__)
@@ -40,38 +76,6 @@ struct Intrinsics {
   Intrinsics::Compiler Intrinsics::compiler() { return Intrinsics::Compiler::Unknown; }
 #endif
 
-/* Platform detection */
-
-#if defined(_WIN32)
-  #define PLATFORM_WINDOWS
-  Intrinsics::Platform Intrinsics::platform() { return Intrinsics::Platform::Windows; }
-#elif defined(__APPLE__)
-  #define PLATFORM_MACOSX
-  Intrinsics::Platform Intrinsics::platform() { return Intrinsics::Platform::MacOSX; }
-#elif defined(linux) || defined(__linux__)
-  #define PLATFORM_LINUX
-  #define PLATFORM_XORG
-  Intrinsics::Platform Intrinsics::platform() { return Intrinsics::Platform::Linux; }
-#elif defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__NetBSD__) || defined(__OpenBSD__)
-  #define PLATFORM_BSD
-  #define PLATFORM_XORG
-  Intrinsics::Platform Intrinsics::platform() { return Intrinsics::Platform::BSD; }
-#else
-  #warning "unable to detect platform"
-  #define PLATFORM_UNKNOWN
-  Intrinsics::Platform Intrinsics::platform() { return Intrinsics::Platform::Unknown; }
-#endif
-
-/* Architecture Detection */
-
-#if defined(PLATFORM_MACOSX)
-  #include <machine/endian.h>
-#elif defined(PLATFORM_LINUX)
-  #include <endian.h>
-#elif defined(PLATFORM_BSD)
-  #include <sys/endian.h>
-#endif
-
 #if defined(__i386__) || defined(_M_IX86)
   #define ARCH_X86
   Intrinsics::Architecture Intrinsics::architecture() { return Intrinsics::Architecture::x86; }
diff --git a/nall/thread.hpp b/nall/thread.hpp
index 5cd2846..4961a96 100644
--- a/nall/thread.hpp
+++ b/nall/thread.hpp
@@ -6,8 +6,7 @@
 #include <nall/intrinsics.hpp>
 
 #if defined(PLATFORM_XORG) || defined(PLATFORM_MACOSX)
-
-#include <pthread.h>
+  #include <pthread.h>
 
 namespace nall {
 
diff --git a/processor/r6502/instructions.cpp b/processor/r6502/instructions.cpp
index 9d551c0..f60fde2 100644
--- a/processor/r6502/instructions.cpp
+++ b/processor/r6502/instructions.cpp
@@ -32,7 +32,7 @@ void R6502::opf_bit() {
 void R6502::opf_cmp() {
   signed r = regs.a - rd;
   regs.p.n = (r & 0x80);
-  regs.p.z = (uint8)(r == 0);
+  regs.p.z = ((uint8)r == 0);
   regs.p.c = (r >= 0);
 }
 
@@ -323,7 +323,7 @@ L op_readpc();
   call(op);
 }
 
-void R6502::opi_store_absolute(uint8& r) {
+void R6502::opi_store_absolute(uint8 r) {
   abs.l = op_readpci();
   abs.h = op_readpci();
 L op_write(abs.w, r);
@@ -343,7 +343,7 @@ void R6502::opi_store_absolute_y(uint8& r) {
 L op_write(abs.w + regs.y, r);
 }
 
-void R6502::opi_store_indirect_zero_page_x(uint8& r) {
+void R6502::opi_store_indirect_zero_page_x(uint8 r) {
   zp = op_readpci();
   op_readzp(zp);
   abs.l = op_readzp(zp++ + regs.x);
@@ -359,7 +359,7 @@ void R6502::opi_store_indirect_zero_page_y(uint8& r) {
 L op_write(abs.w + regs.y, r);
 }
 
-void R6502::opi_store_zero_page(uint8& r) {
+void R6502::opi_store_zero_page(uint8 r) {
   zp = op_readpci();
 L op_writezp(zp, r);
 }
@@ -370,7 +370,7 @@ void R6502::opi_store_zero_page_x(uint8& r) {
 L op_writezp(zp + regs.x, r);
 }
 
-void R6502::opi_store_zero_page_y(uint8& r) {
+void R6502::opi_store_zero_page_y(uint8 r) {
   zp = op_readpci();
   op_readzp(zp);
 L op_writezp(zp + regs.y, r);
@@ -391,11 +391,12 @@ void R6502::op_brk() {
   op_readpci();
   op_writesp(regs.pc >> 8);
   op_writesp(regs.pc >> 0);
+  uint16 vector = 0xfffe;
+  nmi(vector);
   op_writesp(regs.p | 0x30);
-  abs.l = op_read(0xfffe);
+  abs.l = op_read(vector + 0);
   regs.p.i = 1;
-  regs.p.d = 0;
-L abs.h = op_read(0xffff);
+L abs.h = op_read(vector + 1);
   regs.pc = abs.w;
 }
 
@@ -456,9 +457,118 @@ L op_readpc();
   regs.pc = ++abs.w;
 }
 
+//illegal opcode functions
+//========================
+
+void R6502::opillf_dcp() {
+  opf_dec();
+  opf_cmp();
+}
+
+void R6502::opillf_lax() {
+  opf_lda();
+  regs.x = regs.a;
+}
+
+//illegal opcode implementations
+//==============================
+
+template<void (R6502::*opw)(),void (R6502::*opr)()>
+void R6502::opilli_rmwr_absolute() {
+  abs.l = op_readpci();
+  abs.h = op_readpci();
+  rd = op_read(abs.w);
+  op_write(abs.w, rd);
+  call(opw);
+L op_write(abs.w, rd);
+  call(opr);
+}
+
+template<void (R6502::*opw)(),void (R6502::*opr)()>
+void R6502::opilli_rmwr_absolute_x() {
+  abs.l = op_readpci();
+  abs.h = op_readpci();
+  op_page_always(abs.w, abs.w + regs.x);
+  rd = op_read(abs.w + regs.x);
+  op_write(abs.w + regs.x, rd);
+  call(opw);
+L op_write(abs.w + regs.x, rd);
+  call(opr);
+}
+
+template<void (R6502::*opw)(),void (R6502::*opr)()>
+void R6502::opilli_rmwr_absolute_y() {
+  abs.l = op_readpci();
+  abs.h = op_readpci();
+  op_page_always(abs.w, abs.w + regs.y);
+  rd = op_read(abs.w + regs.y);
+  op_write(abs.w + regs.y, rd);
+  call(opw);
+L op_write(abs.w + regs.y, rd);
+  call(opr);
+}
+
+template<void (R6502::*opw)(),void (R6502::*opr)()>
+void R6502::opilli_rmwr_indirect_zero_page_x() {
+  zp = op_readpci();
+  op_readzp(zp);
+  abs.l = op_readzp(zp++ + regs.x);
+  abs.h = op_readzp(zp++ + regs.x);
+  rd = op_read(abs.w);
+  op_write(abs.w, rd);
+  call(opw);
+L op_write(abs.w, rd);
+  call(opr);
+}
+
+template<void (R6502::*opw)(),void (R6502::*opr)()>
+void R6502::opilli_rmwr_indirect_zero_page_y() {
+  rd = op_readpci();
+  abs.l = op_readzp(rd++);
+  abs.h = op_readzp(rd++);
+  op_page(abs.w, abs.w + regs.y);
+  rd = op_read(abs.w + regs.y);
+  op_write(abs.w + regs.y, rd);
+  call(opw);
+L op_write(abs.w + regs.y, rd);
+  call(opr);
+}
+
+template<void (R6502::*opw)(),void (R6502::*opr)()>
+void R6502::opilli_rmwr_zero_page() {
+  zp = op_readpci();
+  rd = op_readzp(zp);
+  op_writezp(zp, rd);
+  call(opw);
+L op_writezp(zp, rd);
+  call(opr);
+}
+
+template<void (R6502::*opw)(),void (R6502::*opr)()>
+void R6502::opilli_rmwr_zero_page_x() {
+  zp = op_readpci();
+  op_readzp(zp);
+  rd = op_readzp(zp + regs.x);
+  op_writezp(zp + regs.x, rd);
+  call(opw);
+L op_writezp(zp + regs.x, rd);
+  call(opr);
+}
+
 //illegal opcodes
 //===============
 
+void R6502::opill_alr_immediate() {
+  opi_read_immediate<&R6502::opf_and>();
+  opf_sra();
+}
+
+void R6502::opill_anc_immediate() {
+L rd = op_readpci();
+  opf_and();
+  regs.p.c = regs.p.n;
+}
+
 void R6502::opill_arr_immediate() {
 L rd = op_readpci();
   regs.a &= rd;
@@ -469,6 +579,62 @@ L rd = op_readpci();
   regs.p.v = regs.p.c ^ ((regs.a >> 5) & 1);
 }
 
+void R6502::opill_axs_immediate() {
+L rd = op_readpci();
+  signed r = (regs.a & regs.x) - rd;
+  regs.p.n = (r & 0x80);
+  regs.p.z = ((uint8)r == 0);
+  regs.p.c = (r >= 0);
+  regs.x = r;
+}
+
+void R6502::opill_dcp_absolute_y() {
+  abs.l = op_readpci();
+  abs.h = op_readpci();
+  op_page_always(abs.w, abs.w + regs.y);
+  rd = op_read(abs.w + regs.y);
+  op_write(abs.w + regs.y, rd);
+  opf_dec();
+  opf_cmp();
+L op_write(abs.w + regs.y, rd);
+}
+
+void R6502::opill_dcp_indirect_zero_page_x() {
+  zp = op_readpci();
+  op_readzp(zp);
+  abs.l = op_readzp(zp++ + regs.x);
+  abs.h = op_readzp(zp++ + regs.x);
+  rd = op_read(abs.w);
+  op_write(abs.w, rd);
+  opf_dec();
+  opf_cmp();
+L op_write(abs.w, rd);
+}
+
+void R6502::opill_dcp_indirect_zero_page_y() {
+  rd = op_readpci();
+  abs.l = op_readzp(rd++);
+  abs.h = op_readzp(rd++);
+  op_page(abs.w, abs.w + regs.y);
+  rd = op_read(abs.w + regs.y);
+  op_write(abs.w + regs.y, rd);
+  opf_dec();
+  opf_cmp();
+L op_write(abs.w + regs.y, rd);
+}
+
+void R6502::opill_stp() {
+  while(true) op_readpc();
+}
+
+// line noise on the data bus interferes with LAX #i.
+void R6502::opill_lax_immediate() {
+  //regs.x = regs.a | 0xee;
+  opi_read_immediate<&R6502::opf_lda>();
+  //regs.a = regs.a & regs.x;
+  regs.x = regs.a;
+}
+
 void R6502::opill_nop_absolute() {
   abs.l = op_readpci();
   abs.h = op_readpci();
@@ -483,7 +649,7 @@ L op_readpc();
 }
 
 void R6502::opill_nop_immediate() {
-L rd = op_readpc();
+L rd = op_readpci();
 }
 
 void R6502::opill_nop_implied() {
@@ -500,3 +666,17 @@ void R6502::opill_nop_zero_page_x() {
   op_readzp(zp);
 L op_readzp(zp + regs.x);
 }
+
+void R6502::opill_shx_absolute_y() {
+  abs.l = op_readpci();
+  abs.h = op_readpci();
+  op_page_always(abs.w, abs.w + regs.y);
+L op_write(abs.w + regs.y, regs.x & (abs.h + 1));
+}
+
+void R6502::opill_shy_absolute_x() {
+  abs.l = op_readpci();
+  abs.h = op_readpci();
+  op_page_always(abs.w, abs.w + regs.x);
+L op_write(abs.w + regs.x, regs.y & (abs.h + 1));
+}
diff --git a/processor/r6502/r6502.cpp b/processor/r6502/r6502.cpp
index b560059..e1df7ad 100644
--- a/processor/r6502/r6502.cpp
+++ b/processor/r6502/r6502.cpp
@@ -50,75 +50,108 @@ void R6502::exec() {
   switch(opcode) {
   case 0x00: return op_brk();
   case 0x01: return opi_read_indirect_zero_page_x<&R6502::opf_ora>();
+I case 0x02: return opill_stp();
+I case 0x03: return opilli_rmwr_indirect_zero_page_x<&R6502::opf_asl,&R6502::opf_ora>();
 I case 0x04: return opill_nop_zero_page();
   case 0x05: return opi_read_zero_page<&R6502::opf_ora>();
   case 0x06: return opi_rmw_zero_page<&R6502::opf_asl>();
+I case 0x07: return opilli_rmwr_zero_page<&R6502::opf_asl,&R6502::opf_ora>();
   case 0x08: return op_php();
   case 0x09: return opi_read_immediate<&R6502::opf_ora>();
   case 0x0a: return opi_shift<&R6502::opf_sla>();
+I case 0x0b: return opill_anc_immediate();
 I case 0x0c: return opill_nop_absolute();
   case 0x0d: return opi_read_absolute<&R6502::opf_ora>();
   case 0x0e: return opi_rmw_absolute<&R6502::opf_asl>();
+I case 0x0f: return opilli_rmwr_absolute<&R6502::opf_asl,&R6502::opf_ora>();
   case 0x10: return opi_branch(regs.p.n == 0);
   case 0x11: return opi_read_indirect_zero_page_y<&R6502::opf_ora>();
+I case 0x12: return opill_stp();
+I case 0x13: return opilli_rmwr_indirect_zero_page_y<&R6502::opf_asl,&R6502::opf_ora>();
 I case 0x14: return opill_nop_zero_page_x();
   case 0x15: return opi_read_zero_page_x<&R6502::opf_ora>();
   case 0x16: return opi_rmw_zero_page_x<&R6502::opf_asl>();
+I case 0x17: return opilli_rmwr_zero_page_x<&R6502::opf_asl,&R6502::opf_ora>();
   case 0x18: return opi_clear_flag(regs.p.c);
   case 0x19: return opi_read_absolute_y<&R6502::opf_ora>();
 I case 0x1a: return opill_nop_implied();
+I case 0x1b: return opilli_rmwr_absolute_y<&R6502::opf_asl,&R6502::opf_ora>();
 I case 0x1c: return opill_nop_absolute_x();
   case 0x1d: return opi_read_absolute_x<&R6502::opf_ora>();
   case 0x1e: return opi_rmw_absolute_x<&R6502::opf_asl>();
+I case 0x1f: return opilli_rmwr_absolute_x<&R6502::opf_asl,&R6502::opf_ora>();
   case 0x20: return op_jsr_absolute();
   case 0x21: return opi_read_indirect_zero_page_x<&R6502::opf_and>();
+I case 0x22: return opill_stp();
+I case 0x23: return opilli_rmwr_indirect_zero_page_x<&R6502::opf_rol,&R6502::opf_and>();
   case 0x24: return opi_read_zero_page<&R6502::opf_bit>();
   case 0x25: return opi_read_zero_page<&R6502::opf_and>();
   case 0x26: return opi_rmw_zero_page<&R6502::opf_rol>();
+I case 0x27: return opilli_rmwr_zero_page<&R6502::opf_rol,&R6502::opf_and>();
   case 0x28: return op_plp();
   case 0x29: return opi_read_immediate<&R6502::opf_and>();
   case 0x2a: return opi_shift<&R6502::opf_rla>();
+I case 0x2b: return opill_anc_immediate();
   case 0x2c: return opi_read_absolute<&R6502::opf_bit>();
   case 0x2d: return opi_read_absolute<&R6502::opf_and>();
   case 0x2e: return opi_rmw_absolute<&R6502::opf_rol>();
+I case 0x2f: return opilli_rmwr_absolute<&R6502::opf_rol,&R6502::opf_and>();
   case 0x30: return opi_branch(regs.p.n == 1);
   case 0x31: return opi_read_indirect_zero_page_y<&R6502::opf_and>();
+I case 0x32: return opill_stp();
+I case 0x33: return opilli_rmwr_indirect_zero_page_y<&R6502::opf_rol,&R6502::opf_and>();
 I case 0x34: return opill_nop_zero_page_x();
   case 0x35: return opi_read_zero_page_x<&R6502::opf_and>();
   case 0x36: return opi_rmw_zero_page_x<&R6502::opf_rol>();
+I case 0x37: return opilli_rmwr_zero_page_x<&R6502::opf_rol,&R6502::opf_and>();
   case 0x38: return opi_set_flag(regs.p.c);
   case 0x39: return opi_read_absolute_y<&R6502::opf_and>();
 I case 0x3a: return opill_nop_implied();
+I case 0x3b: return opilli_rmwr_absolute_y<&R6502::opf_rol,&R6502::opf_and>();
 I case 0x3c: return opill_nop_absolute_x();
   case 0x3d: return opi_read_absolute_x<&R6502::opf_and>();
   case 0x3e: return opi_rmw_absolute_x<&R6502::opf_rol>();
+I case 0x3f: return opilli_rmwr_absolute_x<&R6502::opf_rol,&R6502::opf_and>();
   case 0x40: return op_rti();
   case 0x41: return opi_read_indirect_zero_page_x<&R6502::opf_eor>();
+I case 0x42: return opill_stp();
+I case 0x43: return opilli_rmwr_indirect_zero_page_x<&R6502::opf_lsr,&R6502::opf_eor>();
 I case 0x44: return opill_nop_zero_page();
   case 0x45: return opi_read_zero_page<&R6502::opf_eor>();
   case 0x46: return opi_rmw_zero_page<&R6502::opf_lsr>();
+I case 0x47: return opilli_rmwr_zero_page<&R6502::opf_lsr,&R6502::opf_eor>();
   case 0x48: return opi_push(regs.a);
   case 0x49: return opi_read_immediate<&R6502::opf_eor>();
   case 0x4a: return opi_shift<&R6502::opf_sra>();
+I case 0x4b: return opill_alr_immediate();
   case 0x4c: return op_jmp_absolute();
   case 0x4d: return opi_read_absolute<&R6502::opf_eor>();
   case 0x4e: return opi_rmw_absolute<&R6502::opf_lsr>();
+I case 0x4f: return opilli_rmwr_absolute<&R6502::opf_lsr,&R6502::opf_eor>();
   case 0x50: return opi_branch(regs.p.v == 0);
   case 0x51: return opi_read_indirect_zero_page_y<&R6502::opf_eor>();
+I case 0x52: return opill_stp();
+I case 0x53: return opilli_rmwr_indirect_zero_page_y<&R6502::opf_lsr,&R6502::opf_eor>();
 I case 0x54: return opill_nop_zero_page_x();
   case 0x55: return opi_read_zero_page_x<&R6502::opf_eor>();
   case 0x56: return opi_rmw_zero_page_x<&R6502::opf_lsr>();
+I case 0x57: return opilli_rmwr_zero_page_x<&R6502::opf_lsr,&R6502::opf_eor>();
   case 0x58: return opi_clear_flag(regs.p.i);
   case 0x59: return opi_read_absolute_y<&R6502::opf_eor>();
 I case 0x5a: return opill_nop_implied();
+I case 0x5b: return opilli_rmwr_absolute_y<&R6502::opf_lsr,&R6502::opf_eor>();
 I case 0x5c: return opill_nop_absolute_x();
   case 0x5d: return opi_read_absolute_x<&R6502::opf_eor>();
   case 0x5e: return opi_rmw_absolute_x<&R6502::opf_lsr>();
+I case 0x5f: return opilli_rmwr_absolute_x<&R6502::opf_lsr,&R6502::opf_eor>();
   case 0x60: return op_rts();
   case 0x61: return opi_read_indirect_zero_page_x<&R6502::opf_adc>();
+I case 0x62: return opill_stp();
+I case 0x63: return opilli_rmwr_indirect_zero_page_x<&R6502::opf_ror,&R6502::opf_adc>();
 I case 0x64: return opill_nop_zero_page();
   case 0x65: return opi_read_zero_page<&R6502::opf_adc>();
   case 0x66: return opi_rmw_zero_page<&R6502::opf_ror>();
+I case 0x67: return opilli_rmwr_zero_page<&R6502::opf_ror,&R6502::opf_adc>();
   case 0x68: return opi_pull(regs.a);
   case 0x69: return opi_read_immediate<&R6502::opf_adc>();
   case 0x6a: return opi_shift<&R6502::opf_rra>();
@@ -126,90 +159,122 @@ I case 0x6b: return opill_arr_immediate();
   case 0x6c: return op_jmp_indirect_absolute();
   case 0x6d: return opi_read_absolute<&R6502::opf_adc>();
   case 0x6e: return opi_rmw_absolute<&R6502::opf_ror>();
+I case 0x6f: return opilli_rmwr_absolute<&R6502::opf_ror,&R6502::opf_adc>();
   case 0x70: return opi_branch(regs.p.v == 1);
-I case 0x74: return opill_nop_zero_page_x();
   case 0x71: return opi_read_indirect_zero_page_y<&R6502::opf_adc>();
+I case 0x72: return opill_stp();
+I case 0x73: return opilli_rmwr_indirect_zero_page_y<&R6502::opf_ror,&R6502::opf_adc>();
+I case 0x74: return opill_nop_zero_page_x();
   case 0x75: return opi_read_zero_page_x<&R6502::opf_adc>();
   case 0x76: return opi_rmw_zero_page_x<&R6502::opf_ror>();
+I case 0x77: return opilli_rmwr_zero_page_x<&R6502::opf_ror,&R6502::opf_adc>();
   case 0x78: return opi_set_flag(regs.p.i);
   case 0x79: return opi_read_absolute_y<&R6502::opf_adc>();
 I case 0x7a: return opill_nop_implied();
+I case 0x7b: return opilli_rmwr_absolute_y<&R6502::opf_ror,&R6502::opf_adc>();
 I case 0x7c: return opill_nop_absolute_x();
   case 0x7d: return opi_read_absolute_x<&R6502::opf_adc>();
   case 0x7e: return opi_rmw_absolute_x<&R6502::opf_ror>();
-I case 0x80: return opill_nop_absolute();
+I case 0x7f: return opilli_rmwr_absolute_x<&R6502::opf_ror,&R6502::opf_adc>();
+I case 0x80: return opill_nop_immediate(); // regs.y
   case 0x81: return opi_store_indirect_zero_page_x(regs.a);
-I case 0x82: return opill_nop_immediate();
+I case 0x82: return opill_nop_immediate(); // regs.x
+I case 0x83: return opi_store_indirect_zero_page_x(regs.a & regs.x);
   case 0x84: return opi_store_zero_page(regs.y);
   case 0x85: return opi_store_zero_page(regs.a);
   case 0x86: return opi_store_zero_page(regs.x);
+I case 0x87: return opi_store_zero_page(regs.a & regs.x);
   case 0x88: return opi_decrement(regs.y);
-I case 0x89: return opill_nop_immediate();
+I case 0x89: return opill_nop_immediate(); // regs.a
   case 0x8a: return opi_transfer(regs.x, regs.a, 1);
   case 0x8c: return opi_store_absolute(regs.y);
   case 0x8d: return opi_store_absolute(regs.a);
   case 0x8e: return opi_store_absolute(regs.x);
+I case 0x8f: return opi_store_absolute(regs.a & regs.x);
   case 0x90: return opi_branch(regs.p.c == 0);
   case 0x91: return opi_store_indirect_zero_page_y(regs.a);
+I case 0x92: return opill_stp();
   case 0x94: return opi_store_zero_page_x(regs.y);
   case 0x95: return opi_store_zero_page_x(regs.a);
   case 0x96: return opi_store_zero_page_y(regs.x);
+I case 0x97: return opi_store_zero_page_y(regs.a & regs.x);
   case 0x98: return opi_transfer(regs.y, regs.a, 1);
   case 0x99: return opi_store_absolute_y(regs.a);
   case 0x9a: return opi_transfer(regs.x, regs.s, 0);
+I case 0x9c: return opill_shy_absolute_x();
   case 0x9d: return opi_store_absolute_x(regs.a);
+I case 0x9e: return opill_shx_absolute_y();
   case 0xa0: return opi_read_immediate<&R6502::opf_ldy>();
   case 0xa1: return opi_read_indirect_zero_page_x<&R6502::opf_lda>();
   case 0xa2: return opi_read_immediate<&R6502::opf_ldx>();
+I case 0xa3: return opi_read_indirect_zero_page_x<&R6502::opillf_lax>();
   case 0xa4: return opi_read_zero_page<&R6502::opf_ldy>();
   case 0xa5: return opi_read_zero_page<&R6502::opf_lda>();
   case 0xa6: return opi_read_zero_page<&R6502::opf_ldx>();
+I case 0xa7: return opi_read_zero_page<&R6502::opillf_lax>();
   case 0xa8: return opi_transfer(regs.a, regs.y, 1);
   case 0xa9: return opi_read_immediate<&R6502::opf_lda>();
   case 0xaa: return opi_transfer(regs.a, regs.x, 1);
+I case 0xab: return opill_lax_immediate();
   case 0xac: return opi_read_absolute<&R6502::opf_ldy>();
   case 0xad: return opi_read_absolute<&R6502::opf_lda>();
   case 0xae: return opi_read_absolute<&R6502::opf_ldx>();
+I case 0xaf: return opi_read_absolute<&R6502::opillf_lax>();
   case 0xb0: return opi_branch(regs.p.c == 1);
   case 0xb1: return opi_read_indirect_zero_page_y<&R6502::opf_lda>();
+I case 0xb2: return opill_stp();
+I case 0xb3: return opi_read_indirect_zero_page_y<&R6502::opillf_lax>();
   case 0xb4: return opi_read_zero_page_x<&R6502::opf_ldy>();
   case 0xb5: return opi_read_zero_page_x<&R6502::opf_lda>();
   case 0xb6: return opi_read_zero_page_y<&R6502::opf_ldx>();
+I case 0xb7: return opi_read_zero_page_y<&R6502::opillf_lax>();
   case 0xb8: return opi_clear_flag(regs.p.v);
   case 0xb9: return opi_read_absolute_y<&R6502::opf_lda>();
   case 0xba: return opi_transfer(regs.s, regs.x, 1);
   case 0xbc: return opi_read_absolute_x<&R6502::opf_ldy>();
   case 0xbd: return opi_read_absolute_x<&R6502::opf_lda>();
   case 0xbe: return opi_read_absolute_y<&R6502::opf_ldx>();
+I case 0xbf: return opi_read_absolute_y<&R6502::opillf_lax>();
   case 0xc0: return opi_read_immediate<&R6502::opf_cpy>();
   case 0xc1: return opi_read_indirect_zero_page_x<&R6502::opf_cmp>();
 I case 0xc2: return opill_nop_immediate();
+I case 0xc3: return opill_dcp_indirect_zero_page_x();
   case 0xc4: return opi_read_zero_page<&R6502::opf_cpy>();
   case 0xc5: return opi_read_zero_page<&R6502::opf_cmp>();
   case 0xc6: return opi_rmw_zero_page<&R6502::opf_dec>();
+I case 0xc7: return opi_rmw_zero_page<&R6502::opillf_dcp>();
   case 0xc8: return opi_increment(regs.y);
   case 0xc9: return opi_read_immediate<&R6502::opf_cmp>();
   case 0xca: return opi_decrement(regs.x);
+I case 0xcb: return opill_axs_immediate();
   case 0xcc: return opi_read_absolute<&R6502::opf_cpy>();
   case 0xcd: return opi_read_absolute<&R6502::opf_cmp>();
   case 0xce: return opi_rmw_absolute<&R6502::opf_dec>();
+I case 0xcf: return opi_rmw_absolute<&R6502::opillf_dcp>();
   case 0xd0: return opi_branch(regs.p.z == 0);
   case 0xd1: return opi_read_indirect_zero_page_y<&R6502::opf_cmp>();
+I case 0xd2: return opill_stp();
+I case 0xd3: return opill_dcp_indirect_zero_page_y();
 I case 0xd4: return opill_nop_zero_page_x();
   case 0xd5: return opi_read_zero_page_x<&R6502::opf_cmp>();
   case 0xd6: return opi_rmw_zero_page_x<&R6502::opf_dec>();
+I case 0xd7: return opi_rmw_zero_page_x<&R6502::opillf_dcp>();
   case 0xd8: return opi_clear_flag(regs.p.d);
   case 0xd9: return opi_read_absolute_y<&R6502::opf_cmp>();
 I case 0xda: return opill_nop_implied();
+I case 0xdb: return opill_dcp_absolute_y();
 I case 0xdc: return opill_nop_absolute_x();
   case 0xdd: return opi_read_absolute_x<&R6502::opf_cmp>();
   case 0xde: return opi_rmw_absolute_x<&R6502::opf_dec>();
+I case 0xdf: return opi_rmw_absolute_x<&R6502::opillf_dcp>();
   case 0xe0: return opi_read_immediate<&R6502::opf_cpx>();
   case 0xe1: return opi_read_indirect_zero_page_x<&R6502::opf_sbc>();
 I case 0xe2: return opill_nop_immediate();
+I case 0xe3: return opilli_rmwr_indirect_zero_page_x<&R6502::opf_inc,&R6502::opf_sbc>();
   case 0xe4: return opi_read_zero_page<&R6502::opf_cpx>();
   case 0xe5: return opi_read_zero_page<&R6502::opf_sbc>();
   case 0xe6: return opi_rmw_zero_page<&R6502::opf_inc>();
+I case 0xe7: return opilli_rmwr_zero_page<&R6502::opf_inc,&R6502::opf_sbc>();
   case 0xe8: return opi_increment(regs.x);
   case 0xe9: return opi_read_immediate<&R6502::opf_sbc>();
   case 0xea: return op_nop();
@@ -217,17 +282,23 @@ I case 0xeb: return opi_read_immediate<&R6502::opf_sbc>();
   case 0xec: return opi_read_absolute<&R6502::opf_cpx>();
   case 0xed: return opi_read_absolute<&R6502::opf_sbc>();
   case 0xee: return opi_rmw_absolute<&R6502::opf_inc>();
+I case 0xef: return opilli_rmwr_absolute<&R6502::opf_inc,&R6502::opf_sbc>();
   case 0xf0: return opi_branch(regs.p.z == 1);
   case 0xf1: return opi_read_indirect_zero_page_y<&R6502::opf_sbc>();
+I case 0xf2: return opill_stp();
+I case 0xf3: return opilli_rmwr_indirect_zero_page_y<&R6502::opf_inc,&R6502::opf_sbc>();
 I case 0xf4: return opill_nop_zero_page_x();
   case 0xf5: return opi_read_zero_page_x<&R6502::opf_sbc>();
   case 0xf6: return opi_rmw_zero_page_x<&R6502::opf_inc>();
+I case 0xf7: return opilli_rmwr_zero_page_x<&R6502::opf_inc,&R6502::opf_sbc>();
   case 0xf8: return opi_set_flag(regs.p.d);
   case 0xf9: return opi_read_absolute_y<&R6502::opf_sbc>();
 I case 0xfa: return opill_nop_implied();
+I case 0xfb: return opilli_rmwr_absolute_y<&R6502::opf_inc,&R6502::opf_sbc>();
 I case 0xfc: return opill_nop_absolute_x();
   case 0xfd: return opi_read_absolute_x<&R6502::opf_sbc>();
   case 0xfe: return opi_rmw_absolute_x<&R6502::opf_inc>();
+I case 0xff: return opilli_rmwr_absolute_x<&R6502::opf_inc,&R6502::opf_sbc>();
   }
 
   //unimplemented opcode
diff --git a/processor/r6502/r6502.hpp b/processor/r6502/r6502.hpp
index e6d5dad..c0233ba 100644
--- a/processor/r6502/r6502.hpp
+++ b/processor/r6502/r6502.hpp
@@ -81,14 +81,14 @@ struct R6502 {
   template<void (R6502::*op)()> void opi_rmw_zero_page_x();
   void opi_set_flag(bool& flag);
   template<void (R6502::*op)()> void opi_shift();
-  void opi_store_absolute(uint8& r);
+  void opi_store_absolute(uint8 r);
   void opi_store_absolute_x(uint8& r);
   void opi_store_absolute_y(uint8& r);
-  void opi_store_indirect_zero_page_x(uint8& r);
+  void opi_store_indirect_zero_page_x(uint8 r);
   void opi_store_indirect_zero_page_y(uint8& r);
-  void opi_store_zero_page(uint8& r);
+  void opi_store_zero_page(uint8 r);
   void opi_store_zero_page_x(uint8& r);
-  void opi_store_zero_page_y(uint8& r);
+  void opi_store_zero_page_y(uint8 r);
   void opi_transfer(uint8& s, uint8& d, bool flag);
 
   void op_brk();
@@ -101,13 +101,41 @@ struct R6502 {
   void op_rti();
   void op_rts();
 
+  void opillf_dcp();
+  void opillf_lax();
+
+  template<void (R6502::*opw)(),void (R6502::*opr)()>
+  void opilli_rmwr_absolute();
+  template<void (R6502::*opw)(),void (R6502::*opr)()>
+  void opilli_rmwr_absolute_x();
+  template<void (R6502::*opw)(),void (R6502::*opr)()>
+  void opilli_rmwr_absolute_y();
+  template<void (R6502::*opw)(),void (R6502::*opr)()>
+  void opilli_rmwr_indirect_zero_page_x();
+  template<void (R6502::*opw)(),void (R6502::*opr)()>
+  void opilli_rmwr_indirect_zero_page_y();
+  template<void (R6502::*opw)(),void (R6502::*opr)()>
+  void opilli_rmwr_zero_page();
+  template<void (R6502::*opw)(),void (R6502::*opr)()>
+  void opilli_rmwr_zero_page_x();
+
+  void opill_alr_immediate();
+  void opill_anc_immediate();
   void opill_arr_immediate();
+  void opill_axs_immediate();
+  void opill_dcp_absolute_y();
+  void opill_dcp_indirect_zero_page_x();
+  void opill_dcp_indirect_zero_page_y();
+  void opill_stp();
+  void opill_lax_immediate();
   void opill_nop_absolute();
   void opill_nop_absolute_x();
   void opill_nop_immediate();
   void opill_nop_implied();
   void opill_nop_zero_page();
   void opill_nop_zero_page_x();
+  void opill_shx_absolute_y();
+  void opill_shy_absolute_x();
 
   //disassembler.cpp
   string disassemble();
diff --git a/processor/spc700/disassembler.cpp b/processor/spc700/disassembler.cpp
index fbbde16..9c95d2e 100644
--- a/processor/spc700/disassembler.cpp
+++ b/processor/spc700/disassembler.cpp
@@ -1,4 +1,4 @@
-string SPC700::disassemble_opcode(uint16 addr, bool p) {
+string SPC700::disassemble_opcode(uint16 addr) {
   auto read = [&](uint16 addr) -> uint8 {
     return disassembler_read(addr);
   };
@@ -11,7 +11,7 @@ string SPC700::disassemble_opcode(uint16 addr, bool p) {
   auto a = [&] { return hex<4>((read(addr + 1) << 0) + (read(addr + 2) << 8)); };
   auto b = [&](unsigned n) { return hex<2>(read(addr + 1 + n)); };
   auto r = [&](unsigned r, unsigned n = 0) { return hex<4>(addr + r + (int8)read(addr + 1 + n)); };
-  auto dp = [&](unsigned n) { return hex<3>((p << 8) + read(addr + 1 + n)); };
+  auto dp = [&](unsigned n) { return hex<3>((regs.p.p << 8) + read(addr + 1 + n)); };
   auto ab = [&] {
     unsigned n = (read(addr + 1) << 0) + (read(addr + 2) << 8);
     return string{ hex<4>(n & 0x1fff), ":", hex<1>(n >> 13) };
diff --git a/processor/spc700/spc700.hpp b/processor/spc700/spc700.hpp
index 68ee7a8..5ff3a40 100644
--- a/processor/spc700/spc700.hpp
+++ b/processor/spc700/spc700.hpp
@@ -19,7 +19,7 @@ struct SPC700 {
   uint8 opcode;
 
   void serialize(serializer&);
-  string disassemble_opcode(uint16 addr, bool p);
+  string disassemble_opcode(uint16 addr);
 
 protected:
   uint8 op_adc(uint8, uint8);
diff --git a/profile/PlayChoice-10.sys/manifest.bml b/profile/PlayChoice-10.sys/manifest.bml
new file mode 100644
index 0000000..7295b84
--- /dev/null
+++ b/profile/PlayChoice-10.sys/manifest.bml
@@ -0,0 +1,3 @@
+system name:PlayChoice-10
+  pc10
+    rom name=bios-dual.rom size=16384
diff --git a/ruby/input/shared/rawinput.cpp b/ruby/input/shared/rawinput.cpp
index 8e7a9cd..063384e 100644
--- a/ruby/input/shared/rawinput.cpp
+++ b/ruby/input/shared/rawinput.cpp
@@ -23,11 +23,11 @@ struct RawInput {
   };
   vector<Device> devices;
 
-  optional<Device&> find(uint16_t vendorID, uint16_t productID) {
+  maybe<Device&> find(uint16_t vendorID, uint16_t productID) {
     for(auto& device : devices) {
-      if(device.vendorID == vendorID && device.productID == productID) return {true, device};
+      if(device.vendorID == vendorID && device.productID == productID) return device;
     }
-    return false;
+    return nothing;
   }
 
   void scanDevices() {
diff --git a/sfc/Makefile b/sfc/Makefile
index f18b65a..fc1c0d9 100644
--- a/sfc/Makefile
+++ b/sfc/Makefile
@@ -17,6 +17,12 @@ ifeq ($(profile),accuracy)
   sfcsmp := $(sfc)/smp
   sfcdsp := $(sfc)/dsp
   sfcppu := $(sfc)/ppu
+else ifeq ($(profile),accuracyfast)
+  flags += -DPROFILE_ACCURACYFAST
+  sfccpu := $(sfc)/cpu
+  sfcsmp := $(sfc)/smp
+  sfcdsp := $(sfc)/alt/dsp
+  sfcppu := $(sfc)/ppu
 else ifeq ($(profile),balanced)
   flags += -DPROFILE_BALANCED
   sfccpu := $(sfc)/cpu
diff --git a/sfc/alt/ppu-balanced/ppu.cpp b/sfc/alt/ppu-balanced/ppu.cpp
index ad4fd13..da90980 100644
--- a/sfc/alt/ppu-balanced/ppu.cpp
+++ b/sfc/alt/ppu-balanced/ppu.cpp
@@ -368,6 +368,36 @@ void PPU::reset() {
   regs.bg_y[3] = 0;
 }
 
+void PPU::exportRegisters(string &markup) {
+  markup.append("ppu\n");
+  // 2105
+  markup.append("  bgmode:       ", regs.bg_mode,      "\n");
+  markup.append("  bg3-priority: ", regs.bg3_priority, "\n");
+  // 2133
+  markup.append("  pseudo-hires: ", regs.pseudo_hires, "\n");
+  markup.append("  overscan:     ", regs.overscan,     "\n");
+  // individual backgrounds
+  unsigned bg;
+  for(unsigned bg_id = 1; bg_id <= 4; bg_id++) {
+    switch(bg_id) {
+      case 1: bg = BG1; break;
+      case 2: bg = BG2; break;
+      case 3: bg = BG3; break;
+      case 4: bg = BG4; break;
+    }
+    markup.append("  bg\n");
+    markup.append("    tile-size:     ",   regs.bg_tilesize[bg],       "\n");
+    markup.append("    mosaic:        ",   regs.mosaic_enabled[bg],    "\n");
+    markup.append("    screen-addr:   0x", hex<4>(regs.bg_scaddr[bg]), "\n");
+    markup.append("    screen-size:   ",   regs.bg_scsize[bg],         "\n");
+    markup.append("    tiledata-addr: 0x", hex<4>(regs.bg_tdaddr[bg]), "\n");
+    markup.append("    hoffset:       0x", hex<4>(regs.bg_hofs[bg]),   "\n");
+    markup.append("    voffset:       0x", hex<4>(regs.bg_vofs[bg]),   "\n");
+    markup.append("    main-enable:   ",   regs.bg_enabled[bg],        "\n");
+    markup.append("    sub-enable:    ",   regs.bgsub_enabled[bg],     "\n");
+  }
+}
+
 void PPU::layer_enable(unsigned layer, unsigned priority, bool enable) {
   switch(layer * 4 + priority) {
   case  0: layer_enabled[BG1][0] = enable; break;
diff --git a/sfc/alt/ppu-balanced/ppu.hpp b/sfc/alt/ppu-balanced/ppu.hpp
index 106780f..932c8d5 100644
--- a/sfc/alt/ppu-balanced/ppu.hpp
+++ b/sfc/alt/ppu-balanced/ppu.hpp
@@ -62,6 +62,8 @@ struct PPU : Thread, public PPUcounter {
   void power();
   void reset();
 
+  void exportRegisters(string &markup);
+
   bool layer_enabled[5][4];
   void layer_enable(unsigned layer, unsigned priority, bool enable);
   unsigned frameskip;
diff --git a/sfc/alt/ppu-performance/ppu.cpp b/sfc/alt/ppu-performance/ppu.cpp
index b598cc7..da38ce7 100644
--- a/sfc/alt/ppu-performance/ppu.cpp
+++ b/sfc/alt/ppu-performance/ppu.cpp
@@ -105,6 +105,9 @@ void PPU::reset() {
   display.overscan = false;
 }
 
+void PPU::exportRegisters(string &markup) {
+}
+
 void PPU::layer_enable(unsigned layer, unsigned priority, bool enable) {
   switch(layer * 4 + priority) {
   case  0: bg1.priority0_enable = enable; break;
diff --git a/sfc/alt/ppu-performance/ppu.hpp b/sfc/alt/ppu-performance/ppu.hpp
index b3427e2..a3dd1b2 100644
--- a/sfc/alt/ppu-performance/ppu.hpp
+++ b/sfc/alt/ppu-performance/ppu.hpp
@@ -12,12 +12,14 @@ struct PPU : Thread, public PPUcounter {
   bool overscan() const;
   bool hires() const;
 
+  void scanline();
+  void frame();
   void enter();
   void enable();
   void power();
   void reset();
-  void scanline();
-  void frame();
+
+  void exportRegisters(string &markup);
 
   void layer_enable(unsigned layer, unsigned priority, bool enable);
   void set_frameskip(unsigned frameskip);
diff --git a/sfc/base/satellaview/satellaview.cpp b/sfc/base/satellaview/satellaview.cpp
index 947956f..202d34b 100644
--- a/sfc/base/satellaview/satellaview.cpp
+++ b/sfc/base/satellaview/satellaview.cpp
@@ -28,62 +28,221 @@ void SatellaviewBaseUnit::power() {
 }
 
 void SatellaviewBaseUnit::reset() {
+  BSXF.close();
+  regs.BSXF_NUM = 0;
   memset(&regs, 0x00, sizeof regs);
 }
 
-uint8 SatellaviewBaseUnit::read(unsigned addr) {
-  addr &= 0xffff;
-
-  switch(addr) {
-  case 0x2188: return regs.r2188;
-  case 0x2189: return regs.r2189;
-  case 0x218a: return regs.r218a;
-  case 0x218c: return regs.r218c;
-  case 0x218e: return regs.r218e;
-  case 0x218f: return regs.r218f;
-  case 0x2190: return regs.r2190;
-
-  case 0x2192: {
-    unsigned counter = regs.r2192_counter++;
-    if(regs.r2192_counter >= 18) regs.r2192_counter = 0;
-
-    if(counter == 0) {
-      time_t rawtime;
-      time(&rawtime);
-      tm* t = localtime(&rawtime);
+void SatellaviewBaseUnit::SatellaviewTuneInA(uint8 filenumber) {
+  BSXF.close();
+  uint16 Signal_Nb=regs.r2188^(regs.r2189*256);
+  string filenm;
+  filenm.reserve(nall::configpath().length()+21+4+3);//configpath + bsxdat path + channel + program
+  sprintf(filenm.data(), "%shigan/bsxdat/BSX%04.4hX-%d.bin", (const char*)nall::configpath(), Signal_Nb, filenumber);
+  BSXF.open(filenm.data(), file::mode::read);
+  if(BSXF.size()!= -1) {
+    regs.BSX_access=true;
+    regs.BSXF_Signal++;
+    float QueueSize = BSXF.size() / 22.;
+    regs.BSXF_Queue = (uint8)(ceil(QueueSize));
+    regs.BSXF_1ST = true;
+    }
+  else {
+    regs.BSX_access=false;
+    regs.BSXF_Signal=0;
+    }
+}
 
-      regs.r2192_hour   = t->tm_hour;
-      regs.r2192_minute = t->tm_min;
-      regs.r2192_second = t->tm_sec;
+void SatellaviewBaseUnit::SatellaviewTuneInB(uint8 filenumber) {
+  BSXF2.close();
+  uint16 Signal_Nb=regs.r218e^(regs.r218f*256);
+  string filenm;
+  filenm.reserve(nall::configpath().length()+21+4+3); //configpath + bsxdat path + channel + program
+  sprintf(filenm.data(), "%shigan/bsxdat/BSX%04.4hX-%d.bin", (const char*)nall::configpath(), Signal_Nb, filenumber);
+  BSXF2.open(filenm.data(), file::mode::read);
+  if(BSXF2.size()!= -1) {
+    regs.BSX2_access=true;
+    regs.BSXF2_Signal++;
+    float QueueSize = BSXF2.size() / 22.;
+    regs.BSXF2_Queue = (uint8)(ceil(QueueSize));
+    regs.BSXF2_1ST = true;
+    }
+  else {
+    regs.BSX2_access=false;
+    regs.BSXF2_Signal=0;
     }
+}
 
-    switch(counter) {
+uint8 SatellaviewBaseUnit::GetTime(bool reset_count) {
+  if(reset_count == true) {
+    regs.time_counter = 0;
+    return 0xff;
+  }
+  unsigned counter = regs.time_counter;
+  regs.time_counter++;
+  if(regs.time_counter >= 22) regs.time_counter = 0;
+  if(counter == 0) {
+    time_t rawtime;
+    time(&rawtime);
+    tm *t = localtime(&rawtime);
+    regs.time_hour   = t->tm_hour;
+    regs.time_minute = t->tm_min;
+    regs.time_second = t->tm_sec;
+    regs.time_weekday = (t->tm_wday)++;
+    regs.time_day = (t->tm_mday)++;
+    regs.time_month = t->tm_mon;
+    uint16 time_year = (t->tm_year) + 1900;
+    regs.time_yearL = time_year & 0xFF;
+    regs.time_yearH = time_year >> 8;
+  }
+
+  switch(counter) {
     case  0: return 0x00;  //???
     case  1: return 0x00;  //???
     case  2: return 0x00;  //???
     case  3: return 0x00;  //???
-    case  4: return 0x00;  //???
+    case  4: return 0x03;  //???
     case  5: return 0x01;
     case  6: return 0x01;
     case  7: return 0x00;
     case  8: return 0x00;
     case  9: return 0x00;
-    case 10: return regs.r2192_second;
-    case 11: return regs.r2192_minute;
-    case 12: return regs.r2192_hour;
-    case 13: return 0x00;  //???
-    case 14: return 0x00;  //???
-    case 15: return 0x00;  //???
-    case 16: return 0x00;  //???
-    case 17: return 0x00;  //???
+    case 10: return regs.time_second;
+    case 11: return regs.time_minute;
+    case 12: return regs.time_hour;
+    case 13: return regs.time_weekday;
+    case 14: return regs.time_day;
+    case 15: return regs.time_month;
+    case 16: return regs.time_yearL;  //???
+    case 17: return regs.time_yearH;  //???
+  }
+  return 0;
+}
+
+uint8 SatellaviewBaseUnit::read(unsigned addr) {
+  addr &= 0xffff;
+
+  switch(addr) {
+    case 0x2188: return regs.r2188;
+    case 0x2189: return regs.r2189;
+    case 0x218a: {
+      if(regs.r2188 == 0 && regs.r2189 == 0) {
+        return 0x01;
+      }
+      if (regs.BSXF_Queue <= 0) {
+        regs.BSXF_NUM++;
+        SatellaviewTuneInA(regs.BSXF_NUM-1);
+      }
+      if(!regs.BSX_access && (regs.BSXF_NUM-1) > 0) {
+        regs.BSXF_NUM=1;
+        SatellaviewTuneInA(regs.BSXF_NUM-1);
+      }
+      if(regs.BSX_access) {
+        regs.r218b_chk=true;
+        regs.r218c_chk=true;
+        return regs.BSXF_Queue;
+      }
+      else return 0;
+    }
+    case 0x218b: {
+      if(regs.r218b_port) {
+        if(regs.r2188 == 0 && regs.r2189 == 0) {
+          regs.r218b = 0x90;
+          return 0x90;
+        }
+        if(regs.BSX_access) {
+          regs.r218b_chk=false;
+          uint8 lol = 0;
+          if (regs.BSXF_1ST) {
+            lol = 0x10;
+            regs.BSXF_1ST = false;
+          }
+          regs.BSXF_Queue--;
+          if (regs.BSXF_Queue==0) { lol |= 0x80; }
+          regs.r218d |= lol;
+          return lol;
+        }
+      }
+      else return 0x00;
+    }
+    case 0x218c: {
+      if(regs.r218c_port) {
+        if(regs.r2188 == 0 && regs.r2189 == 0) {
+          return GetTime(false);
+        }
+        if(regs.BSX_access) {
+          return BSXF.read();
+        }
+      }
+      else return 0x00;
+    }
+    case 0x218d: {
+      uint8 lol = regs.r218d;
+    regs.r218d = 0;
+    return lol;
+    }
+    case 0x218e: return regs.r218e;
+    case 0x218f: return regs.r218f;
+    case 0x2190: {
+      if(regs.r218e == 0 && regs.r218f == 0) {
+        return 0x01;
+      }
+      if (regs.BSXF2_Queue <= 0) {
+        regs.BSXF2_NUM++;
+        SatellaviewTuneInB(regs.BSXF2_NUM-1);
+      }
+      if(!regs.BSX2_access && (regs.BSXF2_NUM-1) > 0) {
+        regs.BSXF2_NUM=1;
+        SatellaviewTuneInB(regs.BSXF2_NUM-1);
+      }
+      if(regs.BSX2_access) {
+        regs.r2191_chk=true;
+        regs.r2192_chk=true;
+        return regs.BSXF2_Queue;
+      }
+      else return 0;
+    }
+    case 0x2191: {
+      if(regs.r2191_port) {
+        if(regs.r218e == 0 && regs.r218f == 0) {
+          regs.r2193 = 0x90;
+          return 0x90;
+        }
+        if(regs.BSX2_access) {
+          uint8 lol = 0;
+          if (regs.BSXF2_1ST) {
+            lol = 0x10;
+            regs.BSXF2_1ST = false;
+          }
+          regs.BSXF2_Queue--;
+          if (regs.BSXF2_Queue==0) { lol |= 0x80; }
+          regs.r2193 |= lol;
+          return lol;
+        }
+      }
+      else return 0;
     }
-  } break;
 
-  case 0x2193: return regs.r2193 & ~0x0c;
-  case 0x2194: return regs.r2194;
-  case 0x2196: return regs.r2196;
-  case 0x2197: return regs.r2197;
-  case 0x2199: return regs.r2199;
+    case 0x2192: {
+      if(regs.r2192_port) {
+        if(regs.r218e == 0 && regs.r218f == 0) {
+          return GetTime(false);
+        }
+        if(regs.BSX2_access) {
+          return BSXF2.read();
+        }
+        else return 0x00;
+      } break;
+    } //shouldn't this be here (instead of after this switch)?
+    case 0x2193: {
+      uint8 lol = regs.r2193;
+      regs.r2193 = 0;
+      return lol;
+    }
+    case 0x2194: return 0xff; //regs.r2194;
+    case 0x2196: return regs.r2196;
+    case 0x2197: return regs.r2197;
+    case 0x2199: return regs.r2199;
   }
 
   return cpu.regs.mdr;
@@ -94,10 +253,20 @@ void SatellaviewBaseUnit::write(unsigned addr, uint8 data) {
 
   switch(addr) {
   case 0x2188: {
+    if (regs.r2188 != data) {
+      regs.BSXF_Signal = 0;
+      regs.BSXF_NUM = 0;
+    }
+    else regs.BSXF_Signal++;
     regs.r2188 = data;
   } break;
 
   case 0x2189: {
+    if (regs.r2189 != data) {
+      regs.BSXF_Signal = 0;
+      regs.BSXF_NUM = 0;
+    }
+    else regs.BSXF_Signal++;
     regs.r2189 = data;
   } break;
 
@@ -106,30 +275,50 @@ void SatellaviewBaseUnit::write(unsigned addr, uint8 data) {
   } break;
 
   case 0x218b: {
-    regs.r218b = data;
+    if (data && 1 == 1) {
+      regs.r218b_port=true;
+      regs.r218b_chk=true;
+    }
+    else regs.r218b_port=false;
   } break;
 
   case 0x218c: {
-    regs.r218c = data;
+    if (regs.r2188 == 0 && regs.r2189 == 0) { GetTime(true); }
+    if (data && 1 == 1) {
+      regs.r218c_port=true;
+      regs.r218c_chk=true;
+    }
+    else regs.r218c_port=false;
   } break;
 
   case 0x218e: {
+    if (regs.r218e != data) {
+      regs.BSXF2_Signal = 0;
+      regs.BSXF2_NUM = 0;
+    }
+    else regs.BSXF2_Signal++;
     regs.r218e = data;
   } break;
 
   case 0x218f: {
-    regs.r218e >>= 1;
-    regs.r218e = regs.r218f - regs.r218e;
-    regs.r218f >>= 1;
+    if (regs.r218f != data) {
+      regs.BSXF2_Signal = 0;
+      regs.BSXF2_NUM = 0;
+    }
+    else regs.BSXF2_Signal++;
+    regs.r218f = data;
   } break;
 
   case 0x2191: {
-    regs.r2191 = data;
-    regs.r2192_counter = 0;
+    if (data && 1 == 1) regs.r2191_port=true;
+    else regs.r2191_port=false;
+    regs.time_counter = 0;
   } break;
 
   case 0x2192: {
-    regs.r2190 = 0x80;
+    if (regs.r218e == 0 && regs.r218f == 0) { GetTime(true); }
+    if (data && 1 == 1) regs.r2192_port=true;
+    else regs.r2192_port=false;
   } break;
 
   case 0x2193: {
diff --git a/sfc/base/satellaview/satellaview.hpp b/sfc/base/satellaview/satellaview.hpp
index 2fb7ddd..6887f49 100644
--- a/sfc/base/satellaview/satellaview.hpp
+++ b/sfc/base/satellaview/satellaview.hpp
@@ -1,3 +1,5 @@
+#include <nall/file.hpp>
+
 struct SatellaviewBaseUnit : Memory {
   void init();
   void load();
@@ -5,6 +7,15 @@ struct SatellaviewBaseUnit : Memory {
   void power();
   void reset();
 
+  file BSXF;
+  file BSXF2;
+
+  void SatellaviewTuneInA(uint8 filenumber);
+  void SatellaviewTuneInB(uint8 filenumber);
+
+  uint8 GetTime(bool reset_count);
+
+
   uint8 read(unsigned addr);
   void write(unsigned addr, uint8 data);
 
@@ -17,8 +28,33 @@ private:
     uint8 r2198, r2199, r219a, r219b;
     uint8 r219c, r219d, r219e, r219f;
 
-    uint8 r2192_counter;
-    uint8 r2192_hour, r2192_minute, r2192_second;
+    uint8 time_counter;
+    uint8 time_hour, time_minute, time_second;
+    uint8 time_weekday, time_day, time_month;
+    uint8 time_yearL, time_yearH;
+
+    bool r218b_port, r218c_port;
+    bool r2191_port, r2192_port;
+
+    bool BSX_access;
+    uint8 BSXF_NUM;
+    uint8 BSXF_Signal;
+
+    uint8 BSXF_Queue;
+    bool BSXF_1ST;
+
+    bool BSX2_access;
+    uint8 BSXF2_NUM;
+    uint8 BSXF2_Signal;
+
+    uint8 BSXF2_Queue;
+    bool BSXF2_1ST;
+
+    bool r218b_chk;
+    bool r218c_chk;
+
+    bool r2191_chk;
+    bool r2192_chk;
   } regs;
 };
 
diff --git a/sfc/chip/bsx/bsx.cpp b/sfc/chip/bsx/bsx.cpp
index 567026a..7fdbb97 100644
--- a/sfc/chip/bsx/bsx.cpp
+++ b/sfc/chip/bsx/bsx.cpp
@@ -23,8 +23,14 @@ void BSXCartridge::power() {
 
 void BSXCartridge::reset() {
   for(unsigned i = 0; i < 16; i++) r[i] = 0x00;
+  r[0x02] = 0x80;
+  r[0x03] = 0x80;
+  r[0x05] = 0x80;
+  r[0x06] = 0x80;
   r[0x07] = 0x80;
   r[0x08] = 0x80;
+  r[0x09] = 0x80;
+  r[0x0b] = 0x80;
   mmio_commit();
 }
 
@@ -45,6 +51,7 @@ void BSXCartridge::memory_write(Memory& memory, unsigned addr, uint8 data) {
 
 //mcu_access() allows mcu_read() and mcu_write() to share decoding logic
 uint8 BSXCartridge::mcu_access(bool write, unsigned addr, uint8 data) {
+//BIOS ROM Access
   if((addr & 0xe08000) == 0x008000) {  //$00-1f:8000-ffff
     if(r07 == 1) {
       addr = ((addr & 0x1f0000) >> 1) | (addr & 0x7fff);
@@ -59,31 +66,107 @@ uint8 BSXCartridge::mcu_access(bool write, unsigned addr, uint8 data) {
     }
   }
 
-  if((addr & 0xe0e000) == 0x206000) {  //$20-3f:6000-7fff
-    return memory_access(write, psram, addr, data);
-  }
-
-  if((addr & 0xf00000) == 0x400000) {  //$40-4f:0000-ffff
-    if(r05 == 0) return memory_access(write, psram, addr & 0x0fffff, data);
-  }
-
-  if((addr & 0xf00000) == 0x500000) {  //$50-5f:0000-ffff
-    if(r06 == 0) return memory_access(write, psram, addr & 0x0fffff, data);
-  }
-
-  if((addr & 0xf00000) == 0x600000) {  //$60-6f:0000-ffff
-    if(r03 == 1) return memory_access(write, psram, addr & 0x0fffff, data);
+//PSRAM Access
+//LoROM
+  if(r02==0) {
+    if((addr & 0xf28000) == 0x700000) { //$70-7d:0000-7fff
+      if(r03==1) return memory_access(write, psram, addr & 0x07ffff, data);
+    }
+    if((addr & 0xf08000) == 0xf00000) { //$f0-ff:0000-7fff
+      if(r04==1) return memory_access(write, psram, addr & 0x07ffff, data);
+    }
+    if((addr & 0xf08000) == 0x008000) { //$00-0f:8000-ffff
+      if(r03==1 && r05==0 && r06==0) return memory_access(write, psram, ((addr & 0x7f0000) >> 1) | (addr & 0x7fff), data);
+    }
+    if((addr & 0xf08000) == 0x808000) { //$80-8f:8000-ffff
+      if(r04==1 && r05==0 && r06==0) return memory_access(write, psram, ((addr & 0x7f0000) >> 1) | (addr & 0x7fff), data);
+    }
+    if((addr & 0xf08000) == 0x208000) { //$20-2f:8000-ffff
+      if(r03==1 && r05==1 && r06==0) return memory_access(write, psram, ((addr & 0x7f0000) >> 1) | (addr & 0x7fff), data);
+    }
+    if((addr & 0xf08000) == 0xa08000) { //$a0-af:8000-ffff
+      if(r04==1 && r05==1 && r06==0) return memory_access(write, psram, ((addr & 0x7f0000) >> 1) | (addr & 0x7fff), data);
+    }
+    if((addr & 0xf00000) == 0x400000) { //$40-4f:0000-ffff
+      if(r03==1 && r05==0 && r06==1) return memory_access(write, psram, ((addr & 0x7f0000) >> 1) | (addr & 0x7fff), data);
+    }
+    if((addr & 0xf00000) == 0xc00000) { //$c0-cf:0000-ffff
+      if(r04==1 && r05==0 && r06==1) return memory_access(write, psram, ((addr & 0x7f0000) >> 1) | (addr & 0x7fff), data);
+    }
+    if((addr & 0xf00000) == 0x600000) { //$60-6f:0000-ffff
+      if(r03==1 && r05==1 && r06==1) return memory_access(write, psram, ((addr & 0x7f0000) >> 1) | (addr & 0x7fff), data);
+    }
+    if((addr & 0xf00000) == 0xe00000) { //$e0-ef:0000-ffff
+      if(r04==1 && r05==1 && r06==1) return memory_access(write, psram, ((addr & 0x7f0000) >> 1) | (addr & 0x7fff), data);
+    }
+  } else {
+//HiROM
+    if((addr & 0xe0e000) == 0x206000) { //$20-3f:6000-7fff
+      if(r03==1) return memory_access(write, psram, (addr&0x1fff)|0x6000, data);
+    }
+    if((addr & 0xe0e000) == 0xa06000) { //$a0-bf:6000-7fff
+      if(r04==1) return memory_access(write, psram, (addr&0x1fff)|0x6000, data);
+    }
+    if((addr & 0xf80000) == 0x400000) { //$40-47:0000-ffff
+      if(r03==1 && r05==0 && r06==0) return memory_access(write, psram, addr & 0x0fffff, data);
+    }
+    if((addr & 0xf80000) == 0x500000) { //$50-57:0000-ffff
+      if(r03==1 && r05==1 && r06==0) return memory_access(write, psram, addr & 0x0fffff, data);
+    }
+    if((addr & 0xf80000) == 0x600000) { //$60-67:0000-ffff
+      if(r03==1 && r05==0 && r06==1) return memory_access(write, psram, addr & 0x0fffff, data);
+    }
+    if((addr & 0xf80000) == 0x700000) { //$70-77:0000-ffff
+      if(r03==1 && r05==1 && r06==1) return memory_access(write, psram, addr & 0x0fffff, data);
+    }
+    if((addr & 0xf80000) == 0xc0ffff) { //$c0-c7:0000-ffff
+      if(r04==1 && r05==0 && r06==0) return memory_access(write, psram, addr & 0x0fffff, data);
+    }
+    if((addr & 0xf80000) == 0xd00000) { //$d0-d7:0000-ffff
+      if(r04==1 && r05==1 && r06==0) return memory_access(write, psram, addr & 0x0fffff, data);
+    }
+    if((addr & 0xf80000) == 0xe00000) { //$e0-e7:0000-ffff
+      if(r04==1 && r05==0 && r06==1) return memory_access(write, psram, addr & 0x0fffff, data);
+    }
+    if((addr & 0xf80000) == 0xf00000) { //$f0-f7:0000-ffff
+      if(r04==1 && r05==1 && r06==1) return memory_access(write, psram, addr & 0x0fffff, data);
+    }
   }
 
-  if((addr & 0xf80000) == 0x700000) {  //$70-77:0000-ffff
-    return memory_access(write, psram, addr & 0x07ffff, data);
+//Memory Pack Hole
+  if(r02==0) {
+    if((addr & 0xe08000) == 0x008000) { //$00-1f:8000-ffff
+      if(r09==1 && r0b==0) return cpu.regs.mdr;
+    }
+    if((addr & 0xe00000) == 0x400000) { //$40-5f:0000-ffff
+      if(r09==1 && r0b==1) return cpu.regs.mdr;
+    }
+    if((addr & 0xe08000) == 0x808000) { //$80-9f:8000-ffff
+      if(r0a==1 && r0b==0) return cpu.regs.mdr;
+    }
+    if((addr & 0xe00000) == 0xc00000) { //$c0-df:0000-ffff
+      if(r0a==1 && r0b==1) return cpu.regs.mdr;
+    }
+  } else {
+    if((addr & 0xb08000) == 0x008000) { //$00-0f|$40-4f:0000-ffff
+      if(r09==1 && r0b==0) return cpu.regs.mdr;
+    }
+    if((addr & 0xb08000) == 0x208000) { //$20-2f|$60-6f:0000-ffff
+      if(r09==1 && r0b==1) return cpu.regs.mdr;
+    }
+    if((addr & 0xb08000) == 0x808000) { //$80-8f|$c0-cf:0000-ffff
+      if(r0a==1 && r0b==0) return cpu.regs.mdr;
+    }
+    if((addr & 0xb08000) == 0xa08000) { //$a0-af|$e0-ef:0000-ffff
+      if(r0a==1 && r0b==1) return cpu.regs.mdr;
+    }
   }
-
+// Memory Pack Acess
   if(((addr & 0x408000) == 0x008000)  //$00-3f|80-bf:8000-ffff
   || ((addr & 0x400000) == 0x400000)  //$40-7f|c0-ff:0000-ffff
   ) {
     if(r02 == 0) addr = ((addr & 0x7f0000) >> 1) | (addr & 0x7fff);
-    Memory& memory = (r01 == 0 ? (Memory&)satellaviewcartridge : (Memory&)psram);
+    Memory &memory = (Memory&)satellaviewcartridge;
     return memory_access(write, memory, addr & 0x7fffff, data);
   }
 
diff --git a/sfc/interface/interface.cpp b/sfc/interface/interface.cpp
index 66b7c64..9649603 100644
--- a/sfc/interface/interface.cpp
+++ b/sfc/interface/interface.cpp
@@ -267,6 +267,10 @@ void Interface::save(unsigned id, const stream& stream) {
   if(id == ID::SufamiTurboSlotBRAM) stream.write(sufamiturboB.ram.data(), sufamiturboB.ram.size());
 }
 
+void Interface::savemempak() {
+  system.savemempak();
+}
+
 void Interface::unload() {
   save();
   cartridge.unload();
@@ -340,6 +344,30 @@ void Interface::paletteUpdate(PaletteMode mode) {
   video.generate_palette(mode);
 }
 
+void Interface::exportMemory() {
+  string pathname = {path(group(ID::ROM)), "debug/"};
+  directory::create(pathname);
+
+  // Registers
+  string markup = "";
+  ppu.exportRegisters(markup);
+  file::write({pathname, "registers.bml"}, markup);
+
+  file::write({pathname, "work.ram"}, cpu.wram, 128 * 1024);
+  file::write({pathname, "video.ram"}, ppu.vram, 64 * 1024);
+  file::write({pathname, "sprite.ram"}, ppu.oam, 544);
+  file::write({pathname, "palette.ram"}, ppu.cgram, 512);
+  file::write({pathname, "apu.ram"}, smp.apuram, 64 * 1024);
+  if(cartridge.has_sa1())
+    file::write({pathname, "sa1.internal.ram"}, sa1.iram.data(), sa1.iram.size());
+  if(cartridge.has_armdsp())
+    file::write({pathname, "st018.program.ram"}, armdsp.programRAM, sizeof(armdsp.programRAM));
+  if(cartridge.has_hitachidsp())
+    file::write({pathname, "cx4.data.ram"}, hitachidsp.ram.data(), hitachidsp.ram.size());
+  //if(cartridge.has_necdsp())
+  //  file::write({pathname, "dsp.data.ram"}, necdsp.dataRAM, sizeof(necdsp.dataRAM));
+}
+
 Interface::Interface() {
   interface = this;
   system.init();
diff --git a/sfc/interface/interface.hpp b/sfc/interface/interface.hpp
index e4f0f6d..3be5ff6 100644
--- a/sfc/interface/interface.hpp
+++ b/sfc/interface/interface.hpp
@@ -100,6 +100,7 @@ struct Interface : Emulator::Interface {
   void save();
   void load(unsigned id, const stream& stream);
   void save(unsigned id, const stream& stream);
+  void savemempak();
   void unload();
 
   void connect(unsigned port, unsigned device);
@@ -117,6 +118,9 @@ struct Interface : Emulator::Interface {
 
   void paletteUpdate(PaletteMode mode);
 
+  //debugger functions
+  void exportMemory();
+
   Interface();
 
   vector<Device> device;
diff --git a/sfc/ppu/ppu.cpp b/sfc/ppu/ppu.cpp
index 4ed7389..481ed4c 100644
--- a/sfc/ppu/ppu.cpp
+++ b/sfc/ppu/ppu.cpp
@@ -109,6 +109,36 @@ void PPU::reset() {
   frame();
 }
 
+void PPU::exportRegisters(string &markup) {
+  markup.append("ppu\n");
+  // 2105
+  markup.append("  bgmode:       ", regs.bgmode,       "\n");
+  markup.append("  bg3-priority: ", regs.bg3_priority, "\n");
+  // 2133
+  markup.append("  pseudo-hires: ", regs.pseudo_hires, "\n");
+  markup.append("  overscan:     ", regs.overscan,     "\n");
+  // individual backgrounds
+  auto bg = &bg1;
+  for(unsigned bg_id = 1; bg_id <= 4; bg_id++) {
+    switch(bg_id) {
+      case 1: bg = &bg1; break;
+      case 2: bg = &bg2; break;
+      case 3: bg = &bg3; break;
+      case 4: bg = &bg4; break;
+    }
+    markup.append("  bg\n");
+    markup.append("    tile-size:     ",   bg->regs.tile_size,             "\n");
+    markup.append("    mosaic:        ",   bg->regs.mosaic,                "\n");
+    markup.append("    screen-addr:   0x", hex<4>(bg->regs.screen_addr),   "\n");
+    markup.append("    screen-size:   ",   bg->regs.screen_size,           "\n");
+    markup.append("    tiledata-addr: 0x", hex<4>(bg->regs.tiledata_addr), "\n");
+    markup.append("    hoffset:       0x", hex<3>(bg->regs.hoffset),       "\n");
+    markup.append("    voffset:       0x", hex<3>(bg->regs.voffset),       "\n");
+    markup.append("    main-enable:   ",   bg->regs.main_enable,           "\n");
+    markup.append("    sub-enable:    ",   bg->regs.sub_enable,            "\n");
+  }
+}
+
 void PPU::scanline() {
   if(vcounter() == 0) {
     frame();
diff --git a/sfc/ppu/ppu.hpp b/sfc/ppu/ppu.hpp
index f6cd80b..61eb821 100644
--- a/sfc/ppu/ppu.hpp
+++ b/sfc/ppu/ppu.hpp
@@ -16,6 +16,7 @@ struct PPU : Thread, public PPUcounter {
   void enable();
   void power();
   void reset();
+  void exportRegisters(string &markup);
 
   void serialize(serializer&);
   PPU();
diff --git a/sfc/profile-accuracyfast.hpp b/sfc/profile-accuracyfast.hpp
new file mode 100644
index 0000000..bee7493
--- /dev/null
+++ b/sfc/profile-accuracyfast.hpp
@@ -0,0 +1,8 @@
+#if defined(DEBUGGER)
+  #error "bsnes: debugger not supported with accuracyfast profile."
+#endif
+
+#include <sfc/cpu/cpu.hpp>
+#include <sfc/smp/smp.hpp>
+#include <sfc/alt/dsp/dsp.hpp>
+#include <sfc/ppu/ppu.hpp>
diff --git a/sfc/sfc.hpp b/sfc/sfc.hpp
index a9d4b51..ca32458 100644
--- a/sfc/sfc.hpp
+++ b/sfc/sfc.hpp
@@ -57,6 +57,8 @@ namespace SuperFamicom {
 
   #if defined(PROFILE_ACCURACY)
   #include "profile-accuracy.hpp"
+  #elif defined(PROFILE_ACCURACYFAST)
+  #include "profile-accuracyfast.hpp"
   #elif defined(PROFILE_BALANCED)
   #include "profile-balanced.hpp"
   #elif defined(PROFILE_PERFORMANCE)
diff --git a/sfc/slot/satellaview/satellaview.cpp b/sfc/slot/satellaview/satellaview.cpp
index 5d2a613..3bf8663 100644
--- a/sfc/slot/satellaview/satellaview.cpp
+++ b/sfc/slot/satellaview/satellaview.cpp
@@ -8,6 +8,25 @@ SatellaviewCartridge satellaviewcartridge;
 void SatellaviewCartridge::init() {
 }
 
+void SatellaviewCartridge::save() {
+  if(memory.size() >= 1) {
+    file MEMPAK;
+    string mempakpath = {nall::configpath(), "higan/bsxmem/"}; //TODO: user configurable path
+    directory::create(mempakpath.data());
+    string filenm; //char filenm [25];
+    filenm.reserve(mempakpath.length()+9); //mempakpath + filename
+    bool writeisdone = false;
+    sprintf(filenm.data(), "%smempak.bs", (const char*)mempakpath.data()); //TODO: user configurable name; foltainer?
+    if (MEMPAK.open(filenm, file::mode::write)) {
+      int x;
+      for (x=0; x <= memory.size()-1; x++) {
+          MEMPAK.write(memory.read(x));
+      }
+      MEMPAK.close();
+    }
+  }
+}
+
 void SatellaviewCartridge::load() {
   if(memory.size() == 0) {
     memory.map(allocate<uint8>(1024 * 1024, 0xff), 1024 * 1024);
@@ -29,6 +48,7 @@ void SatellaviewCartridge::reset() {
   regs.flash_enable = false;
   regs.read_enable  = false;
   regs.write_enable = false;
+  regs.command_done = false;
   memory.write_protect(!regs.write_enable);
 }
 
@@ -39,24 +59,35 @@ unsigned SatellaviewCartridge::size() const {
 uint8 SatellaviewCartridge::read(unsigned addr) {
   if(readonly) return memory.read(bus.mirror(addr, memory.size()));
 
-  if(addr == 0x0002) {
-    if(regs.flash_enable) return 0x80;
+  unsigned addr2 = addr&0xffff;
+
+  if(addr2 == 0x5555 && regs.flash_enable) {
+    return 0x80;
   }
 
-  if(addr == 0x5555) {
-    if(regs.flash_enable) return 0x80;
+  if(regs.flash_stat_bsr && addr2 == 0x0002) {
+    return 0xc0;
+  }
+
+  if(regs.flash_stat_gsr && addr2 == 0x0004) {
+    return 0x82;
+  }
+
+  if(regs.flash_stat_csr) {
+    regs.flash_stat_csr = false;
+    return 0x80;
   }
 
-  if(regs.read_enable && addr >= 0xff00 && addr <= 0xff13) {
+  if(regs.read_enable && addr2 >= 0xff00 && addr2 <= 0xff13) {
     //read flash cartridge vendor information
     switch(addr - 0xff00) {
     case 0x00: return 0x4d;
-    case 0x01: return 0x00;
+    case 0x01: return 0x50;
     case 0x02: return 0x50;
     case 0x03: return 0x00;
     case 0x04: return 0x00;
     case 0x05: return 0x00;
-    case 0x06: return 0x2a;  //0x2a = 8mbit, 0x2b = 16mbit (not known to exist, though BIOS recognizes ID)
+    case 0x06: return 0x1a;  //0x2a = 8mbit, 0x2b = 16mbit (not known to exist, though BIOS recognizes ID)
     case 0x07: return 0x00;
     default:   return 0x00;
     }
@@ -73,21 +104,117 @@ void SatellaviewCartridge::write(unsigned addr, uint8 data) {
     regs.write_new = data;
 
     if(regs.write_enable && regs.write_old == regs.write_new) {
+      regs.write_enable = false;
       return memory.write(addr, data);
     }
   } else {
     if(regs.write_enable) {
+      regs.write_enable = false;
       return memory.write(addr, data);
     }
   }
+  if(regs.write_enable) {
+    regs.write_enable = false;
+    return memory.write(addr, data);
+  }
 
-  if(addr == 0x0000) {
+  if(true) {
     regs.command <<= 8;
     regs.command  |= data;
 
-    if((regs.command & 0xffff) == 0x38d0) {
-      regs.flash_enable = true;
-      regs.read_enable  = true;
+    switch(regs.command & 0xff) {
+      case 0x00:
+        regs.flash_enable = false;
+        regs.read_enable  = false;
+        regs.write_enable = false;
+        regs.flash_stat_csr = false;
+        regs.flash_stat_gsr = false;
+        regs.flash_stat_bsr = false;
+        regs.command_done = true;
+        break;
+      case 0x38:
+        regs.flash_enable = true;
+        regs.read_enable  = true;
+        regs.flash_stat_csr = false;
+        regs.flash_stat_gsr = false;
+        regs.flash_stat_bsr = false;
+        break;
+      case 0x10:
+        regs.write_enable = true;
+        regs.flash_stat_csr = true;
+        regs.flash_stat_gsr = false;
+        regs.flash_stat_bsr = false;
+        regs.command_done = true;
+        break;
+      case 0x40:
+        regs.write_enable = true;
+        regs.flash_stat_csr = true;
+        regs.flash_stat_gsr = false;
+        regs.flash_stat_bsr = false;
+        regs.command_done = true;
+        break;
+      case 0x50:
+        regs.flash_stat_csr = false;
+        regs.flash_stat_gsr = false;
+        regs.flash_stat_bsr = false;
+        regs.command_done = true;
+      case 0x70:
+        regs.flash_stat_csr = true;
+        regs.write_enable = false;
+        regs.flash_stat_gsr = false;
+        regs.flash_stat_bsr = false;
+        regs.command_done = true;
+        break;
+      case 0x71:
+        regs.flash_stat_gsr = true;
+        regs.flash_stat_bsr = true;
+        regs.flash_stat_csr = false;
+        regs.flash_enable = true;
+        regs.command_done = true;
+      case 0x72:
+        regs.command_done = true;
+        break;
+      case 0x75:
+        regs.read_enable  = true;
+        regs.flash_stat_csr = false;
+        regs.command_done = true;
+        break;
+      case 0xd0:
+        regs.command_done = true;
+        break;
+      case 0xff:
+        regs.flash_enable = false;
+        regs.read_enable  = false;
+        regs.write_enable = false;
+        regs.flash_stat_csr = false;
+        regs.flash_stat_gsr = false;
+        regs.flash_stat_bsr = false;
+        regs.command_done = true;
+        break;
+    }
+    if(regs.command_done) {
+      memory.write_protect(!regs.write_enable);
+      //Page Erase
+      if (regs.command == 0x20d0) {
+        memory.write_protect(false);
+        int erase_addr = addr & 0xff0000;
+        uint32 x;
+        for (x=0; x < 0xffff; x++) {
+          memory.write(erase_addr+x, 0xff);
+        }
+        memory.write_protect(true);
+      }
+      //Chip Erase
+      if (regs.command == 0xa7d0) {
+        memory.write_protect(false);
+        unsigned x;
+        for (x=0; x < satellaviewcartridge.size(); x++) {
+          memory.write(x, 0xff);
+        }
+        memory.write_protect(true);
+      }
+      regs.command = 0;
+      regs.command_done = false;
     }
   }
 
@@ -102,6 +229,7 @@ void SatellaviewCartridge::write(unsigned addr, uint8 data) {
 
     if((regs.command & 0xffffff) == 0xaa5570) {
       regs.write_enable = false;
+      regs.flash_enable = true;
     }
 
     if((regs.command & 0xffffff) == 0xaa55a0) {
@@ -114,7 +242,10 @@ void SatellaviewCartridge::write(unsigned addr, uint8 data) {
     if((regs.command & 0xffffff) == 0xaa55f0) {
       regs.flash_enable = false;
       regs.read_enable  = false;
-      regs.write_enable = false;
+      regs.write_enable = true;
+      regs.flash_stat_csr = false;
+      regs.flash_stat_gsr = false;
+      regs.flash_stat_bsr = false;
     }
 
     memory.write_protect(!regs.write_enable);
diff --git a/sfc/slot/satellaview/satellaview.hpp b/sfc/slot/satellaview/satellaview.hpp
index e1b8ffa..f5d85bc 100644
--- a/sfc/slot/satellaview/satellaview.hpp
+++ b/sfc/slot/satellaview/satellaview.hpp
@@ -1,8 +1,10 @@
+#include <nall/file.hpp>
 struct SatellaviewCartridge : Memory {
   MappedRAM memory;
   bool readonly;
 
   void init();
+  void save();
   void load();
   void unload();
   void power();
@@ -15,12 +17,17 @@ struct SatellaviewCartridge : Memory {
 private:
   struct {
     unsigned command;
+    unsigned command2;
     uint8 write_old;
     uint8 write_new;
 
     bool flash_enable;
     bool read_enable;
     bool write_enable;
+    bool command_done; //Giving Flash Command is done.
+    bool flash_stat_csr;
+    bool flash_stat_gsr;
+    bool flash_stat_bsr;
   } regs;
 };
 
diff --git a/sfc/system/system.cpp b/sfc/system/system.cpp
index 5b5c624..82282e6 100644
--- a/sfc/system/system.cpp
+++ b/sfc/system/system.cpp
@@ -142,6 +142,10 @@ void System::load() {
   serialize_init();
 }
 
+void System::savemempak() {
+  if(cartridge.has_bs_slot()) satellaviewcartridge.save();
+}
+
 void System::unload() {
   if(expansion() == ExpansionPortDevice::Satellaview) satellaviewbaseunit.unload();
   if(cartridge.has_gb_slot()) icd2.unload();
diff --git a/sfc/system/system.hpp b/sfc/system/system.hpp
index ae2238b..15128df 100644
--- a/sfc/system/system.hpp
+++ b/sfc/system/system.hpp
@@ -10,6 +10,7 @@ struct System : property<System> {
   void init();
   void term();
   void load();
+  void savemempak();
   void unload();
   void power();
   void reset();
diff --git a/target-higan/Makefile b/target-higan/Makefile
index 6e726ce..4c05293 100644
--- a/target-higan/Makefile
+++ b/target-higan/Makefile
@@ -1,4 +1,11 @@
-name := higan
+ifndef name
+  name := higan
+endif
+
+ifndef DESTDIR
+  DESTDIR := /
+endif
+
 
 processors := arm gsu hg51b lr35902 r6502 r65816 spc700 upd96050
 include processor/Makefile
@@ -89,29 +96,28 @@ resource:
 	sourcery $(ui)/resource/resource.bml $(ui)/resource/resource.cpp $(ui)/resource/resource.hpp
 
 install:
-ifneq ($(shell id -un),root)
-	$(error "make install must be run as root")
-else ifeq ($(platform),windows)
+ifeq ($(platform),windows)
 else ifeq ($(platform),macosx)
-	mkdir -p /Library/Application\ Support/$(name)
-	cp -R profile/* /Library/Application\ Support/$(name)
-	cp data/cheats.bml /Library/Application\ Support/$(name)/cheats.bml
-	chmod -R 777 /Library/Application\ Support/$(name)
+	install -d $(DESTDIR)Library/Application\ Support/$(name)
+	cp -R profile/* $(DESTDIR)Library/Application\ Support/$(name)
+	cp data/cheats.bml $(DESTDIR)Library/Application\ Support/$(name)/cheats.bml
+	#chmod -R 777 $(DESTDIR)Library/Application\ Support/$(name)
 else
-	cp out/$(name) $(prefix)/bin/$(name)
-	cp data/$(name).png $(prefix)/share/pixmaps/$(name).png
-	cp data/$(name).desktop $(prefix)/share/applications/$(name).desktop
-	mkdir -p /usr/share/$(name)
-	cp -R profile/* /usr/share/$(name)
-	cp data/cheats.bml /usr/share/$(name)/cheats.bml
-	chmod -R 777 /usr/share/$(name)
+	install -d $(DESTDIR)$(prefix)/bin/
+	cp out/$(name) $(DESTDIR)$(prefix)/bin/$(name)
+	install -d $(DESTDIR)$(prefix)/share/pixmaps/
+	cp data/higan.png $(DESTDIR)$(prefix)/share/pixmaps/$(name).png
+	install -d $(DESTDIR)$(prefix)/share/applications/
+	cp data/higan.desktop $(DESTDIR)$(prefix)/share/applications/$(name).desktop
+	install -d $(DESTDIR)usr/share/$(name)
+	cp -R profile/* $(DESTDIR)usr/share/$(name)
+	cp data/cheats.bml $(DESTDIR)usr/share/$(name)/cheats.bml
+	#chmod -R 777 $(DESTDIR)usr/share/$(name)
 endif
 
 uninstall:
-ifneq ($(shell id -un),root)
-	$(error "make uninstall must be run as root")
-else ifeq ($(platform),windows)
+ifeq ($(platform),windows)
 else ifeq ($(platform),macosx)
 else
-	rm $(prefix)/bin/$(name)
+	rm $(DESTDIR)$(prefix)/bin/$(name)
 endif
diff --git a/target-higan/general/presentation.cpp b/target-higan/general/presentation.cpp
index 651a11a..64405dd 100644
--- a/target-higan/general/presentation.cpp
+++ b/target-higan/general/presentation.cpp
@@ -189,6 +189,7 @@ void Presentation::bootstrap() {
     iEmulator->menu.setText(emulator->information.name);
     iEmulator->power.setText("Power");
     iEmulator->reset.setText("Reset");
+    iEmulator->savemempak.setText("Save BSX Mempak");
     iEmulator->unload.setText("Unload");
 
     for(auto& port : emulator->port) {
@@ -226,6 +227,7 @@ void Presentation::bootstrap() {
 
     iEmulator->power.onActivate = {&Utility::power, utility};
     iEmulator->reset.onActivate = {&Utility::reset, utility};
+    iEmulator->savemempak.onActivate = {&Utility::savemempak, utility};
     iEmulator->unload.onActivate = {&Utility::unload, utility};
 
     emulatorList.append(iEmulator);
diff --git a/target-higan/general/presentation.hpp b/target-higan/general/presentation.hpp
index 7bc8332..7fac1bc 100644
--- a/target-higan/general/presentation.hpp
+++ b/target-higan/general/presentation.hpp
@@ -8,6 +8,7 @@ struct Presentation : Window {
     Menu menu;
       Item power;
       Item reset;
+      Item savemempak;
       Item unload;
       Separator controllerSeparator;
       struct Port {
diff --git a/target-higan/input/hotkeys.cpp b/target-higan/input/hotkeys.cpp
index 0df7255..cc5cf05 100644
--- a/target-higan/input/hotkeys.cpp
+++ b/target-higan/input/hotkeys.cpp
@@ -129,6 +129,18 @@ void InputManager::appendHotkeys() {
     };
   }
 
+  {
+    auto hotkey = new HotkeyInput;
+    hotkey->name    = "Export Memory";
+    hotkey->mapping = "None";
+
+    hotkey->press = [&] {
+      if(program->active == nullptr) return;
+      system().exportMemory();
+      utility->showMessage("Memory exported");
+    };
+  }
+
   Configuration::Node node;
   for(auto& hotkey : hotkeyMap) {
     node.append(hotkey->mapping, string{hotkey->name}.replace(" ", ""));
diff --git a/target-higan/utility/utility.cpp b/target-higan/utility/utility.cpp
index 2645092..b096823 100644
--- a/target-higan/utility/utility.cpp
+++ b/target-higan/utility/utility.cpp
@@ -99,6 +99,10 @@ void Utility::load() {
   cheatEditor->refresh();
 }
 
+void Utility::savemempak() {
+  system().unload();
+}
+
 void Utility::unload() {
   if(program->active == nullptr) return;
 
diff --git a/target-higan/utility/utility.hpp b/target-higan/utility/utility.hpp
index 5b3fb92..245a86f 100644
--- a/target-higan/utility/utility.hpp
+++ b/target-higan/utility/utility.hpp
@@ -12,6 +12,7 @@ struct Utility {
   void power();
   void reset();
   void load();
+  void savemempak();
   void unload();
 
   void saveState(unsigned slot);
diff --git a/target-loki/Makefile b/target-loki/Makefile
index 28b9d9b..891590f 100644
--- a/target-loki/Makefile
+++ b/target-loki/Makefile
@@ -1,4 +1,10 @@
-name := loki
+ifndef name
+  name := loki
+endif
+
+ifndef DESTDIR
+  DESTDIR := /
+endif
 
 processors := arm gsu hg51b lr35902 r65816 spc700 upd96050
 include processor/Makefile
@@ -72,25 +78,22 @@ resource:
 	sourcery $(ui)/resource/resource.bml $(ui)/resource/resource.cpp $(ui)/resource/resource.hpp
 
 install:
-ifneq ($(shell id -un),root)
-	$(error "make install must be run as root")
-else ifeq ($(platform),windows)
+ifeq ($(platform),windows)
 else ifeq ($(platform),macosx)
-	mkdir -p /Library/Application\ Support/$(name)
-	cp -R profile/* /Library/Application\ Support/$(name)
-	chmod -R 777 /Library/Application\ Support/$(name)
+	install -d $(DESTDIR)Library/Application\ Support/$(name)
+	cp -R profile/* $(DESTDIR)Library/Application\ Support/$(name)
+	#chmod -R 777 $(DESTDIR)Library/Application\ Support/$(name)
 else
-	cp out/$(name) $(prefix)/bin/$(name)
-	mkdir -p /usr/share/$(name)
-	cp -R profile/* /usr/share/$(name)
-	chmod -R 777 /usr/share/$(name)
+	install -d $(DESTDIR)$(prefix)/bin/
+	cp out/$(name) $(DESTDIR)$(prefix)/bin/$(name)
+	install -d $(DESTDIR)usr/share/$(name)
+	cp -R profile/* $(DESTDIR)usr/share/$(name)
+	#chmod -R 777 $(DESTDIR)usr/share/$(name)
 endif
 
 uninstall:
-ifneq ($(shell id -un),root)
-	$(error "make uninstall must be run as root")
-else ifeq ($(platform),windows)
+ifeq ($(platform),windows)
 else ifeq ($(platform),macosx)
 else
-	rm $(prefix)/bin/$(name)
+	rm $(DESTDIR)$(prefix)/bin/$(name)
 endif
