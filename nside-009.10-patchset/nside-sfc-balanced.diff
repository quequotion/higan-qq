diff --git a/nSide/higan/sfc-balanced/GNUmakefile b/nSide/higan/sfc-balanced/GNUmakefile
new file mode 100644
index 0000000..6f5c121
--- /dev/null
+++ b/nSide/higan/sfc-balanced/GNUmakefile
@@ -0,0 +1,54 @@
+processors += wdc65816 spc700 arm gsu hg51b upd96050
+
+objects += sfc-balanced-interface sfc-balanced-system sfc-balanced-controller
+objects += sfc-balanced-cartridge sfc-balanced-memory
+objects += sfc-balanced-cpu sfc-balanced-smp sfc-balanced-dsp sfc-balanced-ppu
+objects += sfc-balanced-expansion sfc-balanced-satellaview sfc-balanced-21fx
+objects += sfc-balanced-icd2 sfc-balanced-mcc sfc-balanced-nss sfc-balanced-event
+objects += sfc-balanced-sa1 sfc-balanced-superfx
+objects += sfc-balanced-armdsp sfc-balanced-hitachidsp sfc-balanced-necdsp
+objects += sfc-balanced-epsonrtc sfc-balanced-sharprtc
+objects += sfc-balanced-spc7110 sfc-balanced-sdd1
+objects += sfc-balanced-obc1 sfc-balanced-msu1
+objects += sfc-balanced-bsmemory sfc-balanced-sufamiturbo
+
+flags += -DPROFILE_BALANCED
+
+obj/sfc-balanced-interface.o:   sfc-balanced/interface/interface.cpp $(call rwildcard,sfc-balanced/interface)
+obj/sfc-balanced-system.o:      sfc-balanced/system/system.cpp $(call rwildcard,sfc-balanced/system/)
+obj/sfc-balanced-controller.o:  sfc-balanced/controller/controller.cpp $(call rwildcard,sfc-balanced/controller/)
+obj/sfc-balanced-cartridge.o:   sfc-balanced/cartridge/cartridge.cpp $(call rwildcard,sfc-balanced/cartridge/)
+obj/sfc-balanced-memory.o:      sfc-balanced/memory/memory.cpp $(call rwildcard,sfc-balanced/memory/)
+
+obj/sfc-balanced-cpu.o:         sfc-balanced/cpu/cpu.cpp $(call rwildcard,sfc-balanced/cpu/)
+obj/sfc-balanced-smp.o:         sfc-balanced/smp/smp.cpp $(call rwildcard,sfc-balanced/smp/)
+obj/sfc-balanced-dsp.o:         sfc-balanced/dsp/dsp.cpp $(call rwildcard,sfc-balanced/dsp/)
+obj/sfc-balanced-ppu.o:         sfc-balanced/ppu/ppu.cpp $(call rwildcard,sfc-balanced/ppu/)
+
+obj/sfc-balanced-expansion.o:   sfc-balanced/expansion/expansion.cpp $(call rwildcard,sfc-balanced/expansion/)
+obj/sfc-balanced-satellaview.o: sfc-balanced/expansion/satellaview/satellaview.cpp $(call rwildcard,sfc-balanced/expansion/satellaview/)
+obj/sfc-balanced-21fx.o:        sfc-balanced/expansion/21fx/21fx.cpp $(call rwildcard,sfc-balanced/expansion/21fx/)
+
+obj/sfc-balanced-icd2.o:        sfc-balanced/coprocessor/icd2/icd2.cpp $(call rwildcard,sfc-balanced/coprocessor/icd2/)
+obj/sfc-balanced-mcc.o:         sfc-balanced/coprocessor/mcc/mcc.cpp $(call rwildcard,sfc-balanced/coprocessor/mcc/)
+obj/sfc-balanced-nss.o:         sfc-balanced/coprocessor/nss/nss.cpp $(call rwildcard,sfc-balanced/coprocessor/nss/)
+obj/sfc-balanced-event.o:       sfc-balanced/coprocessor/event/event.cpp $(call rwildcard,sfc-balanced/coprocessor/event/)
+
+obj/sfc-balanced-sa1.o:         sfc-balanced/coprocessor/sa1/sa1.cpp $(call rwildcard,sfc-balanced/coprocessor/sa1/)
+obj/sfc-balanced-superfx.o:     sfc-balanced/coprocessor/superfx/superfx.cpp $(call rwildcard,sfc-balanced/coprocessor/superfx/)
+
+obj/sfc-balanced-armdsp.o:      sfc-balanced/coprocessor/armdsp/armdsp.cpp $(call rwildcard,sfc-balanced/coprocessor/armdsp/)
+obj/sfc-balanced-hitachidsp.o:  sfc-balanced/coprocessor/hitachidsp/hitachidsp.cpp $(call rwildcard,sfc-balanced/coprocessor/hitachidsp/)
+obj/sfc-balanced-necdsp.o:      sfc-balanced/coprocessor/necdsp/necdsp.cpp $(call rwildcard,sfc-balanced/coprocessor/necdsp/)
+
+obj/sfc-balanced-epsonrtc.o:    sfc-balanced/coprocessor/epsonrtc/epsonrtc.cpp $(call rwildcard,sfc-balanced/coprocessor/epsonrtc/)
+obj/sfc-balanced-sharprtc.o:    sfc-balanced/coprocessor/sharprtc/sharprtc.cpp $(call rwildcard,sfc-balanced/coprocessor/sharprtc/)
+
+obj/sfc-balanced-spc7110.o:     sfc-balanced/coprocessor/spc7110/spc7110.cpp $(call rwildcard,sfc-balanced/coprocessor/spc7110/)
+obj/sfc-balanced-sdd1.o:        sfc-balanced/coprocessor/sdd1/sdd1.cpp $(call rwildcard,sfc-balanced/coprocessor/sdd1/)
+obj/sfc-balanced-obc1.o:        sfc-balanced/coprocessor/obc1/obc1.cpp $(call rwildcard,sfc-balanced/coprocessor/obc1/)
+
+obj/sfc-balanced-msu1.o:        sfc-balanced/coprocessor/msu1/msu1.cpp $(call rwildcard,sfc-balanced/coprocessor/msu1/)
+
+obj/sfc-balanced-bsmemory.o:    sfc-balanced/slot/bsmemory/bsmemory.cpp $(call rwildcard,sfc-balanced/slot/bsmemory/)
+obj/sfc-balanced-sufamiturbo.o: sfc-balanced/slot/sufamiturbo/sufamiturbo.cpp $(call rwildcard,sfc-balanced/slot/sufamiturbo/)
diff --git a/nSide/higan/sfc-balanced/cartridge/cartridge.cpp b/nSide/higan/sfc-balanced/cartridge/cartridge.cpp
new file mode 100644
index 0000000..3586b78
--- /dev/null
+++ b/nSide/higan/sfc-balanced/cartridge/cartridge.cpp
@@ -0,0 +1,138 @@
+#include <sfc-balanced/sfc.hpp>
+
+namespace SuperFamicom {
+
+#include "load.cpp"
+#include "save.cpp"
+#include "serialization.cpp"
+Cartridge cartridge;
+
+auto Cartridge::manifest() const -> string {
+  string manifest = information.manifest.cartridge;
+  if(information.manifest.gameBoy) manifest.append("\n[[Game Boy]]\n\n", information.manifest.gameBoy);
+  if(information.manifest.bsMemory) manifest.append("\n[[BS Memory]]\n\n", information.manifest.bsMemory);
+  if(information.manifest.sufamiTurboA) manifest.append("\n[[Sufami Turbo - Slot A]]\n\n", information.manifest.sufamiTurboA);
+  if(information.manifest.sufamiTurboB) manifest.append("\n[[Sufami Turbo - Slot B]]\n\n", information.manifest.sufamiTurboB);
+  return manifest;
+}
+
+auto Cartridge::title() const -> string {
+  string title = information.title.cartridge;
+  if(information.title.gameBoy) title.append(" + ", information.title.gameBoy);
+  if(information.title.bsMemory) title.append(" + ", information.title.bsMemory);
+  if(information.title.sufamiTurboA) title.append(" + ", information.title.sufamiTurboA);
+  if(information.title.sufamiTurboB) title.append(" + ", information.title.sufamiTurboB);
+  return title;
+}
+
+auto Cartridge::load() -> bool {
+  information = Information();
+  has = Has();
+
+  if(auto pathID = interface->load(ID::SuperFamicom, "Super Famicom", "sfc")) {
+    information.pathID = pathID();
+  } else return false;
+
+  if(auto fp = interface->open(ID::SuperFamicom, "manifest.bml", File::Read, File::Required)) {
+    information.manifest.cartridge = fp->reads();
+  } else return false;
+  auto document = BML::unserialize(information.manifest.cartridge);
+  loadCartridge(document);
+
+  //Game Boy
+  if(cartridge.has.ICD2) {
+    information.sha256 = "";  //Game Boy cartridge not loaded yet: set later via loadGameBoy()
+  }
+
+  //BS Memory
+  else if(cartridge.has.MCC && cartridge.has.BSMemorySlot) {
+    information.sha256 = Hash::SHA256(bsmemory.memory.data(), bsmemory.memory.size()).digest();
+  }
+
+  //Sufami Turbo
+  else if(cartridge.has.SufamiTurboSlots) {
+    Hash::SHA256 sha;
+    sha.input(sufamiturboA.rom.data(), sufamiturboA.rom.size());
+    sha.input(sufamiturboB.rom.data(), sufamiturboB.rom.size());
+    information.sha256 = sha.digest();
+  }
+
+  //Super Famicom
+  else {
+    Hash::SHA256 sha;
+    //hash each ROM image that exists; any with size() == 0 is ignored by sha256_chunk()
+    sha.input(rom.data(), rom.size());
+    sha.input(mcc.rom.data(), mcc.rom.size());
+    sha.input(sa1.rom.data(), sa1.rom.size());
+    sha.input(superfx.rom.data(), superfx.rom.size());
+    sha.input(hitachidsp.rom.data(), hitachidsp.rom.size());
+    sha.input(spc7110.prom.data(), spc7110.prom.size());
+    sha.input(spc7110.drom.data(), spc7110.drom.size());
+    sha.input(sdd1.rom.data(), sdd1.rom.size());
+    //hash all firmware that exists
+    vector<uint8> buffer;
+    buffer = armdsp.firmware();
+    sha.input(buffer.data(), buffer.size());
+    buffer = hitachidsp.firmware();
+    sha.input(buffer.data(), buffer.size());
+    buffer = necdsp.firmware();
+    sha.input(buffer.data(), buffer.size());
+    //finalize hash
+    information.sha256 = sha.digest();
+  }
+
+  rom.writeProtect(true);
+  ram.writeProtect(false);
+  return true;
+}
+
+auto Cartridge::loadGameBoy() -> bool {
+  #if defined(SFC_SUPERGAMEBOY)
+  //invoked from ICD2::load()
+  information.sha256 = GameBoy::interface->sha256();
+  information.manifest.gameBoy = GameBoy::interface->manifest();
+  information.title.gameBoy = GameBoy::interface->title();
+  loadGameBoy(BML::unserialize(information.manifest.gameBoy));
+  return true;
+  #endif
+  return false;
+}
+
+auto Cartridge::loadBSMemory() -> bool {
+  if(auto fp = interface->open(bsmemory.pathID, "manifest.bml", File::Read, File::Required)) {
+    information.manifest.bsMemory = fp->reads();
+  } else return false;
+  loadBSMemory(BML::unserialize(information.manifest.bsMemory));
+  return true;
+}
+
+auto Cartridge::loadSufamiTurboA() -> bool {
+  if(auto fp = interface->open(sufamiturboA.pathID, "manifest.bml", File::Read, File::Required)) {
+    information.manifest.sufamiTurboA = fp->reads();
+  } else return false;
+  loadSufamiTurboA(BML::unserialize(information.manifest.sufamiTurboA));
+  return true;
+}
+
+auto Cartridge::loadSufamiTurboB() -> bool {
+  if(auto fp = interface->open(sufamiturboB.pathID, "manifest.bml", File::Read, File::Required)) {
+    information.manifest.sufamiTurboB = fp->reads();
+  } else return false;
+  loadSufamiTurboB(BML::unserialize(information.manifest.sufamiTurboB));
+  return true;
+}
+
+auto Cartridge::save() -> void {
+  saveCartridge(BML::unserialize(information.manifest.cartridge));
+  saveGameBoy(BML::unserialize(information.manifest.gameBoy));
+  saveBSMemory(BML::unserialize(information.manifest.bsMemory));
+  saveSufamiTurboA(BML::unserialize(information.manifest.sufamiTurboA));
+  saveSufamiTurboB(BML::unserialize(information.manifest.sufamiTurboB));
+}
+
+auto Cartridge::unload() -> void {
+  rom.reset();
+  ram.reset();
+}
+
+}
diff --git a/nSide/higan/sfc-balanced/cartridge/cartridge.hpp b/nSide/higan/sfc-balanced/cartridge/cartridge.hpp
new file mode 100644
index 0000000..22eda2f
--- /dev/null
+++ b/nSide/higan/sfc-balanced/cartridge/cartridge.hpp
@@ -0,0 +1,128 @@
+struct Cartridge {
+  enum class Region : uint { NTSC, PAL };
+
+  auto pathID() const -> uint { return information.pathID; }
+  auto sha256() const -> string { return information.sha256; }
+  auto region() const -> Region { return information.region; }
+  auto manifest() const -> string;
+  auto title() const -> string;
+
+  auto load() -> bool;
+  auto save() -> void;
+  auto unload() -> void;
+
+  auto serialize(serializer&) -> void;
+
+  MappedRAM rom;
+  MappedRAM ram;
+
+  struct Information {
+    uint pathID = 0;
+    string sha256;
+    Region region = Region::NTSC;
+
+    struct Manifest {
+      string cartridge;
+      string gameBoy;
+      string bsMemory;
+      string sufamiTurboA;
+      string sufamiTurboB;
+    } manifest;
+
+    struct Title {
+      string cartridge;
+      string gameBoy;
+      string bsMemory;
+      string sufamiTurboA;
+      string sufamiTurboB;
+    } title;
+  } information;
+
+  struct Has {
+    boolean ICD2;
+    boolean MCC;
+    boolean NSSDIP;
+    boolean Event;
+    boolean SA1;
+    boolean SuperFX;
+    boolean ARMDSP;
+    boolean HitachiDSP;
+    boolean NECDSP;
+    boolean EpsonRTC;
+    boolean SharpRTC;
+    boolean SPC7110;
+    boolean SDD1;
+    boolean OBC1;
+    boolean MSU1;
+
+    boolean GameBoySlot;
+    boolean BSMemorySlot;
+    boolean SufamiTurboSlots;
+  } has;
+
+private:
+  //cartridge.cpp
+  auto loadGameBoy() -> bool;
+  auto loadBSMemory() -> bool;
+  auto loadSufamiTurboA() -> bool;
+  auto loadSufamiTurboB() -> bool;
+
+  //load.cpp
+  auto loadCartridge(Markup::Node) -> void;
+  auto loadGameBoy(Markup::Node) -> void;
+  auto loadBSMemory(Markup::Node) -> void;
+  auto loadSufamiTurboA(Markup::Node) -> void;
+  auto loadSufamiTurboB(Markup::Node) -> void;
+
+  auto loadROM(Markup::Node) -> void;
+  auto loadRAM(Markup::Node) -> void;
+  auto loadICD2(Markup::Node) -> void;
+  auto loadMCC(Markup::Node) -> void;
+  auto loadBSMemoryPack(Markup::Node) -> void;
+  auto loadSufamiTurbo(Markup::Node, bool slot) -> void;
+  auto loadNSS(Markup::Node) -> void;
+  auto loadEvent(Markup::Node) -> void;
+  auto loadSA1(Markup::Node) -> void;
+  auto loadSuperFX(Markup::Node) -> void;
+  auto loadARMDSP(Markup::Node) -> void;
+  auto loadHitachiDSP(Markup::Node, uint roms) -> void;
+  auto loadNECDSP(Markup::Node) -> void;
+  auto loadEpsonRTC(Markup::Node) -> void;
+  auto loadSharpRTC(Markup::Node) -> void;
+  auto loadSPC7110(Markup::Node) -> void;
+  auto loadSDD1(Markup::Node) -> void;
+  auto loadOBC1(Markup::Node) -> void;
+  auto loadMSU1(Markup::Node) -> void;
+
+  auto loadMemory(MappedRAM&, Markup::Node, bool required, maybe<uint> id = nothing) -> void;
+  auto loadMap(Markup::Node, SuperFamicom::Memory&) -> void;
+  auto loadMap(Markup::Node, const function<uint8 (uint24, uint8)>&, const function<void (uint24, uint8)>&) -> void;
+
+  //save.cpp
+  auto saveCartridge(Markup::Node) -> void;
+  auto saveGameBoy(Markup::Node) -> void;
+  auto saveBSMemory(Markup::Node) -> void;
+  auto saveSufamiTurboA(Markup::Node) -> void;
+  auto saveSufamiTurboB(Markup::Node) -> void;
+
+  auto saveRAM(Markup::Node) -> void;
+  auto saveMCC(Markup::Node) -> void;
+  auto saveEvent(Markup::Node) -> void;
+  auto saveSA1(Markup::Node) -> void;
+  auto saveSuperFX(Markup::Node) -> void;
+  auto saveARMDSP(Markup::Node) -> void;
+  auto saveHitachiDSP(Markup::Node) -> void;
+  auto saveNECDSP(Markup::Node) -> void;
+  auto saveEpsonRTC(Markup::Node) -> void;
+  auto saveSharpRTC(Markup::Node) -> void;
+  auto saveSPC7110(Markup::Node) -> void;
+  auto saveSDD1(Markup::Node) -> void;
+  auto saveOBC1(Markup::Node) -> void;
+
+  auto saveMemory(MappedRAM&, Markup::Node, maybe<uint> = nothing) -> void;
+
+  friend class Interface;
+  friend class ICD2;
+};
+
+extern Cartridge cartridge;
diff --git a/nSide/higan/sfc-balanced/cartridge/load.cpp b/nSide/higan/sfc-balanced/cartridge/load.cpp
new file mode 100644
index 0000000..ed97741
--- /dev/null
+++ b/nSide/higan/sfc-balanced/cartridge/load.cpp
@@ -0,0 +1,350 @@
+auto Cartridge::loadCartridge(Markup::Node node) -> void {
+  information.title.cartridge = node["information/title"].text();
+  auto board = node["board"];
+  information.region = board["region"].text() == "pal" ? Region::PAL : Region::NTSC;
+
+  if(board["mcc"] || board["bsmemory"]) {
+    if(auto pathID = interface->load(ID::BSMemory, "BS Memory", "bs")) {
+      bsmemory.pathID = pathID();
+      loadBSMemory();
+    }
+  }
+  if(board["sufamiturbo"]) {
+    if(auto pathID = interface->load(ID::SufamiTurboA, "Sufami Turbo", "st")) {
+      sufamiturboA.pathID = pathID();
+      loadSufamiTurboA();
+    }
+  }
+
+  if(auto node = board["rom"]) loadROM(node);
+  if(auto node = board["ram"]) loadRAM(node);
+  if(auto node = board["icd2"]) loadICD2(node);
+  if(auto node = board["mcc"]) loadMCC(node);
+  if(auto node = board["bsmemory"]) loadBSMemoryPack(node);
+  if(auto node = board.find("sufamiturbo")) if(node(0)) loadSufamiTurbo(node(0), 0);
+  if(auto node = board.find("sufamiturbo")) if(node(1)) loadSufamiTurbo(node(1), 1);
+  if(auto node = board["nss"]) loadNSS(node);
+  if(auto node = board["event"]) loadEvent(node);
+  if(auto node = board["sa1"]) loadSA1(node);
+  if(auto node = board["superfx"]) loadSuperFX(node);
+  if(auto node = board["armdsp"]) loadARMDSP(node);
+  if(auto node = board["hitachidsp"]) loadHitachiDSP(node, node["information/board"].text().match("2DC*") ? 2 : 1);
+  if(auto node = board["necdsp"]) loadNECDSP(node);
+  if(auto node = board["epsonrtc"]) loadEpsonRTC(node);
+  if(auto node = board["sharprtc"]) loadSharpRTC(node);
+  if(auto node = board["spc7110"]) loadSPC7110(node);
+  if(auto node = board["sdd1"]) loadSDD1(node);
+  if(auto node = board["obc1"]) loadOBC1(node);
+  if(auto node = board["msu1"]) loadMSU1(node);
+}
+
+auto Cartridge::loadGameBoy(Markup::Node node) -> void {
+}
+
+auto Cartridge::loadBSMemory(Markup::Node node) -> void {
+  information.title.bsMemory = node["information/title"].text();
+  bsmemory.readonly = (node["board/rom/type"].text() == "mrom");
+
+  loadMemory(bsmemory.memory, node["board/rom"], File::Required, bsmemory.pathID);
+}
+
+auto Cartridge::loadSufamiTurboA(Markup::Node node) -> void {
+  information.title.sufamiTurboA = node["information/title"].text();
+
+  loadMemory(sufamiturboA.rom, node["board/rom"], File::Required, sufamiturboA.pathID);
+  loadMemory(sufamiturboA.ram, node["board/ram"], File::Optional, sufamiturboA.pathID);
+
+  if(node["board/linkable"]) {
+    if(auto pathID = interface->load(ID::SufamiTurboB, "Sufami Turbo", "st")) {
+      sufamiturboB.pathID = pathID();
+      loadSufamiTurboB();
+    }
+  }
+}
+
+auto Cartridge::loadSufamiTurboB(Markup::Node node) -> void {
+  information.title.sufamiTurboB = node["information/title"].text();
+
+  loadMemory(sufamiturboB.rom, node["board/rom"], File::Required, sufamiturboB.pathID);
+  loadMemory(sufamiturboB.ram, node["board/ram"], File::Optional, sufamiturboB.pathID);
+}
+
+//
+
+auto Cartridge::loadROM(Markup::Node node) -> void {
+  loadMemory(rom, node, File::Required);
+  for(auto leaf : node.find("map")) loadMap(leaf, rom);
+}
+
+auto Cartridge::loadRAM(Markup::Node node) -> void {
+  loadMemory(ram, node, File::Optional);
+  for(auto leaf : node.find("map")) loadMap(leaf, ram);
+}
+
+auto Cartridge::loadICD2(Markup::Node node) -> void {
+  has.GameBoySlot = true;
+  has.ICD2 = true;
+  icd2.revision = max(1, node["revision"].natural());
+
+  //Game Boy core loads data through ICD2 interface
+  for(auto leaf : node.find("map")) loadMap(leaf, {&ICD2::readIO, &icd2}, {&ICD2::writeIO, &icd2});
+}
+
+auto Cartridge::loadMCC(Markup::Node node) -> void {
+  has.BSMemorySlot = true;
+  has.MCC = true;
+
+  loadMemory(mcc.rom, node["rom"], File::Required);
+  loadMemory(mcc.ram, node["ram"], File::Optional);
+
+  for(auto leaf : node.find("map")) leaf.text() == "mcu"
+  ? loadMap(leaf, {&MCC::mcuRead, &mcc}, {&MCC::mcuWrite, &mcc})
+  : loadMap(leaf, {&MCC::read, &mcc}, {&MCC::write, &mcc});
+  for(auto leaf : node["ram"].find("map")) loadMap(leaf, mcc.ram);
+}
+
+auto Cartridge::loadBSMemoryPack(Markup::Node node) -> void {
+  has.BSMemorySlot = true;
+
+  for(auto leaf : node.find("map")) {
+    if(bsmemory.memory.size() == 0) continue;
+    loadMap(leaf, bsmemory);
+  }
+}
+
+auto Cartridge::loadSufamiTurbo(Markup::Node node, bool slot) -> void {
+  has.SufamiTurboSlots = true;
+
+  for(auto leaf : node["rom"].find("map")) {
+    auto& cart = (slot == 0 ? sufamiturboA : sufamiturboB);
+    if(cart.rom.size() == 0) continue;
+    loadMap(leaf, cart.rom);
+  }
+
+  for(auto leaf : node["ram"].find("map")) {
+    auto& cart = (slot == 0 ? sufamiturboA : sufamiturboB);
+    if(cart.ram.size() == 0) continue;
+    loadMap(leaf, cart.ram);
+  }
+}
+
+auto Cartridge::loadNSS(Markup::Node node) -> void {
+  has.NSSDIP = true;
+  nss.dip = interface->dipSettings(node);
+
+  for(auto leaf : node.find("map")) loadMap(leaf, {&NSS::read, &nss}, {&NSS::write, &nss});
+}
+
+auto Cartridge::loadEvent(Markup::Node node) -> void {
+  auto roms = node.find("rom");
+  if(roms.size() != 4) return;
+
+  has.Event = true;
+
+  for(uint n : range(4)) loadMemory(event.rom[n], roms[n], File::Required);
+  loadMemory(event.ram, node["ram"], File::Optional);
+
+  event.board = Event::Board::CampusChallenge92;
+  if(node.text() == "CC92") event.board = Event::Board::CampusChallenge92;
+  if(node.text() == "PF94") event.board = Event::Board::Powerfest94;
+  event.timer = node["timer"].natural();
+
+  for(auto leaf : node.find("map")) leaf.text() == "mcu"
+  ? loadMap(leaf, {&Event::mcuRead, &event}, {&Event::mcuWrite, &event})
+  : loadMap(leaf, {&Event::read, &event}, {&Event::write, &event});
+  for(auto leaf : node["ram"].find("map")) loadMap(leaf, event.ram);
+}
+
+auto Cartridge::loadSA1(Markup::Node node) -> void {
+  has.SA1 = true;
+
+  loadMemory(sa1.rom, node["rom"], File::Required);
+  loadMemory(sa1.bwram, node["bwram"], File::Optional);
+  loadMemory(sa1.iram, node["iram"], File::Optional);
+
+  for(auto leaf : node.find("map")) loadMap(leaf, {&SA1::readIO, &sa1}, {&SA1::writeIO, &sa1});
+  for(auto leaf : node["rom"].find("map")) loadMap(leaf, {&SA1::mmcromRead, &sa1}, {&SA1::mmcromWrite, &sa1});
+  for(auto leaf : node["bwram"].find("map")) loadMap(leaf, {&SA1::mmcbwramRead, &sa1}, {&SA1::mmcbwramWrite, &sa1});
+  for(auto leaf : node["iram"].find("map")) loadMap(leaf, sa1.cpuiram);
+}
+
+auto Cartridge::loadSuperFX(Markup::Node node) -> void {
+  has.SuperFX = true;
+
+  loadMemory(superfx.rom, node["rom"], File::Required);
+  loadMemory(superfx.ram, node["ram"], File::Optional);
+
+  for(auto leaf : node.find("map")) loadMap(leaf, {&SuperFX::readIO, &superfx}, {&SuperFX::writeIO, &superfx});
+  for(auto leaf : node["rom"].find("map")) loadMap(leaf, superfx.cpurom);
+  for(auto leaf : node["ram"].find("map")) loadMap(leaf, superfx.cpuram);
+}
+
+auto Cartridge::loadARMDSP(Markup::Node node) -> void {
+  has.ARMDSP = true;
+
+  if(auto fp = interface->open(ID::SuperFamicom, node["prom"]["name"].text(), File::Read, File::Required)) {
+    for(auto n : range(128 * 1024)) armdsp.programROM[n] = fp->read();
+  }
+  if(auto fp = interface->open(ID::SuperFamicom, node["drom"]["name"].text(), File::Read, File::Required)) {
+    for(auto n : range( 32 * 1024)) armdsp.dataROM[n] = fp->read();
+  }
+  if(auto fp = interface->open(ID::SuperFamicom, node["ram"]["name"].text(), File::Read)) {
+    for(auto n : range( 16 * 1024)) armdsp.programRAM[n] = fp->read();
+  }
+
+  for(auto leaf : node.find("map")) loadMap(leaf, {&ArmDSP::read, &armdsp}, {&ArmDSP::write, &armdsp});
+}
+
+auto Cartridge::loadHitachiDSP(Markup::Node node, uint roms) -> void {
+  has.HitachiDSP = true;
+
+  hitachidsp.Frequency = node["frequency"].natural();
+  if(hitachidsp.Frequency == 0) hitachidsp.Frequency = 20'000'000;
+  hitachidsp.Roms = roms;  //1 or 2
+
+  loadMemory(hitachidsp.rom, node["rom"], File::Required);
+  loadMemory(hitachidsp.ram, node["ram"], File::Optional);
+
+  for(auto& word : hitachidsp.dataROM) word = 0x000000;
+  for(auto& word : hitachidsp.dataRAM) word = 0x00;
+
+  if(auto fp = interface->open(ID::SuperFamicom, node["drom"]["name"].text(), File::Read, File::Required)) {
+    for(auto n : range(1 * 1024)) hitachidsp.dataROM[n] = fp->readl(3);
+  }
+  if(auto fp = interface->open(ID::SuperFamicom, node["dram"]["name"].text(), File::Read)) {
+    for(auto n : range(3 * 1024)) hitachidsp.dataRAM[n] = fp->readl(1);
+  }
+
+  for(auto leaf : node.find("map")) loadMap(leaf, {&HitachiDSP::dspRead, &hitachidsp}, {&HitachiDSP::dspWrite, &hitachidsp});
+  for(auto leaf : node["rom"].find("map")) loadMap(leaf, {&HitachiDSP::romRead, &hitachidsp}, {&HitachiDSP::romWrite, &hitachidsp});
+  for(auto leaf : node["ram"].find("map")) loadMap(leaf, {&HitachiDSP::ramRead, &hitachidsp}, {&HitachiDSP::ramWrite, &hitachidsp});
+  for(auto leaf : node["dram"].find("map")) loadMap(leaf, {&HitachiDSP::dramRead, &hitachidsp}, {&HitachiDSP::dramWrite, &hitachidsp});
+}
+
+auto Cartridge::loadNECDSP(Markup::Node node) -> void {
+  has.NECDSP = true;
+
+  necdsp.Frequency = node["frequency"].natural();
+  if(necdsp.Frequency == 0) necdsp.Frequency = 8000000;
+  necdsp.revision
+  = node["model"].text() == "uPD7725"  ? NECDSP::Revision::uPD7725
+  : node["model"].text() == "uPD96050" ? NECDSP::Revision::uPD96050
+  : NECDSP::Revision::uPD7725;
+
+  for(auto& word : necdsp.programROM) word = 0x000000;
+  for(auto& word : necdsp.dataROM) word = 0x0000;
+  for(auto& word : necdsp.dataRAM) word = 0x0000;
+
+  uint size[3] = {0};
+  if(necdsp.revision == NECDSP::Revision::uPD7725 ) memory::assign(size,  2048, 1024,  256);
+  if(necdsp.revision == NECDSP::Revision::uPD96050) memory::assign(size, 16384, 2048, 2048);
+
+  if(auto fp = interface->open(ID::SuperFamicom, node["prom"]["name"].text(), File::Read, File::Required)) {
+    for(auto n : range(size[0])) necdsp.programROM[n] = fp->readl(3);
+  }
+  if(auto fp = interface->open(ID::SuperFamicom, node["drom"]["name"].text(), File::Read, File::Required)) {
+    for(auto n : range(size[1])) necdsp.dataROM[n] = fp->readl(2);
+  }
+  if(auto fp = interface->open(ID::SuperFamicom, node["dram"]["name"].text(), File::Read)) {
+    for(auto n : range(size[2])) necdsp.dataRAM[n] = fp->readl(2);
+  }
+
+  for(auto leaf : node.find("map")) loadMap(leaf, {&NECDSP::read, &necdsp}, {&NECDSP::write, &necdsp});
+  for(auto leaf : node["dram"].find("map")) loadMap(leaf, {&NECDSP::readRAM, &necdsp}, {&NECDSP::writeRAM, &necdsp});
+}
+
+auto Cartridge::loadEpsonRTC(Markup::Node node) -> void {
+  has.EpsonRTC = true;
+
+  if(auto fp = interface->open(ID::SuperFamicom, node["ram"]["name"].text(), File::Read)) {
+    uint8 data[16] = {0};
+    for(auto& byte : data) fp->read();
+    epsonrtc.load(data);
+  }
+
+  for(auto leaf : node.find("map")) loadMap(leaf, {&EpsonRTC::read, &epsonrtc}, {&EpsonRTC::write, &epsonrtc});
+}
+
+auto Cartridge::loadSharpRTC(Markup::Node node) -> void {
+  has.SharpRTC = true;
+
+  if(auto fp = interface->open(ID::SuperFamicom, node["ram"]["name"].text(), File::Read)) {
+    uint8 data[16] = {0};
+    for(auto& byte : data) fp->read();
+    sharprtc.load(data);
+  }
+
+  for(auto leaf : node.find("map")) loadMap(leaf, {&SharpRTC::read, &sharprtc}, {&SharpRTC::write, &sharprtc});
+}
+
+auto Cartridge::loadSPC7110(Markup::Node node) -> void {
+  has.SPC7110 = true;
+
+  loadMemory(spc7110.prom, node["prom"], File::Required);
+  loadMemory(spc7110.drom, node["drom"], File::Required);
+  loadMemory(spc7110.ram, node["ram"], File::Optional);
+
+  for(auto leaf : node.find("map")) leaf.text() == "mcu"
+  ? loadMap(leaf, {&SPC7110::mcuromRead, &spc7110}, {&SPC7110::mcuromWrite, &spc7110})
+  : loadMap(leaf, {&SPC7110::read, &spc7110}, {&SPC7110::write, &spc7110});
+  for(auto leaf : node["ram"].find("map")) loadMap(leaf, {&SPC7110::mcuramRead, &spc7110}, {&SPC7110::mcuramWrite, &spc7110});
+}
+
+auto Cartridge::loadSDD1(Markup::Node node) -> void {
+  has.SDD1 = true;
+
+  loadMemory(sdd1.rom, node["rom"], File::Required);
+  loadMemory(sdd1.ram, node["ram"], File::Optional);
+
+  for(auto leaf : node.find("map")) loadMap(leaf, {&SDD1::read, &sdd1}, {&SDD1::write, &sdd1});
+  for(auto leaf : node["rom"].find("map")) loadMap(leaf, {&SDD1::mcuromRead, &sdd1}, {&SDD1::mcuromWrite, &sdd1});
+  for(auto leaf : node["ram"].find("map")) loadMap(leaf, {&SDD1::mcuramRead, &sdd1}, {&SDD1::mcuramWrite, &sdd1});
+}
+
+auto Cartridge::loadOBC1(Markup::Node node) -> void {
+  has.OBC1 = true;
+
+  loadMemory(obc1.ram, node["ram"], File::Optional);
+
+  for(auto leaf : node.find("map")) loadMap(leaf, {&OBC1::read, &obc1}, {&OBC1::write, &obc1});
+}
+
+auto Cartridge::loadMSU1(Markup::Node node) -> void {
+  has.MSU1 = true;
+
+  for(auto leaf : node.find("map")) loadMap(leaf, {&MSU1::readIO, &msu1}, {&MSU1::writeIO, &msu1});
+}
+
+//
+
+auto Cartridge::loadMemory(MappedRAM& ram, Markup::Node node, bool required, maybe<uint> id) -> void {
+  if(!id) id = pathID();
+  auto name = node["name"].text();
+  auto size = node["size"].natural();
+  ram.allocate(size);
+  if(auto fp = interface->open(id(), name, File::Read, required)) {
+    fp->read(ram.data(), ram.size());
+  }
+}
+
+auto Cartridge::loadMap(Markup::Node map, SuperFamicom::Memory& memory) -> void {
+  auto addr = map["address"].text();
+  auto size = map["size"].natural();
+  auto base = map["base"].natural();
+  auto mask = map["mask"].natural();
+  if(size == 0) size = memory.size();
+  if(size == 0) return;
+  bus.map({&SuperFamicom::Memory::read, &memory}, {&SuperFamicom::Memory::write, &memory}, addr, size, base, mask);
+}
+
+auto Cartridge::loadMap(
+  Markup::Node map,
+  const function<uint8 (uint24, uint8)>& reader,
+  const function<void (uint24, uint8)>& writer
+) -> void {
+  auto addr = map["address"].text();
+  auto size = map["size"].natural();
+  auto base = map["base"].natural();
+  auto mask = map["mask"].natural();
+  bus.map(reader, writer, addr, size, base, mask);
+}
diff --git a/nSide/higan/sfc-balanced/cartridge/save.cpp b/nSide/higan/sfc-balanced/cartridge/save.cpp
new file mode 100644
index 0000000..40993b6
--- /dev/null
+++ b/nSide/higan/sfc-balanced/cartridge/save.cpp
@@ -0,0 +1,135 @@
+auto Cartridge::saveCartridge(Markup::Node node) -> void {
+  auto board = node["board"];
+
+  if(auto node = board["ram"]) saveRAM(node);
+  if(auto node = board["mcc"]) saveMCC(node);
+  if(auto node = board["event"]) saveEvent(node);
+  if(auto node = board["sa1"]) saveSA1(node);
+  if(auto node = board["superfx"]) saveSuperFX(node);
+  if(auto node = board["armdsp"]) saveARMDSP(node);
+  if(auto node = board["hitachidsp"]) saveHitachiDSP(node);
+  if(auto node = board["necdsp"]) saveNECDSP(node);
+  if(auto node = board["epsonrtc"]) saveEpsonRTC(node);
+  if(auto node = board["sharprtc"]) saveSharpRTC(node);
+  if(auto node = board["spc7110"]) saveSPC7110(node);
+  if(auto node = board["sdd1"]) saveSDD1(node);
+  if(auto node = board["obc1"]) saveOBC1(node);
+}
+
+auto Cartridge::saveGameBoy(Markup::Node node) -> void {
+}
+
+auto Cartridge::saveBSMemory(Markup::Node node) -> void {
+}
+
+auto Cartridge::saveSufamiTurboA(Markup::Node node) -> void {
+  saveMemory(sufamiturboA.ram, node["board/ram"], sufamiturboA.pathID);
+}
+
+auto Cartridge::saveSufamiTurboB(Markup::Node node) -> void {
+  saveMemory(sufamiturboB.ram, node["board/ram"], sufamiturboB.pathID);
+}
+
+//
+
+auto Cartridge::saveRAM(Markup::Node node) -> void {
+  saveMemory(ram, node);
+}
+
+auto Cartridge::saveMCC(Markup::Node node) -> void {
+  saveMemory(mcc.ram, node["ram"]);
+}
+
+auto Cartridge::saveEvent(Markup::Node node) -> void {
+  saveMemory(event.ram, node["ram"]);
+}
+
+auto Cartridge::saveSA1(Markup::Node node) -> void {
+  saveMemory(sa1.bwram, node["bwram"]);
+  saveMemory(sa1.iram, node["iram"]);
+}
+
+auto Cartridge::saveSuperFX(Markup::Node node) -> void {
+  saveMemory(superfx.ram, node["ram"]);
+}
+
+auto Cartridge::saveARMDSP(Markup::Node node) -> void {
+  if(!node["ram/volatile"]) {
+    if(auto name = node["ram/name"].text()) {
+      if(auto fp = interface->open(ID::SuperFamicom, name, File::Write)) {
+        for(auto n : range(16 * 1024)) fp->write(armdsp.programRAM[n]);
+      }
+    }
+  }
+}
+
+auto Cartridge::saveHitachiDSP(Markup::Node node) -> void {
+  saveMemory(hitachidsp.ram, node["ram"]);
+
+  if(!node["dram/volatile"]) {
+    if(auto name = node["dram/name"].text()) {
+      if(auto fp = interface->open(ID::SuperFamicom, name, File::Write)) {
+        for(auto n : range(3 * 1024)) fp->write(hitachidsp.dataRAM[n]);
+      }
+    }
+  }
+}
+
+auto Cartridge::saveNECDSP(Markup::Node node) -> void {
+  if(!node["dram/volatile"]) {
+    uint size = necdsp.revision == NECDSP::Revision::uPD7725 ? 256 : 2048;
+    if(auto name = node["dram/name"].text()) {
+      if(auto fp = interface->open(ID::SuperFamicom, name, File::Write)) {
+        for(auto n : range(size)) fp->writel(necdsp.dataRAM[n], 2);
+      }
+    }
+  }
+}
+
+auto Cartridge::saveEpsonRTC(Markup::Node node) -> void {
+  if(!node["ram/volatile"]) {
+    if(auto name = node["ram/name"].text()) {
+      if(auto fp = interface->open(ID::SuperFamicom, name, File::Write)) {
+        uint8 data[16] = {0};
+        epsonrtc.save(data);
+        fp->write(data, 16);
+      }
+    }
+  }
+}
+
+auto Cartridge::saveSharpRTC(Markup::Node node) -> void {
+  if(!node["ram/volatile"]) {
+    if(auto name = node["ram/name"].text()) {
+      if(auto fp = interface->open(ID::SuperFamicom, name, File::Write)) {
+        uint8 data[16] = {0};
+        sharprtc.save(data);
+        fp->write(data, 16);
+      }
+    }
+  }
+}
+
+auto Cartridge::saveSPC7110(Markup::Node node) -> void {
+  saveMemory(spc7110.ram, node["ram"]);
+}
+
+auto Cartridge::saveSDD1(Markup::Node node) -> void {
+  saveMemory(sdd1.ram, node["ram"]);
+}
+
+auto Cartridge::saveOBC1(Markup::Node node) -> void {
+  saveMemory(obc1.ram, node["ram"]);
+}
+
+//
+
+auto Cartridge::saveMemory(MappedRAM& memory, Markup::Node node, maybe<uint> id) -> void {
+  if(!id) id = pathID();
+  if(!node || node["volatile"]) return;
+  auto name = node["name"].text();
+  auto size = node["size"].natural();
+  if(auto fp = interface->open(id(), name, File::Write)) {
+    fp->write(memory.data(), memory.size());
+  }
+}
diff --git a/nSide/higan/sfc-balanced/cartridge/serialization.cpp b/nSide/higan/sfc-balanced/cartridge/serialization.cpp
new file mode 100644
index 0000000..1509ab4
--- /dev/null
+++ b/nSide/higan/sfc-balanced/cartridge/serialization.cpp
@@ -0,0 +1,3 @@
+auto Cartridge::serialize(serializer& s) -> void {
+  s.array(ram.data(), ram.size());
+}
diff --git a/nSide/higan/sfc-balanced/controller/controller.cpp b/nSide/higan/sfc-balanced/controller/controller.cpp
new file mode 100644
index 0000000..51a91f6
--- /dev/null
+++ b/nSide/higan/sfc-balanced/controller/controller.cpp
@@ -0,0 +1,46 @@
+#include <sfc-balanced/sfc.hpp>
+
+namespace SuperFamicom {
+
+#include "gamepad/gamepad.cpp"
+#include "mouse/mouse.cpp"
+#include "super-multitap/super-multitap.cpp"
+#include "super-scope/super-scope.cpp"
+#include "justifier/justifier.cpp"
+
+Controller::Controller(bool port) : port(port) {
+  if(!handle()) create(Controller::Enter, 1);
+}
+
+Controller::~Controller() {
+  scheduler.remove(*this);
+}
+
+auto Controller::Enter() -> void {
+  while(true) {
+    scheduler.synchronize();
+    if(peripherals.controllerPort1->active()) peripherals.controllerPort1->main();
+    if(peripherals.controllerPort2->active()) peripherals.controllerPort2->main();
+  }
+}
+
+auto Controller::main() -> void {
+  step(1);
+  synchronize(cpu);
+}
+
+auto Controller::iobit() -> bool {
+  switch(port) {
+  case Controller::Port1: return cpu.pio() & 0x40;
+  case Controller::Port2: return cpu.pio() & 0x80;
+  }
+}
+
+auto Controller::iobit(bool data) -> void {
+  switch(port) {
+  case Controller::Port1: bus.write(0x4201, (cpu.pio() & ~0x40) | (data << 6)); break;
+  case Controller::Port2: bus.write(0x4201, (cpu.pio() & ~0x80) | (data << 7)); break;
+  }
+}
+
+}
diff --git a/nSide/higan/sfc-balanced/controller/controller.hpp b/nSide/higan/sfc-balanced/controller/controller.hpp
new file mode 100644
index 0000000..6c18e2d
--- /dev/null
+++ b/nSide/higan/sfc-balanced/controller/controller.hpp
@@ -0,0 +1,34 @@
+// SNES controller port pinout:
+//  -------------------------------
+// | (1) (2) (3) (4) | (5) (6) (7) )
+//  -------------------------------
+// pin    name     port1                            port2
+//  1:    +5v
+//  2:    clock    $4016 read                       $4017 read
+//  3:    latch    $4016.d0 write                   $4016.d0 write
+//  4:    data1    $4016.d0 read                    $4017.d0 read
+//  5:    data2    $4016.d1 read                    $4017.d1 read
+//  6:    iobit    $4201.d6 write; $4213.d6 read    $4201.d7 write; $4213.d7 read
+//  7:    gnd
+
+struct Controller : Thread {
+  enum : bool { Port1 = 0, Port2 = 1 };
+
+  Controller(bool port);
+  virtual ~Controller();
+  static auto Enter() -> void;
+
+  virtual auto main() -> void;
+  auto iobit() -> bool;
+  auto iobit(bool data) -> void;
+  virtual auto data() -> uint2 { return 0; }
+  virtual auto latch(bool data) -> void {}
+
+  const bool port;
+};
+
+#include "gamepad/gamepad.hpp"
+#include "mouse/mouse.hpp"
+#include "super-multitap/super-multitap.hpp"
+#include "super-scope/super-scope.hpp"
+#include "justifier/justifier.hpp"
diff --git a/nSide/higan/sfc-balanced/controller/gamepad/gamepad.cpp b/nSide/higan/sfc-balanced/controller/gamepad/gamepad.cpp
new file mode 100644
index 0000000..9505782
--- /dev/null
+++ b/nSide/higan/sfc-balanced/controller/gamepad/gamepad.cpp
@@ -0,0 +1,48 @@
+Gamepad::Gamepad(bool port) : Controller(port) {
+  latched = 0;
+  counter = 0;
+}
+
+auto Gamepad::data() -> uint2 {
+  if(counter >= 16) return 1;
+  if(latched == 1) return interface->inputPoll(port, ID::Device::Gamepad, B);
+
+  //note: D-pad physically prevents up+down and left+right from being pressed at the same time
+  switch(counter++) {
+  case  0: return b;
+  case  1: return y;
+  case  2: return select;
+  case  3: return start;
+  case  4: return up & !down;
+  case  5: return down & !up;
+  case  6: return left & !right;
+  case  7: return right & !left;
+  case  8: return a;
+  case  9: return x;
+  case 10: return l;
+  case 11: return r;
+  }
+
+  return 0;  //12-15: signature
+}
+
+auto Gamepad::latch(bool data) -> void {
+  if(latched == data) return;
+  latched = data;
+  counter = 0;
+
+  if(latched == 0) {
+    b      = interface->inputPoll(port, ID::Device::Gamepad, B);
+    y      = interface->inputPoll(port, ID::Device::Gamepad, Y);
+    select = interface->inputPoll(port, ID::Device::Gamepad, Select);
+    start  = interface->inputPoll(port, ID::Device::Gamepad, Start);
+    up     = interface->inputPoll(port, ID::Device::Gamepad, Up);
+    down   = interface->inputPoll(port, ID::Device::Gamepad, Down);
+    left   = interface->inputPoll(port, ID::Device::Gamepad, Left);
+    right  = interface->inputPoll(port, ID::Device::Gamepad, Right);
+    a      = interface->inputPoll(port, ID::Device::Gamepad, A);
+    x      = interface->inputPoll(port, ID::Device::Gamepad, X);
+    l      = interface->inputPoll(port, ID::Device::Gamepad, L);
+    r      = interface->inputPoll(port, ID::Device::Gamepad, R);
+  }
+}
diff --git a/nSide/higan/sfc-balanced/controller/gamepad/gamepad.hpp b/nSide/higan/sfc-balanced/controller/gamepad/gamepad.hpp
new file mode 100644
index 0000000..f96808a
--- /dev/null
+++ b/nSide/higan/sfc-balanced/controller/gamepad/gamepad.hpp
@@ -0,0 +1,18 @@
+struct Gamepad : Controller {
+  enum : uint {
+    Up, Down, Left, Right, B, A, Y, X, L, R, Select, Start,
+  };
+
+  Gamepad(bool port);
+
+  auto data() -> uint2;
+  auto latch(bool data) -> void;
+
+private:
+  bool latched;
+  uint counter;
+
+  boolean b, y, select, start;
+  boolean up, down, left, right;
+  boolean a, x, l, r;
+};
diff --git a/nSide/higan/sfc-balanced/controller/justifier/justifier.cpp b/nSide/higan/sfc-balanced/controller/justifier/justifier.cpp
new file mode 100644
index 0000000..520c72b
--- /dev/null
+++ b/nSide/higan/sfc-balanced/controller/justifier/justifier.cpp
@@ -0,0 +1,140 @@
+Justifier::Justifier(bool port, bool chained):
+Controller(port),
+chained(chained),
+device(!chained ? ID::Device::Justifier : ID::Device::Justifiers)
+{
+  create(Controller::Enter, 21'477'272);
+  latched = 0;
+  counter = 0;
+  active = 0;
+  prev = 0;
+
+  player1.sprite = Emulator::video.createSprite(32, 32);
+  player1.sprite->setPixels(Resource::Sprite::CrosshairBlue);
+  player1.x = 256 / 2;
+  player1.y = 240 / 2;
+  player1.trigger = false;
+  player2.start = false;
+
+  player2.sprite = Emulator::video.createSprite(32, 32);
+  player2.sprite->setPixels(Resource::Sprite::CrosshairRed);
+  player2.x = 256 / 2;
+  player2.y = 240 / 2;
+  player2.trigger = false;
+  player2.start = false;
+
+  if(chained == false) {
+    player2.x = -1;
+    player2.y = -1;
+  } else {
+    player1.x -= 16;
+    player2.x += 16;
+  }
+}
+
+Justifier::~Justifier() {
+  Emulator::video.removeSprite(player1.sprite);
+  Emulator::video.removeSprite(player2.sprite);
+}
+
+auto Justifier::main() -> void {
+  uint next = cpu.vcounter() * 1364 + cpu.hcounter();
+
+  int x = (active == 0 ? player1.x : player2.x), y = (active == 0 ? player1.y : player2.y);
+  bool offscreen = (x < 0 || y < 0 || x >= 256 || y >= ppu.vdisp());
+
+  if(!offscreen) {
+    uint target = y * 1364 + (x + 24) * 4;
+    if(next >= target && prev < target) {
+      //CRT raster detected, toggle iobit to latch counters
+      iobit(0);
+      iobit(1);
+    }
+  }
+
+  if(next < prev) {
+    int nx1 = interface->inputPoll(port, device, 0 + X);
+    int ny1 = interface->inputPoll(port, device, 0 + Y);
+    nx1 += player1.x;
+    ny1 += player1.y;
+    player1.x = max(-16, min(256 + 16, nx1));
+    player1.y = max(-16, min(240 + 16, ny1));
+    player1.sprite->setPosition(player1.x * 2 - 16, player1.y * 2 - 16);
+    player1.sprite->setVisible(true);
+  }
+
+  if(next < prev && chained) {
+    int nx2 = interface->inputPoll(port, device, 4 + X);
+    int ny2 = interface->inputPoll(port, device, 4 + Y);
+    nx2 += player2.x;
+    ny2 += player2.y;
+    player2.x = max(-16, min(256 + 16, nx2));
+    player2.y = max(-16, min(240 + 16, ny2));
+    player2.sprite->setPosition(player2.x * 2 - 16, player2.y * 2 - 16);
+    player2.sprite->setVisible(true);
+  }
+
+  prev = next;
+  step(2);
+  synchronize(cpu);
+}
+
+auto Justifier::data() -> uint2 {
+  if(counter >= 32) return 1;
+
+  if(counter == 0) {
+    player1.trigger = interface->inputPoll(port, device, 0 + Trigger);
+    player1.start   = interface->inputPoll(port, device, 0 + Start);
+  }
+
+  if(counter == 0 && chained) {
+    player2.trigger = interface->inputPoll(port, device, 4 + Trigger);
+    player2.start   = interface->inputPoll(port, device, 4 + Start);
+  }
+
+  switch(counter++) {
+  case  0: return 0;
+  case  1: return 0;
+  case  2: return 0;
+  case  3: return 0;
+  case  4: return 0;
+  case  5: return 0;
+  case  6: return 0;
+  case  7: return 0;
+  case  8: return 0;
+  case  9: return 0;
+  case 10: return 0;
+  case 11: return 0;
+
+  case 12: return 1;  //signature
+  case 13: return 1;  // ||
+  case 14: return 1;  // ||
+  case 15: return 0;  // ||
+
+  case 16: return 0;
+  case 17: return 1;
+  case 18: return 0;
+  case 19: return 1;
+  case 20: return 0;
+  case 21: return 1;
+  case 22: return 0;
+  case 23: return 1;
+
+  case 24: return player1.trigger;
+  case 25: return player2.trigger;
+  case 26: return player1.start;
+  case 27: return player2.start;
+  case 28: return active;
+
+  case 29: return 0;
+  case 30: return 0;
+  case 31: return 0;
+  }
+}
+
+auto Justifier::latch(bool data) -> void {
+  if(latched == data) return;
+  latched = data;
+  counter = 0;
+  if(latched == 0) active = !active;  //toggle between both controllers, even when unchained
+}
diff --git a/nSide/higan/sfc-balanced/controller/justifier/justifier.hpp b/nSide/higan/sfc-balanced/controller/justifier/justifier.hpp
new file mode 100644
index 0000000..6b99b10
--- /dev/null
+++ b/nSide/higan/sfc-balanced/controller/justifier/justifier.hpp
@@ -0,0 +1,28 @@
+struct Justifier : Controller {
+  enum : uint {
+    X, Y, Trigger, Start,
+  };
+
+  Justifier(bool port, bool chained);
+  ~Justifier();
+
+  auto main() -> void;
+  auto data() -> uint2;
+  auto latch(bool data) -> void;
+
+//private:
+  const bool chained;  //true if the second justifier is attached to the first
+  const uint device;
+  bool latched;
+  uint counter;
+  uint prev;
+
+  bool active;
+  struct Player {
+    shared_pointer<Emulator::Sprite> sprite;
+    int x;
+    int y;
+    bool trigger;
+    bool start;
+  } player1, player2;
+};
diff --git a/nSide/higan/sfc-balanced/controller/mouse/mouse.cpp b/nSide/higan/sfc-balanced/controller/mouse/mouse.cpp
new file mode 100644
index 0000000..f9a3f59
--- /dev/null
+++ b/nSide/higan/sfc-balanced/controller/mouse/mouse.cpp
@@ -0,0 +1,86 @@
+Mouse::Mouse(bool port) : Controller(port) {
+  latched = 0;
+  counter = 0;
+
+  speed = 0;
+  x = 0;
+  y = 0;
+  dx = 0;
+  dy = 0;
+  l = 0;
+  r = 0;
+}
+
+auto Mouse::data() -> uint2 {
+  if(latched == 1) {
+    speed = (speed + 1) % 3;
+    return 0;
+  }
+
+  if(counter >= 32) return 1;
+
+  switch(counter++) { default:
+  case  0: return 0;
+  case  1: return 0;
+  case  2: return 0;
+  case  3: return 0;
+  case  4: return 0;
+  case  5: return 0;
+  case  6: return 0;
+  case  7: return 0;
+
+  case  8: return r;
+  case  9: return l;
+  case 10: return (speed >> 1) & 1;
+  case 11: return (speed >> 0) & 1;
+
+  case 12: return 0;  //signature
+  case 13: return 0;  // ||
+  case 14: return 0;  // ||
+  case 15: return 1;  // ||
+
+  case 16: return dy;
+  case 17: return (y >> 6) & 1;
+  case 18: return (y >> 5) & 1;
+  case 19: return (y >> 4) & 1;
+  case 20: return (y >> 3) & 1;
+  case 21: return (y >> 2) & 1;
+  case 22: return (y >> 1) & 1;
+  case 23: return (y >> 0) & 1;
+
+  case 24: return dx;
+  case 25: return (x >> 6) & 1;
+  case 26: return (x >> 5) & 1;
+  case 27: return (x >> 4) & 1;
+  case 28: return (x >> 3) & 1;
+  case 29: return (x >> 2) & 1;
+  case 30: return (x >> 1) & 1;
+  case 31: return (x >> 0) & 1;
+  }
+}
+
+auto Mouse::latch(bool data) -> void {
+  if(latched == data) return;
+  latched = data;
+  counter = 0;
+
+  x = interface->inputPoll(port, ID::Device::Mouse, X);  //-n = left, 0 = center, +n = right
+  y = interface->inputPoll(port, ID::Device::Mouse, Y);  //-n = up,   0 = center, +n = down
+  l = interface->inputPoll(port, ID::Device::Mouse, Left);
+  r = interface->inputPoll(port, ID::Device::Mouse, Right);
+
+  dx = x < 0;  //0 = right, 1 = left
+  dy = y < 0;  //0 = down,  1 = up
+
+  if(x < 0) x = -x;  //abs(position_x)
+  if(y < 0) y = -y;  //abs(position_y)
+
+  double multiplier = 1.0;
+  if(speed == 1) multiplier = 1.5;
+  if(speed == 2) multiplier = 2.0;
+  x = (double)x * multiplier;
+  y = (double)y * multiplier;
+
+  x = min(127, x);
+  y = min(127, y);
+}
diff --git a/nSide/higan/sfc-balanced/controller/mouse/mouse.hpp b/nSide/higan/sfc-balanced/controller/mouse/mouse.hpp
new file mode 100644
index 0000000..2ab71a5
--- /dev/null
+++ b/nSide/higan/sfc-balanced/controller/mouse/mouse.hpp
@@ -0,0 +1,22 @@
+struct Mouse : Controller {
+  enum : uint {
+    X, Y, Left, Right,
+  };
+
+  Mouse(bool port);
+
+  auto data() -> uint2;
+  auto latch(bool data) -> void;
+
+private:
+  bool latched;
+  uint counter;
+
+  uint speed;  //0 = slow, 1 = normal, 2 = fast
+  int  x;      //x-coordinate
+  int  y;      //y-coordinate
+  bool dx;     //x-direction
+  bool dy;     //y-direction
+  bool l;      //left button
+  bool r;      //right button
+};
diff --git a/nSide/higan/sfc-balanced/controller/super-multitap/super-multitap.cpp b/nSide/higan/sfc-balanced/controller/super-multitap/super-multitap.cpp
new file mode 100644
index 0000000..b24f9df
--- /dev/null
+++ b/nSide/higan/sfc-balanced/controller/super-multitap/super-multitap.cpp
@@ -0,0 +1,70 @@
+SuperMultitap::SuperMultitap(bool port) : Controller(port) {
+  latched = 0;
+  counter1 = 0;
+  counter2 = 0;
+}
+
+auto SuperMultitap::data() -> uint2 {
+  if(latched) return 2;  //device detection
+  uint counter, a, b;
+
+  if(iobit()) {
+    counter = counter1;
+    if(counter >= 16) return 3;
+    counter1++;
+    if(counter >= 12) return 0;
+    a = 0;  //controller 2
+    b = 1;  //controller 3
+  } else {
+    counter = counter2;
+    if(counter >= 16) return 3;
+    counter2++;
+    if(counter >= 12) return 0;
+    a = 2;  //controller 4
+    b = 3;  //controller 5
+  }
+
+  auto& A = gamepads[a];
+  auto& B = gamepads[b];
+
+  switch(counter) {
+  case  0: return A.b << 0 | B.b << 1;
+  case  1: return A.y << 0 | B.y << 1;
+  case  2: return A.select << 0 | B.select << 1;
+  case  3: return A.start << 0 | B.start << 1;
+  case  4: return (A.up & !A.down) << 0 | (B.up & !B.down) << 1;
+  case  5: return (A.down & !A.up) << 0 | (B.down & !B.up) << 1;
+  case  6: return (A.left & !A.right) << 0 | (B.left & !B.right) << 1;
+  case  7: return (A.right & !A.left) << 0 | (B.right & !B.left) << 1;
+  case  8: return A.a << 0 | B.a << 1;
+  case  9: return A.x << 0 | B.x << 1;
+  case 10: return A.l << 0 | B.l << 1;
+  case 11: return A.r << 0 | B.r << 1;
+  }
+  unreachable;
+}
+
+auto SuperMultitap::latch(bool data) -> void {
+  if(latched == data) return;
+  latched = data;
+  counter1 = 0;
+  counter2 = 0;
+
+  if(latched == 0) {
+    for(uint id : range(4)) {
+      auto& gamepad = gamepads[id];
+      gamepad.b      = interface->inputPoll(port, ID::Device::SuperMultitap, id * 12 + B);
+      gamepad.y      = interface->inputPoll(port, ID::Device::SuperMultitap, id * 12 + Y);
+      gamepad.select = interface->inputPoll(port, ID::Device::SuperMultitap, id * 12 + Select);
+      gamepad.start  = interface->inputPoll(port, ID::Device::SuperMultitap, id * 12 + Start);
+      gamepad.up     = interface->inputPoll(port, ID::Device::SuperMultitap, id * 12 + Up);
+      gamepad.down   = interface->inputPoll(port, ID::Device::SuperMultitap, id * 12 + Down);
+      gamepad.left   = interface->inputPoll(port, ID::Device::SuperMultitap, id * 12 + Left);
+      gamepad.right  = interface->inputPoll(port, ID::Device::SuperMultitap, id * 12 + Right);
+      gamepad.a      = interface->inputPoll(port, ID::Device::SuperMultitap, id * 12 + A);
+      gamepad.x      = interface->inputPoll(port, ID::Device::SuperMultitap, id * 12 + X);
+      gamepad.l      = interface->inputPoll(port, ID::Device::SuperMultitap, id * 12 + L);
+      gamepad.r      = interface->inputPoll(port, ID::Device::SuperMultitap, id * 12 + R);
+    }
+  }
+}
diff --git a/nSide/higan/sfc-balanced/controller/super-multitap/super-multitap.hpp b/nSide/higan/sfc-balanced/controller/super-multitap/super-multitap.hpp
new file mode 100644
index 0000000..f49dfc2
--- /dev/null
+++ b/nSide/higan/sfc-balanced/controller/super-multitap/super-multitap.hpp
@@ -0,0 +1,21 @@
+struct SuperMultitap : Controller {
+  enum : uint {
+    Up, Down, Left, Right, B, A, Y, X, L, R, Select, Start,
+  };
+
+  SuperMultitap(bool port);
+
+  auto data() -> uint2;
+  auto latch(bool data) -> void;
+
+private:
+  bool latched;
+  uint counter1;
+  uint counter2;
+
+  struct Gamepad {
+    boolean b, y, select, start;
+    boolean up, down, left, right;
+    boolean a, x, l, r;
+  } gamepads[4];
+};
diff --git a/nSide/higan/sfc-balanced/controller/super-scope/super-scope.cpp b/nSide/higan/sfc-balanced/controller/super-scope/super-scope.cpp
new file mode 100644
index 0000000..a66aa47
--- /dev/null
+++ b/nSide/higan/sfc-balanced/controller/super-scope/super-scope.cpp
@@ -0,0 +1,127 @@
+//The Super Scope is a light-gun: it detects the CRT beam cannon position,
+//and latches the counters by toggling iobit. This only works on controller
+//port 2, as iobit there is connected to the PPU H/V counter latch.
+//(PIO $4201.d7)
+
+//It is obviously not possible to perfectly simulate an IR light detecting
+//a CRT beam cannon, hence this class will read the PPU raster counters.
+
+//A Super Scope can still technically be used in port 1, however it would
+//require manual polling of PIO ($4201.d6) to determine when iobit was written.
+//Note that no commercial game ever utilizes a Super Scope in port 1.
+
+SuperScope::SuperScope(bool port) : Controller(port) {
+  create(Controller::Enter, 21'477'272);
+  sprite = Emulator::video.createSprite(32, 32);
+  sprite->setPixels(Resource::Sprite::CrosshairGreen);
+
+  latched = 0;
+  counter = 0;
+
+  //center cursor onscreen
+  x = 256 / 2;
+  y = 240 / 2;
+
+  trigger   = false;
+  cursor    = false;
+  turbo     = false;
+  pause     = false;
+  offscreen = false;
+
+  oldturbo    = false;
+  triggerlock = false;
+  pauselock   = false;
+
+  prev = 0;
+}
+
+SuperScope::~SuperScope() {
+  Emulator::video.removeSprite(sprite);
+}
+
+auto SuperScope::main() -> void {
+  uint next = cpu.vcounter() * 1364 + cpu.hcounter();
+
+  if(!offscreen) {
+    uint target = y * 1364 + (x + 24) * 4;
+    if(next >= target && prev < target) {
+      //CRT raster detected, toggle iobit to latch counters
+      iobit(0);
+      iobit(1);
+    }
+  }
+
+  if(next < prev) {
+    //Vcounter wrapped back to zero; update cursor coordinates for start of new frame
+    int nx = interface->inputPoll(port, ID::Device::SuperScope, X);
+    int ny = interface->inputPoll(port, ID::Device::SuperScope, Y);
+    nx += x;
+    ny += y;
+    x = max(-16, min(256 + 16, nx));
+    y = max(-16, min(240 + 16, ny));
+    offscreen = (x < 0 || y < 0 || x >= 256 || y >= ppu.vdisp());
+    sprite->setPosition(x * 2 - 16, y * 2 - 16);
+    sprite->setVisible(true);
+  }
+
+  prev = next;
+  step(2);
+  synchronize(cpu);
+}
+
+auto SuperScope::data() -> uint2 {
+  if(counter >= 8) return 1;
+
+  if(counter == 0) {
+    //turbo is a switch; toggle is edge sensitive
+    bool newturbo = interface->inputPoll(port, ID::Device::SuperScope, Turbo);
+    if(newturbo && !oldturbo) {
+      turbo = !turbo;  //toggle state
+      sprite->setPixels(turbo ? Resource::Sprite::CrosshairTurbo : Resource::Sprite::CrosshairGreen);
+    }
+    oldturbo = newturbo;
+
+    //trigger is a button
+    //if turbo is active, trigger is level sensitive; otherwise, it is edge sensitive
+    trigger = false;
+    bool newtrigger = interface->inputPoll(port, ID::Device::SuperScope, Trigger);
+    if(newtrigger && (turbo || !triggerlock)) {
+      trigger = true;
+      triggerlock = true;
+    } else if(!newtrigger) {
+      triggerlock = false;
+    }
+
+    //cursor is a button; it is always level sensitive
+    cursor = interface->inputPoll(port, ID::Device::SuperScope, Cursor);
+
+    //pause is a button; it is always edge sensitive
+    pause = false;
+    bool newpause = interface->inputPoll(port, ID::Device::SuperScope, Pause);
+    if(newpause && !pauselock) {
+      pause = true;
+      pauselock = true;
+    } else if(!newpause) {
+      pauselock = false;
+    }
+
+    offscreen = (x < 0 || y < 0 || x >= 256 || y >= ppu.vdisp());
+  }
+
+  switch(counter++) {
+  case 0: return offscreen ? 0 : trigger;
+  case 1: return cursor;
+  case 2: return turbo;
+  case 3: return pause;
+  case 4: return 0;
+  case 5: return 0;
+  case 6: return offscreen;
+  case 7: return 0;  //noise (1 = yes)
+  }
+}
+
+auto SuperScope::latch(bool data) -> void {
+  if(latched == data) return;
+  latched = data;
+  counter = 0;
+}
diff --git a/nSide/higan/sfc-balanced/controller/super-scope/super-scope.hpp b/nSide/higan/sfc-balanced/controller/super-scope/super-scope.hpp
new file mode 100644
index 0000000..bcf467b
--- /dev/null
+++ b/nSide/higan/sfc-balanced/controller/super-scope/super-scope.hpp
@@ -0,0 +1,33 @@
+struct SuperScope : Controller {
+  shared_pointer<Emulator::Sprite> sprite;
+
+  enum : uint {
+    X, Y, Trigger, Cursor, Turbo, Pause,
+  };
+
+  SuperScope(bool port);
+  ~SuperScope();
+
+  auto main() -> void;
+  auto data() -> uint2;
+  auto latch(bool data) -> void;
+
+private:
+  bool latched;
+  uint counter;
+
+  int x;
+  int y;
+
+  bool trigger;
+  bool cursor;
+  bool turbo;
+  bool pause;
+  bool offscreen;
+
+  bool oldturbo;
+  bool triggerlock;
+  bool pauselock;
+
+  uint prev;
+};
diff --git a/nSide/higan/sfc-balanced/coprocessor/armdsp/armdsp.cpp b/nSide/higan/sfc-balanced/coprocessor/armdsp/armdsp.cpp
new file mode 100644
index 0000000..2ed5fcd
--- /dev/null
+++ b/nSide/higan/sfc-balanced/coprocessor/armdsp/armdsp.cpp
@@ -0,0 +1,132 @@
+#include <sfc-balanced/sfc.hpp>
+
+namespace SuperFamicom {
+
+#include "memory.cpp"
+#include "serialization.cpp"
+ArmDSP armdsp;
+
+ArmDSP::ArmDSP() {
+  programROM = new uint8[128 * 1024];
+  dataROM = new uint8[32 * 1024];
+  programRAM = new uint8[16 * 1024];
+}
+
+ArmDSP::~ArmDSP() {
+  delete[] programROM;
+  delete[] dataROM;
+  delete[] programRAM;
+}
+
+auto ArmDSP::Enter() -> void {
+  armdsp.boot();
+  while(true) scheduler.synchronize(), armdsp.main();
+}
+
+auto ArmDSP::boot() -> void {
+  //reset hold delay
+  while(bridge.reset) {
+    step(1);
+    continue;
+  }
+
+  //reset sequence delay
+  if(bridge.ready == false) {
+    step(65'536);
+    bridge.ready = true;
+  }
+}
+
+auto ArmDSP::main() -> void {
+  if(crash) {
+    print(disassembleRegisters(), "\n");
+    print(disassembleInstructionARM(pipeline.execute.address), "\n");
+    print("Executed: ", instructions, "\n");
+    while(true) step(21'477'272);
+  }
+
+  stepARM();
+}
+
+auto ArmDSP::step(uint clocks) -> void {
+  if(bridge.timer && --bridge.timer == 0);
+  Thread::step(clocks);
+  synchronize(cpu);
+}
+
+//MMIO: 00-3f,80-bf:3800-38ff
+//3800-3807 mirrored throughout
+//a0 ignored
+
+auto ArmDSP::read(uint24 addr, uint8) -> uint8 {
+  cpu.synchronize(*this);
+
+  uint8 data = 0x00;
+  addr &= 0xff06;
+
+  if(addr == 0x3800) {
+    if(bridge.armtocpu.ready) {
+      bridge.armtocpu.ready = false;
+      data = bridge.armtocpu.data;
+    }
+  }
+
+  if(addr == 0x3802) {
+    bridge.signal = false;
+  }
+
+  if(addr == 0x3804) {
+    data = bridge.status();
+  }
+
+  return data;
+}
+
+auto ArmDSP::write(uint24 addr, uint8 data) -> void {
+  cpu.synchronize(*this);
+
+  addr &= 0xff06;
+
+  if(addr == 0x3802) {
+    bridge.cputoarm.ready = true;
+    bridge.cputoarm.data = data;
+  }
+
+  if(addr == 0x3804) {
+    data &= 1;
+    if(!bridge.reset && data) resetARM();
+    bridge.reset = data;
+  }
+}
+
+auto ArmDSP::init() -> void {
+}
+
+auto ArmDSP::load() -> void {
+}
+
+auto ArmDSP::unload() -> void {
+}
+
+auto ArmDSP::power() -> void {
+  for(auto n : range(16 * 1024)) programRAM[n] = random(0x00);
+}
+
+auto ArmDSP::reset() -> void {
+  bridge.reset = false;
+  resetARM();
+}
+
+auto ArmDSP::resetARM() -> void {
+  create(ArmDSP::Enter, 21'477'272);
+  ARM::power();
+
+  bridge.ready = false;
+  bridge.signal = false;
+  bridge.timer = 0;
+  bridge.timerlatch = 0;
+  bridge.cputoarm.ready = false;
+  bridge.armtocpu.ready = false;
+}
+
+}
diff --git a/nSide/higan/sfc-balanced/coprocessor/armdsp/armdsp.hpp b/nSide/higan/sfc-balanced/coprocessor/armdsp/armdsp.hpp
new file mode 100644
index 0000000..68d71bb
--- /dev/null
+++ b/nSide/higan/sfc-balanced/coprocessor/armdsp/armdsp.hpp
@@ -0,0 +1,36 @@
+//ARMv3 (ARM60)
+
+struct ArmDSP : Processor::ARM, Thread {
+  #include "registers.hpp"
+
+  ArmDSP();
+  ~ArmDSP();
+
+  static auto Enter() -> void;
+  auto boot() -> void;
+  auto main() -> void;
+
+  auto step(uint clocks) -> void override;
+  auto _idle() -> void override;
+  auto _read(uint mode, uint32 addr) -> uint32 override;
+  auto _write(uint mode, uint32 addr, uint32 word) -> void override;
+
+  auto read(uint24 addr, uint8 data) -> uint8;
+  auto write(uint24 addr, uint8 data) -> void;
+
+  auto init() -> void;
+  auto load() -> void;
+  auto unload() -> void;
+  auto power() -> void;
+  auto reset() -> void;
+  auto resetARM() -> void;
+
+  auto firmware() const -> nall::vector<uint8>;
+  auto serialize(serializer&) -> void;
+
+  uint8* programROM;
+  uint8* dataROM;
+  uint8* programRAM;
+};
+
+extern ArmDSP armdsp;
diff --git a/nSide/higan/sfc-balanced/coprocessor/armdsp/memory.cpp b/nSide/higan/sfc-balanced/coprocessor/armdsp/memory.cpp
new file mode 100644
index 0000000..ceb0d4e
--- /dev/null
+++ b/nSide/higan/sfc-balanced/coprocessor/armdsp/memory.cpp
@@ -0,0 +1,91 @@
+//note: timings are completely unverified
+//due to the ST018 chip design (on-die ROM), testing is nearly impossible
+
+auto ArmDSP::_idle() -> void {
+  step(1);
+}
+
+auto ArmDSP::_read(uint mode, uint32 addr) -> uint32 {
+  step(1);
+
+  static auto memory = [&](const uint8* memory, uint mode, uint32 addr) -> uint32 {
+    if(mode & Word) {
+      memory += addr & ~3;
+      return memory[0] << 0 | memory[1] << 8 | memory[2] << 16 | memory[3] << 24;
+    } else if(mode & Byte) {
+      return memory[addr];
+    } else {
+      return 0;  //should never occur
+    }
+  };
+
+  switch(addr & 0xe000'0000) {
+  case 0x0000'0000: return memory(programROM, mode, addr & 0x1ffff);
+  case 0x2000'0000: return pipeline.fetch.instruction;
+  case 0x4000'0000: break;
+  case 0x6000'0000: return 0x40404001;
+  case 0x8000'0000: return pipeline.fetch.instruction;
+  case 0xa000'0000: return memory(dataROM, mode, addr & 0x7fff);
+  case 0xc000'0000: return pipeline.fetch.instruction;
+  case 0xe000'0000: return memory(programRAM, mode, addr & 0x3fff);
+  }
+
+  addr &= 0xe000'003f;
+
+  if(addr == 0x4000'0010) {
+    if(bridge.cputoarm.ready) {
+      bridge.cputoarm.ready = false;
+      return bridge.cputoarm.data;
+    }
+  }
+
+  if(addr == 0x4000'0020) {
+    return bridge.status();
+  }
+
+  return 0;
+}
+
+auto ArmDSP::_write(uint mode, uint32 addr, uint32 word) -> void {
+  step(1);
+
+  static auto memory = [](uint8* memory, uint mode, uint32 addr, uint32 word) {
+    if(mode & Word) {
+      memory += addr & ~3;
+      *memory++ = word >>  0;
+      *memory++ = word >>  8;
+      *memory++ = word >> 16;
+      *memory++ = word >> 24;
+    } else if(mode & Byte) {
+      memory += addr;
+      *memory++ = word >>  0;
+    }
+  };
+
+  switch(addr & 0xe000'0000) {
+  case 0x0000'0000: return;
+  case 0x2000'0000: return;
+  case 0x4000'0000: break;
+  case 0x6000'0000: return;
+  case 0x8000'0000: return;
+  case 0xa000'0000: return;
+  case 0xc000'0000: return;
+  case 0xe000'0000: return memory(programRAM, mode, addr & 0x3fff, word);
+  }
+
+  addr &= 0xe000'003f;
+  word &= 0x0000'00ff;
+
+  if(addr == 0x4000'0000) {
+    bridge.armtocpu.ready = true;
+    bridge.armtocpu.data = word;
+  }
+
+  if(addr == 0x4000'0010) bridge.signal = true;
+
+  if(addr == 0x4000'0020) bridge.timerlatch.byte(0) = word;
+  if(addr == 0x4000'0024) bridge.timerlatch.byte(1) = word;
+  if(addr == 0x4000'0028) bridge.timerlatch.byte(2) = word;
+
+  if(addr == 0x4000'002c) bridge.timer = bridge.timerlatch;
+}
diff --git a/nSide/higan/sfc-balanced/coprocessor/armdsp/registers.hpp b/nSide/higan/sfc-balanced/coprocessor/armdsp/registers.hpp
new file mode 100644
index 0000000..c05a097
--- /dev/null
+++ b/nSide/higan/sfc-balanced/coprocessor/armdsp/registers.hpp
@@ -0,0 +1,22 @@
+struct Bridge {
+  struct Buffer {
+    bool ready;
+    uint8 data;
+  };
+  Buffer cputoarm;
+  Buffer armtocpu;
+  uint32 timer;
+  uint32 timerlatch;
+  bool reset;
+  bool ready;
+  bool signal;
+
+  auto status() const -> uint8 {
+    return (
+      armtocpu.ready << 0
+    | signal         << 2
+    | cputoarm.ready << 3
+    | ready          << 7
+    );
+  }
+} bridge;
diff --git a/nSide/higan/sfc-balanced/coprocessor/armdsp/serialization.cpp b/nSide/higan/sfc-balanced/coprocessor/armdsp/serialization.cpp
new file mode 100644
index 0000000..fbfba45
--- /dev/null
+++ b/nSide/higan/sfc-balanced/coprocessor/armdsp/serialization.cpp
@@ -0,0 +1,25 @@
+auto ArmDSP::firmware() const -> nall::vector<uint8> {
+  nall::vector<uint8> buffer;
+  if(!cartridge.has.ARMDSP) return buffer;
+  buffer.reserve(128 * 1024 + 32 * 1024);
+  for(auto n : range(128 * 1024)) buffer.append(programROM[n]);
+  for(auto n : range( 32 * 1024)) buffer.append(dataROM[n]);
+  return buffer;
+}
+
+auto ArmDSP::serialize(serializer& s) -> void {
+  ARM::serialize(s);
+  Thread::serialize(s);
+
+  s.array(programRAM, 16 * 1024);
+
+  s.integer(bridge.cputoarm.ready);
+  s.integer(bridge.cputoarm.data);
+  s.integer(bridge.armtocpu.ready);
+  s.integer(bridge.armtocpu.data);
+  s.integer(bridge.timer);
+  s.integer(bridge.timerlatch);
+  s.integer(bridge.reset);
+  s.integer(bridge.ready);
+  s.integer(bridge.signal);
+}
diff --git a/nSide/higan/sfc-balanced/coprocessor/coprocessor.hpp b/nSide/higan/sfc-balanced/coprocessor/coprocessor.hpp
new file mode 100644
index 0000000..47061bf
--- /dev/null
+++ b/nSide/higan/sfc-balanced/coprocessor/coprocessor.hpp
@@ -0,0 +1,20 @@
+#include <sfc-balanced/coprocessor/icd2/icd2.hpp>
+#include <sfc-balanced/coprocessor/mcc/mcc.hpp>
+#include <sfc-balanced/coprocessor/nss/nss.hpp>
+#include <sfc-balanced/coprocessor/event/event.hpp>
+
+#include <sfc-balanced/coprocessor/sa1/sa1.hpp>
+#include <sfc-balanced/coprocessor/superfx/superfx.hpp>
+
+#include <sfc-balanced/coprocessor/armdsp/armdsp.hpp>
+#include <sfc-balanced/coprocessor/hitachidsp/hitachidsp.hpp>
+#include <sfc-balanced/coprocessor/necdsp/necdsp.hpp>
+
+#include <sfc-balanced/coprocessor/epsonrtc/epsonrtc.hpp>
+#include <sfc-balanced/coprocessor/sharprtc/sharprtc.hpp>
+
+#include <sfc-balanced/coprocessor/spc7110/spc7110.hpp>
+#include <sfc-balanced/coprocessor/sdd1/sdd1.hpp>
+#include <sfc-balanced/coprocessor/obc1/obc1.hpp>
+
+#include <sfc-balanced/coprocessor/msu1/msu1.hpp>
diff --git a/nSide/higan/sfc-balanced/coprocessor/epsonrtc/epsonrtc.cpp b/nSide/higan/sfc-balanced/coprocessor/epsonrtc/epsonrtc.cpp
new file mode 100644
index 0000000..a88f4f5
--- /dev/null
+++ b/nSide/higan/sfc-balanced/coprocessor/epsonrtc/epsonrtc.cpp
@@ -0,0 +1,203 @@
+#include <sfc-balanced/sfc.hpp>
+
+namespace SuperFamicom {
+
+#include "memory.cpp"
+#include "time.cpp"
+#include "serialization.cpp"
+EpsonRTC epsonrtc;
+
+auto EpsonRTC::Enter() -> void {
+  while(true) scheduler.synchronize(), epsonrtc.main();
+}
+
+auto EpsonRTC::main() -> void {
+  if(wait) { if(--wait == 0) ready = 1; }
+
+  clocks++;
+  if((clocks & ~0x00ff) == 0) roundSeconds();  //125 microseconds
+  if((clocks & ~0x3fff) == 0) duty();  //1/128th second
+  if((clocks & ~0x7fff) == 0) irq(0);  //1/64th second
+  if(clocks == 0) {  //1 second
+    seconds++;
+    irq(1);
+    if(seconds %   60 == 0) irq(2);  //1 minute
+    if(seconds % 1440 == 0) irq(3), seconds = 0;  //1 hour
+    tick();
+  }
+
+  step(1);
+  synchronize(cpu);
+}
+
+auto EpsonRTC::init() -> void {
+}
+
+auto EpsonRTC::load() -> void {
+  secondlo = 0;
+  secondhi = 0;
+  batteryfailure = 1;
+
+  minutelo = 0;
+  minutehi = 0;
+  resync = 0;
+
+  hourlo = 0;
+  hourhi = 0;
+  meridian = 0;
+
+  daylo = 0;
+  dayhi = 0;
+  dayram = 0;
+
+  monthlo = 0;
+  monthhi = 0;
+  monthram = 0;
+
+  yearlo = 0;
+  yearhi = 0;
+
+  weekday = 0;
+
+  hold = 0;
+  calendar = 0;
+  irqflag = 0;
+  roundseconds = 0;
+
+  irqmask = 0;
+  irqduty = 0;
+  irqperiod = 0;
+
+  pause = 0;
+  stop = 0;
+  atime = 0;
+  test = 0;
+}
+
+auto EpsonRTC::unload() -> void {
+}
+
+auto EpsonRTC::power() -> void {
+}
+
+auto EpsonRTC::reset() -> void {
+  create(EpsonRTC::Enter, 32'768 * 64);
+
+  clocks = 0;
+  seconds = 0;
+
+  chipselect = 0;
+  state = State::Mode;
+  offset = 0;
+  wait = 0;
+  ready = 0;
+  holdtick = 0;
+}
+
+auto EpsonRTC::sync() -> void {
+  time_t systime = time(0);
+  tm* timeinfo = localtime(&systime);
+
+  uint second = min(59, timeinfo->tm_sec);
+  secondlo = second % 10;
+  secondhi = second / 10;
+
+  uint minute = timeinfo->tm_min;
+  minutelo = minute % 10;
+  minutehi = minute / 10;
+
+  uint hour = timeinfo->tm_hour;
+  if(atime) {
+    hourlo = hour % 10;
+    hourhi = hour / 10;
+  } else {
+    meridian = hour >= 12;
+    hour %= 12;
+    if(hour == 0) hour = 12;
+    hourlo = hour % 10;
+    hourhi = hour / 10;
+  }
+
+  uint day = timeinfo->tm_mday;
+  daylo = day % 10;
+  dayhi = day / 10;
+
+  uint month = 1 + timeinfo->tm_mon;
+  monthlo = month % 10;
+  monthhi = month / 10;
+
+  uint year = timeinfo->tm_year % 100;
+  yearlo = year % 10;
+  yearhi = year / 10;
+
+  weekday = timeinfo->tm_wday;
+
+  resync = true;  //alert program that time has changed
+}
+
+auto EpsonRTC::read(uint24 addr, uint8 data) -> uint8 {
+  cpu.synchronize(*this);
+  addr &= 3;
+
+  if(addr == 0) {
+    return chipselect;
+  }
+
+  if(addr == 1) {
+    if(chipselect != 1) return 0;
+    if(ready == 0) return 0;
+    if(state == State::Write) return mdr;
+    if(state != State::Read) return 0;
+    ready = 0;
+    wait = 8;
+    return rtcRead(offset++);
+  }
+
+  if(addr == 2) {
+    return ready << 7;
+  }
+
+  return data;
+}
+
+auto EpsonRTC::write(uint24 addr, uint8 data) -> void {
+  cpu.synchronize(*this);
+  addr &= 3, data &= 15;
+
+  if(addr == 0) {
+    chipselect = data;
+    if(chipselect != 1) rtcReset();
+    ready = 1;
+  }
+
+  if(addr == 1) {
+    if(chipselect != 1) return;
+    if(ready == 0) return;
+
+    if(state == State::Mode) {
+      if(data != 0x03 && data != 0x0c) return;
+      state = State::Seek;
+      ready = 0;
+      wait = 8;
+      mdr = data;
+    }
+
+    else if(state == State::Seek) {
+      if(mdr == 0x03) state = State::Write;
+      if(mdr == 0x0c) state = State::Read;
+      offset = data;
+      ready = 0;
+      wait = 8;
+      mdr = data;
+    }
+
+    else if(state == State::Write) {
+      rtcWrite(offset++, data);
+      ready = 0;
+      wait = 8;
+      mdr = data;
+    }
+  }
+}
+
+}
diff --git a/nSide/higan/sfc-balanced/coprocessor/epsonrtc/epsonrtc.hpp b/nSide/higan/sfc-balanced/coprocessor/epsonrtc/epsonrtc.hpp
new file mode 100644
index 0000000..4a40313
--- /dev/null
+++ b/nSide/higan/sfc-balanced/coprocessor/epsonrtc/epsonrtc.hpp
@@ -0,0 +1,91 @@
+//Epson RTC-4513 Real-Time Clock
+
+struct EpsonRTC : Thread {
+  static auto Enter() -> void;
+  auto main() -> void;
+
+  auto init() -> void;
+  auto load() -> void;
+  auto unload() -> void;
+  auto power() -> void;
+  auto reset() -> void;
+  auto sync() -> void;
+
+  auto read(uint24 addr, uint8 data) -> uint8;
+  auto write(uint24 addr, uint8 data) -> void;
+
+  auto serialize(serializer&) -> void;
+
+  uint21 clocks;
+  uint seconds;
+
+  uint2 chipselect;
+  enum class State : uint { Mode, Seek, Read, Write } state;
+  uint4 mdr;
+  uint4 offset;
+  uint wait;
+  uint1 ready;
+  uint1 holdtick;
+
+  uint4 secondlo;
+  uint3 secondhi;
+  uint1 batteryfailure;
+
+  uint4 minutelo;
+  uint3 minutehi;
+  uint1 resync;
+
+  uint4 hourlo;
+  uint2 hourhi;
+  uint1 meridian;
+
+  uint4 daylo;
+  uint2 dayhi;
+  uint1 dayram;
+
+  uint4 monthlo;
+  uint1 monthhi;
+  uint2 monthram;
+
+  uint4 yearlo;
+  uint4 yearhi;
+
+  uint3 weekday;
+
+  uint1 hold;
+  uint1 calendar;
+  uint1 irqflag;
+  uint1 roundseconds;
+
+  uint1 irqmask;
+  uint1 irqduty;
+  uint2 irqperiod;
+
+  uint1 pause;
+  uint1 stop;
+  uint1 atime;  //astronomical time (24-hour mode)
+  uint1 test;
+
+  //memory.cpp
+  auto rtcReset() -> void;
+  auto rtcRead(uint4 addr) -> uint4;
+  auto rtcWrite(uint4 addr, uint4 data) -> void;
+
+  auto load(const uint8* data) -> void;
+  auto save(uint8* data) -> void;
+
+  //time.cpp
+  auto irq(uint2 period) -> void;
+  auto duty() -> void;
+  auto roundSeconds() -> void;
+  auto tick() -> void;
+
+  auto tickSecond() -> void;
+  auto tickMinute() -> void;
+  auto tickHour() -> void;
+  auto tickDay() -> void;
+  auto tickMonth() -> void;
+  auto tickYear() -> void;
+};
+
+extern EpsonRTC epsonrtc;
diff --git a/nSide/higan/sfc-balanced/coprocessor/epsonrtc/memory.cpp b/nSide/higan/sfc-balanced/coprocessor/epsonrtc/memory.cpp
new file mode 100644
index 0000000..f3ab59e
--- /dev/null
+++ b/nSide/higan/sfc-balanced/coprocessor/epsonrtc/memory.cpp
@@ -0,0 +1,180 @@
+auto EpsonRTC::rtcReset() -> void {
+  state = State::Mode;
+  offset = 0;
+
+  resync = 0;
+  pause = 0;
+  test = 0;
+}
+
+auto EpsonRTC::rtcRead(uint4 addr) -> uint4 {
+  switch(addr) { default:
+  case  0: return secondlo;
+  case  1: return secondhi | batteryfailure << 3;
+  case  2: return minutelo;
+  case  3: return minutehi | resync << 3;
+  case  4: return hourlo;
+  case  5: return hourhi | meridian << 2 | resync << 3;
+  case  6: return daylo;
+  case  7: return dayhi | dayram << 2 | resync << 3;
+  case  8: return monthlo;
+  case  9: return monthhi | monthram << 1 | resync << 3;
+  case 10: return yearlo;
+  case 11: return yearhi;
+  case 12: return weekday | resync << 3;
+  case 13: {
+    uint1 readflag = irqflag & !irqmask;
+    irqflag = 0;
+    return hold | calendar << 1 | readflag << 2 | roundseconds << 3;
+  }
+  case 14: return irqmask | irqduty << 1 | irqperiod << 2;
+  case 15: return pause | stop << 1 | atime << 2 | test << 3;
+  }
+}
+
+auto EpsonRTC::rtcWrite(uint4 addr, uint4 data) -> void {
+  switch(addr) {
+  case 0:
+    secondlo = data;
+    break;
+  case 1:
+    secondhi = data;
+    batteryfailure = data >> 3;
+    break;
+  case 2:
+    minutelo = data;
+    break;
+  case 3:
+    minutehi = data;
+    break;
+  case 4:
+    hourlo = data;
+    break;
+  case 5:
+    hourhi = data;
+    meridian = data >> 2;
+    if(atime == 1) meridian = 0;
+    if(atime == 0) hourhi &= 1;
+    break;
+  case 6:
+    daylo = data;
+    break;
+  case 7:
+    dayhi = data;
+    dayram = data >> 2;
+    break;
+  case 8:
+    monthlo = data;
+    break;
+  case 9:
+    monthhi = data;
+    monthram = data >> 1;
+    break;
+  case 10:
+    yearlo = data;
+    break;
+  case 11:
+    yearhi = data;
+    break;
+  case 12:
+    weekday = data;
+    break;
+  case 13: {
+    bool held = hold;
+    hold = data;
+    calendar = data >> 1;
+    roundseconds = data >> 3;
+    if(held == 1 && hold == 0 && holdtick == 1) {
+      //if a second has passed during hold, increment one second upon resuming
+      holdtick = 0;
+      tickSecond();
+    }
+  } break;
+  case 14:
+    irqmask = data;
+    irqduty = data >> 1;
+    irqperiod = data >> 2;
+    break;
+  case 15:
+    pause = data;
+    stop = data >> 1;
+    atime = data >> 2;
+    test = data >> 3;
+    if(atime == 1) meridian = 0;
+    if(atime == 0) hourhi &= 1;
+    if(pause) {
+      secondlo = 0;
+      secondhi = 0;
+    }
+    break;
+  }
+}
+
+auto EpsonRTC::load(const uint8* data) -> void {
+  secondlo = data[0] >> 0;
+  secondhi = data[0] >> 4;
+  batteryfailure = data[0] >> 7;
+
+  minutelo = data[1] >> 0;
+  minutehi = data[1] >> 4;
+  resync = data[1] >> 7;
+
+  hourlo = data[2] >> 0;
+  hourhi = data[2] >> 4;
+  meridian = data[2] >> 6;
+
+  daylo = data[3] >> 0;
+  dayhi = data[3] >> 4;
+  dayram = data[3] >> 6;
+
+  monthlo = data[4] >> 0;
+  monthhi = data[4] >> 4;
+  monthram = data[4] >> 5;
+
+  yearlo = data[5] >> 0;
+  yearhi = data[5] >> 4;
+
+  weekday = data[6] >> 0;
+
+  hold = data[6] >> 4;
+  calendar = data[6] >> 5;
+  irqflag = data[6] >> 6;
+  roundseconds = data[6] >> 7;
+
+  irqmask = data[7] >> 0;
+  irqduty = data[7] >> 1;
+  irqperiod = data[7] >> 2;
+
+  pause = data[7] >> 4;
+  stop = data[7] >> 5;
+  atime = data[7] >> 6;
+  test = data[7] >> 7;
+
+  uint64 timestamp = 0;
+  for(auto byte : range(8)) {
+    timestamp |= data[8 + byte] << (byte * 8);
+  }
+
+  uint64 diff = (uint64)time(0) - timestamp;
+  while(diff >= 60 * 60 * 24) { tickDay(); diff -= 60 * 60 * 24; }
+  while(diff >= 60 * 60) { tickHour(); diff -= 60 * 60; }
+  while(diff >= 60) { tickMinute(); diff -= 60; }
+  while(diff--) tickSecond();
+}
+
+auto EpsonRTC::save(uint8* data) -> void {
+  data[0] = secondlo << 0 | secondhi << 4 | batteryfailure << 7;
+  data[1] = minutelo << 0 | minutehi << 4 | resync << 7;
+  data[2] = hourlo << 0 | hourhi << 4 | meridian << 6 | resync << 7;
+  data[3] = daylo << 0 | dayhi << 4 | dayram << 6 | resync << 7;
+  data[4] = monthlo << 0 | monthhi << 4 | monthram << 5 | resync << 7;
+  data[5] = yearlo << 0 | yearhi << 4;
+  data[6] = weekday << 0 | resync << 3 | hold << 4 | calendar << 5 | irqflag << 6 | roundseconds << 7;
+  data[7] = irqmask << 0 | irqduty << 1 | irqperiod << 2 | pause << 4 | stop << 5 | atime << 6 | test << 7;
+
+  uint64 timestamp = (uint64)time(0);
+  for(auto byte : range(8)) {
+    data[8 + byte] = timestamp;
+    timestamp >>= 8;
+  }
+}
diff --git a/nSide/higan/sfc-balanced/coprocessor/epsonrtc/serialization.cpp b/nSide/higan/sfc-balanced/coprocessor/epsonrtc/serialization.cpp
new file mode 100644
index 0000000..0b75af6
--- /dev/null
+++ b/nSide/higan/sfc-balanced/coprocessor/epsonrtc/serialization.cpp
@@ -0,0 +1,53 @@
+auto EpsonRTC::serialize(serializer& s) -> void {
+  Thread::serialize(s);
+
+  s.integer(clocks);
+  s.integer(seconds);
+
+  s.integer(chipselect);
+  s.integer((uint&)state);
+  s.integer(mdr);
+  s.integer(offset);
+  s.integer(wait);
+  s.integer(ready);
+  s.integer(holdtick);
+
+  s.integer(secondlo);
+  s.integer(secondhi);
+  s.integer(batteryfailure);
+
+  s.integer(minutelo);
+  s.integer(minutehi);
+  s.integer(resync);
+
+  s.integer(hourlo);
+  s.integer(hourhi);
+  s.integer(meridian);
+
+  s.integer(daylo);
+  s.integer(dayhi);
+  s.integer(dayram);
+
+  s.integer(monthlo);
+  s.integer(monthhi);
+  s.integer(monthram);
+
+  s.integer(yearlo);
+  s.integer(yearhi);
+
+  s.integer(weekday);
+
+  s.integer(hold);
+  s.integer(calendar);
+  s.integer(irqflag);
+  s.integer(roundseconds);
+
+  s.integer(irqmask);
+  s.integer(irqduty);
+  s.integer(irqperiod);
+
+  s.integer(pause);
+  s.integer(stop);
+  s.integer(atime);
+  s.integer(test);
+}
diff --git a/nSide/higan/sfc-balanced/coprocessor/epsonrtc/time.cpp b/nSide/higan/sfc-balanced/coprocessor/epsonrtc/time.cpp
new file mode 100644
index 0000000..08c13a4
--- /dev/null
+++ b/nSide/higan/sfc-balanced/coprocessor/epsonrtc/time.cpp
@@ -0,0 +1,182 @@
+auto EpsonRTC::irq(uint2 period) -> void {
+  if(stop || pause) return;
+
+  if(period == irqperiod) irqflag = 1;
+}
+
+auto EpsonRTC::duty() -> void {
+  if(irqduty) irqflag = 0;
+}
+
+auto EpsonRTC::roundSeconds() -> void {
+  if(roundseconds == 0) return;
+  roundseconds = 0;
+
+  if(secondhi >= 3) tickMinute();
+  secondlo = 0;
+  secondhi = 0;
+}
+
+auto EpsonRTC::tick() -> void {
+  if(stop || pause) return;
+
+  if(hold) {
+    holdtick = 1;
+    return;
+  }
+
+  resync = 1;
+  tickSecond();
+}
+
+//below code provides bit-perfect emulation of invalid BCD values on the RTC-4513
+//code makes extensive use of variable-length integers (see epsonrtc.hpp for sizes)
+
+auto EpsonRTC::tickSecond() -> void {
+  if(secondlo <= 8 || secondlo == 12) {
+    secondlo++;
+  } else {
+    secondlo = 0;
+    if(secondhi < 5) {
+      secondhi++;
+    } else {
+      secondhi = 0;
+      tickMinute();
+    }
+  }
+}
+
+auto EpsonRTC::tickMinute() -> void {
+  if(minutelo <= 8 || minutelo == 12) {
+    minutelo++;
+  } else {
+    minutelo = 0;
+    if(minutehi < 5) {
+      minutehi++;
+    } else {
+      minutehi = 0;
+      tickHour();
+    }
+  }
+}
+
+auto EpsonRTC::tickHour() -> void {
+  if(atime) {
+    if(hourhi < 2) {
+      if(hourlo <= 8 || hourlo == 12) {
+        hourlo++;
+      } else {
+        hourlo = !(hourlo & 1);
+        hourhi++;
+      }
+    } else {
+      if(hourlo != 3 && !(hourlo & 4)) {
+        if(hourlo <= 8 || hourlo >= 12) {
+          hourlo++;
+        } else {
+          hourlo = !(hourlo & 1);
+          hourhi++;
+        }
+      } else {
+        hourlo = !(hourlo & 1);
+        hourhi = 0;
+        tickDay();
+      }
+    }
+  } else {
+    if(hourhi == 0) {
+      if(hourlo <= 8 || hourlo == 12) {
+        hourlo++;
+      } else {
+        hourlo = !(hourlo & 1);
+        hourhi ^= 1;
+      }
+    } else {
+      if(hourlo & 1) meridian ^= 1;
+      if(hourlo < 2 || hourlo == 4 || hourlo == 5 || hourlo == 8 || hourlo == 12) {
+        hourlo++;
+      } else {
+        hourlo = !(hourlo & 1);
+        hourhi ^= 1;
+      }
+      if(meridian == 0 && !(hourlo & 1)) tickDay();
+    }
+  }
+}
+
+auto EpsonRTC::tickDay() -> void {
+  if(calendar == 0) return;
+  weekday = (weekday + 1) + (weekday == 6);
+
+  //January - December = 0x01 - 0x09; 0x10 - 0x12
+  static const uint daysinmonth[32] = {
+    30, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31, 30, 31, 30,
+    31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30, 31, 30,
+  };
+
+  uint days = daysinmonth[monthhi << 4 | monthlo];
+  if(days == 28) {
+    //add one day for leap years
+    if((yearhi & 1) == 0 && ((yearlo - 0) & 3) == 0) days++;
+    if((yearhi & 1) == 1 && ((yearlo - 2) & 3) == 0) days++;
+  }
+
+  if(days == 28 && (dayhi == 3 || (dayhi == 2 && daylo >= 8))) {
+    daylo = 1;
+    dayhi = 0;
+    return tickMonth();
+  }
+
+  if(days == 29 && (dayhi == 3 || (dayhi == 2 && (daylo > 8 && daylo != 12)))) {
+    daylo = 1;
+    dayhi = 0;
+    return tickMonth();
+  }
+
+  if(days == 30 && (dayhi == 3 || (dayhi == 2 && (daylo == 10 || daylo == 14)))) {
+    daylo = 1;
+    dayhi = 0;
+    return tickMonth();
+  }
+
+  if(days == 31 && (dayhi == 3 && (daylo & 3))) {
+    daylo = 1;
+    dayhi = 0;
+    return tickMonth();
+  }
+
+  if(daylo <= 8 || daylo == 12) {
+    daylo++;
+  } else {
+    daylo = !(daylo & 1);
+    dayhi++;
+  }
+}
+
+auto EpsonRTC::tickMonth() -> void {
+  if(monthhi == 0 || !(monthlo & 2)) {
+    if(monthlo <= 8 || monthlo == 12) {
+      monthlo++;
+    } else {
+      monthlo = !(monthlo & 1);
+      monthhi ^= 1;
+    }
+  } else {
+    monthlo = !(monthlo & 1);
+    monthhi = 0;
+    tickYear();
+  }
+}
+
+auto EpsonRTC::tickYear() -> void {
+  if(yearlo <= 8 || yearlo == 12) {
+    yearlo++;
+  } else {
+    yearlo = !(yearlo & 1);
+    if(yearhi <= 8 || yearhi == 12) {
+      yearhi++;
+    } else {
+      yearhi = !(yearhi & 1);
+    }
+  }
+}
diff --git a/nSide/higan/sfc-balanced/coprocessor/event/event.cpp b/nSide/higan/sfc-balanced/coprocessor/event/event.cpp
new file mode 100644
index 0000000..d4ce1ae
--- /dev/null
+++ b/nSide/higan/sfc-balanced/coprocessor/event/event.cpp
@@ -0,0 +1,127 @@
+#include <sfc-balanced/sfc.hpp>
+
+namespace SuperFamicom {
+
+Event event;
+
+auto Event::Enter() -> void {
+  while(true) scheduler.synchronize(), event.main();
+}
+
+auto Event::main() -> void {
+  if(scoreActive && scoreSecondsRemaining) {
+    if(--scoreSecondsRemaining == 0) {
+      scoreActive = false;
+    }
+  }
+
+  if(timerActive && timerSecondsRemaining) {
+    if(--timerSecondsRemaining == 0) {
+      timerActive = false;
+      status |= 0x02;  //time over
+      scoreActive = true;
+      scoreSecondsRemaining = 5;
+    }
+  }
+
+  step(1);
+  synchronize(cpu);
+}
+
+auto Event::init() -> void {
+}
+
+auto Event::load() -> void {
+}
+
+auto Event::unload() -> void {
+  rom[0].reset();
+  rom[1].reset();
+  rom[2].reset();
+  rom[3].reset();
+  ram.reset();
+}
+
+auto Event::power() -> void {
+}
+
+auto Event::reset() -> void {
+  create(Event::Enter, 1);
+
+  for(auto n : range(ram.size())) ram.write(n, 0x00);
+  status = 0x00;
+  select = 0x00;
+  timerActive = false;
+  scoreActive = false;
+  timerSecondsRemaining = 0;
+  scoreSecondsRemaining = 0;
+}
+
+auto Event::mcuRead(uint24 addr, uint8 data) -> uint8 {
+  if(board == Board::CampusChallenge92) {
+    uint id = 0;
+    if(select == 0x09) id = 1;
+    if(select == 0x05) id = 2;
+    if(select == 0x03) id = 3;
+    if((addr & 0x808000) == 0x808000) id = 0;
+
+    if(addr & 0x008000) {
+      addr = ((addr & 0x7f0000) >> 1) | (addr & 0x7fff);
+      return rom[id].read(bus.mirror(addr, rom[id].size()), data);
+    }
+  }
+
+  if(board == Board::Powerfest94) {
+    uint id = 0;
+    if(select == 0x09) id = 1;
+    if(select == 0x0c) id = 2;
+    if(select == 0x0a) id = 3;
+    if((addr & 0x208000) == 0x208000) id = 0;
+
+    if(addr & 0x400000) {
+      addr &= 0x3fffff;
+      return rom[id].read(bus.mirror(addr, rom[id].size()), data);
+    }
+
+    if(addr & 0x008000) {
+      addr &= 0x1fffff;
+      if(id != 2) addr = ((addr & 0x1f0000) >> 1) | (addr & 0x7fff);
+      return rom[id].read(bus.mirror(addr, rom[id].size()), data);
+    }
+  }
+
+  return data;
+}
+
+auto Event::mcuWrite(uint24 addr, uint8 data) -> void {
+}
+
+auto Event::read(uint24 addr, uint8 data) -> uint8 {
+  if(addr == 0x106000 || addr == 0xc00000) {
+    return status;
+  }
+  return data;
+}
+
+auto Event::write(uint24 addr, uint8 data) -> void {
+  if(addr == 0x206000 || addr == 0xe00000) {
+    select = data;
+    if(timer && data == 0x09) {
+      timerActive = true;
+      timerSecondsRemaining = timer;
+    }
+  }
+}
+
+auto Event::serialize(serializer& s) -> void {
+  Thread::serialize(s);
+  s.array(ram.data(), ram.size());
+  s.integer(status);
+  s.integer(select);
+  s.integer(timerActive);
+  s.integer(scoreActive);
+  s.integer(timerSecondsRemaining);
+  s.integer(scoreSecondsRemaining);
+}
+
+}
diff --git a/nSide/higan/sfc-balanced/coprocessor/event/event.hpp b/nSide/higan/sfc-balanced/coprocessor/event/event.hpp
new file mode 100644
index 0000000..5373ac4
--- /dev/null
+++ b/nSide/higan/sfc-balanced/coprocessor/event/event.hpp
@@ -0,0 +1,39 @@
+//SNES-EVENT board emulation:
+//* Campus Challenge '92
+//* Powerfest '94
+
+struct Event : Thread {
+  static auto Enter() -> void;
+  auto main() -> void;
+  auto init() -> void;
+  auto load() -> void;
+  auto unload() -> void;
+  auto power() -> void;
+  auto reset() -> void;
+
+  auto mcuRead(uint24 addr, uint8) -> uint8;
+  auto mcuWrite(uint24 addr, uint8) -> void;
+
+  auto read(uint24 addr, uint8 data) -> uint8;
+  auto write(uint24 addr, uint8 data) -> void;
+
+  auto serialize(serializer&) -> void;
+
+  MappedRAM rom[4];
+  MappedRAM ram;
+
+  enum class Board : uint { CampusChallenge92, Powerfest94 } board;
+  uint timer;
+
+privileged:
+  uint8 status;
+  uint8 select;
+
+  bool timerActive;
+  bool scoreActive;
+
+  uint timerSecondsRemaining;
+  uint scoreSecondsRemaining;
+};
+
+extern Event event;
diff --git a/nSide/higan/sfc-balanced/coprocessor/hitachidsp/hitachidsp.cpp b/nSide/higan/sfc-balanced/coprocessor/hitachidsp/hitachidsp.cpp
new file mode 100644
index 0000000..c832001
--- /dev/null
+++ b/nSide/higan/sfc-balanced/coprocessor/hitachidsp/hitachidsp.cpp
@@ -0,0 +1,60 @@
+#include <sfc-balanced/sfc.hpp>
+
+namespace SuperFamicom {
+
+#include "memory.cpp"
+#include "serialization.cpp"
+HitachiDSP hitachidsp;
+
+auto HitachiDSP::Enter() -> void {
+  while(true) scheduler.synchronize(), hitachidsp.main();
+}
+
+auto HitachiDSP::main() -> void {
+  if(mmio.dma) {
+    for(auto n : range(mmio.dmaLength)) {
+      write(mmio.dmaTarget + n, read(mmio.dmaSource + n));
+      step(2);
+      synchronize(cpu);
+    }
+    mmio.dma = false;
+  }
+
+  exec(mmio.programOffset);
+  step(1);
+  synchronize(cpu);
+}
+
+auto HitachiDSP::init() -> void {
+}
+
+auto HitachiDSP::load() -> void {
+}
+
+auto HitachiDSP::unload() -> void {
+  rom.reset();
+  ram.reset();
+}
+
+auto HitachiDSP::power() -> void {
+  mmio.dma = false;
+
+  mmio.dmaSource = 0x000000;
+  mmio.dmaLength = 0x0000;
+  mmio.dmaTarget = 0x000000;
+  mmio.r1f48 = 0x00;
+  mmio.programOffset = 0x000000;
+  mmio.r1f4c = 0x00;
+  mmio.pageNumber = 0x0000;
+  mmio.programCounter = 0x00;
+  mmio.r1f50 = 0x33;
+  mmio.r1f51 = 0x00;
+  mmio.r1f52 = 0x01;
+}
+
+auto HitachiDSP::reset() -> void {
+  create(HitachiDSP::Enter, Frequency);
+  HG51B::power();
+}
+
+}
diff --git a/nSide/higan/sfc-balanced/coprocessor/hitachidsp/hitachidsp.hpp b/nSide/higan/sfc-balanced/coprocessor/hitachidsp/hitachidsp.hpp
new file mode 100644
index 0000000..586652f
--- /dev/null
+++ b/nSide/higan/sfc-balanced/coprocessor/hitachidsp/hitachidsp.hpp
@@ -0,0 +1,58 @@
+struct HitachiDSP : Processor::HG51B, Thread {
+  MappedRAM rom;
+  MappedRAM ram;
+
+  static auto Enter() -> void;
+  auto main() -> void;
+
+  auto init() -> void;
+  auto load() -> void;
+  auto unload() -> void;
+  auto power() -> void;
+  auto reset() -> void;
+
+  //HG51B read/write
+  auto read(uint24 addr) -> uint8 override;
+  auto write(uint24 addr, uint8 data) -> void override;
+
+  //CPU ROM read/write
+  auto romRead(uint24 addr, uint8 data) -> uint8;
+  auto romWrite(uint24 addr, uint8 data) -> void;
+
+  //CPU RAM read/write
+  auto ramRead(uint24 addr, uint8 data) -> uint8;
+  auto ramWrite(uint24 addr, uint8 data) -> void;
+
+  //HG51B data RAM read/write
+  auto dramRead(uint24 addr, uint8 data) -> uint8;
+  auto dramWrite(uint24 addr, uint8 data) -> void;
+
+  //CPU MMIO read/write
+  auto dspRead(uint24 addr, uint8 data) -> uint8;
+  auto dspWrite(uint24 addr, uint8 data) -> void;
+
+  auto firmware() const -> vector<uint8>;
+  auto serialize(serializer&) -> void;
+
+  uint Frequency;
+  uint Roms;
+
+  struct MMIO {
+    bool dma;  //true during DMA transfers
+
+    uint24 dmaSource;       //$1f40-$1f42
+    uint24 dmaLength;       //$1f43-$1f44
+    uint24 dmaTarget;       //$1f45-$1f47
+    uint8  r1f48;           //$1f48
+    uint24 programOffset;   //$1f49-$1f4b
+    uint8  r1f4c;           //$1f4c
+    uint16 pageNumber;      //$1f4d-$1f4e
+    uint8  programCounter;  //$1f4f
+    uint8  r1f50;           //$1f50
+    uint8  r1f51;           //$1f51
+    uint8  r1f52;           //$1f52
+    uint8  vector[32];      //$1f60-$1f7f
+  } mmio;
+};
+
+extern HitachiDSP hitachidsp;
diff --git a/nSide/higan/sfc-balanced/coprocessor/hitachidsp/memory.cpp b/nSide/higan/sfc-balanced/coprocessor/hitachidsp/memory.cpp
new file mode 100644
index 0000000..167c9f3
--- /dev/null
+++ b/nSide/higan/sfc-balanced/coprocessor/hitachidsp/memory.cpp
@@ -0,0 +1,166 @@
+auto HitachiDSP::read(uint24 addr) -> uint8 {
+  if((addr & 0x40ec00) == 0x006c00) {  //$00-3f,80-bf:6c00-6cff,7c00-7cff
+    return dspRead(addr, 0x00);
+  }
+  if((addr & 0x40e000) == 0x006000) {  //$00-3f,80-bf:6000-6bff,7000-7bff
+    return dramRead(addr, 0x00);
+  }
+  if((addr & 0x408000) == 0x008000) {  //$00-3f,80-bf:8000-ffff
+    if(rom.size() == 0) return 0x00;
+    addr = ((addr & 0x3f0000) >> 1) | (addr & 0x7fff);
+    addr = Bus::mirror(addr, rom.size());
+    return rom.read(addr, 0);
+  }
+  if((addr & 0xf88000) == 0x700000) {  //$70-77:0000-7fff
+    if(ram.size() == 0) return 0x00;
+    addr = ((addr & 0x070000) >> 1) | (addr & 0x7fff);
+    addr = Bus::mirror(addr, ram.size());
+    return ram.read(addr);
+  }
+  return 0x00;
+}
+
+auto HitachiDSP::write(uint24 addr, uint8 data) -> void {
+  if((addr & 0x40ec00) == 0x006c00) {  //$00-3f,80-bf:6c00-6fff,7c00-7fff
+    return dspWrite(addr, data);
+  }
+  if((addr & 0x40e000) == 0x006000) {  //$00-3f,80-bf:6000-6bff,7000-7bff
+    return dramWrite(addr, data);
+  }
+  if((addr & 0xf88000) == 0x700000) {  //$70-77:0000-7fff
+    if(ram.size() == 0) return;
+    addr = ((addr & 0x070000) >> 1) | (addr & 0x7fff);
+    addr = Bus::mirror(addr, ram.size());
+    return ram.write(addr, data);
+  }
+}
+
+auto HitachiDSP::romRead(uint24 addr, uint8 data) -> uint8 {
+  if(hitachidsp.active() || regs.halt) {
+    addr = Bus::mirror(addr, rom.size());
+  //if(Roms == 2 && mmio.r1f52 == 1 && addr >= (bit::round(rom.size()) >> 1)) return 0x00;
+    return rom.read(addr, data);
+  }
+  if((addr & 0x40ffe0) == 0x00ffe0) return mmio.vector[addr & 0x1f];
+  return data;
+}
+
+auto HitachiDSP::romWrite(uint24 addr, uint8 data) -> void {
+}
+
+auto HitachiDSP::ramRead(uint24 addr, uint8 data) -> uint8 {
+  if(ram.size() == 0) return 0x00;  //not open bus
+  return ram.read(Bus::mirror(addr, ram.size()), data);
+}
+
+auto HitachiDSP::ramWrite(uint24 addr, uint8 data) -> void {
+  if(ram.size() == 0) return;
+  return ram.write(Bus::mirror(addr, ram.size()), data);
+}
+
+auto HitachiDSP::dramRead(uint24 addr, uint8 data) -> uint8 {
+  addr &= 0xfff;
+  if(addr >= 0xc00) return data;
+  return dataRAM[addr];
+}
+
+auto HitachiDSP::dramWrite(uint24 addr, uint8 data) -> void {
+  addr &= 0xfff;
+  if(addr >= 0xc00) return;
+  dataRAM[addr] = data;
+}
+
+auto HitachiDSP::dspRead(uint24 addr, uint8) -> uint8 {
+  addr = 0x7c00 | (addr & 0x03ff);
+
+  //MMIO
+  switch(addr) {
+  case 0x7f40: return mmio.dmaSource >>  0;
+  case 0x7f41: return mmio.dmaSource >>  8;
+  case 0x7f42: return mmio.dmaSource >> 16;
+  case 0x7f43: return mmio.dmaLength >>  0;
+  case 0x7f44: return mmio.dmaLength >>  8;
+  case 0x7f45: return mmio.dmaTarget >>  0;
+  case 0x7f46: return mmio.dmaTarget >>  8;
+  case 0x7f47: return mmio.dmaTarget >> 16;
+  case 0x7f48: return mmio.r1f48;
+  case 0x7f49: return mmio.programOffset >>  0;
+  case 0x7f4a: return mmio.programOffset >>  8;
+  case 0x7f4b: return mmio.programOffset >> 16;
+  case 0x7f4c: return mmio.r1f4c;
+  case 0x7f4d: return mmio.pageNumber >> 0;
+  case 0x7f4e: return mmio.pageNumber >> 8;
+  case 0x7f4f: return mmio.programCounter;
+  case 0x7f50: return mmio.r1f50;
+  case 0x7f51: return mmio.r1f51;
+  case 0x7f52: return mmio.r1f52;
+  case 0x7f53: case 0x7f54: case 0x7f55: case 0x7f56:
+  case 0x7f57: case 0x7f58: case 0x7f59: case 0x7f5a:
+  case 0x7f5b: case 0x7f5c: case 0x7f5d: case 0x7f5e:
+  case 0x7f5f: return ((regs.halt == false) << 6) | ((regs.halt == true) << 1);
+  }
+
+  //Vector
+  if(addr >= 0x7f60 && addr <= 0x7f7f) {
+    return mmio.vector[addr & 0x1f];
+  }
+
+  //GPRs
+  if((addr >= 0x7f80 && addr <= 0x7faf) || (addr >= 0x7fc0 && addr <= 0x7fef)) {
+    uint index = (addr & 0x3f) / 3;        //0..15
+    uint shift = ((addr & 0x3f) % 3) * 8;  //0, 8, 16
+    return regs.gpr[index] >> shift;
+  }
+
+  return 0x00;
+}
+
+auto HitachiDSP::dspWrite(uint24 addr, uint8 data) -> void {
+  addr = 0x7c00 | (addr & 0x03ff);
+
+  //MMIO
+  switch(addr) {
+  case 0x7f40: mmio.dmaSource = (mmio.dmaSource & 0xffff00) | (data <<  0); return;
+  case 0x7f41: mmio.dmaSource = (mmio.dmaSource & 0xff00ff) | (data <<  8); return;
+  case 0x7f42: mmio.dmaSource = (mmio.dmaSource & 0x00ffff) | (data << 16); return;
+  case 0x7f43: mmio.dmaLength = (mmio.dmaLength &   0xff00) | (data <<  0); return;
+  case 0x7f44: mmio.dmaLength = (mmio.dmaLength &   0x00ff) | (data <<  8); return;
+  case 0x7f45: mmio.dmaTarget = (mmio.dmaTarget & 0xffff00) | (data <<  0); return;
+  case 0x7f46: mmio.dmaTarget = (mmio.dmaTarget & 0xff00ff) | (data <<  8); return;
+  case 0x7f47: mmio.dmaTarget = (mmio.dmaTarget & 0x00ffff) | (data << 16);
+    if(regs.halt) mmio.dma = true;
+    return;
+  case 0x7f48: mmio.r1f48 = data & 0x01; return;
+  case 0x7f49: mmio.programOffset = (mmio.programOffset & 0xffff00) | (data <<  0); return;
+  case 0x7f4a: mmio.programOffset = (mmio.programOffset & 0xff00ff) | (data <<  8); return;
+  case 0x7f4b: mmio.programOffset = (mmio.programOffset & 0x00ffff) | (data << 16); return;
+  case 0x7f4c: mmio.r1f4c = data & 0x03; return;
+  case 0x7f4d: mmio.pageNumber = (mmio.pageNumber & 0x7f00) | ((data & 0xff) << 0); return;
+  case 0x7f4e: mmio.pageNumber = (mmio.pageNumber & 0x00ff) | ((data & 0x7f) << 8); return;
+  case 0x7f4f: mmio.programCounter = data;
+    if(regs.halt) {
+      regs.pc = mmio.pageNumber * 256 + mmio.programCounter;
+      regs.halt = false;
+    }
+    return;
+  case 0x7f50: mmio.r1f50 = data & 0x77; return;
+  case 0x7f51: mmio.r1f51 = data & 0x01; return;
+  case 0x7f52: mmio.r1f52 = data & 0x01; return;
+  }
+
+  //Vector
+  if(addr >= 0x7f60 && addr <= 0x7f7f) {
+    mmio.vector[addr & 0x1f] = data;
+    return;
+  }
+
+  //GPRs
+  if((addr >= 0x7f80 && addr <= 0x7faf) || (addr >= 0x7fc0 && addr <= 0x7fef)) {
+    uint index = (addr & 0x3f) / 3;
+    switch((addr & 0x3f) % 3) {
+    case 0: regs.gpr[index] = (regs.gpr[index] & 0xffff00) | (data <<  0); return;
+    case 1: regs.gpr[index] = (regs.gpr[index] & 0xff00ff) | (data <<  8); return;
+    case 2: regs.gpr[index] = (regs.gpr[index] & 0x00ffff) | (data << 16); return;
+    }
+  }
+}
diff --git a/nSide/higan/sfc-balanced/coprocessor/hitachidsp/serialization.cpp b/nSide/higan/sfc-balanced/coprocessor/hitachidsp/serialization.cpp
new file mode 100644
index 0000000..6ac657b
--- /dev/null
+++ b/nSide/higan/sfc-balanced/coprocessor/hitachidsp/serialization.cpp
@@ -0,0 +1,30 @@
+auto HitachiDSP::firmware() const -> vector<uint8> {
+  vector<uint8> buffer;
+  if(!cartridge.has.HitachiDSP) return buffer;
+  buffer.reserve(1024 * 3);
+  for(auto n : range(1024)) {
+    buffer.append(dataROM[n] >>  0);
+    buffer.append(dataROM[n] >>  8);
+    buffer.append(dataROM[n] >> 16);
+  }
+  return buffer;
+}
+
+auto HitachiDSP::serialize(serializer& s) -> void {
+  HG51B::serialize(s);
+  Thread::serialize(s);
+
+  s.integer(mmio.dma);
+  s.integer(mmio.dmaSource);
+  s.integer(mmio.dmaLength);
+  s.integer(mmio.dmaTarget);
+  s.integer(mmio.r1f48);
+  s.integer(mmio.programOffset);
+  s.integer(mmio.r1f4c);
+  s.integer(mmio.pageNumber);
+  s.integer(mmio.programCounter);
+  s.integer(mmio.r1f50);
+  s.integer(mmio.r1f51);
+  s.integer(mmio.r1f52);
+  s.array(mmio.vector);
+}
diff --git a/nSide/higan/sfc-balanced/coprocessor/icd2/icd2.cpp b/nSide/higan/sfc-balanced/coprocessor/icd2/icd2.cpp
new file mode 100644
index 0000000..7d95288
--- /dev/null
+++ b/nSide/higan/sfc-balanced/coprocessor/icd2/icd2.cpp
@@ -0,0 +1,85 @@
+#include <sfc-balanced/sfc.hpp>
+
+namespace SuperFamicom {
+
+ICD2 icd2;
+
+#if defined(SFC_SUPERGAMEBOY)
+
+#include "interface.cpp"
+#include "io.cpp"
+#include "serialization.cpp"
+
+auto ICD2::Enter() -> void {
+  while(true) {
+    if(scheduler.synchronizing()) GameBoy::system.runToSave();
+    scheduler.synchronize();
+    icd2.main();
+  }
+}
+
+auto ICD2::main() -> void {
+  if(r6003 & 0x80) {
+    GameBoy::system.run();
+    step(GameBoy::system._clocksExecuted);
+    GameBoy::system._clocksExecuted = 0;
+  } else {  //DMG halted
+    stream->sample(0.0, 0.0);
+    step(2);  //two clocks per audio sample
+  }
+  synchronize(cpu);
+}
+
+auto ICD2::init() -> void {
+}
+
+auto ICD2::load() -> bool {
+  bind = GameBoy::interface->bind;
+  hook = GameBoy::interface->hook;
+  GameBoy::interface->bind = this;
+  GameBoy::interface->hook = this;
+  GameBoy::interface->load(GameBoy::ID::SuperGameBoy);
+  return cartridge.loadGameBoy();
+}
+
+auto ICD2::unload() -> void {
+  GameBoy::interface->unload();
+  GameBoy::interface->bind = bind;
+  GameBoy::interface->hook = hook;
+}
+
+auto ICD2::power() -> void {
+}
+
+auto ICD2::reset(bool soft) -> void {
+  auto frequency = system.colorburst() * 6.0;
+  create(ICD2::Enter, frequency / 5);
+  if(!soft) stream = Emulator::audio.createStream(2, frequency / 10);
+
+  r6003 = 0x00;
+  r6004 = 0xff;
+  r6005 = 0xff;
+  r6006 = 0xff;
+  r6007 = 0xff;
+  for(auto& r : r7000) r = 0x00;
+  mltReq = 0;
+
+  for(auto& n : output) n = 0xff;
+  readBank = 0;
+  readAddress = 0;
+  writeBank = 0;
+  writeAddress = 0;
+
+  packetSize = 0;
+  joypID = 3;
+  joyp15Lock = 0;
+  joyp14Lock = 0;
+  pulseLock = true;
+
+  GameBoy::system.init();
+  GameBoy::system.power();
+}
+
+#endif
+
+}
diff --git a/nSide/higan/sfc-balanced/coprocessor/icd2/icd2.hpp b/nSide/higan/sfc-balanced/coprocessor/icd2/icd2.hpp
new file mode 100644
index 0000000..d80e5bb
--- /dev/null
+++ b/nSide/higan/sfc-balanced/coprocessor/icd2/icd2.hpp
@@ -0,0 +1,91 @@
+#if defined(SFC_SUPERGAMEBOY)
+
+struct ICD2 : Emulator::Interface::Bind, GameBoy::Interface::Hook, Thread {
+  shared_pointer<Emulator::Stream> stream;
+
+  static auto Enter() -> void;
+  auto main() -> void;
+
+  auto init() -> void;
+  auto load() -> bool;
+  auto unload() -> void;
+  auto power() -> void;
+  auto reset(bool soft = false) -> void;
+
+  //interface.cpp
+  auto lcdScanline() -> void override;
+  auto lcdOutput(uint2 color) -> void override;
+  auto joypWrite(bool p15, bool p14) -> void override;
+
+  auto open(uint id, string name, vfs::file::mode mode, bool required) -> vfs::shared::file override;
+  auto load(uint id, string name, string type) -> maybe<uint> override;
+
+  auto videoRefresh(const uint32* data, uint pitch, uint width, uint height) -> void override;
+  auto audioSample(const double* samples, uint channels) -> void override;
+  auto inputPoll(uint port, uint device, uint id) -> int16 override;
+
+  //io.cpp
+  auto readIO(uint24 addr, uint8 data) -> uint8;
+  auto writeIO(uint24 addr, uint8 data) -> void;
+
+  //serialization.cpp
+  auto serialize(serializer&) -> void;
+
+  uint revision;
+
+private:
+  Emulator::Interface::Bind* bind = nullptr;
+  GameBoy::Interface::Hook* hook = nullptr;
+
+  struct Packet {
+    auto operator[](uint addr) -> uint8& { return data[addr & 15]; }
+    uint8 data[16];
+  };
+  Packet packet[64];
+  uint packetSize;
+
+  uint joypID;
+  bool joyp15Lock;
+  bool joyp14Lock;
+  bool pulseLock;
+  bool strobeLock;
+  bool packetLock;
+  Packet joypPacket;
+  uint8 packetOffset;
+  uint8 bitData, bitOffset;
+
+  uint8 r6003;      //control port
+  uint8 r6004;      //joypad 1
+  uint8 r6005;      //joypad 2
+  uint8 r6006;      //joypad 3
+  uint8 r6007;      //joypad 4
+  uint8 r7000[16];  //JOYP packet data
+  uint8 mltReq;     //number of active joypads
+
+  uint8 output[4 * 512];
+  uint readBank;
+  uint readAddress;
+  uint writeBank;
+  uint writeAddress;
+};
+
+#else
+
+struct ICD2 : Thread {
+  auto init() -> void {}
+  auto load() -> void {}
+  auto unload() -> void {}
+  auto power() -> void {}
+  auto reset() -> void {}
+
+  auto readIO(uint24, uint8) -> uint8 { return 0; }
+  auto writeIO(uint24, uint8) -> void { return; }
+
+  auto serialize(serializer&) -> void {}
+
+  uint revision;
+};
+
+#endif
+
+extern ICD2 icd2;
diff --git a/nSide/higan/sfc-balanced/coprocessor/icd2/interface.cpp b/nSide/higan/sfc-balanced/coprocessor/icd2/interface.cpp
new file mode 100644
index 0000000..a4ca83c
--- /dev/null
+++ b/nSide/higan/sfc-balanced/coprocessor/icd2/interface.cpp
@@ -0,0 +1,129 @@
+auto ICD2::lcdScanline() -> void {
+  if(GameBoy::ppu.status.ly > 143) return;  //Vblank
+  if((GameBoy::ppu.status.ly & 7) == 0) {
+    writeBank = (writeBank + 1) & 3;
+    writeAddress = 0;
+  }
+}
+
+auto ICD2::lcdOutput(uint2 color) -> void {
+  uint y = writeAddress / 160;
+  uint x = writeAddress % 160;
+  uint addr = writeBank * 512 + y * 2 + x / 8 * 16;
+  output[addr + 0] = (output[addr + 0] << 1) | (bool)(color & 1);
+  output[addr + 1] = (output[addr + 1] << 1) | (bool)(color & 2);
+  writeAddress = (writeAddress + 1) % 1280;
+}
+
+auto ICD2::joypWrite(bool p15, bool p14) -> void {
+  //joypad handling
+  if(p15 == 1 && p14 == 1) {
+    if(joyp15Lock == 0 && joyp14Lock == 0) {
+      joyp15Lock = 1;
+      joyp14Lock = 1;
+      joypID = (joypID + 1) & 3;
+    }
+  }
+
+  if(p15 == 0 && p14 == 1) joyp15Lock = 0;
+  if(p15 == 1 && p14 == 0) joyp14Lock = 0;
+
+  //packet handling
+  if(p15 == 0 && p14 == 0) {  //pulse
+    pulseLock = false;
+    packetOffset = 0;
+    bitOffset = 0;
+    strobeLock = true;
+    packetLock = false;
+    return;
+  }
+
+  if(pulseLock) return;
+
+  if(p15 == 1 && p14 == 1) {
+    strobeLock = false;
+    return;
+  }
+
+  if(strobeLock) {
+    if(p15 == 1 || p14 == 1) {  //malformed packet
+      packetLock = false;
+      pulseLock = true;
+      bitOffset = 0;
+      packetOffset = 0;
+    } else {
+      return;
+    }
+  }
+
+  //p15:1, p14:0 = 0
+  //p15:0, p14:1 = 1
+  bool bit = (p15 == 0);
+  strobeLock = true;
+
+  if(packetLock) {
+    if(p15 == 1 && p14 == 0) {
+      if((joypPacket[0] >> 3) == 0x11) {
+        mltReq = joypPacket[1] & 3;
+        if(mltReq == 2) mltReq = 3;
+        joypID = 0;
+      }
+
+      if(packetSize < 64) packet[packetSize++] = joypPacket;
+      packetLock = false;
+      pulseLock = true;
+    }
+    return;
+  }
+
+  bitData = (bit << 7) | (bitData >> 1);
+  if(++bitOffset < 8) return;
+
+  bitOffset = 0;
+  joypPacket[packetOffset] = bitData;
+  if(++packetOffset < 16) return;
+  packetLock = true;
+}
+
+auto ICD2::open(uint id, string name, vfs::file::mode mode, bool required) -> vfs::shared::file {
+  //redirect system folder to cartridge folder:
+  //expects "GameBoy.sys"; but this would be "Super Famicom.sys"; redirect to "Super Game Boy.sfc/"
+  if(id == ID::System) id = cartridge.pathID();
+  return interface->open(id, name, mode, required);
+}
+
+auto ICD2::load(uint id, string name, string type) -> maybe<uint> {
+  return interface->load(id, name, type);
+}
+
+auto ICD2::videoRefresh(const uint32* data, uint pitch, uint width, uint height) -> void {
+}
+
+auto ICD2::audioSample(const double* samples, uint channels) -> void {
+  stream->write(samples);
+}
+
+auto ICD2::inputPoll(uint port, uint device, uint id) -> int16 {
+  GameBoy::cpu.status.mltReq = joypID & mltReq;
+
+  uint data = 0x00;
+  switch(joypID & mltReq) {
+  case 0: data = ~r6004; break;
+  case 1: data = ~r6005; break;
+  case 2: data = ~r6006; break;
+  case 3: data = ~r6007; break;
+  }
+
+  switch((GameBoy::Input)id) {
+  case GameBoy::Input::Start:  return (bool)(data & 0x80);
+  case GameBoy::Input::Select: return (bool)(data & 0x40);
+  case GameBoy::Input::B:      return (bool)(data & 0x20);
+  case GameBoy::Input::A:      return (bool)(data & 0x10);
+  case GameBoy::Input::Down:   return (bool)(data & 0x08);
+  case GameBoy::Input::Up:     return (bool)(data & 0x04);
+  case GameBoy::Input::Left:   return (bool)(data & 0x02);
+  case GameBoy::Input::Right:  return (bool)(data & 0x01);
+  }
+
+  return 0;
+}
diff --git a/nSide/higan/sfc-balanced/coprocessor/icd2/io.cpp b/nSide/higan/sfc-balanced/coprocessor/icd2/io.cpp
new file mode 100644
index 0000000..5155182
--- /dev/null
+++ b/nSide/higan/sfc-balanced/coprocessor/icd2/io.cpp
@@ -0,0 +1,74 @@
+auto ICD2::readIO(uint24 addr, uint8 data) -> uint8 {
+  addr &= 0x40ffff;
+
+  //LY counter
+  if(addr == 0x6000) {
+    uint y = min((uint8)143, GameBoy::ppu.status.ly);
+    return (y & ~7) | writeBank;
+  }
+
+  //command ready port
+  if(addr == 0x6002) {
+    data = packetSize > 0;
+    if(data) {
+      for(auto n : range(16)) r7000[n] = packet[0][n];
+      packetSize--;
+      for(auto n : range(packetSize)) packet[n] = packet[n + 1];
+    }
+    return data;
+  }
+
+  //ICD2 revision
+  if(addr == 0x600f) {
+    return 0x21;
+  }
+
+  //command port
+  if((addr & 0x40fff0) == 0x7000) {
+    return r7000[addr & 15];
+  }
+
+  //VRAM port
+  if(addr == 0x7800) {
+    data = output[readBank * 512 + readAddress];
+    readAddress = (readAddress + 1) & 511;
+    return data;
+  }
+
+  return 0x00;
+}
+
+auto ICD2::writeIO(uint24 addr, uint8 data) -> void {
+  addr &= 0xffff;
+
+  //VRAM port
+  if(addr == 0x6001) {
+    readBank = data & 3;
+    readAddress = 0;
+    return;
+  }
+
+  //control port
+  //d7: 0 = halt, 1 = reset
+  //d5,d4: 0 = 1-player, 1 = 2-player, 2 = 4-player, 3 = ???
+  //d1,d0: 0 = frequency divider (clock rate adjust)
+  if(addr == 0x6003) {
+    if((r6003 & 0x80) == 0x00 && (data & 0x80) == 0x80) {
+      reset(true);
+    }
+    auto frequency = system.colorburst() * 6.0;
+    switch(data & 3) {
+    case 0: setFrequency(frequency / 4); break;  //fast (glitchy, even on real hardware)
+    case 1: setFrequency(frequency / 5); break;  //normal
+    case 2: setFrequency(frequency / 7); break;  //slow
+    case 3: setFrequency(frequency / 9); break;  //very slow
+    }
+    r6003 = data;
+    return;
+  }
+
+  if(addr == 0x6004) { r6004 = data; return; }  //joypad 1
+  if(addr == 0x6005) { r6005 = data; return; }  //joypad 2
+  if(addr == 0x6006) { r6006 = data; return; }  //joypad 3
+  if(addr == 0x6007) { r6007 = data; return; }  //joypad 4
+}
diff --git a/nSide/higan/sfc-balanced/coprocessor/icd2/serialization.cpp b/nSide/higan/sfc-balanced/coprocessor/icd2/serialization.cpp
new file mode 100644
index 0000000..10e0f67
--- /dev/null
+++ b/nSide/higan/sfc-balanced/coprocessor/icd2/serialization.cpp
@@ -0,0 +1,32 @@
+auto ICD2::serialize(serializer& s) -> void {
+  Thread::serialize(s);
+  GameBoy::system.serializeAll(s);
+
+  for(auto n : range(64)) s.array(packet[n].data);
+  s.integer(packetSize);
+
+  s.integer(joypID);
+  s.integer(joyp15Lock);
+  s.integer(joyp14Lock);
+  s.integer(pulseLock);
+  s.integer(strobeLock);
+  s.integer(packetLock);
+  s.array(joypPacket.data);
+  s.integer(packetOffset);
+  s.integer(bitData);
+  s.integer(bitOffset);
+
+  s.integer(r6003);
+  s.integer(r6004);
+  s.integer(r6005);
+  s.integer(r6006);
+  s.integer(r6007);
+  s.array(r7000);
+  s.integer(mltReq);
+
+  s.array(output);
+  s.integer(readBank);
+  s.integer(readAddress);
+  s.integer(writeBank);
+  s.integer(writeAddress);
+}
diff --git a/nSide/higan/sfc-balanced/coprocessor/mcc/mcc.cpp b/nSide/higan/sfc-balanced/coprocessor/mcc/mcc.cpp
new file mode 100644
index 0000000..8ffcfed
--- /dev/null
+++ b/nSide/higan/sfc-balanced/coprocessor/mcc/mcc.cpp
@@ -0,0 +1,136 @@
+#include <sfc-balanced/sfc.hpp>
+
+namespace SuperFamicom {
+
+#include "serialization.cpp"
+MCC mcc;
+
+auto MCC::init() -> void {
+}
+
+auto MCC::load() -> void {
+}
+
+auto MCC::unload() -> void {
+  rom.reset();
+  ram.reset();
+}
+
+auto MCC::power() -> void {
+}
+
+auto MCC::reset() -> void {
+  for(auto n : range(16)) r[n] = 0x00;
+  r[0x07] = 0x80;
+  r[0x08] = 0x80;
+  commit();
+}
+
+auto MCC::memoryAccess(bool write, Memory& memory, uint24 addr, uint8 data) -> uint8 {
+  addr = bus.mirror(addr, memory.size());
+  if(!write) {
+    return memory.read(addr, data);
+  } else {
+    memory.write(addr, data);
+  }
+}
+
+//map address=00-3f,80-bf:8000-ffff mask=0x408000
+//map address=40-7d,c0-ff:0000-ffff
+auto MCC::mcuAccess(bool write, uint24 addr, uint8 data) -> uint8 {
+  if(addr < 0x400000) {
+    //note: manifest maps 00-3f,80-bf:8000-ffff mask=0x408000 => 00-3f:0000-ffff
+    //the intention is consistency in pre-decoding as much as possible
+    //however, the MCC code is intended to be rewritten; and is too convoluted
+    //so for right now, I'm simply transforming it back to its original state
+    //this is very wasteful; but will be addressed once things are rewritten
+    addr = ((addr & 0x200000) << 2) | ((addr & 0x1f8000) << 1) | 0x8000 | (addr & 0x7fff);
+  }
+
+  if((addr & 0xe08000) == 0x008000) {  //$00-1f:8000-ffff
+    if(r07 == 1) {
+      addr = ((addr & 0x1f0000) >> 1) | (addr & 0x7fff);
+      return memoryAccess(write, rom, addr, data);
+    }
+  }
+
+  if((addr & 0xe08000) == 0x808000) {  //$80-9f:8000-ffff
+    if(r08 == 1) {
+      addr = ((addr & 0x1f0000) >> 1) | (addr & 0x7fff);
+      return memoryAccess(write, rom, addr, data);
+    }
+  }
+
+  if((addr & 0xf00000) == 0x400000) {  //$40-4f:0000-ffff
+    if(r05 == 0) return memoryAccess(write, ram, addr & 0x0fffff, data);
+  }
+
+  if((addr & 0xf00000) == 0x500000) {  //$50-5f:0000-ffff
+    if(r06 == 0) return memoryAccess(write, ram, addr & 0x0fffff, data);
+  }
+
+  if((addr & 0xf00000) == 0x600000) {  //$60-6f:0000-ffff
+    if(r03 == 1) return memoryAccess(write, ram, addr & 0x0fffff, data);
+  }
+
+  if((addr & 0xf80000) == 0x700000) {  //$70-77:0000-ffff
+    return memoryAccess(write, ram, addr & 0x07ffff, data);
+  }
+
+  if(((addr & 0x408000) == 0x008000)  //$00-3f,80-bf:8000-ffff
+  || ((addr & 0x400000) == 0x400000)  //$40-7f,c0-ff:0000-ffff
+  ) {
+    if(r02 == 0) addr = ((addr & 0x7f0000) >> 1) | (addr & 0x7fff);
+    Memory& memory = (r01 == 0 ? (Memory&)bsmemory : (Memory&)ram);
+    return memoryAccess(write, memory, addr & 0x7fffff, data);
+  }
+
+  return 0x00;
+}
+
+auto MCC::mcuRead(uint24 addr, uint8 data) -> uint8 {
+  return mcuAccess(false, addr, data);
+}
+
+auto MCC::mcuWrite(uint24 addr, uint8 data) -> void {
+  mcuAccess(true, addr, data);
+}
+
+auto MCC::read(uint24 addr, uint8 data) -> uint8 {
+  if((addr & 0xf0ffff) == 0x005000) {  //$00-0f:5000
+    uint8 n = (addr >> 16) & 15;
+    return r[n];
+  }
+
+  return data;
+}
+
+auto MCC::write(uint24 addr, uint8 data) -> void {
+  if((addr & 0xf0ffff) == 0x005000) {  //$00-0f:5000
+    uint8 n = (addr >> 16) & 15;
+    r[n] = data;
+    if(n == 0x0e && data & 0x80) commit();
+    return;
+  }
+}
+
+auto MCC::commit() -> void {
+  r00 = r[0x00] & 0x80;
+  r01 = r[0x01] & 0x80;
+  r02 = r[0x02] & 0x80;
+  r03 = r[0x03] & 0x80;
+  r04 = r[0x04] & 0x80;
+  r05 = r[0x05] & 0x80;
+  r06 = r[0x06] & 0x80;
+  r07 = r[0x07] & 0x80;
+  r08 = r[0x08] & 0x80;
+  r09 = r[0x09] & 0x80;
+  r0a = r[0x0a] & 0x80;
+  r0b = r[0x0b] & 0x80;
+  r0c = r[0x0c] & 0x80;
+  r0d = r[0x0d] & 0x80;
+  r0e = r[0x0e] & 0x80;
+  r0f = r[0x0f] & 0x80;
+}
+
+}
diff --git a/nSide/higan/sfc-balanced/coprocessor/mcc/mcc.hpp b/nSide/higan/sfc-balanced/coprocessor/mcc/mcc.hpp
new file mode 100644
index 0000000..0558b3c
--- /dev/null
+++ b/nSide/higan/sfc-balanced/coprocessor/mcc/mcc.hpp
@@ -0,0 +1,34 @@
+//the MCC is the custom logic chip inside the BS-X Satellaview cartridge
+
+struct MCC {
+  MappedRAM rom;
+  MappedRAM ram;
+
+  auto init() -> void;
+  auto load() -> void;
+  auto unload() -> void;
+  auto power() -> void;
+  auto reset() -> void;
+
+  auto memoryAccess(bool write, Memory& memory, uint24 addr, uint8 data) -> uint8;
+  auto mcuAccess(bool write, uint24 addr, uint8 data) -> uint8;
+
+  auto mcuRead(uint24 addr, uint8 data) -> uint8;
+  auto mcuWrite(uint24 addr, uint8 data) -> void;
+
+  auto read(uint24 addr, uint8 data) -> uint8;
+  auto write(uint24 addr, uint8 data) -> void;
+
+  auto commit() -> void;
+
+  auto serialize(serializer&) -> void;
+
+private:
+  uint8 r[16];
+  bool r00, r01, r02, r03;
+  bool r04, r05, r06, r07;
+  bool r08, r09, r0a, r0b;
+  bool r0c, r0d, r0e, r0f;
+};
+
+extern MCC mcc;
diff --git a/nSide/higan/sfc-balanced/coprocessor/mcc/serialization.cpp b/nSide/higan/sfc-balanced/coprocessor/mcc/serialization.cpp
new file mode 100644
index 0000000..4558f4d
--- /dev/null
+++ b/nSide/higan/sfc-balanced/coprocessor/mcc/serialization.cpp
@@ -0,0 +1,3 @@
+auto MCC::serialize(serializer& s) -> void {
+  s.array(ram.data(), ram.size());
+}
diff --git a/nSide/higan/sfc-balanced/coprocessor/msu1/msu1.cpp b/nSide/higan/sfc-balanced/coprocessor/msu1/msu1.cpp
new file mode 100644
index 0000000..f933409
--- /dev/null
+++ b/nSide/higan/sfc-balanced/coprocessor/msu1/msu1.cpp
@@ -0,0 +1,185 @@
+#include <sfc-balanced/sfc.hpp>
+
+namespace SuperFamicom {
+
+MSU1 msu1;
+
+#include "serialization.cpp"
+
+auto MSU1::Enter() -> void {
+  while(true) scheduler.synchronize(), msu1.main();
+}
+
+auto MSU1::main() -> void {
+  double left = 0.0;
+  double right = 0.0;
+
+  if(io.audioPlay) {
+    if(audioFile) {
+      if(audioFile->end()) {
+        if(!io.audioRepeat) {
+          io.audioPlay = false;
+          audioFile->seek(io.audioPlayOffset = 8);
+        } else {
+          audioFile->seek(io.audioPlayOffset = io.audioLoopOffset);
+        }
+      } else {
+        io.audioPlayOffset += 4;
+        left  = (double)(int16)audioFile->readl(2) / 32768.0 * (double)io.audioVolume / 255.0;
+        right = (double)(int16)audioFile->readl(2) / 32768.0 * (double)io.audioVolume / 255.0;
+        if(dsp.mute()) left = 0, right = 0;
+      }
+    } else {
+      io.audioPlay = false;
+    }
+  }
+
+  stream->sample(left, right);
+  step(1);
+  synchronize(cpu);
+}
+
+auto MSU1::init() -> void {
+}
+
+auto MSU1::load() -> void {
+}
+
+auto MSU1::unload() -> void {
+  dataFile.reset();
+  audioFile.reset();
+}
+
+auto MSU1::power() -> void {
+}
+
+auto MSU1::reset() -> void {
+  create(MSU1::Enter, 44100);
+  stream = Emulator::audio.createStream(2, 44100.0);
+
+  io.dataSeekOffset = 0;
+  io.dataReadOffset = 0;
+
+  io.audioPlayOffset = 0;
+  io.audioLoopOffset = 0;
+
+  io.audioTrack = 0;
+  io.audioVolume = 0;
+
+  io.audioResumeTrack = ~0;  //no resume
+  io.audioResumeOffset = 0;
+
+  io.audioError = false;
+  io.audioPlay = false;
+  io.audioRepeat = false;
+  io.audioBusy = false;
+  io.dataBusy = false;
+
+  dataOpen();
+  audioOpen();
+}
+
+auto MSU1::dataOpen() -> void {
+  dataFile.reset();
+  auto document = BML::unserialize(cartridge.information.manifest.cartridge);
+  string name = document["board/msu1/rom/name"].text();
+  if(!name) name = "msu1.rom";
+  if(dataFile = interface->open(ID::SuperFamicom, name, File::Read)) {
+    dataFile->seek(io.dataReadOffset);
+  }
+}
+
+auto MSU1::audioOpen() -> void {
+  audioFile.reset();
+  auto document = BML::unserialize(cartridge.information.manifest.cartridge);
+  string name = {"track-", io.audioTrack, ".pcm"};
+  for(auto track : document.find("board/msu1/track")) {
+    if(track["number"].natural() != io.audioTrack) continue;
+    name = track["name"].text();
+    break;
+  }
+  if(audioFile = interface->open(ID::SuperFamicom, name, File::Read)) {
+    if(audioFile->size() >= 8) {
+      uint32 header = audioFile->readm(4);
+      if(header == 0x4d535531) {  //"MSU1"
+        io.audioLoopOffset = 8 + audioFile->readl(4) * 4;
+        if(io.audioLoopOffset > audioFile->size()) io.audioLoopOffset = 8;
+        io.audioError = false;
+        audioFile->seek(io.audioPlayOffset);
+        return;
+      }
+    }
+    audioFile.reset();
+  }
+  io.audioError = true;
+}
+
+auto MSU1::readIO(uint24 addr, uint8) -> uint8 {
+  cpu.synchronize(*this);
+
+  switch(0x2000 | (addr & 7)) {
+  case 0x2000:
+    return (
+      Revision       << 0
+    | io.audioError  << 3
+    | io.audioPlay   << 4
+    | io.audioRepeat << 5
+    | io.audioBusy   << 6
+    | io.dataBusy    << 7
+    );
+  case 0x2001:
+    if(io.dataBusy) return 0x00;
+    if(!dataFile) return 0x00;
+    if(dataFile->end()) return 0x00;
+    io.dataReadOffset++;
+    return dataFile->read();
+  case 0x2002: return 'S';
+  case 0x2003: return '-';
+  case 0x2004: return 'M';
+  case 0x2005: return 'S';
+  case 0x2006: return 'U';
+  case 0x2007: return '1';
+  }
+}
+
+auto MSU1::writeIO(uint24 addr, uint8 data) -> void {
+  cpu.synchronize(*this);
+
+  switch(0x2000 | (addr & 7)) {
+  case 0x2000: io.dataSeekOffset.byte(0) = data; break;
+  case 0x2001: io.dataSeekOffset.byte(1) = data; break;
+  case 0x2002: io.dataSeekOffset.byte(2) = data; break;
+  case 0x2003: io.dataSeekOffset.byte(3) = data;
+    io.dataReadOffset = io.dataSeekOffset;
+    if(dataFile) dataFile->seek(io.dataReadOffset);
+    break;
+  case 0x2004: io.audioTrack.byte(0) = data; break;
+  case 0x2005: io.audioTrack.byte(1) = data;
+    io.audioPlay = false;
+    io.audioRepeat = false;
+    io.audioPlayOffset = 8;
+    if(io.audioTrack == io.audioResumeTrack) {
+      io.audioPlayOffset = io.audioResumeOffset;
+      io.audioResumeTrack = ~0;  //erase resume track
+      io.audioResumeOffset = 0;
+    }
+    audioOpen();
+    break;
+  case 0x2006:
+    io.audioVolume = data;
+    break;
+  case 0x2007:
+    if(io.audioBusy) break;
+    if(io.audioError) break;
+    io.audioPlay = data.bit(0);
+    io.audioRepeat = data.bit(1);
+    bool audioResume = data.bit(2);
+    if(!io.audioPlay && audioResume) {
+      io.audioResumeTrack = io.audioTrack;
+      io.audioResumeOffset = io.audioPlayOffset;
+    }
+    break;
+  }
+}
+
+}
diff --git a/nSide/higan/sfc-balanced/coprocessor/msu1/msu1.hpp b/nSide/higan/sfc-balanced/coprocessor/msu1/msu1.hpp
new file mode 100644
index 0000000..22a2f65
--- /dev/null
+++ b/nSide/higan/sfc-balanced/coprocessor/msu1/msu1.hpp
@@ -0,0 +1,54 @@
+struct MSU1 : Thread {
+  shared_pointer<Emulator::Stream> stream;
+
+  static auto Enter() -> void;
+  auto main() -> void;
+  auto init() -> void;
+  auto load() -> void;
+  auto unload() -> void;
+  auto power() -> void;
+  auto reset() -> void;
+
+  auto dataOpen() -> void;
+  auto audioOpen() -> void;
+
+  auto readIO(uint24 addr, uint8 data) -> uint8;
+  auto writeIO(uint24 addr, uint8 data) -> void;
+
+  auto serialize(serializer&) -> void;
+
+private:
+  vfs::shared::file dataFile;
+  vfs::shared::file audioFile;
+
+  enum Flag : uint {
+    Revision       = 0x02,  //max: 0x07
+    AudioError     = 0x08,
+    AudioPlaying   = 0x10,
+    AudioRepeating = 0x20,
+    AudioBusy      = 0x40,
+    DataBusy       = 0x80,
+  };
+
+  struct IO {
+    uint32 dataSeekOffset;
+    uint32 dataReadOffset;
+
+    uint32 audioPlayOffset;
+    uint32 audioLoopOffset;
+
+    uint16 audioTrack;
+    uint8 audioVolume;
+
+    uint32 audioResumeTrack;
+    uint32 audioResumeOffset;
+
+    bool audioError;
+    bool audioPlay;
+    bool audioRepeat;
+    bool audioBusy;
+    bool dataBusy;
+  } io;
+};
+
+extern MSU1 msu1;
diff --git a/nSide/higan/sfc-balanced/coprocessor/msu1/serialization.cpp b/nSide/higan/sfc-balanced/coprocessor/msu1/serialization.cpp
new file mode 100644
index 0000000..798cf6c
--- /dev/null
+++ b/nSide/higan/sfc-balanced/coprocessor/msu1/serialization.cpp
@@ -0,0 +1,24 @@
+auto MSU1::serialize(serializer& s) -> void {
+  Thread::serialize(s);
+
+  s.integer(io.dataSeekOffset);
+  s.integer(io.dataReadOffset);
+
+  s.integer(io.audioPlayOffset);
+  s.integer(io.audioLoopOffset);
+
+  s.integer(io.audioTrack);
+  s.integer(io.audioVolume);
+
+  s.integer(io.audioResumeTrack);
+  s.integer(io.audioResumeOffset);
+
+  s.integer(io.audioError);
+  s.integer(io.audioPlay);
+  s.integer(io.audioRepeat);
+  s.integer(io.audioBusy);
+  s.integer(io.dataBusy);
+
+  dataOpen();
+  audioOpen();
+}
diff --git a/nSide/higan/sfc-balanced/coprocessor/necdsp/necdsp.cpp b/nSide/higan/sfc-balanced/coprocessor/necdsp/necdsp.cpp
new file mode 100644
index 0000000..7e37868
--- /dev/null
+++ b/nSide/higan/sfc-balanced/coprocessor/necdsp/necdsp.cpp
@@ -0,0 +1,63 @@
+#include <sfc-balanced/sfc.hpp>
+
+namespace SuperFamicom {
+
+#include "serialization.cpp"
+NECDSP necdsp;
+
+auto NECDSP::Enter() -> void {
+  while(true) scheduler.synchronize(), necdsp.main();
+}
+
+auto NECDSP::main() -> void {
+  exec();
+  step(1);
+  synchronize(cpu);
+}
+
+auto NECDSP::read(uint24 addr, uint8) -> uint8 {
+  cpu.synchronize(*this);
+  if(addr & 1) {
+    return uPD96050::readSR();
+  } else {
+    return uPD96050::readDR();
+  }
+}
+
+auto NECDSP::write(uint24 addr, uint8 data) -> void {
+  cpu.synchronize(*this);
+  if(addr & 1) {
+    return uPD96050::writeSR(data);
+  } else {
+    return uPD96050::writeDR(data);
+  }
+}
+
+auto NECDSP::readRAM(uint24 addr, uint8) -> uint8 {
+  cpu.synchronize(*this);
+  return uPD96050::readDP(addr);
+}
+
+auto NECDSP::writeRAM(uint24 addr, uint8 data) -> void {
+  cpu.synchronize(*this);
+  return uPD96050::writeDP(addr, data);
+}
+
+auto NECDSP::init() -> void {
+}
+
+auto NECDSP::load() -> void {
+}
+
+auto NECDSP::unload() -> void {
+}
+
+auto NECDSP::power() -> void {
+}
+
+auto NECDSP::reset() -> void {
+  create(NECDSP::Enter, Frequency);
+  uPD96050::power();
+}
+
+}
diff --git a/nSide/higan/sfc-balanced/coprocessor/necdsp/necdsp.hpp b/nSide/higan/sfc-balanced/coprocessor/necdsp/necdsp.hpp
new file mode 100644
index 0000000..9967b21
--- /dev/null
+++ b/nSide/higan/sfc-balanced/coprocessor/necdsp/necdsp.hpp
@@ -0,0 +1,23 @@
+struct NECDSP : Processor::uPD96050, Thread {
+  static auto Enter() -> void;
+  auto main() -> void;
+
+  auto read(uint24 addr, uint8 data) -> uint8;
+  auto write(uint24 addr, uint8 data) -> void;
+
+  auto readRAM(uint24 addr, uint8 data) -> uint8;
+  auto writeRAM(uint24 addr, uint8 data) -> void;
+
+  auto init() -> void;
+  auto load() -> void;
+  auto unload() -> void;
+  auto power() -> void;
+  auto reset() -> void;
+
+  auto firmware() const -> vector<uint8>;
+  auto serialize(serializer&) -> void;
+
+  uint Frequency = 0;
+};
+
+extern NECDSP necdsp;
diff --git a/nSide/higan/sfc-balanced/coprocessor/necdsp/serialization.cpp b/nSide/higan/sfc-balanced/coprocessor/necdsp/serialization.cpp
new file mode 100644
index 0000000..8708471
--- /dev/null
+++ b/nSide/higan/sfc-balanced/coprocessor/necdsp/serialization.cpp
@@ -0,0 +1,25 @@
+auto NECDSP::firmware() const -> vector<uint8> {
+  vector<uint8> buffer;
+  if(!cartridge.has.NECDSP) return buffer;
+  uint plength = 2048, dlength = 1024;
+  if(revision == Revision::uPD96050) plength = 16384, dlength = 2048;
+  buffer.reserve(plength * 3 + dlength * 2);
+
+  for(auto n : range(plength)) {
+    buffer.append(programROM[n] >>  0);
+    buffer.append(programROM[n] >>  8);
+    buffer.append(programROM[n] >> 16);
+  }
+
+  for(auto n : range(dlength)) {
+    buffer.append(dataROM[n] >> 0);
+    buffer.append(dataROM[n] >> 8);
+  }
+
+  return buffer;
+}
+
+auto NECDSP::serialize(serializer& s) -> void {
+  uPD96050::serialize(s);
+  Thread::serialize(s);
+}
diff --git a/nSide/higan/sfc-balanced/coprocessor/nss/nss.cpp b/nSide/higan/sfc-balanced/coprocessor/nss/nss.cpp
new file mode 100644
index 0000000..8e97901
--- /dev/null
+++ b/nSide/higan/sfc-balanced/coprocessor/nss/nss.cpp
@@ -0,0 +1,33 @@
+#include <sfc-balanced/sfc.hpp>
+
+namespace SuperFamicom {
+
+NSS nss;
+
+auto NSS::init() -> void {
+}
+
+auto NSS::load() -> void {
+}
+
+auto NSS::unload() -> void {
+}
+
+auto NSS::power() -> void {
+}
+
+auto NSS::reset() -> void {
+}
+
+auto NSS::setDip(uint16 dip) -> void {
+  this->dip = dip;
+}
+
+auto NSS::read(uint24, uint8) -> uint8 {
+  return dip;
+}
+
+auto NSS::write(uint24, uint8) -> void {
+}
+
+}
diff --git a/nSide/higan/sfc-balanced/coprocessor/nss/nss.hpp b/nSide/higan/sfc-balanced/coprocessor/nss/nss.hpp
new file mode 100644
index 0000000..cbdb0cd
--- /dev/null
+++ b/nSide/higan/sfc-balanced/coprocessor/nss/nss.hpp
@@ -0,0 +1,15 @@
+struct NSS {
+  auto init() -> void;
+  auto load() -> void;
+  auto unload() -> void;
+  auto power() -> void;
+  auto reset() -> void;
+
+  auto setDip(uint16 dip) -> void;
+  auto read(uint24 addr, uint8 data) -> uint8;
+  auto write(uint24 addr, uint8 data) -> void;
+
+  uint8 dip = 0x00;
+};
+
+extern NSS nss;
diff --git a/nSide/higan/sfc-balanced/coprocessor/obc1/obc1.cpp b/nSide/higan/sfc-balanced/coprocessor/obc1/obc1.cpp
new file mode 100644
index 0000000..dcf9109
--- /dev/null
+++ b/nSide/higan/sfc-balanced/coprocessor/obc1/obc1.cpp
@@ -0,0 +1,79 @@
+#include <sfc-balanced/sfc.hpp>
+
+namespace SuperFamicom {
+
+#include "serialization.cpp"
+OBC1 obc1;
+
+auto OBC1::init() -> void {
+}
+
+auto OBC1::load() -> void {
+}
+
+auto OBC1::unload() -> void {
+  ram.reset();
+}
+
+auto OBC1::power() -> void {
+}
+
+auto OBC1::reset() -> void {
+  status.baseptr = (ramRead(0x1ff5) & 1) ? 0x1800 : 0x1c00;
+  status.address = (ramRead(0x1ff6) & 0x7f);
+  status.shift   = (ramRead(0x1ff6) & 3) << 1;
+}
+
+auto OBC1::read(uint24 addr, uint8) -> uint8 {
+  addr &= 0x1fff;
+
+  switch(addr) {
+  case 0x1ff0: return ramRead(status.baseptr + (status.address << 2) + 0);
+  case 0x1ff1: return ramRead(status.baseptr + (status.address << 2) + 1);
+  case 0x1ff2: return ramRead(status.baseptr + (status.address << 2) + 2);
+  case 0x1ff3: return ramRead(status.baseptr + (status.address << 2) + 3);
+  case 0x1ff4: return ramRead(status.baseptr + (status.address >> 2) + 0x200);
+  }
+
+  return ramRead(addr);
+}
+
+auto OBC1::write(uint24 addr, uint8 data) -> void {
+  addr &= 0x1fff;
+
+  switch(addr) {
+  case 0x1ff0: ramWrite(status.baseptr + (status.address << 2) + 0, data); return;
+  case 0x1ff1: ramWrite(status.baseptr + (status.address << 2) + 1, data); return;
+  case 0x1ff2: ramWrite(status.baseptr + (status.address << 2) + 2, data); return;
+  case 0x1ff3: ramWrite(status.baseptr + (status.address << 2) + 3, data); return;
+  case 0x1ff4: {
+    uint8 temp = ramRead(status.baseptr + (status.address >> 2) + 0x200);
+    temp = (temp & ~(3 << status.shift)) | ((data & 3) << status.shift);
+    ramWrite(status.baseptr + (status.address >> 2) + 0x200, temp);
+  } return;
+  case 0x1ff5:
+    status.baseptr = (data & 1) ? 0x1800 : 0x1c00;
+    ramWrite(addr, data);
+    return;
+  case 0x1ff6:
+    status.address = (data & 0x7f);
+    status.shift   = (data & 3) << 1;
+    ramWrite(addr, data);
+    return;
+  case 0x1ff7:
+    ramWrite(addr, data);
+    return;
+  }
+
+  return ramWrite(addr, data);
+}
+
+auto OBC1::ramRead(uint addr) -> uint8 {
+  return ram.read(addr & 0x1fff);
+}
+
+auto OBC1::ramWrite(uint addr, uint8 data) -> void {
+  ram.write(addr & 0x1fff, data);
+}
+
+}
diff --git a/nSide/higan/sfc-balanced/coprocessor/obc1/obc1.hpp b/nSide/higan/sfc-balanced/coprocessor/obc1/obc1.hpp
new file mode 100644
index 0000000..9ada171
--- /dev/null
+++ b/nSide/higan/sfc-balanced/coprocessor/obc1/obc1.hpp
@@ -0,0 +1,26 @@
+struct OBC1 {
+  auto init() -> void;
+  auto load() -> void;
+  auto unload() -> void;
+  auto power() -> void;
+  auto reset() -> void;
+
+  auto read(uint24 addr, uint8 data) -> uint8;
+  auto write(uint24 addr, uint8 data) -> void;
+
+  auto serialize(serializer&) -> void;
+
+  MappedRAM ram;
+
+private:
+  auto ramRead(uint addr) -> uint8;
+  auto ramWrite(uint addr, uint8 data) -> void;
+
+  struct {
+    uint16 address;
+    uint16 baseptr;
+    uint16 shift;
+  } status;
+};
+
+extern OBC1 obc1;
diff --git a/nSide/higan/sfc-balanced/coprocessor/obc1/serialization.cpp b/nSide/higan/sfc-balanced/coprocessor/obc1/serialization.cpp
new file mode 100644
index 0000000..851a16d
--- /dev/null
+++ b/nSide/higan/sfc-balanced/coprocessor/obc1/serialization.cpp
@@ -0,0 +1,7 @@
+auto OBC1::serialize(serializer& s) -> void {
+  s.array(ram.data(), ram.size());
+
+  s.integer(status.address);
+  s.integer(status.baseptr);
+  s.integer(status.shift);
+}
diff --git a/nSide/higan/sfc-balanced/coprocessor/sa1/bus.cpp b/nSide/higan/sfc-balanced/coprocessor/sa1/bus.cpp
new file mode 100644
index 0000000..02861f3
--- /dev/null
+++ b/nSide/higan/sfc-balanced/coprocessor/sa1/bus.cpp
@@ -0,0 +1,30 @@
+//ROM / RAM access from the S-CPU
+
+auto SA1::CPUIRAM::size() const -> uint {
+  return sa1.iram.size();
+}
+
+auto SA1::CPUIRAM::read(uint24 addr, uint8) -> uint8 {
+  cpu.synchronize(sa1);
+  return sa1.iram.read(addr & 0x07ff);
+}
+
+auto SA1::CPUIRAM::write(uint24 addr, uint8 data) -> void {
+  cpu.synchronize(sa1);
+  sa1.iram.write(addr & 0x07ff, data);
+}
+
+auto SA1::CPUBWRAM::size() const -> uint {
+  return sa1.bwram.size();
+}
+
+auto SA1::CPUBWRAM::read(uint24 addr, uint8) -> uint8 {
+  cpu.synchronize(sa1);
+  if(dma) return sa1.dmaCC1Read(addr);
+  return sa1.bwram.read(addr);
+}
+
+auto SA1::CPUBWRAM::write(uint24 addr, uint8 data) -> void {
+  cpu.synchronize(sa1);
+  sa1.bwram.write(addr, data);
+}
diff --git a/nSide/higan/sfc-balanced/coprocessor/sa1/dma.cpp b/nSide/higan/sfc-balanced/coprocessor/sa1/dma.cpp
new file mode 100644
index 0000000..944d9a3
--- /dev/null
+++ b/nSide/higan/sfc-balanced/coprocessor/sa1/dma.cpp
@@ -0,0 +1,135 @@
+//====================
+//direct data transfer
+//====================
+
+auto SA1::dmaNormal() -> void {
+  while(mmio.dtc--) {
+    uint8 data = r.mdr;
+    uint32 dsa = mmio.dsa++;
+    uint32 dda = mmio.dda++;
+
+    //source and destination cannot be the same
+    if(mmio.sd == DMA::SourceBWRAM && mmio.dd == DMA::DestBWRAM) continue;
+    if(mmio.sd == DMA::SourceIRAM  && mmio.dd == DMA::DestIRAM ) continue;
+
+    switch(mmio.sd) {
+    case DMA::SourceROM:
+      if((dsa & 0x408000) == 0x008000 || (dsa & 0xc00000) == 0xc00000) {
+        data = busRead(dsa, data);
+      }
+      break;
+
+    case DMA::SourceBWRAM:
+      if((dsa & 0x40e000) == 0x006000 || (dsa & 0xf00000) == 0x400000) {
+        data = busRead(dsa, data);
+      }
+      break;
+
+    case DMA::SourceIRAM:
+      data = iram.read(dsa & 0x07ff);
+      break;
+    }
+
+    switch(mmio.dd) {
+    case DMA::DestBWRAM:
+      if((dda & 0x40e000) == 0x006000 || (dda & 0xf00000) == 0x400000) {
+        busWrite(dda, data);
+      }
+      break;
+
+    case DMA::DestIRAM:
+      iram.write(dda & 0x07ff, data);
+      break;
+    }
+  }
+
+  mmio.dma_irqfl = true;
+  if(mmio.dma_irqen) mmio.dma_irqcl = 0;
+}
+
+//((byte & 6) << 3) + (byte & 1) explanation:
+//transforms a byte index (0-7) into a planar index:
+//result[] = {  0,  1, 16, 17, 32, 33, 48, 49 };
+//works for 2bpp, 4bpp and 8bpp modes
+
+//===========================
+//type-1 character conversion
+//===========================
+
+auto SA1::dmaCC1() -> void {
+  cpubwram.dma = true;
+  mmio.chdma_irqfl = true;
+  if(mmio.chdma_irqen) {
+    mmio.chdma_irqcl = 0;
+    cpu.r.irq = 1;
+  }
+}
+
+auto SA1::dmaCC1Read(uint addr) -> uint8 {
+  //16 bytes/char (2bpp); 32 bytes/char (4bpp); 64 bytes/char (8bpp)
+  uint charmask = (1 << (6 - mmio.dmacb)) - 1;
+
+  if((addr & charmask) == 0) {
+    //buffer next character to I-RAM
+    uint bpp = 2 << (2 - mmio.dmacb);
+    uint bpl = (8 << mmio.dmasize) >> mmio.dmacb;
+    uint bwmask = bwram.size() - 1;
+    uint tile = ((addr - mmio.dsa) & bwmask) >> (6 - mmio.dmacb);
+    uint ty = (tile >> mmio.dmasize);
+    uint tx = tile & ((1 << mmio.dmasize) - 1);
+    uint bwaddr = mmio.dsa + ty * 8 * bpl + tx * bpp;
+
+    for(auto y : range(8)) {
+      uint64 data = 0;
+      for(auto byte : range(bpp)) {
+        data |= (uint64)bwram.read((bwaddr + byte) & bwmask) << (byte << 3);
+      }
+      bwaddr += bpl;
+
+      uint8 out[] = {0, 0, 0, 0, 0, 0, 0, 0};
+      for(auto x : range(8)) {
+        out[0] |= (data & 1) << (7 - x); data >>= 1;
+        out[1] |= (data & 1) << (7 - x); data >>= 1;
+        if(mmio.dmacb == 2) continue;
+        out[2] |= (data & 1) << (7 - x); data >>= 1;
+        out[3] |= (data & 1) << (7 - x); data >>= 1;
+        if(mmio.dmacb == 1) continue;
+        out[4] |= (data & 1) << (7 - x); data >>= 1;
+        out[5] |= (data & 1) << (7 - x); data >>= 1;
+        out[6] |= (data & 1) << (7 - x); data >>= 1;
+        out[7] |= (data & 1) << (7 - x); data >>= 1;
+      }
+
+      for(auto byte : range(bpp)) {
+        uint p = mmio.dda + (y << 1) + ((byte & 6) << 3) + (byte & 1);
+        iram.write(p & 0x07ff, out[byte]);
+      }
+    }
+  }
+
+  return iram.read((mmio.dda + (addr & charmask)) & 0x07ff);
+}
+
+//===========================
+//type-2 character conversion
+//===========================
+
+auto SA1::dmaCC2() -> void {
+  //select register file index (0-7 or 8-15)
+  const uint8* brf = &mmio.brf[(dma.line & 1) << 3];
+  uint bpp = 2 << (2 - mmio.dmacb);
+  uint addr = mmio.dda & 0x07ff;
+  addr &= ~((1 << (7 - mmio.dmacb)) - 1);
+  addr += (dma.line & 8) * bpp;
+  addr += (dma.line & 7) * 2;
+
+  for(auto byte : range(bpp)) {
+    uint8 output = 0;
+    for(auto bit : range(8)) {
+      output |= ((brf[bit] >> byte) & 1) << (7 - bit);
+    }
+    iram.write(addr + ((byte & 6) << 3) + (byte & 1), output);
+  }
+
+  dma.line = (dma.line + 1) & 15;
+}
diff --git a/nSide/higan/sfc-balanced/coprocessor/sa1/io.cpp b/nSide/higan/sfc-balanced/coprocessor/sa1/io.cpp
new file mode 100644
index 0000000..7cfe6e4
--- /dev/null
+++ b/nSide/higan/sfc-balanced/coprocessor/sa1/io.cpp
@@ -0,0 +1,489 @@
+auto SA1::readIO(uint24 addr, uint8) -> uint8 {
+  cpu.active() ? cpu.synchronize(sa1) : synchronize(cpu);
+
+  switch(0x2300 | addr.bits(0,7)) {
+
+  //(SFR) S-CPU flag read
+  case 0x2300: {
+    uint8 data;
+    data  = mmio.cpu_irqfl   << 7;
+    data |= mmio.cpu_ivsw    << 6;
+    data |= mmio.chdma_irqfl << 5;
+    data |= mmio.cpu_nvsw    << 4;
+    data |= mmio.cmeg;
+    return data;
+  }
+
+  //(CFR) SA-1 flag read
+  case 0x2301: {
+    uint8 data;
+    data  = mmio.sa1_irqfl   << 7;
+    data |= mmio.timer_irqfl << 6;
+    data |= mmio.dma_irqfl   << 5;
+    data |= mmio.sa1_nmifl   << 4;
+    data |= mmio.smeg;
+    return data;
+  }
+
+  //(HCR) hcounter read
+  case 0x2302: {
+    //latch counters
+    mmio.hcr = status.hcounter >> 2;
+    mmio.vcr = status.vcounter;
+    return mmio.hcr >> 0;
+  }
+
+  case 0x2303: {
+    return mmio.hcr >> 8;
+  }
+
+  //(VCR) vcounter read
+  case 0x2304: return mmio.vcr >> 0;
+  case 0x2305: return mmio.vcr >> 8;
+
+  //(MR) arithmetic result
+  case 0x2306: return mmio.mr >>  0;
+  case 0x2307: return mmio.mr >>  8;
+  case 0x2308: return mmio.mr >> 16;
+  case 0x2309: return mmio.mr >> 24;
+  case 0x230a: return mmio.mr >> 32;
+
+  //(OF) arithmetic overflow flag
+  case 0x230b: return mmio.overflow << 7;
+
+  //(VDPL) variable-length data read port low
+  case 0x230c: {
+    uint24 data;
+    data.byte(0) = vbrRead(mmio.va + 0);
+    data.byte(1) = vbrRead(mmio.va + 1);
+    data.byte(2) = vbrRead(mmio.va + 2);
+    data >>= mmio.vbit;
+
+    return data >> 0;
+  }
+
+  //(VDPH) variable-length data read port high
+  case 0x230d: {
+    uint24 data;
+    data.byte(0) = vbrRead(mmio.va + 0);
+    data.byte(1) = vbrRead(mmio.va + 1);
+    data.byte(2) = vbrRead(mmio.va + 2);
+    data >>= mmio.vbit;
+
+    if(mmio.hl == 1) {
+      //auto-increment mode
+      mmio.vbit += mmio.vb;
+      mmio.va += (mmio.vbit >> 3);
+      mmio.vbit &= 7;
+    }
+
+    return data >> 8;
+  }
+
+  //(VC) version code register
+  case 0x230e: {
+    return 0x01;  //true value unknown
+  }
+
+  }
+
+  return 0x00;
+}
+
+auto SA1::writeIO(uint24 addr, uint8 data) -> void {
+  cpu.active() ? cpu.synchronize(sa1) : synchronize(cpu);
+
+  switch(0x2200 | addr.bits(0,7)) {
+
+  //(CCNT) SA-1 control
+  case 0x2200: {
+    if(mmio.sa1_resb && !(data & 0x80)) {
+      //reset SA-1 CPU
+      r.pc.w = mmio.crv;
+      r.pc.b = 0x00;
+    }
+
+    mmio.sa1_irq  = (data & 0x80);
+    mmio.sa1_rdyb = (data & 0x40);
+    mmio.sa1_resb = (data & 0x20);
+    mmio.sa1_nmi  = (data & 0x10);
+    mmio.smeg     = (data & 0x0f);
+
+    if(mmio.sa1_irq) {
+      mmio.sa1_irqfl = true;
+      if(mmio.sa1_irqen) mmio.sa1_irqcl = 0;
+    }
+
+    if(mmio.sa1_nmi) {
+      mmio.sa1_nmifl = true;
+      if(mmio.sa1_nmien) mmio.sa1_nmicl = 0;
+    }
+
+    return;
+  }
+
+  //(SIE) S-CPU interrupt enable
+  case 0x2201: {
+    if(!mmio.cpu_irqen && (data & 0x80)) {
+      if(mmio.cpu_irqfl) {
+        mmio.cpu_irqcl = 0;
+        cpu.r.irq = 1;
+      }
+    }
+
+    if(!mmio.chdma_irqen && (data & 0x20)) {
+      if(mmio.chdma_irqfl) {
+        mmio.chdma_irqcl = 0;
+        cpu.r.irq = 1;
+      }
+    }
+
+    mmio.cpu_irqen   = (data & 0x80);
+    mmio.chdma_irqen = (data & 0x20);
+    return;
+  }
+
+  //(SIC) S-CPU interrupt clear
+  case 0x2202: {
+    mmio.cpu_irqcl   = (data & 0x80);
+    mmio.chdma_irqcl = (data & 0x20);
+
+    if(mmio.cpu_irqcl  ) mmio.cpu_irqfl   = false;
+    if(mmio.chdma_irqcl) mmio.chdma_irqfl = false;
+
+    if(!mmio.cpu_irqfl && !mmio.chdma_irqfl) cpu.r.irq = 0;
+    return;
+  }
+
+  //(CRV) SA-1 reset vector
+  case 0x2203: { mmio.crv = (mmio.crv & 0xff00) | data; return; }
+  case 0x2204: { mmio.crv = (data << 8) | (mmio.crv & 0xff); return; }
+
+  //(CNV) SA-1 NMI vector
+  case 0x2205: { mmio.cnv = (mmio.cnv & 0xff00) | data; return; }
+  case 0x2206: { mmio.cnv = (data << 8) | (mmio.cnv & 0xff); return; }
+
+  //(CIV) SA-1 IRQ vector
+  case 0x2207: { mmio.civ = (mmio.civ & 0xff00) | data; return; }
+  case 0x2208: { mmio.civ = (data << 8) | (mmio.civ & 0xff); return; }
+
+  //(SCNT) S-CPU control
+  case 0x2209: {
+    mmio.cpu_irq  = (data & 0x80);
+    mmio.cpu_ivsw = (data & 0x40);
+    mmio.cpu_nvsw = (data & 0x10);
+    mmio.cmeg     = (data & 0x0f);
+
+    if(mmio.cpu_irq) {
+      mmio.cpu_irqfl = true;
+      if(mmio.cpu_irqen) {
+        mmio.cpu_irqcl = 0;
+        cpu.r.irq = 1;
+      }
+    }
+
+    return;
+  }
+
+  //(CIE) SA-1 interrupt enable
+  case 0x220a: {
+    if(!mmio.sa1_irqen   && (data & 0x80) && mmio.sa1_irqfl  ) mmio.sa1_irqcl   = 0;
+    if(!mmio.timer_irqen && (data & 0x40) && mmio.timer_irqfl) mmio.timer_irqcl = 0;
+    if(!mmio.dma_irqen   && (data & 0x20) && mmio.dma_irqfl  ) mmio.dma_irqcl   = 0;
+    if(!mmio.sa1_nmien   && (data & 0x10) && mmio.sa1_nmifl  ) mmio.sa1_nmicl   = 0;
+
+    mmio.sa1_irqen   = (data & 0x80);
+    mmio.timer_irqen = (data & 0x40);
+    mmio.dma_irqen   = (data & 0x20);
+    mmio.sa1_nmien   = (data & 0x10);
+    return;
+  }
+
+  //(CIC) SA-1 interrupt clear
+  case 0x220b: {
+    mmio.sa1_irqcl   = (data & 0x80);
+    mmio.timer_irqcl = (data & 0x40);
+    mmio.dma_irqcl   = (data & 0x20);
+    mmio.sa1_nmicl   = (data & 0x10);
+
+    if(mmio.sa1_irqcl)   mmio.sa1_irqfl   = false;
+    if(mmio.timer_irqcl) mmio.timer_irqfl = false;
+    if(mmio.dma_irqcl)   mmio.dma_irqfl   = false;
+    if(mmio.sa1_nmicl)   mmio.sa1_nmifl   = false;
+    return;
+  }
+
+  //(SNV) S-CPU NMI vector
+  case 0x220c: { mmio.snv = (mmio.snv & 0xff00) | data; return; }
+  case 0x220d: { mmio.snv = (data << 8) | (mmio.snv & 0xff); return; }
+
+  //(SIV) S-CPU IRQ vector
+  case 0x220e: { mmio.siv = (mmio.siv & 0xff00) | data; return; }
+  case 0x220f: { mmio.siv = (data << 8) | (mmio.siv & 0xff); return; }
+
+  //(TMC) H/V timer control
+  case 0x2210: {
+    mmio.hvselb = (data & 0x80);
+    mmio.ven    = (data & 0x02);
+    mmio.hen    = (data & 0x01);
+    return;
+  }
+
+  //(CTR) SA-1 timer restart
+  case 0x2211: {
+    status.vcounter = 0;
+    status.hcounter = 0;
+    return;
+  }
+
+  //(HCNT) H-count
+  case 0x2212: { mmio.hcnt = (mmio.hcnt & 0xff00) | (data << 0); return; }
+  case 0x2213: { mmio.hcnt = (mmio.hcnt & 0x00ff) | (data << 8); return; }
+
+  //(VCNT) V-count
+  case 0x2214: { mmio.vcnt = (mmio.vcnt & 0xff00) | (data << 0); return; }
+  case 0x2215: { mmio.vcnt = (mmio.vcnt & 0x00ff) | (data << 8); return; }
+
+  //(CXB) Super MMC bank C
+  case 0x2220: {
+    mmio.cbmode = (data & 0x80);
+    mmio.cb     = (data & 0x07);
+    return;
+  }
+
+  //(DXB) Super MMC bank D
+  case 0x2221: {
+    mmio.dbmode = (data & 0x80);
+    mmio.db     = (data & 0x07);
+    return;
+  }
+
+  //(EXB) Super MMC bank E
+  case 0x2222: {
+    mmio.ebmode = (data & 0x80);
+    mmio.eb     = (data & 0x07);
+    return;
+  }
+
+  //(FXB) Super MMC bank F
+  case 0x2223: {
+    mmio.fbmode = (data & 0x80);
+    mmio.fb     = (data & 0x07);
+    return;
+  }
+
+  //(BMAPS) S-CPU BW-RAM address mapping
+  case 0x2224: {
+    mmio.sbm = (data & 0x1f);
+    return;
+  }
+
+  //(BMAP) SA-1 BW-RAM address mapping
+  case 0x2225: {
+    mmio.sw46 = (data & 0x80);
+    mmio.cbm  = (data & 0x7f);
+    return;
+  }
+
+  //(SWBE) S-CPU BW-RAM write enable
+  case 0x2226: {
+    mmio.swen = (data & 0x80);
+    return;
+  }
+
+  //(CWBE) SA-1 BW-RAM write enable
+  case 0x2227: {
+    mmio.cwen = (data & 0x80);
+    return;
+  }
+
+  //(BWPA) BW-RAM write-protected area
+  case 0x2228: {
+    mmio.bwp = (data & 0x0f);
+    return;
+  }
+
+  //(SIWP) S-CPU I-RAM write protection
+  case 0x2229: {
+    mmio.siwp = data;
+    return;
+  }
+
+  //(CIWP) SA-1 I-RAM write protection
+  case 0x222a: {
+    mmio.ciwp = data;
+    return;
+  }
+
+  //(DCNT) DMA control
+  case 0x2230: {
+    mmio.dmaen = (data & 0x80);
+    mmio.dprio = (data & 0x40);
+    mmio.cden  = (data & 0x20);
+    mmio.cdsel = (data & 0x10);
+    mmio.dd    = (data & 0x04);
+    mmio.sd    = (data & 0x03);
+
+    if(mmio.dmaen == 0) dma.line = 0;
+    return;
+  }
+
+  //(CDMA) character conversion DMA parameters
+  case 0x2231: {
+    mmio.chdend  = (data & 0x80);
+    mmio.dmasize = (data >> 2) & 7;
+    mmio.dmacb   = (data & 0x03);
+
+    if(mmio.chdend) cpubwram.dma = false;
+    if(mmio.dmasize > 5) mmio.dmasize = 5;
+    if(mmio.dmacb   > 2) mmio.dmacb   = 2;
+    return;
+  }
+
+  //(SDA) DMA source device start address
+  case 0x2232: { mmio.dsa = (mmio.dsa & 0xffff00) | (data <<  0); return; }
+  case 0x2233: { mmio.dsa = (mmio.dsa & 0xff00ff) | (data <<  8); return; }
+  case 0x2234: { mmio.dsa = (mmio.dsa & 0x00ffff) | (data << 16); return; }
+
+  //(DDA) DMA destination start address
+  case 0x2235: { mmio.dda = (mmio.dda & 0xffff00) | (data <<  0); return; }
+  case 0x2236: { mmio.dda = (mmio.dda & 0xff00ff) | (data <<  8);
+    if(mmio.dmaen) {
+      if(mmio.cden == 0 && mmio.dd == DMA::DestIRAM) {
+        dmaNormal();
+      } else if(mmio.cden == 1 && mmio.cdsel == 1) {
+        dmaCC1();
+      }
+    }
+    return;
+  }
+  case 0x2237: { mmio.dda = (mmio.dda & 0x00ffff) | (data << 16);
+    if(mmio.dmaen) {
+      if(mmio.cden == 0 && mmio.dd == DMA::DestBWRAM) {
+        dmaNormal();
+      }
+    }
+    return;
+  }
+
+  //(DTC) DMA terminal counter
+  case 0x2238: { mmio.dtc = (mmio.dtc & 0xff00) | (data << 0); return; }
+  case 0x2239: { mmio.dtc = (mmio.dtc & 0x00ff) | (data << 8); return; }
+
+  //(BBF) BW-RAM bitmap format
+  case 0x223f: { mmio.bbf = (data & 0x80); return; }
+
+  //(BRF) bitmap register files
+  case 0x2240: { mmio.brf[ 0] = data; return; }
+  case 0x2241: { mmio.brf[ 1] = data; return; }
+  case 0x2242: { mmio.brf[ 2] = data; return; }
+  case 0x2243: { mmio.brf[ 3] = data; return; }
+  case 0x2244: { mmio.brf[ 4] = data; return; }
+  case 0x2245: { mmio.brf[ 5] = data; return; }
+  case 0x2246: { mmio.brf[ 6] = data; return; }
+  case 0x2247: { mmio.brf[ 7] = data;
+    if(mmio.dmaen) {
+      if(mmio.cden == 1 && mmio.cdsel == 0) {
+        dmaCC2();
+      }
+    }
+    return;
+  }
+  case 0x2248: { mmio.brf[ 8] = data; return; }
+  case 0x2249: { mmio.brf[ 9] = data; return; }
+  case 0x224a: { mmio.brf[10] = data; return; }
+  case 0x224b: { mmio.brf[11] = data; return; }
+  case 0x224c: { mmio.brf[12] = data; return; }
+  case 0x224d: { mmio.brf[13] = data; return; }
+  case 0x224e: { mmio.brf[14] = data; return; }
+  case 0x224f: { mmio.brf[15] = data;
+    if(mmio.dmaen) {
+      if(mmio.cden == 1 && mmio.cdsel == 0) {
+        dmaCC2();
+      }
+    }
+    return;
+  }
+
+  //(MCNT) arithmetic control
+  case 0x2250: {
+    mmio.acm = (data & 0x02);
+    mmio.md  = (data & 0x01);
+
+    if(mmio.acm) mmio.mr = 0;
+    return;
+  }
+
+  //(MAL) multiplicand / dividend low
+  case 0x2251: {
+    mmio.ma = (mmio.ma & 0xff00) | data;
+    return;
+  }
+
+  //(MAH) multiplicand / dividend high
+  case 0x2252: {
+    mmio.ma = (data << 8) | (mmio.ma & 0x00ff);
+    return;
+  }
+
+  //(MBL) multiplier / divisor low
+  case 0x2253: {
+    mmio.mb = (mmio.mb & 0xff00) | data;
+    return;
+  }
+
+  //(MBH) multiplier / divisor high
+  //multiplication / cumulative sum only resets MB
+  //division resets both MA and MB
+  case 0x2254: {
+    mmio.mb = (data << 8) | (mmio.mb & 0x00ff);
+
+    if(mmio.acm == 0) {
+      if(mmio.md == 0) {
+        //signed multiplication
+        mmio.mr = (int16)mmio.ma * (int16)mmio.mb;
+        mmio.mb = 0;
+      } else {
+        //unsigned division
+        if(mmio.mb == 0) {
+          mmio.mr = 0;
+        } else {
+          int16  quotient  = (int16)mmio.ma / (uint16)mmio.mb;
+          uint16 remainder = (int16)mmio.ma % (uint16)mmio.mb;
+          mmio.mr = (remainder << 16) | quotient;
+        }
+        mmio.ma = 0;
+        mmio.mb = 0;
+      }
+    } else {
+      //sigma (accumulative multiplication)
+      mmio.mr += (int16)mmio.ma * (int16)mmio.mb;
+      mmio.overflow = (mmio.mr >= (1ULL << 40));
+      mmio.mr &= (1ULL << 40) - 1;
+      mmio.mb = 0;
+    }
+    return;
+  }
+
+  //(VBD) variable-length bit processing
+  case 0x2258: {
+    mmio.hl = (data & 0x80);
+    mmio.vb = (data & 0x0f);
+    if(mmio.vb == 0) mmio.vb = 16;
+
+    if(mmio.hl == 0) {
+      //fixed mode
+      mmio.vbit += mmio.vb;
+      mmio.va += (mmio.vbit >> 3);
+      mmio.vbit &= 7;
+    }
+    return;
+  }
+
+  //(VDA) variable-length bit game pak ROM start address
+  case 0x2259: { mmio.va = (mmio.va & 0xffff00) | (data <<  0); return; }
+  case 0x225a: { mmio.va = (mmio.va & 0xff00ff) | (data <<  8); return; }
+  case 0x225b: { mmio.va = (mmio.va & 0x00ffff) | (data << 16); mmio.vbit = 0; return; }
+
+  }
+}
diff --git a/nSide/higan/sfc-balanced/coprocessor/sa1/memory.cpp b/nSide/higan/sfc-balanced/coprocessor/sa1/memory.cpp
new file mode 100644
index 0000000..e59b94c
--- /dev/null
+++ b/nSide/higan/sfc-balanced/coprocessor/sa1/memory.cpp
@@ -0,0 +1,268 @@
+auto SA1::busRead(uint24 addr, uint8 data) -> uint8 {
+  if((addr & 0x40fe00) == 0x002200) {  //$00-3f,80-bf:2200-23ff
+    return readIO(addr, data);
+  }
+
+  if((addr & 0x408000) == 0x008000) {  //$00-3f,80-bf:8000-ffff
+    addr = ((addr & 0x800000) >> 2) | ((addr & 0x3f0000) >> 1) | (addr & 0x7fff);
+    return mmcromRead(addr, data);
+  }
+
+  if((addr & 0xc00000) == 0xc00000) {  //$c0-ff:0000-ffff
+    return mmcromRead(addr, data);
+  }
+
+  if((addr & 0x40e000) == 0x006000) {  //$00-3f,80-bf:6000-7fff
+    return mmcSA1Read(addr, data);
+  }
+
+  if((addr & 0x40f800) == 0x000000) {  //$00-3f,80-bf:0000-07ff
+    synchronize(cpu);
+    return iram.read(addr & 2047, data);
+  }
+
+  if((addr & 0x40f800) == 0x003000) {  //$00-3f,80-bf:3000-37ff
+    synchronize(cpu);
+    return iram.read(addr & 2047, data);
+  }
+
+  if((addr & 0xf00000) == 0x400000) {  //$40-4f:0000-ffff
+    synchronize(cpu);
+    return bwram.read(addr & (bwram.size() - 1), data);
+  }
+
+  if((addr & 0xf00000) == 0x600000) {  //$60-6f:0000-ffff
+    synchronize(cpu);
+    return bitmapRead(addr & 0x0fffff, data);
+  }
+
+  //unmapped region
+  return data;
+}
+
+auto SA1::busWrite(uint24 addr, uint8 data) -> void {
+  if((addr & 0x40fe00) == 0x002200) {  //$00-3f,80-bf:2200-23ff
+    return writeIO(addr, data);
+  }
+
+  if((addr & 0x40e000) == 0x006000) {  //$00-3f,80-bf:6000-7fff
+    return mmcSA1Write(addr, data);
+  }
+
+  if((addr & 0x40f800) == 0x000000) {  //$00-3f,80-bf:0000-07ff
+    synchronize(cpu);
+    return iram.write(addr & 2047, data);
+  }
+
+  if((addr & 0x40f800) == 0x003000) {  //$00-3f,80-bf:3000-37ff
+    synchronize(cpu);
+    return iram.write(addr & 2047, data);
+  }
+
+  if((addr & 0xf00000) == 0x400000) {  //$40-4f:0000-ffff
+    synchronize(cpu);
+    return bwram.write(addr & (bwram.size() - 1), data);
+  }
+
+  if((addr & 0xf00000) == 0x600000) {  //$60-6f:0000-ffff
+    synchronize(cpu);
+    return bitmapWrite(addr & 0x0fffff, data);
+  }
+}
+
+//$230c (VDPL), $230d (VDPH) use this bus to read variable-length data.
+//this is used both to keep VBR-reads from accessing MMIO registers, and
+//to avoid syncing the S-CPU and SA-1*; as both chips are able to access
+//these ports.
+auto SA1::vbrRead(uint24 addr, uint8 data) -> uint8 {
+  if((addr & 0x408000) == 0x008000) {  //$00-3f,80-bf:8000-ffff
+    addr = ((addr & 0x800000) >> 2) | ((addr & 0x3f0000) >> 1) | (addr & 0x7fff);
+    return mmcromRead(addr, data);
+  }
+
+  if((addr & 0xc00000) == 0xc00000) {  //$c0-ff:0000-ffff
+    return mmcromRead(addr, data);
+  }
+
+  if((addr & 0x40e000) == 0x006000) {  //$00-3f,80-bf:6000-7fff
+    return bwram.read(addr & (bwram.size() - 1), data);
+  }
+
+  if((addr & 0xf00000) == 0x400000) {  //$40-4f:0000-ffff
+    return bwram.read(addr & (bwram.size() - 1), data);
+  }
+
+  if((addr & 0x40f800) == 0x000000) {  //$00-3f,80-bf:0000-07ff
+    return iram.read(addr & 2047, data);
+  }
+
+  if((addr & 0x40f800) == 0x003000) {  //$00-3f,80-bf:3000-37ff
+    return iram.read(addr & 2047, data);
+  }
+
+  return 0x00;
+}
+
+//ROM, I-RAM and MMIO registers are accessed at ~10.74MHz (2 clock ticks)
+//BW-RAM is accessed at ~5.37MHz (4 clock ticks)
+//tick() == 2 clock ticks
+//note: bus conflict delays are not emulated at this time
+
+auto SA1::idle() -> void {
+  tick();
+}
+
+auto SA1::read(uint24 addr) -> uint8 {
+  tick();
+  if(((addr & 0x40e000) == 0x006000) || ((addr & 0xd00000) == 0x400000)) tick();
+  return busRead(addr, r.mdr);
+}
+
+auto SA1::write(uint24 addr, uint8 data) -> void {
+  tick();
+  if(((addr & 0x40e000) == 0x006000) || ((addr & 0xd00000) == 0x400000)) tick();
+  busWrite(addr, r.mdr = data);
+}
+
+//note: addresses are translated prior to invoking this function:
+//$00-3f,80-bf:8000-ffff mask=0x408000 => $00-3f:0000-ffff
+//$c0-ff:0000-ffff mask=0
+auto SA1::mmcromRead(uint24 addr, uint8) -> uint8 {
+  //reset vector overrides
+  if((addr & 0xffffe0) == 0x007fe0) {  //$00:ffe0-ffef
+    if(addr == 0x7fea && sa1.mmio.cpu_nvsw) return sa1.mmio.snv >> 0;
+    if(addr == 0x7feb && sa1.mmio.cpu_nvsw) return sa1.mmio.snv >> 8;
+    if(addr == 0x7fee && sa1.mmio.cpu_ivsw) return sa1.mmio.siv >> 0;
+    if(addr == 0x7fef && sa1.mmio.cpu_ivsw) return sa1.mmio.siv >> 8;
+  }
+
+  static auto read = [](uint addr) {
+    return sa1.rom.read(bus.mirror(addr, sa1.rom.size()));
+  };
+
+  bool lo = addr < 0x400000;  //*bmode==0 only applies to $00-3f,80-bf:8000-ffff
+  addr &= 0x3fffff;
+
+  if(addr < 0x100000) {  //$00-1f,8000-ffff; $c0-cf:0000-ffff
+    if(lo && mmio.cbmode == 0) return read(addr);
+    return read((mmio.cb << 20) | (addr & 0x0fffff));
+  }
+
+  if(addr < 0x200000) {  //$20-3f,8000-ffff; $d0-df:0000-ffff
+    if(lo && mmio.dbmode == 0) return read(addr);
+    return read((mmio.db << 20) | (addr & 0x0fffff));
+  }
+
+  if(addr < 0x300000) {  //$80-9f,8000-ffff; $e0-ef:0000-ffff
+    if(lo && mmio.ebmode == 0) return read(addr);
+    return read((mmio.eb << 20) | (addr & 0x0fffff));
+  }
+
+  if(addr < 0x400000) {  //$a0-bf,8000-ffff; $f0-ff:0000-ffff
+    if(lo && mmio.fbmode == 0) return read(addr);
+    return read((mmio.fb << 20) | (addr & 0x0fffff));
+  }
+
+  return 0x00;
+}
+
+auto SA1::mmcromWrite(uint24 addr, uint8 data) -> void {
+}
+
+auto SA1::mmcbwramRead(uint24 addr, uint8 data) -> uint8 {
+  if(addr < 0x2000) {  //$00-3f,80-bf:6000-7fff
+    cpu.synchronize(sa1);
+    addr = bus.mirror(mmio.sbm * 0x2000 + (addr & 0x1fff), cpubwram.size());
+    return cpubwram.read(addr);
+  }
+
+  if((addr & 0xf00000) == 0x400000) {  //$40-4f:0000-ffff
+    return cpubwram.read(addr & 0x0fffff);
+  }
+
+  return data;
+}
+
+auto SA1::mmcbwramWrite(uint24 addr, uint8 data) -> void {
+  if(addr < 0x2000) {  //$00-3f,80-bf:6000-7fff
+    cpu.synchronize(sa1);
+    addr = bus.mirror(mmio.sbm * 0x2000 + (addr & 0x1fff), cpubwram.size());
+    return cpubwram.write(addr, data);
+  }
+
+  if((addr & 0xf00000) == 0x400000) {  //$40-4f:0000-ffff
+    return cpubwram.write(addr & 0x0fffff, data);
+  }
+}
+
+auto SA1::mmcSA1Read(uint addr, uint8 data) -> uint8 {
+  synchronize(cpu);
+  if(mmio.sw46 == 0) {
+    //$40-43:0000-ffff x  32 projection
+    addr = bus.mirror((mmio.cbm & 0x1f) * 0x2000 + (addr & 0x1fff), bwram.size());
+    return bwram.read(addr, data);
+  } else {
+    //$60-6f:0000-ffff x 128 projection
+    addr = bus.mirror(mmio.cbm * 0x2000 + (addr & 0x1fff), 0x100000);
+    return bitmapRead(addr, data);
+  }
+}
+
+auto SA1::mmcSA1Write(uint addr, uint8 data) -> void {
+  synchronize(cpu);
+  if(mmio.sw46 == 0) {
+    //$40-43:0000-ffff x  32 projection
+    addr = bus.mirror((mmio.cbm & 0x1f) * 0x2000 + (addr & 0x1fff), bwram.size());
+    bwram.write(addr, data);
+  } else {
+    //$60-6f:0000-ffff x 128 projection
+    addr = bus.mirror(mmio.cbm * 0x2000 + (addr & 0x1fff), 0x100000);
+    bitmapWrite(addr, data);
+  }
+}
+
+auto SA1::bitmapRead(uint addr, uint8 data) -> uint8 {
+  if(mmio.bbf == 0) {
+    //4bpp
+    uint shift = addr & 1;
+    addr = (addr >> 1) & (bwram.size() - 1);
+    switch(shift) {
+    case 0: return (bwram.read(addr) >> 0) & 15;
+    case 1: return (bwram.read(addr) >> 4) & 15;
+    }
+  } else {
+    //2bpp
+    uint shift = addr & 3;
+    addr = (addr >> 2) & (bwram.size() - 1);
+    switch(shift) {
+    case 0: return (bwram.read(addr) >> 0) & 3;
+    case 1: return (bwram.read(addr) >> 2) & 3;
+    case 2: return (bwram.read(addr) >> 4) & 3;
+    case 3: return (bwram.read(addr) >> 6) & 3;
+    }
+  }
+}
+
+auto SA1::bitmapWrite(uint addr, uint8 data) -> void {
+  if(mmio.bbf == 0) {
+    //4bpp
+    uint shift = addr & 1;
+    addr = (addr >> 1) & (bwram.size() - 1);
+    switch(shift) {
+    case 0: data = (bwram.read(addr) & 0xf0) | ((data & 15) << 0); break;
+    case 1: data = (bwram.read(addr) & 0x0f) | ((data & 15) << 4); break;
+    }
+  } else {
+    //2bpp
+    uint shift = addr & 3;
+    addr = (addr >> 2) & (bwram.size() - 1);
+    switch(shift) {
+    case 0: data = (bwram.read(addr) & 0xfc) | ((data &  3) << 0); break;
+    case 1: data = (bwram.read(addr) & 0xf3) | ((data &  3) << 2); break;
+    case 2: data = (bwram.read(addr) & 0xcf) | ((data &  3) << 4); break;
+    case 3: data = (bwram.read(addr) & 0x3f) | ((data &  3) << 6); break;
+    }
+  }
+
+  bwram.write(addr, data);
+}
diff --git a/nSide/higan/sfc-balanced/coprocessor/sa1/sa1.cpp b/nSide/higan/sfc-balanced/coprocessor/sa1/sa1.cpp
new file mode 100644
index 0000000..d4b1969
--- /dev/null
+++ b/nSide/higan/sfc-balanced/coprocessor/sa1/sa1.cpp
@@ -0,0 +1,324 @@
+#include <sfc-balanced/sfc.hpp>
+
+namespace SuperFamicom {
+
+#include "bus.cpp"
+#include "dma.cpp"
+#include "memory.cpp"
+#include "io.cpp"
+#include "serialization.cpp"
+SA1 sa1;
+
+auto SA1::Enter() -> void {
+  while(true) scheduler.synchronize(), sa1.main();
+}
+
+auto SA1::main() -> void {
+  if(mmio.sa1_rdyb || mmio.sa1_resb) {
+    //SA-1 co-processor is asleep
+    tick();
+    synchronize(cpu);
+    return;
+  }
+
+  if(status.interruptPending) {
+    status.interruptPending = false;
+    interrupt();
+    return;
+  }
+
+  instruction();
+}
+
+//override WDC65816::interrupt() to support SA-1 vector location IO registers
+auto SA1::interrupt() -> void {
+  read(r.pc.d);
+  idle();
+  if(!r.e) writeSP(r.pc.b);
+  writeSP(r.pc.h);
+  writeSP(r.pc.l);
+  writeSP(r.e ? (r.p & ~0x10) : r.p);
+  r.pc.w = r.vector;
+  r.pc.b = 0x00;
+  r.p.i = 1;
+  r.p.d = 0;
+}
+
+auto SA1::lastCycle() -> void {
+  if(mmio.sa1_nmi && !mmio.sa1_nmicl) {
+    status.interruptPending = true;
+    r.vector = mmio.cnv;
+    mmio.sa1_nmifl = true;
+    mmio.sa1_nmicl = 1;
+    r.wai = false;
+  } else if(!r.p.i) {
+    if(mmio.timer_irqen && !mmio.timer_irqcl) {
+      status.interruptPending = true;
+      r.vector = mmio.civ;
+      mmio.timer_irqfl = true;
+      r.wai = false;
+    } else if(mmio.dma_irqen && !mmio.dma_irqcl) {
+      status.interruptPending = true;
+      r.vector = mmio.civ;
+      mmio.dma_irqfl = true;
+      r.wai = false;
+    } else if(mmio.sa1_irq && !mmio.sa1_irqcl) {
+      status.interruptPending = true;
+      r.vector = mmio.civ;
+      mmio.sa1_irqfl = true;
+      r.wai = false;
+    }
+  }
+}
+
+auto SA1::interruptPending() const -> bool {
+  return status.interruptPending;
+}
+
+auto SA1::tick() -> void {
+  step(2);
+  if(++status.counter == 0) synchronize(cpu);
+
+  //adjust counters:
+  //note that internally, status counters are in clocks;
+  //whereas MMIO register counters are in dots (4 clocks = 1 dot)
+  if(mmio.hvselb == 0) {
+    //HV timer
+    status.hcounter += 2;
+    if(status.hcounter >= 1364) {
+      status.hcounter = 0;
+      if(++status.vcounter >= status.scanlines) status.vcounter = 0;
+    }
+  } else {
+    //linear timer
+    status.hcounter += 2;
+    status.vcounter += (status.hcounter >> 11);
+    status.hcounter &= 0x07ff;
+    status.vcounter &= 0x01ff;
+  }
+
+  //test counters for timer IRQ
+  switch((mmio.ven << 1) + (mmio.hen << 0)) {
+  case 0: break;
+  case 1: if(status.hcounter == (mmio.hcnt << 2)) triggerIRQ(); break;
+  case 2: if(status.vcounter == mmio.vcnt && status.hcounter == 0) triggerIRQ(); break;
+  case 3: if(status.vcounter == mmio.vcnt && status.hcounter == (mmio.hcnt << 2)) triggerIRQ(); break;
+  }
+}
+
+auto SA1::triggerIRQ() -> void {
+  mmio.timer_irqfl = true;
+  if(mmio.timer_irqen) mmio.timer_irqcl = 0;
+}
+
+auto SA1::init() -> void {
+}
+
+auto SA1::load() -> void {
+}
+
+auto SA1::unload() -> void {
+  rom.reset();
+  iram.reset();
+  bwram.reset();
+}
+
+auto SA1::power() -> void {
+  r.a = 0x0000;
+  r.x = 0x0000;
+  r.y = 0x0000;
+  r.s = 0x01ff;
+}
+
+auto SA1::reset() -> void {
+  create(SA1::Enter, system.colorburst() * 6.0);
+
+  cpubwram.dma = false;
+  for(auto addr : range(iram.size())) {
+    iram.write(addr, 0x00);
+  }
+
+  r.pc.d   = 0x000000;
+  r.x.h    = 0x00;
+  r.y.h    = 0x00;
+  r.s.h    = 0x01;
+  r.d      = 0x0000;
+  r.db     = 0x00;
+  r.p      = 0x34;
+  r.e      = 1;
+  r.mdr    = 0x00;
+  r.wai    = false;
+  r.vector = 0x0000;
+
+  status.counter = 0;
+
+  status.interruptPending = false;
+
+  status.scanlines = (system.region() == System::Region::NTSC ? 262 : 312);
+  status.vcounter  = 0;
+  status.hcounter  = 0;
+
+  dma.line = 0;
+
+  //$2200 CCNT
+  mmio.sa1_irq  = false;
+  mmio.sa1_rdyb = false;
+  mmio.sa1_resb = true;
+  mmio.sa1_nmi  = false;
+  mmio.smeg     = 0;
+
+  //$2201 SIE
+  mmio.cpu_irqen   = false;
+  mmio.chdma_irqen = false;
+
+  //$2202 SIC
+  mmio.cpu_irqcl   = false;
+  mmio.chdma_irqcl = false;
+
+  //$2203,$2204 CRV
+  mmio.crv = 0x0000;
+
+  //$2205,$2206 CNV
+  mmio.cnv = 0x0000;
+
+  //$2207,$2208 CIV
+  mmio.civ = 0x0000;
+
+  //$2209 SCNT
+  mmio.cpu_irq  = false;
+  mmio.cpu_ivsw = false;
+  mmio.cpu_nvsw = false;
+  mmio.cmeg     = 0;
+
+  //$220a CIE
+  mmio.sa1_irqen   = false;
+  mmio.timer_irqen = false;
+  mmio.dma_irqen   = false;
+  mmio.sa1_nmien   = false;
+
+  //$220b CIC
+  mmio.sa1_irqcl   = false;
+  mmio.timer_irqcl = false;
+  mmio.dma_irqcl   = false;
+  mmio.sa1_nmicl   = false;
+
+  //$220c,$220d SNV
+  mmio.snv = 0x0000;
+
+  //$220e,$220f SIV
+  mmio.siv = 0x0000;
+
+  //$2210
+  mmio.hvselb = false;
+  mmio.ven    = false;
+  mmio.hen    = false;
+
+  //$2212,$2213 HCNT
+  mmio.hcnt = 0x0000;
+
+  //$2214,$2215 VCNT
+  mmio.vcnt = 0x0000;
+
+  //$2220-2223 CXB, DXB, EXB, FXB
+  mmio.cbmode = 0;
+  mmio.dbmode = 0;
+  mmio.ebmode = 0;
+  mmio.fbmode = 0;
+
+  mmio.cb = 0x00;
+  mmio.db = 0x01;
+  mmio.eb = 0x02;
+  mmio.fb = 0x03;
+
+  //$2224 BMAPS
+  mmio.sbm = 0x00;
+
+  //$2225 BMAP
+  mmio.sw46 = false;
+  mmio.cbm  = 0x00;
+
+  //$2226 SWBE
+  mmio.swen = false;
+
+  //$2227 CWBE
+  mmio.cwen = false;
+
+  //$2228 BWPA
+  mmio.bwp = 0x0f;
+
+  //$2229 SIWP
+  mmio.siwp = 0x00;
+
+  //$222a CIWP
+  mmio.ciwp = 0x00;
+
+  //$2230 DCNT
+  mmio.dmaen = false;
+  mmio.dprio = false;
+  mmio.cden  = false;
+  mmio.cdsel = false;
+  mmio.dd    = 0;
+  mmio.sd    = 0;
+
+  //$2231 CDMA
+  mmio.chdend  = false;
+  mmio.dmasize = 0;
+  mmio.dmacb   = 0;
+
+  //$2232-$2234 SDA
+  mmio.dsa = 0x000000;
+
+  //$2235-$2237 DDA
+  mmio.dda = 0x000000;
+
+  //$2238,$2239 DTC
+  mmio.dtc = 0x0000;
+
+  //$223f BBF
+  mmio.bbf = 0;
+
+  //$2240-$224f BRF
+  for(auto& n : mmio.brf) n = 0x00;
+
+  //$2250 MCNT
+  mmio.acm = 0;
+  mmio.md  = 0;
+
+  //$2251,$2252 MA
+  mmio.ma = 0x0000;
+
+  //$2253,$2254 MB
+  mmio.mb = 0x0000;
+
+  //$2258 VBD
+  mmio.hl = false;
+  mmio.vb = 16;
+
+  //$2259-$225b
+  mmio.va   = 0x000000;
+  mmio.vbit = 0;
+
+  //$2300 SFR
+  mmio.cpu_irqfl   = false;
+  mmio.chdma_irqfl = false;
+
+  //$2301 CFR
+  mmio.sa1_irqfl   = false;
+  mmio.timer_irqfl = false;
+  mmio.dma_irqfl   = false;
+  mmio.sa1_nmifl   = false;
+
+  //$2302,$2303 HCR
+  mmio.hcr = 0x0000;
+
+  //$2304,$2305 VCR
+  mmio.vcr = 0x0000;
+
+  //$2306-$230a MR
+  mmio.mr = 0;
+
+  //$230b
+  mmio.overflow = false;
+}
+
+}
diff --git a/nSide/higan/sfc-balanced/coprocessor/sa1/sa1.hpp b/nSide/higan/sfc-balanced/coprocessor/sa1/sa1.hpp
new file mode 100644
index 0000000..4df67be
--- /dev/null
+++ b/nSide/higan/sfc-balanced/coprocessor/sa1/sa1.hpp
@@ -0,0 +1,261 @@
+struct SA1 : Processor::WDC65816, Thread {
+  //sa1.cpp
+  static auto Enter() -> void;
+  auto main() -> void;
+  auto tick() -> void;
+  auto interrupt() -> void override;
+
+  alwaysinline auto triggerIRQ() -> void;
+  alwaysinline auto lastCycle() -> void override;
+  alwaysinline auto interruptPending() const -> bool override;
+
+  auto init() -> void;
+  auto load() -> void;
+  auto unload() -> void;
+  auto power() -> void;
+  auto reset() -> void;
+
+  //bus.cpp
+  struct CPUIRAM : Memory {
+    auto size() const -> uint;
+    alwaysinline auto read(uint24, uint8 = 0) -> uint8;
+    alwaysinline auto write(uint24, uint8) -> void;
+  };
+
+  struct CPUBWRAM : Memory {
+    auto size() const -> uint;
+    alwaysinline auto read(uint24, uint8 = 0) -> uint8;
+    alwaysinline auto write(uint24, uint8) -> void;
+    bool dma;
+  };
+
+  //dma.cpp
+  struct DMA {
+    enum CDEN : uint { DmaNormal = 0, DmaCharConversion = 1 };
+    enum SD : uint { SourceROM = 0, SourceBWRAM = 1, SourceIRAM = 2 };
+    enum DD : uint { DestIRAM = 0, DestBWRAM = 1 };
+    uint line;
+  };
+
+  auto dmaNormal() -> void;
+  auto dmaCC1() -> void;
+  auto dmaCC1Read(uint addr) -> uint8;
+  auto dmaCC2() -> void;
+
+  //memory.cpp
+  auto busRead(uint24 addr, uint8 data) -> uint8;
+  auto busWrite(uint24 addr, uint8 data) -> void;
+  auto vbrRead(uint24 addr, uint8 data = 0) -> uint8;
+
+  alwaysinline auto idle() -> void override;
+  alwaysinline auto read(uint24 addr) -> uint8 override;
+  alwaysinline auto write(uint24 addr, uint8 data) -> void override;
+
+  auto mmcromRead(uint24 addr, uint8 data) -> uint8;
+  auto mmcromWrite(uint24 addr, uint8 data) -> void;
+
+  auto mmcbwramRead(uint24 addr, uint8 data) -> uint8;
+  auto mmcbwramWrite(uint24 addr, uint8 data) -> void;
+
+  auto mmcSA1Read(uint addr, uint8 data) -> uint8;
+  auto mmcSA1Write(uint addr, uint8 data) -> void;
+
+  auto bitmapRead(uint addr, uint8 data) -> uint8;
+  auto bitmapWrite(uint addr, uint8 data) -> void;
+
+  //io.cpp
+  auto readIO(uint24 addr, uint8 data) -> uint8;
+  auto writeIO(uint24 addr, uint8 data) -> void;
+
+  //serialization.cpp
+  auto serialize(serializer&) -> void;
+
+  MappedRAM rom;
+  MappedRAM iram;
+  MappedRAM bwram;
+
+  CPUIRAM cpuiram;
+  CPUBWRAM cpubwram;
+
+private:
+  DMA dma;
+
+  struct Status {
+    uint8 counter;
+
+    bool interruptPending;
+
+    uint16 scanlines;
+    uint16 vcounter;
+    uint16 hcounter;
+  } status;
+
+  struct MMIO {
+    //$2200 CCNT
+    bool sa1_irq;
+    bool sa1_rdyb;
+    bool sa1_resb;
+    bool sa1_nmi;
+    uint8 smeg;
+
+    //$2201 SIE
+    bool cpu_irqen;
+    bool chdma_irqen;
+
+    //$2202 SIC
+    bool cpu_irqcl;
+    bool chdma_irqcl;
+
+    //$2203,$2204 CRV
+    uint16 crv;
+
+    //$2205,$2206 CNV
+    uint16 cnv;
+
+    //$2207,$2208 CIV
+    uint16 civ;
+
+    //$2209 SCNT
+    bool cpu_irq;
+    bool cpu_ivsw;
+    bool cpu_nvsw;
+    uint8 cmeg;
+
+    //$220a CIE
+    bool sa1_irqen;
+    bool timer_irqen;
+    bool dma_irqen;
+    bool sa1_nmien;
+
+    //$220b CIC
+    bool sa1_irqcl;
+    bool timer_irqcl;
+    bool dma_irqcl;
+    bool sa1_nmicl;
+
+    //$220c,$220d SNV
+    uint16 snv;
+
+    //$220e,$220f SIV
+    uint16 siv;
+
+    //$2210 TMC
+    bool hvselb;
+    bool ven;
+    bool hen;
+
+    //$2212,$2213
+    uint16 hcnt;
+
+    //$2214,$2215
+    uint16 vcnt;
+
+    //$2220 CXB
+    bool cbmode;
+    uint cb;
+
+    //$2221 DXB
+    bool dbmode;
+    uint db;
+
+    //$2222 EXB
+    bool ebmode;
+    uint eb;
+
+    //$2223 FXB
+    bool fbmode;
+    uint fb;
+
+    //$2224 BMAPS
+    uint8 sbm;
+
+    //$2225 BMAP
+    bool sw46;
+    uint8 cbm;
+
+    //$2226 SBWE
+    bool swen;
+
+    //$2227 CBWE
+    bool cwen;
+
+    //$2228 BWPA
+    uint8 bwp;
+
+    //$2229 SIWP
+    uint8 siwp;
+
+    //$222a CIWP
+    uint8 ciwp;
+
+    //$2230 DCNT
+    bool dmaen;
+    bool dprio;
+    bool cden;
+    bool cdsel;
+    bool dd;
+    uint8 sd;
+
+    //$2231 CDMA
+    bool chdend;
+    uint8 dmasize;
+    uint8 dmacb;
+
+    //$2232-$2234 SDA
+    uint32 dsa;
+
+    //$2235-$2237 DDA
+    uint32 dda;
+
+    //$2238,$2239 DTC
+    uint16 dtc;
+
+    //$223f BBF
+    bool bbf;
+
+    //$2240-224f BRF
+    uint8 brf[16];
+
+    //$2250 MCNT
+    bool acm;
+    bool md;
+
+    //$2251,$2252 MA
+    uint16 ma;
+
+    //$2253,$2254 MB
+    uint16 mb;
+
+    //$2258 VBD
+    bool hl;
+    uint8 vb;
+
+    //$2259-$225b VDA
+    uint32 va;
+    uint8 vbit;
+
+    //$2300 SFR
+    bool cpu_irqfl;
+    bool chdma_irqfl;
+
+    //$2301 CFR
+    bool sa1_irqfl;
+    bool timer_irqfl;
+    bool dma_irqfl;
+    bool sa1_nmifl;
+
+    //$2302,$2303 HCR
+    uint16 hcr;
+
+    //$2304,$2305 VCR
+    uint16 vcr;
+
+    //$2306-230a MR
+    uint64 mr;
+
+    //$230b OF
+    bool overflow;
+  } mmio;
+};
+
+extern SA1 sa1;
diff --git a/nSide/higan/sfc-balanced/coprocessor/sa1/serialization.cpp b/nSide/higan/sfc-balanced/coprocessor/sa1/serialization.cpp
new file mode 100644
index 0000000..5ab0688
--- /dev/null
+++ b/nSide/higan/sfc-balanced/coprocessor/sa1/serialization.cpp
@@ -0,0 +1,147 @@
+auto SA1::serialize(serializer& s) -> void {
+  WDC65816::serialize(s);
+  Thread::serialize(s);
+
+  s.array(iram.data(), iram.size());
+  s.array(bwram.data(), bwram.size());
+
+  //sa1.hpp
+  s.integer(status.counter);
+
+  s.integer(status.interruptPending);
+
+  s.integer(status.scanlines);
+  s.integer(status.vcounter);
+  s.integer(status.hcounter);
+
+  //bus/bus.hpp
+  s.array(iram.data(), iram.size());
+
+  s.integer(cpubwram.dma);
+
+  //dma/dma.hpp
+  s.integer(dma.line);
+
+  //mmio/mmio.hpp
+  s.integer(mmio.sa1_irq);
+  s.integer(mmio.sa1_rdyb);
+  s.integer(mmio.sa1_resb);
+  s.integer(mmio.sa1_nmi);
+  s.integer(mmio.smeg);
+
+  s.integer(mmio.cpu_irqen);
+  s.integer(mmio.chdma_irqen);
+
+  s.integer(mmio.cpu_irqcl);
+  s.integer(mmio.chdma_irqcl);
+
+  s.integer(mmio.crv);
+
+  s.integer(mmio.cnv);
+
+  s.integer(mmio.civ);
+
+  s.integer(mmio.cpu_irq);
+  s.integer(mmio.cpu_ivsw);
+  s.integer(mmio.cpu_nvsw);
+  s.integer(mmio.cmeg);
+
+  s.integer(mmio.sa1_irqen);
+  s.integer(mmio.timer_irqen);
+  s.integer(mmio.dma_irqen);
+  s.integer(mmio.sa1_nmien);
+
+  s.integer(mmio.sa1_irqcl);
+  s.integer(mmio.timer_irqcl);
+  s.integer(mmio.dma_irqcl);
+  s.integer(mmio.sa1_nmicl);
+
+  s.integer(mmio.snv);
+
+  s.integer(mmio.siv);
+
+  s.integer(mmio.hvselb);
+  s.integer(mmio.ven);
+  s.integer(mmio.hen);
+
+  s.integer(mmio.hcnt);
+
+  s.integer(mmio.vcnt);
+
+  s.integer(mmio.cbmode);
+  s.integer(mmio.cb);
+
+  s.integer(mmio.dbmode);
+  s.integer(mmio.db);
+
+  s.integer(mmio.ebmode);
+  s.integer(mmio.eb);
+
+  s.integer(mmio.fbmode);
+  s.integer(mmio.fb);
+
+  s.integer(mmio.sbm);
+
+  s.integer(mmio.sw46);
+  s.integer(mmio.cbm);
+
+  s.integer(mmio.swen);
+
+  s.integer(mmio.cwen);
+
+  s.integer(mmio.bwp);
+
+  s.integer(mmio.siwp);
+
+  s.integer(mmio.ciwp);
+
+  s.integer(mmio.dmaen);
+  s.integer(mmio.dprio);
+  s.integer(mmio.cden);
+  s.integer(mmio.cdsel);
+  s.integer(mmio.dd);
+  s.integer(mmio.sd);
+
+  s.integer(mmio.chdend);
+  s.integer(mmio.dmasize);
+  s.integer(mmio.dmacb);
+
+  s.integer(mmio.dsa);
+
+  s.integer(mmio.dda);
+
+  s.integer(mmio.dtc);
+
+  s.integer(mmio.bbf);
+
+  s.array(mmio.brf);
+
+  s.integer(mmio.acm);
+  s.integer(mmio.md);
+
+  s.integer(mmio.ma);
+
+  s.integer(mmio.mb);
+
+  s.integer(mmio.hl);
+  s.integer(mmio.vb);
+
+  s.integer(mmio.va);
+  s.integer(mmio.vbit);
+
+  s.integer(mmio.cpu_irqfl);
+  s.integer(mmio.chdma_irqfl);
+
+  s.integer(mmio.sa1_irqfl);
+  s.integer(mmio.timer_irqfl);
+  s.integer(mmio.dma_irqfl);
+  s.integer(mmio.sa1_nmifl);
+
+  s.integer(mmio.hcr);
+
+  s.integer(mmio.vcr);
+
+  s.integer(mmio.mr);
+
+  s.integer(mmio.overflow);
+}
diff --git a/nSide/higan/sfc-balanced/coprocessor/sdd1/decompressor.cpp b/nSide/higan/sfc-balanced/coprocessor/sdd1/decompressor.cpp
new file mode 100644
index 0000000..66fb609
--- /dev/null
+++ b/nSide/higan/sfc-balanced/coprocessor/sdd1/decompressor.cpp
@@ -0,0 +1,284 @@
+//S-DD1 decompression algorithm implementation
+//original code written by Andreas Naive (public domain license)
+//bsnes port written by byuu
+
+//note: decompression module does not need to be serialized with bsnes
+//this is because decompression only runs during DMA, and bsnes will complete
+//any pending DMA transfers prior to serialization.
+
+//input manager
+
+auto SDD1::Decompressor::IM::init(uint offset_) -> void {
+  offset = offset_;
+  bitCount = 4;
+}
+
+auto SDD1::Decompressor::IM::getCodeWord(uint8 codeLength) -> uint8 {
+  uint8 codeWord;
+  uint8 compCount;
+
+  codeWord = sdd1.mmcRead(offset) << bitCount;
+  bitCount++;
+
+  if(codeWord & 0x80) {
+    codeWord |= sdd1.mmcRead(offset + 1) >> (9 - bitCount);
+    bitCount += codeLength;
+  }
+
+  if(bitCount & 0x08) {
+    offset++;
+    bitCount &= 0x07;
+  }
+
+  return codeWord;
+}
+
+//golomb-code decoder
+
+const uint8 SDD1::Decompressor::GCD::runCount[] = {
+  0x00, 0x00, 0x01, 0x00, 0x03, 0x01, 0x02, 0x00,
+  0x07, 0x03, 0x05, 0x01, 0x06, 0x02, 0x04, 0x00,
+  0x0f, 0x07, 0x0b, 0x03, 0x0d, 0x05, 0x09, 0x01,
+  0x0e, 0x06, 0x0a, 0x02, 0x0c, 0x04, 0x08, 0x00,
+  0x1f, 0x0f, 0x17, 0x07, 0x1b, 0x0b, 0x13, 0x03,
+  0x1d, 0x0d, 0x15, 0x05, 0x19, 0x09, 0x11, 0x01,
+  0x1e, 0x0e, 0x16, 0x06, 0x1a, 0x0a, 0x12, 0x02,
+  0x1c, 0x0c, 0x14, 0x04, 0x18, 0x08, 0x10, 0x00,
+  0x3f, 0x1f, 0x2f, 0x0f, 0x37, 0x17, 0x27, 0x07,
+  0x3b, 0x1b, 0x2b, 0x0b, 0x33, 0x13, 0x23, 0x03,
+  0x3d, 0x1d, 0x2d, 0x0d, 0x35, 0x15, 0x25, 0x05,
+  0x39, 0x19, 0x29, 0x09, 0x31, 0x11, 0x21, 0x01,
+  0x3e, 0x1e, 0x2e, 0x0e, 0x36, 0x16, 0x26, 0x06,
+  0x3a, 0x1a, 0x2a, 0x0a, 0x32, 0x12, 0x22, 0x02,
+  0x3c, 0x1c, 0x2c, 0x0c, 0x34, 0x14, 0x24, 0x04,
+  0x38, 0x18, 0x28, 0x08, 0x30, 0x10, 0x20, 0x00,
+  0x7f, 0x3f, 0x5f, 0x1f, 0x6f, 0x2f, 0x4f, 0x0f,
+  0x77, 0x37, 0x57, 0x17, 0x67, 0x27, 0x47, 0x07,
+  0x7b, 0x3b, 0x5b, 0x1b, 0x6b, 0x2b, 0x4b, 0x0b,
+  0x73, 0x33, 0x53, 0x13, 0x63, 0x23, 0x43, 0x03,
+  0x7d, 0x3d, 0x5d, 0x1d, 0x6d, 0x2d, 0x4d, 0x0d,
+  0x75, 0x35, 0x55, 0x15, 0x65, 0x25, 0x45, 0x05,
+  0x79, 0x39, 0x59, 0x19, 0x69, 0x29, 0x49, 0x09,
+  0x71, 0x31, 0x51, 0x11, 0x61, 0x21, 0x41, 0x01,
+  0x7e, 0x3e, 0x5e, 0x1e, 0x6e, 0x2e, 0x4e, 0x0e,
+  0x76, 0x36, 0x56, 0x16, 0x66, 0x26, 0x46, 0x06,
+  0x7a, 0x3a, 0x5a, 0x1a, 0x6a, 0x2a, 0x4a, 0x0a,
+  0x72, 0x32, 0x52, 0x12, 0x62, 0x22, 0x42, 0x02,
+  0x7c, 0x3c, 0x5c, 0x1c, 0x6c, 0x2c, 0x4c, 0x0c,
+  0x74, 0x34, 0x54, 0x14, 0x64, 0x24, 0x44, 0x04,
+  0x78, 0x38, 0x58, 0x18, 0x68, 0x28, 0x48, 0x08,
+  0x70, 0x30, 0x50, 0x10, 0x60, 0x20, 0x40, 0x00,
+};
+
+auto SDD1::Decompressor::GCD::getRunCount(uint8 codeNumber, uint8& mpsCount, bool& lpsIndex) -> void {
+  uint8 codeWord = self.im.getCodeWord(codeNumber);
+
+  if(codeWord & 0x80) {
+    lpsIndex = 1;
+    mpsCount = runCount[codeWord >> (codeNumber ^ 0x07)];
+  } else {
+    mpsCount = 1 << codeNumber;
+  }
+}
+
+//bits generator
+
+auto SDD1::Decompressor::BG::init() -> void {
+  mpsCount = 0;
+  lpsIndex = 0;
+}
+
+auto SDD1::Decompressor::BG::getBit(bool& endOfRun) -> uint8 {
+  if(!(mpsCount || lpsIndex)) self.gcd.getRunCount(codeNumber, mpsCount, lpsIndex);
+
+  uint8 bit;
+  if(mpsCount) {
+    bit = 0;
+    mpsCount--;
+  } else {
+    bit = 1;
+    lpsIndex = 0;
+  }
+
+  endOfRun = !(mpsCount || lpsIndex);
+  return bit;
+}
+
+//probability estimation module
+
+const SDD1::Decompressor::PEM::State SDD1::Decompressor::PEM::evolutionTable[33] = {
+  {0, 25, 25},
+  {0,  2,  1},
+  {0,  3,  1},
+  {0,  4,  2},
+  {0,  5,  3},
+  {1,  6,  4},
+  {1,  7,  5},
+  {1,  8,  6},
+  {1,  9,  7},
+  {2, 10,  8},
+  {2, 11,  9},
+  {2, 12, 10},
+  {2, 13, 11},
+  {3, 14, 12},
+  {3, 15, 13},
+  {3, 16, 14},
+  {3, 17, 15},
+  {4, 18, 16},
+  {4, 19, 17},
+  {5, 20, 18},
+  {5, 21, 19},
+  {6, 22, 20},
+  {6, 23, 21},
+  {7, 24, 22},
+  {7, 24, 23},
+  {0, 26,  1},
+  {1, 27,  2},
+  {2, 28,  4},
+  {3, 29,  8},
+  {4, 30, 12},
+  {5, 31, 16},
+  {6, 32, 18},
+  {7, 24, 22},
+};
+
+auto SDD1::Decompressor::PEM::init() -> void {
+  for(auto n : range(32)) {
+    contextInfo[n].status = 0;
+    contextInfo[n].mps = 0;
+  }
+}
+
+auto SDD1::Decompressor::PEM::getBit(uint8 context) -> uint8 {
+  ContextInfo& info = contextInfo[context];
+  uint8 currentStatus = info.status;
+  uint8 currentMps = info.mps;
+  const State& s = SDD1::Decompressor::PEM::evolutionTable[currentStatus];
+
+  uint8 bit;
+  bool endOfRun;
+  switch(s.codeNumber) {
+  case 0: bit = self.bg0.getBit(endOfRun); break;
+  case 1: bit = self.bg1.getBit(endOfRun); break;
+  case 2: bit = self.bg2.getBit(endOfRun); break;
+  case 3: bit = self.bg3.getBit(endOfRun); break;
+  case 4: bit = self.bg4.getBit(endOfRun); break;
+  case 5: bit = self.bg5.getBit(endOfRun); break;
+  case 6: bit = self.bg6.getBit(endOfRun); break;
+  case 7: bit = self.bg7.getBit(endOfRun); break;
+  }
+
+  if(endOfRun) {
+    if(bit) {
+      if(!(currentStatus & 0xfe)) info.mps ^= 0x01;
+      info.status = s.nextIfLps;
+    } else {
+      info.status = s.nextIfMps;
+    }
+  }
+
+  return bit ^ currentMps;
+}
+
+//context model
+
+auto SDD1::Decompressor::CM::init(uint offset) -> void {
+  bitplanesInfo = sdd1.mmcRead(offset) & 0xc0;
+  contextBitsInfo = sdd1.mmcRead(offset) & 0x30;
+  bitNumber = 0;
+  for(auto n : range(8)) previousBitplaneBits[n] = 0;
+  switch(bitplanesInfo) {
+  case 0x00: currentBitplane = 1; break;
+  case 0x40: currentBitplane = 7; break;
+  case 0x80: currentBitplane = 3; break;
+  }
+}
+
+auto SDD1::Decompressor::CM::getBit() -> uint8 {
+  switch(bitplanesInfo) {
+  case 0x00:
+    currentBitplane ^= 0x01;
+    break;
+  case 0x40:
+    currentBitplane ^= 0x01;
+    if(!(bitNumber & 0x7f)) currentBitplane = ((currentBitplane + 2) & 0x07);
+    break;
+  case 0x80:
+    currentBitplane ^= 0x01;
+    if(!(bitNumber & 0x7f)) currentBitplane ^= 0x02;
+    break;
+  case 0xc0:
+    currentBitplane = bitNumber & 0x07;
+    break;
+  }
+
+  uint16& contextBits = previousBitplaneBits[currentBitplane];
+  uint8 currentContext = (currentBitplane & 0x01) << 4;
+  switch(contextBitsInfo) {
+  case 0x00: currentContext |= ((contextBits & 0x01c0) >> 5) | (contextBits & 0x0001); break;
+  case 0x10: currentContext |= ((contextBits & 0x0180) >> 5) | (contextBits & 0x0001); break;
+  case 0x20: currentContext |= ((contextBits & 0x00c0) >> 5) | (contextBits & 0x0001); break;
+  case 0x30: currentContext |= ((contextBits & 0x0180) >> 5) | (contextBits & 0x0003); break;
+  }
+
+  uint8 bit = self.pem.getBit(currentContext);
+  contextBits <<= 1;
+  contextBits |= bit;
+  bitNumber++;
+  return bit;
+}
+
+//output logic
+
+auto SDD1::Decompressor::OL::init(uint offset) -> void {
+  bitplanesInfo = sdd1.mmcRead(offset) & 0xc0;
+  r0 = 0x01;
+}
+
+auto SDD1::Decompressor::OL::decompress() -> uint8 {
+  switch(bitplanesInfo) {
+  case 0x00: case 0x40: case 0x80:
+    if(r0 == 0) {
+      r0 = ~r0;
+      return r2;
+    }
+    for(r0 = 0x80, r1 = 0, r2 = 0; r0; r0 >>= 1) {
+      if(self.cm.getBit()) r1 |= r0;
+      if(self.cm.getBit()) r2 |= r0;
+    }
+    return r1;
+  case 0xc0:
+    for(r0 = 0x01, r1 = 0; r0; r0 <<= 1) {
+      if(self.cm.getBit()) r1 |= r0;
+    }
+    return r1;
+  }
+}
+
+//core
+
+SDD1::Decompressor::Decompressor():
+im(*this), gcd(*this),
+bg0(*this, 0), bg1(*this, 1), bg2(*this, 2), bg3(*this, 3),
+bg4(*this, 4), bg5(*this, 5), bg6(*this, 6), bg7(*this, 7),
+pem(*this), cm(*this), ol(*this) {
+}
+
+auto SDD1::Decompressor::init(uint offset) -> void {
+  im.init(offset);
+  bg0.init();
+  bg1.init();
+  bg2.init();
+  bg3.init();
+  bg4.init();
+  bg5.init();
+  bg6.init();
+  bg7.init();
+  pem.init();
+  cm.init(offset);
+  ol.init(offset);
+}
+
+auto SDD1::Decompressor::read() -> uint8 {
+  return ol.decompress();
+}
diff --git a/nSide/higan/sfc-balanced/coprocessor/sdd1/decompressor.hpp b/nSide/higan/sfc-balanced/coprocessor/sdd1/decompressor.hpp
new file mode 100644
index 0000000..fad4901
--- /dev/null
+++ b/nSide/higan/sfc-balanced/coprocessor/sdd1/decompressor.hpp
@@ -0,0 +1,88 @@
+struct Decompressor {
+  struct IM {  //input manager
+    IM(SDD1::Decompressor& self) : self(self) {}
+    auto init(uint offset) -> void;
+    auto getCodeWord(uint8 codeLength) -> uint8;
+
+  private:
+    Decompressor& self;
+    uint offset;
+    uint bitCount;
+  };
+
+  struct GCD {  //golomb-code decoder
+    GCD(SDD1::Decompressor& self) : self(self) {}
+    auto getRunCount(uint8 codeNumber, uint8& mpsCount, bool& lpsIndex) -> void;
+
+  private:
+    Decompressor& self;
+    static const uint8 runCount[256];
+  };
+
+  struct BG {  //bits generator
+    BG(SDD1::Decompressor& self, uint8 codeNumber) : self(self), codeNumber(codeNumber) {}
+    auto init() -> void;
+    auto getBit(bool& endOfRun) -> uint8;
+
+  private:
+    Decompressor& self;
+    const uint8 codeNumber;
+    uint8 mpsCount;
+    bool lpsIndex;
+  };
+
+  struct PEM {  //probability estimation module
+    PEM(SDD1::Decompressor& self) : self(self) {}
+    auto init() -> void;
+    auto getBit(uint8 context) -> uint8;
+
+  private:
+    Decompressor& self;
+    struct State {
+      uint8 codeNumber;
+      uint8 nextIfMps;
+      uint8 nextIfLps;
+    };
+    static const State evolutionTable[33];
+    struct ContextInfo {
+      uint8 status;
+      uint8 mps;
+    } contextInfo[32];
+  };
+
+  struct CM {  //context model
+    CM(SDD1::Decompressor& self) : self(self) {}
+    auto init(uint offset) -> void;
+    auto getBit() -> uint8;
+
+  private:
+    Decompressor& self;
+    uint8 bitplanesInfo;
+    uint8 contextBitsInfo;
+    uint8 bitNumber;
+    uint8 currentBitplane;
+    uint16 previousBitplaneBits[8];
+  };
+
+  struct OL {  //output logic
+    OL(SDD1::Decompressor& self) : self(self) {}
+    auto init(uint offset) -> void;
+    auto decompress() -> uint8;
+
+  private:
+    Decompressor& self;
+    uint8 bitplanesInfo;
+    uint8 r0, r1, r2;
+  };
+
+  Decompressor();
+  auto init(uint offset) -> void;
+  auto read() -> uint8;
+
+  IM  im;
+  GCD gcd;
+  BG  bg0, bg1, bg2, bg3, bg4, bg5, bg6, bg7;
+  PEM pem;
+  CM  cm;
+  OL  ol;
+};
diff --git a/nSide/higan/sfc-balanced/coprocessor/sdd1/sdd1.cpp b/nSide/higan/sfc-balanced/coprocessor/sdd1/sdd1.cpp
new file mode 100644
index 0000000..36845a7
--- /dev/null
+++ b/nSide/higan/sfc-balanced/coprocessor/sdd1/sdd1.cpp
@@ -0,0 +1,152 @@
+#include <sfc-balanced/sfc.hpp>
+
+namespace SuperFamicom {
+
+SDD1 sdd1;
+
+#include "decompressor.cpp"
+#include "serialization.cpp"
+
+auto SDD1::init() -> void {
+}
+
+void SDD1::load() {
+}
+
+auto SDD1::unload() -> void {
+  rom.reset();
+  ram.reset();
+}
+
+auto SDD1::power() -> void {
+}
+
+auto SDD1::reset() -> void {
+  //hook S-CPU DMA MMIO registers to gather information for struct dma[];
+  //buffer address and transfer size information for use in SDD1::mcu_read()
+  bus.map({&SDD1::dmaRead, &sdd1}, {&SDD1::dmaWrite, &sdd1}, "00-3f,80-bf:4300-437f");
+
+  r4800 = 0x00;
+  r4801 = 0x00;
+  r4804 = 0x00;
+  r4805 = 0x01;
+  r4806 = 0x02;
+  r4807 = 0x03;
+
+  for(auto n : range(8)) {
+    dma[n].addr = 0;
+    dma[n].size = 0;
+  }
+  dmaReady = false;
+}
+
+auto SDD1::read(uint24 addr, uint8 data) -> uint8 {
+  addr = 0x4800 | addr.bits(0,3);
+
+  switch(addr) {
+  case 0x4800: return r4800;
+  case 0x4801: return r4801;
+  case 0x4804: return r4804;
+  case 0x4805: return r4805;
+  case 0x4806: return r4806;
+  case 0x4807: return r4807;
+  }
+
+  //00-3f,80-bf:4802-4803,4808-480f falls through to ROM
+  return rom.read(addr);
+}
+
+auto SDD1::write(uint24 addr, uint8 data) -> void {
+  addr = 0x4800 | addr.bits(0,3);
+
+  switch(addr) {
+  case 0x4800: r4800 = data; break;
+  case 0x4801: r4801 = data; break;
+  case 0x4804: r4804 = data & 0x8f; break;
+  case 0x4805: r4805 = data & 0x8f; break;
+  case 0x4806: r4806 = data & 0x8f; break;
+  case 0x4807: r4807 = data & 0x8f; break;
+  }
+}
+
+auto SDD1::dmaRead(uint24 addr, uint8 data) -> uint8 {
+  return cpu.readDMA(addr, data);
+}
+
+auto SDD1::dmaWrite(uint24 addr, uint8 data) -> void {
+  uint channel = addr.bits(4,6);
+  switch(addr.bits(0,3)) {
+  case 2: dma[channel].addr.byte(0) = data; break;
+  case 3: dma[channel].addr.byte(1) = data; break;
+  case 4: dma[channel].addr.byte(2) = data; break;
+  case 5: dma[channel].size.byte(0) = data; break;
+  case 6: dma[channel].size.byte(1) = data; break;
+  }
+  return cpu.writeDMA(addr, data);
+}
+
+auto SDD1::mmcRead(uint24 addr) -> uint8 {
+  switch(addr.bits(20,21)) {
+  case 0: return rom.read(r4804.bits(0,3) << 20 | addr.bits(0,19));  //c0-cf:0000-ffff
+  case 1: return rom.read(r4805.bits(0,3) << 20 | addr.bits(0,19));  //d0-df:0000-ffff
+  case 2: return rom.read(r4806.bits(0,3) << 20 | addr.bits(0,19));  //e0-ef:0000-ffff
+  case 3: return rom.read(r4807.bits(0,3) << 20 | addr.bits(0,19));  //f0-ff:0000-ffff
+  }
+  unreachable;
+}
+
+//map address=00-3f,80-bf:8000-ffff
+//map address=c0-ff:0000-ffff
+auto SDD1::mcuromRead(uint24 addr, uint8 data) -> uint8 {
+  //map address=00-3f,80-bf:8000-ffff
+  if(!addr.bit(22)) {
+    if(!addr.bit(23) && addr.bit(21) && r4805.bit(7)) addr.bit(21) = 0;  //20-3f:8000-ffff
+    if( addr.bit(23) && addr.bit(21) && r4807.bit(7)) addr.bit(21) = 0;  //a0-bf:8000-ffff
+    addr = addr.bits(16,21) << 15 | addr.bits(0,14);
+    return rom.read(addr);
+  }
+
+  //map address=c0-ff:0000-ffff
+  if(r4800 & r4801) {
+    //at least one channel has S-DD1 decompression enabled ...
+    for(auto n : range(8)) {
+      if(r4800.bit(n) && r4801.bit(n)) {
+        //S-DD1 always uses fixed transfer mode, so address will not change during transfer
+        if(addr == dma[n].addr) {
+          if(!dmaReady) {
+            //prepare streaming decompression
+            decompressor.init(addr);
+            dmaReady = true;
+          }
+
+          //fetch a decompressed byte; once finished, disable channel and invalidate buffer
+          data = decompressor.read();
+          if(--dma[n].size == 0) {
+            dmaReady = false;
+            r4801.bit(n) = 0;
+          }
+
+          return data;
+        }  //address matched
+      }  //channel enabled
+    }  //channel loop
+  }  //S-DD1 decompressor enabled
+
+  //S-DD1 decompression mode inactive; return ROM data
+  return mmcRead(addr);
+}
+
+auto SDD1::mcuromWrite(uint24 addr, uint8 data) -> void {
+}
+
+//map address=00-3f,80-bf:6000-7fff mask=0xe000
+//map address=70-73:0000-ffff mask=0x8000
+auto SDD1::mcuramRead(uint24 addr, uint8 data) -> uint8 {
+  return ram.read(addr.bits(0,12), data);
+}
+
+auto SDD1::mcuramWrite(uint24 addr, uint8 data) -> void {
+  return ram.write(addr.bits(0,12), data);
+}
+
+}
diff --git a/nSide/higan/sfc-balanced/coprocessor/sdd1/sdd1.hpp b/nSide/higan/sfc-balanced/coprocessor/sdd1/sdd1.hpp
new file mode 100644
index 0000000..6a578ce
--- /dev/null
+++ b/nSide/higan/sfc-balanced/coprocessor/sdd1/sdd1.hpp
@@ -0,0 +1,46 @@
+struct SDD1 {
+  auto init() -> void;
+  auto load() -> void;
+  auto unload() -> void;
+  auto power() -> void;
+  auto reset() -> void;
+
+  auto read(uint24 addr, uint8 data) -> uint8;
+  auto write(uint24 addr, uint8 data) -> void;
+
+  auto dmaRead(uint24 addr, uint8 data) -> uint8;
+  auto dmaWrite(uint24 addr, uint8 data) -> void;
+
+  auto mmcRead(uint24 addr) -> uint8;
+
+  auto mcuromRead(uint24 addr, uint8 data) -> uint8;
+  auto mcuromWrite(uint24 addr, uint8 data) -> void;
+
+  auto mcuramRead(uint24 addr, uint8 data) -> uint8;
+  auto mcuramWrite(uint24 addr, uint8 data) -> void;
+
+  auto serialize(serializer&) -> void;
+
+  MappedRAM rom;
+  MappedRAM ram;
+
+private:
+  uint8 r4800;  //hard enable
+  uint8 r4801;  //soft enable
+  uint8 r4804;  //MMC bank 0
+  uint8 r4805;  //MMC bank 1
+  uint8 r4806;  //MMC bank 2
+  uint8 r4807;  //MMC bank 3
+
+  struct DMA {
+    uint24 addr;  //$43x2-$43x4 -- DMA transfer address
+    uint16 size;  //$43x5-$43x6 -- DMA transfer size
+  } dma[8];
+  bool dmaReady;  //used to initialize decompression module
+
+public:
+  #include "decompressor.hpp"
+  Decompressor decompressor;
+};
+
+extern SDD1 sdd1;
diff --git a/nSide/higan/sfc-balanced/coprocessor/sdd1/serialization.cpp b/nSide/higan/sfc-balanced/coprocessor/sdd1/serialization.cpp
new file mode 100644
index 0000000..618b5dc
--- /dev/null
+++ b/nSide/higan/sfc-balanced/coprocessor/sdd1/serialization.cpp
@@ -0,0 +1,16 @@
+auto SDD1::serialize(serializer& s) -> void {
+  s.array(ram.data(), ram.size());
+
+  s.integer(r4800);
+  s.integer(r4801);
+  s.integer(r4804);
+  s.integer(r4805);
+  s.integer(r4806);
+  s.integer(r4807);
+
+  for(auto n : range(8)) {
+    s.integer(dma[n].addr);
+    s.integer(dma[n].size);
+  }
+  s.integer(dmaReady);
+}
diff --git a/nSide/higan/sfc-balanced/coprocessor/sharprtc/memory.cpp b/nSide/higan/sfc-balanced/coprocessor/sharprtc/memory.cpp
new file mode 100644
index 0000000..3803f1e
--- /dev/null
+++ b/nSide/higan/sfc-balanced/coprocessor/sharprtc/memory.cpp
@@ -0,0 +1,67 @@
+auto SharpRTC::rtcRead(uint4 addr) -> uint4 {
+  switch(addr) {
+  case  0: return second % 10;
+  case  1: return second / 10;
+  case  2: return minute % 10;
+  case  3: return minute / 10;
+  case  4: return hour % 10;
+  case  5: return hour / 10;
+  case  6: return day % 10;
+  case  7: return day / 10;
+  case  8: return month;
+  case  9: return year % 10;
+  case 10: return year / 10 % 10;
+  case 11: return year / 100;
+  case 12: return weekday;
+  default: return 0;
+  }
+}
+
+auto SharpRTC::rtcWrite(uint4 addr, uint4 data) -> void {
+  switch(addr) {
+  case  0: second = second / 10 * 10 + data; break;
+  case  1: second = data * 10 + second % 10; break;
+  case  2: minute = minute / 10 * 10 + data; break;
+  case  3: minute = data * 10 + minute % 10; break;
+  case  4: hour = hour / 10 * 10 + data; break;
+  case  5: hour = data * 10 + hour % 10; break;
+  case  6: day = day / 10 * 10 + data; break;
+  case  7: day = data * 10 + day % 10; break;
+  case  8: month = data; break;
+  case  9: year = year / 10 * 10 + data; break;
+  case 10: year = year / 100 * 100 + data * 10 + year % 10; break;
+  case 11: year = data * 100 + year % 100; break;
+  case 12: weekday = data; break;
+  }
+}
+
+auto SharpRTC::load(const uint8* data) -> void {
+  for(auto byte : range(8)) {
+    rtcWrite(byte * 2 + 0, data[byte] >> 0);
+    rtcWrite(byte * 2 + 1, data[byte] >> 4);
+  }
+
+  uint64 timestamp = 0;
+  for(auto byte : range(8)) {
+    timestamp |= data[8 + byte] << (byte * 8);
+  }
+
+  uint64 diff = (uint64)time(0) - timestamp;
+  while(diff >= 60 * 60 * 24) { tickDay(); diff -= 60 * 60 * 24; }
+  while(diff >= 60 * 60) { tickHour(); diff -= 60 * 60; }
+  while(diff >= 60) { tickMinute(); diff -= 60; }
+  while(diff--) tickSecond();
+}
+
+auto SharpRTC::save(uint8* data) -> void {
+  for(auto byte : range(8)) {
+    data[byte]  = rtcRead(byte * 2 + 0) << 0;
+    data[byte] |= rtcRead(byte * 2 + 1) << 4;
+  }
+
+  uint64 timestamp = (uint64)time(nullptr);
+  for(auto byte : range(8)) {
+    data[8 + byte] = timestamp;
+    timestamp >>= 8;
+  }
+}
diff --git a/nSide/higan/sfc-balanced/coprocessor/sharprtc/serialization.cpp b/nSide/higan/sfc-balanced/coprocessor/sharprtc/serialization.cpp
new file mode 100644
index 0000000..d4666a1
--- /dev/null
+++ b/nSide/higan/sfc-balanced/coprocessor/sharprtc/serialization.cpp
@@ -0,0 +1,14 @@
+auto SharpRTC::serialize(serializer& s) -> void {
+  Thread::serialize(s);
+
+  s.integer((uint&)state);
+  s.integer(index);
+
+  s.integer(second);
+  s.integer(minute);
+  s.integer(hour);
+  s.integer(day);
+  s.integer(month);
+  s.integer(year);
+  s.integer(weekday);
+}
diff --git a/nSide/higan/sfc-balanced/coprocessor/sharprtc/sharprtc.cpp b/nSide/higan/sfc-balanced/coprocessor/sharprtc/sharprtc.cpp
new file mode 100644
index 0000000..b8e125e
--- /dev/null
+++ b/nSide/higan/sfc-balanced/coprocessor/sharprtc/sharprtc.cpp
@@ -0,0 +1,134 @@
+#include <sfc-balanced/sfc.hpp>
+
+namespace SuperFamicom {
+
+#include "memory.cpp"
+#include "time.cpp"
+#include "serialization.cpp"
+SharpRTC sharprtc;
+
+auto SharpRTC::Enter() -> void {
+  while(true) scheduler.synchronize(), sharprtc.main();
+}
+
+auto SharpRTC::main() -> void {
+  tickSecond();
+
+  step(1);
+  synchronize(cpu);
+}
+
+auto SharpRTC::init() -> void {
+}
+
+auto SharpRTC::load() -> void {
+  return;
+
+  second = 0;
+  minute = 0;
+  hour = 0;
+  day = 0;
+  month = 0;
+  year = 0;
+  weekday = 0;
+}
+
+auto SharpRTC::unload() -> void {
+}
+
+auto SharpRTC::power() -> void {
+}
+
+auto SharpRTC::reset() -> void {
+  create(SharpRTC::Enter, 1);
+
+  state = State::Read;
+  index = -1;
+}
+
+auto SharpRTC::sync() -> void {
+  time_t systime = time(0);
+  tm* timeinfo = localtime(&systime);
+
+  second = min(59, timeinfo->tm_sec);
+  minute = timeinfo->tm_min;
+  hour = timeinfo->tm_hour;
+  day = timeinfo->tm_mday;
+  month = 1 + timeinfo->tm_mon;
+  year = 900 + timeinfo->tm_year;
+  weekday = timeinfo->tm_wday;
+}
+
+auto SharpRTC::read(uint24 addr, uint8 data) -> uint8 {
+  addr &= 1;
+
+  if(addr == 0) {
+    if(state != State::Read) return 0;
+
+    if(index < 0) {
+      index++;
+      return 15;
+    } else if(index > 12) {
+      index = -1;
+      return 15;
+    } else {
+      return rtcRead(index++);
+    }
+  }
+
+  return data;
+}
+
+auto SharpRTC::write(uint24 addr, uint8 data) -> void {
+  addr &= 1, data &= 15;
+
+  if(addr == 1) {
+    if(data == 0x0d) {
+      state = State::Read;
+      index = -1;
+      return;
+    }
+
+    if(data == 0x0e) {
+      state = State::Command;
+      return;
+    }
+
+    if(data == 0x0f) return;  //unknown behavior
+
+    if(state == State::Command) {
+      if(data == 0) {
+        state = State::Write;
+        index = 0;
+      } else if(data == 4) {
+        state = State::Ready;
+        index = -1;
+        //reset time
+        second = 0;
+        minute = 0;
+        hour = 0;
+        day = 0;
+        month = 0;
+        year = 0;
+        weekday = 0;
+      } else {
+        //unknown behavior
+        state = State::Ready;
+      }
+      return;
+    }
+
+    if(state == State::Write) {
+      if(index >= 0 && index < 12) {
+        rtcWrite(index++, data);
+        if(index == 12) {
+          //day of week is automatically calculated and written
+          weekday = calculateWeekday(1000 + year, month, day);
+        }
+      }
+      return;
+    }
+  }
+}
+
+}
diff --git a/nSide/higan/sfc-balanced/coprocessor/sharprtc/sharprtc.hpp b/nSide/higan/sfc-balanced/coprocessor/sharprtc/sharprtc.hpp
new file mode 100644
index 0000000..54d4570
--- /dev/null
+++ b/nSide/higan/sfc-balanced/coprocessor/sharprtc/sharprtc.hpp
@@ -0,0 +1,47 @@
+struct SharpRTC : Thread {
+  static auto Enter() -> void;
+  auto main() -> void;
+
+  auto init() -> void;
+  auto load() -> void;
+  auto unload() -> void;
+  auto power() -> void;
+  auto reset() -> void;
+  auto sync() -> void;
+
+  auto read(uint24 addr, uint8 data) -> uint8;
+  auto write(uint24 addr, uint8 data) -> void;
+
+  auto serialize(serializer&) -> void;
+
+  enum class State : uint { Ready, Command, Read, Write } state;
+  int index;
+
+  uint second;
+  uint minute;
+  uint hour;
+  uint day;
+  uint month;
+  uint year;
+  uint weekday;
+
+  //memory.cpp
+  auto rtcRead(uint4 addr) -> uint4;
+  auto rtcWrite(uint4 addr, uint4 data) -> void;
+
+  auto load(const uint8* data) -> void;
+  auto save(uint8* data) -> void;
+
+  //time.cpp
+  static const uint daysInMonth[12];
+  auto tickSecond() -> void;
+  auto tickMinute() -> void;
+  auto tickHour() -> void;
+  auto tickDay() -> void;
+  auto tickMonth() -> void;
+  auto tickYear() -> void;
+
+  auto calculateWeekday(uint year, uint month, uint day) -> uint;
+};
+
+extern SharpRTC sharprtc;
diff --git a/nSide/higan/sfc-balanced/coprocessor/sharprtc/time.cpp b/nSide/higan/sfc-balanced/coprocessor/sharprtc/time.cpp
new file mode 100644
index 0000000..be7355d
--- /dev/null
+++ b/nSide/higan/sfc-balanced/coprocessor/sharprtc/time.cpp
@@ -0,0 +1,83 @@
+const uint SharpRTC::daysInMonth[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
+
+auto SharpRTC::tickSecond() -> void {
+  if(++second < 60) return;
+  second = 0;
+  tickMinute();
+}
+
+auto SharpRTC::tickMinute() -> void {
+  if(++minute < 60) return;
+  minute = 0;
+  tickHour();
+}
+
+auto SharpRTC::tickHour() -> void {
+  if(++hour < 24) return;
+  hour = 0;
+  tickDay();
+}
+
+auto SharpRTC::tickDay() -> void {
+  uint days = daysInMonth[(month - 1) % 12];
+
+  //add one day in February for leap years
+  if(month == 2) {
+         if(year % 400 == 0) days++;
+    else if(year % 100 == 0);
+    else if(year %   4 == 0) days++;
+  }
+
+  if(day++ < days) return;
+  day = 1;
+  tickMonth();
+}
+
+auto SharpRTC::tickMonth() -> void {
+  if(month++ < 12) return;
+  month = 1;
+  tickYear();
+}
+
+auto SharpRTC::tickYear() -> void {
+  year++;
+  year = (uint12)year;
+}
+
+//returns day of week for specified date
+//eg 0 = Sunday, 1 = Monday, ... 6 = Saturday
+//usage: calculate_weekday(2008, 1, 1) returns weekday of January 1st, 2008
+auto SharpRTC::calculateWeekday(uint year, uint month, uint day) -> uint {
+  uint y = 1000, m = 1;  //SharpRTC epoch is 1000-01-01
+  uint sum = 0;          //number of days passed since epoch
+
+  year = max(1000, year);
+  month = max(1, min(12, month));
+  day = max(1, min(31, day));
+
+  while(y < year) {
+    bool leapyear = false;
+    if(y % 4 == 0) {
+      leapyear = true;
+      if(y % 100 == 0 && y % 400 != 0) leapyear = false;
+    }
+    sum += 365 + leapyear;
+    y++;
+  }
+
+  while(m < month) {
+    uint days = daysInMonth[(m - 1) % 12];
+    bool leapyearmonth = false;
+    if(days == 28) {
+      if(y % 4 == 0) {
+        leapyearmonth = true;
+        if(y % 100 == 0 && y % 400 != 0) leapyearmonth = false;
+      }
+    }
+    sum += days + leapyearmonth;
+    m++;
+  }
+
+  sum += day - 1;
+  return (sum + 3) % 7;  //1000-01-01 was a Wednesday
+}
diff --git a/nSide/higan/sfc-balanced/coprocessor/spc7110/alu.cpp b/nSide/higan/sfc-balanced/coprocessor/spc7110/alu.cpp
new file mode 100644
index 0000000..6b71dbc
--- /dev/null
+++ b/nSide/higan/sfc-balanced/coprocessor/spc7110/alu.cpp
@@ -0,0 +1,83 @@
+auto SPC7110::aluMultiply() -> void {
+  addClocks(30);
+
+  if(r482e & 1) {
+    //signed 16-bit x 16-bit multiplication
+    int16 r0 = (int16)(r4824 | r4825 << 8);
+    int16 r1 = (int16)(r4820 | r4821 << 8);
+
+    int result = r0 * r1;
+    r4828 = result;
+    r4829 = result >> 8;
+    r482a = result >> 16;
+    r482b = result >> 24;
+  } else {
+    //unsigned 16-bit x 16-bit multiplication
+    uint16 r0 = (uint16)(r4824 | r4825 << 8);
+    uint16 r1 = (uint16)(r4820 | r4821 << 8);
+
+    uint result = r0 * r1;
+    r4828 = result;
+    r4829 = result >> 8;
+    r482a = result >> 16;
+    r482b = result >> 24;
+  }
+
+  r482f &= 0x7f;
+}
+
+auto SPC7110::aluDivide() -> void {
+  addClocks(40);
+
+  if(r482e & 1) {
+    //signed 32-bit x 16-bit division
+    int32 dividend = (int32)(r4820 | r4821 << 8 | r4822 << 16 | r4823 << 24);
+    int16 divisor  = (int16)(r4826 | r4827 << 8);
+
+    int32 quotient;
+    int16 remainder;
+
+    if(divisor) {
+      quotient  = (int32)(dividend / divisor);
+      remainder = (int32)(dividend % divisor);
+    } else {
+      //illegal division by zero
+      quotient  = 0;
+      remainder = dividend;
+    }
+
+    r4828 = quotient;
+    r4829 = quotient >> 8;
+    r482a = quotient >> 16;
+    r482b = quotient >> 24;
+
+    r482c = remainder;
+    r482d = remainder >> 8;
+  } else {
+    //unsigned 32-bit x 16-bit division
+    uint32 dividend = (uint32)(r4820 | r4821 << 8 | r4822 << 16 | r4823 << 24);
+    uint16 divisor  = (uint16)(r4826 | r4827 << 8);
+
+    uint32 quotient;
+    uint16 remainder;
+
+    if(divisor) {
+      quotient  = (uint32)(dividend / divisor);
+      remainder = (uint16)(dividend % divisor);
+    } else {
+      //illegal division by zero
+      quotient  = 0;
+      remainder = dividend;
+    }
+
+    r4828 = quotient;
+    r4829 = quotient >> 8;
+    r482a = quotient >> 16;
+    r482b = quotient >> 24;
+
+    r482c = remainder;
+    r482d = remainder >> 8;
+  }
+
+  r482f &= 0x7f;
+}
diff --git a/nSide/higan/sfc-balanced/coprocessor/spc7110/data.cpp b/nSide/higan/sfc-balanced/coprocessor/spc7110/data.cpp
new file mode 100644
index 0000000..b10c0f1
--- /dev/null
+++ b/nSide/higan/sfc-balanced/coprocessor/spc7110/data.cpp
@@ -0,0 +1,58 @@
+auto SPC7110::dataromRead(uint addr) -> uint8 {
+  uint size = 1 << (r4834 & 3);  //size in MB
+  uint mask = 0x100000 * size - 1;
+  uint offset = addr & mask;
+  if((r4834 & 3) != 3 && (addr & 0x400000)) return 0x00;
+  return drom.read(Bus::mirror(offset, drom.size()));
+}
+
+auto SPC7110::dataOffset() -> uint { return r4811 | r4812 << 8 | r4813 << 16; }
+auto SPC7110::dataAdjust() -> uint { return r4814 | r4815 << 8; }
+auto SPC7110::dataStride() -> uint { return r4816 | r4817 << 8; }
+auto SPC7110::setDataOffset(uint addr) -> void { r4811 = addr; r4812 = addr >> 8; r4813 = addr >> 16; }
+auto SPC7110::setDataAdjust(uint addr) -> void { r4814 = addr; r4815 = addr >> 8; }
+
+auto SPC7110::dataPortRead() -> void {
+  uint offset = dataOffset();
+  uint adjust = r4818 & 2 ? dataAdjust() : 0;
+  if(r4818 & 8) adjust = (int16)adjust;
+  r4810 = dataromRead(offset + adjust);
+}
+
+auto SPC7110::dataPortIncrement4810() -> void {
+  uint offset = dataOffset();
+  uint stride = r4818 & 1 ? dataStride() : 1;
+  uint adjust = dataAdjust();
+  if(r4818 & 4) stride = (int16)stride;
+  if(r4818 & 8) adjust = (int16)adjust;
+  if((r4818 & 16) == 0) setDataOffset(offset + stride);
+  if((r4818 & 16) != 0) setDataAdjust(adjust + stride);
+  dataPortRead();
+}
+
+auto SPC7110::dataPortIncrement4814() -> void {
+  if(r4818 >> 5 != 1) return;
+  uint offset = dataOffset();
+  uint adjust = dataAdjust();
+  if(r4818 & 8) adjust = (int16)adjust;
+  setDataOffset(offset + adjust);
+  dataPortRead();
+}
+
+auto SPC7110::dataPortIncrement4815() -> void {
+  if(r4818 >> 5 != 2) return;
+  uint offset = dataOffset();
+  uint adjust = dataAdjust();
+  if(r4818 & 8) adjust = (int16)adjust;
+  setDataOffset(offset + adjust);
+  dataPortRead();
+}
+
+auto SPC7110::dataPortIncrement481a() -> void {
+  if(r4818 >> 5 != 3) return;
+  uint offset = dataOffset();
+  uint adjust = dataAdjust();
+  if(r4818 & 8) adjust = (int16)adjust;
+  setDataOffset(offset + adjust);
+  dataPortRead();
+}
diff --git a/nSide/higan/sfc-balanced/coprocessor/spc7110/dcu.cpp b/nSide/higan/sfc-balanced/coprocessor/spc7110/dcu.cpp
new file mode 100644
index 0000000..b91f2b6
--- /dev/null
+++ b/nSide/higan/sfc-balanced/coprocessor/spc7110/dcu.cpp
@@ -0,0 +1,57 @@
+#include "decompressor.cpp"
+
+auto SPC7110::dcuLoadAddress() -> void {
+  uint table = r4801 | r4802 << 8 | r4803 << 16;
+  uint index = r4804 << 2;
+
+  uint address = table + index;
+  dcuMode     = dataromRead(address + 0);
+  dcuAddress  = dataromRead(address + 1) << 16;
+  dcuAddress |= dataromRead(address + 2) <<  8;
+  dcuAddress |= dataromRead(address + 3) <<  0;
+}
+
+auto SPC7110::dcuBeginTransfer() -> void {
+  if(dcuMode == 3) return;  //invalid mode
+
+  addClocks(20);
+  decompressor->initialize(dcuMode, dcuAddress);
+  decompressor->decode();
+
+  uint seek = r480b & 2 ? r4805 | r4806 << 8 : 0;
+  while(seek--) decompressor->decode();
+
+  r480c |= 0x80;
+  dcuOffset = 0;
+}
+
+auto SPC7110::dcuRead() -> uint8 {
+  if((r480c & 0x80) == 0) return 0x00;
+
+  if(dcuOffset == 0) {
+    for(auto row : range(8)) {
+      switch(decompressor->bpp) {
+      case 1:
+        dcuTile[row] = decompressor->result;
+        break;
+      case 2:
+        dcuTile[row * 2 + 0] = decompressor->result >> 0;
+        dcuTile[row * 2 + 1] = decompressor->result >> 8;
+        break;
+      case 4:
+        dcuTile[row * 2 +  0] = decompressor->result >>  0;
+        dcuTile[row * 2 +  1] = decompressor->result >>  8;
+        dcuTile[row * 2 + 16] = decompressor->result >> 16;
+        dcuTile[row * 2 + 17] = decompressor->result >> 24;
+        break;
+      }
+
+      uint seek = r480b & 1 ? r4807 : (uint8)1;
+      while(seek--) decompressor->decode();
+    }
+  }
+
+  uint8 data = dcuTile[dcuOffset++];
+  dcuOffset &= 8 * decompressor->bpp - 1;
+  return data;
+}
diff --git a/nSide/higan/sfc-balanced/coprocessor/spc7110/decompressor.cpp b/nSide/higan/sfc-balanced/coprocessor/spc7110/decompressor.cpp
new file mode 100644
index 0000000..0ab823a
--- /dev/null
+++ b/nSide/higan/sfc-balanced/coprocessor/spc7110/decompressor.cpp
@@ -0,0 +1,190 @@
+//SPC7110 decompressor
+//original implementation: neviksti
+//optimized implementation: cydrak
+
+struct Decompressor {
+  SPC7110& spc7110;
+
+  Decompressor(SPC7110& spc7110) : spc7110(spc7110) {}
+
+  auto read() -> uint8 {
+    return spc7110.dataromRead(offset++);
+  }
+
+  //inverse morton code transform: unpack big-endian packed pixels
+  //returns odd bits in lower half; even bits in upper half
+  auto deinterleave(uint64 data, uint bits) -> uint32 {
+    data = data & (1ull << bits) - 1;
+    data = 0x5555555555555555ull & (data << bits | data >> 1);
+    data = 0x3333333333333333ull & (data | data >> 1);
+    data = 0x0f0f0f0f0f0f0f0full & (data | data >> 2);
+    data = 0x00ff00ff00ff00ffull & (data | data >> 4);
+    data = 0x0000ffff0000ffffull & (data | data >> 8);
+    return data | data >> 16;
+  }
+
+  //extract a nibble and move it to the low four bits
+  auto moveToFront(uint64 list, uint nibble) -> uint64 {
+    for(uint64 n = 0, mask = ~15; n < 64; n += 4, mask <<= 4) {
+      if((list >> n & 15) != nibble) continue;
+      return list = (list & mask) + (list << 4 & ~mask) + nibble;
+    }
+    return list;
+  }
+
+  auto initialize(uint mode, uint origin) -> void {
+    for(auto& root : context) for(auto& node : root) node = {0, 0};
+    bpp = 1 << mode;
+    offset = origin;
+    bits = 8;
+    range = Max + 1;
+    input = read();
+    input = input << 8 | read();
+    output = 0;
+    pixels = 0;
+    colormap = 0xfedcba9876543210ull;
+  }
+
+  auto decode() -> void {
+    for(uint pixel = 0; pixel < 8; pixel++) {
+      uint64 map = colormap;
+      uint diff = 0;
+
+      if(bpp > 1) {
+        uint pa = (bpp == 2 ? pixels >>  2 & 3 : pixels >>  0 & 15);
+        uint pb = (bpp == 2 ? pixels >> 14 & 3 : pixels >> 28 & 15);
+        uint pc = (bpp == 2 ? pixels >> 16 & 3 : pixels >> 32 & 15);
+
+        if(pa != pb || pb != pc) {
+          uint match = pa ^ pb ^ pc;
+          diff = 4;                        //no match; all pixels differ
+          if((match ^ pc) == 0) diff = 3;  //a == b; pixel c differs
+          if((match ^ pb) == 0) diff = 2;  //c == a; pixel b differs
+          if((match ^ pa) == 0) diff = 1;  //b == c; pixel a differs
+        }
+
+        colormap = moveToFront(colormap, pa);
+
+        map = moveToFront(map, pc);
+        map = moveToFront(map, pb);
+        map = moveToFront(map, pa);
+      }
+
+      for(uint plane = 0; plane < bpp; plane++) {
+        uint bit = bpp > 1 ? 1 << plane : 1 << (pixel & 3);
+        uint history = bit - 1 & output;
+        uint set = 0;
+
+        if(bpp == 1) set = pixel >= 4;
+        if(bpp == 2) set = diff;
+        if(plane >= 2 && history <= 1) set = diff;
+
+        auto& ctx = context[set][bit + history - 1];
+        auto& model = evolution[ctx.prediction];
+        uint8 lps_offset = range - model.probability;
+        bool symbol = input >= (lps_offset << 8);  //test only the MSB
+
+        output = output << 1 | (symbol ^ ctx.swap);
+
+        if(symbol == MPS) {          //[0 ... range-p]
+          range = lps_offset;        //range = range-p
+        } else {                     //[range-p+1 ... range]
+          range -= lps_offset;       //range = p-1, with p < 0.75
+          input -= lps_offset << 8;  //therefore, always rescale
+        }
+
+        while(range <= Max / 2) {    //scale back into [0.75 ... 1.5]
+          ctx.prediction = model.next[symbol];
+
+          range <<= 1;
+          input <<= 1;
+
+          if(--bits == 0) {
+            bits = 8;
+            input += read();
+          }
+        }
+
+        if(symbol == LPS && model.probability > Half) ctx.swap ^= 1;
+      }
+
+      uint index = output & (1 << bpp) - 1;
+      if(bpp == 1) index ^= pixels >> 15 & 1;
+
+      pixels = pixels << bpp | (map >> 4 * index & 15);
+    }
+
+    if(bpp == 1) result = pixels;
+    if(bpp == 2) result = deinterleave(pixels, 16);
+    if(bpp == 4) result = deinterleave(deinterleave(pixels, 32), 32);
+  }
+
+  auto serialize(serializer& s) -> void {
+    for(auto& root : context) {
+      for(auto& node : root) {
+        s.integer(node.prediction);
+        s.integer(node.swap);
+      }
+    }
+
+    s.integer(bpp);
+    s.integer(offset);
+    s.integer(bits);
+    s.integer(range);
+    s.integer(input);
+    s.integer(output);
+    s.integer(pixels);
+    s.integer(colormap);
+    s.integer(result);
+  }
+
+  enum : uint { MPS = 0, LPS = 1 };
+  enum : uint { One = 0xaa, Half = 0x55, Max = 0xff };
+
+  struct ModelState {
+    uint8 probability;  //of the more probable symbol (MPS)
+    uint8 next[2];      //next state after output {MPS, LPS}
+  };
+  static ModelState evolution[53];
+
+  struct Context {
+    uint8 prediction;   //current model state
+    uint8 swap;         //if 1, exchange the role of MPS and LPS
+  } context[5][15];     //not all 75 contexts exists; this simplifies the code
+
+  uint bpp;             //bits per pixel (1bpp = 1; 2bpp = 2; 4bpp = 4)
+  uint offset;          //SPC7110 data ROM read offset
+  uint bits;            //bits remaining in input
+  uint16 range;         //arithmetic range: technically 8-bits, but Max+1 = 256
+  uint16 input;         //input data from SPC7110 data ROM
+  uint8 output;
+  uint64 pixels;
+  uint64 colormap;      //most recently used list
+  uint32 result;        //decompressed word after calling decode()
+};
+
+Decompressor::ModelState Decompressor::evolution[53] = {
+  {0x5a, { 1, 1}}, {0x25, { 2, 6}}, {0x11, { 3, 8}},
+  {0x08, { 4,10}}, {0x03, { 5,12}}, {0x01, { 5,15}},
+
+  {0x5a, { 7, 7}}, {0x3f, { 8,19}}, {0x2c, { 9,21}},
+  {0x20, {10,22}}, {0x17, {11,23}}, {0x11, {12,25}},
+  {0x0c, {13,26}}, {0x09, {14,28}}, {0x07, {15,29}},
+  {0x05, {16,31}}, {0x04, {17,32}}, {0x03, {18,34}},
+  {0x02, { 5,35}},
+
+  {0x5a, {20,20}}, {0x48, {21,39}}, {0x3a, {22,40}},
+  {0x2e, {23,42}}, {0x26, {24,44}}, {0x1f, {25,45}},
+  {0x19, {26,46}}, {0x15, {27,25}}, {0x11, {28,26}},
+  {0x0e, {29,26}}, {0x0b, {30,27}}, {0x09, {31,28}},
+  {0x08, {32,29}}, {0x07, {33,30}}, {0x05, {34,31}},
+  {0x04, {35,33}}, {0x04, {36,33}}, {0x03, {37,34}},
+  {0x02, {38,35}}, {0x02, { 5,36}},
+
+  {0x58, {40,39}}, {0x4d, {41,47}}, {0x43, {42,48}},
+  {0x3b, {43,49}}, {0x34, {44,50}}, {0x2e, {45,51}},
+  {0x29, {46,44}}, {0x25, {24,45}},
+
+  {0x56, {48,47}}, {0x4f, {49,47}}, {0x47, {50,48}},
+  {0x41, {51,49}}, {0x3c, {52,50}}, {0x37, {43,51}},
+};
diff --git a/nSide/higan/sfc-balanced/coprocessor/spc7110/serialization.cpp b/nSide/higan/sfc-balanced/coprocessor/spc7110/serialization.cpp
new file mode 100644
index 0000000..8c49071
--- /dev/null
+++ b/nSide/higan/sfc-balanced/coprocessor/spc7110/serialization.cpp
@@ -0,0 +1,59 @@
+auto SPC7110::serialize(serializer& s) -> void {
+  s.array(ram.data(), ram.size());
+
+  s.integer(r4801);
+  s.integer(r4802);
+  s.integer(r4803);
+  s.integer(r4804);
+  s.integer(r4805);
+  s.integer(r4806);
+  s.integer(r4807);
+  s.integer(r4809);
+  s.integer(r480a);
+  s.integer(r480b);
+  s.integer(r480c);
+
+  s.integer(dcuPending);
+  s.integer(dcuMode);
+  s.integer(dcuAddress);
+  s.integer(dcuOffset);
+  s.array(dcuTile);
+  decompressor->serialize(s);
+
+  s.integer(r4810);
+  s.integer(r4811);
+  s.integer(r4812);
+  s.integer(r4813);
+  s.integer(r4814);
+  s.integer(r4815);
+  s.integer(r4816);
+  s.integer(r4817);
+  s.integer(r4818);
+  s.integer(r481a);
+
+  s.integer(r4820);
+  s.integer(r4821);
+  s.integer(r4822);
+  s.integer(r4823);
+  s.integer(r4824);
+  s.integer(r4825);
+  s.integer(r4826);
+  s.integer(r4827);
+  s.integer(r4828);
+  s.integer(r4829);
+  s.integer(r482a);
+  s.integer(r482b);
+  s.integer(r482c);
+  s.integer(r482d);
+  s.integer(r482e);
+  s.integer(r482f);
+
+  s.integer(mulPending);
+  s.integer(divPending);
+
+  s.integer(r4830);
+  s.integer(r4831);
+  s.integer(r4832);
+  s.integer(r4833);
+  s.integer(r4834);
+}
diff --git a/nSide/higan/sfc-balanced/coprocessor/spc7110/spc7110.cpp b/nSide/higan/sfc-balanced/coprocessor/spc7110/spc7110.cpp
new file mode 100644
index 0000000..d4b558c
--- /dev/null
+++ b/nSide/higan/sfc-balanced/coprocessor/spc7110/spc7110.cpp
@@ -0,0 +1,314 @@
+#include <sfc-balanced/sfc.hpp>
+
+namespace SuperFamicom {
+
+#include "dcu.cpp"
+#include "data.cpp"
+#include "alu.cpp"
+#include "serialization.cpp"
+SPC7110 spc7110;
+
+SPC7110::SPC7110() {
+  decompressor = new Decompressor(*this);
+}
+
+SPC7110::~SPC7110() {
+  delete decompressor;
+}
+
+auto SPC7110::Enter() -> void {
+  while(true) scheduler.synchronize(), spc7110.main();
+}
+
+auto SPC7110::main() -> void {
+  if(dcuPending) { dcuPending = 0; dcuBeginTransfer(); }
+  if(mulPending) { mulPending = 0; aluMultiply(); }
+  if(divPending) { divPending = 0; aluDivide(); }
+  addClocks(1);
+}
+
+auto SPC7110::addClocks(uint clocks) -> void {
+  step(clocks);
+  synchronize(cpu);
+}
+
+auto SPC7110::init() -> void {
+}
+
+auto SPC7110::load() -> void {
+}
+
+auto SPC7110::unload() -> void {
+  prom.reset();
+  drom.reset();
+  ram.reset();
+}
+
+auto SPC7110::power() -> void {
+}
+
+auto SPC7110::reset() -> void {
+  create(SPC7110::Enter, 21'477'272);
+
+  r4801 = 0x00;
+  r4802 = 0x00;
+  r4803 = 0x00;
+  r4804 = 0x00;
+  r4805 = 0x00;
+  r4806 = 0x00;
+  r4807 = 0x00;
+  r4809 = 0x00;
+  r480a = 0x00;
+  r480b = 0x00;
+  r480c = 0x00;
+
+  dcuPending = 0;
+  dcuMode = 0;
+  dcuAddress = 0;
+
+  r4810 = 0x00;
+  r4811 = 0x00;
+  r4812 = 0x00;
+  r4813 = 0x00;
+  r4814 = 0x00;
+  r4815 = 0x00;
+  r4816 = 0x00;
+  r4817 = 0x00;
+  r4818 = 0x00;
+  r481a = 0x00;
+
+  r4820 = 0x00;
+  r4821 = 0x00;
+  r4822 = 0x00;
+  r4823 = 0x00;
+  r4824 = 0x00;
+  r4825 = 0x00;
+  r4826 = 0x00;
+  r4827 = 0x00;
+  r4828 = 0x00;
+  r4829 = 0x00;
+  r482a = 0x00;
+  r482b = 0x00;
+  r482c = 0x00;
+  r482d = 0x00;
+  r482e = 0x00;
+  r482f = 0x00;
+
+  mulPending = 0;
+  divPending = 0;
+
+  r4830 = 0x00;
+  r4831 = 0x00;
+  r4832 = 0x01;
+  r4833 = 0x02;
+  r4834 = 0x00;
+}
+
+auto SPC7110::read(uint24 addr, uint8 data) -> uint8 {
+  cpu.synchronize(*this);
+  if((addr & 0xff0000) == 0x500000) addr = 0x4800;  //$50:0000-ffff == $4800
+  if((addr & 0xff0000) == 0x580000) addr = 0x4808;  //$58:0000-ffff == $4808
+  addr = 0x4800 | (addr & 0x3f);  //$00-3f,80-bf:4800-483f
+
+  switch(addr) {
+  //==================
+  //decompression unit
+  //==================
+  case 0x4800: {
+    uint16 counter = r4809 | r480a << 8;
+    counter--;
+    r4809 = counter >> 0;
+    r480a = counter >> 8;
+    return dcuRead();
+  }
+  case 0x4801: return r4801;
+  case 0x4802: return r4802;
+  case 0x4803: return r4803;
+  case 0x4804: return r4804;
+  case 0x4805: return r4805;
+  case 0x4806: return r4806;
+  case 0x4807: return r4807;
+  case 0x4808: return 0x00;
+  case 0x4809: return r4809;
+  case 0x480a: return r480a;
+  case 0x480b: return r480b;
+  case 0x480c: return r480c;
+
+  //==============
+  //data port unit
+  //==============
+  case 0x4810: {
+    data = r4810;
+    dataPortIncrement4810();
+    return data;
+  }
+  case 0x4811: return r4811;
+  case 0x4812: return r4812;
+  case 0x4813: return r4813;
+  case 0x4814: return r4814;
+  case 0x4815: return r4815;
+  case 0x4816: return r4816;
+  case 0x4817: return r4817;
+  case 0x4818: return r4818;
+  case 0x481a: {
+    dataPortIncrement481a();
+    return 0x00;
+  }
+
+  //=====================
+  //arithmetic logic unit
+  //=====================
+  case 0x4820: return r4820;
+  case 0x4821: return r4821;
+  case 0x4822: return r4822;
+  case 0x4823: return r4823;
+  case 0x4824: return r4824;
+  case 0x4825: return r4825;
+  case 0x4826: return r4826;
+  case 0x4827: return r4827;
+  case 0x4828: return r4828;
+  case 0x4829: return r4829;
+  case 0x482a: return r482a;
+  case 0x482b: return r482b;
+  case 0x482c: return r482c;
+  case 0x482d: return r482d;
+  case 0x482e: return r482e;
+  case 0x482f: return r482f;
+
+  //===================
+  //memory control unit
+  //===================
+  case 0x4830: return r4830;
+  case 0x4831: return r4831;
+  case 0x4832: return r4832;
+  case 0x4833: return r4833;
+  case 0x4834: return r4834;
+  }
+
+  return data;
+}
+
+auto SPC7110::write(uint24 addr, uint8 data) -> void {
+  cpu.synchronize(*this);
+  if((addr & 0xff0000) == 0x500000) addr = 0x4800;  //$50:0000-ffff == $4800
+  if((addr & 0xff0000) == 0x580000) addr = 0x4808;  //$58:0000-ffff == $4808
+  addr = 0x4800 | (addr & 0x3f);  //$00-3f,80-bf:4800-483f
+
+  switch(addr) {
+  //==================
+  //decompression unit
+  //==================
+  case 0x4801: r4801 = data; break;
+  case 0x4802: r4802 = data; break;
+  case 0x4803: r4803 = data; break;
+  case 0x4804: r4804 = data; dcuLoadAddress(); break;
+  case 0x4805: r4805 = data; break;
+  case 0x4806: r4806 = data; r480c &= 0x7f; dcuPending = 1; break;
+  case 0x4807: r4807 = data; break;
+  case 0x4808: break;
+  case 0x4809: r4809 = data; break;
+  case 0x480a: r480a = data; break;
+  case 0x480b: r480b = data & 0x03; break;
+
+  //==============
+  //data port unit
+  //==============
+  case 0x4811: r4811 = data; break;
+  case 0x4812: r4812 = data; break;
+  case 0x4813: r4813 = data; dataPortRead(); break;
+  case 0x4814: r4814 = data; dataPortIncrement4814(); break;
+  case 0x4815: r4815 = data; if(r4818 & 2) dataPortRead(); dataPortIncrement4815(); break;
+  case 0x4816: r4816 = data; break;
+  case 0x4817: r4817 = data; break;
+  case 0x4818: r4818 = data & 0x7f; dataPortRead(); break;
+
+  //=====================
+  //arithmetic logic unit
+  //=====================
+  case 0x4820: r4820 = data; break;
+  case 0x4821: r4821 = data; break;
+  case 0x4822: r4822 = data; break;
+  case 0x4823: r4823 = data; break;
+  case 0x4824: r4824 = data; break;
+  case 0x4825: r4825 = data; r482f |= 0x81; mulPending = 1; break;
+  case 0x4826: r4826 = data; break;
+  case 0x4827: r4827 = data; r482f |= 0x80; divPending = 1; break;
+  case 0x482e: r482e = data & 0x01; break;
+
+  //===================
+  //memory control unit
+  //===================
+  case 0x4830: r4830 = data & 0x87; break;
+  case 0x4831: r4831 = data & 0x07; break;
+  case 0x4832: r4832 = data & 0x07; break;
+  case 0x4833: r4833 = data & 0x07; break;
+  case 0x4834: r4834 = data & 0x07; break;
+  }
+}
+
+//===============
+//SPC7110::MCUROM
+//===============
+
+//map address=00-3f,80-bf:8000-ffff mask=0x800000 => 00-3f:8000-ffff
+//map address=c0-ff:0000-ffff mask=0xc00000 => c0-ff:0000-ffff
+auto SPC7110::mcuromRead(uint24 addr, uint8 data) -> uint8 {
+  uint mask = (1 << (r4834 & 3)) - 1;  //8mbit, 16mbit, 32mbit, 64mbit DROM
+
+  if(addr < 0x100000) {  //$00-0f,80-8f:8000-ffff; $c0-cf:0000-ffff
+    addr &= 0x0fffff;
+    if(prom.size()) {  //8mbit PROM
+      return prom.read(bus.mirror(0x000000 + addr, prom.size()));
+    }
+    addr |= 0x100000 * (r4830 & 7);
+    return dataromRead(addr);
+  }
+
+  if(addr < 0x200000) {  //$10-1f,90-9f:8000-ffff; $d0-df:0000-ffff
+    addr &= 0x0fffff;
+    if(r4834 & 4) {  //16mbit PROM
+      return prom.read(bus.mirror(0x100000 + addr, prom.size()));
+    }
+    addr |= 0x100000 * (r4831 & 7);
+    return dataromRead(addr);
+  }
+
+  if(addr < 0x300000) {  //$20-2f,a0-af:8000-ffff; $e0-ef:0000-ffff
+    addr &= 0x0fffff;
+    addr |= 0x100000 * (r4832 & 7);
+    return dataromRead(addr);
+  }
+
+  if(addr < 0x400000) {  //$30-3f,b0-bf:8000-ffff; $f0-ff:0000-ffff
+    addr &= 0x0fffff;
+    addr |= 0x100000 * (r4833 & 7);
+    return dataromRead(addr);
+  }
+
+  return data;
+}
+
+auto SPC7110::mcuromWrite(uint24 addr, uint8 data) -> void {
+}
+
+//===============
+//SPC7110::MCURAM
+//===============
+
+//map address=00-3f,80-bf:6000-7fff mask=0x80e000 => 00-07:0000-ffff
+auto SPC7110::mcuramRead(uint24 addr, uint8) -> uint8 {
+  if(r4830 & 0x80) {
+    addr = bus.mirror(addr, ram.size());
+    return ram.read(addr);
+  }
+  return 0x00;
+}
+
+auto SPC7110::mcuramWrite(uint24 addr, uint8 data) -> void {
+  if(r4830 & 0x80) {
+    addr = bus.mirror(addr, ram.size());
+    ram.write(addr, data);
+  }
+}
+
+}
diff --git a/nSide/higan/sfc-balanced/coprocessor/spc7110/spc7110.hpp b/nSide/higan/sfc-balanced/coprocessor/spc7110/spc7110.hpp
new file mode 100644
index 0000000..cea52a6
--- /dev/null
+++ b/nSide/higan/sfc-balanced/coprocessor/spc7110/spc7110.hpp
@@ -0,0 +1,124 @@
+struct Decompressor;
+
+struct SPC7110 : Thread {
+  SPC7110();
+  ~SPC7110();
+
+  static auto Enter() -> void;
+  auto main() -> void;
+  auto init() -> void;
+  auto load() -> void;
+  auto unload() -> void;
+  auto power() -> void;
+  auto reset() -> void;
+
+  auto addClocks(uint clocks) -> void;
+
+  auto read(uint24 addr, uint8 data) -> uint8;
+  auto write(uint24 addr, uint8 data) -> void;
+
+  auto mcuromRead(uint24 addr, uint8 data) -> uint8;
+  auto mcuromWrite(uint24 addr, uint8 data) -> void;
+
+  auto mcuramRead(uint24 addr, uint8 data) -> uint8;
+  auto mcuramWrite(uint24 addr, uint8 data) -> void;
+
+  auto serialize(serializer&) -> void;
+
+  //dcu.cpp
+  auto dcuLoadAddress() -> void;
+  auto dcuBeginTransfer() -> void;
+  auto dcuRead() -> uint8;
+
+  auto deinterleave1bpp(uint length) -> void;
+  auto deinterleave2bpp(uint length) -> void;
+  auto deinterleave4bpp(uint length) -> void;
+
+  //data.cpp
+  auto dataromRead(uint addr) -> uint8;
+
+  auto dataOffset() -> uint;
+  auto dataAdjust() -> uint;
+  auto dataStride() -> uint;
+
+  auto setDataOffset(uint addr) -> void;
+  auto setDataAdjust(uint addr) -> void;
+
+  auto dataPortRead() -> void;
+
+  auto dataPortIncrement4810() -> void;
+  auto dataPortIncrement4814() -> void;
+  auto dataPortIncrement4815() -> void;
+  auto dataPortIncrement481a() -> void;
+
+  //alu.cpp
+  auto aluMultiply() -> void;
+  auto aluDivide() -> void;
+
+  MappedRAM prom;  //program ROM
+  MappedRAM drom;  //data ROM
+  MappedRAM ram;
+
+private:
+  //decompression unit
+  uint8 r4801;  //compression table B0
+  uint8 r4802;  //compression table B1
+  uint7 r4803;  //compression table B2
+  uint8 r4804;  //compression table index
+  uint8 r4805;  //adjust length B0
+  uint8 r4806;  //adjust length B1
+  uint8 r4807;  //stride length
+  uint8 r4809;  //compression counter B0
+  uint8 r480a;  //compression counter B1
+  uint8 r480b;  //decompression settings
+  uint8 r480c;  //decompression status
+
+  bool dcuPending;
+  uint2 dcuMode;
+  uint23 dcuAddress;
+  uint dcuOffset;
+  uint8 dcuTile[32];
+  Decompressor* decompressor;
+
+  //data port unit
+  uint8 r4810;  //data port read + seek
+  uint8 r4811;  //data offset B0
+  uint8 r4812;  //data offset B1
+  uint7 r4813;  //data offset B2
+  uint8 r4814;  //data adjust B0
+  uint8 r4815;  //data adjust B1
+  uint8 r4816;  //data stride B0
+  uint8 r4817;  //data stride B1
+  uint8 r4818;  //data port settings
+  uint8 r481a;  //data port seek
+
+  //arithmetic logic unit
+  uint8 r4820;  //16-bit multiplicand B0, 32-bit dividend B0
+  uint8 r4821;  //16-bit multiplicand B1, 32-bit dividend B1
+  uint8 r4822;  //32-bit dividend B2
+  uint8 r4823;  //32-bit dividend B3
+  uint8 r4824;  //16-bit multiplier B0
+  uint8 r4825;  //16-bit multiplier B1
+  uint8 r4826;  //16-bit divisor B0
+  uint8 r4827;  //16-bit divisor B1
+  uint8 r4828;  //32-bit product B0, 32-bit quotient B0
+  uint8 r4829;  //32-bit product B1, 32-bit quotient B1
+  uint8 r482a;  //32-bit product B2, 32-bit quotient B2
+  uint8 r482b;  //32-bit product B3, 32-bit quotient B3
+  uint8 r482c;  //16-bit remainder B0
+  uint8 r482d;  //16-bit remainder B1
+  uint8 r482e;  //math settings
+  uint8 r482f;  //math status
+
+  bool mulPending;
+  bool divPending;
+
+  //memory control unit
+  uint8 r4830;  //bank 0 mapping + SRAM write enable
+  uint8 r4831;  //bank 1 mapping
+  uint8 r4832;  //bank 2 mapping
+  uint8 r4833;  //bank 3 mapping
+  uint8 r4834;  //bank mapping settings
+};
+
+extern SPC7110 spc7110;
diff --git a/nSide/higan/sfc-balanced/coprocessor/superfx/bus.cpp b/nSide/higan/sfc-balanced/coprocessor/superfx/bus.cpp
new file mode 100644
index 0000000..d7d7306
--- /dev/null
+++ b/nSide/higan/sfc-balanced/coprocessor/superfx/bus.cpp
@@ -0,0 +1,33 @@
+//ROM / RAM access from the S-CPU
+
+auto SuperFX::CPUROM::size() const -> uint {
+  return superfx.rom.size();
+}
+
+auto SuperFX::CPUROM::read(uint24 addr, uint8 data) -> uint8 {
+  if(superfx.regs.sfr.g && superfx.regs.scmr.ron) {
+    static const uint8 vector[16] = {
+      0x00, 0x01, 0x00, 0x01, 0x04, 0x01, 0x00, 0x01,
+      0x00, 0x01, 0x08, 0x01, 0x00, 0x01, 0x0c, 0x01,
+    };
+    return vector[addr & 15];
+  }
+  return superfx.rom.read(addr, data);
+}
+
+auto SuperFX::CPUROM::write(uint24 addr, uint8 data) -> void {
+  superfx.rom.write(addr, data);
+}
+
+auto SuperFX::CPURAM::size() const -> uint {
+  return superfx.ram.size();
+}
+
+auto SuperFX::CPURAM::read(uint24 addr, uint8 data) -> uint8 {
+  if(superfx.regs.sfr.g && superfx.regs.scmr.ran) return data;
+  return superfx.ram.read(addr, data);
+}
+
+auto SuperFX::CPURAM::write(uint24 addr, uint8 data) -> void {
+  superfx.ram.write(addr, data);
+}
diff --git a/nSide/higan/sfc-balanced/coprocessor/superfx/core.cpp b/nSide/higan/sfc-balanced/coprocessor/superfx/core.cpp
new file mode 100644
index 0000000..9c2b241
--- /dev/null
+++ b/nSide/higan/sfc-balanced/coprocessor/superfx/core.cpp
@@ -0,0 +1,104 @@
+auto SuperFX::stop() -> void {
+  cpu.r.irq = 1;
+}
+
+auto SuperFX::color(uint8 source) -> uint8 {
+  if(regs.por.highnibble) return (regs.colr & 0xf0) | (source >> 4);
+  if(regs.por.freezehigh) return (regs.colr & 0xf0) | (source & 0x0f);
+  return source;
+}
+
+auto SuperFX::plot(uint8 x, uint8 y) -> void {
+  uint8 color = regs.colr;
+
+  if(regs.por.dither && regs.scmr.md != 3) {
+    if((x ^ y) & 1) color >>= 4;
+    color &= 0x0f;
+  }
+
+  if(!regs.por.transparent) {
+    if(regs.scmr.md == 3) {
+      if(regs.por.freezehigh) {
+        if((color & 0x0f) == 0) return;
+      } else {
+        if(color == 0) return;
+      }
+    } else {
+      if((color & 0x0f) == 0) return;
+    }
+  }
+
+  uint16 offset = (y << 5) + (x >> 3);
+  if(offset != pixelcache[0].offset) {
+    flushPixelCache(pixelcache[1]);
+    pixelcache[1] = pixelcache[0];
+    pixelcache[0].bitpend = 0x00;
+    pixelcache[0].offset = offset;
+  }
+
+  x = (x & 7) ^ 7;
+  pixelcache[0].data[x] = color;
+  pixelcache[0].bitpend |= 1 << x;
+  if(pixelcache[0].bitpend == 0xff) {
+    flushPixelCache(pixelcache[1]);
+    pixelcache[1] = pixelcache[0];
+    pixelcache[0].bitpend = 0x00;
+  }
+}
+
+auto SuperFX::rpix(uint8 x, uint8 y) -> uint8 {
+  flushPixelCache(pixelcache[1]);
+  flushPixelCache(pixelcache[0]);
+
+  uint cn;  //character number
+  switch(regs.por.obj ? 3 : regs.scmr.ht) {
+  case 0: cn = ((x & 0xf8) << 1) + ((y & 0xf8) >> 3); break;
+  case 1: cn = ((x & 0xf8) << 1) + ((x & 0xf8) >> 1) + ((y & 0xf8) >> 3); break;
+  case 2: cn = ((x & 0xf8) << 1) + ((x & 0xf8) << 0) + ((y & 0xf8) >> 3); break;
+  case 3: cn = ((y & 0x80) << 2) + ((x & 0x80) << 1) + ((y & 0x78) << 1) + ((x & 0x78) >> 3); break;
+  }
+  uint bpp = 2 << (regs.scmr.md - (regs.scmr.md >> 1));  // = [regs.scmr.md]{ 2, 4, 4, 8 };
+  uint addr = 0x700000 + (cn * (bpp << 3)) + (regs.scbr << 10) + ((y & 0x07) * 2);
+  uint8 data = 0x00;
+  x = (x & 7) ^ 7;
+
+  for(uint n : range(bpp)) {
+    uint byte = ((n >> 1) << 4) + (n & 1);  // = [n]{ 0, 1, 16, 17, 32, 33, 48, 49 };
+    step(regs.clsr ? 5 : 6);
+    data |= ((read(addr + byte) >> x) & 1) << n;
+  }
+
+  return data;
+}
+
+auto SuperFX::flushPixelCache(PixelCache& cache) -> void {
+  if(cache.bitpend == 0x00) return;
+
+  uint8 x = cache.offset << 3;
+  uint8 y = cache.offset >> 5;
+
+  uint cn;  //character number
+  switch(regs.por.obj ? 3 : regs.scmr.ht) {
+  case 0: cn = ((x & 0xf8) << 1) + ((y & 0xf8) >> 3); break;
+  case 1: cn = ((x & 0xf8) << 1) + ((x & 0xf8) >> 1) + ((y & 0xf8) >> 3); break;
+  case 2: cn = ((x & 0xf8) << 1) + ((x & 0xf8) << 0) + ((y & 0xf8) >> 3); break;
+  case 3: cn = ((y & 0x80) << 2) + ((x & 0x80) << 1) + ((y & 0x78) << 1) + ((x & 0x78) >> 3); break;
+  }
+  uint bpp = 2 << (regs.scmr.md - (regs.scmr.md >> 1));  // = [regs.scmr.md]{ 2, 4, 4, 8 };
+  uint addr = 0x700000 + (cn * (bpp << 3)) + (regs.scbr << 10) + ((y & 0x07) * 2);
+
+  for(uint n : range(bpp)) {
+    uint byte = ((n >> 1) << 4) + (n & 1);  // = [n]{ 0, 1, 16, 17, 32, 33, 48, 49 };
+    uint8 data = 0x00;
+    for(uint x : range(8)) data |= ((cache.data[x] >> n) & 1) << x;
+    if(cache.bitpend != 0xff) {
+      step(regs.clsr ? 5 : 6);
+      data &= cache.bitpend;
+      data |= read(addr + byte) & ~cache.bitpend;
+    }
+    step(regs.clsr ? 5 : 6);
+    write(addr + byte, data);
+  }
+
+  cache.bitpend = 0x00;
+}
diff --git a/nSide/higan/sfc-balanced/coprocessor/superfx/io.cpp b/nSide/higan/sfc-balanced/coprocessor/superfx/io.cpp
new file mode 100644
index 0000000..372dd4c
--- /dev/null
+++ b/nSide/higan/sfc-balanced/coprocessor/superfx/io.cpp
@@ -0,0 +1,113 @@
+auto SuperFX::readIO(uint24 addr, uint8) -> uint8 {
+  cpu.synchronize(*this);
+  addr = 0x3000 | addr.bits(0,9);
+
+  if(addr >= 0x3100 && addr <= 0x32ff) {
+    return readCache(addr - 0x3100);
+  }
+
+  if(addr >= 0x3000 && addr <= 0x301f) {
+    return regs.r[(addr >> 1) & 15] >> ((addr & 1) << 3);
+  }
+
+  switch(addr) {
+  case 0x3030: {
+    return regs.sfr >> 0;
+  }
+
+  case 0x3031: {
+    uint8 r = regs.sfr >> 8;
+    regs.sfr.irq = 0;
+    cpu.r.irq = 0;
+    return r;
+  }
+
+  case 0x3034: {
+    return regs.pbr;
+  }
+
+  case 0x3036: {
+    return regs.rombr;
+  }
+
+  case 0x303b: {
+    return regs.vcr;
+  }
+
+  case 0x303c: {
+    return regs.rambr;
+  }
+
+  case 0x303e: {
+    return regs.cbr >> 0;
+  }
+
+  case 0x303f: {
+    return regs.cbr >> 8;
+  }
+  }
+
+  return 0x00;
+}
+
+auto SuperFX::writeIO(uint24 addr, uint8 data) -> void {
+  cpu.synchronize(*this);
+  addr = 0x3000 | addr.bits(0,9);
+
+  if(addr >= 0x3100 && addr <= 0x32ff) {
+    return writeCache(addr - 0x3100, data);
+  }
+
+  if(addr >= 0x3000 && addr <= 0x301f) {
+    uint n = (addr >> 1) & 15;
+    if((addr & 1) == 0) {
+      regs.r[n] = (regs.r[n] & 0xff00) | data;
+    } else {
+      regs.r[n] = (data << 8) | (regs.r[n] & 0xff);
+    }
+    if(n == 14) updateROMBuffer();
+
+    if(addr == 0x301f) regs.sfr.g = 1;
+    return;
+  }
+
+  switch(addr) {
+  case 0x3030: {
+    bool g = regs.sfr.g;
+    regs.sfr = (regs.sfr & 0xff00) | (data << 0);
+    if(g == 1 && regs.sfr.g == 0) {
+      regs.cbr = 0x0000;
+      flushCache();
+    }
+  } break;
+
+  case 0x3031: {
+    regs.sfr = (data << 8) | (regs.sfr & 0x00ff);
+  } break;
+
+  case 0x3033: {
+    regs.bramr = data & 0x01;
+  } break;
+
+  case 0x3034: {
+    regs.pbr = data & 0x7f;
+    flushCache();
+  } break;
+
+  case 0x3037: {
+    regs.cfgr = data;
+  } break;
+
+  case 0x3038: {
+    regs.scbr = data;
+  } break;
+
+  case 0x3039: {
+    regs.clsr = data & 0x01;
+  } break;
+
+  case 0x303a: {
+    regs.scmr = data;
+  } break;
+  }
+}
diff --git a/nSide/higan/sfc-balanced/coprocessor/superfx/memory.cpp b/nSide/higan/sfc-balanced/coprocessor/superfx/memory.cpp
new file mode 100644
index 0000000..3f1efc2
--- /dev/null
+++ b/nSide/higan/sfc-balanced/coprocessor/superfx/memory.cpp
@@ -0,0 +1,96 @@
+auto SuperFX::read(uint24 addr, uint8 data) -> uint8 {
+  if((addr & 0xc00000) == 0x000000) {  //$00-3f:0000-7fff,:8000-ffff
+    while(!regs.scmr.ron) {
+      step(6);
+      synchronize(cpu);
+    }
+    return rom.read((((addr & 0x3f0000) >> 1) | (addr & 0x7fff)) & romMask);
+  }
+
+  if((addr & 0xe00000) == 0x400000) {  //$40-5f:0000-ffff
+    while(!regs.scmr.ron) {
+      step(6);
+      synchronize(cpu);
+    }
+    return rom.read(addr & romMask);
+  }
+
+  if((addr & 0xe00000) == 0x600000) {  //$60-7f:0000-ffff
+    while(!regs.scmr.ran) {
+      step(6);
+      synchronize(cpu);
+    }
+    return ram.read(addr & ramMask);
+  }
+
+  return data;
+}
+
+auto SuperFX::write(uint24 addr, uint8 data) -> void {
+  if((addr & 0xe00000) == 0x600000) {  //$60-7f:0000-ffff
+    while(!regs.scmr.ran) {
+      step(6);
+      synchronize(cpu);
+    }
+    return ram.write(addr & ramMask, data);
+  }
+}
+
+auto SuperFX::readOpcode(uint16 addr) -> uint8 {
+  uint16 offset = addr - regs.cbr;
+  if(offset < 512) {
+    if(cache.valid[offset >> 4] == false) {
+      uint dp = offset & 0xfff0;
+      uint sp = (regs.pbr << 16) + ((regs.cbr + dp) & 0xfff0);
+      for(uint n : range(16)) {
+        step(regs.clsr ? 5 : 6);
+        cache.buffer[dp++] = read(sp++);
+      }
+      cache.valid[offset >> 4] = true;
+    } else {
+      step(regs.clsr ? 1 : 2);
+    }
+    return cache.buffer[offset];
+  }
+
+  if(regs.pbr <= 0x5f) {
+    //$00-5f:0000-ffff ROM
+    syncROMBuffer();
+    step(regs.clsr ? 5 : 6);
+    return read(regs.pbr << 16 | addr);
+  } else {
+    //$60-7f:0000-ffff RAM
+    syncRAMBuffer();
+    step(regs.clsr ? 5 : 6);
+    return read(regs.pbr << 16 | addr);
+  }
+}
+
+auto SuperFX::peekpipe() -> uint8 {
+  uint8 result = regs.pipeline;
+  regs.pipeline = readOpcode(regs.r[15]);
+  regs.r[15].modified = false;
+  return result;
+}
+
+auto SuperFX::pipe() -> uint8 {
+  uint8 result = regs.pipeline;
+  regs.pipeline = readOpcode(++regs.r[15]);
+  regs.r[15].modified = false;
+  return result;
+}
+
+auto SuperFX::flushCache() -> void {
+  for(uint n : range(32)) cache.valid[n] = false;
+}
+
+auto SuperFX::readCache(uint16 addr) -> uint8 {
+  addr = (addr + regs.cbr) & 511;
+  return cache.buffer[addr];
+}
+
+auto SuperFX::writeCache(uint16 addr, uint8 data) -> void {
+  addr = (addr + regs.cbr) & 511;
+  cache.buffer[addr] = data;
+  if((addr & 15) == 15) cache.valid[addr >> 4] = true;
+}
diff --git a/nSide/higan/sfc-balanced/coprocessor/superfx/serialization.cpp b/nSide/higan/sfc-balanced/coprocessor/superfx/serialization.cpp
new file mode 100644
index 0000000..214f5dd
--- /dev/null
+++ b/nSide/higan/sfc-balanced/coprocessor/superfx/serialization.cpp
@@ -0,0 +1,6 @@
+auto SuperFX::serialize(serializer& s) -> void {
+  GSU::serialize(s);
+  Thread::serialize(s);
+
+  s.array(ram.data(), ram.size());
+}
diff --git a/nSide/higan/sfc-balanced/coprocessor/superfx/superfx.cpp b/nSide/higan/sfc-balanced/coprocessor/superfx/superfx.cpp
new file mode 100644
index 0000000..d23e2e6
--- /dev/null
+++ b/nSide/higan/sfc-balanced/coprocessor/superfx/superfx.cpp
@@ -0,0 +1,71 @@
+#include <sfc-balanced/sfc.hpp>
+
+namespace SuperFamicom {
+
+#include "bus.cpp"
+#include "core.cpp"
+#include "memory.cpp"
+#include "io.cpp"
+#include "timing.cpp"
+#include "serialization.cpp"
+SuperFX superfx;
+
+auto SuperFX::Enter() -> void {
+  while(true) scheduler.synchronize(), superfx.main();
+}
+
+auto SuperFX::main() -> void {
+  if(regs.sfr.g == 0) return step(6);
+
+  instruction(peekpipe());
+
+  if(regs.r[14].modified) {
+    regs.r[14].modified = false;
+    updateROMBuffer();
+  }
+
+  if(regs.r[15].modified) {
+    regs.r[15].modified = false;
+  } else {
+    regs.r[15]++;
+  }
+}
+
+auto SuperFX::init() -> void {
+}
+
+auto SuperFX::load() -> void {
+}
+
+auto SuperFX::unload() -> void {
+  rom.reset();
+  ram.reset();
+}
+
+auto SuperFX::power() -> void {
+  GSU::power();
+}
+
+auto SuperFX::reset() -> void {
+  GSU::reset();
+  create(SuperFX::Enter, system.colorburst() * 6.0);
+
+  romMask = rom.size() - 1;
+  ramMask = ram.size() - 1;
+
+  for(uint n : range(512)) cache.buffer[n] = 0x00;
+  for(uint n : range(32)) cache.valid[n] = false;
+  for(uint n : range(2)) {
+    pixelcache[n].offset = ~0;
+    pixelcache[n].bitpend = 0x00;
+  }
+
+  regs.romcl = 0;
+  regs.romdr = 0;
+
+  regs.ramcl = 0;
+  regs.ramar = 0;
+  regs.ramdr = 0;
+}
+
+}
diff --git a/nSide/higan/sfc-balanced/coprocessor/superfx/superfx.hpp b/nSide/higan/sfc-balanced/coprocessor/superfx/superfx.hpp
new file mode 100644
index 0000000..2d9f7d9
--- /dev/null
+++ b/nSide/higan/sfc-balanced/coprocessor/superfx/superfx.hpp
@@ -0,0 +1,73 @@
+struct SuperFX : Processor::GSU, Thread {
+  MappedRAM rom;
+  MappedRAM ram;
+
+  //superfx.cpp
+  static auto Enter() -> void;
+  auto main() -> void;
+  auto init() -> void;
+  auto load() -> void;
+  auto unload() -> void;
+  auto power() -> void;
+  auto reset() -> void;
+
+  //bus.cpp
+  struct CPUROM : Memory {
+    auto size() const -> uint;
+    auto read(uint24, uint8) -> uint8;
+    auto write(uint24, uint8) -> void;
+  };
+
+  struct CPURAM : Memory {
+    auto size() const -> uint;
+    auto read(uint24, uint8) -> uint8;
+    auto write(uint24, uint8) -> void;
+  };
+
+  //core.cpp
+  auto stop() -> void override;
+  auto color(uint8 source) -> uint8 override;
+  auto plot(uint8 x, uint8 y) -> void override;
+  auto rpix(uint8 x, uint8 y) -> uint8 override;
+
+  auto flushPixelCache(PixelCache& cache) -> void;
+
+  //memory.cpp
+  auto read(uint24 addr, uint8 data = 0x00) -> uint8 override;
+  auto write(uint24 addr, uint8 data) -> void override;
+
+  auto readOpcode(uint16 addr) -> uint8;
+  alwaysinline auto peekpipe() -> uint8;
+  alwaysinline auto pipe() -> uint8 override;
+
+  auto flushCache() -> void override;
+  auto readCache(uint16 addr) -> uint8;
+  auto writeCache(uint16 addr, uint8 data) -> void;
+
+  //io.cpp
+  auto readIO(uint24 addr, uint8 data) -> uint8;
+  auto writeIO(uint24 addr, uint8 data) -> void;
+
+  //timing.cpp
+  auto step(uint clocks) -> void override;
+
+  auto syncROMBuffer() -> void override;
+  auto readROMBuffer() -> uint8 override;
+  auto updateROMBuffer() -> void;
+
+  auto syncRAMBuffer() -> void override;
+  auto readRAMBuffer(uint16 addr) -> uint8 override;
+  auto writeRAMBuffer(uint16 addr, uint8 data) -> void override;
+
+  //serialization.cpp
+  auto serialize(serializer&) -> void;
+
+  CPUROM cpurom;
+  CPURAM cpuram;
+
+private:
+  uint romMask;
+  uint ramMask;
+};
+
+extern SuperFX superfx;
diff --git a/nSide/higan/sfc-balanced/coprocessor/superfx/timing.cpp b/nSide/higan/sfc-balanced/coprocessor/superfx/timing.cpp
new file mode 100644
index 0000000..3a427b2
--- /dev/null
+++ b/nSide/higan/sfc-balanced/coprocessor/superfx/timing.cpp
@@ -0,0 +1,49 @@
+auto SuperFX::step(uint clocks) -> void {
+  if(regs.romcl) {
+    regs.romcl -= min(clocks, regs.romcl);
+    if(regs.romcl == 0) {
+      regs.sfr.r = 0;
+      regs.romdr = read((regs.rombr << 16) + regs.r[14]);
+    }
+  }
+
+  if(regs.ramcl) {
+    regs.ramcl -= min(clocks, regs.ramcl);
+    if(regs.ramcl == 0) {
+      write(0x700000 + (regs.rambr << 16) + regs.ramar, regs.ramdr);
+    }
+  }
+
+  Thread::step(clocks);
+  synchronize(cpu);
+}
+
+auto SuperFX::syncROMBuffer() -> void {
+  if(regs.romcl) step(regs.romcl);
+}
+
+auto SuperFX::readROMBuffer() -> uint8 {
+  syncROMBuffer();
+  return regs.romdr;
+}
+
+auto SuperFX::updateROMBuffer() -> void {
+  regs.sfr.r = 1;
+  regs.romcl = regs.clsr ? 5 : 6;
+}
+
+auto SuperFX::syncRAMBuffer() -> void {
+  if(regs.ramcl) step(regs.ramcl);
+}
+
+auto SuperFX::readRAMBuffer(uint16 addr) -> uint8 {
+  syncRAMBuffer();
+  return read(0x700000 + (regs.rambr << 16) + addr);
+}
+
+auto SuperFX::writeRAMBuffer(uint16 addr, uint8 data) -> void {
+  syncRAMBuffer();
+  regs.ramcl = regs.clsr ? 5 : 6;
+  regs.ramar = addr;
+  regs.ramdr = data;
+}
diff --git a/nSide/higan/sfc-balanced/cpu/cpu.cpp b/nSide/higan/sfc-balanced/cpu/cpu.cpp
new file mode 100644
index 0000000..d80352c
--- /dev/null
+++ b/nSide/higan/sfc-balanced/cpu/cpu.cpp
@@ -0,0 +1,237 @@
+#include <sfc-balanced/sfc.hpp>
+
+namespace SuperFamicom {
+
+CPU cpu;
+#include "dma.cpp"
+#include "memory.cpp"
+#include "io.cpp"
+#include "timing.cpp"
+#include "irq.cpp"
+#include "joypad.cpp"
+#include "serialization.cpp"
+
+auto CPU::interruptPending() const -> bool { return status.interruptPending; }
+auto CPU::pio() const -> uint8 { return io.pio; }
+auto CPU::joylatch() const -> bool { return io.joypadStrobeLatch; }
+
+CPU::CPU() {
+  PPUcounter::scanline = {&CPU::scanline, this};
+}
+
+auto CPU::Enter() -> void {
+  while(true) scheduler.synchronize(), cpu.main();
+}
+
+auto CPU::main() -> void {
+  if(status.interruptPending) {
+    status.interruptPending = false;
+    if(status.nmiPending) {
+      status.nmiPending = false;
+      r.vector = r.e ? 0xfffa : 0xffea;
+      interrupt();
+      debug(cpu.nmi);
+    } else if(status.irqPending) {
+      status.irqPending = false;
+      r.vector = r.e ? 0xfffe : 0xffee;
+      interrupt();
+      debug(cpu.irq);
+    } else if(status.resetPending) {
+      status.resetPending = false;
+      step(132);
+      r.vector = 0xfffc;
+      interrupt();
+    } else if(status.powerPending) {
+      status.powerPending = false;
+      step(186);
+      r.pc.l = bus.read(0xfffc, r.mdr);
+      r.pc.h = bus.read(0xfffd, r.mdr);
+    }
+  }
+
+  debug(cpu.execute, r.pc);
+  instruction();
+}
+
+auto CPU::load(Markup::Node node) -> bool {
+  version = max(1, min(2, node["cpu/version"].natural()));
+  return true;
+}
+
+auto CPU::power() -> void {
+  for(auto& byte : wram) byte = random(0x55);
+
+  //CPU
+  r.a = 0x0000;
+  r.x = 0x0000;
+  r.y = 0x0000;
+  r.s = 0x01ff;
+
+  //DMA
+  for(auto& channel : this->channel) {
+    channel.direction = 1;
+    channel.indirect = true;
+    channel.unused = true;
+    channel.reverseTransfer = true;
+    channel.fixedTransfer = true;
+    channel.transferMode = 7;
+
+    channel.targetAddress = 0xff;
+
+    channel.sourceAddress = 0xffff;
+    channel.sourceBank = 0xff;
+
+    channel.transferSize = 0xffff;
+    channel.indirectBank = 0xff;
+
+    channel.hdmaAddress = 0xffff;
+    channel.lineCounter = 0xff;
+    channel.unknown = 0xff;
+  }
+
+  status.powerPending = true;
+  status.interruptPending = true;
+}
+
+auto CPU::reset() -> void {
+  create(Enter, system.colorburst() * 6.0);
+  coprocessors.reset();
+  PPUcounter::reset();
+
+  function<auto (uint24, uint8) -> uint8> reader;
+  function<auto (uint24, uint8) -> void> writer;
+
+  reader = {&CPU::readAPU, this};
+  writer = {&CPU::writeAPU, this};
+  bus.map(reader, writer, "00-3f,80-bf:2140-217f");
+
+  reader = {&CPU::readCPU, this};
+  writer = {&CPU::writeCPU, this};
+  bus.map(reader, writer, "00-3f,80-bf:2180-2183,4016-4017,4200-421f");
+
+  reader = {&CPU::readDMA, this};
+  writer = {&CPU::writeDMA, this};
+  bus.map(reader, writer, "00-3f,80-bf:4300-437f");
+
+  reader = [](uint24 addr, uint8) -> uint8 { return cpu.wram[addr]; };
+  writer = [](uint24 addr, uint8 data) -> void { cpu.wram[addr] = data; };
+  bus.map(reader, writer, "00-3f,80-bf:0000-1fff", 0x2000);
+  bus.map(reader, writer, "7e-7f:0000-ffff", 0x20000);
+
+  //CPU
+  r.pc     = 0x000000;
+  r.x.h    = 0x00;
+  r.y.h    = 0x00;
+  r.s.h    = 0x01;
+  r.d      = 0x0000;
+  r.db     = 0x00;
+  r.p      = 0x34;
+  r.e      = 1;
+  r.mdr    = 0x00;
+  r.wai    = false;
+  r.vector = 0xfffc;  //reset vector address
+
+  //$2140-217f
+  for(auto& port : io.port) port = 0x00;
+
+  //$2181-$2183
+  io.wramAddress = 0x000000;
+
+  //$4016-$4017
+  io.joypadStrobeLatch = 0;
+
+  //$4200
+  io.nmiEnabled = false;
+  io.hirqEnabled = false;
+  io.virqEnabled = false;
+  io.autoJoypadPoll = false;
+
+  //$4201
+  io.pio = 0xff;
+
+  //$4202-$4203
+  io.wrmpya = 0xff;
+  io.wrmpyb = 0xff;
+
+  //$4204-$4206
+  io.wrdiva = 0xffff;
+  io.wrdivb = 0xff;
+
+  //$4207-$420a
+  io.hirqPos = 0x01ff;
+  io.virqPos = 0x01ff;
+
+  //$420d
+  io.romSpeed = 8;
+
+  //$4214-$4217
+  io.rddiv = 0x0000;
+  io.rdmpy = 0x0000;
+
+  //$4218-$421f
+  io.joy1 = 0x0000;
+  io.joy2 = 0x0000;
+  io.joy3 = 0x0000;
+  io.joy4 = 0x0000;
+
+  //ALU
+  alu.mpyctr = 0;
+  alu.divctr = 0;
+  alu.shift = 0;
+
+  //DMA
+  for(auto& channel : this->channel) {
+    channel.dmaEnabled = false;
+    channel.hdmaEnabled = false;
+
+    channel.hdmaCompleted = false;
+    channel.hdmaDoTransfer = false;
+  }
+
+  pipe.valid = false;
+  pipe.addr = 0;
+  pipe.data = 0;
+
+  //Timing
+  status.clockCount = 0;
+  status.lineClocks = lineclocks();
+
+  status.irqLock = false;
+  status.dramRefreshPosition = (version == 1 ? 530 : 538);
+  status.dramRefreshed = false;
+
+  status.hdmaInitPosition = (version == 1 ? 12 + 8 - dmaCounter() : 12 + dmaCounter());
+  status.hdmaInitTriggered = false;
+
+  status.hdmaPosition = 1104;
+  status.hdmaTriggered = false;
+
+  status.nmiValid      = false;
+  status.nmiLine       = false;
+  status.nmiTransition = false;
+  status.nmiPending    = false;
+  status.nmiHold       = false;
+
+  status.irqValid      = false;
+  status.irqLine       = false;
+  status.irqTransition = false;
+  status.irqPending    = false;
+  status.irqHold       = false;
+
+  status.resetPending = !status.powerPending;
+  status.interruptPending = true;
+
+  status.dmaActive   = false;
+  status.dmaCounter  = 0;
+  status.dmaClocks   = 0;
+  status.dmaPending  = false;
+  status.hdmaPending = false;
+  status.hdmaMode    = 0;
+
+  status.autoJoypadActive  = false;
+  status.autoJoypadLatch   = false;
+  status.autoJoypadCounter = 0;
+  status.autoJoypadClock   = 0;
+}
+
+}
diff --git a/nSide/higan/sfc-balanced/cpu/cpu.hpp b/nSide/higan/sfc-balanced/cpu/cpu.hpp
new file mode 100644
index 0000000..6dcb316
--- /dev/null
+++ b/nSide/higan/sfc-balanced/cpu/cpu.hpp
@@ -0,0 +1,244 @@
+struct CPU : Processor::WDC65816, Thread, PPUcounter {
+  auto interruptPending() const -> bool override;
+  auto pio() const -> uint8;
+  auto joylatch() const -> bool;
+
+  CPU();
+
+  auto readPort(uint2 port) const -> uint8;
+  auto writePort(uint2 port, uint8 data) -> void;
+
+  static auto Enter() -> void;
+  auto main() -> void;
+  auto load(Markup::Node) -> bool;
+  auto power() -> void;
+  auto reset() -> void;
+
+  //dma.cpp
+  auto dmaStep(uint clocks) -> void;
+  auto dmaTransferValid(uint8 bbus, uint24 abus) -> bool;
+  auto dmaAddressValid(uint24 abus) -> bool;
+  auto dmaRead(uint24 abus) -> uint8;
+  auto dmaWrite(bool valid, uint addr = 0, uint8 data = 0) -> void;
+  auto dmaTransfer(bool direction, uint8 bbus, uint24 abus) -> void;
+
+  inline auto dmaAddressB(uint n, uint channel) -> uint8;
+  inline auto dmaAddress(uint n) -> uint24;
+  inline auto hdmaAddress(uint n) -> uint24;
+  inline auto hdmaIndirectAddress(uint n) -> uint24;
+
+  inline auto dmaEnabledChannels() -> uint;
+  inline auto hdmaActive(uint n) -> bool;
+  inline auto hdmaActiveAfter(uint s) -> bool;
+  inline auto hdmaEnabledChannels() -> uint;
+  inline auto hdmaActiveChannels() -> uint;
+
+  auto dmaRun() -> void;
+  auto hdmaUpdate(uint n) -> void;
+  auto hdmaRun() -> void;
+  auto hdmaInitReset() -> void;
+  auto hdmaInit() -> void;
+
+  //memory.cpp
+  auto idle() -> void override;
+  auto read(uint24 addr) -> uint8 override;
+  auto write(uint24 addr, uint8 data) -> void override;
+  alwaysinline auto speed(uint24 addr) const -> uint;
+  auto readDisassembler(uint24 addr) -> uint8 override;
+
+  //io.cpp
+  auto readAPU(uint24 addr, uint8 data) -> uint8;
+  auto readCPU(uint24 addr, uint8 data) -> uint8;
+  auto readDMA(uint24 addr, uint8 data) -> uint8;
+  auto writeAPU(uint24 addr, uint8 data) -> void;
+  auto writeCPU(uint24 addr, uint8 data) -> void;
+  auto writeDMA(uint24 addr, uint8 data) -> void;
+
+  //timing.cpp
+  auto dmaCounter() const -> uint;
+
+  auto step(uint clocks) -> void;
+  auto scanline() -> void;
+
+  alwaysinline auto aluEdge() -> void;
+  alwaysinline auto dmaEdge() -> void;
+  alwaysinline auto lastCycle() -> void;
+
+  //irq.cpp
+  alwaysinline auto pollInterrupts() -> void;
+  auto nmitimenUpdate(uint8 data) -> void;
+  auto rdnmi() -> bool;
+  auto timeup() -> bool;
+
+  alwaysinline auto nmiTest() -> bool;
+  alwaysinline auto irqTest() -> bool;
+
+  //joypad.cpp
+  auto stepAutoJoypadPoll() -> void;
+
+  //serialization.cpp
+  auto serialize(serializer&) -> void;
+
+  uint8 wram[128 * 1024];
+  vector<Thread*> coprocessors;
+  vector<Thread*> peripherals;
+
+privileged:
+  uint version = 2;  //allowed: 1, 2
+
+  struct Status {
+    bool interruptPending;
+
+    uint clockCount;
+    uint lineClocks;
+
+    //timing
+    bool irqLock;
+
+    uint dramRefreshPosition;
+    bool dramRefreshed;
+
+    uint hdmaInitPosition;
+    bool hdmaInitTriggered;
+
+    uint hdmaPosition;
+    bool hdmaTriggered;
+
+    bool nmiValid;
+    bool nmiLine;
+    bool nmiTransition;
+    bool nmiPending;
+    bool nmiHold;
+
+    bool irqValid;
+    bool irqLine;
+    bool irqTransition;
+    bool irqPending;
+    bool irqHold;
+
+    bool powerPending;
+    bool resetPending;
+
+    //DMA
+    bool dmaActive;
+    uint dmaCounter;
+    uint dmaClocks;
+    bool dmaPending;
+    bool hdmaPending;
+    bool hdmaMode;  //0 = init, 1 = run
+
+    //auto joypad polling
+    bool autoJoypadActive;
+    bool autoJoypadLatch;
+    uint autoJoypadCounter;
+    uint autoJoypadClock;
+  } status;
+
+  struct IO {
+    //$2140-217f
+    uint8 port[4];
+
+    //$2181-$2183
+    uint17 wramAddress;
+
+    //$4016-$4017
+    bool joypadStrobeLatch;
+
+    //$4200
+    bool nmiEnabled;
+    bool hirqEnabled;
+    bool virqEnabled;
+    bool autoJoypadPoll;
+
+    //$4201
+    uint8 pio;
+
+    //$4202-$4203
+    uint8 wrmpya;
+    uint8 wrmpyb;
+
+    //$4204-$4206
+    uint16 wrdiva;
+    uint8 wrdivb;
+
+    //$4207-$420a
+    uint9 hirqPos;
+    uint9 virqPos;
+
+    //$420d
+    uint romSpeed;
+
+    //$4214-$4217
+    uint16 rddiv;
+    uint16 rdmpy;
+
+    //$4218-$421f
+    uint16 joy1;
+    uint16 joy2;
+    uint16 joy3;
+    uint16 joy4;
+  } io;
+
+  struct ALU {
+    uint mpyctr;
+    uint divctr;
+    uint shift;
+  } alu;
+
+  struct Channel {
+    //$420b
+    bool dmaEnabled;
+
+    //$420c
+    bool hdmaEnabled;
+
+    //$43x0
+    bool direction;
+    bool indirect;
+    bool unused;
+    bool reverseTransfer;
+    bool fixedTransfer;
+    uint3 transferMode;
+
+    //$43x1
+    uint8 targetAddress;
+
+    //$43x2-$43x3
+    uint16 sourceAddress;
+
+    //$43x4
+    uint8 sourceBank;
+
+    //$43x5-$43x6
+    union {
+      uint16 transferSize;
+      uint16 indirectAddress;
+    };
+
+    //$43x7
+    uint8 indirectBank;
+
+    //$43x8-$43x9
+    uint16 hdmaAddress;
+
+    //$43xa
+    uint8 lineCounter;
+
+    //$43xb/$43xf
+    uint8 unknown;
+
+    //internal state
+    bool hdmaCompleted;
+    bool hdmaDoTransfer;
+
+    Channel() : transferSize(0) {}
+  } channel[8];
+
+  struct Pipe {
+    bool valid;
+    uint addr;
+    uint8 data;
+  } pipe;
+};
+
+extern CPU cpu;
diff --git a/nSide/higan/sfc-balanced/cpu/dma.cpp b/nSide/higan/sfc-balanced/cpu/dma.cpp
new file mode 100644
index 0000000..af68524
--- /dev/null
+++ b/nSide/higan/sfc-balanced/cpu/dma.cpp
@@ -0,0 +1,239 @@
+auto CPU::dmaStep(uint clocks) -> void {
+  status.dmaClocks += clocks;
+  step(clocks);
+}
+
+//=============
+//memory access
+//=============
+
+auto CPU::dmaTransferValid(uint8 bbus, uint24 abus) -> bool {
+  //transfers from WRAM to WRAM are invalid; chip only has one address bus
+  if(bbus == 0x80 && ((abus & 0xfe0000) == 0x7e0000 || (abus & 0x40e000) == 0x0000)) return false;
+  return true;
+}
+
+auto CPU::dmaAddressValid(uint24 abus) -> bool {
+  //A-bus access to B-bus or S-CPU registers are invalid
+  if((abus & 0x40ff00) == 0x2100) return false;  //$00-3f,80-bf:2100-21ff
+  if((abus & 0x40fe00) == 0x4000) return false;  //$00-3f,80-bf:4000-41ff
+  if((abus & 0x40ffe0) == 0x4200) return false;  //$00-3f,80-bf:4200-421f
+  if((abus & 0x40ff80) == 0x4300) return false;  //$00-3f,80-bf:4300-437f
+  return true;
+}
+
+auto CPU::dmaRead(uint24 abus) -> uint8 {
+  if(!dmaAddressValid(abus)) return 0x00;
+  return bus.read(abus, r.mdr);
+}
+
+//simulate two-stage pipeline for DMA transfers; example:
+//cycle 0: read N+0
+//cycle 1: write N+0 & read N+1 (parallel; one on A-bus, one on B-bus)
+//cycle 2: write N+1 & read N+2 (parallel)
+//cycle 3: write N+2
+auto CPU::dmaWrite(bool valid, uint addr, uint8 data) -> void {
+  if(pipe.valid) bus.write(pipe.addr, pipe.data);
+  pipe.valid = valid;
+  pipe.addr = addr;
+  pipe.data = data;
+}
+
+auto CPU::dmaTransfer(bool direction, uint8 bbus, uint24 abus) -> void {
+  if(direction == 0) {
+    dmaStep(4);
+    r.mdr = dmaRead(abus);
+    dmaStep(4);
+    dmaWrite(dmaTransferValid(bbus, abus), 0x2100 | bbus, r.mdr);
+  } else {
+    dmaStep(4);
+    r.mdr = dmaTransferValid(bbus, abus) ? bus.read(0x2100 | bbus, r.mdr) : (uint8)0x00;
+    dmaStep(4);
+    dmaWrite(dmaAddressValid(abus), abus, r.mdr);
+  }
+}
+
+//===================
+//address calculation
+//===================
+
+auto CPU::dmaAddressB(uint n, uint index) -> uint8 {
+  switch(channel[n].transferMode) {
+  case 0: return (channel[n].targetAddress);                       //0
+  case 1: return (channel[n].targetAddress + (index & 1));         //0,1
+  case 2: return (channel[n].targetAddress);                       //0,0
+  case 3: return (channel[n].targetAddress + ((index >> 1) & 1));  //0,0,1,1
+  case 4: return (channel[n].targetAddress + (index & 3));         //0,1,2,3
+  case 5: return (channel[n].targetAddress + (index & 1));         //0,1,0,1
+  case 6: return (channel[n].targetAddress);                       //0,0     [2]
+  case 7: return (channel[n].targetAddress + ((index >> 1) & 1));  //0,0,1,1 [3]
+  }
+  unreachable;
+}
+
+auto CPU::dmaAddress(uint n) -> uint24 {
+  uint24 addr = channel[n].sourceBank << 16 | channel[n].sourceAddress;
+
+  if(!channel[n].fixedTransfer) {
+    if(!channel[n].reverseTransfer) {
+      channel[n].sourceAddress++;
+    } else {
+      channel[n].sourceAddress--;
+    }
+  }
+
+  return addr;
+}
+
+auto CPU::hdmaAddress(uint n) -> uint24 {
+  return channel[n].sourceBank << 16 | channel[n].hdmaAddress++;
+}
+
+auto CPU::hdmaIndirectAddress(uint n) -> uint24 {
+  return channel[n].indirectBank << 16 | channel[n].indirectAddress++;
+}
+
+//==============
+//channel status
+//==============
+
+auto CPU::dmaEnabledChannels() -> uint {
+  uint count = 0;
+  for(auto n : range(8)) count += channel[n].dmaEnabled;
+  return count;
+}
+
+auto CPU::hdmaActive(uint n) -> bool {
+  return channel[n].hdmaEnabled && !channel[n].hdmaCompleted;
+}
+
+auto CPU::hdmaActiveAfter(uint s) -> bool {
+  for(uint n = s + 1; n < 8; n++) {
+    if(hdmaActive(n)) return true;
+  }
+  return false;
+}
+
+auto CPU::hdmaEnabledChannels() -> uint {
+  uint count = 0;
+  for(auto n : range(8)) count += channel[n].hdmaEnabled;
+  return count;
+}
+
+auto CPU::hdmaActiveChannels() -> uint {
+  uint count = 0;
+  for(auto n : range(8)) count += hdmaActive(n);
+  return count;
+}
+
+//==============
+//core functions
+//==============
+
+auto CPU::dmaRun() -> void {
+  dmaStep(8);
+  dmaWrite(false);
+  dmaEdge();
+
+  for(auto n : range(8)) {
+    if(!channel[n].dmaEnabled) continue;
+
+    uint index = 0;
+    do {
+      dmaTransfer(channel[n].direction, dmaAddressB(n, index++), dmaAddress(n));
+      dmaEdge();
+    } while(channel[n].dmaEnabled && --channel[n].transferSize);
+
+    dmaStep(8);
+    dmaWrite(false);
+    dmaEdge();
+
+    channel[n].dmaEnabled = false;
+  }
+
+  status.irqLock = true;
+}
+
+auto CPU::hdmaUpdate(uint n) -> void {
+  dmaStep(4);
+  r.mdr = dmaRead(channel[n].sourceBank << 16 | channel[n].hdmaAddress);
+  dmaStep(4);
+  dmaWrite(false);
+
+  if((channel[n].lineCounter & 0x7f) == 0) {
+    channel[n].lineCounter = r.mdr;
+    channel[n].hdmaAddress++;
+
+    channel[n].hdmaCompleted = channel[n].lineCounter == 0;
+    channel[n].hdmaDoTransfer = !channel[n].hdmaCompleted;
+
+    if(channel[n].indirect) {
+      dmaStep(4);
+      r.mdr = dmaRead(hdmaAddress(n));
+      channel[n].indirectAddress = r.mdr << 8;
+      dmaStep(4);
+      dmaWrite(false);
+
+      if(!channel[n].hdmaCompleted || hdmaActiveAfter(n)) {
+        dmaStep(4);
+        r.mdr = dmaRead(hdmaAddress(n));
+        channel[n].indirectAddress >>= 8;
+        channel[n].indirectAddress |= r.mdr << 8;
+        dmaStep(4);
+        dmaWrite(false);
+      }
+    }
+  }
+}
+
+auto CPU::hdmaRun() -> void {
+  dmaStep(8);
+  dmaWrite(false);
+
+  for(auto n : range(8)) {
+    if(!hdmaActive(n)) continue;
+    channel[n].dmaEnabled = false;  //HDMA run during DMA will stop DMA mid-transfer
+
+    if(channel[n].hdmaDoTransfer) {
+      static const uint transferLength[8] = {1, 2, 2, 4, 4, 4, 2, 4};
+      uint length = transferLength[channel[n].transferMode];
+      for(auto index : range(length)) {
+        uint addr = !channel[n].indirect ? hdmaAddress(n) : hdmaIndirectAddress(n);
+        dmaTransfer(channel[n].direction, dmaAddressB(n, index), addr);
+      }
+    }
+  }
+
+  for(auto n : range(8)) {
+    if(!hdmaActive(n)) continue;
+
+    channel[n].lineCounter--;
+    channel[n].hdmaDoTransfer = channel[n].lineCounter & 0x80;
+    hdmaUpdate(n);
+  }
+
+  status.irqLock = true;
+}
+
+auto CPU::hdmaInitReset() -> void {
+  for(auto n : range(8)) {
+    channel[n].hdmaCompleted = false;
+    channel[n].hdmaDoTransfer = false;
+  }
+}
+
+auto CPU::hdmaInit() -> void {
+  dmaStep(8);
+  dmaWrite(false);
+
+  for(auto n : range(8)) {
+    if(!channel[n].hdmaEnabled) continue;
+    channel[n].dmaEnabled = false;  //HDMA init during DMA will stop DMA mid-transfer
+
+    channel[n].hdmaAddress = channel[n].sourceAddress;
+    channel[n].lineCounter = 0;
+    hdmaUpdate(n);
+  }
+
+  status.irqLock = true;
+}
diff --git a/nSide/higan/sfc-balanced/cpu/io.cpp b/nSide/higan/sfc-balanced/cpu/io.cpp
new file mode 100644
index 0000000..14f4a2a
--- /dev/null
+++ b/nSide/higan/sfc-balanced/cpu/io.cpp
@@ -0,0 +1,310 @@
+auto CPU::readAPU(uint24 addr, uint8 data) -> uint8 {
+  synchronize(smp);
+  return smp.readPort(addr.bits(0,1));
+}
+
+auto CPU::readCPU(uint24 addr, uint8 data) -> uint8 {
+  switch((uint16)addr) {
+
+  //WMDATA
+  case 0x2180: {
+    return bus.read(0x7e0000 | io.wramAddress++, r.mdr);
+  }
+
+  //JOYSER0
+  //7-2 = MDR
+  //1-0 = Joypad serial data
+  case 0x4016: {
+    uint8 v = r.mdr & 0xfc;
+    v |= SuperFamicom::peripherals.controllerPort1->data();
+    return v;
+  }
+
+  //JOYSER1
+  case 0x4017: {
+    //7-5 = MDR
+    //4-2 = Always 1 (pins are connected to GND)
+    //1-0 = Joypad serial data
+    uint8 v = (r.mdr & 0xe0) | 0x1c;
+    v |= SuperFamicom::peripherals.controllerPort2->data();
+    return v;
+  }
+
+  //RDNMI
+  case 0x4210: {
+    //7   = NMI acknowledge
+    //6-4 = MDR
+    //3-0 = CPU (5a22) version
+    uint8 v = (r.mdr & 0x70);
+    v |= (uint8)(rdnmi()) << 7;
+    v |= (version & 0x0f);
+    return v;
+  }
+
+  //TIMEUP
+  case 0x4211: {
+    //7   = IRQ acknowledge
+    //6-0 = MDR
+    uint8 v = (r.mdr & 0x7f);
+    v |= (uint8)(timeup()) << 7;
+    return v;
+  }
+
+  //HVBJOY
+  case 0x4212: {
+    //7   = VBLANK acknowledge
+    //6   = HBLANK acknowledge
+    //5-1 = MDR
+    //0   = JOYPAD acknowledge
+    uint8 v = (r.mdr & 0x3e);
+    if(status.autoJoypadActive) v |= 0x01;
+    if(hcounter() <= 2 || hcounter() >= 1096) v |= 0x40;  //hblank
+    if(vcounter() >= ppu.vdisp()) v |= 0x80;  //vblank
+    return v;
+  }
+
+  //RDIO
+  case 0x4213: {
+    return io.pio;
+  }
+
+  //RDDIVL
+  case 0x4214: {
+    return io.rddiv.byte(0);
+  }
+
+  //RDDIVH
+  case 0x4215: {
+    return io.rddiv.byte(1);
+  }
+
+  //RDMPYL
+  case 0x4216: {
+    return io.rdmpy.byte(0);
+  }
+
+  //RDMPYH
+  case 0x4217: {
+    return io.rdmpy.byte(1);
+  }
+
+  case 0x4218: return io.joy1.byte(0);  //JOY1L
+  case 0x4219: return io.joy1.byte(1);  //JOY1H
+  case 0x421a: return io.joy2.byte(0);  //JOY2L
+  case 0x421b: return io.joy2.byte(1);  //JOY2H
+  case 0x421c: return io.joy3.byte(0);  //JOY3L
+  case 0x421d: return io.joy3.byte(1);  //JOY3H
+  case 0x421e: return io.joy4.byte(0);  //JOY4L
+  case 0x421f: return io.joy4.byte(1);  //JOY4H
+
+  }
+
+  return data;
+}
+
+auto CPU::readDMA(uint24 addr, uint8 data) -> uint8 {
+  auto& channel = this->channel[addr.bits(4,6)];
+
+  switch(addr & 0xff0f) {
+
+  //DMAPx
+  case 0x4300: return (
+    channel.transferMode    << 0
+  | channel.fixedTransfer   << 3
+  | channel.reverseTransfer << 4
+  | channel.unused          << 5
+  | channel.indirect        << 6
+  | channel.direction       << 7
+  );
+
+  //BBADx
+  case 0x4301: return channel.targetAddress;
+
+  //A1TxL
+  case 0x4302: return channel.sourceAddress >> 0;
+
+  //A1TxH
+  case 0x4303: return channel.sourceAddress >> 8;
+
+  //A1Bx
+  case 0x4304: return channel.sourceBank;
+
+  //DASxL -- union { uint16 transferSize; uint16 indirectAddress; };
+  case 0x4305: return channel.transferSize.byte(0);
+
+  //DASxH -- union { uint16 transferSize; uint16 indirectAddress; };
+  case 0x4306: return channel.transferSize.byte(1);
+
+  //DASBx
+  case 0x4307: return channel.indirectBank;
+
+  //A2AxL
+  case 0x4308: return channel.hdmaAddress.byte(0);
+
+  //A2AxH
+  case 0x4309: return channel.hdmaAddress.byte(1);
+
+  //NTRLx
+  case 0x430a: return channel.lineCounter;
+
+  //???
+  case 0x430b:
+  case 0x430f: return channel.unknown;
+
+  }
+
+  return data;
+}
+
+auto CPU::writeAPU(uint24 addr, uint8 data) -> void {
+  synchronize(smp);
+  return writePort(addr.bits(0,1), data);
+}
+
+auto CPU::writeCPU(uint24 addr, uint8 data) -> void {
+  switch((uint16)addr) {
+
+  //WMDATA
+  case 0x2180: {
+    return bus.write(0x7e0000 | io.wramAddress++, data);
+  }
+
+  case 0x2181: io.wramAddress.bits( 0, 7) = data;        return;  //WMADDL
+  case 0x2182: io.wramAddress.bits( 8,15) = data;        return;  //WMADDM
+  case 0x2183: io.wramAddress.bit (16   ) = data.bit(0); return;  //WMADDH
+
+  //JOYSER0
+  case 0x4016: {
+    //bit 0 is shared between JOYSER0 and JOYSER1, therefore
+    //strobing $4016.d0 affects both controller port latches.
+    //$4017 bit 0 writes are ignored.
+    SuperFamicom::peripherals.controllerPort1->latch(data.bit(0));
+    SuperFamicom::peripherals.controllerPort2->latch(data.bit(0));
+    return;
+  }
+
+  //NMITIMEN
+  case 0x4200: {
+    io.autoJoypadPoll = data.bit(0);
+    nmitimenUpdate(data);
+    return;
+  }
+
+  //WRIO
+  case 0x4201: {
+    if(io.pio.bit(7) && !data.bit(7)) ppu.latchCounters();
+    io.pio = data;
+    return;
+  }
+
+  //WRMPYA
+  case 0x4202: io.wrmpya = data; return;
+
+  //WRMPYB
+  case 0x4203: {
+    io.rdmpy = 0;
+    if(alu.mpyctr || alu.divctr) return;
+
+    io.wrmpyb = data;
+    io.rddiv = (io.wrmpyb << 8) | io.wrmpya;
+
+    alu.mpyctr = 8;  //perform multiplication over the next eight cycles
+    alu.shift = io.wrmpyb;
+    return;
+  }
+
+  case 0x4204: { io.wrdiva.byte(0) = data; return; }  //WRDIVL
+  case 0x4205: { io.wrdiva.byte(1) = data; return; }  //WRDIVH
+
+  //WRDIVB
+  case 0x4206: {
+    io.rdmpy = io.wrdiva;
+    if(alu.mpyctr || alu.divctr) return;
+
+    io.wrdivb = data;
+
+    alu.divctr = 16;  //perform division over the next sixteen cycles
+    alu.shift = io.wrdivb << 16;
+    return;
+  }
+
+  case 0x4207: io.hirqPos.bits(0,7) = data;        return;  //HTIMEL
+  case 0x4208: io.hirqPos.bit (8  ) = data.bit(0); return;  //HTIMEH
+
+  case 0x4209: io.virqPos.bits(0,7) = data;        return;  //VTIMEL
+  case 0x420a: io.virqPos.bit (8  ) = data.bit(0); return;  //VTIMEH
+
+  //DMAEN
+  case 0x420b: {
+    for(auto n : range(8)) channel[n].dmaEnabled = data.bit(n);
+    if(data) status.dmaPending = true;
+    return;
+  }
+
+  //HDMAEN
+  case 0x420c: {
+    for(auto n : range(8)) channel[n].hdmaEnabled = data.bit(n);
+    return;
+  }
+
+  //MEMSEL
+  case 0x420d: {
+    io.romSpeed = data.bit(0) ? 6 : 8;
+    return;
+  }
+
+  }
+}
+
+auto CPU::writeDMA(uint24 addr, uint8 data) -> void {
+  auto& channel = this->channel[addr.bits(4,6)];
+
+  switch(addr & 0xff0f) {
+
+  //DMAPx
+  case 0x4300: {
+    channel.transferMode    = data.bits(0,2);
+    channel.fixedTransfer   = data.bit (3);
+    channel.reverseTransfer = data.bit (4);
+    channel.unused          = data.bit (5);
+    channel.indirect        = data.bit (6);
+    channel.direction       = data.bit (7);
+    return;
+  }
+
+  //DDBADx
+  case 0x4301: channel.targetAddress = data; return;
+
+  //A1TxL
+  case 0x4302: channel.sourceAddress.byte(0) = data; return;
+
+  //A1TxH
+  case 0x4303: channel.sourceAddress.byte(1) = data; return;
+
+  //A1Bx
+  case 0x4304: channel.sourceBank = data; return;
+
+  //DASxL -- union { uint16 transferSize; uint16 indirectAddress; };
+  case 0x4305: channel.transferSize.byte(0) = data; return;
+
+  //DASxH -- union { uint16 transferSize; uint16 indirectAddress; };
+  case 0x4306: channel.transferSize.byte(1) = data; return;
+
+  //DASBx
+  case 0x4307: channel.indirectBank = data; return;
+
+  //A2AxL
+  case 0x4308: channel.hdmaAddress.byte(0) = data; return;
+
+  //A2AxH
+  case 0x4309: channel.hdmaAddress.byte(1) = data; return;
+
+  //NTRLx
+  case 0x430a: channel.lineCounter = data; return;
+
+  //???
+  case 0x430b:
+  case 0x430f: channel.unknown = data; return;
+
+  }
+}
diff --git a/nSide/higan/sfc-balanced/cpu/irq.cpp b/nSide/higan/sfc-balanced/cpu/irq.cpp
new file mode 100644
index 0000000..5d268e0
--- /dev/null
+++ b/nSide/higan/sfc-balanced/cpu/irq.cpp
@@ -0,0 +1,102 @@
+//called once every four clock cycles;
+//as NMI steps by scanlines (divisible by 4) and IRQ by PPU 4-cycle dots.
+//
+//ppu.(vh)counter(n) returns the value of said counters n-clocks before current time;
+//it is used to emulate hardware communication delay between opcode and interrupt units.
+auto CPU::pollInterrupts() -> void {
+  //NMI hold
+  if(status.nmiHold) {
+    status.nmiHold = false;
+    if(io.nmiEnabled) status.nmiTransition = true;
+  }
+
+  //NMI test
+  bool nmiValid = vcounter(2) >= ppu.vdisp();
+  if(!status.nmiValid && nmiValid) {
+    //0->1 edge sensitive transition
+    status.nmiLine = true;
+    status.nmiHold = true;  //hold /NMI for four cycles
+  } else if(status.nmiValid && !nmiValid) {
+    //1->0 edge sensitive transition
+    status.nmiLine = false;
+  }
+  status.nmiValid = nmiValid;
+
+  //IRQ hold
+  status.irqHold = false;
+  if(status.irqLine) {
+    if(io.virqEnabled || io.hirqEnabled) status.irqTransition = true;
+  }
+
+  //IRQ test
+  bool irqValid = io.virqEnabled || io.hirqEnabled;
+  if(irqValid) {
+    if((io.virqEnabled && vcounter(10) != (io.virqPos))
+    || (io.hirqEnabled && hcounter(10) != (io.hirqPos + 1) * 4)
+    || (io.virqPos && vcounter(6) == 0)  //IRQs cannot trigger on last dot of field
+    ) irqValid = false;
+  }
+  if(!status.irqValid && irqValid) {
+    //0->1 edge sensitive transition
+    status.irqLine = true;
+    status.irqHold = true;  //hold /IRQ for four cycles
+  }
+  status.irqValid = irqValid;
+}
+
+auto CPU::nmitimenUpdate(uint8 data) -> void {
+  bool nmiEnabled  = io.nmiEnabled;
+  bool virqEnabled = io.virqEnabled;
+  bool hirqEnabled = io.hirqEnabled;
+  io.nmiEnabled  = data & 0x80;
+  io.virqEnabled = data & 0x20;
+  io.hirqEnabled = data & 0x10;
+
+  //0->1 edge sensitive transition
+  if(!nmiEnabled && io.nmiEnabled && status.nmiLine) {
+    status.nmiTransition = true;
+  }
+
+  //?->1 level sensitive transition
+  if(io.virqEnabled && !io.hirqEnabled && status.irqLine) {
+    status.irqTransition = true;
+  }
+
+  if(!io.virqEnabled && !io.hirqEnabled) {
+    status.irqLine = false;
+    status.irqTransition = false;
+  }
+
+  status.irqLock = true;
+}
+
+auto CPU::rdnmi() -> bool {
+  bool result = status.nmiLine;
+  if(!status.nmiHold) {
+    status.nmiLine = false;
+  }
+  return result;
+}
+
+auto CPU::timeup() -> bool {
+  bool result = status.irqLine;
+  if(!status.irqHold) {
+    status.irqLine = false;
+    status.irqTransition = false;
+  }
+  return result;
+}
+
+auto CPU::nmiTest() -> bool {
+  if(!status.nmiTransition) return false;
+  status.nmiTransition = false;
+  r.wai = false;
+  return true;
+}
+
+auto CPU::irqTest() -> bool {
+  if(!status.irqTransition && !r.irq) return false;
+  status.irqTransition = false;
+  r.wai = false;
+  return !r.p.i;
+}
diff --git a/nSide/higan/sfc-balanced/cpu/joypad.cpp b/nSide/higan/sfc-balanced/cpu/joypad.cpp
new file mode 100644
index 0000000..cd14c40
--- /dev/null
+++ b/nSide/higan/sfc-balanced/cpu/joypad.cpp
@@ -0,0 +1,27 @@
+//called every 256 clocks; see CPU::addClocks()
+auto CPU::stepAutoJoypadPoll() -> void {
+  if(vcounter() >= ppu.vdisp()) {
+    //cache enable state at first iteration
+    if(status.autoJoypadCounter == 0) status.autoJoypadLatch = io.autoJoypadPoll;
+    status.autoJoypadActive = status.autoJoypadCounter <= 15;
+
+    if(status.autoJoypadActive && status.autoJoypadLatch) {
+      if(status.autoJoypadCounter == 0) {
+        SuperFamicom::peripherals.controllerPort1->latch(1);
+        SuperFamicom::peripherals.controllerPort2->latch(1);
+        SuperFamicom::peripherals.controllerPort1->latch(0);
+        SuperFamicom::peripherals.controllerPort2->latch(0);
+      }
+
+      uint2 port0 = SuperFamicom::peripherals.controllerPort1->data();
+      uint2 port1 = SuperFamicom::peripherals.controllerPort2->data();
+
+      io.joy1 = io.joy1 << 1 | port0.bit(0);
+      io.joy2 = io.joy2 << 1 | port1.bit(0);
+      io.joy3 = io.joy3 << 1 | port0.bit(1);
+      io.joy4 = io.joy4 << 1 | port1.bit(1);
+    }
+
+    status.autoJoypadCounter++;
+  }
+}
diff --git a/nSide/higan/sfc-balanced/cpu/memory.cpp b/nSide/higan/sfc-balanced/cpu/memory.cpp
new file mode 100644
index 0000000..17fe1da
--- /dev/null
+++ b/nSide/higan/sfc-balanced/cpu/memory.cpp
@@ -0,0 +1,45 @@
+auto CPU::readPort(uint2 port) const -> uint8 {
+  return io.port[port];
+}
+
+auto CPU::writePort(uint2 port, uint8 data) -> void {
+  io.port[port] = data;
+}
+
+auto CPU::idle() -> void {
+  status.clockCount = 6;
+  dmaEdge();
+  step(6);
+  aluEdge();
+}
+
+auto CPU::read(uint24 addr) -> uint8 {
+  status.clockCount = speed(addr);
+  dmaEdge();
+  step(status.clockCount - 4);
+  r.mdr = bus.read(addr, r.mdr);
+  step(4);
+  aluEdge();
+  debug(cpu.read, addr, r.mdr);
+  return r.mdr;
+}
+
+auto CPU::write(uint24 addr, uint8 data) -> void {
+  aluEdge();
+  status.clockCount = speed(addr);
+  dmaEdge();
+  step(status.clockCount);
+  bus.write(addr, r.mdr = data);
+  debug(cpu.write, addr, r.mdr);
+}
+
+auto CPU::speed(uint24 addr) const -> uint {
+  if(addr & 0x408000) return addr & 0x800000 ? io.romSpeed : 8;
+  if(addr + 0x6000 & 0x4000) return 8;
+  if(addr - 0x4000 & 0x7e00) return 6;
+  return 12;
+}
+
+auto CPU::readDisassembler(uint24 addr) -> uint8 {
+  return bus.read(addr, r.mdr);
+}
diff --git a/nSide/higan/sfc-balanced/cpu/serialization.cpp b/nSide/higan/sfc-balanced/cpu/serialization.cpp
new file mode 100644
index 0000000..90c2a82
--- /dev/null
+++ b/nSide/higan/sfc-balanced/cpu/serialization.cpp
@@ -0,0 +1,113 @@
+auto CPU::serialize(serializer& s) -> void {
+  WDC65816::serialize(s);
+  Thread::serialize(s);
+  PPUcounter::serialize(s);
+
+  s.array(wram);
+
+  s.integer(version);
+
+  s.integer(status.interruptPending);
+
+  s.integer(status.clockCount);
+  s.integer(status.lineClocks);
+
+  s.integer(status.irqLock);
+
+  s.integer(status.dramRefreshPosition);
+  s.integer(status.dramRefreshed);
+
+  s.integer(status.hdmaInitPosition);
+  s.integer(status.hdmaInitTriggered);
+
+  s.integer(status.hdmaPosition);
+  s.integer(status.hdmaTriggered);
+
+  s.integer(status.nmiValid);
+  s.integer(status.nmiLine);
+  s.integer(status.nmiTransition);
+  s.integer(status.nmiPending);
+  s.integer(status.nmiHold);
+
+  s.integer(status.irqValid);
+  s.integer(status.irqLine);
+  s.integer(status.irqTransition);
+  s.integer(status.irqPending);
+  s.integer(status.irqHold);
+
+  s.integer(status.powerPending);
+  s.integer(status.resetPending);
+
+  s.integer(status.dmaActive);
+  s.integer(status.dmaCounter);
+  s.integer(status.dmaClocks);
+  s.integer(status.dmaPending);
+  s.integer(status.hdmaPending);
+  s.integer(status.hdmaMode);
+
+  s.integer(status.autoJoypadActive);
+  s.integer(status.autoJoypadLatch);
+  s.integer(status.autoJoypadCounter);
+  s.integer(status.autoJoypadClock);
+
+  s.array(io.port);
+
+  s.integer(io.wramAddress);
+
+  s.integer(io.joypadStrobeLatch);
+
+  s.integer(io.nmiEnabled);
+  s.integer(io.hirqEnabled);
+  s.integer(io.virqEnabled);
+  s.integer(io.autoJoypadPoll);
+
+  s.integer(io.pio);
+
+  s.integer(io.wrmpya);
+  s.integer(io.wrmpyb);
+
+  s.integer(io.wrdiva);
+  s.integer(io.wrdivb);
+
+  s.integer(io.hirqPos);
+  s.integer(io.virqPos);
+
+  s.integer(io.romSpeed);
+
+  s.integer(io.rddiv);
+  s.integer(io.rdmpy);
+
+  s.integer(io.joy1);
+  s.integer(io.joy2);
+  s.integer(io.joy3);
+  s.integer(io.joy4);
+
+  s.integer(alu.mpyctr);
+  s.integer(alu.divctr);
+  s.integer(alu.shift);
+
+  for(uint n : range(8)) {
+    s.integer(channel[n].dmaEnabled);
+    s.integer(channel[n].hdmaEnabled);
+    s.integer(channel[n].direction);
+    s.integer(channel[n].indirect);
+    s.integer(channel[n].unused);
+    s.integer(channel[n].reverseTransfer);
+    s.integer(channel[n].fixedTransfer);
+    s.integer(channel[n].transferMode);
+    s.integer(channel[n].targetAddress);
+    s.integer(channel[n].sourceAddress);
+    s.integer(channel[n].sourceBank);
+    s.integer(channel[n].transferSize);
+    s.integer(channel[n].indirectBank);
+    s.integer(channel[n].hdmaAddress);
+    s.integer(channel[n].lineCounter);
+    s.integer(channel[n].unknown);
+    s.integer(channel[n].hdmaCompleted);
+    s.integer(channel[n].hdmaDoTransfer);
+  }
+
+  s.integer(pipe.valid);
+  s.integer(pipe.addr);
+  s.integer(pipe.data);
+}
diff --git a/nSide/higan/sfc-balanced/cpu/timing.cpp b/nSide/higan/sfc-balanced/cpu/timing.cpp
new file mode 100644
index 0000000..3c610ff
--- /dev/null
+++ b/nSide/higan/sfc-balanced/cpu/timing.cpp
@@ -0,0 +1,153 @@
+auto CPU::dmaCounter() const -> uint {
+  return (status.dmaCounter + hcounter()) & 7;
+}
+
+auto CPU::step(uint clocks) -> void {
+  status.irqLock = false;
+  uint ticks = clocks >> 1;
+  while(ticks--) {
+    tick();
+    if(hcounter() & 2) pollInterrupts();
+  }
+
+  Thread::step(clocks);
+  for(auto peripheral : peripherals) synchronize(*peripheral);
+
+  status.autoJoypadClock += clocks;
+  if(status.autoJoypadClock >= 256) {
+    status.autoJoypadClock -= 256;
+    stepAutoJoypadPoll();
+  }
+
+  if(!status.dramRefreshed && hcounter() >= status.dramRefreshPosition) {
+    status.dramRefreshed = true;
+    step(40);
+  }
+
+  #if defined(DEBUGGER)
+  synchronize(smp);
+  synchronize(ppu);
+  for(auto coprocessor : coprocessors) synchronize(*coprocessor);
+  #endif
+}
+
+//called by ppu.tick() when Hcounter=0
+auto CPU::scanline() -> void {
+  status.dmaCounter = (status.dmaCounter + status.lineClocks) & 7;
+  status.lineClocks = lineclocks();
+
+  //forcefully sync S-CPU to other processors, in case chips are not communicating
+  synchronize(smp);
+  synchronize(ppu);
+  for(auto coprocessor : coprocessors) synchronize(*coprocessor);
+
+  if(vcounter() == 0) {
+    //HDMA init triggers once every frame
+    status.hdmaInitPosition = (version == 1 ? 12 + 8 - dmaCounter() : 12 + dmaCounter());
+    status.hdmaInitTriggered = false;
+
+    status.autoJoypadCounter = 0;
+  }
+
+  //DRAM refresh occurs once every scanline
+  if(version == 2) status.dramRefreshPosition = 530 + 8 - dmaCounter();
+  status.dramRefreshed = false;
+
+  //HDMA triggers once every visible scanline
+  if(vcounter() < ppu.vdisp()) {
+    status.hdmaPosition = 1104;
+    status.hdmaTriggered = false;
+  }
+}
+
+auto CPU::aluEdge() -> void {
+  if(alu.mpyctr) {
+    alu.mpyctr--;
+    if(io.rddiv & 1) io.rdmpy += alu.shift;
+    io.rddiv >>= 1;
+    alu.shift <<= 1;
+  }
+
+  if(alu.divctr) {
+    alu.divctr--;
+    io.rddiv <<= 1;
+    alu.shift >>= 1;
+    if(io.rdmpy >= alu.shift) {
+      io.rdmpy -= alu.shift;
+      io.rddiv |= 1;
+    }
+  }
+}
+
+auto CPU::dmaEdge() -> void {
+  //H/DMA pending && DMA inactive?
+  //.. Run one full CPU cycle
+  //.. HDMA pending && HDMA enabled ? DMA sync + HDMA run
+  //.. DMA pending && DMA enabled ? DMA sync + DMA run
+  //.... HDMA during DMA && HDMA enabled ? DMA sync + HDMA run
+  //.. Run one bus CPU cycle
+  //.. CPU sync
+
+  if(status.dmaActive) {
+    if(status.hdmaPending) {
+      status.hdmaPending = false;
+      if(hdmaEnabledChannels()) {
+        if(!dmaEnabledChannels()) {
+          dmaStep(8 - dmaCounter());
+        }
+        status.hdmaMode == 0 ? hdmaInit() : hdmaRun();
+        if(!dmaEnabledChannels()) {
+          step(status.clockCount - (status.dmaClocks % status.clockCount));
+          status.dmaActive = false;
+        }
+      }
+    }
+
+    if(status.dmaPending) {
+      status.dmaPending = false;
+      if(dmaEnabledChannels()) {
+        dmaStep(8 - dmaCounter());
+        dmaRun();
+        step(status.clockCount - (status.dmaClocks % status.clockCount));
+        status.dmaActive = false;
+      }
+    }
+  }
+
+  if(!status.hdmaInitTriggered && hcounter() >= status.hdmaInitPosition) {
+    status.hdmaInitTriggered = true;
+    hdmaInitReset();
+    if(hdmaEnabledChannels()) {
+      status.hdmaPending = true;
+      status.hdmaMode = 0;
+    }
+  }
+
+  if(!status.hdmaTriggered && hcounter() >= status.hdmaPosition) {
+    status.hdmaTriggered = true;
+    if(hdmaActiveChannels()) {
+      status.hdmaPending = true;
+      status.hdmaMode = 1;
+    }
+  }
+
+  if(!status.dmaActive) {
+    if(status.dmaPending || status.hdmaPending) {
+      status.dmaClocks = 0;
+      status.dmaActive = true;
+    }
+  }
+}
+
+//used to test for NMI/IRQ, which can trigger on the edge of every opcode.
+//test one cycle early to simulate two-stage pipeline of x816 CPU.
+//
+//status.irq_lock is used to simulate hardware delay before interrupts can
+//trigger during certain events (immediately after DMA, writes to $4200, etc)
+auto CPU::lastCycle() -> void {
+  if(!status.irqLock) {
+    status.nmiPending |= nmiTest();
+    status.irqPending |= irqTest();
+    status.interruptPending = (status.nmiPending || status.irqPending);
+  }
+}
diff --git a/nSide/higan/sfc-balanced/debugger.hpp b/nSide/higan/sfc-balanced/debugger.hpp
new file mode 100644
index 0000000..0524715
--- /dev/null
+++ b/nSide/higan/sfc-balanced/debugger.hpp
@@ -0,0 +1,40 @@
+#pragma once
+
+namespace SuperFamicom {
+
+struct Debugger {
+  struct CPU {
+    function<void (uint24, uint8)> read;
+    function<void (uint24, uint8)> write;
+    function<void (uint24)> execute;
+    function<void ()> nmi;
+    function<void ()> irq;
+  } cpu;
+
+  struct SMP {
+    function<void (uint16, uint8)> read;
+    function<void (uint16, uint8)> write;
+    function<void (uint16)> execute;
+  } smp;
+
+  struct PPU {
+    struct VRAM {
+      function<void (uint17, uint8)> read;
+      function<void (uint17, uint8)> write;
+    } vram;
+
+    struct OAM {
+      function<void (uint10, uint8)> read;
+      function<void (uint10, uint8)> write;
+    } oam;
+
+    struct CGRAM {
+      function<void (uint9, uint8)> read;
+      function<void (uint9, uint8)> write;
+    } cgram;
+  } ppu;
+};
+
+extern Debugger debugger;
+
+}
diff --git a/nSide/higan/sfc-balanced/dsp/SPC_DSP.cpp b/nSide/higan/sfc-balanced/dsp/SPC_DSP.cpp
new file mode 100644
index 0000000..b012140
--- /dev/null
+++ b/nSide/higan/sfc-balanced/dsp/SPC_DSP.cpp
@@ -0,0 +1,1027 @@
+// snes_spc 0.9.0. http://www.slack.net/~ant/
+
+#include "SPC_DSP.h"
+
+#include "blargg_endian.h"
+#include <string.h>
+
+/* Copyright (C) 2007 Shay Green. This module is free software; you
+can redistribute it and/or modify it under the terms of the GNU Lesser
+General Public License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version. This
+module is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
+details. You should have received a copy of the GNU Lesser General Public
+License along with this module; if not, write to the Free Software Foundation,
+Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA */
+
+#include "blargg_source.h"
+
+#ifdef BLARGG_ENABLE_OPTIMIZER
+	#include BLARGG_ENABLE_OPTIMIZER
+#endif
+
+#if INT_MAX < 0x7FFFFFFF
+	#error "Requires that int type have at least 32 bits"
+#endif
+
+// TODO: add to blargg_endian.h
+#define GET_LE16SA( addr )      ((BOOST::int16_t) GET_LE16( addr ))
+#define GET_LE16A( addr )       GET_LE16( addr )
+#define SET_LE16A( addr, data ) SET_LE16( addr, data )
+
+static BOOST::uint8_t const initial_regs [SPC_DSP::register_count] =
+{
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0x00,0x00,0x00,
+	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
+
+//	0x45,0x8B,0x5A,0x9A,0xE4,0x82,0x1B,0x78,0x00,0x00,0xAA,0x96,0x89,0x0E,0xE0,0x80,
+//	0x2A,0x49,0x3D,0xBA,0x14,0xA0,0xAC,0xC5,0x00,0x00,0x51,0xBB,0x9C,0x4E,0x7B,0xFF,
+//	0xF4,0xFD,0x57,0x32,0x37,0xD9,0x42,0x22,0x00,0x00,0x5B,0x3C,0x9F,0x1B,0x87,0x9A,
+//	0x6F,0x27,0xAF,0x7B,0xE5,0x68,0x0A,0xD9,0x00,0x00,0x9A,0xC5,0x9C,0x4E,0x7B,0xFF,
+//	0xEA,0x21,0x78,0x4F,0xDD,0xED,0x24,0x14,0x00,0x00,0x77,0xB1,0xD1,0x36,0xC1,0x67,
+//	0x52,0x57,0x46,0x3D,0x59,0xF4,0x87,0xA4,0x00,0x00,0x7E,0x44,0x9C,0x4E,0x7B,0xFF,
+//	0x75,0xF5,0x06,0x97,0x10,0xC3,0x24,0xBB,0x00,0x00,0x7B,0x7A,0xE0,0x60,0x12,0x0F,
+//	0xF7,0x74,0x1C,0xE5,0x39,0x3D,0x73,0xC1,0x00,0x00,0x7A,0xB3,0xFF,0x4E,0x7B,0xFF
+};
+
+// if ( io < -32768 ) io = -32768;
+// if ( io >  32767 ) io =  32767;
+#define CLAMP16( io )\
+{\
+	if ( (int16_t) io != io )\
+		io = (io >> 31) ^ 0x7FFF;\
+}
+
+// Access global DSP register
+#define REG(n)      m.regs [r_##n]
+
+// Access voice DSP register
+#define VREG(r,n)   r [v_##n]
+
+#define WRITE_SAMPLES( l, r, out ) \
+{\
+	out [0] = l;\
+	out [1] = r;\
+	out += 2;\
+	if ( out >= m.out_end )\
+	{\
+		check( out == m.out_end );\
+		check( m.out_end != &m.extra [extra_size] || \
+			(m.extra <= m.out_begin && m.extra < &m.extra [extra_size]) );\
+		out       = m.extra;\
+		m.out_end = &m.extra [extra_size];\
+	}\
+}\
+
+void SPC_DSP::set_output( sample_t* out, int size )
+{
+	require( (size & 1) == 0 ); // must be even
+	if ( !out )
+	{
+		out  = m.extra;
+		size = extra_size;
+	}
+	m.out_begin = out;
+	m.out       = out;
+	m.out_end   = out + size;
+}
+
+// Volume registers and efb are signed! Easy to forget int8_t cast.
+// Prefixes are to avoid accidental use of locals with same names.
+
+// Gaussian interpolation
+
+static short const gauss [512] =
+{
+   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
+   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   2,   2,   2,   2,   2,
+   2,   2,   3,   3,   3,   3,   3,   4,   4,   4,   4,   4,   5,   5,   5,   5,
+   6,   6,   6,   6,   7,   7,   7,   8,   8,   8,   9,   9,   9,  10,  10,  10,
+  11,  11,  11,  12,  12,  13,  13,  14,  14,  15,  15,  15,  16,  16,  17,  17,
+  18,  19,  19,  20,  20,  21,  21,  22,  23,  23,  24,  24,  25,  26,  27,  27,
+  28,  29,  29,  30,  31,  32,  32,  33,  34,  35,  36,  36,  37,  38,  39,  40,
+  41,  42,  43,  44,  45,  46,  47,  48,  49,  50,  51,  52,  53,  54,  55,  56,
+  58,  59,  60,  61,  62,  64,  65,  66,  67,  69,  70,  71,  73,  74,  76,  77,
+  78,  80,  81,  83,  84,  86,  87,  89,  90,  92,  94,  95,  97,  99, 100, 102,
+ 104, 106, 107, 109, 111, 113, 115, 117, 118, 120, 122, 124, 126, 128, 130, 132,
+ 134, 137, 139, 141, 143, 145, 147, 150, 152, 154, 156, 159, 161, 163, 166, 168,
+ 171, 173, 175, 178, 180, 183, 186, 188, 191, 193, 196, 199, 201, 204, 207, 210,
+ 212, 215, 218, 221, 224, 227, 230, 233, 236, 239, 242, 245, 248, 251, 254, 257,
+ 260, 263, 267, 270, 273, 276, 280, 283, 286, 290, 293, 297, 300, 304, 307, 311,
+ 314, 318, 321, 325, 328, 332, 336, 339, 343, 347, 351, 354, 358, 362, 366, 370,
+ 374, 378, 381, 385, 389, 393, 397, 401, 405, 410, 414, 418, 422, 426, 430, 434,
+ 439, 443, 447, 451, 456, 460, 464, 469, 473, 477, 482, 486, 491, 495, 499, 504,
+ 508, 513, 517, 522, 527, 531, 536, 540, 545, 550, 554, 559, 563, 568, 573, 577,
+ 582, 587, 592, 596, 601, 606, 611, 615, 620, 625, 630, 635, 640, 644, 649, 654,
+ 659, 664, 669, 674, 678, 683, 688, 693, 698, 703, 708, 713, 718, 723, 728, 732,
+ 737, 742, 747, 752, 757, 762, 767, 772, 777, 782, 787, 792, 797, 802, 806, 811,
+ 816, 821, 826, 831, 836, 841, 846, 851, 855, 860, 865, 870, 875, 880, 884, 889,
+ 894, 899, 904, 908, 913, 918, 923, 927, 932, 937, 941, 946, 951, 955, 960, 965,
+ 969, 974, 978, 983, 988, 992, 997,1001,1005,1010,1014,1019,1023,1027,1032,1036,
+1040,1045,1049,1053,1057,1061,1066,1070,1074,1078,1082,1086,1090,1094,1098,1102,
+1106,1109,1113,1117,1121,1125,1128,1132,1136,1139,1143,1146,1150,1153,1157,1160,
+1164,1167,1170,1174,1177,1180,1183,1186,1190,1193,1196,1199,1202,1205,1207,1210,
+1213,1216,1219,1221,1224,1227,1229,1232,1234,1237,1239,1241,1244,1246,1248,1251,
+1253,1255,1257,1259,1261,1263,1265,1267,1269,1270,1272,1274,1275,1277,1279,1280,
+1282,1283,1284,1286,1287,1288,1290,1291,1292,1293,1294,1295,1296,1297,1297,1298,
+1299,1300,1300,1301,1302,1302,1303,1303,1303,1304,1304,1304,1304,1304,1305,1305,
+};
+
+inline int SPC_DSP::interpolate( voice_t const* v )
+{
+	// Make pointers into gaussian based on fractional position between samples
+	int offset = v->interp_pos >> 4 & 0xFF;
+	short const* fwd = gauss + 255 - offset;
+	short const* rev = gauss       + offset; // mirror left half of gaussian
+	
+	int const* in = &v->buf [(v->interp_pos >> 12) + v->buf_pos];
+	int out;
+	out  = (fwd [  0] * in [0]) >> 11;
+	out += (fwd [256] * in [1]) >> 11;
+	out += (rev [256] * in [2]) >> 11;
+	out = (int16_t) out;
+	out += (rev [  0] * in [3]) >> 11;
+	
+	CLAMP16( out );
+	out &= ~1;
+	return out;
+}
+
+
+//// Counters
+
+int const simple_counter_range = 2048 * 5 * 3; // 30720
+
+static unsigned const counter_rates [32] =
+{
+   simple_counter_range + 1, // never fires
+          2048, 1536,
+	1280, 1024,  768,
+	 640,  512,  384,
+	 320,  256,  192,
+	 160,  128,   96,
+	  80,   64,   48,
+	  40,   32,   24,
+	  20,   16,   12,
+	  10,    8,    6,
+	   5,    4,    3,
+	         2,
+	         1
+};
+
+static unsigned const counter_offsets [32] =
+{
+	  1, 0, 1040,
+	536, 0, 1040,
+	536, 0, 1040,
+	536, 0, 1040,
+	536, 0, 1040,
+	536, 0, 1040,
+	536, 0, 1040,
+	536, 0, 1040,
+	536, 0, 1040,
+	536, 0, 1040,
+	     0,
+	     0
+};
+
+inline void SPC_DSP::init_counter()
+{
+	m.counter = 0;
+}
+
+inline void SPC_DSP::run_counters()
+{
+	if ( --m.counter < 0 )
+		m.counter = simple_counter_range - 1;
+}
+
+inline unsigned SPC_DSP::read_counter( int rate )
+{
+	return ((unsigned) m.counter + counter_offsets [rate]) % counter_rates [rate];
+}
+
+
+//// Envelope
+
+inline void SPC_DSP::run_envelope( voice_t* const v )
+{
+	int env = v->env;
+	if ( v->env_mode == env_release ) // 60%
+	{
+		if ( (env -= 0x8) < 0 )
+			env = 0;
+		v->env = env;
+	}
+	else
+	{
+		int rate;
+		int env_data = VREG(v->regs,adsr1);
+		if ( m.t_adsr0 & 0x80 ) // 99% ADSR
+		{
+			if ( v->env_mode >= env_decay ) // 99%
+			{
+				env--;
+				env -= env >> 8;
+				rate = env_data & 0x1F;
+				if ( v->env_mode == env_decay ) // 1%
+					rate = (m.t_adsr0 >> 3 & 0x0E) + 0x10;
+			}
+			else // env_attack
+			{
+				rate = (m.t_adsr0 & 0x0F) * 2 + 1;
+				env += rate < 31 ? 0x20 : 0x400;
+			}
+		}
+		else // GAIN
+		{
+			int mode;
+			env_data = VREG(v->regs,gain);
+			mode = env_data >> 5;
+			if ( mode < 4 ) // direct
+			{
+				env = env_data * 0x10;
+				rate = 31;
+			}
+			else
+			{
+				rate = env_data & 0x1F;
+				if ( mode == 4 ) // 4: linear decrease
+				{
+					env -= 0x20;
+				}
+				else if ( mode < 6 ) // 5: exponential decrease
+				{
+					env--;
+					env -= env >> 8;
+				}
+				else // 6,7: linear increase
+				{
+					env += 0x20;
+					if ( mode > 6 && (unsigned) v->hidden_env >= 0x600 )
+						env += 0x8 - 0x20; // 7: two-slope linear increase
+				}
+			}
+		}
+		
+		// Sustain level
+		if ( (env >> 8) == (env_data >> 5) && v->env_mode == env_decay )
+			v->env_mode = env_sustain;
+		
+		v->hidden_env = env;
+		
+		// unsigned cast because linear decrease going negative also triggers this
+		if ( (unsigned) env > 0x7FF )
+		{
+			env = (env < 0 ? 0 : 0x7FF);
+			if ( v->env_mode == env_attack )
+				v->env_mode = env_decay;
+		}
+		
+		if ( !read_counter( rate ) )
+			v->env = env; // nothing else is controlled by the counter
+	}
+}
+
+
+//// BRR Decoding
+
+inline void SPC_DSP::decode_brr( voice_t* v )
+{
+	// Arrange the four input nybbles in 0xABCD order for easy decoding
+	int nybbles = m.t_brr_byte * 0x100 + m.ram [(v->brr_addr + v->brr_offset + 1) & 0xFFFF];
+	
+	int const header = m.t_brr_header;
+	
+	// Write to next four samples in circular buffer
+	int* pos = &v->buf [v->buf_pos];
+	int* end;
+	if ( (v->buf_pos += 4) >= brr_buf_size )
+		v->buf_pos = 0;
+	
+	// Decode four samples
+	for ( end = pos + 4; pos < end; pos++, nybbles <<= 4 )
+	{
+		// Extract nybble and sign-extend
+		int s = (int16_t) nybbles >> 12;
+		
+		// Shift sample based on header
+		int const shift = header >> 4;
+		s = (s << shift) >> 1;
+		if ( shift >= 0xD ) // handle invalid range
+			s = (s >> 25) << 11; // same as: s = (s < 0 ? -0x800 : 0)
+		
+		// Apply IIR filter (8 is the most commonly used)
+		int const filter = header & 0x0C;
+		int const p1 = pos [brr_buf_size - 1];
+		int const p2 = pos [brr_buf_size - 2] >> 1;
+		if ( filter >= 8 )
+		{
+			s += p1;
+			s -= p2;
+			if ( filter == 8 ) // s += p1 * 0.953125 - p2 * 0.46875
+			{
+				s += p2 >> 4;
+				s += (p1 * -3) >> 6;
+			}
+			else // s += p1 * 0.8984375 - p2 * 0.40625
+			{
+				s += (p1 * -13) >> 7;
+				s += (p2 * 3) >> 4;
+			}
+		}
+		else if ( filter ) // s += p1 * 0.46875
+		{
+			s += p1 >> 1;
+			s += (-p1) >> 5;
+		}
+		
+		// Adjust and write sample
+		CLAMP16( s );
+		s = (int16_t) (s * 2);
+		pos [brr_buf_size] = pos [0] = s; // second copy simplifies wrap-around
+	}
+}
+
+
+//// Misc
+
+#define MISC_CLOCK( n ) inline void SPC_DSP::misc_##n()
+
+MISC_CLOCK( 27 )
+{
+	m.t_pmon = REG(pmon) & 0xFE; // voice 0 doesn't support PMON
+}
+MISC_CLOCK( 28 )
+{
+	m.t_non = REG(non);
+	m.t_eon = REG(eon);
+	m.t_dir = REG(dir);
+}
+MISC_CLOCK( 29 )
+{
+	if ( (m.every_other_sample ^= 1) != 0 )
+		m.new_kon &= ~m.kon; // clears KON 63 clocks after it was last read
+}
+MISC_CLOCK( 30 )
+{
+	if ( m.every_other_sample )
+	{
+		m.kon    = m.new_kon;
+		m.t_koff = REG(koff) | m.mute_mask; 
+	}
+	
+	run_counters();
+	
+	// Noise
+	if ( !read_counter( REG(flg) & 0x1F ) )
+	{
+		int feedback = (m.noise << 13) ^ (m.noise << 14);
+		m.noise = (feedback & 0x4000) ^ (m.noise >> 1);
+	}
+}
+
+
+//// Voices
+
+#define VOICE_CLOCK( n ) void SPC_DSP::voice_##n( voice_t* const v )
+
+inline VOICE_CLOCK( V1 )
+{
+	m.t_dir_addr = m.t_dir * 0x100 + m.t_srcn * 4;
+	m.t_srcn = VREG(v->regs,srcn);
+}
+inline VOICE_CLOCK( V2 )
+{
+	// Read sample pointer (ignored if not needed)
+	uint8_t const* entry = &m.ram [m.t_dir_addr];
+	if ( !v->kon_delay )
+		entry += 2;
+	m.t_brr_next_addr = GET_LE16A( entry );
+	
+	m.t_adsr0 = VREG(v->regs,adsr0);
+	
+	// Read pitch, spread over two clocks
+	m.t_pitch = VREG(v->regs,pitchl);
+}
+inline VOICE_CLOCK( V3a )
+{
+	m.t_pitch += (VREG(v->regs,pitchh) & 0x3F) << 8;
+}
+inline VOICE_CLOCK( V3b )
+{
+	// Read BRR header and byte
+	m.t_brr_byte   = m.ram [(v->brr_addr + v->brr_offset) & 0xFFFF];
+	m.t_brr_header = m.ram [v->brr_addr]; // brr_addr doesn't need masking
+}
+VOICE_CLOCK( V3c )
+{
+	// Pitch modulation using previous voice's output
+	if ( m.t_pmon & v->vbit )
+		m.t_pitch += ((m.t_output >> 5) * m.t_pitch) >> 10;
+	
+	if ( v->kon_delay )
+	{
+		// Get ready to start BRR decoding on next sample
+		if ( v->kon_delay == 5 )
+		{
+			v->brr_addr    = m.t_brr_next_addr;
+			v->brr_offset  = 1;
+			v->buf_pos     = 0;
+			m.t_brr_header = 0; // header is ignored on this sample
+			m.kon_check    = true;
+		}
+		
+		// Envelope is never run during KON
+		v->env        = 0;
+		v->hidden_env = 0;
+		
+		// Disable BRR decoding until last three samples
+		v->interp_pos = 0;
+		if ( --v->kon_delay & 3 )
+			v->interp_pos = 0x4000;
+		
+		// Pitch is never added during KON
+		m.t_pitch = 0;
+	}
+	
+	// Gaussian interpolation
+	{
+		int output = interpolate( v );
+		
+		// Noise
+		if ( m.t_non & v->vbit )
+			output = (int16_t) (m.noise * 2);
+		
+		// Apply envelope
+		m.t_output = (output * v->env) >> 11 & ~1;
+		v->t_envx_out = (uint8_t) (v->env >> 4);
+	}
+	
+	// Immediate silence due to end of sample or soft reset
+	if ( REG(flg) & 0x80 || (m.t_brr_header & 3) == 1 )
+	{
+		v->env_mode = env_release;
+		v->env      = 0;
+	}
+	
+	if ( m.every_other_sample )
+	{
+		// KOFF
+		if ( m.t_koff & v->vbit )
+			v->env_mode = env_release;
+		
+		// KON
+		if ( m.kon & v->vbit )
+		{
+			v->kon_delay = 5;
+			v->env_mode  = env_attack;
+		}
+	}
+	
+	// Run envelope for next sample
+	if ( !v->kon_delay )
+		run_envelope( v );
+}
+inline void SPC_DSP::voice_output( voice_t const* v, int ch )
+{
+	// Apply left/right volume
+	int amp = (m.t_output * (int8_t) VREG(v->regs,voll + ch)) >> 7;
+	
+	// Add to output total
+	m.t_main_out [ch] += amp;
+	CLAMP16( m.t_main_out [ch] );
+	
+	// Optionally add to echo total
+	if ( m.t_eon & v->vbit )
+	{
+		m.t_echo_out [ch] += amp;
+		CLAMP16( m.t_echo_out [ch] );
+	}
+}
+VOICE_CLOCK( V4 )
+{
+	// Decode BRR
+	m.t_looped = 0;
+	if ( v->interp_pos >= 0x4000 )
+	{
+		decode_brr( v );
+		
+		if ( (v->brr_offset += 2) >= brr_block_size )
+		{
+			// Start decoding next BRR block
+			assert( v->brr_offset == brr_block_size );
+			v->brr_addr = (v->brr_addr + brr_block_size) & 0xFFFF;
+			if ( m.t_brr_header & 1 )
+			{
+				v->brr_addr = m.t_brr_next_addr;
+				m.t_looped = v->vbit;
+			}
+			v->brr_offset = 1;
+		}
+	}
+	
+	// Apply pitch
+	v->interp_pos = (v->interp_pos & 0x3FFF) + m.t_pitch;
+	
+	// Keep from getting too far ahead (when using pitch modulation)
+	if ( v->interp_pos > 0x7FFF )
+		v->interp_pos = 0x7FFF;
+	
+	// Output left
+	voice_output( v, 0 );
+}
+inline VOICE_CLOCK( V5 )
+{
+	// Output right
+	voice_output( v, 1 );
+	
+	// ENDX, OUTX, and ENVX won't update if you wrote to them 1-2 clocks earlier
+	int endx_buf = REG(endx) | m.t_looped;
+	
+	// Clear bit in ENDX if KON just began
+	if ( v->kon_delay == 5 )
+		endx_buf &= ~v->vbit;
+	m.endx_buf = (uint8_t) endx_buf;
+}
+inline VOICE_CLOCK( V6 )
+{
+	(void) v; // avoid compiler warning about unused v
+	m.outx_buf = (uint8_t) (m.t_output >> 8);
+}
+inline VOICE_CLOCK( V7 )
+{
+	// Update ENDX
+	REG(endx) = m.endx_buf;
+	
+	m.envx_buf = v->t_envx_out;
+}
+inline VOICE_CLOCK( V8 )
+{
+	// Update OUTX
+	VREG(v->regs,outx) = m.outx_buf;
+}
+inline VOICE_CLOCK( V9 )
+{
+	// Update ENVX
+	VREG(v->regs,envx) = m.envx_buf;
+}
+
+// Most voices do all these in one clock, so make a handy composite
+inline VOICE_CLOCK( V3 )
+{
+	voice_V3a( v );
+	voice_V3b( v );
+	voice_V3c( v );
+}
+
+// Common combinations of voice steps on different voices. This greatly reduces
+// code size and allows everything to be inlined in these functions.
+VOICE_CLOCK(V7_V4_V1) { voice_V7(v); voice_V1(v+3); voice_V4(v+1); }
+VOICE_CLOCK(V8_V5_V2) { voice_V8(v); voice_V5(v+1); voice_V2(v+2); }
+VOICE_CLOCK(V9_V6_V3) { voice_V9(v); voice_V6(v+1); voice_V3(v+2); }
+
+
+//// Echo
+
+// Current echo buffer pointer for left/right channel
+#define ECHO_PTR( ch )      (&m.ram [m.t_echo_ptr + ch * 2])
+
+// Sample in echo history buffer, where 0 is the oldest
+#define ECHO_FIR( i )       (m.echo_hist_pos [i])
+
+// Calculate FIR point for left/right channel
+#define CALC_FIR( i, ch )   ((ECHO_FIR( i + 1 ) [ch] * (int8_t) REG(fir + i * 0x10)) >> 6)
+
+#define ECHO_CLOCK( n ) inline void SPC_DSP::echo_##n()
+
+inline void SPC_DSP::echo_read( int ch )
+{
+	int s = GET_LE16SA( ECHO_PTR( ch ) );
+	// second copy simplifies wrap-around handling
+	ECHO_FIR( 0 ) [ch] = ECHO_FIR( 8 ) [ch] = s >> 1;
+}
+
+ECHO_CLOCK( 22 )
+{
+	// History
+	if ( ++m.echo_hist_pos >= &m.echo_hist [echo_hist_size] )
+		m.echo_hist_pos = m.echo_hist;
+	
+	m.t_echo_ptr = (m.t_esa * 0x100 + m.echo_offset) & 0xFFFF;
+	echo_read( 0 );
+	
+	// FIR (using l and r temporaries below helps compiler optimize)
+	int l = CALC_FIR( 0, 0 );
+	int r = CALC_FIR( 0, 1 );
+	
+	m.t_echo_in [0] = l;
+	m.t_echo_in [1] = r;
+}
+ECHO_CLOCK( 23 )
+{
+	int l = CALC_FIR( 1, 0 ) + CALC_FIR( 2, 0 );
+	int r = CALC_FIR( 1, 1 ) + CALC_FIR( 2, 1 );
+	
+	m.t_echo_in [0] += l;
+	m.t_echo_in [1] += r;
+	
+	echo_read( 1 );
+}
+ECHO_CLOCK( 24 )
+{
+	int l = CALC_FIR( 3, 0 ) + CALC_FIR( 4, 0 ) + CALC_FIR( 5, 0 );
+	int r = CALC_FIR( 3, 1 ) + CALC_FIR( 4, 1 ) + CALC_FIR( 5, 1 );
+	
+	m.t_echo_in [0] += l;
+	m.t_echo_in [1] += r;
+}
+ECHO_CLOCK( 25 )
+{
+	int l = m.t_echo_in [0] + CALC_FIR( 6, 0 );
+	int r = m.t_echo_in [1] + CALC_FIR( 6, 1 );
+	
+	l = (int16_t) l;
+	r = (int16_t) r;
+	
+	l += (int16_t) CALC_FIR( 7, 0 );
+	r += (int16_t) CALC_FIR( 7, 1 );
+	
+	CLAMP16( l );
+	CLAMP16( r );
+	
+	m.t_echo_in [0] = l & ~1;
+	m.t_echo_in [1] = r & ~1;
+}
+inline int SPC_DSP::echo_output( int ch )
+{
+	int out = (int16_t) ((m.t_main_out [ch] * (int8_t) REG(mvoll + ch * 0x10)) >> 7) +
+			(int16_t) ((m.t_echo_in [ch] * (int8_t) REG(evoll + ch * 0x10)) >> 7);
+	CLAMP16( out );
+	return out;
+}
+ECHO_CLOCK( 26 )
+{
+	// Left output volumes
+	// (save sample for next clock so we can output both together)
+	m.t_main_out [0] = echo_output( 0 );
+	
+	// Echo feedback
+	int l = m.t_echo_out [0] + (int16_t) ((m.t_echo_in [0] * (int8_t) REG(efb)) >> 7);
+	int r = m.t_echo_out [1] + (int16_t) ((m.t_echo_in [1] * (int8_t) REG(efb)) >> 7);
+	
+	CLAMP16( l );
+	CLAMP16( r );
+	
+	m.t_echo_out [0] = l & ~1;
+	m.t_echo_out [1] = r & ~1;
+}
+ECHO_CLOCK( 27 )
+{
+	// Output
+	int l = m.t_main_out [0];
+	int r = echo_output( 1 );
+	m.t_main_out [0] = 0;
+	m.t_main_out [1] = 0;
+	
+	// TODO: global muting isn't this simple (turns DAC on and off
+	// or something, causing small ~37-sample pulse when first muted)
+	if ( REG(flg) & 0x40 )
+	{
+		l = 0;
+		r = 0;
+	}
+	
+	// Output sample to DAC
+	#ifdef SPC_DSP_OUT_HOOK
+		SPC_DSP_OUT_HOOK( l, r );
+	#else
+		sample_t* out = m.out;
+		WRITE_SAMPLES( l, r, out );
+		m.out = out;
+	#endif
+}
+ECHO_CLOCK( 28 )
+{
+	m.t_echo_enabled = REG(flg);
+}
+inline void SPC_DSP::echo_write( int ch )
+{
+	if ( !(m.t_echo_enabled & 0x20) )
+		SET_LE16A( ECHO_PTR( ch ), m.t_echo_out [ch] );
+	m.t_echo_out [ch] = 0;
+}
+ECHO_CLOCK( 29 )
+{
+	m.t_esa = REG(esa);
+	
+	if ( !m.echo_offset )
+		m.echo_length = (REG(edl) & 0x0F) * 0x800;
+	
+	m.echo_offset += 4;
+	if ( m.echo_offset >= m.echo_length )
+		m.echo_offset = 0;
+	
+	// Write left echo
+	echo_write( 0 );
+	
+	m.t_echo_enabled = REG(flg);
+}
+ECHO_CLOCK( 30 )
+{
+	// Write right echo
+	echo_write( 1 );
+}
+
+
+//// Timing
+
+// Execute clock for a particular voice
+#define V( clock, voice )   voice_##clock( &m.voices [voice] );
+
+/* The most common sequence of clocks uses composite operations
+for efficiency. For example, the following are equivalent to the
+individual steps on the right:
+
+V(V7_V4_V1,2) -> V(V7,2) V(V4,3) V(V1,5)
+V(V8_V5_V2,2) -> V(V8,2) V(V5,3) V(V2,4)
+V(V9_V6_V3,2) -> V(V9,2) V(V6,3) V(V3,4) */
+
+// Voice      0      1      2      3      4      5      6      7
+#define GEN_DSP_TIMING \
+PHASE( 0)  V(V5,0)V(V2,1)\
+PHASE( 1)  V(V6,0)V(V3,1)\
+PHASE( 2)  V(V7_V4_V1,0)\
+PHASE( 3)  V(V8_V5_V2,0)\
+PHASE( 4)  V(V9_V6_V3,0)\
+PHASE( 5)         V(V7_V4_V1,1)\
+PHASE( 6)         V(V8_V5_V2,1)\
+PHASE( 7)         V(V9_V6_V3,1)\
+PHASE( 8)                V(V7_V4_V1,2)\
+PHASE( 9)                V(V8_V5_V2,2)\
+PHASE(10)                V(V9_V6_V3,2)\
+PHASE(11)                       V(V7_V4_V1,3)\
+PHASE(12)                       V(V8_V5_V2,3)\
+PHASE(13)                       V(V9_V6_V3,3)\
+PHASE(14)                              V(V7_V4_V1,4)\
+PHASE(15)                              V(V8_V5_V2,4)\
+PHASE(16)                              V(V9_V6_V3,4)\
+PHASE(17)  V(V1,0)                            V(V7,5)V(V4,6)\
+PHASE(18)                                     V(V8_V5_V2,5)\
+PHASE(19)                                     V(V9_V6_V3,5)\
+PHASE(20)         V(V1,1)                            V(V7,6)V(V4,7)\
+PHASE(21)                                            V(V8,6)V(V5,7)  V(V2,0)  /* t_brr_next_addr order dependency */\
+PHASE(22)  V(V3a,0)                                  V(V9,6)V(V6,7)  echo_22();\
+PHASE(23)                                                   V(V7,7)  echo_23();\
+PHASE(24)                                                   V(V8,7)  echo_24();\
+PHASE(25)  V(V3b,0)                                         V(V9,7)  echo_25();\
+PHASE(26)                                                            echo_26();\
+PHASE(27) misc_27();                                                 echo_27();\
+PHASE(28) misc_28();                                                 echo_28();\
+PHASE(29) misc_29();                                                 echo_29();\
+PHASE(30) misc_30();V(V3c,0)                                         echo_30();\
+PHASE(31)  V(V4,0)       V(V1,2)\
+
+#if !SPC_DSP_CUSTOM_RUN
+
+void SPC_DSP::run( int clocks_remain )
+{
+	require( clocks_remain > 0 );
+	
+	int const phase = m.phase;
+	m.phase = (phase + clocks_remain) & 31;
+	switch ( phase )
+	{
+	loop:
+	
+		#define PHASE( n ) if ( n && !--clocks_remain ) break; case n:
+		GEN_DSP_TIMING
+		#undef PHASE
+	
+		if ( --clocks_remain )
+			goto loop;
+	}
+}
+
+#endif
+
+
+//// Setup
+
+void SPC_DSP::init( void* ram_64k )
+{
+	m.ram = (uint8_t*) ram_64k;
+	mute_voices( 0 );
+	disable_surround( false );
+	set_output( 0, 0 );
+	reset();
+	
+	#ifndef NDEBUG
+		// be sure this sign-extends
+		assert( (int16_t) 0x8000 == -0x8000 );
+		
+		// be sure right shift preserves sign
+		assert( (-1 >> 1) == -1 );
+		
+		// check clamp macro
+		int i;
+		i = +0x8000; CLAMP16( i ); assert( i == +0x7FFF );
+		i = -0x8001; CLAMP16( i ); assert( i == -0x8000 );
+		
+		blargg_verify_byte_order();
+	#endif
+}
+
+void SPC_DSP::soft_reset_common()
+{
+	require( m.ram ); // init() must have been called already
+	
+	m.noise              = 0x4000;
+	m.echo_hist_pos      = m.echo_hist;
+	m.every_other_sample = 1;
+	m.echo_offset        = 0;
+	m.phase              = 0;
+	
+	init_counter();
+}
+
+void SPC_DSP::soft_reset()
+{
+	REG(flg) = 0xE0;
+	soft_reset_common();
+}
+
+void SPC_DSP::load( uint8_t const regs [register_count] )
+{
+	memcpy( m.regs, regs, sizeof m.regs );
+	memset( &m.regs [register_count], 0, offsetof (state_t,ram) - register_count );
+	
+	// Internal state
+	for ( int i = voice_count; --i >= 0; )
+	{
+		voice_t* v = &m.voices [i];
+		v->brr_offset = 1;
+		v->vbit       = 1 << i;
+		v->regs       = &m.regs [i * 0x10];
+	}
+	m.new_kon = REG(kon);
+	m.t_dir   = REG(dir);
+	m.t_esa   = REG(esa);
+	
+	soft_reset_common();
+}
+
+void SPC_DSP::reset() { load( initial_regs ); }
+
+
+//// State save/load
+
+#if !SPC_NO_COPY_STATE_FUNCS
+
+void SPC_State_Copier::copy( void* state, size_t size )
+{
+	func( buf, state, size );
+}
+
+int SPC_State_Copier::copy_int( int state, int size )
+{
+	BOOST::uint8_t s [2];
+	SET_LE16( s, state );
+	func( buf, &s, size );
+	return GET_LE16( s );
+}
+
+void SPC_State_Copier::skip( int count )
+{
+	if ( count > 0 )
+	{
+		char temp [64];
+		memset( temp, 0, sizeof temp );
+		do
+		{
+			int n = sizeof temp;
+			if ( n > count )
+				n = count;
+			count -= n;
+			func( buf, temp, n );
+		}
+		while ( count );
+	}
+}
+
+void SPC_State_Copier::extra()
+{
+	int n = 0;
+	SPC_State_Copier& copier = *this;
+	SPC_COPY( uint8_t, n );
+	skip( n );
+}
+
+void SPC_DSP::copy_state( unsigned char** io, copy_func_t copy )
+{
+	SPC_State_Copier copier( io, copy );
+	
+	// DSP registers
+	copier.copy( m.regs, register_count );
+	
+	// Internal state
+	
+	// Voices
+	int i;
+	for ( i = 0; i < voice_count; i++ )
+	{
+		voice_t* v = &m.voices [i];
+		
+		// BRR buffer
+		int i;
+		for ( i = 0; i < brr_buf_size; i++ )
+		{
+			int s = v->buf [i];
+			SPC_COPY(  int16_t, s );
+			v->buf [i] = v->buf [i + brr_buf_size] = s;
+		}
+		
+		SPC_COPY( uint16_t, v->interp_pos );
+		SPC_COPY( uint16_t, v->brr_addr );
+		SPC_COPY( uint16_t, v->env );
+		SPC_COPY(  int16_t, v->hidden_env );
+		SPC_COPY(  uint8_t, v->buf_pos );
+		SPC_COPY(  uint8_t, v->brr_offset );
+		SPC_COPY(  uint8_t, v->kon_delay );
+		{
+			int m = v->env_mode;
+			SPC_COPY(  uint8_t, m );
+			v->env_mode = (enum env_mode_t) m;
+		}
+		SPC_COPY(  uint8_t, v->t_envx_out );
+		
+		copier.extra();
+	}
+	
+	// Echo history
+	for ( i = 0; i < echo_hist_size; i++ )
+	{
+		int j;
+		for ( j = 0; j < 2; j++ )
+		{
+			int s = m.echo_hist_pos [i] [j];
+			SPC_COPY( int16_t, s );
+			m.echo_hist [i] [j] = s; // write back at offset 0
+		}
+	}
+	m.echo_hist_pos = m.echo_hist;
+	memcpy( &m.echo_hist [echo_hist_size], m.echo_hist, echo_hist_size * sizeof m.echo_hist [0] );
+	
+	// Misc
+	SPC_COPY(  uint8_t, m.every_other_sample );
+	SPC_COPY(  uint8_t, m.kon );
+	
+	SPC_COPY( uint16_t, m.noise );
+	SPC_COPY( uint16_t, m.counter );
+	SPC_COPY( uint16_t, m.echo_offset );
+	SPC_COPY( uint16_t, m.echo_length );
+	SPC_COPY(  uint8_t, m.phase );
+	
+	SPC_COPY(  uint8_t, m.new_kon );
+	SPC_COPY(  uint8_t, m.endx_buf );
+	SPC_COPY(  uint8_t, m.envx_buf );
+	SPC_COPY(  uint8_t, m.outx_buf );
+	
+	SPC_COPY(  uint8_t, m.t_pmon );
+	SPC_COPY(  uint8_t, m.t_non );
+	SPC_COPY(  uint8_t, m.t_eon );
+	SPC_COPY(  uint8_t, m.t_dir );
+	SPC_COPY(  uint8_t, m.t_koff );
+	
+	SPC_COPY( uint16_t, m.t_brr_next_addr );
+	SPC_COPY(  uint8_t, m.t_adsr0 );
+	SPC_COPY(  uint8_t, m.t_brr_header );
+	SPC_COPY(  uint8_t, m.t_brr_byte );
+	SPC_COPY(  uint8_t, m.t_srcn );
+	SPC_COPY(  uint8_t, m.t_esa );
+	SPC_COPY(  uint8_t, m.t_echo_enabled );
+	
+	SPC_COPY(  int16_t, m.t_main_out [0] );
+	SPC_COPY(  int16_t, m.t_main_out [1] );
+	SPC_COPY(  int16_t, m.t_echo_out [0] );
+	SPC_COPY(  int16_t, m.t_echo_out [1] );
+	SPC_COPY(  int16_t, m.t_echo_in  [0] );
+	SPC_COPY(  int16_t, m.t_echo_in  [1] );
+	
+	SPC_COPY( uint16_t, m.t_dir_addr );
+	SPC_COPY( uint16_t, m.t_pitch );
+	SPC_COPY(  int16_t, m.t_output );
+	SPC_COPY( uint16_t, m.t_echo_ptr );
+	SPC_COPY(  uint8_t, m.t_looped );
+	
+	copier.extra();
+}
+#endif
diff --git a/nSide/higan/sfc-balanced/dsp/SPC_DSP.h b/nSide/higan/sfc-balanced/dsp/SPC_DSP.h
new file mode 100644
index 0000000..62095a5
--- /dev/null
+++ b/nSide/higan/sfc-balanced/dsp/SPC_DSP.h
@@ -0,0 +1,307 @@
+// Highly accurate SNES SPC-700 DSP emulator
+
+// snes_spc 0.9.0
+#ifndef SPC_DSP_H
+#define SPC_DSP_H
+
+#include "blargg_common.h"
+
+extern "C" { typedef void (*dsp_copy_func_t)( unsigned char** io, void* state, size_t ); }
+
+class SPC_DSP {
+public:
+	typedef BOOST::uint8_t uint8_t;
+	
+// Setup
+
+	// Initializes DSP and has it use the 64K RAM provided
+	void init( void* ram_64k );
+
+	// Sets destination for output samples. If out is NULL or out_size is 0,
+	// doesn't generate any.
+	typedef short sample_t;
+	void set_output( sample_t* out, int out_size );
+
+	// Number of samples written to output since it was last set, always
+	// a multiple of 2. Undefined if more samples were generated than
+	// output buffer could hold.
+	int sample_count() const;
+
+// Emulation
+
+	// Resets DSP to power-on state
+	void reset();
+
+	// Emulates pressing reset switch on SNES
+	void soft_reset();
+	
+	// Reads/writes DSP registers. For accuracy, you must first call run()
+	// to catch the DSP up to present.
+	int  read ( int addr ) const;
+	void write( int addr, int data );
+
+	// Runs DSP for specified number of clocks (~1024000 per second). Every 32 clocks
+	// a pair of samples is be generated.
+	void run( int clock_count );
+	
+// Sound control
+
+	// Mutes voices corresponding to non-zero bits in mask (issues repeated KOFF events).
+	// Reduces emulation accuracy.
+	enum { voice_count = 8 };
+	void mute_voices( int mask );
+
+// State
+	
+	// Resets DSP and uses supplied values to initialize registers
+	enum { register_count = 128 };
+	void load( uint8_t const regs [register_count] );
+
+	// Saves/loads exact emulator state
+	enum { state_size = 640 }; // maximum space needed when saving
+	typedef dsp_copy_func_t copy_func_t;
+	void copy_state( unsigned char** io, copy_func_t );
+
+	// Returns non-zero if new key-on events occurred since last call
+	bool check_kon();
+	
+// DSP register addresses
+
+	// Global registers
+	enum {
+	    r_mvoll = 0x0C, r_mvolr = 0x1C,
+	    r_evoll = 0x2C, r_evolr = 0x3C,
+	    r_kon   = 0x4C, r_koff  = 0x5C,
+	    r_flg   = 0x6C, r_endx  = 0x7C,
+	    r_efb   = 0x0D, r_pmon  = 0x2D,
+	    r_non   = 0x3D, r_eon   = 0x4D,
+	    r_dir   = 0x5D, r_esa   = 0x6D,
+	    r_edl   = 0x7D,
+	    r_fir   = 0x0F // 8 coefficients at 0x0F, 0x1F ... 0x7F
+	};
+
+	// Voice registers
+	enum {
+		v_voll   = 0x00, v_volr   = 0x01,
+		v_pitchl = 0x02, v_pitchh = 0x03,
+		v_srcn   = 0x04, v_adsr0  = 0x05,
+		v_adsr1  = 0x06, v_gain   = 0x07,
+		v_envx   = 0x08, v_outx   = 0x09
+	};
+
+public:
+	enum { extra_size = 16 };
+	sample_t* extra()               { return m.extra; }
+	sample_t const* out_pos() const { return m.out; }
+	void disable_surround( bool ) { } // not supported
+public:
+	BLARGG_DISABLE_NOTHROW
+	
+	typedef BOOST::int8_t   int8_t;
+	typedef BOOST::int16_t int16_t;
+	
+	enum { echo_hist_size = 8 };
+	
+	enum env_mode_t { env_release, env_attack, env_decay, env_sustain };
+	enum { brr_buf_size = 12 };
+	struct voice_t
+	{
+		int buf [brr_buf_size*2];// decoded samples (twice the size to simplify wrap handling)
+		int buf_pos;            // place in buffer where next samples will be decoded
+		int interp_pos;         // relative fractional position in sample (0x1000 = 1.0)
+		int brr_addr;           // address of current BRR block
+		int brr_offset;         // current decoding offset in BRR block
+		uint8_t* regs;          // pointer to voice's DSP registers
+		int vbit;               // bitmask for voice: 0x01 for voice 0, 0x02 for voice 1, etc.
+		int kon_delay;          // KON delay/current setup phase
+		env_mode_t env_mode;
+		int env;                // current envelope level
+		int hidden_env;         // used by GAIN mode 7, very obscure quirk
+		uint8_t t_envx_out;
+	};
+private:
+	enum { brr_block_size = 9 };
+	
+	struct state_t
+	{
+		uint8_t regs [register_count];
+		
+		// Echo history keeps most recent 8 samples (twice the size to simplify wrap handling)
+		int echo_hist [echo_hist_size * 2] [2];
+		int (*echo_hist_pos) [2]; // &echo_hist [0 to 7]
+		
+		int every_other_sample; // toggles every sample
+		int kon;                // KON value when last checked
+		int noise;
+		int counter;
+		int echo_offset;        // offset from ESA in echo buffer
+		int echo_length;        // number of bytes that echo_offset will stop at
+		int phase;              // next clock cycle to run (0-31)
+		bool kon_check;         // set when a new KON occurs
+		
+		// Hidden registers also written to when main register is written to
+		int new_kon;
+		uint8_t endx_buf;
+		uint8_t envx_buf;
+		uint8_t outx_buf;
+		
+		// Temporary state between clocks
+		
+		// read once per sample
+		int t_pmon;
+		int t_non;
+		int t_eon;
+		int t_dir;
+		int t_koff;
+		
+		// read a few clocks ahead then used
+		int t_brr_next_addr;
+		int t_adsr0;
+		int t_brr_header;
+		int t_brr_byte;
+		int t_srcn;
+		int t_esa;
+		int t_echo_enabled;
+		
+		// internal state that is recalculated every sample
+		int t_dir_addr;
+		int t_pitch;
+		int t_output;
+		int t_looped;
+		int t_echo_ptr;
+		
+		// left/right sums
+		int t_main_out [2];
+		int t_echo_out [2];
+		int t_echo_in  [2];
+		
+		voice_t voices [voice_count];
+		
+		// non-emulation state
+		uint8_t* ram; // 64K shared RAM between DSP and SMP
+		int mute_mask;
+		sample_t* out;
+		sample_t* out_end;
+		sample_t* out_begin;
+		sample_t extra [extra_size];
+	};
+	state_t m;
+	
+	void init_counter();
+	void run_counters();
+	unsigned read_counter( int rate );
+	
+	int  interpolate( voice_t const* v );
+	void run_envelope( voice_t* const v );
+	void decode_brr( voice_t* v );
+
+	void misc_27();
+	void misc_28();
+	void misc_29();
+	void misc_30();
+
+	void voice_output( voice_t const* v, int ch );
+	void voice_V1( voice_t* const );
+	void voice_V2( voice_t* const );
+	void voice_V3( voice_t* const );
+	void voice_V3a( voice_t* const );
+	void voice_V3b( voice_t* const );
+	void voice_V3c( voice_t* const );
+	void voice_V4( voice_t* const );
+	void voice_V5( voice_t* const );
+	void voice_V6( voice_t* const );
+	void voice_V7( voice_t* const );
+	void voice_V8( voice_t* const );
+	void voice_V9( voice_t* const );
+	void voice_V7_V4_V1( voice_t* const );
+	void voice_V8_V5_V2( voice_t* const );
+	void voice_V9_V6_V3( voice_t* const );
+
+	void echo_read( int ch );
+	int  echo_output( int ch );
+	void echo_write( int ch );
+	void echo_22();
+	void echo_23();
+	void echo_24();
+	void echo_25();
+	void echo_26();
+	void echo_27();
+	void echo_28();
+	void echo_29();
+	void echo_30();
+	
+	void soft_reset_common();
+
+public:
+	bool mute() { return m.regs[r_flg] & 0x40; }
+};
+
+#include <assert.h>
+
+inline int SPC_DSP::sample_count() const { return m.out - m.out_begin; }
+
+inline int SPC_DSP::read( int addr ) const
+{
+	assert( (unsigned) addr < register_count );
+	return m.regs [addr];
+}
+
+inline void SPC_DSP::write( int addr, int data )
+{
+	assert( (unsigned) addr < register_count );
+	
+	m.regs [addr] = (uint8_t) data;
+	switch ( addr & 0x0F )
+	{
+	case v_envx:
+		m.envx_buf = (uint8_t) data;
+		break;
+		
+	case v_outx:
+		m.outx_buf = (uint8_t) data;
+		break;
+	
+	case 0x0C:
+		if ( addr == r_kon )
+			m.new_kon = (uint8_t) data;
+		
+		if ( addr == r_endx ) // always cleared, regardless of data written
+		{
+			m.endx_buf = 0;
+			m.regs [r_endx] = 0;
+		}
+		break;
+	}
+}
+
+inline void SPC_DSP::mute_voices( int mask ) { m.mute_mask = mask; }
+
+inline bool SPC_DSP::check_kon()
+{
+	bool old = m.kon_check;
+	m.kon_check = 0;
+	return old;
+}
+
+#if !SPC_NO_COPY_STATE_FUNCS
+
+class SPC_State_Copier {
+	SPC_DSP::copy_func_t func;
+	unsigned char** buf;
+public:
+	SPC_State_Copier( unsigned char** p, SPC_DSP::copy_func_t f ) { func = f; buf = p; }
+	void copy( void* state, size_t size );
+	int copy_int( int state, int size );
+	void skip( int count );
+	void extra();
+};
+
+#define SPC_COPY( type, state )\
+{\
+	state = (BOOST::type) copier.copy_int( state, sizeof (BOOST::type) );\
+	assert( (BOOST::type) state == state );\
+}
+
+#endif
+
+#endif
diff --git a/nSide/higan/sfc-balanced/dsp/blargg_common.h b/nSide/higan/sfc-balanced/dsp/blargg_common.h
new file mode 100644
index 0000000..75edff3
--- /dev/null
+++ b/nSide/higan/sfc-balanced/dsp/blargg_common.h
@@ -0,0 +1,186 @@
+// Sets up common environment for Shay Green's libraries.
+// To change configuration options, modify blargg_config.h, not this file.
+
+// snes_spc 0.9.0
+#ifndef BLARGG_COMMON_H
+#define BLARGG_COMMON_H
+
+#include <stddef.h>
+#include <stdlib.h>
+#include <assert.h>
+#include <limits.h>
+
+#undef BLARGG_COMMON_H
+// allow blargg_config.h to #include blargg_common.h
+#include "blargg_config.h"
+#ifndef BLARGG_COMMON_H
+#define BLARGG_COMMON_H
+
+// BLARGG_RESTRICT: equivalent to restrict, where supported
+#if defined (__GNUC__) || _MSC_VER >= 1100
+	#define BLARGG_RESTRICT __restrict
+#else
+	#define BLARGG_RESTRICT
+#endif
+
+// STATIC_CAST(T,expr): Used in place of static_cast<T> (expr)
+#ifndef STATIC_CAST
+	#define STATIC_CAST(T,expr) ((T) (expr))
+#endif
+
+// blargg_err_t (0 on success, otherwise error string)
+#ifndef blargg_err_t
+	typedef const char* blargg_err_t;
+#endif
+
+// blargg_vector - very lightweight vector of POD types (no constructor/destructor)
+template<class T>
+class blargg_vector {
+	T* begin_;
+	size_t size_;
+public:
+	blargg_vector() : begin_( 0 ), size_( 0 ) { }
+	~blargg_vector() { free( begin_ ); }
+	size_t size() const { return size_; }
+	T* begin() const { return begin_; }
+	T* end() const { return begin_ + size_; }
+	blargg_err_t resize( size_t n )
+	{
+		// TODO: blargg_common.cpp to hold this as an outline function, ugh
+		void* p = realloc( begin_, n * sizeof (T) );
+		if ( p )
+			begin_ = (T*) p;
+		else if ( n > size_ ) // realloc failure only a problem if expanding
+			return "Out of memory";
+		size_ = n;
+		return 0;
+	}
+	void clear() { void* p = begin_; begin_ = 0; size_ = 0; free( p ); }
+	T& operator [] ( size_t n ) const
+	{
+		assert( n <= size_ ); // <= to allow past-the-end value
+		return begin_ [n];
+	}
+};
+
+#ifndef BLARGG_DISABLE_NOTHROW
+	// throw spec mandatory in ISO C++ if operator new can return NULL
+	#if __cplusplus >= 199711 || defined (__GNUC__)
+		#define BLARGG_THROWS( spec ) throw spec
+	#else
+		#define BLARGG_THROWS( spec )
+	#endif
+	#define BLARGG_DISABLE_NOTHROW \
+		void* operator new ( size_t s ) BLARGG_THROWS(()) { return malloc( s ); }\
+		void operator delete ( void* p ) { free( p ); }
+	#define BLARGG_NEW new
+#else
+	#include <new>
+	#define BLARGG_NEW new (std::nothrow)
+#endif
+
+// BLARGG_4CHAR('a','b','c','d') = 'abcd' (four character integer constant)
+#define BLARGG_4CHAR( a, b, c, d ) \
+	((a&0xFF)*0x1000000L + (b&0xFF)*0x10000L + (c&0xFF)*0x100L + (d&0xFF))
+
+// BOOST_STATIC_ASSERT( expr ): Generates compile error if expr is 0.
+#ifndef BOOST_STATIC_ASSERT
+	#ifdef _MSC_VER
+		// MSVC6 (_MSC_VER < 1300) fails for use of __LINE__ when /Zl is specified
+		#define BOOST_STATIC_ASSERT( expr ) \
+			void blargg_failed_( int (*arg) [2 / (int) !!(expr) - 1] )
+	#else
+		// Some other compilers fail when declaring same function multiple times in class,
+		// so differentiate them by line
+		#define BOOST_STATIC_ASSERT( expr ) \
+			void blargg_failed_( int (*arg) [2 / !!(expr) - 1] [__LINE__] )
+	#endif
+#endif
+
+// BLARGG_COMPILER_HAS_BOOL: If 0, provides bool support for old compiler. If 1,
+// compiler is assumed to support bool. If undefined, availability is determined.
+#ifndef BLARGG_COMPILER_HAS_BOOL
+	#if defined (__MWERKS__)
+		#if !__option(bool)
+			#define BLARGG_COMPILER_HAS_BOOL 0
+		#endif
+	#elif defined (_MSC_VER)
+		#if _MSC_VER < 1100
+			#define BLARGG_COMPILER_HAS_BOOL 0
+		#endif
+	#elif defined (__GNUC__)
+		// supports bool
+	#elif __cplusplus < 199711
+		#define BLARGG_COMPILER_HAS_BOOL 0
+	#endif
+#endif
+#if defined (BLARGG_COMPILER_HAS_BOOL) && !BLARGG_COMPILER_HAS_BOOL
+	// If you get errors here, modify your blargg_config.h file
+	typedef int bool;
+	const bool true  = 1;
+	const bool false = 0;
+#endif
+
+// blargg_long/blargg_ulong = at least 32 bits, int if it's big enough
+
+#if INT_MAX < 0x7FFFFFFF || LONG_MAX == 0x7FFFFFFF
+	typedef long blargg_long;
+#else
+	typedef int blargg_long;
+#endif
+
+#if UINT_MAX < 0xFFFFFFFF || ULONG_MAX == 0xFFFFFFFF
+	typedef unsigned long blargg_ulong;
+#else
+	typedef unsigned blargg_ulong;
+#endif
+
+// BOOST::int8_t etc.
+
+// HAVE_STDINT_H: If defined, use <stdint.h> for int8_t etc.
+#if defined (HAVE_STDINT_H)
+	#include <stdint.h>
+	#define BOOST
+
+// HAVE_INTTYPES_H: If defined, use <stdint.h> for int8_t etc.
+#elif defined (HAVE_INTTYPES_H)
+	#include <inttypes.h>
+	#define BOOST
+
+#else
+	struct BOOST
+	{
+		#if UCHAR_MAX == 0xFF && SCHAR_MAX == 0x7F
+			typedef signed char     int8_t;
+			typedef unsigned char   uint8_t;
+		#else
+			// No suitable 8-bit type available
+			typedef struct see_blargg_common_h int8_t;
+			typedef struct see_blargg_common_h uint8_t;
+		#endif
+		
+		#if USHRT_MAX == 0xFFFF
+			typedef short           int16_t;
+			typedef unsigned short  uint16_t;
+		#else
+			// No suitable 16-bit type available
+			typedef struct see_blargg_common_h int16_t;
+			typedef struct see_blargg_common_h uint16_t;
+		#endif
+		
+		#if ULONG_MAX == 0xFFFFFFFF
+			typedef long            int32_t;
+			typedef unsigned long   uint32_t;
+		#elif UINT_MAX == 0xFFFFFFFF
+			typedef int             int32_t;
+			typedef unsigned int    uint32_t;
+		#else
+			// No suitable 32-bit type available
+			typedef struct see_blargg_common_h int32_t;
+			typedef struct see_blargg_common_h uint32_t;
+		#endif
+	};
+#endif
+
+#endif
+#endif
diff --git a/nSide/higan/sfc-balanced/dsp/blargg_config.h b/nSide/higan/sfc-balanced/dsp/blargg_config.h
new file mode 100644
index 0000000..d85d266
--- /dev/null
+++ b/nSide/higan/sfc-balanced/dsp/blargg_config.h
@@ -0,0 +1,24 @@
+// snes_spc 0.9.0 user configuration file. Don't replace when updating library.
+
+// snes_spc 0.9.0
+#ifndef BLARGG_CONFIG_H
+#define BLARGG_CONFIG_H
+
+// Uncomment to disable debugging checks
+#define NDEBUG 1
+
+// Uncomment to enable platform-specific (and possibly non-portable) optimizations
+//#define BLARGG_NONPORTABLE 1
+
+// Uncomment if automatic byte-order determination doesn't work
+//#define BLARGG_BIG_ENDIAN 1
+
+// Uncomment if you get errors in the bool section of blargg_common.h
+//#define BLARGG_COMPILER_HAS_BOOL 1
+
+// Use standard config.h if present
+#ifdef HAVE_CONFIG_H
+	#include "config.h"
+#endif
+
+#endif
diff --git a/nSide/higan/sfc-balanced/dsp/blargg_endian.h b/nSide/higan/sfc-balanced/dsp/blargg_endian.h
new file mode 100644
index 0000000..f2daca6
--- /dev/null
+++ b/nSide/higan/sfc-balanced/dsp/blargg_endian.h
@@ -0,0 +1,185 @@
+// CPU Byte Order Utilities
+
+// snes_spc 0.9.0
+#ifndef BLARGG_ENDIAN
+#define BLARGG_ENDIAN
+
+#include "blargg_common.h"
+
+// BLARGG_CPU_CISC: Defined if CPU has very few general-purpose registers (< 16)
+#if defined (_M_IX86) || defined (_M_IA64) || defined (__i486__) || \
+		defined (__x86_64__) || defined (__ia64__) || defined (__i386__)
+	#define BLARGG_CPU_X86 1
+	#define BLARGG_CPU_CISC 1
+#endif
+
+#if defined (__powerpc__) || defined (__ppc__) || defined (__POWERPC__) || defined (__powerc)
+	#define BLARGG_CPU_POWERPC 1
+	#define BLARGG_CPU_RISC 1
+#endif
+
+// BLARGG_BIG_ENDIAN, BLARGG_LITTLE_ENDIAN: Determined automatically, otherwise only
+// one may be #defined to 1. Only needed if something actually depends on byte order.
+#if !defined (BLARGG_BIG_ENDIAN) && !defined (BLARGG_LITTLE_ENDIAN)
+#ifdef __GLIBC__
+	// GCC handles this for us
+	#include <endian.h>
+	#if __BYTE_ORDER == __LITTLE_ENDIAN
+		#define BLARGG_LITTLE_ENDIAN 1
+	#elif __BYTE_ORDER == __BIG_ENDIAN
+		#define BLARGG_BIG_ENDIAN 1
+	#endif
+#else
+
+#if defined (LSB_FIRST) || defined (__LITTLE_ENDIAN__) || BLARGG_CPU_X86 || \
+		(defined (LITTLE_ENDIAN) && LITTLE_ENDIAN+0 != 1234)
+	#define BLARGG_LITTLE_ENDIAN 1
+#endif
+
+#if defined (MSB_FIRST)     || defined (__BIG_ENDIAN__) || defined (WORDS_BIGENDIAN) || \
+	defined (__sparc__)     ||  BLARGG_CPU_POWERPC || \
+	(defined (BIG_ENDIAN) && BIG_ENDIAN+0 != 4321)
+	#define BLARGG_BIG_ENDIAN 1
+#elif !defined (__mips__)
+	// No endian specified; assume little-endian, since it's most common
+	#define BLARGG_LITTLE_ENDIAN 1
+#endif
+#endif
+#endif
+
+#if BLARGG_LITTLE_ENDIAN && BLARGG_BIG_ENDIAN
+	#undef BLARGG_LITTLE_ENDIAN
+	#undef BLARGG_BIG_ENDIAN
+#endif
+
+inline void blargg_verify_byte_order()
+{
+	#ifndef NDEBUG
+		#if BLARGG_BIG_ENDIAN
+			volatile int i = 1;
+			assert( *(volatile char*) &i == 0 );
+		#elif BLARGG_LITTLE_ENDIAN
+			volatile int i = 1;
+			assert( *(volatile char*) &i != 0 );
+		#endif
+	#endif
+}
+
+inline unsigned get_le16( void const* p )
+{
+	return  (unsigned) ((unsigned char const*) p) [1] << 8 |
+			(unsigned) ((unsigned char const*) p) [0];
+}
+
+inline unsigned get_be16( void const* p )
+{
+	return  (unsigned) ((unsigned char const*) p) [0] << 8 |
+			(unsigned) ((unsigned char const*) p) [1];
+}
+
+inline blargg_ulong get_le32( void const* p )
+{
+	return  (blargg_ulong) ((unsigned char const*) p) [3] << 24 |
+			(blargg_ulong) ((unsigned char const*) p) [2] << 16 |
+			(blargg_ulong) ((unsigned char const*) p) [1] <<  8 |
+			(blargg_ulong) ((unsigned char const*) p) [0];
+}
+
+inline blargg_ulong get_be32( void const* p )
+{
+	return  (blargg_ulong) ((unsigned char const*) p) [0] << 24 |
+			(blargg_ulong) ((unsigned char const*) p) [1] << 16 |
+			(blargg_ulong) ((unsigned char const*) p) [2] <<  8 |
+			(blargg_ulong) ((unsigned char const*) p) [3];
+}
+
+inline void set_le16( void* p, unsigned n )
+{
+	((unsigned char*) p) [1] = (unsigned char) (n >> 8);
+	((unsigned char*) p) [0] = (unsigned char) n;
+}
+
+inline void set_be16( void* p, unsigned n )
+{
+	((unsigned char*) p) [0] = (unsigned char) (n >> 8);
+	((unsigned char*) p) [1] = (unsigned char) n;
+}
+
+inline void set_le32( void* p, blargg_ulong n )
+{
+	((unsigned char*) p) [0] = (unsigned char) n;
+	((unsigned char*) p) [1] = (unsigned char) (n >> 8);
+	((unsigned char*) p) [2] = (unsigned char) (n >> 16);
+	((unsigned char*) p) [3] = (unsigned char) (n >> 24);
+}
+
+inline void set_be32( void* p, blargg_ulong n )
+{
+	((unsigned char*) p) [3] = (unsigned char) n;
+	((unsigned char*) p) [2] = (unsigned char) (n >> 8);
+	((unsigned char*) p) [1] = (unsigned char) (n >> 16);
+	((unsigned char*) p) [0] = (unsigned char) (n >> 24);
+}
+
+#if BLARGG_NONPORTABLE
+	// Optimized implementation if byte order is known
+	#if BLARGG_LITTLE_ENDIAN
+		#define GET_LE16( addr )        (*(BOOST::uint16_t*) (addr))
+		#define GET_LE32( addr )        (*(BOOST::uint32_t*) (addr))
+		#define SET_LE16( addr, data )  (void) (*(BOOST::uint16_t*) (addr) = (data))
+		#define SET_LE32( addr, data )  (void) (*(BOOST::uint32_t*) (addr) = (data))
+	#elif BLARGG_BIG_ENDIAN
+		#define GET_BE16( addr )        (*(BOOST::uint16_t*) (addr))
+		#define GET_BE32( addr )        (*(BOOST::uint32_t*) (addr))
+		#define SET_BE16( addr, data )  (void) (*(BOOST::uint16_t*) (addr) = (data))
+		#define SET_BE32( addr, data )  (void) (*(BOOST::uint32_t*) (addr) = (data))
+		
+		#if BLARGG_CPU_POWERPC
+			// PowerPC has special byte-reversed instructions
+			#if defined (__MWERKS__)
+				#define GET_LE16( addr )        (__lhbrx( addr, 0 ))
+				#define GET_LE32( addr )        (__lwbrx( addr, 0 ))
+				#define SET_LE16( addr, in )    (__sthbrx( in, addr, 0 ))
+				#define SET_LE32( addr, in )    (__stwbrx( in, addr, 0 ))
+			#elif defined (__GNUC__)
+				#define GET_LE16( addr )        ({unsigned ppc_lhbrx_; asm( "lhbrx %0,0,%1" : "=r" (ppc_lhbrx_) : "r" (addr), "0" (ppc_lhbrx_) ); ppc_lhbrx_;})
+				#define GET_LE32( addr )        ({unsigned ppc_lwbrx_; asm( "lwbrx %0,0,%1" : "=r" (ppc_lwbrx_) : "r" (addr), "0" (ppc_lwbrx_) ); ppc_lwbrx_;})
+				#define SET_LE16( addr, in )    ({asm( "sthbrx %0,0,%1" : : "r" (in), "r" (addr) );})
+				#define SET_LE32( addr, in )    ({asm( "stwbrx %0,0,%1" : : "r" (in), "r" (addr) );})
+			#endif
+		#endif
+	#endif
+#endif
+
+#ifndef GET_LE16
+	#define GET_LE16( addr )        get_le16( addr )
+	#define SET_LE16( addr, data )  set_le16( addr, data )
+#endif
+
+#ifndef GET_LE32
+	#define GET_LE32( addr )        get_le32( addr )
+	#define SET_LE32( addr, data )  set_le32( addr, data )
+#endif
+
+#ifndef GET_BE16
+	#define GET_BE16( addr )        get_be16( addr )
+	#define SET_BE16( addr, data )  set_be16( addr, data )
+#endif
+
+#ifndef GET_BE32
+	#define GET_BE32( addr )        get_be32( addr )
+	#define SET_BE32( addr, data )  set_be32( addr, data )
+#endif
+
+// auto-selecting versions
+
+inline void set_le( BOOST::uint16_t* p, unsigned     n ) { SET_LE16( p, n ); }
+inline void set_le( BOOST::uint32_t* p, blargg_ulong n ) { SET_LE32( p, n ); }
+inline void set_be( BOOST::uint16_t* p, unsigned     n ) { SET_BE16( p, n ); }
+inline void set_be( BOOST::uint32_t* p, blargg_ulong n ) { SET_BE32( p, n ); }
+inline unsigned     get_le( BOOST::uint16_t* p ) { return GET_LE16( p ); }
+inline blargg_ulong get_le( BOOST::uint32_t* p ) { return GET_LE32( p ); }
+inline unsigned     get_be( BOOST::uint16_t* p ) { return GET_BE16( p ); }
+inline blargg_ulong get_be( BOOST::uint32_t* p ) { return GET_BE32( p ); }
+
+#endif
diff --git a/nSide/higan/sfc-balanced/dsp/blargg_source.h b/nSide/higan/sfc-balanced/dsp/blargg_source.h
new file mode 100644
index 0000000..5e45c4f
--- /dev/null
+++ b/nSide/higan/sfc-balanced/dsp/blargg_source.h
@@ -0,0 +1,100 @@
+/* Included at the beginning of library source files, after all other #include lines.
+Sets up helpful macros and services used in my source code. They don't need
+module an annoying module prefix on their names since they are defined after
+all other #include lines. */
+
+// snes_spc 0.9.0
+#ifndef BLARGG_SOURCE_H
+#define BLARGG_SOURCE_H
+
+// If debugging is enabled, abort program if expr is false. Meant for checking
+// internal state and consistency. A failed assertion indicates a bug in the module.
+// void assert( bool expr );
+#include <assert.h>
+
+// If debugging is enabled and expr is false, abort program. Meant for checking
+// caller-supplied parameters and operations that are outside the control of the
+// module. A failed requirement indicates a bug outside the module.
+// void require( bool expr );
+#undef require
+#define require( expr ) assert( expr )
+
+// Like printf() except output goes to debug log file. Might be defined to do
+// nothing (not even evaluate its arguments).
+// void dprintf( const char* format, ... );
+static inline void blargg_dprintf_( const char*, ... ) { }
+#undef dprintf
+#define dprintf (1) ? (void) 0 : blargg_dprintf_
+
+// If enabled, evaluate expr and if false, make debug log entry with source file
+// and line. Meant for finding situations that should be examined further, but that
+// don't indicate a problem. In all cases, execution continues normally.
+#undef check
+#define check( expr ) ((void) 0)
+
+// If expr yields error string, return it from current function, otherwise continue.
+#undef RETURN_ERR
+#define RETURN_ERR( expr ) do {                         \
+		blargg_err_t blargg_return_err_ = (expr);               \
+		if ( blargg_return_err_ ) return blargg_return_err_;    \
+	} while ( 0 )
+
+// If ptr is 0, return out of memory error string.
+#undef CHECK_ALLOC
+#define CHECK_ALLOC( ptr ) do { if ( (ptr) == 0 ) return "Out of memory"; } while ( 0 )
+
+// Avoid any macros which evaluate their arguments multiple times
+#undef min
+#undef max
+
+#define DEF_MIN_MAX( type ) \
+	static inline type min( type x, type y ) { if ( x < y ) return x; return y; }\
+	static inline type max( type x, type y ) { if ( y < x ) return x; return y; }
+
+DEF_MIN_MAX( int )
+DEF_MIN_MAX( unsigned )
+DEF_MIN_MAX( long )
+DEF_MIN_MAX( unsigned long )
+DEF_MIN_MAX( float )
+DEF_MIN_MAX( double )
+
+#undef DEF_MIN_MAX
+
+/*
+// using const references generates crappy code, and I am currenly only using these
+// for built-in types, so they take arguments by value
+
+// TODO: remove
+inline int min( int x, int y ) 
+template<class T>
+inline T min( T x, T y )
+{
+	if ( x < y )
+		return x;
+	return y;
+}
+
+template<class T>
+inline T max( T x, T y )
+{
+	if ( x < y )
+		return y;
+	return x;
+}
+*/
+
+// TODO: good idea? bad idea?
+#undef byte
+#define byte byte_
+typedef unsigned char byte;
+
+// deprecated
+#define BLARGG_CHECK_ALLOC CHECK_ALLOC
+#define BLARGG_RETURN_ERR RETURN_ERR
+
+// BLARGG_SOURCE_BEGIN: If defined, #included, allowing redefition of dprintf and check
+#ifdef BLARGG_SOURCE_BEGIN
+	#include BLARGG_SOURCE_BEGIN
+#endif
+
+#endif
diff --git a/nSide/higan/sfc-balanced/dsp/dsp.cpp b/nSide/higan/sfc-balanced/dsp/dsp.cpp
new file mode 100644
index 0000000..f1da174
--- /dev/null
+++ b/nSide/higan/sfc-balanced/dsp/dsp.cpp
@@ -0,0 +1,58 @@
+#include <sfc-balanced/sfc.hpp>
+
+namespace SuperFamicom {
+
+DSP dsp;
+
+#include "serialization.cpp"
+#include "SPC_DSP.cpp"
+
+DSP::DSP() {
+}
+
+auto DSP::step(uint clocks) -> void {
+  clock += clocks;
+}
+
+auto DSP::main() -> void {
+  spc_dsp.run(1);
+  step(3 * 8);
+
+  int count = spc_dsp.sample_count();
+  if(count > 0) {
+    for(uint n = 0; n < count; n += 2) stream->sample(samplebuffer[n + 0] / 32768.0, samplebuffer[n + 1] / 32768.0);
+    spc_dsp.set_output(samplebuffer, 8192);
+  }
+}
+
+auto DSP::mute() -> bool {
+  return spc_dsp.mute();
+}
+
+auto DSP::read(uint8 addr) -> uint8 {
+  return spc_dsp.read(addr);
+}
+
+auto DSP::write(uint8 addr, uint8 data) -> void {
+  spc_dsp.write(addr, data);
+}
+
+auto DSP::load(Markup::Node node) -> bool {
+  return true;
+}
+
+auto DSP::power() -> void {
+  spc_dsp.init(smp.apuram);
+  spc_dsp.reset();
+  spc_dsp.set_output(samplebuffer, 8192);
+}
+
+auto DSP::reset() -> void {
+  clock = 0;
+  stream = Emulator::audio.createStream(2, 32040.0);
+
+  spc_dsp.soft_reset();
+  spc_dsp.set_output(samplebuffer, 8192);
+}
+
+}
diff --git a/nSide/higan/sfc-balanced/dsp/dsp.hpp b/nSide/higan/sfc-balanced/dsp/dsp.hpp
new file mode 100644
index 0000000..48acb01
--- /dev/null
+++ b/nSide/higan/sfc-balanced/dsp/dsp.hpp
@@ -0,0 +1,28 @@
+#include "SPC_DSP.h"
+
+struct DSP {
+  shared_pointer<Emulator::Stream> stream;
+
+  DSP();
+
+  alwaysinline auto step(uint clocks) -> void;
+
+  auto mute() -> bool;
+  auto read(uint8 addr) -> uint8;
+  auto write(uint8 addr, uint8 data) -> void;
+
+  auto main() -> void;
+  auto load(Markup::Node) -> bool;
+  auto power() -> void;
+  auto reset() -> void;
+
+  auto serialize(serializer&) -> void;
+
+  int64 clock;
+
+private:
+  SPC_DSP spc_dsp;
+  int16_t samplebuffer[8192];
+};
+
+extern DSP dsp;
diff --git a/nSide/higan/sfc-balanced/dsp/serialization.cpp b/nSide/higan/sfc-balanced/dsp/serialization.cpp
new file mode 100644
index 0000000..01b6a53
--- /dev/null
+++ b/nSide/higan/sfc-balanced/dsp/serialization.cpp
@@ -0,0 +1,27 @@
+static auto dsp_state_save(unsigned char** out, void* in, size_t size) -> void {
+  memcpy(*out, in, size);
+  *out += size;
+}
+
+static auto dsp_state_load(unsigned char** in, void* out, size_t size) -> void {
+  memcpy(out, *in, size);
+  *in += size;
+}
+
+auto DSP::serialize(serializer &s) -> void {
+  s.integer(clock);
+  s.array(samplebuffer);
+
+  unsigned char state[SPC_DSP::state_size];
+  unsigned char *p = state;
+  memset(&state, 0, SPC_DSP::state_size);
+  if(s.mode() == serializer::Save) {
+    spc_dsp.copy_state(&p, dsp_state_save);
+    s.array(state);
+  } else if(s.mode() == serializer::Load) {
+    s.array(state);
+    spc_dsp.copy_state(&p, dsp_state_load);
+  } else {
+    s.array(state);
+  }
+}
diff --git a/nSide/higan/sfc-balanced/expansion/21fx/21fx.cpp b/nSide/higan/sfc-balanced/expansion/21fx/21fx.cpp
new file mode 100644
index 0000000..0093cd7
--- /dev/null
+++ b/nSide/higan/sfc-balanced/expansion/21fx/21fx.cpp
@@ -0,0 +1,145 @@
+#include <sfc-balanced/sfc.hpp>
+
+namespace SuperFamicom {
+
+S21FX::S21FX() {
+  create(S21FX::Enter, 10'000'000);
+
+  resetVector.byte(0) = bus.read(0xfffc, 0x00);
+  resetVector.byte(1) = bus.read(0xfffd, 0x00);
+
+  bus.map({&S21FX::read, this}, {&S21FX::write, this}, "00-3f,80-bf:2184-21ff");
+  bus.map({&S21FX::read, this}, {&S21FX::write, this}, "00:fffc-fffd");
+
+  booted = false;
+
+  for(auto& byte : ram) byte = 0xdb;  //stp
+  ram[0] = 0x6c;  //jmp ($fffc)
+  ram[1] = 0xfc;
+  ram[2] = 0xff;
+
+  if(auto buffer = file::read({interface->path(ID::System), "21fx.rom"})) {
+    memory::copy(ram, sizeof(ram), buffer.data(), buffer.size());
+  }
+
+  string filename{interface->path(ID::SuperFamicom), "21fx.so"};
+  if(link.openAbsolute(filename)) {
+    linkInit = link.sym("fx_init");
+    linkMain = link.sym("fx_main");
+  }
+}
+
+S21FX::~S21FX() {
+  scheduler.remove(*this);
+  bus.unmap("00-3f,80-bf:2184-21ff");
+  bus.unmap("00:fffc-fffd");
+
+  //note: this is an awful hack ...
+  //since the bus maps are lambdas, we can't safely restore the original reset vector handler
+  //as such, we install a basic read-only lambda that simply returns the known reset vector
+  //the downside is that if 00:fffc-fffd were anything but ROM; it will now only act as ROM
+  //given that this is the only device that hooks the reset vector like this,
+  //it's not worth the added complexity to support some form of reversible bus mapping hooks
+  uint vector = resetVector;
+  bus.map([vector](uint24 addr, uint8) -> uint8 {
+    return vector >> addr * 8;
+  }, [](uint24, uint8) -> void {
+  }, "00:fffc-fffd", 2);
+
+  if(link.open()) link.close();
+  linkInit.reset();
+  linkMain.reset();
+}
+
+auto S21FX::Enter() -> void {
+  while(true) scheduler.synchronize(), peripherals.expansionPort->main();
+}
+
+auto S21FX::step(uint clocks) -> void {
+  Thread::step(clocks);
+  synchronize(cpu);
+}
+
+auto S21FX::main() -> void {
+  if(linkInit) linkInit(
+    {&S21FX::quit, this},
+    {&S21FX::usleep, this},
+    {&S21FX::readable, this},
+    {&S21FX::writable, this},
+    {&S21FX::read, this},
+    {&S21FX::write, this}
+  );
+  if(linkMain) linkMain({});
+  while(true) step(10'000'000);
+}
+
+auto S21FX::read(uint24 addr, uint8 data) -> uint8 {
+  addr &= 0x40ffff;
+
+  if(addr == 0xfffc) return booted ? resetVector.byte(0) : (uint8)0x84;
+  if(addr == 0xfffd) return booted ? resetVector.byte(1) : (booted = true, (uint8)0x21);
+
+  if(addr >= 0x2184 && addr <= 0x21fd) return ram[addr - 0x2184];
+
+  if(addr == 0x21fe) return !link.open() ? 0 : (
+    (linkBuffer.size() >    0) << 7  //1 = readable
+  | (snesBuffer.size() < 1024) << 6  //1 = writable
+  | (link.open())              << 5  //1 = connected
+  );
+
+  if(addr == 0x21ff) {
+    if(linkBuffer.size() > 0) {
+      return linkBuffer.takeLeft();
+    }
+  }
+
+  return data;
+}
+
+auto S21FX::write(uint24 addr, uint8 data) -> void {
+  addr &= 0x40ffff;
+
+  if(addr == 0x21ff) {
+    if(snesBuffer.size() < 1024) {
+      snesBuffer.append(data);
+    }
+  }
+}
+
+auto S21FX::quit() -> bool {
+  step(1);
+  return false;
+}
+
+auto S21FX::usleep(uint microseconds) -> void {
+  step(10 * microseconds);
+}
+
+auto S21FX::readable() -> bool {
+  step(1);
+  return snesBuffer.size() > 0;
+}
+
+auto S21FX::writable() -> bool {
+  step(1);
+  return linkBuffer.size() < 1024;
+}
+
+//SNES -> Link
+auto S21FX::read() -> uint8 {
+  step(1);
+  if(snesBuffer.size() > 0) {
+    return snesBuffer.takeLeft();
+  }
+  return 0x00;
+}
+
+//Link -> SNES
+auto S21FX::write(uint8 data) -> void {
+  step(1);
+  if(linkBuffer.size() < 1024) {
+    linkBuffer.append(data);
+  }
+}
+
+}
diff --git a/nSide/higan/sfc-balanced/expansion/21fx/21fx.hpp b/nSide/higan/sfc-balanced/expansion/21fx/21fx.hpp
new file mode 100644
index 0000000..50eb7d8
--- /dev/null
+++ b/nSide/higan/sfc-balanced/expansion/21fx/21fx.hpp
@@ -0,0 +1,37 @@
+struct S21FX : Expansion {
+  S21FX();
+  ~S21FX();
+
+  static auto Enter() -> void;
+  auto step(uint clocks) -> void;
+  auto main() -> void;
+
+  auto read(uint24 addr, uint8 data) -> uint8;
+  auto write(uint24 addr, uint8 data) -> void;
+
+private:
+  auto quit() -> bool;
+  auto usleep(uint) -> void;
+  auto readable() -> bool;
+  auto writable() -> bool;
+  auto read() -> uint8;
+  auto write(uint8) -> void;
+
+  bool booted = false;
+  uint16 resetVector;
+  uint8 ram[122];
+
+  nall::library link;
+  function<void (
+    function<bool ()>,      //quit
+    function<void (uint)>,  //usleep
+    function<bool ()>,      //readable
+    function<bool ()>,      //writable
+    function<uint8 ()>,     //read
+    function<void (uint8)>  //write
+  )> linkInit;
+  function<void (string_vector)> linkMain;
+
+  vector<uint8> snesBuffer;  //SNES -> Link
+  vector<uint8> linkBuffer;  //Link -> SNES
+};
diff --git a/nSide/higan/sfc-balanced/expansion/expansion.cpp b/nSide/higan/sfc-balanced/expansion/expansion.cpp
new file mode 100644
index 0000000..cdd22f3
--- /dev/null
+++ b/nSide/higan/sfc-balanced/expansion/expansion.cpp
@@ -0,0 +1,18 @@
+#include <sfc-balanced/sfc.hpp>
+
+namespace SuperFamicom {
+
+Expansion::Expansion() {
+  if(!handle()) create(Expansion::Enter, 1);
+}
+
+auto Expansion::Enter() -> void {
+  while(true) scheduler.synchronize(), peripherals.expansionPort->main();
+}
+
+auto Expansion::main() -> void {
+  step(1);
+  synchronize(cpu);
+}
+
+}
diff --git a/nSide/higan/sfc-balanced/expansion/expansion.hpp b/nSide/higan/sfc-balanced/expansion/expansion.hpp
new file mode 100644
index 0000000..a7a0ff9
--- /dev/null
+++ b/nSide/higan/sfc-balanced/expansion/expansion.hpp
@@ -0,0 +1,8 @@
+struct Expansion : Thread {
+  Expansion();
+  static auto Enter() -> void;
+  virtual auto main() -> void;
+};
+
+#include <sfc-balanced/expansion/satellaview/satellaview.hpp>
+#include <sfc-balanced/expansion/21fx/21fx.hpp>
diff --git a/nSide/higan/sfc-balanced/expansion/satellaview/satellaview.cpp b/nSide/higan/sfc-balanced/expansion/satellaview/satellaview.cpp
new file mode 100644
index 0000000..a3d168e
--- /dev/null
+++ b/nSide/higan/sfc-balanced/expansion/satellaview/satellaview.cpp
@@ -0,0 +1,129 @@
+#include <sfc-balanced/sfc.hpp>
+
+namespace SuperFamicom {
+
+Satellaview::Satellaview() {
+  bus.map({&Satellaview::read, this}, {&Satellaview::write, this}, "00-3f,80-bf:2188-219f");
+  memory::fill(&regs, sizeof regs);
+}
+
+Satellaview::~Satellaview() {
+  bus.unmap("00-3f,80-bf:2188-219f");
+}
+
+auto Satellaview::read(uint24 addr, uint8 data) -> uint8 {
+  switch(addr &= 0xffff) {
+  case 0x2188: return regs.r2188;
+  case 0x2189: return regs.r2189;
+  case 0x218a: return regs.r218a;
+  case 0x218c: return regs.r218c;
+  case 0x218e: return regs.r218e;
+  case 0x218f: return regs.r218f;
+  case 0x2190: return regs.r2190;
+
+  case 0x2192: {
+    uint counter = regs.rtcCounter++;
+    if(regs.rtcCounter >= 18) regs.rtcCounter = 0;
+
+    if(counter == 0) {
+      time_t rawtime;
+      time(&rawtime);
+      tm* t = localtime(&rawtime);
+
+      regs.rtcHour   = t->tm_hour;
+      regs.rtcMinute = t->tm_min;
+      regs.rtcSecond = t->tm_sec;
+    }
+
+    switch(counter) {
+    case  0: return 0x00;  //???
+    case  1: return 0x00;  //???
+    case  2: return 0x00;  //???
+    case  3: return 0x00;  //???
+    case  4: return 0x00;  //???
+    case  5: return 0x01;
+    case  6: return 0x01;
+    case  7: return 0x00;
+    case  8: return 0x00;
+    case  9: return 0x00;
+    case 10: return regs.rtcSecond;
+    case 11: return regs.rtcMinute;
+    case 12: return regs.rtcHour;
+    case 13: return 0x00;  //???
+    case 14: return 0x00;  //???
+    case 15: return 0x00;  //???
+    case 16: return 0x00;  //???
+    case 17: return 0x00;  //???
+    }
+  } break;
+
+  case 0x2193: return regs.r2193 & ~0x0c;
+  case 0x2194: return regs.r2194;
+  case 0x2196: return regs.r2196;
+  case 0x2197: return regs.r2197;
+  case 0x2199: return regs.r2199;
+  }
+
+  return data;
+}
+
+auto Satellaview::write(uint24 addr, uint8 data) -> void {
+  switch(addr &= 0xffff) {
+  case 0x2188: {
+    regs.r2188 = data;
+  } break;
+
+  case 0x2189: {
+    regs.r2189 = data;
+  } break;
+
+  case 0x218a: {
+    regs.r218a = data;
+  } break;
+
+  case 0x218b: {
+    regs.r218b = data;
+  } break;
+
+  case 0x218c: {
+    regs.r218c = data;
+  } break;
+
+  case 0x218e: {
+    regs.r218e = data;
+  } break;
+
+  case 0x218f: {
+    regs.r218e >>= 1;
+    regs.r218e = regs.r218f - regs.r218e;
+    regs.r218f >>= 1;
+  } break;
+
+  case 0x2191: {
+    regs.r2191 = data;
+    regs.rtcCounter = 0;
+  } break;
+
+  case 0x2192: {
+    regs.r2190 = 0x80;
+  } break;
+
+  case 0x2193: {
+    regs.r2193 = data;
+  } break;
+
+  case 0x2194: {
+    regs.r2194 = data;
+  } break;
+
+  case 0x2197: {
+    regs.r2197 = data;
+  } break;
+
+  case 0x2199: {
+    regs.r2199 = data;
+  } break;
+  }
+}
+
+}
diff --git a/nSide/higan/sfc-balanced/expansion/satellaview/satellaview.hpp b/nSide/higan/sfc-balanced/expansion/satellaview/satellaview.hpp
new file mode 100644
index 0000000..8814be5
--- /dev/null
+++ b/nSide/higan/sfc-balanced/expansion/satellaview/satellaview.hpp
@@ -0,0 +1,22 @@
+struct Satellaview : Expansion {
+  Satellaview();
+  ~Satellaview();
+
+  auto read(uint24 addr, uint8 data) -> uint8;
+  auto write(uint24 addr, uint8 data) -> void;
+
+private:
+  struct {
+    uint8 r2188, r2189, r218a, r218b;
+    uint8 r218c, r218d, r218e, r218f;
+    uint8 r2190, r2191, r2192, r2193;
+    uint8 r2194, r2195, r2196, r2197;
+    uint8 r2198, r2199, r219a, r219b;
+    uint8 r219c, r219d, r219e, r219f;
+
+    uint8 rtcCounter;
+    uint8 rtcHour;
+    uint8 rtcMinute;
+    uint8 rtcSecond;
+  } regs;
+};
diff --git a/nSide/higan/sfc-balanced/interface/interface.cpp b/nSide/higan/sfc-balanced/interface/interface.cpp
new file mode 100644
index 0000000..90f4570
--- /dev/null
+++ b/nSide/higan/sfc-balanced/interface/interface.cpp
@@ -0,0 +1,331 @@
+#include <sfc-balanced/sfc.hpp>
+
+namespace SuperFamicom {
+
+Interface* interface = nullptr;
+Settings settings;
+Debugger debugger;
+
+Interface::Interface() {
+  interface = this;
+  system.init();
+
+  information.preAlpha     = false;
+  information.manufacturer = "Nintendo";
+  information.name         = "Super Famicom";
+  information.overscan     = true;
+  information.resettable   = true;
+
+  information.capability.states = true;
+  information.capability.cheats = true;
+
+  media.append({ID::SuperFamicom, "Super Famicom", "sfc", Domain::Home});
+
+  Port controllerPort1{ID::Port::Controller1, "Controller Port 1", PlugAndPlay};
+  Port controllerPort2{ID::Port::Controller2, "Controller Port 2", PlugAndPlay};
+  Port expansionPort{ID::Port::Expansion, "Expansion Port", PlugAndPlay};
+
+  { Device device{ID::Device::None, "None"};
+    controllerPort1.devices.append(device);
+    controllerPort2.devices.append(device);
+    expansionPort.devices.append(device);
+  }
+
+  { Device device{ID::Device::Gamepad, "Gamepad"};
+    device.inputs.append({0, "Up"    });
+    device.inputs.append({0, "Down"  });
+    device.inputs.append({0, "Left"  });
+    device.inputs.append({0, "Right" });
+    device.inputs.append({0, "B"     });
+    device.inputs.append({0, "A"     });
+    device.inputs.append({0, "Y"     });
+    device.inputs.append({0, "X"     });
+    device.inputs.append({0, "L"     });
+    device.inputs.append({0, "R"     });
+    device.inputs.append({0, "Select"});
+    device.inputs.append({0, "Start" });
+    controllerPort1.devices.append(device);
+    controllerPort2.devices.append(device);
+  }
+
+  { Device device{ID::Device::Mouse, "Mouse"};
+    device.inputs.append({1, "X-axis"});
+    device.inputs.append({1, "Y-axis"});
+    device.inputs.append({0, "Left"  });
+    device.inputs.append({0, "Right" });
+    controllerPort1.devices.append(device);
+    controllerPort2.devices.append(device);
+  }
+
+  { Device device{ID::Device::SuperMultitap, "Super Multitap"};
+    for(uint p = 2; p <= 5; p++) {
+      device.inputs.append({0, {"Port ", p, " - ", "Up"    }});
+      device.inputs.append({0, {"Port ", p, " - ", "Down"  }});
+      device.inputs.append({0, {"Port ", p, " - ", "Left"  }});
+      device.inputs.append({0, {"Port ", p, " - ", "Right" }});
+      device.inputs.append({0, {"Port ", p, " - ", "B"     }});
+      device.inputs.append({0, {"Port ", p, " - ", "A"     }});
+      device.inputs.append({0, {"Port ", p, " - ", "Y"     }});
+      device.inputs.append({0, {"Port ", p, " - ", "X"     }});
+      device.inputs.append({0, {"Port ", p, " - ", "L"     }});
+      device.inputs.append({0, {"Port ", p, " - ", "R"     }});
+      device.inputs.append({0, {"Port ", p, " - ", "Select"}});
+      device.inputs.append({0, {"Port ", p, " - ", "Start" }});
+    }
+    controllerPort2.devices.append(device);
+  }
+
+  { Device device{ID::Device::SuperScope, "Super Scope"};
+    device.inputs.append({1, "X-axis" });
+    device.inputs.append({1, "Y-axis" });
+    device.inputs.append({0, "Trigger"});
+    device.inputs.append({0, "Cursor" });
+    device.inputs.append({0, "Turbo"  });
+    device.inputs.append({0, "Pause"  });
+    controllerPort2.devices.append(device);
+  }
+
+  { Device device{ID::Device::Justifier, "Justifier"};
+    device.inputs.append({1, "X-axis" });
+    device.inputs.append({1, "Y-axis" });
+    device.inputs.append({0, "Trigger"});
+    device.inputs.append({0, "Start"  });
+    controllerPort2.devices.append(device);
+  }
+
+  { Device device{ID::Device::Justifiers, "Justifiers"};
+    device.inputs.append({1, "Port 1 - X-axis" });
+    device.inputs.append({1, "Port 1 - Y-axis" });
+    device.inputs.append({0, "Port 1 - Trigger"});
+    device.inputs.append({0, "Port 1 - Start"  });
+    device.inputs.append({1, "Port 2 - X-axis" });
+    device.inputs.append({1, "Port 2 - Y-axis" });
+    device.inputs.append({0, "Port 2 - Trigger"});
+    device.inputs.append({0, "Port 2 - Start"  });
+    controllerPort2.devices.append(device);
+  }
+
+  { Device device{ID::Device::Satellaview, "Satellaview"};
+    expansionPort.devices.append(device);
+  }
+
+  { Device device{ID::Device::S21FX, "21fx"};
+    expansionPort.devices.append(device);
+  }
+
+  ports.append(move(controllerPort1));
+  ports.append(move(controllerPort2));
+  ports.append(move(expansionPort));
+}
+
+auto Interface::manifest() -> string {
+  return cartridge.manifest();
+}
+
+auto Interface::title() -> string {
+  return cartridge.title();
+}
+
+auto Interface::videoSize() -> VideoSize {
+  return {512, 480};
+}
+
+auto Interface::videoSize(uint width, uint height, bool arc) -> VideoSize {
+  double w = 256;
+  if(arc) {
+    double squarePixelRate = system.region() == System::Region::NTSC
+    ? 135.0 / 22.0 * 1'000'000.0
+    : 7'375'000.0;
+    //note: PAL SNES multiples colorburst by 4/5 to make clock rate
+    w *= squarePixelRate / (system.colorburst() * 6.0 / (2.0 + 2.0));
+  }
+  uint h = 240;
+  uint m = min((uint)(width / w), height / h);
+  return {(uint)(w * m), h * m};
+}
+
+auto Interface::videoFrequency() -> double {
+  switch(system.region()) { default:
+  case System::Region::NTSC: return (system.colorburst() * 6.0) / (262.0 * 1364.0 - 4.0);
+  case System::Region::PAL:  return (system.colorburst() * 6.0) / (312.0 * 1364.0);
+  }
+}
+
+auto Interface::videoColors() -> uint32 {
+  return 1 << 19;
+}
+
+auto Interface::videoColor(uint32 color) -> uint64 {
+  uint r = color.bits( 0, 4);
+  uint g = color.bits( 5, 9);
+  uint b = color.bits(10,14);
+  uint l = color.bits(15,18);
+
+  double L = (1.0 + l) / 16.0 * (l ? 1.0 : 0.5);
+  uint64 R = L * image::normalize(r, 5, 16);
+  uint64 G = L * image::normalize(g, 5, 16);
+  uint64 B = L * image::normalize(b, 5, 16);
+
+  if(settings.colorEmulation) {
+    static const uint8 gammaRamp[32] = {
+      0x00, 0x01, 0x03, 0x06, 0x0a, 0x0f, 0x15, 0x1c,
+      0x24, 0x2d, 0x37, 0x42, 0x4e, 0x5b, 0x69, 0x78,
+      0x88, 0x90, 0x98, 0xa0, 0xa8, 0xb0, 0xb8, 0xc0,
+      0xc8, 0xd0, 0xd8, 0xe0, 0xe8, 0xf0, 0xf8, 0xff,
+    };
+    R = L * gammaRamp[r] * 0x0101;
+    G = L * gammaRamp[g] * 0x0101;
+    B = L * gammaRamp[b] * 0x0101;
+  }
+
+  return R << 32 | G << 16 | B << 0;
+}
+
+auto Interface::audioFrequency() -> double {
+  return 32040.0;
+}
+
+auto Interface::loaded() -> bool {
+  return system.loaded();
+}
+
+auto Interface::sha256() -> string {
+  return cartridge.sha256();
+}
+
+auto Interface::load(uint id) -> bool {
+  if(id == ID::SuperFamicom) return system.load();
+  if(id == ID::BSMemory) return cartridge.loadBSMemory();
+  if(id == ID::SufamiTurboA) return cartridge.loadSufamiTurboA();
+  if(id == ID::SufamiTurboB) return cartridge.loadSufamiTurboB();
+  return false;
+}
+
+auto Interface::save() -> void {
+  system.save();
+}
+
+auto Interface::unload() -> void {
+  save();
+  system.unload();
+}
+
+auto Interface::connect(uint port, uint device) -> void {
+  SuperFamicom::peripherals.connect(port, device);
+}
+
+auto Interface::power() -> void {
+  system.power();
+}
+
+auto Interface::reset() -> void {
+  system.reset();
+}
+
+auto Interface::run() -> void {
+  system.run();
+}
+
+auto Interface::rtc() -> bool {
+  if(cartridge.has.EpsonRTC) return true;
+  if(cartridge.has.SharpRTC) return true;
+  return false;
+}
+
+auto Interface::rtcsync() -> void {
+  if(cartridge.has.EpsonRTC) epsonrtc.sync();
+  if(cartridge.has.SharpRTC) sharprtc.sync();
+}
+
+auto Interface::serialize() -> serializer {
+  system.runToSave();
+  return system.serialize();
+}
+
+auto Interface::unserialize(serializer& s) -> bool {
+  return system.unserialize(s);
+}
+
+auto Interface::cheatSet(const string_vector& list) -> void {
+  cheat.reset();
+  #if defined(SFC_SUPERGAMEBOY)
+  if(cartridge.has.ICD2) return GameBoy::cheat.assign(list);
+  #endif
+  cheat.assign(list);
+}
+
+auto Interface::cap(const string& name) -> bool {
+  if(name == "Blur Emulation") return true;
+  if(name == "Color Emulation") return true;
+  if(name == "Scanline Emulation") return true;
+  return false;
+}
+
+auto Interface::get(const string& name) -> any {
+  if(name == "Blur Emulation") return settings.blurEmulation;
+  if(name == "Color Emulation") return settings.colorEmulation;
+  if(name == "Scanline Emulation") return settings.scanlineEmulation;
+  return {};
+}
+
+auto Interface::set(const string& name, const any& value) -> bool {
+  if(name == "Blur Emulation" && value.is<bool>()) {
+    settings.blurEmulation = value.get<bool>();
+    system.configureVideoEffects();
+    return true;
+  }
+  if(name == "Color Emulation" && value.is<bool>()) {
+    settings.colorEmulation = value.get<bool>();
+    system.configureVideoPalette();
+    return true;
+  }
+  if(name == "Scanline Emulation" && value.is<bool>()) return settings.scanlineEmulation = value.get<bool>(), true;
+  return false;
+}
+
+auto Interface::exportMemory() -> void {
+  string pathname = {path(cartridge.pathID()), "debug/"};
+  directory::create(pathname);
+
+  if(auto fp = interface->open(cartridge.pathID(), "debug/work.ram", File::Write)) fp->write(cpu.wram, 128 * 1024);
+  if(cartridge.ram.size()) if(auto fp = interface->open(cartridge.pathID(), "debug/program-save.ram", File::Write)) {
+    fp->write(cartridge.ram.data(), cartridge.ram.size());
+  }
+  if(cartridge.has.MCC) if(auto fp = interface->open(cartridge.pathID(), "debug/mcc.ram", File::Write)) {
+    fp->write(mcc.ram.data(), mcc.ram.size());
+  }
+  if(cartridge.has.Event) if(auto fp = interface->open(cartridge.pathID(), "debug/event.ram", File::Write)) {
+    fp->write(event.ram.data(), event.ram.size());
+  }
+  if(cartridge.has.SA1) {
+    if(auto fp = interface->open(cartridge.pathID(), "debug/sa1.internal.ram", File::Write)) {
+      fp->write(sa1.iram.data(), sa1.iram.size());
+    }
+    if(auto fp = interface->open(cartridge.pathID(), "debug/sa1.bitmap-work.ram", File::Write)) {
+      fp->write(sa1.bwram.data(), sa1.bwram.size());
+    }
+  }
+  if(cartridge.has.SuperFX) if(auto fp = interface->open(cartridge.pathID(), "debug/superfx.ram", File::Write)) {
+    fp->write(superfx.ram.data(), superfx.ram.size());
+  }
+  if(cartridge.has.SPC7110) if(auto fp = interface->open(cartridge.pathID(), "debug/spc7110.ram", File::Write)) {
+    fp->write(spc7110.ram.data(), spc7110.ram.size());
+  }
+  if(cartridge.has.SDD1) if(auto fp = interface->open(cartridge.pathID(), "debug/sdd1.ram", File::Write)) {
+    fp->write(sdd1.ram.data(), sdd1.ram.size());
+  }
+  if(cartridge.has.OBC1) if(auto fp = interface->open(cartridge.pathID(), "debug/obc1.ram", File::Write)) {
+    fp->write(obc1.ram.data(), obc1.ram.size());
+  }
+
+  if(cartridge.has.SufamiTurboSlots) {
+    if(auto fp = interface->open(cartridge.pathID(), "debug/sufamiturbo.slota.ram", File::Write)) {
+      fp->write(sufamiturboA.ram.data(), sufamiturboA.ram.size());
+    }
+    if(auto fp = interface->open(cartridge.pathID(), "debug/sufamiturbo.slotb.ram", File::Write)) {
+      fp->write(sufamiturboB.ram.data(), sufamiturboB.ram.size());
+    }
+  }
+}
+
+}
diff --git a/nSide/higan/sfc-balanced/interface/interface.hpp b/nSide/higan/sfc-balanced/interface/interface.hpp
new file mode 100644
index 0000000..84a8731
--- /dev/null
+++ b/nSide/higan/sfc-balanced/interface/interface.hpp
@@ -0,0 +1,92 @@
+#include <sfc-balanced/debugger.hpp>
+
+namespace SuperFamicom {
+
+struct ID {
+  enum : uint {
+    System,
+    SuperFamicom,
+    GameBoy,
+    BSMemory,
+    SufamiTurboA,
+    SufamiTurboB,
+  };
+
+  struct Port { enum : uint {
+    Controller1,
+    Controller2,
+    Expansion,
+  };};
+
+  struct Device { enum : uint {
+    None,
+    Gamepad,
+    Mouse,
+    SuperMultitap,
+    SuperScope,
+    Justifier,
+    Justifiers,
+
+    Satellaview,
+    S21FX,
+  };};
+};
+
+struct Interface : Emulator::Interface {
+  using Emulator::Interface::load;
+
+  Interface();
+
+  auto manifest() -> string override;
+  auto title() -> string override;
+
+  auto videoSize() -> VideoSize override;
+  auto videoSize(uint width, uint height, bool arc) -> VideoSize override;
+  auto videoFrequency() -> double override;
+  auto videoColors() -> uint32 override;
+  auto videoColor(uint32 color) -> uint64 override;
+
+  auto audioFrequency() -> double override;
+
+  auto loaded() -> bool override;
+  auto sha256() -> string override;
+  auto load(uint id) -> bool override;
+  auto save() -> void override;
+  auto unload() -> void override;
+
+  auto connect(uint port, uint device) -> void override;
+  auto power() -> void override;
+  auto reset() -> void override;
+  auto run() -> void override;
+
+  auto rtc() -> bool override;
+  auto rtcsync() -> void override;
+
+  auto serialize() -> serializer override;
+  auto unserialize(serializer&) -> bool override;
+
+  auto cheatSet(const string_vector&) -> void override;
+
+  auto cap(const string& name) -> bool override;
+  auto get(const string& name) -> any override;
+  auto set(const string& name, const any& value) -> bool override;
+
+  //debugger functions
+  auto exportMemory() -> void override;
+};
+
+struct Settings {
+  bool blurEmulation = true;
+  bool colorEmulation = true;
+  bool scanlineEmulation = true;
+
+  uint controllerPort1 = 0;
+  uint controllerPort2 = 0;
+  uint expansionPort = 0;
+  bool random = true;
+};
+
+extern Interface* interface;
+extern Settings settings;
+
+}
diff --git a/nSide/higan/sfc-balanced/memory/memory-inline.hpp b/nSide/higan/sfc-balanced/memory/memory-inline.hpp
new file mode 100644
index 0000000..babbd5d
--- /dev/null
+++ b/nSide/higan/sfc-balanced/memory/memory-inline.hpp
@@ -0,0 +1,79 @@
+//Memory
+
+auto Memory::size() const -> uint { return 0; }
+
+//StaticRAM
+
+StaticRAM::StaticRAM(uint size) : _size(size) { _data = new uint8[_size]; }
+StaticRAM::~StaticRAM() { delete[] _data; }
+
+auto StaticRAM::data() -> uint8* { return _data; }
+auto StaticRAM::size() const -> uint { return _size; }
+
+auto StaticRAM::read(uint24 addr, uint8) -> uint8 { return _data[addr]; }
+auto StaticRAM::write(uint24 addr, uint8 data) -> void { _data[addr] = data; }
+auto StaticRAM::operator[](uint24 addr) -> uint8& { return _data[addr]; }
+auto StaticRAM::operator[](uint24 addr) const -> const uint8& { return _data[addr]; }
+
+//MappedRAM
+
+auto MappedRAM::reset() -> void {
+  delete[] _data;
+  _data = nullptr;
+  _size = 0;
+  _writeProtect = false;
+}
+
+auto MappedRAM::allocate(uint size) -> void {
+  reset();
+  _data = new uint8[_size = size];
+  memory::fill(_data, _size, 0xff);
+}
+
+auto MappedRAM::writeProtect(bool writeProtect) -> void { _writeProtect = writeProtect; }
+auto MappedRAM::data() -> uint8* { return _data; }
+auto MappedRAM::size() const -> uint { return _size; }
+
+auto MappedRAM::read(uint24 addr, uint8) -> uint8 { return _data[addr]; }
+auto MappedRAM::write(uint24 addr, uint8 data) -> void { if(!_writeProtect) _data[addr] = data; }
+auto MappedRAM::operator[](uint24 addr) const -> const uint8& { return _data[addr]; }
+
+//Bus
+
+auto Bus::mirror(uint addr, uint size) -> uint {
+  if(size == 0) return 0;
+  uint base = 0;
+  uint mask = 1 << 23;
+  while(addr >= size) {
+    while(!(addr & mask)) mask >>= 1;
+    addr -= mask;
+    if(size > mask) {
+      size -= mask;
+      base += mask;
+    }
+    mask >>= 1;
+  }
+  return base + addr;
+}
+
+auto Bus::reduce(uint addr, uint mask) -> uint {
+  while(mask) {
+    uint bits = (mask & -mask) - 1;
+    addr = ((addr >> 1) & ~bits) | (addr & bits);
+    mask = (mask & (mask - 1)) >> 1;
+  }
+  return addr;
+}
+
+auto Bus::read(uint24 addr, uint8 data) -> uint8 {
+  data = reader[lookup[addr]](target[addr], data);
+  if(cheat) {
+    if(!(addr & 0x40e000)) addr = 0x7e0000 | (addr & 0x1fff);  //de-mirror WRAM
+    if(auto result = cheat.find<1>(addr, data)) return result();
+  }
+  return data;
+}
+
+auto Bus::write(uint24 addr, uint8 data) -> void {
+  return writer[lookup[addr]](target[addr], data);
+}
diff --git a/nSide/higan/sfc-balanced/memory/memory.cpp b/nSide/higan/sfc-balanced/memory/memory.cpp
new file mode 100644
index 0000000..483866e
--- /dev/null
+++ b/nSide/higan/sfc-balanced/memory/memory.cpp
@@ -0,0 +1,102 @@
+#include <sfc-balanced/sfc.hpp>
+
+namespace SuperFamicom {
+
+Bus bus;
+
+Bus::~Bus() {
+  if(lookup) delete[] lookup;
+  if(target) delete[] target;
+}
+
+auto Bus::reset() -> void {
+  for(auto id : range(256)) {
+    reader[id].reset();
+    writer[id].reset();
+    counter[id] = 0;
+  }
+
+  if(lookup) delete[] lookup;
+  if(target) delete[] target;
+
+  lookup = new uint8 [16 * 1024 * 1024]();
+  target = new uint32[16 * 1024 * 1024]();
+
+  reader[0] = [](uint24, uint8 data) -> uint8 { return data; };
+  writer[0] = [](uint24, uint8) -> void {};
+}
+
+auto Bus::map(
+  const function<uint8 (uint24, uint8)>& read,
+  const function<void (uint24, uint8)>& write,
+  const string& addr, uint size, uint base, uint mask
+) -> void {
+  uint id = 1;
+  while(counter[id]) {
+    if(++id >= 256) return print("SFC error: bus map exhausted\n");
+  }
+
+  reader[id] = read;
+  writer[id] = write;
+
+  auto p = addr.split(":", 1L);
+  auto banks = p(0).split(",");
+  auto addrs = p(1).split(",");
+  for(auto& bank : banks) {
+    for(auto& addr : addrs) {
+      auto bankRange = bank.split("-", 1L);
+      auto addrRange = addr.split("-", 1L);
+      uint bankLo = bankRange(0).hex();
+      uint bankHi = bankRange(1, bankRange(0)).hex();
+      uint addrLo = addrRange(0).hex();
+      uint addrHi = addrRange(1, addrRange(0)).hex();
+
+      for(uint bank = bankLo; bank <= bankHi; bank++) {
+        for(uint addr = addrLo; addr <= addrHi; addr++) {
+          uint pid = lookup[bank << 16 | addr];
+          if(pid && --counter[pid] == 0) {
+            reader[pid].reset();
+            writer[pid].reset();
+          }
+
+          uint offset = reduce(bank << 16 | addr, mask);
+          if(size) offset = base + mirror(offset, size - base);
+          lookup[bank << 16 | addr] = id;
+          target[bank << 16 | addr] = offset;
+          counter[id]++;
+        }
+      }
+    }
+  }
+}
+
+auto Bus::unmap(const string& addr) -> void {
+  auto p = addr.split(":", 1L);
+  auto banks = p(0).split(",");
+  auto addrs = p(1).split(",");
+  for(auto& bank : banks) {
+    for(auto& addr : addrs) {
+      auto bankRange = bank.split("-", 1L);
+      auto addrRange = addr.split("-", 1L);
+      uint bankLo = bankRange(0).hex();
+      uint bankHi = bankRange(1, bankRange(0)).hex();
+      uint addrLo = addrRange(0).hex();
+      uint addrHi = addrRange(1, addrRange(1)).hex();
+
+      for(uint bank = bankLo; bank <= bankHi; bank++) {
+        for(uint addr = addrLo; addr <= addrHi; addr++) {
+          uint pid = lookup[bank << 16 | addr];
+          if(pid && --counter[pid] == 0) {
+            reader[pid].reset();
+            writer[pid].reset();
+          }
+
+          lookup[bank << 16 | addr] = 0;
+          target[bank << 16 | addr] = 0;
+        }
+      }
+    }
+  }
+}
+
+}
diff --git a/nSide/higan/sfc-balanced/memory/memory.hpp b/nSide/higan/sfc-balanced/memory/memory.hpp
new file mode 100644
index 0000000..6dadbd1
--- /dev/null
+++ b/nSide/higan/sfc-balanced/memory/memory.hpp
@@ -0,0 +1,68 @@
+struct Memory {
+  virtual inline auto size() const -> uint;
+  virtual auto read(uint24 addr, uint8 data = 0) -> uint8 = 0;
+  virtual auto write(uint24 addr, uint8 data) -> void = 0;
+};
+
+struct StaticRAM : Memory {
+  inline StaticRAM(uint size);
+  inline ~StaticRAM();
+
+  inline auto data() -> uint8*;
+  inline auto size() const -> uint;
+
+  inline auto read(uint24 addr, uint8 data = 0) -> uint8;
+  inline auto write(uint24 addr, uint8 data) -> void;
+  inline auto operator[](uint24 addr) -> uint8&;
+  inline auto operator[](uint24 addr) const -> const uint8&;
+
+private:
+  uint8* _data = nullptr;
+  uint _size = 0;
+};
+
+struct MappedRAM : Memory {
+  inline auto reset() -> void;
+  inline auto allocate(uint) -> void;
+
+  inline auto writeProtect(bool writeProtect) -> void;
+  inline auto data() -> uint8*;
+  inline auto size() const -> uint;
+
+  inline auto read(uint24 addr, uint8 data = 0) -> uint8;
+  inline auto write(uint24 addr, uint8 data) -> void;
+  inline auto operator[](uint24 addr) const -> const uint8&;
+
+private:
+  uint8* _data = nullptr;
+  uint _size = 0;
+  bool _writeProtect = false;
+};
+
+struct Bus {
+  alwaysinline static auto mirror(uint addr, uint size) -> uint;
+  alwaysinline static auto reduce(uint addr, uint mask) -> uint;
+
+  ~Bus();
+
+  alwaysinline auto read(uint24 addr, uint8 data) -> uint8;
+  alwaysinline auto write(uint24 addr, uint8 data) -> void;
+
+  auto reset() -> void;
+  auto map(
+    const function<uint8 (uint24, uint8)>& read,
+    const function<void (uint24, uint8)>& write,
+    const string& addr, uint size = 0, uint base = 0, uint mask = 0
+  ) -> void;
+  auto unmap(const string& addr) -> void;
+
+private:
+  uint8* lookup = nullptr;
+  uint32* target = nullptr;
+
+  function<auto (uint24, uint8) -> uint8> reader[256];
+  function<auto (uint24, uint8) -> void> writer[256];
+  uint24 counter[256];
+};
+
+extern Bus bus;
diff --git a/nSide/higan/sfc-balanced/ppu/background/background.cpp b/nSide/higan/sfc-balanced/ppu/background/background.cpp
new file mode 100644
index 0000000..e6d9447
--- /dev/null
+++ b/nSide/higan/sfc-balanced/ppu/background/background.cpp
@@ -0,0 +1,33 @@
+auto PPU::Background::getTile(uint x, uint y) -> uint16 {
+  x = (x & ppu.bg_info[id].maskX) >> ppu.bg_info[id].tileWidth;
+  y = (y & ppu.bg_info[id].maskY) >> ppu.bg_info[id].tileHeight;
+
+  uint16 offset = ((y & 0x1f) << 5) + (x & 0x1f);
+  if(x & 0x20) offset += ppu.bg_info[id].screenX;
+  if(y & 0x20) offset += ppu.bg_info[id].screenY;
+
+  const uint16 address = io.screenAddress + offset;
+  return ppu.vram[address];
+}
+
+auto PPU::Background::reset() -> void {
+  io.tiledataAddress = 0x0000;
+  io.screenAddress = 0x0000;
+  io.screenSize = ScreenSize::Size32x32;
+  io.mosaic = 0;
+  io.tileSize = TileSize::Size8x8;
+  io.mode = 0;
+  for(auto& p : io.priority) p = 0;
+  io.aboveEnable = false;
+  io.belowEnable = false;
+  io.hoffset = 0x0000;
+  io.voffset = 0x0000;
+
+  //x = 0;
+  y = 0;
+
+  tile = 0;
+  priority = 0;
+  paletteNumber = 0;
+  paletteIndex = 0;
+}
diff --git a/nSide/higan/sfc-balanced/ppu/background/background.hpp b/nSide/higan/sfc-balanced/ppu/background/background.hpp
new file mode 100644
index 0000000..11423e0
--- /dev/null
+++ b/nSide/higan/sfc-balanced/ppu/background/background.hpp
@@ -0,0 +1,46 @@
+struct Background {
+  Background(uint id) : id(id) {}
+
+  auto reset() -> void;
+
+  auto getTile(uint x, uint y) -> uint16;
+
+  auto serialize(serializer&) -> void;
+
+  struct ID { enum : uint { BG1, BG2, BG3, BG4 }; };
+  const uint id;
+
+  struct Mode { enum : uint { BPP2, BPP4, BPP8, Mode7, Inactive }; };
+  struct ScreenSize { enum : uint { Size32x32, Size32x64, Size64x32, Size64x64 }; };
+  struct TileSize { enum : uint { Size8x8, Size16x16 }; };
+  struct Screen { enum : uint { Above, Below }; };
+
+  struct IO {
+    uint16 tiledataAddress;
+    uint16 screenAddress;
+    uint2 screenSize;
+    uint4 mosaic;
+    bool tileSize;
+
+    uint mode;
+    uint priority[2];
+
+    bool aboveEnable;
+    bool belowEnable;
+
+    uint16 hoffset;
+    uint16 voffset;
+  } io;
+
+  struct {
+    //int x;
+    int y;
+
+    uint tile;
+    uint priority;
+    uint paletteNumber;
+    uint paletteIndex;
+  };
+
+  friend class PPU;
+};
diff --git a/nSide/higan/sfc-balanced/ppu/counter/counter-inline.hpp b/nSide/higan/sfc-balanced/ppu/counter/counter-inline.hpp
new file mode 100644
index 0000000..711bf89
--- /dev/null
+++ b/nSide/higan/sfc-balanced/ppu/counter/counter-inline.hpp
@@ -0,0 +1,85 @@
+//this should only be called by CPU::PPUcounter::tick();
+//keeps track of previous counter positions in history table
+auto PPUcounter::tick() -> void {
+  status.hcounter += 2;  //increment by smallest unit of time
+  if(status.hcounter >= 1360 && status.hcounter == lineclocks()) {
+    status.hcounter = 0;
+    vcounterTick();
+  }
+
+  history.index = (history.index + 1) & 2047;
+  history.field   [history.index] = status.field;
+  history.vcounter[history.index] = status.vcounter;
+  history.hcounter[history.index] = status.hcounter;
+}
+
+//this should only be called by PPU::PPUcounter::tick(n);
+//allows stepping by more than the smallest unit of time
+auto PPUcounter::tick(uint clocks) -> void {
+  status.hcounter += clocks;
+  if(status.hcounter >= lineclocks()) {
+    status.hcounter -= lineclocks();
+    vcounterTick();
+  }
+}
+
+//internal
+auto PPUcounter::vcounterTick() -> void {
+  if(++status.vcounter == 128) status.interlace = ppu.interlace();
+
+  if((system.region() == System::Region::NTSC && status.interlace == false && status.vcounter == 262)
+  || (system.region() == System::Region::NTSC && status.interlace == true  && status.vcounter == 263)
+  || (system.region() == System::Region::NTSC && status.interlace == true  && status.vcounter == 262 && status.field == 1)
+  || (system.region() == System::Region::PAL  && status.interlace == false && status.vcounter == 312)
+  || (system.region() == System::Region::PAL  && status.interlace == true  && status.vcounter == 313)
+  || (system.region() == System::Region::PAL  && status.interlace == true  && status.vcounter == 312 && status.field == 1)
+  ) {
+    status.vcounter = 0;
+    status.field = !status.field;
+  }
+  if(scanline) scanline();
+}
+
+auto PPUcounter::field() const -> bool { return status.field; }
+auto PPUcounter::vcounter() const -> uint16 { return status.vcounter; }
+auto PPUcounter::hcounter() const -> uint16 { return status.hcounter; }
+
+auto PPUcounter::field(uint offset) const -> bool { return history.field[(history.index - (offset >> 1)) & 2047]; }
+auto PPUcounter::vcounter(uint offset) const -> uint16 { return history.vcounter[(history.index - (offset >> 1)) & 2047]; }
+auto PPUcounter::hcounter(uint offset) const -> uint16 { return history.hcounter[(history.index - (offset >> 1)) & 2047]; }
+
+//one PPU dot = 4 CPU clocks
+//
+//PPU dots 323 and 327 are 6 CPU clocks long.
+//this does not apply to NTSC non-interlace scanline 240 on odd fields. this is
+//because the PPU skips one dot to alter the color burst phase of the video signal.
+//
+//dot 323 range = {1292, 1294, 1296}
+//dot 327 range = {1310, 1312, 1314}
+
+auto PPUcounter::hdot() const -> uint16 {
+  if(system.region() == System::Region::NTSC && status.interlace == false && vcounter() == 240 && field() == 1) {
+    return (hcounter() >> 2);
+  } else {
+    return (hcounter() - ((hcounter() > 1292) << 1) - ((hcounter() > 1310) << 1)) >> 2;
+  }
+}
+
+auto PPUcounter::lineclocks() const -> uint16 {
+  if(system.region() == System::Region::NTSC && status.interlace == false &&  vcounter() == 240 &&  field() == 1) return 1360;
+  return 1364;
+}
+
+auto PPUcounter::reset() -> void {
+  status.interlace = false;
+  status.field     = 0;
+  status.vcounter  = 0;
+  status.hcounter  = 0;
+  history.index    = 0;
+
+  for(auto n : range(2048)) {
+    history.field   [n] = 0;
+    history.vcounter[n] = 0;
+    history.hcounter[n] = 0;
+  }
+}
diff --git a/nSide/higan/sfc-balanced/ppu/counter/counter.hpp b/nSide/higan/sfc-balanced/ppu/counter/counter.hpp
new file mode 100644
index 0000000..9937bdb
--- /dev/null
+++ b/nSide/higan/sfc-balanced/ppu/counter/counter.hpp
@@ -0,0 +1,49 @@
+//PPUcounter emulates the H/V latch counters of the S-PPU2.
+//
+//real hardware has the S-CPU maintain its own copy of these counters that are
+//updated based on the state of the S-PPU Vblank and Hblank pins. emulating this
+//would require full lock-step synchronization for every clock tick.
+//to bypass this and allow the two to run out-of-order, both the CPU and PPU
+//classes inherit PPUcounter and keep their own counters.
+//the timers are kept in sync, as the only differences occur on V=240 and V=261,
+//based on interlace. thus, we need only synchronize and fetch interlace at any
+//point before this in the frame, which is handled internally by this class at
+//V=128.
+
+struct PPUcounter {
+  alwaysinline auto tick() -> void;
+  alwaysinline auto tick(uint clocks) -> void;
+
+  alwaysinline auto field() const -> bool;
+  alwaysinline auto vcounter() const -> uint16;
+  alwaysinline auto hcounter() const -> uint16;
+  inline auto hdot() const -> uint16;
+  inline auto lineclocks() const -> uint16;
+
+  alwaysinline auto field(uint offset) const -> bool;
+  alwaysinline auto vcounter(uint offset) const -> uint16;
+  alwaysinline auto hcounter(uint offset) const -> uint16;
+
+  inline auto reset() -> void;
+  auto serialize(serializer&) -> void;
+
+  function<auto () -> void> scanline;
+
+private:
+  inline auto vcounterTick() -> void;
+
+  struct {
+    bool interlace;
+    bool field;
+    uint16 vcounter;
+    uint16 hcounter;
+  } status;
+
+  struct {
+    bool field[2048];
+    uint16 vcounter[2048];
+    uint16 hcounter[2048];
+
+    int32 index;
+  } history;
+};
diff --git a/nSide/higan/sfc-balanced/ppu/io.cpp b/nSide/higan/sfc-balanced/ppu/io.cpp
new file mode 100644
index 0000000..8ce4348
--- /dev/null
+++ b/nSide/higan/sfc-balanced/ppu/io.cpp
@@ -0,0 +1,755 @@
+auto PPU::addressVRAM() const -> uint16 {
+  uint16 address = io.vramAddress;
+  switch(io.vramMapping) {
+  case 0: return address;
+  case 1: return address.bits( 8,15) <<  8 | address.bits(0,4) << 3 | address.bits(5,7);
+  case 2: return address.bits( 9,15) <<  9 | address.bits(0,5) << 3 | address.bits(6,8);
+  case 3: return address.bits(10,15) << 10 | address.bits(0,6) << 3 | address.bits(7,9);
+  }
+  unreachable;
+}
+
+//NOTE: all VRAM writes during active display are invalid. Unlike OAM and CGRAM, they will
+//not be written anywhere at all. The below address ranges for where writes are invalid have
+//been validated on hardware, as has the edge case where the S-CPU MDR can be written if the
+//write occurs during the very last clock cycle of vblank.
+auto PPU::readVRAM() -> uint16 {
+  if(!io.displayDisable && cpu.vcounter() < vdisp()) return 0x0000;
+  auto addr = addressVRAM();
+  auto data = vram[addr];
+  debug(ppu.vram.read, addr << 1 | 0, data.byte(0));
+  debug(ppu.vram.read, addr << 1 | 1, data.byte(1));
+  return data;
+}
+
+auto PPU::writeVRAM(bool byte, uint8 data) -> void {
+  if(!io.displayDisable && cpu.vcounter() < vdisp()) return;
+  auto addr = addressVRAM();
+  vram[addr].byte(byte) = data;
+  tiledataCache.tiledataState[Background::Mode::BPP2][(addr & vram.mask) >> 3] = 1;
+  tiledataCache.tiledataState[Background::Mode::BPP4][(addr & vram.mask) >> 4] = 1;
+  tiledataCache.tiledataState[Background::Mode::BPP8][(addr & vram.mask) >> 5] = 1;
+  debug(ppu.vram.write, addr << 1 | byte, data);
+}
+
+auto PPU::readOAM(uint10 addr) -> uint8 {
+  if(!io.displayDisable && cpu.vcounter() < vdisp()) addr = latch.oamAddress;
+  auto data = obj.oam.read(addr);
+  debug(ppu.oam.read, addr, data);
+  return data;
+}
+
+auto PPU::writeOAM(uint10 addr, uint8 data) -> void {
+  if(!io.displayDisable && cpu.vcounter() < vdisp()) addr = latch.oamAddress;
+  obj.oam.write(addr, data);
+  debug(ppu.oam.write, addr, data);
+}
+
+auto PPU::readCGRAM(bool byte, uint8 addr) -> uint8 {
+  if(!io.displayDisable
+  && cpu.vcounter() > 0 && cpu.vcounter() < vdisp()
+  && cpu.hcounter() >= 88 && cpu.hcounter() < 1096
+  ) addr = latch.cgramAddress;
+  auto data = screen.cgram[addr].byte(byte);
+  debug(ppu.cgram.read, addr << 1 | byte, data);
+  return data;
+}
+
+auto PPU::writeCGRAM(uint8 addr, uint15 data) -> void {
+  if(!io.displayDisable
+  && cpu.vcounter() > 0 && cpu.vcounter() < vdisp()
+  && cpu.hcounter() >= 88 && cpu.hcounter() < 1096
+  ) addr = latch.cgramAddress;
+  screen.cgram[addr] = data;
+  debug(ppu.cgram.write, addr << 1 | 0, data.byte(0));
+  debug(ppu.cgram.write, addr << 1 | 1, data.byte(1));
+}
+
+auto PPU::readIO(uint24 addr, uint8 data) -> uint8 {
+  cpu.synchronize(ppu);
+
+  switch((uint16)addr) {
+
+  case 0x2104: case 0x2105: case 0x2106: case 0x2108:
+  case 0x2109: case 0x210a: case 0x2114: case 0x2115:
+  case 0x2116: case 0x2118: case 0x2119: case 0x211a:
+  case 0x2124: case 0x2125: case 0x2126: case 0x2128:
+  case 0x2129: case 0x212a: {
+    return ppu1.mdr;
+  }
+
+  //MPYL
+  case 0x2134: {
+    uint24 result = (int16)io.m7a * (int8)(io.m7b >> 8);
+    return ppu1.mdr = result.byte(0);
+  }
+
+  //MPYM
+  case 0x2135: {
+    uint24 result = (int16)io.m7a * (int8)(io.m7b >> 8);
+    return ppu1.mdr = result.byte(1);
+  }
+
+  //MPYH
+  case 0x2136: {
+    uint24 result = (int16)io.m7a * (int8)(io.m7b >> 8);
+    return ppu1.mdr = result.byte(2);
+  }
+
+  //SLHV
+  case 0x2137: {
+    if(cpu.pio().bit(7)) latchCounters();
+    return data;  //CPU MDR
+  }
+
+  //OAMDATAREAD
+  case 0x2138: {
+    ppu1.mdr = readOAM(io.oamAddress++);
+    obj.setFirstSprite();
+    return ppu1.mdr;
+  }
+
+  //VMDATALREAD
+  case 0x2139: {
+    ppu1.mdr = latch.vram.byte(0);
+    if(io.vramIncrementMode == 0) {
+      latch.vram = readVRAM();
+      io.vramAddress += io.vramIncrementSize;
+    }
+    return ppu1.mdr;
+  }
+
+  //VMDATAHREAD
+  case 0x213a: {
+    ppu1.mdr = latch.vram.byte(1);
+    if(io.vramIncrementMode == 1) {
+      latch.vram = readVRAM();
+      io.vramAddress += io.vramIncrementSize;
+    }
+    return ppu1.mdr;
+  }
+
+  //CGDATAREAD
+  case 0x213b: {
+    //note: CGRAM palette data is 15-bits (0,bbbbb,ggggg,rrrrr)
+    //therefore, the high byte read from each color does not
+    //update bit 7 of the PPU2 MDR.
+    if(io.cgramAddressLatch++ == 0) {
+      ppu2.mdr.bits(0,7) = readCGRAM(0, io.cgramAddress);
+    } else {
+      ppu2.mdr.bits(0,6) = readCGRAM(1, io.cgramAddress++);
+    }
+    return ppu2.mdr;
+  }
+
+  //OPHCT
+  case 0x213c: {
+    if(latch.hcounter++ == 0) {
+      ppu2.mdr.bits(0,7) = io.hcounter.bits(0,7);
+    } else {
+      ppu2.mdr.bit (0  ) = io.hcounter.bit (  8);
+    }
+    return ppu2.mdr;
+  }
+
+  //OPVCT
+  case 0x213d: {
+    if(latch.vcounter++ == 0) {
+      ppu2.mdr.bits(0,7) = io.vcounter.bits(0,7);
+    } else {
+      ppu2.mdr.bit (0  ) = io.vcounter.bit (  8);
+    }
+    return ppu2.mdr;
+  };
+
+  //STAT77
+  case 0x213e: {
+    ppu1.mdr.bits(0,3) = ppu1.version;
+    ppu1.mdr.bit (  5) = 0;
+    ppu1.mdr.bit (  6) = obj.io.rangeOver;
+    ppu1.mdr.bit (  7) = obj.io.timeOver;
+    return ppu1.mdr;
+  }
+
+  //STAT78
+  case 0x213f: {
+    latch.hcounter = 0;
+    latch.vcounter = 0;
+
+    ppu2.mdr.bits(0,3) = ppu2.version;
+    ppu2.mdr.bit (  4) = system.region() == System::Region::PAL;  //0 = NTSC
+    if(!cpu.pio().bit(7)) {
+      ppu2.mdr.bit( 6) = 1;
+    } else {
+      ppu2.mdr.bit( 6) = latch.counters;
+      latch.counters = 0;
+    }
+    ppu2.mdr.bit (  7) = field();
+    return ppu2.mdr;
+  }
+
+  }
+
+  return data;
+}
+
+auto PPU::writeIO(uint24 addr, uint8 data) -> void {
+  cpu.synchronize(ppu);
+
+  switch((uint16)addr) {
+
+  //INIDISP
+  case 0x2100: {
+    if(io.displayDisable && cpu.vcounter() == vdisp()) obj.addressReset();
+    io.displayBrightness = data.bits(0,3);
+    io.displayDisable    = data.bit (7);
+    return;
+  }
+
+  //OBSEL
+  case 0x2101: {
+    obj.io.tiledataAddress = data.bits(0,2) << 13;
+    obj.io.nameselect      = data.bits(3,4);
+    obj.io.baseSize        = data.bits(5,7);
+    for(auto& object : obj.oam.object) object.updateSize();
+    return;
+  }
+
+  //OAMADDL
+  case 0x2102: {
+    io.oamBaseAddress = (io.oamBaseAddress & 0x0200) | (data << 1);
+    obj.addressReset();
+    return;
+  }
+
+  //OAMADDH
+  case 0x2103: {
+    io.oamBaseAddress = data.bit(0) << 9 | (io.oamBaseAddress & 0x01fe);
+    io.oamPriority = data.bit(7);
+    obj.addressReset();
+    return;
+  }
+
+  //OAMDATA
+  case 0x2104: {
+    bool latchBit = io.oamAddress & 1;
+    uint10 address = io.oamAddress++;
+
+    if(latchBit == 0) latch.oam = data;
+    if(address.bit(9)) {
+      writeOAM(address, data);
+    } else if(latchBit == 1) {
+      writeOAM((address & ~1) + 0, latch.oam);
+      writeOAM((address & ~1) + 1, data);
+    }
+    obj.setFirstSprite();
+    return;
+  }
+
+  //BGMODE
+  case 0x2105: {
+    io.bgMode       = data.bits(0,2);
+    io.bgPriority   = data.bit (  3);
+    bg1.io.tileSize = data.bit (  4);
+    bg2.io.tileSize = data.bit (  5);
+    bg3.io.tileSize = data.bit (  6);
+    bg4.io.tileSize = data.bit (  7);
+    updateVideoMode();
+    return;
+  }
+
+  //MOSAIC
+  case 0x2106: {
+    uint mosaicSize = data.bits(4,7);
+    bg1.io.mosaic = data.bit(0) ? mosaicSize : 0;
+    bg2.io.mosaic = data.bit(1) ? mosaicSize : 0;
+    bg3.io.mosaic = data.bit(2) ? mosaicSize : 0;
+    bg4.io.mosaic = data.bit(3) ? mosaicSize : 0;
+    return;
+  }
+
+  //BG1SC
+  case 0x2107: {
+    bg1.io.screenSize    = data.bits(0,1);
+    bg1.io.screenAddress = data.bits(2,7) << 10;
+    return;
+  }
+
+  //BG2SC
+  case 0x2108: {
+    bg2.io.screenSize    = data.bits(0,1);
+    bg2.io.screenAddress = data.bits(2,7) << 10;
+    return;
+  }
+
+  //BG3SC
+  case 0x2109: {
+    bg3.io.screenSize    = data.bits(0,1);
+    bg3.io.screenAddress = data.bits(2,7) << 10;
+    return;
+  }
+
+  //BG4SC
+  case 0x210a: {
+    bg4.io.screenSize    = data.bits(0,1);
+    bg4.io.screenAddress = data.bits(2,7) << 10;
+    return;
+  }
+
+  //BG12NBA
+  case 0x210b: {
+    bg1.io.tiledataAddress = data.bits(0,3) << 12;
+    bg2.io.tiledataAddress = data.bits(4,7) << 12;
+    return;
+  }
+
+  //BG34NBA
+  case 0x210c: {
+    bg3.io.tiledataAddress = data.bits(0,3) << 12;
+    bg4.io.tiledataAddress = data.bits(4,7) << 12;
+    return;
+  }
+
+  //BG1HOFS
+  case 0x210d: {
+    io.hoffsetMode7 = data << 8 | latch.mode7;
+    latch.mode7 = data;
+
+    bg1.io.hoffset = data << 8 | (latch.bgofs & ~7) | (bg1.io.hoffset >> 8 & 7);
+    latch.bgofs = data;
+    return;
+  }
+
+  //BG1VOFS
+  case 0x210e: {
+    io.voffsetMode7 = data << 8 | latch.mode7;
+    latch.mode7 = data;
+
+    bg1.io.voffset = data << 8 | latch.bgofs;
+    latch.bgofs = data;
+    return;
+  }
+
+  //BG2HOFS
+  case 0x210f: {
+    bg2.io.hoffset = data << 8 | (latch.bgofs & ~7) | (bg2.io.hoffset >> 8 & 7);
+    latch.bgofs = data;
+    return;
+  }
+
+  //BG2VOFS
+  case 0x2110: {
+    bg2.io.voffset = data << 8 | latch.bgofs;
+    latch.bgofs = data;
+    return;
+  }
+
+  //BG3HOFS
+  case 0x2111: {
+    bg3.io.hoffset = data << 8 | (latch.bgofs & ~7) | (bg3.io.hoffset >> 8 & 7);
+    latch.bgofs = data;
+    return;
+  }
+
+  //BG3VOFS
+  case 0x2112: {
+    bg3.io.voffset = data << 8 | latch.bgofs;
+    latch.bgofs = data;
+    return;
+  }
+
+  //BG4HOFS
+  case 0x2113: {
+    bg4.io.hoffset = data << 8 | (latch.bgofs & ~7) | (bg4.io.hoffset >> 8 & 7);
+    latch.bgofs = data;
+    return;
+  }
+
+  //BG4VOFS
+  case 0x2114: {
+    bg4.io.voffset = data << 8 | latch.bgofs;
+    latch.bgofs = data;
+    return;
+  }
+
+  //VMAIN
+  case 0x2115: {
+    static const uint size[4] = {1, 32, 128, 128};
+    io.vramIncrementSize = size[data.bits(0,1)];
+    io.vramMapping       = data.bits(2,3);
+    io.vramIncrementMode = data.bit (  7);
+    return;
+  }
+
+  //VMADDL
+  case 0x2116: {
+    io.vramAddress.byte(0) = data;
+    latch.vram = readVRAM();
+    return;
+  }
+
+  //VMADDH
+  case 0x2117: {
+    io.vramAddress.byte(1) = data;
+    latch.vram = readVRAM();
+    return;
+  }
+
+  //VMDATAL
+  case 0x2118: {
+    writeVRAM(0, data);
+    if(io.vramIncrementMode == 0) io.vramAddress += io.vramIncrementSize;
+    return;
+  }
+
+  //VMDATAH
+  case 0x2119: {
+    writeVRAM(1, data);
+    if(io.vramIncrementMode == 1) io.vramAddress += io.vramIncrementSize;
+    return;
+  }
+
+  //M7SEL
+  case 0x211a: {
+    io.hflipMode7  = data.bit (  0);
+    io.vflipMode7  = data.bit (  1);
+    io.repeatMode7 = data.bits(6,7);
+    return;
+  }
+
+  //M7A
+  case 0x211b: {
+    io.m7a = data << 8 | latch.mode7;
+    latch.mode7 = data;
+    return;
+  }
+
+  //M7B
+  case 0x211c: {
+    io.m7b = data << 8 | latch.mode7;
+    latch.mode7 = data;
+    return;
+  }
+
+  //M7C
+  case 0x211d: {
+    io.m7c = data << 8 | latch.mode7;
+    latch.mode7 = data;
+    return;
+  }
+
+  //M7D
+  case 0x211e: {
+    io.m7d = data << 8 | latch.mode7;
+    latch.mode7 = data;
+    return;
+  }
+
+  //M7X
+  case 0x211f: {
+    io.m7x = data << 8 | latch.mode7;
+    latch.mode7 = data;
+    return;
+  }
+
+  //M7Y
+  case 0x2120: {
+    io.m7y = data << 8 | latch.mode7;
+    latch.mode7 = data;
+    return;
+  }
+
+  //CGADD
+  case 0x2121: {
+    io.cgramAddress = data;
+    io.cgramAddressLatch = 0;
+    return;
+  }
+
+  //CGDATA
+  case 0x2122: {
+    //note: CGRAM palette data format is 15-bits
+    //(0,bbbbb,ggggg,rrrrr). Highest bit is ignored,
+    //as evidenced by $213b CGRAM data reads.
+    if(io.cgramAddressLatch++ == 0) {
+      latch.cgram = data;
+    } else {
+      writeCGRAM(io.cgramAddress++, data.bits(0,6) << 8 | latch.cgram);
+    }
+    return;
+  }
+
+  //W12SEL
+  case 0x2123: {
+    window.io.bg1.oneInvert = data.bit(0);
+    window.io.bg1.oneEnable = data.bit(1);
+    window.io.bg1.twoInvert = data.bit(2);
+    window.io.bg1.twoEnable = data.bit(3);
+    window.io.bg2.oneInvert = data.bit(4);
+    window.io.bg2.oneEnable = data.bit(5);
+    window.io.bg2.twoInvert = data.bit(6);
+    window.io.bg2.twoEnable = data.bit(7);
+    return;
+  }
+
+  //W34SEL
+  case 0x2124: {
+    window.io.bg3.oneInvert = data.bit(0);
+    window.io.bg3.oneEnable = data.bit(1);
+    window.io.bg3.twoInvert = data.bit(2);
+    window.io.bg3.twoEnable = data.bit(3);
+    window.io.bg4.oneInvert = data.bit(4);
+    window.io.bg4.oneEnable = data.bit(5);
+    window.io.bg4.twoInvert = data.bit(6);
+    window.io.bg4.twoEnable = data.bit(7);
+    return;
+  }
+
+  //WOBJSEL
+  case 0x2125: {
+    window.io.obj.oneInvert = data.bit(0);
+    window.io.obj.oneEnable = data.bit(1);
+    window.io.obj.twoInvert = data.bit(2);
+    window.io.obj.twoEnable = data.bit(3);
+    window.io.col.oneInvert = data.bit(4);
+    window.io.col.oneEnable = data.bit(5);
+    window.io.col.twoInvert = data.bit(6);
+    window.io.col.twoEnable = data.bit(7);
+    return;
+  }
+
+  //WH0
+  case 0x2126: {
+    window.io.oneLeft = data;
+    return;
+  }
+
+  //WH1
+  case 0x2127: {
+    window.io.oneRight = data;
+    return;
+  }
+
+  //WH2
+  case 0x2128: {
+    window.io.twoLeft = data;
+    return;
+  }
+
+  //WH3
+  case 0x2129: {
+    window.io.twoRight = data;
+    return;
+  }
+
+  //WBGLOG
+  case 0x212a: {
+    window.io.bg1.mask = data.bits(0,1);
+    window.io.bg2.mask = data.bits(2,3);
+    window.io.bg3.mask = data.bits(4,5);
+    window.io.bg4.mask = data.bits(6,7);
+    return;
+  }
+
+  //WOBJLOG
+  case 0x212b: {
+    window.io.obj.mask = data.bits(0,1);
+    window.io.col.mask = data.bits(2,3);
+    return;
+  }
+
+  //TM
+  case 0x212c: {
+    bg1.io.aboveEnable = data.bit(0);
+    bg2.io.aboveEnable = data.bit(1);
+    bg3.io.aboveEnable = data.bit(2);
+    bg4.io.aboveEnable = data.bit(3);
+    obj.io.aboveEnable = data.bit(4);
+    return;
+  }
+
+  //TS
+  case 0x212d: {
+    bg1.io.belowEnable = data.bit(0);
+    bg2.io.belowEnable = data.bit(1);
+    bg3.io.belowEnable = data.bit(2);
+    bg4.io.belowEnable = data.bit(3);
+    obj.io.belowEnable = data.bit(4);
+    return;
+  }
+
+  //TMW
+  case 0x212e: {
+    window.io.bg1.aboveEnable = data.bit(0);
+    window.io.bg2.aboveEnable = data.bit(1);
+    window.io.bg3.aboveEnable = data.bit(2);
+    window.io.bg4.aboveEnable = data.bit(3);
+    window.io.obj.aboveEnable = data.bit(4);
+    return;
+  }
+
+  //TSW
+  case 0x212f: {
+    window.io.bg1.belowEnable = data.bit(0);
+    window.io.bg2.belowEnable = data.bit(1);
+    window.io.bg3.belowEnable = data.bit(2);
+    window.io.bg4.belowEnable = data.bit(3);
+    window.io.obj.belowEnable = data.bit(4);
+    return;
+  }
+
+  //CGWSEL
+  case 0x2130: {
+    screen.io.directColor   = data.bit (  0);
+    screen.io.blendMode     = data.bit (  1);
+    window.io.col.belowMask = data.bits(4,5);
+    window.io.col.aboveMask = data.bits(6,7);
+    return;
+  }
+
+  //CGADDSUB
+  case 0x2131: {
+    screen.io.bg1.colorEnable  = data.bit(0);
+    screen.io.bg2.colorEnable  = data.bit(1);
+    screen.io.bg3.colorEnable  = data.bit(2);
+    screen.io.bg4.colorEnable  = data.bit(3);
+    screen.io.obj.colorEnable  = data.bit(4);
+    screen.io.back.colorEnable = data.bit(5);
+    screen.io.colorHalve       = data.bit(6);
+    screen.io.colorMode        = data.bit(7);
+    return;
+  }
+
+  //COLDATA
+  case 0x2132: {
+    if(data.bit(5)) screen.io.colorRed   = data.bits(0,4);
+    if(data.bit(6)) screen.io.colorGreen = data.bits(0,4);
+    if(data.bit(7)) screen.io.colorBlue  = data.bits(0,4);
+
+    io.color_rgb = screen.fixedColor();
+    return;
+  }
+
+  //SETINI
+  case 0x2133: {
+    io.interlace     = data.bit(0);
+    obj.io.interlace = data.bit(1);
+    io.overscan      = data.bit(2);
+    io.pseudoHires   = data.bit(3);
+    io.extbg         = data.bit(6);
+    updateVideoMode();
+
+    display.overscan = io.overscan;
+    return;
+  }
+
+  }
+}
+
+auto PPU::latchCounters() -> void {
+  io.hcounter = cpu.hdot();
+  io.vcounter = cpu.vcounter();
+  latch.counters = 1;
+}
+
+auto PPU::updateVideoMode() -> void {
+  switch(io.bgMode) {
+  case 0:
+    bg1.io.mode = Background::Mode::BPP2;
+    bg2.io.mode = Background::Mode::BPP2;
+    bg3.io.mode = Background::Mode::BPP2;
+    bg4.io.mode = Background::Mode::BPP2;
+    memory::assign(bg1.io.priority, 8, 11);
+    memory::assign(bg2.io.priority, 7, 10);
+    memory::assign(bg3.io.priority, 2,  5);
+    memory::assign(bg4.io.priority, 1,  4);
+    memory::assign(obj.io.priority, 3,  6, 9, 12);
+    break;
+
+  case 1:
+    bg1.io.mode = Background::Mode::BPP4;
+    bg2.io.mode = Background::Mode::BPP4;
+    bg3.io.mode = Background::Mode::BPP2;
+    bg4.io.mode = Background::Mode::Inactive;
+    if(io.bgPriority) {
+      memory::assign(bg1.io.priority, 5,  8);
+      memory::assign(bg2.io.priority, 4,  7);
+      memory::assign(bg3.io.priority, 1, 10);
+      memory::assign(obj.io.priority, 2,  3, 6, 9);
+    } else {
+      memory::assign(bg1.io.priority, 6,  9);
+      memory::assign(bg2.io.priority, 5,  8);
+      memory::assign(bg3.io.priority, 1,  3);
+      memory::assign(obj.io.priority, 2,  4, 7, 10);
+    }
+    break;
+
+  case 2:
+    bg1.io.mode = Background::Mode::BPP4;
+    bg2.io.mode = Background::Mode::BPP4;
+    bg3.io.mode = Background::Mode::Inactive;
+    bg4.io.mode = Background::Mode::Inactive;
+    memory::assign(bg1.io.priority, 3, 7);
+    memory::assign(bg2.io.priority, 1, 5);
+    memory::assign(obj.io.priority, 2, 4, 6, 8);
+    break;
+
+  case 3:
+    bg1.io.mode = Background::Mode::BPP8;
+    bg2.io.mode = Background::Mode::BPP4;
+    bg3.io.mode = Background::Mode::Inactive;
+    bg4.io.mode = Background::Mode::Inactive;
+    memory::assign(bg1.io.priority, 3, 7);
+    memory::assign(bg2.io.priority, 1, 5);
+    memory::assign(obj.io.priority, 2, 4, 6, 8);
+    break;
+
+  case 4:
+    bg1.io.mode = Background::Mode::BPP8;
+    bg2.io.mode = Background::Mode::BPP2;
+    bg3.io.mode = Background::Mode::Inactive;
+    bg4.io.mode = Background::Mode::Inactive;
+    memory::assign(bg1.io.priority, 3, 7);
+    memory::assign(bg2.io.priority, 1, 5);
+    memory::assign(obj.io.priority, 2, 4, 6, 8);
+    break;
+
+  case 5:
+    bg1.io.mode = Background::Mode::BPP4;
+    bg2.io.mode = Background::Mode::BPP2;
+    bg3.io.mode = Background::Mode::Inactive;
+    bg4.io.mode = Background::Mode::Inactive;
+    memory::assign(bg1.io.priority, 3, 7);
+    memory::assign(bg2.io.priority, 1, 5);
+    memory::assign(obj.io.priority, 2, 4, 6, 8);
+    break;
+
+  case 6:
+    bg1.io.mode = Background::Mode::BPP4;
+    bg2.io.mode = Background::Mode::Inactive;
+    bg3.io.mode = Background::Mode::Inactive;
+    bg4.io.mode = Background::Mode::Inactive;
+    memory::assign(bg1.io.priority, 2, 5);
+    memory::assign(obj.io.priority, 1, 3, 4, 6);
+    break;
+
+  case 7:
+    if(!io.extbg) {
+      bg1.io.mode = Background::Mode::Mode7;
+      bg2.io.mode = Background::Mode::Inactive;
+      bg3.io.mode = Background::Mode::Inactive;
+      bg4.io.mode = Background::Mode::Inactive;
+      memory::assign(bg1.io.priority, 2);
+      memory::assign(obj.io.priority, 1, 3, 4, 5);
+    } else {
+      bg1.io.mode = Background::Mode::Mode7;
+      bg2.io.mode = Background::Mode::Mode7;
+      bg3.io.mode = Background::Mode::Inactive;
+      bg4.io.mode = Background::Mode::Inactive;
+      memory::assign(bg1.io.priority, 3);
+      memory::assign(bg2.io.priority, 1, 5);
+      memory::assign(obj.io.priority, 2, 4, 6, 7);
+    }
+    break;
+  }
+}
diff --git a/nSide/higan/sfc-balanced/ppu/object/oam.cpp b/nSide/higan/sfc-balanced/ppu/object/oam.cpp
new file mode 100644
index 0000000..dc9cf9a
--- /dev/null
+++ b/nSide/higan/sfc-balanced/ppu/object/oam.cpp
@@ -0,0 +1,72 @@
+auto PPU::OAM::read(uint10 addr) -> uint8 {
+  if(addr < 0x0200) {
+    uint n = addr >> 2;
+    addr &= 3;
+    if(addr == 0) return object[n].x.bits(0,7);
+    if(addr == 1) return object[n].y;
+    if(addr == 2) return object[n].character;
+    return (
+      object[n].nameselect << 0
+    | object[n].palette    << 1
+    | object[n].priority   << 4
+    | object[n].hflip      << 6
+    | object[n].vflip      << 7
+    );
+  } else {
+    uint n = (addr & 0x1f) << 2;  //object#
+    return (
+      object[n + 0].x.bit(8) << 0
+    | object[n + 0].size     << 1
+    | object[n + 1].x.bit(8) << 2
+    | object[n + 1].size     << 3
+    | object[n + 2].x.bit(8) << 4
+    | object[n + 2].size     << 5
+    | object[n + 3].x.bit(8) << 6
+    | object[n + 3].size     << 7
+    );
+  }
+}
+
+auto PPU::OAM::write(uint10 addr, uint8 data) -> void {
+  if(!addr.bit(9)) {
+    uint n = addr >> 2;  //object#
+    addr &= 3;
+    if(addr == 0) { object[n].x.bits(0,7) = data; return; }
+    if(addr == 1) { object[n].y = data; return; }
+    if(addr == 2) { object[n].character = data; return; }
+    object[n].nameselect = data.bit (0);
+    object[n].palette    = data.bits(1,3);
+    object[n].priority   = data.bits(4,5);
+    object[n].hflip      = data.bit (6);
+    object[n].vflip      = data.bit (7);
+  } else {
+    uint n = (addr & 0x1f) << 2;  //object#
+    object[n + 0].x.bit(8) = data.bit(0);
+    object[n + 0].size     = data.bit(1);
+    object[n + 0].updateSize();
+    object[n + 1].x.bit(8) = data.bit(2);
+    object[n + 1].size     = data.bit(3);
+    object[n + 1].updateSize();
+    object[n + 2].x.bit(8) = data.bit(4);
+    object[n + 2].size     = data.bit(5);
+    object[n + 2].updateSize();
+    object[n + 3].x.bit(8) = data.bit(6);
+    object[n + 3].size     = data.bit(7);
+    object[n + 3].updateSize();
+  }
+}
+
+auto PPU::OAM::Object::updateSize() -> void {
+  if(size == 0) {
+    static const uint widths[]  = { 8,  8,  8, 16, 16, 32, 16, 16};
+    static const uint heights[] = { 8,  8,  8, 16, 16, 32, 32, 32};
+    width  = widths[ppu.obj.io.baseSize];
+    //hardware quirk
+    height = ppu.obj.io.interlace && ppu.obj.io.baseSize >= 6 ? 16 : heights[ppu.obj.io.baseSize];
+  } else {
+    static const uint widths[]  = {16, 32, 64, 32, 64, 64, 32, 32};
+    static const uint heights[] = {16, 32, 64, 32, 64, 64, 64, 32};
+    width  = widths[ppu.obj.io.baseSize];
+    height = heights[ppu.obj.io.baseSize];
+  }
+}
diff --git a/nSide/higan/sfc-balanced/ppu/object/object.cpp b/nSide/higan/sfc-balanced/ppu/object/object.cpp
new file mode 100644
index 0000000..c755d37
--- /dev/null
+++ b/nSide/higan/sfc-balanced/ppu/object/object.cpp
@@ -0,0 +1,41 @@
+#include "oam.cpp"
+
+auto PPU::Object::addressReset() -> void {
+  ppu.io.oamAddress = ppu.io.oamBaseAddress;
+  setFirstSprite();
+}
+
+auto PPU::Object::setFirstSprite() -> void {
+  io.firstSprite = !ppu.io.oamPriority ? 0 : (ppu.io.oamAddress >> 2) & 127;
+}
+
+auto PPU::Object::reset() -> void {
+  for(auto& object : oam.object) {
+    object.x = 0;
+    object.y = 0;
+    object.character = 0;
+    object.nameselect = 0;
+    object.vflip = 0;
+    object.hflip = 0;
+    object.priority = 0;
+    object.palette = 0;
+    object.size = 0;
+  }
+
+  t.itemCount = 0;
+  t.tileCount = 0;
+
+  io.aboveEnable = false;
+  io.belowEnable = false;
+  io.interlace = false;
+
+  io.baseSize = 0;
+  io.nameselect = 0;
+  io.tiledataAddress = 0x0000;
+  io.firstSprite = 0;
+
+  for(auto& p : io.priority) p = 0;
+
+  io.timeOver = false;
+  io.rangeOver = false;
+}
diff --git a/nSide/higan/sfc-balanced/ppu/object/object.hpp b/nSide/higan/sfc-balanced/ppu/object/object.hpp
new file mode 100644
index 0000000..95ac9e8
--- /dev/null
+++ b/nSide/higan/sfc-balanced/ppu/object/object.hpp
@@ -0,0 +1,88 @@
+struct OAM {
+  auto read(uint10 addr) -> uint8;
+  auto write(uint10 addr, uint8 data) -> void;
+
+  struct Object {
+    uint8 width;
+    uint8 height;
+
+    uint9 x;
+    uint8 y;
+    uint8 character;
+    bool  nameselect;
+    bool  vflip;
+    bool  hflip;
+    uint2 priority;
+    uint3 palette;
+    bool  size;
+
+    auto updateSize() -> void;
+  } object[128];
+};
+
+struct Object {
+  alwaysinline auto addressReset() -> void;
+  alwaysinline auto setFirstSprite() -> void;
+  auto reset() -> void;
+
+  auto serialize(serializer&) -> void;
+
+  struct ID { enum : uint { OBJ = 4 }; };
+
+  OAM oam;
+
+  struct IO {
+    bool aboveEnable;
+    bool belowEnable;
+    bool interlace;
+
+    uint3  baseSize;
+    uint2  nameselect;
+    uint16 tiledataAddress;
+    uint7  firstSprite;
+
+    uint priority[4];
+
+    bool timeOver;
+    bool rangeOver;
+  } io;
+
+  /*
+  struct Item {
+    bool  valid;
+    uint7 index;
+  };
+
+  struct Tile {
+    bool   valid;
+    uint9  x;
+    uint2  priority;
+    uint8  palette;
+    uint1  hflip;
+    uint32 data;
+  };
+  */
+
+  struct State {
+    //uint x;
+    //uint y;
+
+    uint itemCount;
+    uint tileCount;
+
+    //bool active;
+    //Item item[2][32];
+    //Tile tile[2][34];
+  } t;
+
+  /*
+  struct Output {
+    struct Pixel {
+      uint  priority;  //0 = none (transparent)
+      uint8 palette;
+    } above, below;
+  } output;
+  */
+
+  friend class PPU;
+};
diff --git a/nSide/higan/sfc-balanced/ppu/ppu.cpp b/nSide/higan/sfc-balanced/ppu/ppu.cpp
new file mode 100644
index 0000000..ac73bd1
--- /dev/null
+++ b/nSide/higan/sfc-balanced/ppu/ppu.cpp
@@ -0,0 +1,265 @@
+#include <sfc-balanced/sfc.hpp>
+
+namespace SuperFamicom {
+
+PPU ppu;
+
+#include "io.cpp"
+#include "background/background.cpp"
+#include "object/object.cpp"
+#include "window/window.cpp"
+#include "screen/screen.cpp"
+#include "render/render.cpp"
+#include "serialization.cpp"
+
+PPU::PPU() :
+bg1(Background::ID::BG1),
+bg2(Background::ID::BG2),
+bg3(Background::ID::BG3),
+bg4(Background::ID::BG4) {
+  ppu1.version = 1;  //allowed values: 1
+  ppu2.version = 3;  //allowed values: 1, 2, 3
+
+  output = new uint32[512 * 512];
+  output += 16 * 512;  //overscan offset
+
+  tiledataCache.allocate();
+
+  for(uint l : range(16)) {
+    for(uint i : range(4096)) {
+      mosaicTable[l][i] = (i / (l + 1)) * (l + 1);
+    }
+  }
+}
+
+PPU::~PPU() {
+  output -= 16 * 512;
+  delete[] output;
+  tiledataCache.free();
+}
+
+auto PPU::step(uint clocks) -> void {
+  tick(clocks);
+  Thread::step(clocks);
+  synchronize(cpu);
+}
+
+auto PPU::Enter() -> void {
+  while(true) scheduler.synchronize(), ppu.main();
+}
+
+auto PPU::main() -> void {
+  //H =    0 (initialize)
+  scanline();
+  step(10);
+
+  //H =   10 (cache mode7 registers + OAM address reset)
+  cache.hoffsetMode7 = io.hoffsetMode7;
+  cache.voffsetMode7 = io.voffsetMode7;
+  cache.m7a = io.m7a;
+  cache.m7b = io.m7b;
+  cache.m7c = io.m7c;
+  cache.m7d = io.m7d;
+  cache.m7x = io.m7x;
+  cache.m7y = io.m7y;
+  if(vcounter() == vdisp() && !io.displayDisable) obj.addressReset();
+  step(502);
+
+  //H =  512 (render)
+  if(line == 0) obj_renderLine_rto();
+  if(line >= 1 && line < 240) renderLine();
+  step(640);
+
+  //H = 1152 (cache OBSEL)
+  if(cache.obj_baseSize != obj.io.baseSize) {
+    cache.obj_baseSize = obj.io.baseSize;
+  }
+  cache.obj_nameselect = obj.io.nameselect;
+  cache.obj_tiledataAddress = obj.io.tiledataAddress;
+  step(lineclocks() - 1152);  //seek to start of next scanline
+}
+
+auto PPU::load(Markup::Node node) -> bool {
+  ppu1.version = max(1, min(1, node["ppu1/version"].natural()));
+  ppu2.version = max(1, min(3, node["ppu2/version"].natural()));
+  ppu.vram.mask = node["ppu1/ram/size"].natural() - 1;
+  if(ppu.vram.mask != 0xffff) ppu.vram.mask = 0x7fff;
+  return true;
+}
+
+auto PPU::power() -> void {
+  for(auto& n : vram.data) n = random(0x0000);
+  tiledataCache.flush();
+}
+
+auto PPU::reset() -> void {
+  create(Enter, system.colorburst() * 6.0);
+  PPUcounter::reset();
+  memory::fill(output, 512 * 480 * sizeof(uint32));
+
+  function<auto (uint24, uint8) -> uint8> reader{&PPU::readIO, this};
+  function<auto (uint24, uint8) -> void> writer{&PPU::writeIO, this};
+  bus.map(reader, writer, "00-3f,80-bf:2100-213f");
+
+  //open bus support
+  ppu1.mdr = random(0xff);
+  ppu2.mdr = random(0xff);
+
+  latch.vram = random(0x0000);
+  latch.oam = random(0x00);
+  latch.cgram = random(0x00);
+  latch.bgofs = random(0x00);
+  latch.mode7 = random(0x00);
+  latch.counters = false;
+  latch.hcounter = 0;
+  latch.vcounter = 0;
+
+  latch.oamAddress = 0x0000;
+  latch.cgramAddress = 0x00;
+
+  //$2100  INIDISP
+  io.displayDisable = true;
+  io.displayBrightness = 0;
+
+  //$2101
+  cache.obj_baseSize = 0;
+  cache.obj_nameselect = 0;
+  cache.obj_tiledataAddress = 0x0000;
+
+  //$2102  OAMADDL
+  //$2103  OAMADDH
+  io.oamBaseAddress = random(0x0000);
+  io.oamAddress = random(0x0000);
+  io.oamPriority = random(false);
+
+  //$2105  BGMODE
+  io.bgPriority = false;
+  io.bgMode = 0;
+
+  //$2106  MOSAIC
+  io.mosaicCountdown = 0;
+
+  //$210d  BG1HOFS
+  io.hoffsetMode7 = random(0x0000);
+
+  //$210e  BG1VOFS
+  io.voffsetMode7 = random(0x0000);
+
+  //$2115  VMAIN
+  io.vramIncrementMode = random(1);
+  io.vramMapping = random(0);
+  io.vramIncrementSize = 1;
+
+  //$2116  VMADDL
+  //$2117  VMADDH
+  io.vramAddress = random(0x0000);
+
+  //$211a  M7SEL
+  io.repeatMode7 = random(0);
+  io.vflipMode7 = random(false);
+  io.hflipMode7 = random(false);
+
+  //$211b  M7A
+  io.m7a = random(0x0000);
+
+  //$211c  M7B
+  io.m7b = random(0x0000);
+
+  //$211d  M7C
+  io.m7c = random(0x0000);
+
+  //$211e  M7D
+  io.m7d = random(0x0000);
+
+  //$211f  M7X
+  io.m7x = random(0x0000);
+
+  //$2120  M7Y
+  io.m7y = random(0x0000);
+
+  //$2121  CGADD
+  io.cgramAddress = random(0x00);
+  io.cgramAddressLatch = random(0);
+
+  //$2132  COLDATA
+  io.color_rgb = 0x0000;
+
+  //$2133  SETINI
+  io.extbg = random(false);
+  io.pseudoHires = random(false);
+  io.overscan = false;
+  io.interlace = false;
+
+  //$213c  OPHCT
+  io.hcounter = 0;
+
+  //$213d  OPVCT
+  io.vcounter = 0;
+
+  bg1.reset();
+  bg2.reset();
+  bg3.reset();
+  bg4.reset();
+  obj.reset();
+  window.reset();
+  screen.reset();
+
+  //bg line counters
+  io.bg_y[Background::ID::BG1] = 0;
+  io.bg_y[Background::ID::BG2] = 0;
+  io.bg_y[Background::ID::BG3] = 0;
+  io.bg_y[Background::ID::BG4] = 0;
+
+  frame();
+}
+
+auto PPU::scanline() -> void {
+  line = vcounter();
+
+  if(line == 0) {
+    frame();
+
+    //RTO flag reset
+    obj.io.timeOver  = false;
+    obj.io.rangeOver = false;
+  }
+
+  if(line == 1) {
+    //mosaic reset
+    for(int bg_id = Background::ID::BG1; bg_id <= Background::ID::BG4; bg_id++) io.bg_y[bg_id] = 1;
+    io.mosaicCountdown = max(bg1.io.mosaic, bg2.io.mosaic, bg3.io.mosaic, bg4.io.mosaic) + 1;
+    io.mosaicCountdown--;
+  } else {
+    for(int bg_id = Background::ID::BG1; bg_id <= Background::ID::BG4; bg_id++) {
+      auto bg = &bg1;
+      switch(bg_id) {
+      case Background::ID::BG1: bg = &bg1; break;
+      case Background::ID::BG2: bg = &bg2; break;
+      case Background::ID::BG3: bg = &bg3; break;
+      case Background::ID::BG4: bg = &bg4; break;
+      }
+      if(!bg->io.mosaic || !io.mosaicCountdown) io.bg_y[bg_id] = line;
+    }
+    if(!io.mosaicCountdown) io.mosaicCountdown = max(bg1.io.mosaic, bg2.io.mosaic, bg3.io.mosaic, bg4.io.mosaic) + 1;
+    io.mosaicCountdown--;
+  }
+
+  if(line == 241) {
+    scheduler.exit(Scheduler::Event::Frame);
+  }
+}
+
+auto PPU::frame() -> void {
+  if(field() == 0) display.interlace = io.interlace;
+}
+
+auto PPU::refresh() -> void {
+  auto output = this->output;
+  if(!overscan()) output -= 14 * 512;
+  auto pitch = 512; //1024 >> interlace();
+  auto width = 512;
+  auto height = 480; //!interlace() ? 240 : 480;
+  Emulator::video.refresh(output, pitch * sizeof(uint32), width, height);
+}
+
+}
diff --git a/nSide/higan/sfc-balanced/ppu/ppu.hpp b/nSide/higan/sfc-balanced/ppu/ppu.hpp
new file mode 100644
index 0000000..87399c6
--- /dev/null
+++ b/nSide/higan/sfc-balanced/ppu/ppu.hpp
@@ -0,0 +1,191 @@
+struct PPU : Thread, PPUcounter {
+  alwaysinline auto interlace() const -> bool { return display.interlace; }
+  alwaysinline auto overscan() const -> bool { return display.overscan; }
+  alwaysinline auto vdisp() const -> uint { return display.overscan ? 240 : 225; }
+
+  PPU();
+  ~PPU();
+
+  alwaysinline auto step(uint clocks) -> void;
+
+  static auto Enter() -> void;
+  auto main() -> void;
+  auto load(Markup::Node) -> bool;
+  auto power() -> void;
+  auto reset() -> void;
+
+  auto serialize(serializer&) -> void;
+
+  //mmio.cpp
+  alwaysinline auto addressVRAM() const -> uint16;
+  alwaysinline auto readVRAM() -> uint16;
+  alwaysinline auto writeVRAM(bool byte, uint8 data) -> void;
+  alwaysinline auto readOAM(uint10 addr) -> uint8;
+  alwaysinline auto writeOAM(uint10 addr, uint8 data) -> void;
+  alwaysinline auto readCGRAM(bool byte, uint8 addr) -> uint8;
+  alwaysinline auto writeCGRAM(uint8 addr, uint15 data) -> void;
+  auto readIO(uint24 addr, uint8 data) -> uint8;
+  auto writeIO(uint24 addr, uint8 data) -> void;
+  auto latchCounters() -> void;
+  auto updateVideoMode() -> void;
+
+privileged:
+  struct VRAM {
+    auto& operator[](uint addr) { return data[addr & mask]; }
+    uint16 data[64 * 1024];
+    uint mask = 0x7fff;
+  } vram;
+
+  uint32* output = nullptr;
+
+  struct {
+    bool interlace;
+    bool overscan;
+  } display;
+
+  auto scanline() -> void;
+  auto frame() -> void;
+  auto refresh() -> void;
+
+  struct {
+    uint version;
+    uint8 mdr;
+  } ppu1, ppu2;
+
+  auto renderLine() -> void;
+
+  struct Latches {
+    uint16 vram;
+    uint8 oam;
+    uint8 cgram;
+    uint8 bgofs;
+    uint8 mode7;
+    uint1 counters;
+    uint1 hcounter;
+    uint1 vcounter;
+
+    uint10 oamAddress;
+    uint8 cgramAddress;
+  } latch;
+
+  struct IO {
+    uint16 bg_y[4];
+
+    //$2100  INIDSP
+    bool displayDisable;
+    uint4 displayBrightness;
+
+    //$2102  OAMADDL
+    //$2103  OAMADDH
+    uint10 oamBaseAddress;
+    uint10 oamAddress;
+    bool oamPriority;
+
+    //$2105  BGMODE
+    bool bgPriority;
+    uint8 bgMode;
+
+    //$2106  MOSAIC
+    uint16 mosaicCountdown;
+
+    //$210d  BG1HOFS
+    uint16 hoffsetMode7;
+
+    //$210e  BG1VOFS
+    uint16 voffsetMode7;
+
+    //$2115  VMAIN
+    bool vramIncrementMode;
+    uint8 vramMapping;
+    uint8 vramIncrementSize;
+
+    //$2116  VMADDL
+    //$2117  VMADDH
+    uint16 vramAddress;
+
+    //$211a  M7SEL
+    uint8 repeatMode7;
+    bool vflipMode7;
+    bool hflipMode7;
+
+    //$211b  M7A
+    uint16 m7a;
+
+    //$211c  M7B
+    uint16 m7b;
+
+    //$211d  M7C
+    uint16 m7c;
+
+    //$211e  M7D
+    uint16 m7d;
+
+    //$211f  M7X
+    uint16 m7x;
+
+    //$2120  M7Y
+    uint16 m7y;
+
+    //$2121  CGADD
+    uint8 cgramAddress;
+    uint1 cgramAddressLatch;
+
+    //$2132  COLDATA
+    uint16 color_rgb;
+
+    //$2133  SETINI
+    //overscan and interlace are checked once per frame to
+    //determine if entire frame should be interlaced/non-interlace
+    //and overscan adjusted. therefore, the variables act sort of
+    //like a buffer, but they do still affect internal rendering
+    bool extbg;
+    bool pseudoHires;
+    bool overscan;
+    bool interlace;
+
+    //$213c  OPHCT
+    uint16 hcounter;
+
+    //$213d  OPVCT
+    uint16 vcounter;
+  } io;
+
+  uint line;
+
+  struct {
+    //$2101
+    uint8  obj_baseSize;
+    uint8  obj_nameselect;
+    uint16 obj_tiledataAddress;
+
+    //$210d-$210e
+    uint16 hoffsetMode7, voffsetMode7;
+
+    //$211b-$2120
+    uint16 m7a, m7b, m7c, m7d, m7x, m7y;
+  } cache;
+
+  uint16 mosaicTable[16][4096];
+
+  #include "background/background.hpp"
+  #include "screen/screen.hpp"
+  #include "object/object.hpp"
+  #include "window/window.hpp"
+  #include "render/render.hpp"
+
+  Background bg1;
+  Background bg2;
+  Background bg3;
+  Background bg4;
+  Object obj;
+  Window window;
+  Screen screen;
+
+  friend class PPU::Background;
+  friend class PPU::Object;
+  friend class PPU::Window;
+  friend class PPU::Screen;
+  friend class System;
+};
+
+extern PPU ppu;
diff --git a/nSide/higan/sfc-balanced/ppu/render/bg.cpp b/nSide/higan/sfc-balanced/ppu/render/bg.cpp
new file mode 100644
index 0000000..627ae81
--- /dev/null
+++ b/nSide/higan/sfc-balanced/ppu/render/bg.cpp
@@ -0,0 +1,339 @@
+//called once at the start of every rendered scanline
+auto PPU::updateBGInfo() -> void {
+  const uint hires = io.bgMode == 5 || io.bgMode == 6;
+  const uint width = !hires ? 256 : 512;
+
+  auto bg = &bg1;
+  for(uint bg_id = Background::ID::BG1; bg_id <= Background::ID::BG4; bg_id++) {
+    switch(bg_id) {
+    case Background::ID::BG1: bg = &bg1; break;
+    case Background::ID::BG2: bg = &bg2; break;
+    case Background::ID::BG3: bg = &bg3; break;
+    case Background::ID::BG4: bg = &bg4; break;
+    }
+
+    bg_info[bg_id].tileHeight = bg->io.tileSize ? 4 : 3;
+    bg_info[bg_id].tileWidth = hires ? 4 : (uint)bg_info[bg_id].tileHeight;
+
+    bg_info[bg_id].maskX = bg_info[bg_id].tileHeight == 4 ? width << 1 : width;
+    bg_info[bg_id].maskY = bg_info[bg_id].maskX;
+    if(bg->io.screenSize & 0x01) bg_info[bg_id].maskX <<= 1;
+    if(bg->io.screenSize & 0x02) bg_info[bg_id].maskY <<= 1;
+    bg_info[bg_id].maskX--;
+    bg_info[bg_id].maskY--;
+
+    bg_info[bg_id].screenX = bg->io.screenSize & 0x01 ? 32 << 5 : 0;
+    bg_info[bg_id].screenY = bg->io.screenSize & 0x02 ? 32 << 5 : 0;
+    if(bg->io.screenSize == Background::ScreenSize::Size64x64) bg_info[bg_id].screenY <<= 1;
+  }
+}
+
+template<uint bg_id>
+auto PPU::bg_renderLine() -> void {
+  if(io.bgMode == 7) return bg_renderLineMode7<bg_id>();
+  Background& bg = (
+  bg_id == Background::ID::BG1 ? bg1 :
+  bg_id == Background::ID::BG2 ? bg2 :
+  bg_id == Background::ID::BG3 ? bg3 :
+                                 bg4
+  );
+  if(bg.io.mode == Background::Mode::Inactive) return;
+  if(bg.io.priority[0] + bg.io.priority[1] == 0) return;
+  if(!bg.io.aboveEnable && !bg.io.belowEnable) return;
+
+  const uint16 validMask = bg_id == Background::ID::BG1 ? 0x2000 : 0x4000;
+
+  const uint paletteOffset = (io.bgMode == 0 ? bg_id << 5 : 0);
+  const uint paletteSize = 2 << bg.io.mode;
+  const uint tileMask = ppu.vram.mask >> (3 + bg.io.mode);
+  const uint tiledataIndex = bg.io.tiledataAddress >> (3 + bg.io.mode);
+
+  const uint8* bg_tiledata  = tiledataCache.tiledata[bg.io.mode];
+  const uint8* bg_tilestate = tiledataCache.tiledataState[bg.io.mode];
+
+  const uint8  tileWidth  = bg_info[bg_id].tileWidth;
+  const uint8  tileHeight = bg_info[bg_id].tileHeight;
+  const uint16 maskX      = bg_info[bg_id].maskX;
+  const uint16 maskY      = bg_info[bg_id].maskY;
+
+  bg.y           = io.bg_y[bg_id];
+  uint16 hscroll = bg.io.hoffset;
+  uint16 vscroll = bg.io.voffset;
+
+  const uint hires = io.bgMode == 5 || io.bgMode == 6;
+  const uint width = 256 << hires;
+
+  if(hires) {
+    hscroll <<= 1;
+    if(io.interlace) bg.y = (bg.y << 1) + field();
+  }
+
+  uint16 hval, vval;
+  uint16 hoffset, voffset, offsetX, col;
+  bool   mirrorX, mirrorY;
+
+  const uint8*  tile_ptr;
+  const uint16* mtable = mosaicTable[bg.io.mosaic];
+  const bool isOPTMode = io.bgMode == 2 || io.bgMode == 4 || io.bgMode == 6;
+  const bool isDirectColorMode = screen.io.directColor && bg_id == Background::ID::BG1 && (io.bgMode == 3 || io.bgMode == 4);
+
+  buildWindowTables(bg_id);
+  const uint8* wt_above = windowCache[bg_id].above;
+  const uint8* wt_below = windowCache[bg_id].below;
+
+  uint16 prev_x = 0xffff, prev_y = 0xffff, prev_optx = 0xffff;
+  for(uint16 x : range(width)) {
+    hoffset = mtable[x] + hscroll;
+    voffset = bg.y + vscroll;
+
+    if(isOPTMode) {
+      offsetX = (x + (hscroll & 7));
+
+      //tile 0 is unaffected by offset-per-tile mode...
+      if(offsetX >= 8) {
+
+        //cache tile data in hval, vval if possible
+        if((offsetX >> 3) != (prev_optx >> 3)) {
+          prev_optx = offsetX;
+
+          hval = bg3.getTile((offsetX - 8) + (bg3.io.hoffset & ~7), bg3.io.voffset);
+          if(io.bgMode != 4) {
+            vval = bg3.getTile((offsetX - 8) + (bg3.io.hoffset & ~7), bg3.io.voffset + 8);
+          }
+        }
+
+        if(io.bgMode == 4) {
+          if(hval & validMask) {
+            if(!(hval & 0x8000)) {
+              hoffset = offsetX + (hval & ~7);
+            } else {
+              voffset = bg.y + hval;
+            }
+          }
+        } else {
+          if(hval & validMask) {
+            hoffset = offsetX + (hval & ~7);
+          }
+          if(vval & validMask) {
+            voffset = bg.y + vval;
+          }
+        }
+      }
+    }
+
+    hoffset &= maskX;
+    voffset &= maskY;
+
+    if(hoffset >> 3 != prev_x || voffset >> 3 != prev_y) {
+      prev_x = hoffset >> 3;
+      prev_y = voffset >> 3;
+
+      bg.tile = bg.getTile((uint)hoffset, (uint)voffset);  //format = vhopppcc cccccccc
+      mirrorY = bg.tile & 0x8000;
+      mirrorX = bg.tile & 0x4000;
+      bg.priority = bg.io.priority[(bg.tile & 0x2000) >> 13];
+      bg.paletteNumber = (bg.tile >> 10) & 7;
+      bg.paletteIndex = paletteOffset + (bg.paletteNumber << paletteSize);
+
+      if(tileWidth  == 4) {  //16x16 horizontal tile mirroring
+        if((bool)(hoffset & 8) != mirrorX) bg.tile++;
+      }
+
+      if(tileHeight == 4) {  //16x16 vertical tile mirroring
+        if((bool)(voffset & 8) != mirrorY) bg.tile += 16;
+      }
+
+      uint16 character = ((bg.tile & 0x03ff) + tiledataIndex) & tileMask;
+
+      if(bg_tilestate[character] == 1) {
+        renderBGTile(bg.io.mode, character);
+      }
+
+      if(mirrorY) voffset ^= 7;  //invert y tile pos
+      tile_ptr = bg_tiledata + (character * 64) + ((voffset & 7) * 8);
+    }
+
+    if(mirrorX) hoffset ^= 7;  //invert x tile pos
+    col = *(tile_ptr + (hoffset & 7));
+    if(col) {
+      if(isDirectColorMode) {
+        col = screen.directColor(col, bg.tile);
+      } else {
+        col = screen.paletteColor(col + bg.paletteIndex);
+      }
+
+      #define setpixel_above(x) \
+        if(pixelCache[x].abovePriority < bg.priority) { \
+          pixelCache[x].abovePriority = bg.priority; \
+          pixelCache[x].aboveLayer = bg_id; \
+          pixelCache[x].aboveColor = col; \
+          pixelCache[x].aboveColorExemption = false; \
+        }
+
+      #define setpixel_below(x) \
+        if(pixelCache[x].belowPriority < bg.priority) { \
+          pixelCache[x].belowPriority = bg.priority; \
+          pixelCache[x].belowLayer = bg_id; \
+          pixelCache[x].belowColor = col; \
+          pixelCache[x].belowColorExemption = false; \
+        }
+      if(!hires) {
+        if(bg.io.aboveEnable && !wt_above[x]) { setpixel_above(x); }
+        if(bg.io.belowEnable && !wt_below[x]) { setpixel_below(x); }
+      } else {
+        int hx = x >> 1;
+        if(x & 1) {
+          if(bg.io.aboveEnable && !wt_above[hx]) { setpixel_above(hx); }
+        } else {
+          if(bg.io.belowEnable && !wt_below[hx]) { setpixel_below(hx); }
+        }
+      }
+      #undef setpixel_above
+      #undef setpixel_below
+    }
+  }
+}
+
+//higan mode7 renderer
+//
+//base algorithm written by anomie
+//higan implementation written by byuu
+//
+//supports mode 7 + extbg + rotate + zoom + direct color + scrolling + m7sel + windowing + mosaic
+//interlace and pseudo-hires support are automatic via main rendering routine
+
+template<uint bg_id>
+auto PPU::bg_renderLineMode7() -> void {
+  Background& bg = (
+  bg_id == Background::ID::BG1 ? bg1 :
+  bg_id == Background::ID::BG2 ? bg2 :
+  bg_id == Background::ID::BG3 ? bg3 :
+                                 bg4
+  );
+  if(bg.io.mode == Background::Mode::Inactive) return;
+  if(bg.io.priority[0] + bg.io.priority[1] == 0) return;
+  if(!bg.io.aboveEnable && !bg.io.belowEnable) return;
+
+  int32 px, py;
+  int32 tx, ty, tile, palette;
+
+  int32 a = sclip<16>(cache.m7a);
+  int32 b = sclip<16>(cache.m7b);
+  int32 c = sclip<16>(cache.m7c);
+  int32 d = sclip<16>(cache.m7d);
+
+  int32 cx   = sclip<13>(cache.m7x);
+  int32 cy   = sclip<13>(cache.m7y);
+  int32 hofs = sclip<13>(cache.hoffsetMode7);
+  int32 vofs = sclip<13>(cache.voffsetMode7);
+
+  int  _pri, _x;
+
+  buildWindowTables(bg_id);
+  uint8* wt_above = windowCache[bg_id].above;
+  uint8* wt_below = windowCache[bg_id].below;
+
+  bg.y = !io.vflipMode7 ? line : 255 - line;
+
+  uint16* mtable_x;
+  uint16* mtable_y;
+  if(bg_id == Background::ID::BG1) {
+    mtable_x = (uint16*)mosaicTable[bg1.io.mosaic];
+    mtable_y = (uint16*)mosaicTable[bg1.io.mosaic];
+  } else {  //bg_id == Background::ID::BG2
+    //Mode7 EXTBG BG2 uses BG1 mosaic enable to control vertical mosaic,
+    //and BG2 mosaic enable to control horizontal mosaic...
+    mtable_x = (uint16*)mosaicTable[bg2.io.mosaic];
+    mtable_y = (uint16*)mosaicTable[bg1.io.mosaic];
+  }
+
+  //13-bit sign extend
+  //--s---vvvvvvvvvv -> ssssssvvvvvvvvvv
+  #define CLIP(x) ( (x) & 0x2000 ? (x) | ~0x03ff : (x) & 0x03ff )
+
+  int32 psx = ((a * CLIP(hofs - cx)) & ~63) + ((b * CLIP(vofs - cy)) & ~63) + ((b * mtable_y[bg.y]) & ~63) + (cx << 8);
+  int32 psy = ((c * CLIP(hofs - cx)) & ~63) + ((d * CLIP(vofs - cy)) & ~63) + ((d * mtable_y[bg.y]) & ~63) + (cy << 8);
+
+  #undef CLIP
+
+  for(int32 x = 0; x < 256; x++) {
+    px = psx + (a * mtable_x[x]);
+    py = psy + (c * mtable_x[x]);
+
+    //mask floating-point bits (low 8 bits)
+    px >>= 8;
+    py >>= 8;
+
+    switch(io.repeatMode7) {
+    //screen repetition outside of screen area
+    case 0:
+    case 1:
+      px &= 1023;
+      py &= 1023;
+      tile = vram[(py >> 3) * 128 + (px >> 3)].byte(0);
+      palette = vram[(tile << 6) + ((py & 7) << 3) + (px & 7)].byte(1);
+      break;
+
+    //palette color 0 outside of screen area
+    case 2: 
+      if((px | py) & ~1023) {
+        palette = 0;
+      } else {
+        px &= 1023;
+        py &= 1023;
+        tile = vram[(py >> 3) * 128 + (px >> 3)].byte(0);
+        palette = vram[(tile << 6) + ((py & 7) << 3) + (px & 7)].byte(1);
+      }
+      break;
+
+    //character 0 repetition outside of screen area
+    case 3:
+      if((px | py) & ~1023) {
+        tile = 0;
+      } else {
+        px &= 1023;
+        py &= 1023;
+        tile = vram[(py >> 3) * 128 + (px >> 3)].byte(0);
+      }
+      palette = vram[(tile << 6) + ((py & 7) << 3) + (px & 7)].byte(1);
+      break;
+
+    }
+
+    if(bg_id == Background::ID::BG1) {
+      _pri = bg.io.priority[0];
+    } else {
+      _pri = bg.io.priority[(palette >> 7) ? 1 : 0];
+      palette &= 0x7f;
+    }
+
+    if(!palette) continue;
+
+    _x = !io.hflipMode7 ? (uint)x : 255 - x;
+
+    uint32 col;
+    if(screen.io.directColor && bg_id == Background::ID::BG1) {
+      //direct color mode does not apply to bg2, as it is only 128 colors...
+      col = screen.directColor(palette, 0);
+    } else {
+      col = screen.paletteColor(palette);
+    }
+
+    if(bg.io.aboveEnable && !wt_above[_x]) {
+      if(pixelCache[_x].abovePriority < _pri) {
+        pixelCache[_x].abovePriority = _pri;
+        pixelCache[_x].aboveLayer = bg_id;
+        pixelCache[_x].aboveColor = col;
+        pixelCache[_x].aboveColorExemption = false;
+      }
+    }
+    if(bg.io.belowEnable && !wt_below[_x]) {
+      if(pixelCache[_x].belowPriority < _pri) {
+        pixelCache[_x].belowPriority = _pri;
+        pixelCache[_x].belowLayer = bg_id;
+        pixelCache[_x].belowColor = col;
+        pixelCache[_x].belowColorExemption = false;
+      }
+    }
+  }
+}
diff --git a/nSide/higan/sfc-balanced/ppu/render/cache.cpp b/nSide/higan/sfc-balanced/ppu/render/cache.cpp
new file mode 100644
index 0000000..ac50c22
--- /dev/null
+++ b/nSide/higan/sfc-balanced/ppu/render/cache.cpp
@@ -0,0 +1,136 @@
+auto PPU::renderBGTile(uint colorDepth, uint16 tile_num) -> void {
+  uint8 col, d0, d1, d2, d3, d4, d5, d6, d7;
+
+  uint8* dest = (uint8*)tiledataCache.tiledata[colorDepth] + tile_num * (8 * 8);
+  uint y = 8;
+
+  #define renderBGTile_line_2bpp(mask) \
+    col  = !!(d0 & mask) << 0; \
+    col += !!(d1 & mask) << 1; \
+    *dest++ = col
+
+  #define renderBGTile_line_4bpp(mask) \
+    col  = !!(d0 & mask) << 0; \
+    col += !!(d1 & mask) << 1; \
+    col += !!(d2 & mask) << 2; \
+    col += !!(d3 & mask) << 3; \
+    *dest++ = col
+
+  #define renderBGTile_line_8bpp(mask) \
+    col  = !!(d0 & mask) << 0; \
+    col += !!(d1 & mask) << 1; \
+    col += !!(d2 & mask) << 2; \
+    col += !!(d3 & mask) << 3; \
+    col += !!(d4 & mask) << 4; \
+    col += !!(d5 & mask) << 5; \
+    col += !!(d6 & mask) << 6; \
+    col += !!(d7 & mask) << 7; \
+    *dest++ = col
+
+  if(colorDepth == Background::Mode::BPP2) {
+    uint pos = tile_num * 8;
+    while(y--) {
+      d0 = vram[pos +  0].byte(0);
+      d1 = vram[pos +  0].byte(1);
+      renderBGTile_line_2bpp(0x80);
+      renderBGTile_line_2bpp(0x40);
+      renderBGTile_line_2bpp(0x20);
+      renderBGTile_line_2bpp(0x10);
+      renderBGTile_line_2bpp(0x08);
+      renderBGTile_line_2bpp(0x04);
+      renderBGTile_line_2bpp(0x02);
+      renderBGTile_line_2bpp(0x01);
+      pos++;
+    }
+  }
+
+  if(colorDepth == Background::Mode::BPP4) {
+    uint pos = tile_num * 16;
+    while(y--) {
+      d0 = vram[pos +  0].byte(0);
+      d1 = vram[pos +  0].byte(1);
+      d2 = vram[pos +  8].byte(0);
+      d3 = vram[pos +  8].byte(1);
+      renderBGTile_line_4bpp(0x80);
+      renderBGTile_line_4bpp(0x40);
+      renderBGTile_line_4bpp(0x20);
+      renderBGTile_line_4bpp(0x10);
+      renderBGTile_line_4bpp(0x08);
+      renderBGTile_line_4bpp(0x04);
+      renderBGTile_line_4bpp(0x02);
+      renderBGTile_line_4bpp(0x01);
+      pos++;
+    }
+  }
+
+  if(colorDepth == Background::Mode::BPP8) {
+    uint pos = tile_num * 32;
+    while(y--) {
+      d0 = vram[pos +  0].byte(0);
+      d1 = vram[pos +  0].byte(1);
+      d2 = vram[pos +  8].byte(0);
+      d3 = vram[pos +  8].byte(1);
+      d4 = vram[pos + 16].byte(0);
+      d5 = vram[pos + 16].byte(1);
+      d6 = vram[pos + 24].byte(0);
+      d7 = vram[pos + 24].byte(1);
+      renderBGTile_line_8bpp(0x80);
+      renderBGTile_line_8bpp(0x40);
+      renderBGTile_line_8bpp(0x20);
+      renderBGTile_line_8bpp(0x10);
+      renderBGTile_line_8bpp(0x08);
+      renderBGTile_line_8bpp(0x04);
+      renderBGTile_line_8bpp(0x02);
+      renderBGTile_line_8bpp(0x01);
+      pos++;
+    }
+  }
+
+  tiledataCache.tiledataState[colorDepth][tile_num] = 0;
+
+  #undef renderBGTile_line_2bpp
+  #undef renderBGTile_line_4bpp
+  #undef renderBGTile_line_8bpp
+}
+
+auto PPU::flushPixelCache() -> void {
+  uint16 above = screen.cgram[0];
+  uint16 below = (io.pseudoHires || io.bgMode == 5 || io.bgMode == 6) ? above : io.color_rgb;
+
+  uint i = 255;
+  do {
+    pixelCache[i].aboveColor = above;
+    pixelCache[i].belowColor = below;
+    pixelCache[i].aboveLayer = Screen::ID::BACK;
+    pixelCache[i].belowLayer = Screen::ID::BACK;
+    pixelCache[i].aboveColorExemption = false;
+    pixelCache[i].belowColorExemption = false;
+    pixelCache[i].abovePriority = 0;
+    pixelCache[i].belowPriority = 0;
+  } while(i--);
+}
+
+auto PPU::TiledataCache::allocate() -> void {
+  tiledata[Background::Mode::BPP2]      = new uint8[8192 * 64];
+  tiledata[Background::Mode::BPP4]      = new uint8[4096 * 64];
+  tiledata[Background::Mode::BPP8]      = new uint8[2048 * 64];
+  tiledataState[Background::Mode::BPP2] = new uint8[8192];
+  tiledataState[Background::Mode::BPP4] = new uint8[4096];
+  tiledataState[Background::Mode::BPP8] = new uint8[2048];
+}
+
+//marks all tiledata cache entries as dirty
+auto PPU::TiledataCache::flush() -> void {
+  for(uint i : range(8192)) tiledataState[Background::Mode::BPP2][i] = 1;
+  for(uint i : range(4096)) tiledataState[Background::Mode::BPP4][i] = 1;
+  for(uint i : range(2048)) tiledataState[Background::Mode::BPP8][i] = 1;
+}
+
+auto PPU::TiledataCache::free() -> void {
+  delete[] tiledata[Background::Mode::BPP2];
+  delete[] tiledata[Background::Mode::BPP4];
+  delete[] tiledata[Background::Mode::BPP8];
+  delete[] tiledataState[Background::Mode::BPP2];
+  delete[] tiledataState[Background::Mode::BPP4];
+  delete[] tiledataState[Background::Mode::BPP8];
+}
diff --git a/nSide/higan/sfc-balanced/ppu/render/line.cpp b/nSide/higan/sfc-balanced/ppu/render/line.cpp
new file mode 100644
index 0000000..4cd49a9
--- /dev/null
+++ b/nSide/higan/sfc-balanced/ppu/render/line.cpp
@@ -0,0 +1,116 @@
+inline auto PPU::getPixelBelow(uint32 x) -> uint16 {
+  CachePixel& p = pixelCache[x];
+  uint15 aboveColor, belowColor;
+  uint8 aboveLayer;
+
+  belowColor = p.belowColor;
+
+  if(!screen.io.blendMode) {
+    aboveLayer = Screen::ID::BACK;
+    aboveColor = io.color_rgb;
+  } else {
+    aboveLayer = p.aboveLayer;
+    aboveColor = p.aboveColor;
+  }
+
+  if(!windowCache[Window::ID::COL].above[x]) {
+    if(!windowCache[Window::ID::COL].below[x]) {
+      return 0x0000;
+    }
+    belowColor = 0x0000;
+  }
+
+  bool colorEnable;
+  switch(p.belowLayer) {
+  case Background::ID::BG1: colorEnable = screen.io.bg1.colorEnable; break;
+  case Background::ID::BG2: colorEnable = screen.io.bg2.colorEnable; break;
+  case Background::ID::BG3: colorEnable = screen.io.bg3.colorEnable; break;
+  case Background::ID::BG4: colorEnable = screen.io.bg4.colorEnable; break;
+  case Object::ID::OBJ:     colorEnable = screen.io.obj.colorEnable; break;
+  case Screen::ID::BACK:    colorEnable = screen.io.back.colorEnable; break;
+  }
+
+  if(!p.belowColorExemption && colorEnable && windowCache[Window::ID::COL].below[x]) {
+    screen.math.colorHalve = false;
+    if(screen.io.colorHalve && windowCache[Window::ID::COL].above[x]) {
+      if(screen.io.blendMode == 0 || aboveLayer != Screen::ID::BACK) {
+        screen.math.colorHalve = true;
+      }
+    }
+    return screen.blend(belowColor, aboveColor);
+  }
+
+  return belowColor;
+}
+
+inline auto PPU::getPixelAbove(uint32 x) -> uint16 {
+  CachePixel& p = pixelCache[x];
+  uint15 aboveColor, belowColor;
+  uint8 belowLayer;
+
+  aboveColor = p.aboveColor;
+
+  if(!screen.io.blendMode) {
+    belowLayer = Screen::ID::BACK;
+    belowColor = io.color_rgb;
+  } else {
+    belowLayer = p.belowLayer;
+    belowColor = p.belowColor;
+  }
+
+  if(!windowCache[Window::ID::COL].above[x]) {
+    if(!windowCache[Window::ID::COL].below[x]) {
+      return 0x0000;
+    }
+    aboveColor = 0x0000;
+  }
+
+  bool colorEnable;
+  switch(p.aboveLayer) {
+  case Background::ID::BG1: colorEnable = screen.io.bg1.colorEnable; break;
+  case Background::ID::BG2: colorEnable = screen.io.bg2.colorEnable; break;
+  case Background::ID::BG3: colorEnable = screen.io.bg3.colorEnable; break;
+  case Background::ID::BG4: colorEnable = screen.io.bg4.colorEnable; break;
+  case Object::ID::OBJ:     colorEnable = screen.io.obj.colorEnable; break;
+  case Screen::ID::BACK:    colorEnable = screen.io.back.colorEnable; break;
+  }
+
+  if(!p.aboveColorExemption && colorEnable && windowCache[Window::ID::COL].below[x]) {
+    screen.math.colorHalve = false;
+    if(screen.io.colorHalve && windowCache[Window::ID::COL].above[x]) {
+      if(screen.io.blendMode == 0 || belowLayer != Screen::ID::BACK) {
+        screen.math.colorHalve = true;
+      }
+    }
+    return screen.blend(aboveColor, belowColor);
+  }
+
+  return aboveColor;
+}
+
+inline auto PPU::renderLineOutput() -> void {
+  uint32* lineA = output + line * 1024;
+  uint32* lineB = lineA + (interlace() ? 0 : 512);
+  if(interlace() && field()) lineA += 512, lineB += 512;
+
+  if(!io.pseudoHires && io.bgMode != 5 && io.bgMode != 6) {
+    for(uint x : range(256)) {
+      uint color = (io.displayBrightness << 15) | getPixelAbove(x);
+      *lineA++ = *lineB++ = color;
+      *lineA++ = *lineB++ = color;
+    }
+  } else {
+    for(uint x : range(256)) {
+      *lineA++ = *lineB++ = (io.displayBrightness << 15) | getPixelBelow(x);
+      *lineA++ = *lineB++ = (io.displayBrightness << 15) | getPixelAbove(x);
+    }
+  }
+}
+
+inline auto PPU::clearLine() -> void {
+  uint32* lineA = output + line * 1024;
+  uint32* lineB = lineA + (interlace() ? 0 : 512);
+  if(interlace() && field()) lineA += 512, lineB += 512;
+  memory::fill(lineA, 512 * sizeof(uint32));
+  memory::fill(lineB, 512 * sizeof(uint32));
+}
diff --git a/nSide/higan/sfc-balanced/ppu/render/object.cpp b/nSide/higan/sfc-balanced/ppu/render/object.cpp
new file mode 100644
index 0000000..00b693a
--- /dev/null
+++ b/nSide/higan/sfc-balanced/ppu/render/object.cpp
@@ -0,0 +1,156 @@
+auto PPU::isSpriteOnScanline() -> bool {
+  //if sprite is entirely offscreen and doesn't wrap around to the left side of the screen,
+  //then it is not counted. this *should* be 256, and not 255, even though dot 256 is offscreen.
+  OAM::Object* spr = &obj.oam.object[activeSprite];
+  if(spr->x > 256 && (spr->x + spr->width - 1) < 512) return false;
+
+  int spr_height = !obj.io.interlace ? (uint)spr->height : spr->height >> 1;
+  if(line >= spr->y && line < (spr->y + spr_height)) return true;
+  if((spr->y + spr_height) >= 256 && line < ((spr->y + spr_height) & 255)) return true;
+  return false;
+}
+
+auto PPU::obj_loadTiles() -> void {
+  OAM::Object* spr = &obj.oam.object[activeSprite];
+  uint16 tile_width = spr->width >> 3;
+  int x = spr->x;
+  int y = (line - spr->y) & 0xff;
+  if(obj.io.interlace) {
+    y <<= 1;
+  }
+
+  if(spr->vflip) {
+    if(spr->width == spr->height) {
+      y = (spr->height - 1) - y;
+    } else {
+      y = y < spr->width ? (spr->width - 1) - y : spr->width + ((spr->width - 1) - (y - spr->width));
+    }
+  }
+
+  if(obj.io.interlace) {
+    y = !spr->vflip ? y + field() : y - field();
+  }
+
+  x &= 511;
+  y &= 255;
+
+  uint16 tdaddr = cache.obj_tiledataAddress;
+  uint16 chrx   = (spr->character     ) & 15;
+  uint16 chry   = (spr->character >> 4) & 15;
+  if(spr->nameselect) {
+    tdaddr += (256 * 16) + (cache.obj_nameselect << 12);
+  }
+  chry  += (y >> 3);
+  chry  &= 15;
+  chry <<= 4;
+
+  for(uint tx : range(tile_width)) {
+    uint sx = (x + (tx << 3)) & 511;
+    //ignore sprites that are offscreen, x==256 is a special case that loads all tiles in OBJ
+    if(x != 256 && sx >= 256 && (sx + 7) < 512) continue;
+
+    if(obj.t.tileCount++ >= 34) break;
+    uint n = obj.t.tileCount - 1;
+    obj_tileList[n].x        = sx;
+    obj_tileList[n].y        = y;
+    obj_tileList[n].priority = spr->priority;
+    obj_tileList[n].palette  = 128 + (spr->palette << 4);
+    obj_tileList[n].hflip    = spr->hflip;
+
+    uint mx  = !spr->hflip ? tx : (tile_width - 1) - tx;
+    uint pos = tdaddr + ((chry + ((chrx + mx) & 15)) << 4);
+    obj_tileList[n].tile = (pos >> 4) & (ppu.vram.mask >> 4);
+  }
+}
+
+auto PPU::obj_renderTile(uint n) -> void {
+  uint8* obj_tileData      = (uint8*)tiledataCache.tiledata[Background::Mode::BPP4];
+  uint8* obj_tileDataState = (uint8*)tiledataCache.tiledataState[Background::Mode::BPP4];
+
+  if(obj_tileDataState[obj_tileList[n].tile] == 1) {
+    renderBGTile(Background::Mode::BPP4, obj_tileList[n].tile);
+  }
+
+  uint sx = obj_tileList[n].x;
+  uint8* tile_ptr = (uint8*)obj_tileData + (obj_tileList[n].tile << 6) + ((obj_tileList[n].y & 7) << 3);
+  for(uint x : range(8)) {
+    sx &= 511;
+    if(sx < 256) {
+      uint col = *(tile_ptr + (!obj_tileList[n].hflip ? x : 7 - x));
+      if(col) {
+        col += obj_tileList[n].palette;
+        obj_linePalette[sx] = col;
+        obj_linePriority[sx] = obj_tileList[n].priority;
+      }
+    }
+    sx++;
+  }
+}
+
+auto PPU::obj_renderLine_rto() -> void {
+  obj.t.itemCount = 0;
+  obj.t.tileCount = 0;
+
+  memset(obj_linePriority, OBJ_PRI_NONE, 256);
+  memset(obj_itemList, 0xff, 32);
+  for(int s : range(34)) obj_tileList[s].tile = 0xffff;
+
+  for(int s : range(128)) {
+    activeSprite = (s + obj.io.firstSprite) & 127;
+    if(!isSpriteOnScanline()) continue;
+    if(obj.t.itemCount++ >= 32) break;
+    obj_itemList[obj.t.itemCount - 1] = (s + obj.io.firstSprite) & 127;
+  }
+
+  if(obj.t.itemCount > 0 && obj_itemList[obj.t.itemCount - 1] != 0xff) {
+    latch.oamAddress = 0x0200 + (obj_itemList[obj.t.itemCount - 1] >> 2);
+  }
+
+  for(int s = 31; s >= 0; s--) {
+    if(obj_itemList[s] == 0xff) continue;
+    activeSprite = obj_itemList[s];
+    obj_loadTiles();
+  }
+
+  obj.io.timeOver  |= (obj.t.tileCount > 34);
+  obj.io.rangeOver |= (obj.t.itemCount > 32);
+}
+
+auto PPU::obj_renderLine() -> void {
+  if(obj.io.priority[0] + obj.io.priority[1] + obj.io.priority[2] + obj.io.priority[3] == 0) return;
+
+  if(!obj.io.aboveEnable && !obj.io.belowEnable) return;
+
+  for(uint s : range(34)) {
+    if(obj_tileList[s].tile == 0xffff) continue;
+    obj_renderTile(s);
+  }
+
+  buildWindowTables(Object::ID::OBJ);
+  uint8* wt_above = windowCache[Object::ID::OBJ].above;
+  uint8* wt_below = windowCache[Object::ID::OBJ].below;
+
+  #define setPixelAbove(x) \
+    if(pixelCache[x].abovePriority < pri) { \
+      pixelCache[x].abovePriority = pri; \
+      pixelCache[x].aboveLayer = Object::ID::OBJ; \
+      pixelCache[x].aboveColor = screen.cgram[obj_linePalette[x]]; \
+      pixelCache[x].aboveColorExemption = obj_linePalette[x] < 192; \
+    }
+  #define setPixelBelow(x) \
+    if(pixelCache[x].belowPriority < pri) { \
+      pixelCache[x].belowPriority = pri; \
+      pixelCache[x].belowLayer = Object::ID::OBJ; \
+      pixelCache[x].belowColor = screen.cgram[obj_linePalette[x]]; \
+      pixelCache[x].belowColorExemption = obj_linePalette[x] < 192; \
+    }
+  for(int x : range(256)) {
+    if(obj_linePriority[x] == OBJ_PRI_NONE) continue;
+
+    uint pri = obj.io.priority[obj_linePriority[x]];
+    if(obj.io.aboveEnable && !wt_above[x]) { setPixelAbove(x); }
+    if(obj.io.belowEnable && !wt_below[x]) { setPixelBelow(x); }
+  }
+  #undef setPixelAbove
+  #undef setPixelBelow
+}
diff --git a/nSide/higan/sfc-balanced/ppu/render/render.cpp b/nSide/higan/sfc-balanced/ppu/render/render.cpp
new file mode 100644
index 0000000..3f7a36f
--- /dev/null
+++ b/nSide/higan/sfc-balanced/ppu/render/render.cpp
@@ -0,0 +1,63 @@
+#include "cache.cpp"
+#include "windows.cpp"
+#include "bg.cpp"
+#include "object.cpp"
+#include "line.cpp"
+
+//Mode 0: ->
+//     1,    2,    3,    4,    5,    6,    7,    8,    9,   10,   11,   12
+//  BG4B, BG3B, OBJ0, BG4A, BG3A, OBJ1, BG2B, BG1B, OBJ2, BG2A, BG1A, OBJ3
+
+//Mode 1 (pri=1): ->
+//     1,    2,    3,    4,    5,    6,    7,    8,    9,   10
+//  BG3B, OBJ0, OBJ1, BG2B, BG1B, OBJ2, BG2A, BG1A, OBJ3, BG3A
+//
+//Mode 1 (pri=0): ->
+//     1,    2,    3,    4,    5,    6,    7,    8,    9,   10
+//  BG3B, OBJ0, BG3A, OBJ1, BG2B, BG1B, OBJ2, BG2A, BG1A, OBJ3
+
+//Mode 2: ->
+//     1,    2,    3,    4,    5,    6,    7,    8
+//  BG2B, OBJ0, BG1B, OBJ1, BG2A, OBJ2, BG1A, OBJ3
+
+//Mode 3: ->
+//     1,    2,    3,    4,    5,    6,    7,    8
+//  BG2B, OBJ0, BG1B, OBJ1, BG2A, OBJ2, BG1A, OBJ3
+
+//Mode 4: ->
+//     1,    2,    3,    4,    5,    6,    7,    8
+//  BG2B, OBJ0, BG1B, OBJ1, BG2A, OBJ2, BG1A, OBJ3
+
+//Mode 5: ->
+//     1,    2,    3,    4,    5,    6,    7,    8
+//  BG2B, OBJ0, BG1B, OBJ1, BG2A, OBJ2, BG1A, OBJ3
+
+//Mode 6: ->
+//     1,    2,    3,    4,    5,    6
+//  OBJ0, BG1B, OBJ1, OBJ2, BG1A, OBJ3
+
+//Mode7: ->
+//     1,    2,    3,    4,    5
+//  OBJ0, BG1n, OBJ1, OBJ2, OBJ3
+
+//Mode 7 EXTBG: ->
+//     1,    2,    3,    4,    5,    6,    7
+//  BG2B, OBJ0, BG1n, OBJ1, BG2A, OBJ2, OBJ3
+
+auto PPU::renderLine() -> void {
+  if(io.displayDisable || line >= vdisp()) return clearLine();
+
+  flushPixelCache();
+  buildWindowTables(Window::ID::COL);
+  updateBGInfo();
+
+  bg_renderLine<Background::ID::BG1>();
+  bg_renderLine<Background::ID::BG2>();
+  bg_renderLine<Background::ID::BG3>();
+  bg_renderLine<Background::ID::BG4>();
+  obj_renderLine();
+
+  renderLineOutput();
+
+  obj_renderLine_rto();
+}
diff --git a/nSide/higan/sfc-balanced/ppu/render/render.hpp b/nSide/higan/sfc-balanced/ppu/render/render.hpp
new file mode 100644
index 0000000..a84d519
--- /dev/null
+++ b/nSide/higan/sfc-balanced/ppu/render/render.hpp
@@ -0,0 +1,71 @@
+struct CachePixel {
+  //bgr555 color data for main/subscreen pixels: 0x0000 = transparent / use palette color # 0
+  //needs to be bgr555 instead of palette index for direct color mode ($2130 bit 0) to work
+  uint15 aboveColor, belowColor;
+  //indicates source of palette # for main/subscreen (BG1-4, OBJ, or back)
+  uint8  aboveLayer, belowLayer;
+  //color_exemption -- true when bg == OBJ && palette index >= 192, disables color blend effects
+  uint8  aboveColorExemption, belowColorExemption;
+  //priority level of src_n. to set src_n,
+  //the priority of the pixel must be >pri_n
+  uint8  abovePriority, belowPriority;
+} pixelCache[256];
+
+struct TiledataCache {
+  uint8* tiledata[3];
+  uint8* tiledataState[3];  //0 = valid, 1 = dirty
+  auto allocate() -> void;
+  auto flush() -> void;
+  auto free() -> void;
+} tiledataCache;
+
+auto renderBGTile(uint colorDepth, uint16 tile_num) -> void;
+inline auto flushPixelCache() -> void;
+
+//windows.cpp
+struct CacheWindow {
+  uint8 above[256], below[256];
+} windowCache[6];
+
+auto buildWindowTable(uint bg_id, bool screen) -> void;
+auto buildWindowTables(uint bg_id) -> void;
+
+//bg.cpp
+struct BGInfo {  //only needed because of offset-per-tile mode
+  uint16 tileWidth, tileHeight;
+  uint16 maskX,     maskY;
+  uint16 screenX,   screenY;
+} bg_info[4];
+auto updateBGInfo() -> void;
+
+template<uint bg_id> auto bg_renderLine() -> void;
+template<uint bg_id> auto bg_renderLineMode7() -> void;
+
+//object.cpp
+uint activeSprite;
+
+uint8 obj_itemList[32];
+struct obj_tileItem {
+  uint16 x;
+  uint16 y;
+  uint16 priority;
+  uint16 palette;
+  bool   hflip;
+  uint16 tile;
+} obj_tileList[34];
+
+const uint8 OBJ_PRI_NONE = ~1;
+uint8 obj_linePalette[256], obj_linePriority[256];
+
+auto updateSpriteList(uint addr, uint8 data) -> void;
+auto isSpriteOnScanline() -> bool;
+auto obj_loadTiles() -> void;
+auto obj_renderTile(uint n) -> void;
+auto obj_renderLine_rto() -> void;
+auto obj_renderLine() -> void;
+
+//line.cpp
+inline auto getPixelBelow(uint32 x) -> uint16;
+inline auto getPixelAbove(uint32 x) -> uint16;
+auto renderLineOutput() -> void;
+auto clearLine() -> void;
diff --git a/nSide/higan/sfc-balanced/ppu/render/windows.cpp b/nSide/higan/sfc-balanced/ppu/render/windows.cpp
new file mode 100644
index 0000000..df01c48
--- /dev/null
+++ b/nSide/higan/sfc-balanced/ppu/render/windows.cpp
@@ -0,0 +1,133 @@
+auto PPU::buildWindowTable(uint bg_id, bool screen) -> void {
+  bool set = 1, clr = 0;
+  uint8* table = screen == Background::Screen::Above ? windowCache[bg_id].above : windowCache[bg_id].below;
+
+  if(bg_id != Window::ID::COL) {
+    bool window_aboveEnable;
+    bool window_belowEnable;
+    switch(bg_id) {
+    case Background::ID::BG1:
+      window_aboveEnable = window.io.bg1.aboveEnable;
+      window_belowEnable = window.io.bg1.belowEnable;
+      break;
+    case Background::ID::BG2:
+      window_aboveEnable = window.io.bg2.aboveEnable;
+      window_belowEnable = window.io.bg2.belowEnable;
+      break;
+    case Background::ID::BG3:
+      window_aboveEnable = window.io.bg3.aboveEnable;
+      window_belowEnable = window.io.bg3.belowEnable;
+      break;
+    case Background::ID::BG4:
+      window_aboveEnable = window.io.bg4.aboveEnable;
+      window_belowEnable = window.io.bg4.belowEnable;
+      break;
+    case Object::ID::OBJ:
+      window_aboveEnable = window.io.obj.aboveEnable;
+      window_belowEnable = window.io.obj.belowEnable;
+      break;
+    }
+    if(screen == Background::Screen::Above && !window_aboveEnable) {
+      memset(table, 0, 256);
+      return;
+    }
+    if(screen == Background::Screen::Below && !window_belowEnable) {
+      memset(table, 0, 256);
+      return;
+    }
+  } else {
+    switch(screen == Background::Screen::Above ? window.io.col.aboveMask : window.io.col.belowMask) {
+    case 0: memset(table, 1, 256); return;  //always
+    case 3: memset(table, 0, 256); return;  //never
+    case 1: set = 1, clr = 0; break;        //inside window only
+    case 2: set = 0, clr = 1; break;        //outside window only
+    }
+  }
+
+  bool window_oneEnable;
+  bool window_oneInvert;
+  bool window_twoEnable;
+  bool window_twoInvert;
+  uint2 window_mask;
+  switch(bg_id) {
+  case Background::ID::BG1:
+    window_oneEnable = window.io.bg1.oneEnable;
+    window_oneInvert = window.io.bg1.oneInvert;
+    window_twoEnable = window.io.bg1.twoEnable;
+    window_twoInvert = window.io.bg1.twoInvert;
+    window_mask = window.io.bg1.mask;
+    break;
+  case Background::ID::BG2:
+    window_oneEnable = window.io.bg2.oneEnable;
+    window_oneInvert = window.io.bg2.oneInvert;
+    window_twoEnable = window.io.bg2.twoEnable;
+    window_twoInvert = window.io.bg2.twoInvert;
+    window_mask = window.io.bg2.mask;
+    break;
+  case Background::ID::BG3:
+    window_oneEnable = window.io.bg3.oneEnable;
+    window_oneInvert = window.io.bg3.oneInvert;
+    window_twoEnable = window.io.bg3.twoEnable;
+    window_twoInvert = window.io.bg3.twoInvert;
+    window_mask = window.io.bg3.mask;
+    break;
+  case Background::ID::BG4:
+    window_oneEnable = window.io.bg4.oneEnable;
+    window_oneInvert = window.io.bg4.oneInvert;
+    window_twoEnable = window.io.bg4.twoEnable;
+    window_twoInvert = window.io.bg4.twoInvert;
+    window_mask = window.io.bg4.mask;
+    break;
+  case Object::ID::OBJ:
+    window_oneEnable = window.io.obj.oneEnable;
+    window_oneInvert = window.io.obj.oneInvert;
+    window_twoEnable = window.io.obj.twoEnable;
+    window_twoInvert = window.io.obj.twoInvert;
+    window_mask = window.io.obj.mask;
+    break;
+  case Window::ID::COL:
+    window_oneEnable = window.io.col.oneEnable;
+    window_oneInvert = window.io.col.oneInvert;
+    window_twoEnable = window.io.col.twoEnable;
+    window_twoInvert = window.io.col.twoInvert;
+    window_mask = window.io.col.mask;
+    break;
+  }
+  if(!window_oneEnable && !window_twoEnable) {
+    memset(table, clr, 256);
+    return;
+  }
+
+  if( window_oneEnable && !window_twoEnable) {
+    if(window_oneInvert) set ^= clr ^= set ^= clr;
+    for(uint x : range(256)) {
+      table[x] = (x >= window.io.oneLeft && x <= window.io.oneRight) ? set : clr;
+    }
+    return;
+  }
+
+  if(!window_oneEnable &&  window_twoEnable) {
+    if(window_twoInvert) set ^= clr ^= set ^= clr;
+    for(uint x : range(256)) {
+      table[x] = (x >= window.io.twoLeft && x <= window.io.twoRight) ? set : clr;
+    }
+    return;
+  }
+
+  for(uint x : range(256)) {
+    bool w1_mask = (x >= window.io.oneLeft && x <= window.io.oneRight) ^ window_oneInvert;
+    bool w2_mask = (x >= window.io.twoLeft && x <= window.io.twoRight) ^ window_twoInvert;
+
+    switch(window_mask) {
+    case 0: table[x] = (w1_mask | w2_mask) == 1 ? set : clr; break;  //or
+    case 1: table[x] = (w1_mask & w2_mask) == 1 ? set : clr; break;  //and
+    case 2: table[x] = (w1_mask ^ w2_mask) == 1 ? set : clr; break;  //xor
+    case 3: table[x] = (w1_mask ^ w2_mask) == 0 ? set : clr; break;  //xnor
+    }
+  }
+}
+
+auto PPU::buildWindowTables(uint bg_id) -> void {
+  buildWindowTable(bg_id, Background::Screen::Above);
+  buildWindowTable(bg_id, Background::Screen::Below);
+}
diff --git a/nSide/higan/sfc-balanced/ppu/screen/screen.cpp b/nSide/higan/sfc-balanced/ppu/screen/screen.cpp
new file mode 100644
index 0000000..663f645
--- /dev/null
+++ b/nSide/higan/sfc-balanced/ppu/screen/screen.cpp
@@ -0,0 +1,55 @@
+//color addition / subtraction
+//thanks go to blargg for the optimized algorithms
+auto PPU::Screen::blend(uint x, uint y) const -> uint15 {
+  if(!io.colorMode) {
+    if(!math.colorHalve) {
+      uint sum = x + y;
+      uint carry = (sum - ((x ^ y) & 0x0421)) & 0x8420;
+      return (sum - carry) | (carry - (carry >> 5));
+    } else {
+      return (x + y - ((x ^ y) & 0x0421)) >> 1;
+    }
+  } else {
+    uint diff = x - y + 0x8420;
+    uint borrow = (diff - ((x ^ y) & 0x8420)) & 0x8420;
+    if(!math.colorHalve) {
+      return   (diff - borrow) & (borrow - (borrow >> 5));
+    } else {
+      return (((diff - borrow) & (borrow - (borrow >> 5))) & 0x7bde) >> 1;
+    }
+  }
+}
+
+auto PPU::Screen::paletteColor(uint8 palette) const -> uint15 {
+  ppu.latch.cgramAddress = palette;
+  return cgram[palette];
+}
+
+auto PPU::Screen::directColor(uint8 palette, uint16 tile) const -> uint15 {
+  //palette = -------- BBGGGRRR
+  //tile    = ---bgr-- --------
+  //output  = 0BBb00GG Gg0RRRr0
+  return ((palette << 7) & 0x6000) + ((tile >> 0) & 0x1000)
+       + ((palette << 4) & 0x0380) + ((tile >> 5) & 0x0040)
+       + ((palette << 2) & 0x001c) + ((tile >> 9) & 0x0002);
+}
+
+auto PPU::Screen::fixedColor() const -> uint15 {
+  return io.colorBlue << 10 | io.colorGreen << 5 | io.colorRed << 0;
+}
+
+auto PPU::Screen::reset() -> void {
+  io.blendMode = false;
+  io.directColor = false;
+  io.colorMode = false;
+  io.colorHalve = false;
+  io.bg1.colorEnable = false;
+  io.bg2.colorEnable = false;
+  io.bg3.colorEnable = false;
+  io.bg4.colorEnable = false;
+  io.obj.colorEnable = false;
+  io.back.colorEnable = false;
+  io.colorBlue = 0;
+  io.colorGreen = 0;
+  io.colorRed = 0;
+}
diff --git a/nSide/higan/sfc-balanced/ppu/screen/screen.hpp b/nSide/higan/sfc-balanced/ppu/screen/screen.hpp
new file mode 100644
index 0000000..98537e7
--- /dev/null
+++ b/nSide/higan/sfc-balanced/ppu/screen/screen.hpp
@@ -0,0 +1,41 @@
+struct Screen {
+  auto reset() -> void;
+
+  auto blend(uint x, uint y) const -> uint15;
+  /*alwaysinline*/ auto paletteColor(uint8 palette) const -> uint15;
+  /*alwaysinline*/ auto directColor(uint8 palette, uint16 tile) const -> uint15;
+  /*alwaysinline*/ auto fixedColor() const -> uint15;
+
+  auto serialize(serializer&) -> void;
+
+  struct ID { enum : uint { BACK = 5 }; };
+
+  uint15 cgram[256];
+
+  struct IO {
+    bool blendMode;
+    bool directColor;
+
+    bool colorMode;
+    bool colorHalve;
+    struct Layer {
+      bool colorEnable;
+    } bg1, bg2, bg3, bg4, obj, back;
+
+    uint5 colorBlue;
+    uint5 colorGreen;
+    uint5 colorRed;
+  } io;
+
+  struct Math {
+    //struct Screen {
+    //  uint15 color;
+    //  bool colorEnable;
+    //} above, below;
+    //bool transparent;
+    //bool blendMode;
+    bool colorHalve;
+  } math;
+
+  friend class PPU;
+};
diff --git a/nSide/higan/sfc-balanced/ppu/serialization.cpp b/nSide/higan/sfc-balanced/ppu/serialization.cpp
new file mode 100644
index 0000000..aedd9f6
--- /dev/null
+++ b/nSide/higan/sfc-balanced/ppu/serialization.cpp
@@ -0,0 +1,271 @@
+auto PPUcounter::serialize(serializer& s) -> void {
+  s.integer(status.interlace);
+  s.integer(status.field);
+  s.integer(status.vcounter);
+  s.integer(status.hcounter);
+
+  s.array(history.field);
+  s.array(history.vcounter);
+  s.array(history.hcounter);
+  s.integer(history.index);
+}
+
+auto PPU::serialize(serializer& s) -> void {
+  Thread::serialize(s);
+  PPUcounter::serialize(s);
+
+  s.integer(vram.mask);
+  s.array(vram.data, vram.mask + 1);
+
+  s.integer(ppu1.version);
+  s.integer(ppu1.mdr);
+
+  s.integer(ppu2.version);
+  s.integer(ppu2.mdr);
+
+  s.integer(line);
+
+  s.integer(display.interlace);
+  s.integer(display.overscan);
+
+  s.integer(cache.obj_baseSize);
+  s.integer(cache.obj_nameselect);
+  s.integer(cache.obj_tiledataAddress);
+
+  s.array(io.bg_y);
+
+  s.integer(latch.vram);
+  s.integer(latch.oam);
+  s.integer(latch.cgram);
+  s.integer(latch.bgofs);
+  s.integer(latch.mode7);
+  s.integer(latch.counters);
+  s.integer(latch.hcounter);
+  s.integer(latch.vcounter);
+
+  s.integer(latch.oamAddress);
+  s.integer(latch.cgramAddress);
+
+  s.integer(io.displayDisable);
+  s.integer(io.displayBrightness);
+
+  s.integer(io.oamBaseAddress);
+  s.integer(io.oamAddress);
+  s.integer(io.oamPriority);
+
+  s.integer(io.bgPriority);
+  s.integer(io.bgMode);
+
+  s.integer(io.mosaicCountdown);
+
+  s.integer(io.hoffsetMode7);
+  s.integer(io.voffsetMode7);
+
+  s.integer(io.vramIncrementMode);
+  s.integer(io.vramMapping);
+  s.integer(io.vramIncrementSize);
+
+  s.integer(io.vramAddress);
+
+  s.integer(io.repeatMode7);
+  s.integer(io.vflipMode7);
+  s.integer(io.hflipMode7);
+
+  s.integer(io.m7a);
+  s.integer(io.m7b);
+  s.integer(io.m7c);
+  s.integer(io.m7d);
+  s.integer(io.m7x);
+  s.integer(io.m7y);
+
+  s.integer(io.cgramAddress);
+  s.integer(io.cgramAddressLatch);
+
+  s.integer(io.color_rgb);
+
+  s.integer(io.extbg);
+  s.integer(io.pseudoHires);
+  s.integer(io.overscan);
+  s.integer(io.interlace);
+
+  s.integer(io.hcounter);
+  s.integer(io.vcounter);
+
+  for(uint n : range(256)) {
+    s.integer(pixelCache[n].aboveColor);
+    s.integer(pixelCache[n].belowColor);
+    s.integer(pixelCache[n].aboveLayer);
+    s.integer(pixelCache[n].belowLayer);
+    s.integer(pixelCache[n].aboveColorExemption);
+    s.integer(pixelCache[n].belowColorExemption);
+    s.integer(pixelCache[n].abovePriority);
+    s.integer(pixelCache[n].belowPriority);
+  }
+
+  //better to just take a small speed hit than store all of the tiledata cache ...
+  tiledataCache.flush();
+
+  for(uint n : range(6)) {
+    s.array(windowCache[n].above, 256);
+    s.array(windowCache[n].below, 256);
+  }
+
+  s.integer(activeSprite);
+
+  s.array(obj_itemList, 32);
+
+  for(uint n : range(34)) {
+    s.integer(obj_tileList[n].x);
+    s.integer(obj_tileList[n].y);
+    s.integer(obj_tileList[n].priority);
+    s.integer(obj_tileList[n].palette);
+    s.integer(obj_tileList[n].tile);
+    s.integer(obj_tileList[n].hflip);
+  }
+
+  s.array(obj_linePalette, 256);
+  s.array(obj_linePriority, 256);
+
+  bg1.serialize(s);
+  bg2.serialize(s);
+  bg3.serialize(s);
+  bg4.serialize(s);
+  obj.serialize(s);
+  window.serialize(s);
+  screen.serialize(s);
+}
+
+auto PPU::Background::serialize(serializer& s) -> void {
+  s.integer(io.tiledataAddress);
+  s.integer(io.screenAddress);
+  s.integer(io.screenSize);
+  s.integer(io.mosaic);
+  s.integer(io.tileSize);
+
+  s.integer(io.mode);
+  s.array(io.priority);
+
+  s.integer(io.aboveEnable);
+  s.integer(io.belowEnable);
+
+  s.integer(io.hoffset);
+  s.integer(io.voffset);
+
+  //s.integer(x);
+  s.integer(y);
+
+  //s.integer(tileCounter);
+  s.integer(tile);
+  s.integer(priority);
+  s.integer(paletteNumber);
+  s.integer(paletteIndex);
+  //s.array(data);
+}
+
+auto PPU::Object::serialize(serializer& s) -> void {
+  for(auto& object : oam.object) {
+    s.integer(object.x);
+    s.integer(object.y);
+    s.integer(object.character);
+    s.integer(object.nameselect);
+    s.integer(object.vflip);
+    s.integer(object.hflip);
+    s.integer(object.priority);
+    s.integer(object.palette);
+    s.integer(object.size);
+  }
+
+  s.integer(io.aboveEnable);
+  s.integer(io.belowEnable);
+  s.integer(io.interlace);
+
+  s.integer(io.baseSize);
+  s.integer(io.nameselect);
+  s.integer(io.tiledataAddress);
+  s.integer(io.firstSprite);
+
+  s.array(io.priority);
+
+  s.integer(io.timeOver);
+  s.integer(io.rangeOver);
+
+  s.integer(t.itemCount);
+  s.integer(t.tileCount);
+}
+
+auto PPU::Window::serialize(serializer& s) -> void {
+  s.integer(io.bg1.oneEnable);
+  s.integer(io.bg1.oneInvert);
+  s.integer(io.bg1.twoEnable);
+  s.integer(io.bg1.twoInvert);
+  s.integer(io.bg1.mask);
+  s.integer(io.bg1.aboveEnable);
+  s.integer(io.bg1.belowEnable);
+  
+  s.integer(io.bg2.oneEnable);
+  s.integer(io.bg2.oneInvert);
+  s.integer(io.bg2.twoEnable);
+  s.integer(io.bg2.twoInvert);
+  s.integer(io.bg2.mask);
+  s.integer(io.bg2.aboveEnable);
+  s.integer(io.bg2.belowEnable);
+
+  s.integer(io.bg3.oneEnable);
+  s.integer(io.bg3.oneInvert);
+  s.integer(io.bg3.twoEnable);
+  s.integer(io.bg3.twoInvert);
+  s.integer(io.bg3.mask);
+  s.integer(io.bg3.aboveEnable);
+  s.integer(io.bg3.belowEnable);
+
+  s.integer(io.bg4.oneEnable);
+  s.integer(io.bg4.oneInvert);
+  s.integer(io.bg4.twoEnable);
+  s.integer(io.bg4.twoInvert);
+  s.integer(io.bg4.mask);
+  s.integer(io.bg4.aboveEnable);
+  s.integer(io.bg4.belowEnable);
+
+  s.integer(io.obj.oneEnable);
+  s.integer(io.obj.oneInvert);
+  s.integer(io.obj.twoEnable);
+  s.integer(io.obj.twoInvert);
+  s.integer(io.obj.mask);
+  s.integer(io.obj.aboveEnable);
+  s.integer(io.obj.belowEnable);
+
+  s.integer(io.col.oneEnable);
+  s.integer(io.col.oneInvert);
+  s.integer(io.col.twoEnable);
+  s.integer(io.col.twoInvert);
+  s.integer(io.col.mask);
+  s.integer(io.col.aboveMask);
+  s.integer(io.col.belowMask);
+
+  s.integer(io.oneLeft);
+  s.integer(io.oneRight);
+  s.integer(io.twoLeft);
+  s.integer(io.twoRight);
+}
+
+auto PPU::Screen::serialize(serializer& s) -> void {
+  s.array(cgram);
+
+  s.integer(io.blendMode);
+  s.integer(io.directColor);
+
+  s.integer(io.colorMode);
+  s.integer(io.colorHalve);
+  s.integer(io.bg1.colorEnable);
+  s.integer(io.bg2.colorEnable);
+  s.integer(io.bg3.colorEnable);
+  s.integer(io.bg4.colorEnable);
+  s.integer(io.obj.colorEnable);
+  s.integer(io.back.colorEnable);
+
+  s.integer(io.colorBlue);
+  s.integer(io.colorGreen);
+  s.integer(io.colorRed);
+
+  s.integer(math.colorHalve);
+}
diff --git a/nSide/higan/sfc-balanced/ppu/window/window.cpp b/nSide/higan/sfc-balanced/ppu/window/window.cpp
new file mode 100644
index 0000000..2af5a3c
--- /dev/null
+++ b/nSide/higan/sfc-balanced/ppu/window/window.cpp
@@ -0,0 +1,54 @@
+auto PPU::Window::reset() -> void {
+  io.bg1.oneEnable = false;
+  io.bg1.oneInvert = false;
+  io.bg1.twoEnable = false;
+  io.bg1.twoInvert = false;
+  io.bg1.mask = 0;
+  io.bg1.aboveEnable = false;
+  io.bg1.belowEnable = false;
+
+  io.bg2.oneEnable = false;
+  io.bg2.oneInvert = false;
+  io.bg2.twoEnable = false;
+  io.bg2.twoInvert = false;
+  io.bg2.mask = 0;
+  io.bg2.aboveEnable = false;
+  io.bg2.belowEnable = false;
+
+  io.bg3.oneEnable = false;
+  io.bg3.oneInvert = false;
+  io.bg3.twoEnable = false;
+  io.bg3.twoInvert = false;
+  io.bg3.mask = 0;
+  io.bg3.aboveEnable = false;
+  io.bg3.belowEnable = false;
+
+  io.bg4.oneEnable = false;
+  io.bg4.oneInvert = false;
+  io.bg4.twoEnable = false;
+  io.bg4.twoInvert = false;
+  io.bg4.mask = 0;
+  io.bg4.aboveEnable = false;
+  io.bg4.belowEnable = false;
+
+  io.obj.oneEnable = false;
+  io.obj.oneInvert = false;
+  io.obj.twoEnable = false;
+  io.obj.twoInvert = false;
+  io.obj.mask = 0;
+  io.obj.aboveEnable = false;
+  io.obj.belowEnable = false;
+
+  io.col.oneEnable = false;
+  io.col.oneInvert = false;
+  io.col.twoEnable = false;
+  io.col.twoInvert = false;
+  io.col.mask = 0;
+  io.col.aboveMask = 0;
+  io.col.belowMask = 0;
+
+  io.oneLeft = 0x00;
+  io.oneRight = 0x00;
+  io.twoLeft = 0x00;
+  io.twoRight = 0x00;
+}
diff --git a/nSide/higan/sfc-balanced/ppu/window/window.hpp b/nSide/higan/sfc-balanced/ppu/window/window.hpp
new file mode 100644
index 0000000..be65ff8
--- /dev/null
+++ b/nSide/higan/sfc-balanced/ppu/window/window.hpp
@@ -0,0 +1,36 @@
+struct Window {
+  auto reset() -> void;
+
+  auto serialize(serializer&) -> void;
+
+  struct ID { enum : uint { COL = 5 }; };
+
+  struct IO {
+    struct Layer {
+      bool oneEnable;
+      bool oneInvert;
+      bool twoEnable;
+      bool twoInvert;
+      uint2 mask;
+      bool aboveEnable;
+      bool belowEnable;
+    } bg1, bg2, bg3, bg4, obj;
+
+    struct Color {
+      bool oneEnable;
+      bool oneInvert;
+      bool twoEnable;
+      bool twoInvert;
+      uint2 mask;
+      uint2 aboveMask;
+      uint2 belowMask;
+    } col;
+
+    uint8 oneLeft;
+    uint8 oneRight;
+    uint8 twoLeft;
+    uint8 twoRight;
+  } io;
+
+  friend class PPU;
+};
diff --git a/nSide/higan/sfc-balanced/sfc.hpp b/nSide/higan/sfc-balanced/sfc.hpp
new file mode 100644
index 0000000..87c9991
--- /dev/null
+++ b/nSide/higan/sfc-balanced/sfc.hpp
@@ -0,0 +1,63 @@
+#pragma once
+
+//clone of higan's Super Famicom emulator's balanced profile.
+//Credits for all components excpet for PPU and DSP are available in <sfc/sfc.hpp>.
+// blargg            (Balanced/Performance DSP)
+// hex_usr           (clean-up of Balanced PPU code)
+//license: GPLv3
+//original project started: 2004-10-14
+
+#include <emulator/emulator.hpp>
+#include <emulator/thread.hpp>
+#include <emulator/scheduler.hpp>
+#include <emulator/cheat.hpp>
+
+#include <processor/arm/arm.hpp>
+#include <processor/gsu/gsu.hpp>
+#include <processor/hg51b/hg51b.hpp>
+#include <processor/wdc65816/wdc65816.hpp>
+#include <processor/spc700/spc700.hpp>
+#include <processor/upd96050/upd96050.hpp>
+
+#if defined(SFC_SUPERGAMEBOY)
+  #include <gb/gb.hpp>
+#endif
+
+namespace SuperFamicom {
+  using File = Emulator::File;
+  using Scheduler = Emulator::Scheduler;
+  using Cheat = Emulator::Cheat;
+  extern Scheduler scheduler;
+  extern Cheat cheat;
+
+  struct Thread : Emulator::Thread {
+    auto create(auto (*entrypoint)() -> void, double frequency) -> void {
+      Emulator::Thread::create(entrypoint, frequency);
+      scheduler.append(*this);
+    }
+
+    inline auto synchronize(Thread& thread) -> void {
+      if(clock() >= thread.clock()) scheduler.resume(thread);
+    }
+  };
+
+  #include <sfc-balanced/memory/memory.hpp>
+  #include <sfc-balanced/ppu/counter/counter.hpp>
+
+  #include <sfc-balanced/cpu/cpu.hpp>
+  #include <sfc-balanced/smp/smp.hpp>
+  #include <sfc-balanced/dsp/dsp.hpp>
+  #include <sfc-balanced/ppu/ppu.hpp>
+
+  #include <sfc-balanced/controller/controller.hpp>
+  #include <sfc-balanced/expansion/expansion.hpp>
+  #include <sfc-balanced/system/system.hpp>
+  #include <sfc-balanced/coprocessor/coprocessor.hpp>
+  #include <sfc-balanced/slot/slot.hpp>
+  #include <sfc-balanced/cartridge/cartridge.hpp>
+
+  #include <sfc-balanced/memory/memory-inline.hpp>
+  #include <sfc-balanced/ppu/counter/counter-inline.hpp>
+}
+
+#include <sfc-balanced/interface/interface.hpp>
diff --git a/nSide/higan/sfc-balanced/slot/bsmemory/bsmemory.cpp b/nSide/higan/sfc-balanced/slot/bsmemory/bsmemory.cpp
new file mode 100644
index 0000000..27195ff
--- /dev/null
+++ b/nSide/higan/sfc-balanced/slot/bsmemory/bsmemory.cpp
@@ -0,0 +1,127 @@
+#include <sfc-balanced/sfc.hpp>
+
+namespace SuperFamicom {
+
+BSMemory bsmemory;
+
+auto BSMemory::init() -> void {
+}
+
+auto BSMemory::load() -> void {
+  if(memory.size() == 0) {
+    memory.allocate(1024 * 1024);
+  }
+}
+
+auto BSMemory::unload() -> void {
+  memory.reset();
+}
+
+auto BSMemory::power() -> void {
+}
+
+auto BSMemory::reset() -> void {
+  regs.command   = 0;
+  regs.writeOld = 0x00;
+  regs.writeNew = 0x00;
+
+  regs.flashEnable = false;
+  regs.readEnable  = false;
+  regs.writeEnable = false;
+  memory.writeProtect(!regs.writeEnable);
+}
+
+auto BSMemory::size() const -> uint {
+  return memory.size();
+}
+
+auto BSMemory::read(uint24 addr, uint8 data) -> uint8 {
+  if(readonly) {
+    return memory.read(bus.mirror(addr, memory.size()), data);
+  }
+
+  if(addr == 0x0002) {
+    if(regs.flashEnable) return 0x80;
+  }
+
+  if(addr == 0x5555) {
+    if(regs.flashEnable) return 0x80;
+  }
+
+  if(regs.readEnable && addr >= 0xff00 && addr <= 0xff13) {
+    //read flash cartridge vendor information
+    switch(addr - 0xff00) {
+    case 0x00: return 0x4d;
+    case 0x01: return 0x00;
+    case 0x02: return 0x50;
+    case 0x03: return 0x00;
+    case 0x04: return 0x00;
+    case 0x05: return 0x00;
+    case 0x06: return 0x2a;  //0x2a = 8mbit, 0x2b = 16mbit (not known to exist, though BIOS recognizes ID)
+    case 0x07: return 0x00;
+    default:   return 0x00;
+    }
+  }
+
+  return memory.read(addr, data);
+}
+
+auto BSMemory::write(uint24 addr, uint8 data) -> void {
+  if(readonly) {
+    return;
+  }
+
+  if((addr & 0xff0000) == 0) {
+    regs.writeOld = regs.writeNew;
+    regs.writeNew = data;
+
+    if(regs.writeEnable && regs.writeOld == regs.writeNew) {
+      return memory.write(addr, data);
+    }
+  } else {
+    if(regs.writeEnable) {
+      return memory.write(addr, data);
+    }
+  }
+
+  if(addr == 0x0000) {
+    regs.command <<= 8;
+    regs.command  |= data;
+
+    if((regs.command & 0xffff) == 0x38d0) {
+      regs.flashEnable = true;
+      regs.readEnable  = true;
+    }
+  }
+
+  if(addr == 0x2aaa) {
+    regs.command <<= 8;
+    regs.command  |= data;
+  }
+
+  if(addr == 0x5555) {
+    regs.command <<= 8;
+    regs.command  |= data;
+
+    if((regs.command & 0xffffff) == 0xaa5570) {
+      regs.writeEnable = false;
+    }
+
+    if((regs.command & 0xffffff) == 0xaa55a0) {
+      regs.writeOld = 0x00;
+      regs.writeNew = 0x00;
+      regs.flashEnable = true;
+      regs.writeEnable = true;
+    }
+
+    if((regs.command & 0xffffff) == 0xaa55f0) {
+      regs.flashEnable = false;
+      regs.readEnable  = false;
+      regs.writeEnable = false;
+    }
+
+    memory.writeProtect(!regs.writeEnable);
+  }
+}
+
+}
diff --git a/nSide/higan/sfc-balanced/slot/bsmemory/bsmemory.hpp b/nSide/higan/sfc-balanced/slot/bsmemory/bsmemory.hpp
new file mode 100644
index 0000000..6c3abd2
--- /dev/null
+++ b/nSide/higan/sfc-balanced/slot/bsmemory/bsmemory.hpp
@@ -0,0 +1,28 @@
+struct BSMemory : Memory {
+  auto init() -> void;
+  auto load() -> void;
+  auto unload() -> void;
+  auto power() -> void;
+  auto reset() -> void;
+
+  auto size() const -> uint;
+  auto read(uint24 addr, uint8) -> uint8;
+  auto write(uint24 addr, uint8 data) -> void;
+
+  uint pathID = 0;
+  MappedRAM memory;
+  bool readonly;
+
+private:
+  struct {
+    uint command;
+    uint8 writeOld;
+    uint8 writeNew;
+
+    bool flashEnable;
+    bool readEnable;
+    bool writeEnable;
+  } regs;
+};
+
+extern BSMemory bsmemory;
diff --git a/nSide/higan/sfc-balanced/slot/slot.hpp b/nSide/higan/sfc-balanced/slot/slot.hpp
new file mode 100644
index 0000000..fd52598
--- /dev/null
+++ b/nSide/higan/sfc-balanced/slot/slot.hpp
@@ -0,0 +1,2 @@
+#include <sfc-balanced/slot/bsmemory/bsmemory.hpp>
+#include <sfc-balanced/slot/sufamiturbo/sufamiturbo.hpp>
diff --git a/nSide/higan/sfc-balanced/slot/sufamiturbo/serialization.cpp b/nSide/higan/sfc-balanced/slot/sufamiturbo/serialization.cpp
new file mode 100644
index 0000000..0f97d98
--- /dev/null
+++ b/nSide/higan/sfc-balanced/slot/sufamiturbo/serialization.cpp
@@ -0,0 +1,3 @@
+auto SufamiTurboCartridge::serialize(serializer& s) -> void {
+  s.array(ram.data(), ram.size());
+}
diff --git a/nSide/higan/sfc-balanced/slot/sufamiturbo/sufamiturbo.cpp b/nSide/higan/sfc-balanced/slot/sufamiturbo/sufamiturbo.cpp
new file mode 100644
index 0000000..ce60feb
--- /dev/null
+++ b/nSide/higan/sfc-balanced/slot/sufamiturbo/sufamiturbo.cpp
@@ -0,0 +1,17 @@
+#include <sfc-balanced/sfc.hpp>
+
+namespace SuperFamicom {
+
+#include "serialization.cpp"
+SufamiTurboCartridge sufamiturboA;
+SufamiTurboCartridge sufamiturboB;
+
+auto SufamiTurboCartridge::load() -> void {
+}
+
+auto SufamiTurboCartridge::unload() -> void {
+  rom.reset();
+  ram.reset();
+}
+
+}
diff --git a/nSide/higan/sfc-balanced/slot/sufamiturbo/sufamiturbo.hpp b/nSide/higan/sfc-balanced/slot/sufamiturbo/sufamiturbo.hpp
new file mode 100644
index 0000000..11fbfc2
--- /dev/null
+++ b/nSide/higan/sfc-balanced/slot/sufamiturbo/sufamiturbo.hpp
@@ -0,0 +1,12 @@
+struct SufamiTurboCartridge {
+  auto load() -> void;
+  auto unload() -> void;
+  auto serialize(serializer&) -> void;
+
+  uint pathID = 0;
+  MappedRAM rom;
+  MappedRAM ram;
+};
+
+extern SufamiTurboCartridge sufamiturboA;
+extern SufamiTurboCartridge sufamiturboB;
diff --git a/nSide/higan/sfc-balanced/smp/memory.cpp b/nSide/higan/sfc-balanced/smp/memory.cpp
new file mode 100644
index 0000000..63b727f
--- /dev/null
+++ b/nSide/higan/sfc-balanced/smp/memory.cpp
@@ -0,0 +1,201 @@
+alwaysinline auto SMP::readRAM(uint16 addr) -> uint8 {
+  if(addr >= 0xffc0 && io.iplromEnable) return iplrom[addr & 0x3f];
+  if(io.ramDisable) return 0x5a;  //0xff on mini-SNES
+  return apuram[addr];
+}
+
+alwaysinline auto SMP::writeRAM(uint16 addr, uint8 data) -> void {
+  //writes to $ffc0-$ffff always go to apuram, even if the iplrom is enabled
+  if(io.ramWritable && !io.ramDisable) apuram[addr] = data;
+}
+
+auto SMP::readPort(uint2 port) const -> uint8 {
+  return apuram[0xf4 + port];
+}
+
+auto SMP::writePort(uint2 port, uint8 data) -> void {
+  apuram[0xf4 + port] = data;
+}
+
+auto SMP::readBus(uint16 addr) -> uint8 {
+  uint result;
+
+  switch(addr) {
+  case 0xf0:  //TEST -- write-only register
+    return 0x00;
+
+  case 0xf1:  //CONTROL -- write-only register
+    return 0x00;
+
+  case 0xf2:  //DSPADDR
+    return io.dspAddr;
+
+  case 0xf3:  //DSPDATA
+    //0x80-0xff are read-only mirrors of 0x00-0x7f
+    return dsp.read(io.dspAddr & 0x7f);
+
+  case 0xf4:  //CPUIO0
+  case 0xf5:  //CPUIO1
+  case 0xf6:  //CPUIO2
+  case 0xf7:  //CPUIO3
+    synchronize(cpu);
+    return cpu.readPort(addr);
+
+  case 0xf8:  //RAM0
+    return io.ram00f8;
+
+  case 0xf9:  //RAM1
+    return io.ram00f9;
+
+  case 0xfa:  //T0TARGET
+  case 0xfb:  //T1TARGET
+  case 0xfc:  //T2TARGET -- write-only registers
+    return 0x00;
+
+  case 0xfd:  //T0OUT -- 4-bit counter value
+    result = timer0.stage3;
+    timer0.stage3 = 0;
+    return result;
+
+  case 0xfe:  //T1OUT -- 4-bit counter value
+    result = timer1.stage3;
+    timer1.stage3 = 0;
+    return result;
+
+  case 0xff:  //T2OUT -- 4-bit counter value
+    result = timer2.stage3;
+    timer2.stage3 = 0;
+    return result;
+  }
+
+  return readRAM(addr);
+}
+
+auto SMP::writeBus(uint16 addr, uint8 data) -> void {
+  switch(addr) {
+  case 0xf0:  //TEST
+    if(regs.p.p) break;  //writes only valid when P flag is clear
+
+    io.clockSpeed    = (data >> 6) & 3;
+    io.timerSpeed    = (data >> 4) & 3;
+    io.timersEnable  = data & 0x08;
+    io.ramDisable    = data & 0x04;
+    io.ramWritable   = data & 0x02;
+    io.timersDisable = data & 0x01;
+
+    io.timerStep = (1 << io.clockSpeed) + (2 << io.timerSpeed);
+
+    timer0.synchronizeStage1();
+    timer1.synchronizeStage1();
+    timer2.synchronizeStage1();
+    break;
+
+  case 0xf1:  //CONTROL
+    io.iplromEnable = data & 0x80;
+
+    if(data & 0x30) {
+      //one-time clearing of APU port read registers,
+      //emulated by simulating CPU writes of 0x00
+      synchronize(cpu);
+      if(data & 0x20) {
+        cpu.writePort(2, 0x00);
+        cpu.writePort(3, 0x00);
+      }
+      if(data & 0x10) {
+        cpu.writePort(0, 0x00);
+        cpu.writePort(1, 0x00);
+      }
+    }
+
+    //0->1 transistion resets timers
+    if(!timer2.enable && (data & 0x04)) {
+      timer2.stage2 = 0;
+      timer2.stage3 = 0;
+    }
+    timer2.enable = data & 0x04;
+
+    if(!timer1.enable && (data & 0x02)) {
+      timer1.stage2 = 0;
+      timer1.stage3 = 0;
+    }
+    timer1.enable = data & 0x02;
+
+    if(!timer0.enable && (data & 0x01)) {
+      timer0.stage2 = 0;
+      timer0.stage3 = 0;
+    }
+    timer0.enable = data & 0x01;
+    break;
+
+  case 0xf2:  //DSPADDR
+    io.dspAddr = data;
+    break;
+
+  case 0xf3:  //DSPDATA
+    if(io.dspAddr & 0x80) break;  //0x80-0xff are read-only mirrors of 0x00-0x7f
+    dsp.write(io.dspAddr & 0x7f, data);
+    break;
+
+  case 0xf4:  //CPUIO0
+  case 0xf5:  //CPUIO1
+  case 0xf6:  //CPUIO2
+  case 0xf7:  //CPUIO3
+    synchronize(cpu);
+    writePort(addr, data);
+    break;
+
+  case 0xf8:  //RAM0
+    io.ram00f8 = data;
+    break;
+
+  case 0xf9:  //RAM1
+    io.ram00f9 = data;
+    break;
+
+  case 0xfa:  //T0TARGET
+    timer0.target = data;
+    break;
+
+  case 0xfb:  //T1TARGET
+    timer1.target = data;
+    break;
+
+  case 0xfc:  //T2TARGET
+    timer2.target = data;
+    break;
+
+  case 0xfd:  //T0OUT
+  case 0xfe:  //T1OUT
+  case 0xff:  //T2OUT -- read-only registers
+    break;
+  }
+
+  writeRAM(addr, data);  //all writes, even to MMIO registers, appear on bus
+}
+
+auto SMP::idle() -> void {
+  step(24);
+  cycleEdge();
+}
+
+auto SMP::read(uint16 addr) -> uint8 {
+  step(12);
+  uint8 data = readBus(addr);
+  step(12);
+  cycleEdge();
+  debug(smp.read, addr, data);
+  return data;
+}
+
+auto SMP::write(uint16 addr, uint8 data) -> void {
+  step(24);
+  writeBus(addr, data);
+  cycleEdge();
+  debug(smp.write, addr, data);
+}
+
+auto SMP::readDisassembler(uint16 addr) -> uint8 {
+  if((addr & 0xfff0) == 0x00f0) return 0x00;
+  if((addr & 0xffc0) == 0xffc0 && io.iplromEnable) return iplrom[addr & 0x3f];
+  return apuram[addr];
+}
diff --git a/nSide/higan/sfc-balanced/smp/serialization.cpp b/nSide/higan/sfc-balanced/smp/serialization.cpp
new file mode 100644
index 0000000..215f392
--- /dev/null
+++ b/nSide/higan/sfc-balanced/smp/serialization.cpp
@@ -0,0 +1,48 @@
+auto SMP::serialize(serializer& s) -> void {
+  SPC700::serialize(s);
+  Thread::serialize(s);
+
+  s.array(apuram);
+
+  s.integer(io.clockCounter);
+  s.integer(io.dspCounter);
+  s.integer(io.timerStep);
+
+  s.integer(io.clockSpeed);
+  s.integer(io.timerSpeed);
+  s.integer(io.timersEnable);
+  s.integer(io.ramDisable);
+  s.integer(io.ramWritable);
+  s.integer(io.timersDisable);
+
+  s.integer(io.iplromEnable);
+
+  s.integer(io.dspAddr);
+
+  s.integer(io.ram00f8);
+  s.integer(io.ram00f9);
+
+  s.integer(timer0.stage0);
+  s.integer(timer0.stage1);
+  s.integer(timer0.stage2);
+  s.integer(timer0.stage3);
+  s.integer(timer0.line);
+  s.integer(timer0.enable);
+  s.integer(timer0.target);
+
+  s.integer(timer1.stage0);
+  s.integer(timer1.stage1);
+  s.integer(timer1.stage2);
+  s.integer(timer1.stage3);
+  s.integer(timer1.line);
+  s.integer(timer1.enable);
+  s.integer(timer1.target);
+
+  s.integer(timer2.stage0);
+  s.integer(timer2.stage1);
+  s.integer(timer2.stage2);
+  s.integer(timer2.stage3);
+  s.integer(timer2.line);
+  s.integer(timer2.enable);
+  s.integer(timer2.target);
+}
diff --git a/nSide/higan/sfc-balanced/smp/smp.cpp b/nSide/higan/sfc-balanced/smp/smp.cpp
new file mode 100644
index 0000000..fdc315f
--- /dev/null
+++ b/nSide/higan/sfc-balanced/smp/smp.cpp
@@ -0,0 +1,101 @@
+#include <sfc-balanced/sfc.hpp>
+
+namespace SuperFamicom {
+
+SMP smp;
+
+#include "memory.cpp"
+#include "timing.cpp"
+#include "serialization.cpp"
+
+auto SMP::Enter() -> void {
+  while(true) scheduler.synchronize(), smp.main();
+}
+
+auto SMP::main() -> void {
+  debug(smp.execute, regs.pc);
+  instruction();
+}
+
+auto SMP::load(Markup::Node node) -> bool {
+  if(auto name = node["smp/rom/name"].text()) {
+    if(auto fp = interface->open(ID::System, name, File::Read, File::Required)) {
+      fp->read(iplrom, 64);
+      return true;
+    }
+  }
+  return false;
+}
+
+auto SMP::power() -> void {
+  //targets not initialized/changed upon reset
+  timer0.target = 0;
+  timer1.target = 0;
+  timer2.target = 0;
+}
+
+auto SMP::reset() -> void {
+  create(Enter, 32040.0 * 768.0);
+
+  regs.pc.l = iplrom[62];
+  regs.pc.h = iplrom[63];
+  regs.a = 0x00;
+  regs.x = 0x00;
+  regs.y = 0x00;
+  regs.s = 0xef;
+  regs.p = 0x02;
+
+  for(auto& byte : apuram) byte = random(0x00);
+  apuram[0x00f4] = 0x00;
+  apuram[0x00f5] = 0x00;
+  apuram[0x00f6] = 0x00;
+  apuram[0x00f7] = 0x00;
+
+  io.clockCounter = 0;
+  io.dspCounter = 0;
+  io.timerStep = 3;
+
+  //$00f0
+  io.clockSpeed = 0;
+  io.timerSpeed = 0;
+  io.timersEnable = true;
+  io.ramDisable = false;
+  io.ramWritable = true;
+  io.timersDisable = false;
+
+  //$00f1
+  io.iplromEnable = true;
+
+  //$00f2
+  io.dspAddr = 0x00;
+
+  //$00f8,$00f9
+  io.ram00f8 = 0x00;
+  io.ram00f9 = 0x00;
+
+  timer0.stage0 = 0;
+  timer1.stage0 = 0;
+  timer2.stage0 = 0;
+
+  timer0.stage1 = 0;
+  timer1.stage1 = 0;
+  timer2.stage1 = 0;
+
+  timer0.stage2 = 0;
+  timer1.stage2 = 0;
+  timer2.stage2 = 0;
+
+  timer0.stage3 = 0;
+  timer1.stage3 = 0;
+  timer2.stage3 = 0;
+
+  timer0.line = 0;
+  timer1.line = 0;
+  timer2.line = 0;
+
+  timer0.enable = false;
+  timer1.enable = false;
+  timer2.enable = false;
+}
+
+}
diff --git a/nSide/higan/sfc-balanced/smp/smp.hpp b/nSide/higan/sfc-balanced/smp/smp.hpp
new file mode 100644
index 0000000..e6e112f
--- /dev/null
+++ b/nSide/higan/sfc-balanced/smp/smp.hpp
@@ -0,0 +1,80 @@
+//Sony CXP1100Q-1
+
+struct SMP : Processor::SPC700, Thread {
+  auto readPort(uint2 port) const -> uint8;
+  auto writePort(uint2 port, uint8 data) -> void;
+
+  auto main() -> void;
+  auto load(Markup::Node) -> bool;
+  auto power() -> void;
+  auto reset() -> void;
+
+  auto serialize(serializer&) -> void;
+
+  uint8 iplrom[64];
+  uint8 apuram[64 * 1024];
+
+privileged:
+  struct IO {
+    //timing
+    uint clockCounter;
+    uint dspCounter;
+    uint timerStep;
+
+    //$00f0
+    uint8 clockSpeed;
+    uint8 timerSpeed;
+    bool timersEnable;
+    bool ramDisable;
+    bool ramWritable;
+    bool timersDisable;
+
+    //$00f1
+    bool iplromEnable;
+
+    //$00f2
+    uint8 dspAddr;
+
+    //$00f8,$00f9
+    uint8 ram00f8;
+    uint8 ram00f9;
+  } io;
+
+  static auto Enter() -> void;
+
+  //memory.cpp
+  auto readRAM(uint16 addr) -> uint8;
+  auto writeRAM(uint16 addr, uint8 data) -> void;
+
+  auto readBus(uint16 addr) -> uint8;
+  auto writeBus(uint16 addr, uint8 data) -> void;
+
+  auto idle() -> void override;
+  auto read(uint16 addr) -> uint8 override;
+  auto write(uint16 addr, uint8 data) -> void override;
+
+  auto readDisassembler(uint16 addr) -> uint8 override;
+
+  //timing.cpp
+  template<uint Frequency> struct Timer {
+    uint8 stage0;
+    uint8 stage1;
+    uint8 stage2;
+    uint4 stage3;
+    bool line;
+    bool enable;
+    uint8 target;
+
+    auto tick() -> void;
+    auto synchronizeStage1() -> void;
+  };
+
+  Timer<192> timer0;
+  Timer<192> timer1;
+  Timer< 24> timer2;
+
+  alwaysinline auto step(uint clocks) -> void;
+  alwaysinline auto cycleEdge() -> void;
+};
+
+extern SMP smp;
diff --git a/nSide/higan/sfc-balanced/smp/timing.cpp b/nSide/higan/sfc-balanced/smp/timing.cpp
new file mode 100644
index 0000000..e26ae9e
--- /dev/null
+++ b/nSide/higan/sfc-balanced/smp/timing.cpp
@@ -0,0 +1,57 @@
+auto SMP::step(uint clocks) -> void {
+  Thread::step(clocks);
+  dsp.clock -= clocks;
+  while(dsp.clock < 0) dsp.main();
+
+  #if defined(DEBUGGER)
+  synchronize(cpu);
+  #else
+  //forcefully sync S-SMP to S-CPU in case chips are not communicating
+  //sync if S-SMP is more than 1ms ahead of S-CPU
+  if(clock() - cpu.clock() > Thread::Second / 1'000) synchronize(cpu);
+  #endif
+}
+
+auto SMP::cycleEdge() -> void {
+  timer0.tick();
+  timer1.tick();
+  timer2.tick();
+
+  //TEST register S-SMP speed control
+  //24 clocks have already been added for this cycle at this point
+  switch(io.clockSpeed) {
+  case 0: break;                 //100% speed
+  case 1: step(24); break;       // 50% speed
+  case 2: while(true) step(24);  //  0% speed -- locks S-SMP
+  case 3: step(24 * 9); break;   // 10% speed
+  }
+}
+
+template<uint Frequency> auto SMP::Timer<Frequency>::tick() -> void {
+  //stage 0 increment
+  stage0 += smp.io.timerStep;
+  if(stage0 < Frequency) return;
+  stage0 -= Frequency;
+
+  //stage 1 increment
+  stage1 ^= 1;
+  synchronizeStage1();
+}
+
+template<uint Frequency> auto SMP::Timer<Frequency>::synchronizeStage1() -> void {
+  bool newLine = stage1;
+  if(!smp.io.timersEnable) newLine = false;
+  if(smp.io.timersDisable) newLine = false;
+
+  bool oldLine = line;
+  line = newLine;
+  if(oldLine != 1 || newLine != 0) return;  //only pulse on 1->0 transition
+
+  //stage 2 increment
+  if(!enable) return;
+  if(++stage2 != target) return;
+
+  //stage 3 increment
+  stage2 = 0;
+  stage3++;
+}
diff --git a/nSide/higan/sfc-balanced/system/peripherals.cpp b/nSide/higan/sfc-balanced/system/peripherals.cpp
new file mode 100644
index 0000000..dbd0a8f
--- /dev/null
+++ b/nSide/higan/sfc-balanced/system/peripherals.cpp
@@ -0,0 +1,63 @@
+Peripherals peripherals;
+
+auto Peripherals::unload() -> void {
+  delete controllerPort1;
+  delete controllerPort2;
+  delete expansionPort;
+  controllerPort1 = nullptr;
+  controllerPort2 = nullptr;
+  expansionPort = nullptr;
+}
+
+auto Peripherals::reset() -> void {
+  connect(ID::Port::Controller1, settings.controllerPort1);
+  connect(ID::Port::Controller2, settings.controllerPort2);
+  connect(ID::Port::Expansion, settings.expansionPort);
+}
+
+auto Peripherals::connect(uint port, uint device) -> void {
+  if(port == ID::Port::Controller1) {
+    settings.controllerPort1 = device;
+    if(!system.loaded()) return;
+
+    delete controllerPort1;
+    switch(device) { default:
+    case ID::Device::None:    controllerPort1 = new Controller(0); break;
+    case ID::Device::Gamepad: controllerPort1 = new Gamepad(0); break;
+    case ID::Device::Mouse:   controllerPort1 = new Mouse(0); break;
+    }
+  }
+
+  if(port == ID::Port::Controller2) {
+    settings.controllerPort2 = device;
+    if(!system.loaded()) return;
+
+    delete controllerPort2;
+    switch(device) { default:
+    case ID::Device::None:          controllerPort2 = new Controller(1); break;
+    case ID::Device::Gamepad:       controllerPort2 = new Gamepad(1); break;
+    case ID::Device::Mouse:         controllerPort2 = new Mouse(1); break;
+    case ID::Device::SuperMultitap: controllerPort2 = new SuperMultitap(1); break;
+    case ID::Device::SuperScope:    controllerPort2 = new SuperScope(1); break;
+    case ID::Device::Justifier:     controllerPort2 = new Justifier(1, false); break;
+    case ID::Device::Justifiers:    controllerPort2 = new Justifier(1, true); break;
+    }
+  }
+
+  if(port == ID::Port::Expansion) {
+    settings.expansionPort = device;
+    if(!system.loaded()) return;
+
+    delete expansionPort;
+    switch(device) { default:
+    case ID::Device::None:        expansionPort = new Expansion; break;
+    case ID::Device::Satellaview: expansionPort = new Satellaview; break;
+    case ID::Device::S21FX:       expansionPort = new S21FX; break;
+    }
+  }
+
+  cpu.peripherals.reset();
+  cpu.peripherals.append(controllerPort1);
+  cpu.peripherals.append(controllerPort2);
+  cpu.peripherals.append(expansionPort);
+}
diff --git a/nSide/higan/sfc-balanced/system/random.cpp b/nSide/higan/sfc-balanced/system/random.cpp
new file mode 100644
index 0000000..5e68546
--- /dev/null
+++ b/nSide/higan/sfc-balanced/system/random.cpp
@@ -0,0 +1,14 @@
+Random random;
+
+auto Random::seed(uint seed) -> void {
+  iter = seed;
+}
+
+auto Random::operator()(uint result) -> uint {
+  if(!settings.random) return result;
+  return iter = (iter >> 1) ^ (((iter & 1) - 1) & 0xedb88320);
+}
+
+auto Random::serialize(serializer& s) -> void {
+  s.integer(iter);
+}
diff --git a/nSide/higan/sfc-balanced/system/serialization.cpp b/nSide/higan/sfc-balanced/system/serialization.cpp
new file mode 100644
index 0000000..7f883df
--- /dev/null
+++ b/nSide/higan/sfc-balanced/system/serialization.cpp
@@ -0,0 +1,90 @@
+auto System::serialize() -> serializer {
+  serializer s(serializeSize);
+
+  uint signature = 0x31545342;
+  char version[16] = {};
+  char hash[64] = {};
+  char description[512] = {};
+  memory::copy(&version, (const char*)Emulator::SerializerVersion, Emulator::SerializerVersion.size());
+  memory::copy(&hash, (const char*)cartridge.sha256(), 64);
+
+  s.integer(signature);
+  s.array(version);
+  s.array(hash);
+  s.array(description);
+
+  serializeAll(s);
+  return s;
+}
+
+auto System::unserialize(serializer& s) -> bool {
+  uint signature = 0;
+  char version[16] = {};
+  char hash[64] = {};
+  char description[512] = {};
+
+  s.integer(signature);
+  s.array(version);
+  s.array(hash);
+  s.array(description);
+
+  if(signature != 0x31545342) return false;
+  if(string{version} != Emulator::SerializerVersion) return false;
+
+  power();
+  serializeAll(s);
+  return true;
+}
+
+//internal
+
+auto System::serialize(serializer& s) -> void {
+  s.integer((uint&)information.region);
+}
+
+auto System::serializeAll(serializer& s) -> void {
+  cartridge.serialize(s);
+  system.serialize(s);
+  random.serialize(s);
+  cpu.serialize(s);
+  smp.serialize(s);
+  ppu.serialize(s);
+  dsp.serialize(s);
+
+  if(cartridge.has.ICD2) icd2.serialize(s);
+  if(cartridge.has.MCC) mcc.serialize(s);
+  if(cartridge.has.Event) event.serialize(s);
+  if(cartridge.has.SA1) sa1.serialize(s);
+  if(cartridge.has.SuperFX) superfx.serialize(s);
+  if(cartridge.has.ARMDSP) armdsp.serialize(s);
+  if(cartridge.has.HitachiDSP) hitachidsp.serialize(s);
+  if(cartridge.has.NECDSP) necdsp.serialize(s);
+  if(cartridge.has.EpsonRTC) epsonrtc.serialize(s);
+  if(cartridge.has.SharpRTC) sharprtc.serialize(s);
+  if(cartridge.has.SPC7110) spc7110.serialize(s);
+  if(cartridge.has.SDD1) sdd1.serialize(s);
+  if(cartridge.has.OBC1) obc1.serialize(s);
+  if(cartridge.has.MSU1) msu1.serialize(s);
+
+  if(cartridge.has.SufamiTurboSlots) sufamiturboA.serialize(s), sufamiturboB.serialize(s);
+}
+
+//perform dry-run state save:
+//determines exactly how many bytes are needed to save state for this cartridge,
+//as amount varies per game (eg different RAM sizes, special chips, etc.)
+auto System::serializeInit() -> void {
+  serializer s;
+
+  uint signature = 0;
+  char version[16] = {};
+  char hash[64] = {};
+  char description[512] = {};
+
+  s.integer(signature);
+  s.array(version);
+  s.array(hash);
+  s.array(description);
+
+  serializeAll(s);
+  serializeSize = s.size();
+}
diff --git a/nSide/higan/sfc-balanced/system/system.cpp b/nSide/higan/sfc-balanced/system/system.cpp
new file mode 100644
index 0000000..6a6c4c5
--- /dev/null
+++ b/nSide/higan/sfc-balanced/system/system.cpp
@@ -0,0 +1,208 @@
+#include <sfc-balanced/sfc.hpp>
+
+namespace SuperFamicom {
+
+System system;
+Scheduler scheduler;
+Cheat cheat;
+#include "video.cpp"
+#include "peripherals.cpp"
+#include "random.cpp"
+#include "serialization.cpp"
+
+auto System::run() -> void {
+  if(scheduler.enter() == Scheduler::Event::Frame) ppu.refresh();
+}
+
+auto System::runToSave() -> void {
+  scheduler.synchronize(cpu);
+  scheduler.synchronize(smp);
+  scheduler.synchronize(ppu);
+  for(auto coprocessor : cpu.coprocessors) scheduler.synchronize(*coprocessor);
+  for(auto peripheral : cpu.peripherals) scheduler.synchronize(*peripheral);
+}
+
+auto System::init() -> void {
+  assert(interface != nullptr);
+
+  icd2.init();
+  mcc.init();
+  nss.init();
+  event.init();
+  sa1.init();
+  superfx.init();
+  armdsp.init();
+  hitachidsp.init();
+  necdsp.init();
+  epsonrtc.init();
+  sharprtc.init();
+  spc7110.init();
+  sdd1.init();
+  obc1.init();
+  msu1.init();
+
+  bsmemory.init();
+}
+
+auto System::term() -> void {
+}
+
+auto System::load() -> bool {
+  information = Information();
+
+  if(auto fp = interface->open(ID::System, "manifest.bml", File::Read, File::Required)) {
+    information.manifest = fp->reads();
+  } else return false;
+
+  auto document = BML::unserialize(information.manifest);
+  auto system = document["system"];
+
+  bus.reset();
+  if(!cpu.load(system)) return false;
+  if(!smp.load(system)) return false;
+  if(!ppu.load(system)) return false;
+  if(!dsp.load(system)) return false;
+  if(!cartridge.load()) return false;
+
+  information.region = cartridge.region() == Cartridge::Region::NTSC ? Region::NTSC : Region::PAL;
+  if(system["region"].text() == "NTSC") information.region = Region::NTSC;
+  if(system["region"].text() == "PAL" ) information.region = Region::PAL;
+
+  information.colorburst = region() == Region::NTSC
+  ? Emulator::Constants::Colorburst::NTSC
+  : Emulator::Constants::Colorburst::PAL * 4.0 / 5.0;
+
+  if(cartridge.has.ICD2) icd2.load();
+  if(cartridge.has.MCC) mcc.load();
+  if(cartridge.has.NSSDIP) nss.load();
+  if(cartridge.has.Event) event.load();
+  if(cartridge.has.SA1) sa1.load();
+  if(cartridge.has.SuperFX) superfx.load();
+  if(cartridge.has.ARMDSP) armdsp.load();
+  if(cartridge.has.HitachiDSP) hitachidsp.load();
+  if(cartridge.has.NECDSP) necdsp.load();
+  if(cartridge.has.EpsonRTC) epsonrtc.load();
+  if(cartridge.has.SharpRTC) sharprtc.load();
+  if(cartridge.has.SPC7110) spc7110.load();
+  if(cartridge.has.SDD1) sdd1.load();
+  if(cartridge.has.OBC1) obc1.load();
+  if(cartridge.has.MSU1) msu1.load();
+
+  if(cartridge.has.BSMemorySlot) bsmemory.load();
+  if(cartridge.has.SufamiTurboSlots) sufamiturboA.load(), sufamiturboB.load();
+
+  serializeInit();
+  return information.loaded = true;
+}
+
+auto System::save() -> void {
+  if(!loaded()) return;
+  cartridge.save();
+}
+
+auto System::unload() -> void {
+  if(!loaded()) return;
+  peripherals.unload();
+
+  if(cartridge.has.ICD2) icd2.unload();
+  if(cartridge.has.MCC) mcc.unload();
+  if(cartridge.has.NSSDIP) nss.unload();
+  if(cartridge.has.Event) event.unload();
+  if(cartridge.has.SA1) sa1.unload();
+  if(cartridge.has.SuperFX) superfx.unload();
+  if(cartridge.has.ARMDSP) armdsp.unload();
+  if(cartridge.has.HitachiDSP) hitachidsp.unload();
+  if(cartridge.has.NECDSP) necdsp.unload();
+  if(cartridge.has.EpsonRTC) epsonrtc.unload();
+  if(cartridge.has.SharpRTC) sharprtc.unload();
+  if(cartridge.has.SPC7110) spc7110.unload();
+  if(cartridge.has.SDD1) sdd1.unload();
+  if(cartridge.has.OBC1) obc1.unload();
+  if(cartridge.has.MSU1) msu1.unload();
+
+  if(cartridge.has.BSMemorySlot) bsmemory.unload();
+  if(cartridge.has.SufamiTurboSlots) sufamiturboA.unload(), sufamiturboB.unload();
+
+  cartridge.unload();
+  information.loaded = false;
+}
+
+auto System::power() -> void {
+  random.seed((uint)time(0));
+
+  cpu.power();
+  smp.power();
+  dsp.power();
+  ppu.power();
+
+  if(cartridge.has.ICD2) icd2.power();
+  if(cartridge.has.MCC) mcc.power();
+  if(cartridge.has.NSSDIP) nss.power();
+  if(cartridge.has.Event) event.power();
+  if(cartridge.has.SA1) sa1.power();
+  if(cartridge.has.SuperFX) superfx.power();
+  if(cartridge.has.ARMDSP) armdsp.power();
+  if(cartridge.has.HitachiDSP) hitachidsp.power();
+  if(cartridge.has.NECDSP) necdsp.power();
+  if(cartridge.has.EpsonRTC) epsonrtc.power();
+  if(cartridge.has.SharpRTC) sharprtc.power();
+  if(cartridge.has.SPC7110) spc7110.power();
+  if(cartridge.has.SDD1) sdd1.power();
+  if(cartridge.has.OBC1) obc1.power();
+  if(cartridge.has.MSU1) msu1.power();
+
+  if(cartridge.has.BSMemorySlot) bsmemory.power();
+
+  reset();
+}
+
+auto System::reset() -> void {
+  Emulator::video.reset();
+  Emulator::video.setInterface(interface);
+  configureVideoPalette();
+  configureVideoEffects();
+
+  Emulator::audio.reset();
+  Emulator::audio.setInterface(interface);
+
+  scheduler.reset();
+  cpu.reset();
+  smp.reset();
+  dsp.reset();
+  ppu.reset();
+
+  if(cartridge.has.ICD2) icd2.reset();
+  if(cartridge.has.MCC) mcc.reset();
+  if(cartridge.has.NSSDIP) nss.reset();
+  if(cartridge.has.Event) event.reset();
+  if(cartridge.has.SA1) sa1.reset();
+  if(cartridge.has.SuperFX) superfx.reset();
+  if(cartridge.has.ARMDSP) armdsp.reset();
+  if(cartridge.has.HitachiDSP) hitachidsp.reset();
+  if(cartridge.has.NECDSP) necdsp.reset();
+  if(cartridge.has.EpsonRTC) epsonrtc.reset();
+  if(cartridge.has.SharpRTC) sharprtc.reset();
+  if(cartridge.has.SPC7110) spc7110.reset();
+  if(cartridge.has.SDD1) sdd1.reset();
+  if(cartridge.has.OBC1) obc1.reset();
+  if(cartridge.has.MSU1) msu1.reset();
+
+  if(cartridge.has.BSMemorySlot) bsmemory.reset();
+
+  if(cartridge.has.ICD2) cpu.coprocessors.append(&icd2);
+  if(cartridge.has.Event) cpu.coprocessors.append(&event);
+  if(cartridge.has.SA1) cpu.coprocessors.append(&sa1);
+  if(cartridge.has.SuperFX) cpu.coprocessors.append(&superfx);
+  if(cartridge.has.ARMDSP) cpu.coprocessors.append(&armdsp);
+  if(cartridge.has.HitachiDSP) cpu.coprocessors.append(&hitachidsp);
+  if(cartridge.has.NECDSP) cpu.coprocessors.append(&necdsp);
+  if(cartridge.has.EpsonRTC) cpu.coprocessors.append(&epsonrtc);
+  if(cartridge.has.SharpRTC) cpu.coprocessors.append(&sharprtc);
+  if(cartridge.has.SPC7110) cpu.coprocessors.append(&spc7110);
+  if(cartridge.has.MSU1) cpu.coprocessors.append(&msu1);
+
+  scheduler.primary(cpu);
+  peripherals.reset();
+}
+
+}
diff --git a/nSide/higan/sfc-balanced/system/system.hpp b/nSide/higan/sfc-balanced/system/system.hpp
new file mode 100644
index 0000000..26809de
--- /dev/null
+++ b/nSide/higan/sfc-balanced/system/system.hpp
@@ -0,0 +1,67 @@
+struct Interface;
+
+struct System {
+  enum class Region : bool { NTSC = 0, PAL = 1 };
+
+  inline auto loaded() const -> bool { return information.loaded; }
+  inline auto region() const -> Region { return information.region; }
+  inline auto colorburst() const -> double { return information.colorburst; }
+
+  auto run() -> void;
+  auto runToSave() -> void;
+
+  auto init() -> void;
+  auto term() -> void;
+  auto load() -> bool;
+  auto save() -> void;
+  auto unload() -> void;
+  auto power() -> void;
+  auto reset() -> void;
+
+  //video.cpp
+  auto configureVideoPalette() -> void;
+  auto configureVideoEffects() -> void;
+
+  //serialization.cpp
+  auto serialize() -> serializer;
+  auto unserialize(serializer&) -> bool;
+
+private:
+  struct Information {
+    string manifest;
+    bool loaded = false;
+    Region region = Region::NTSC;
+    double colorburst = 0.0;
+  } information;
+
+  uint serializeSize = 0;
+
+  auto serialize(serializer&) -> void;
+  auto serializeAll(serializer&) -> void;
+  auto serializeInit() -> void;
+
+  friend class Cartridge;
+};
+
+struct Peripherals {
+  auto unload() -> void;
+  auto reset() -> void;
+  auto connect(uint port, uint device) -> void;
+
+  Controller* controllerPort1 = nullptr;
+  Controller* controllerPort2 = nullptr;
+  Expansion* expansionPort = nullptr;
+};
+
+struct Random {
+  auto seed(uint seed) -> void;
+  auto operator()(uint result) -> uint;
+  auto serialize(serializer& s) -> void;
+
+private:
+  uint iter = 0;
+};
+
+extern System system;
+extern Peripherals peripherals;
+extern Random random;
diff --git a/nSide/higan/sfc-balanced/system/video.cpp b/nSide/higan/sfc-balanced/system/video.cpp
new file mode 100644
index 0000000..f537903
--- /dev/null
+++ b/nSide/higan/sfc-balanced/system/video.cpp
@@ -0,0 +1,7 @@
+auto System::configureVideoPalette() -> void {
+  Emulator::video.setPalette();
+}
+
+auto System::configureVideoEffects() -> void {
+  Emulator::video.setEffect(Emulator::Video::Effect::ColorBleed, settings.blurEmulation);
+}

