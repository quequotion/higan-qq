diff --git a/higan-hack/shaders/Curvature.shader/manifest.bml b/higan-hack/shaders/Curvature.shader/manifest.bml
index 7bec470..2f9b930 100644
--- a/higan-hack/shaders/Curvature.shader/manifest.bml
+++ b/higan-hack/shaders/Curvature.shader/manifest.bml
@@ -1,4 +1,6 @@
-program
+input
   filter: linear
   wrap: border
+
+program
   fragment: curvature.fs
diff --git a/higan-hack/shaders/Display Emulation/Famicom.shader/famicom.fs b/higan-hack/shaders/Display Emulation/Famicom.shader/famicom.fs
new file mode 100644
index 0000000..32799f6
--- /dev/null
+++ b/higan-hack/shaders/Display Emulation/Famicom.shader/famicom.fs	
@@ -0,0 +1,72 @@
+#version 150
+
+#in saturation
+#in hue
+#in contrast
+#in brightness
+#in gamma
+
+#define black 0.518
+#define white 1.962
+#define attenuation 0.746
+const float levels[8] = {
+  0.350, 0.518, 0.962, 1.550,
+  1.094, 1.506, 1.962, 1.962
+};
+
+uniform sampler2D source[];
+
+in Vertex {
+  vec2 texCoord;
+};
+
+out vec4 fragColor;
+
+bool wave(int p, int color) {
+  return (color + p + 8) % 12 < 6;
+};
+
+float gammaAdjust(float f) {
+  return f < 0.0 ? 0.0 : pow(f, 2.2 / gamma);
+};
+
+void main() {
+  vec4 elc0 = texture(source[0], texCoord);
+  int emphasis = int(elc0[0] * 7);
+
+  int color = int(elc0[2] * 15), level = color < 0xe ? int(elc0[1] * 3) : 1;
+
+  float lo_and_hi[2] = float[](
+    levels[level + (color == 0x0 ? 4 : 0)],
+    levels[level + (color <  0xd ? 4 : 0)]
+  );
+
+  float y = 0.0, i = 0.0, q = 0.0;
+  for(int p = 0; p < 12; p++) {
+    float spot = lo_and_hi[wave(p, color) ? 1 : 0];
+
+    if(((emphasis & 1) == 1 && wave(p, 12))
+    || ((emphasis & 2) == 2 && wave(p,  4))
+    || ((emphasis & 4) == 4 && wave(p,  8))
+    ) spot *= attenuation;
+
+    float v = (spot - black) / (white - black);
+
+    v = (v - 0.5) * contrast + 0.5;
+    v *= brightness / 12.0;
+
+    y += v;
+    i += v * cos((3.141592653 / 6.0) * (p + hue));
+    q += v * sin((3.141592653 / 6.0) * (p + hue));
+  }
+
+  i *= saturation;
+  q *= saturation;
+
+  fragColor = vec4(
+    gammaAdjust(y +  0.946882 * i +  0.623557 * q),
+    gammaAdjust(y + -0.274788 * i + -0.635691 * q),
+    gammaAdjust(y + -1.108545 * i +  1.709007 * q),
+    0.0
+  );
+}
diff --git a/higan-hack/shaders/Display Emulation/Famicom.shader/manifest.bml b/higan-hack/shaders/Display Emulation/Famicom.shader/manifest.bml
new file mode 100644
index 0000000..4d37e5e
--- /dev/null
+++ b/higan-hack/shaders/Display Emulation/Famicom.shader/manifest.bml	
@@ -0,0 +1,15 @@
+settings
+  saturation: 2.0
+  hue:        0.0
+  contrast:   1.0
+  brightness: 1.0
+  // Standard
+  gamma:      2.2
+  // Color emulation
+  //gamma:      1.8
+input
+  // Using linear filtering is not safe because of pre-blurred chroma and luma.
+  filter: nearest
+  wrap: border
+program
+  fragment: famicom.fs
diff --git a/higan-hack/shaders/Display Emulation/GTUfamicomLite.shader/DAC.fs b/higan-hack/shaders/Display Emulation/GTUfamicomLite.shader/DAC.fs
new file mode 100644
index 0000000..068fed9
--- /dev/null
+++ b/higan-hack/shaders/Display Emulation/GTUfamicomLite.shader/DAC.fs	
@@ -0,0 +1,30 @@
+#version 150
+
+////////////////////////////////////////////////////////
+//	GTU-Famicom version 0.50	
+//	Author: aliaspider - aliaspider@gmail.com
+//	License: GPLv3      
+////////////////////////////////////////////////////////
+
+uniform sampler2D	source[];
+uniform sampler2D	pixmap[];
+uniform vec4		sourceSize[];
+uniform vec4 		targetSize;
+uniform int 		phase;
+
+in Vertex {
+	vec2 texCoord;
+	float colorPhase;
+};
+out vec4 fragColor;
+
+
+void main() {
+	vec4 c=texture2D(source[0], texCoord.xy);
+	
+	vec2 pixmapCoord;
+	pixmapCoord.x= c.z*(15.0/(16.0*4.0))+c.y*(3.0/4.0)+(0.5/(16.0*4.0));
+	pixmapCoord.y= 1.0-(mod(colorPhase,12.0)/(12.0*8.0)+c.x*(7.0/8.0)+(0.5/(12.0*8.0)));
+	
+	fragColor.r=texture(pixmap[0], pixmapCoord.xy).r;
+}
diff --git a/higan-hack/shaders/Display Emulation/GTUfamicomLite.shader/DAC.vs b/higan-hack/shaders/Display Emulation/GTUfamicomLite.shader/DAC.vs
new file mode 100644
index 0000000..c35b062
--- /dev/null
+++ b/higan-hack/shaders/Display Emulation/GTUfamicomLite.shader/DAC.vs	
@@ -0,0 +1,29 @@
+#version 150
+
+////////////////////////////////////////////////////////
+//	GTU-Famicom version 0.50	
+//	Author: aliaspider - aliaspider@gmail.com
+//	License: GPLv3      
+////////////////////////////////////////////////////////
+
+
+#in cropOverscan
+// #define cropOverscan
+
+uniform vec4 targetSize;
+uniform int  phase;
+
+in vec4 position;
+in vec2 texCoord;
+
+out Vertex{
+	vec2 texCoord;
+	float colorPhase;
+}vertexOut;
+
+void main(void){	
+	gl_Position=position;
+	vertexOut.texCoord=texCoord;	
+	vec2 pos = (texCoord.xy*targetSize.xy)-0.5;	
+	vertexOut.colorPhase=8.0+pos.x+pos.y*4.0+(phase%2)*4.0;
+}
diff --git a/higan-hack/shaders/Display Emulation/GTUfamicomLite.shader/combFilter.fs b/higan-hack/shaders/Display Emulation/GTUfamicomLite.shader/combFilter.fs
new file mode 100644
index 0000000..a581015
--- /dev/null
+++ b/higan-hack/shaders/Display Emulation/GTUfamicomLite.shader/combFilter.fs	
@@ -0,0 +1,31 @@
+#version 150
+
+////////////////////////////////////////////////////////
+//	GTU-Famicom version 0.50	
+//	Author: aliaspider - aliaspider@gmail.com
+//	License: GPLv3      
+////////////////////////////////////////////////////////
+
+
+uniform sampler2D	source[];
+uniform vec4 		targetSize;
+
+in Vertex {
+	vec2 texCoord;
+	float colorPhase;
+};
+out vec4 fragColor;
+#define pi			3.14159265358
+#define GET_LEVEL(X) ((X)*(255.0f / (128.0f*(1.962f-.518f)))-(.518f / (1.962f-.518f)))
+
+void main() {
+	
+	float level=GET_LEVEL(texture(source[0],texCoord.xy).r);
+	float signal=0.5f*(level+GET_LEVEL(texture(source[0],texCoord.xy-vec2(6.0*targetSize.z,0.0)).r));
+	
+	float chromaSignal=level-signal;
+	float I = chromaSignal * cos (colorPhase * (2.0 * pi / 12.0))*2.0;
+	float Q = chromaSignal * sin (colorPhase * (2.0 * pi / 12.0))*2.0;	
+
+	fragColor.rgb = vec3(signal,I+0.5,Q+0.5);
+}
diff --git a/higan-hack/shaders/Display Emulation/GTUfamicomLite.shader/combFilter.vs b/higan-hack/shaders/Display Emulation/GTUfamicomLite.shader/combFilter.vs
new file mode 100644
index 0000000..73f79e1
--- /dev/null
+++ b/higan-hack/shaders/Display Emulation/GTUfamicomLite.shader/combFilter.vs	
@@ -0,0 +1,27 @@
+#version 150
+
+////////////////////////////////////////////////////////
+//	GTU-Famicom version 0.50	
+//	Author: aliaspider - aliaspider@gmail.com
+//	License: GPLv3      
+////////////////////////////////////////////////////////
+
+#in phaseOffset
+
+uniform vec4 targetSize;
+uniform int  phase;
+
+in vec4 position;
+in vec2 texCoord;
+
+out Vertex{
+	vec2 texCoord;
+	float colorPhase;
+}vertexOut;
+
+void main(void){	
+	gl_Position=position;
+	vertexOut.texCoord=texCoord;	
+	vec2 pos = (texCoord.xy*targetSize.xy)-0.5;	
+	vertexOut.colorPhase=8.0+pos.x+pos.y*4.0+ (phase%2)*4.0+4.0+phaseOffset*12.0;
+}
diff --git a/higan-hack/shaders/Display Emulation/GTUfamicomLite.shader/manifest.bml b/higan-hack/shaders/Display Emulation/GTUfamicomLite.shader/manifest.bml
new file mode 100644
index 0000000..f55e58c
--- /dev/null
+++ b/higan-hack/shaders/Display Emulation/GTUfamicomLite.shader/manifest.bml	
@@ -0,0 +1,68 @@
+// GTUfamicomLite
+// by aliaspider
+settings
+  cropOverscan:
+    active: false
+  noScanlines:
+    active: false
+  tvVerticalResolution: 275.0
+    min: 20.0
+    max: 1000.0
+    step: 1.0
+  signalResolutionY: 350.0
+    min: 20.0
+    max: 500.0
+    step: 1.0
+  signalResolutionI: 125.0
+    min: 20.0
+    max: 350.0
+    step: 1.0
+  signalResolutionQ: 125.0
+    min: 20.0
+    max: 350.0
+    step: 1.0
+  blackLevel: 0.07
+    min: -0.30
+    max: 0.30
+    step: 0.0001
+  contrast: 1.0
+    min: 0.0
+    max: 2.0
+    step: 0.1
+  gamma: 1.0
+    min: 0.5
+    max: 1.5
+    step: 0.01
+  phaseOffset: 0.0
+    min: -0.5
+    max: 0.5
+    step: 0.01
+input
+  filter: nearest
+program
+  width: 800%
+  height: 100%
+  wrap: edge
+  modulo: 32
+  vertex: DAC.vs
+  fragment: DAC.fs
+  pixmap: NesTable.png
+    filter: nearest
+	wrap: border
+program
+  width: 100%
+  height: 100%
+  wrap: edge
+  vertex: combFilter.vs
+  fragment: combFilter.fs
+program
+  height: 100%
+  wrap: edge
+  vertex: scaleX.vs
+  fragment: scaleX.fs
+program
+  wrap: edge
+  vertex: scaleY.vs
+  fragment: scaleY.fs
+output
+  filter: nearest
diff --git a/higan-hack/shaders/Display Emulation/GTUfamicomLite.shader/scaleX.fs b/higan-hack/shaders/Display Emulation/GTUfamicomLite.shader/scaleX.fs
new file mode 100644
index 0000000..5cc59f1
--- /dev/null
+++ b/higan-hack/shaders/Display Emulation/GTUfamicomLite.shader/scaleX.fs	
@@ -0,0 +1,83 @@
+#version 150
+
+////////////////////////////////////////////////////////
+//	GTU-Famicom version 0.50	
+//	Author: aliaspider - aliaspider@gmail.com
+//	License: GPLv3      
+////////////////////////////////////////////////////////
+
+
+#in signalResolutionY
+#in signalResolutionI
+#in signalResolutionQ
+
+#define YIQ_to_RGB 	mat3x3( 1.0   , 1.0      , 1.0      ,	0.9563   , -0.2721   , -1.1070   ,		0.6210   , -0.6474   , 1.7046   )
+
+
+#define pi			3.14159265358
+float STU0 (float x, float b){	
+	x = x*b*pi;
+	return clamp((x+sin(x))/(2.0*pi)+0.5,0.0,1.0);
+}
+float STU(float x, float b){
+	return STU0(x+0.5,b)-STU0(x-0.5,b);
+}
+
+uniform sampler2D	source[];
+uniform vec4		sourceSize[];
+
+in Vertex {
+	vec2 texCoord;
+};
+out vec4 fragColor;
+#define PROCESS_YIQ(X) \
+c=texture(source[0], vec2(texCoord.x - (X)*sourceSize[0].z,texCoord.y)).xyz;\
+tempColor+=vec3((c.x*STU(X,(signalResolutionY*sourceSize[0].z))),\
+                (c.y*STU(X,(signalResolutionI*sourceSize[0].z))),\
+                (c.z*STU(X,(signalResolutionQ*sourceSize[0].z))));
+#define PROCESS_IQ(X) \
+c.yz=texture(source[0], vec2(texCoord.x - (X)*sourceSize[0].z,texCoord.y)).yz;\
+tempColor.yz+=vec2((c.y*STU((X),(signalResolutionI*sourceSize[0].z))),\
+                   (c.z*STU((X),(signalResolutionQ*sourceSize[0].z))));
+#define PROCESS_Q(X) \
+c.z=texture(source[0], vec2(texCoord.x - (X)*sourceSize[0].z,texCoord.y)).z;\
+tempColor.z+=c.z*STU((X),(signalResolutionQ*sourceSize[0].z));
+
+void main() {
+	float	offset	= fract((texCoord.x * sourceSize[0].x) - 0.5);
+	vec3	tempColor = vec3(0.0);	
+	
+	
+	float range=ceil(0.5+sourceSize[0].x/min(min(signalResolutionY,signalResolutionI),signalResolutionQ));
+	range = min ( range, 255.0);
+	float X,i;
+	vec3 	c;
+
+	float rangeY=ceil(0.5+sourceSize[0].x/signalResolutionY);
+	rangeY = min ( range, 255.0);
+	float rangeI=ceil(0.5+sourceSize[0].x/signalResolutionI);
+	rangeI = min ( range, 255.0);
+	float rangeQ=ceil(0.5+sourceSize[0].x/signalResolutionQ);
+	rangeQ = min ( range, 255.0);
+	
+	for (i=1.0-rangeQ;i<1.0-rangeI;i++){
+		PROCESS_Q(offset-i)
+	}
+	for (i=1.0-rangeI;i<1.0-rangeY;i++){
+		PROCESS_IQ(offset-i)	
+	}
+	for (i=1.0-rangeY;i<1.0+rangeY;i++){
+		PROCESS_YIQ(offset-i)	
+	}	
+	for (i=1.0+rangeY;i<1.0+rangeI;i++){
+		PROCESS_IQ(offset-i)
+	}	
+	for (i=1.0+rangeI;i<1.0+rangeQ;i++){
+		PROCESS_Q(offset-i)
+	}		
+	
+	tempColor.gb-=vec2(0.5,0.5);
+	
+	tempColor=clamp(YIQ_to_RGB*tempColor,0.0,1.0);
+	fragColor.rgb = tempColor;
+}
diff --git a/higan-hack/shaders/Display Emulation/GTUfamicomLite.shader/scaleX.vs b/higan-hack/shaders/Display Emulation/GTUfamicomLite.shader/scaleX.vs
new file mode 100644
index 0000000..a051750
--- /dev/null
+++ b/higan-hack/shaders/Display Emulation/GTUfamicomLite.shader/scaleX.vs	
@@ -0,0 +1,29 @@
+#version 150
+
+////////////////////////////////////////////////////////
+//	GTU-Famicom version 0.50	
+//	Author: aliaspider - aliaspider@gmail.com
+//	License: GPLv3      
+////////////////////////////////////////////////////////
+
+#in cropOverscan
+
+in vec4 position;
+in vec2 texCoord;
+
+
+out Vertex{
+	vec2 texCoord;
+}vertexOut;
+
+void main(void){
+	
+#ifdef cropOverscan
+	gl_Position=position;
+	gl_Position.x/=(240.0/256.0);
+#else
+	gl_Position=position;
+#endif
+	
+	vertexOut.texCoord=texCoord;	
+}
diff --git a/higan-hack/shaders/Display Emulation/GTUfamicomLite.shader/scaleY.fs b/higan-hack/shaders/Display Emulation/GTUfamicomLite.shader/scaleY.fs
new file mode 100644
index 0000000..51dc284
--- /dev/null
+++ b/higan-hack/shaders/Display Emulation/GTUfamicomLite.shader/scaleY.fs	
@@ -0,0 +1,71 @@
+#version 150
+
+////////////////////////////////////////////////////////
+//	GTU version 0.50	
+//	Author: aliaspider - aliaspider@gmail.com
+//	License: GPLv3      
+////////////////////////////////////////////////////////
+
+
+#in tvVerticalResolution
+#in noScanlines
+#in blackLevel
+#in contrast
+#in gamma
+#in perfTest2
+
+
+uniform sampler2D	source[];
+uniform vec4		sourceSize[];
+uniform vec4		targetSize;
+
+in Vertex {
+	vec2 texCoord;
+	float range;
+};
+out vec4 fragColor;
+
+#define pi			3.14159265358
+float STU0 (float x, float b){	
+	x = x*b*pi;
+	return clamp(((x+sin(x))/(2.0*pi))+0.5,0.0,1.0);
+}
+float STU(float x, float b){
+	return STU0(x+0.5,b)-STU0(x-0.5,b);
+}
+float STUR(float x, float b,float r){
+	return (STU0(x+r,b)-STU0(x-r,b));
+}
+#ifdef noScanlines		
+#define PROCESS(Y) \
+c=texture(source[0], vec2(texCoord.x,texCoord.y - (Y)*sourceSize[0].w)).xyz;\
+tempColor+=c*STU((Y),(tvVerticalResolution*sourceSize[0].w));
+#define FINISH
+#else
+#define PROCESS(Y) \
+c=texture(source[0], vec2(texCoord.x,texCoord.y - (Y)*sourceSize[0].w)).xyz;\
+tempColor+=c*STUR((Y),tvVerticalResolution*sourceSize[0].w,0.5*(sourceSize[0].y*targetSize.w));
+#define FINISH tempColor*=(sourceSize[0].w*targetSize.y);
+#endif
+
+void main() {
+	
+	float	offset	= fract(texCoord.y * sourceSize[0].y - 0.5);
+	vec3	tempColor = vec3(0.0);	
+
+	float range=ceil(0.5+sourceSize[0].y/tvVerticalResolution);
+	range = min ( range, 255.0);
+	float Y;
+	vec3 	c;
+
+	PROCESS(offset-2)
+	PROCESS(offset-1)
+	PROCESS(offset-0)
+	PROCESS(offset+1)
+	FINISH
+	
+	tempColor-=vec3(blackLevel);
+	tempColor*=(contrast/vec3(1.0-blackLevel));
+	tempColor=pow(tempColor,vec3(gamma));
+	fragColor = vec4(tempColor, 1.0);
+}
diff --git a/higan-hack/shaders/Display Emulation/GTUfamicomLite.shader/scaleY.vs b/higan-hack/shaders/Display Emulation/GTUfamicomLite.shader/scaleY.vs
new file mode 100644
index 0000000..a55cdd4
--- /dev/null
+++ b/higan-hack/shaders/Display Emulation/GTUfamicomLite.shader/scaleY.vs	
@@ -0,0 +1,29 @@
+#version 150
+
+////////////////////////////////////////////////////////
+//	GTU version 0.50	
+//	Author: aliaspider - aliaspider@gmail.com
+//	License: GPLv3      
+////////////////////////////////////////////////////////
+
+#in cropOverscan
+
+
+in vec4 position;
+in vec2 texCoord;
+
+out Vertex{
+	vec2 texCoord;
+}vertexOut;
+
+void main(void){
+	
+#ifdef cropOverscan
+	gl_Position=position;
+	gl_Position.y/=(224.0/240.0);
+#else
+	gl_Position=position;
+#endif
+	
+	vertexOut.texCoord=texCoord;		
+}
diff --git a/higan-hack/shaders/Display Emulation/Game Boy Advance.shader/game-boy-advance.fs b/higan-hack/shaders/Display Emulation/Game Boy Advance.shader/game-boy-advance.fs
new file mode 100644
index 0000000..f68d8c0
--- /dev/null
+++ b/higan-hack/shaders/Display Emulation/Game Boy Advance.shader/game-boy-advance.fs	
@@ -0,0 +1,68 @@
+#version 150
+
+#in coloremulation
+
+#ifdef coloremulation
+const uint curve[32] = {
+  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0e, 0x10, 0x12,
+  0x14, 0x16, 0x18, 0x1c, 0x20, 0x28, 0x38, 0x38,
+  0x40, 0x48, 0x50, 0x58, 0x60, 0x68, 0x70, 0x80,
+  0x88, 0x90, 0xa0, 0xb0, 0xc0, 0xd0, 0xe0, 0xf0
+};
+#endif
+
+uniform sampler2D source[];
+
+in Vertex {
+  vec2 texCoord;
+};
+
+out vec4 fragColor;
+
+void main() {
+  vec4 rgba = texture(source[0], texCoord);
+  #ifndef coloremulation
+  fragColor = rgba;
+  #else
+  uint R = curve[uint(rgba[0] * 31)];
+  uint G = curve[uint(rgba[1] * 31)];
+  uint B = curve[uint(rgba[2] * 31)];
+
+  uint Rr = R * 16;
+  uint Gr = R *  4;
+  uint Br = R *  4;
+
+  uint Rg = G *  8;
+  uint Gg = G * 16;
+  uint Bg = G *  8;
+
+  uint Rb = B *  0;  //intentionally always zero
+  uint Gb = B *  8;
+  uint Bb = B * 16;
+
+  // With no pointers, the shader language has no swap method.
+  #define swap(a, b) {a ^= b; b ^= a; a ^= b;}
+  if(Rr < Rg) swap(Rr, Rg);
+  if(Rr < Rb) swap(Rr, Rb);
+  if(Rg < Rb) swap(Rg, Rb);
+
+  if(Gr < Gg) swap(Gr, Gg);
+  if(Gr < Gb) swap(Gr, Gb);
+  if(Gg < Gb) swap(Gg, Gb);
+
+  if(Br < Bg) swap(Br, Bg);
+  if(Br < Bb) swap(Br, Bb);
+  if(Bg < Bb) swap(Bg, Bb);
+
+  R = (((4 * Rr + 2 * Rg + Rb) * 160) >> 14) + 32;
+  G = (((4 * Gr + 2 * Gg + Gb) * 160) >> 14) + 32;
+  B = (((4 * Br + 2 * Bg + Bb) * 160) >> 14) + 32;
+
+  fragColor = vec4(
+    R / 255.0,
+    G / 255.0,
+    B / 255.0,
+    0.0
+  );
+  #endif
+}
diff --git a/higan-hack/shaders/Display Emulation/Game Boy Advance.shader/manifest.bml b/higan-hack/shaders/Display Emulation/Game Boy Advance.shader/manifest.bml
new file mode 100644
index 0000000..2e49040
--- /dev/null
+++ b/higan-hack/shaders/Display Emulation/Game Boy Advance.shader/manifest.bml	
@@ -0,0 +1,9 @@
+settings
+  //coloremulation
+input
+  // Using linear with color emulation is not recommended.
+  // Colors are rounded down before being converted.
+  filter: nearest
+  wrap: border
+program
+  fragment: game-boy-advance.fs
diff --git a/higan-hack/shaders/Display Emulation/Game Boy Color.shader/game-boy-color.fs b/higan-hack/shaders/Display Emulation/Game Boy Color.shader/game-boy-color.fs
new file mode 100644
index 0000000..918cc18
--- /dev/null
+++ b/higan-hack/shaders/Display Emulation/Game Boy Color.shader/game-boy-color.fs	
@@ -0,0 +1,28 @@
+#version 150
+
+#in coloremulation
+
+uniform sampler2D source[];
+
+in Vertex {
+  vec2 texCoord;
+};
+
+out vec4 fragColor;
+
+void main() {
+  vec4 rgba = texture(source[0], texCoord);
+  #ifndef coloremulation
+  fragColor = rgba;
+  #else
+  float r = rgba[0];
+  float g = rgba[1];
+  float b = rgba[2];
+  fragColor = vec4(
+    min(r * 806 + g * 124 + b *  62, 960.0) / 1023.0,
+    min(          g * 744 + b * 248, 960.0) / 1023.0,
+    min(r * 186 + g * 124 + b * 682, 960.0) / 1023.0,
+    0.0
+  );
+  #endif
+}
diff --git a/higan-hack/shaders/Display Emulation/Game Boy Color.shader/manifest.bml b/higan-hack/shaders/Display Emulation/Game Boy Color.shader/manifest.bml
new file mode 100644
index 0000000..c83a3b2
--- /dev/null
+++ b/higan-hack/shaders/Display Emulation/Game Boy Color.shader/manifest.bml	
@@ -0,0 +1,7 @@
+settings
+  //coloremulation
+input
+  filter: nearest
+  wrap: border
+program
+  fragment: game-boy-color.fs
diff --git a/higan-hack/shaders/Display Emulation/Game Boy.shader/game-boy.fs b/higan-hack/shaders/Display Emulation/Game Boy.shader/game-boy.fs
new file mode 100644
index 0000000..5490a6c
--- /dev/null
+++ b/higan-hack/shaders/Display Emulation/Game Boy.shader/game-boy.fs	
@@ -0,0 +1,40 @@
+#version 150
+
+#in palette
+
+const int green[12] = {
+  0xae, 0xd9, 0x27,
+  0x58, 0xa0, 0x28,
+  0x20, 0x62, 0x29,
+  0x1a, 0x45, 0x2a
+};
+
+const int yellow[12] = {
+  0xff, 0xf7, 0x7b,
+  0xb5, 0xae, 0x4a,
+  0x6b, 0x69, 0x31,
+  0x21, 0x20, 0x10
+};
+
+uniform sampler2D source[];
+
+in Vertex {
+  vec2 texCoord;
+};
+
+out vec4 fragColor;
+
+void main() {
+  #ifndef palette // Standard
+  float brightness = 1.0 - texture(source[0], texCoord)[2];
+  fragColor = brightness;
+  #else           // Color Emulation
+  int color = int(texture(source[0], texCoord)[2] * 3) * 3;
+  fragColor = vec4(
+    palette[color + 0] / 255.0,
+    palette[color + 1] / 255.0,
+    palette[color + 2] / 255.0,
+    0.0
+  );
+  #endif
+}
diff --git a/higan-hack/shaders/Display Emulation/Game Boy.shader/manifest.bml b/higan-hack/shaders/Display Emulation/Game Boy.shader/manifest.bml
new file mode 100644
index 0000000..ee6c782
--- /dev/null
+++ b/higan-hack/shaders/Display Emulation/Game Boy.shader/manifest.bml	
@@ -0,0 +1,11 @@
+settings
+  // Color emulation: green, yellow
+  palette: green
+input
+  // Using linear with a color emulation palette is not recommended.
+  // Colors are rounded up before being converted, making a display that
+  // resembles 2xSaI or HQ#x.
+  filter: nearest
+  wrap: border
+program
+  fragment: game-boy.fs
diff --git a/higan-hack/shaders/Display Emulation/Gameboy-Display-Emulation.shader/manifest.bml b/higan-hack/shaders/Display Emulation/Gameboy-Display-Emulation.shader/manifest.bml
new file mode 100644
index 0000000..cf0de77
--- /dev/null
+++ b/higan-hack/shaders/Display Emulation/Gameboy-Display-Emulation.shader/manifest.bml	
@@ -0,0 +1,37 @@
+// Gameboy-Display-Emulation
+// by aliaspider
+// adapted for Game Boy Display Emulation by hex_usr
+settings
+  //forceMonochromeGameBoy
+  blend
+  spacing: 0.045
+  shadowOffsetX: 0.4
+  shadowOffsetY: 0.4
+  contrast: 0.99
+  baselineAlpha: 0.1
+  shadowOpacity: 0.55
+  foregroundColor: (vec3(20.0,22.0,35.0)/255.0)
+  backgroundColor: (vec3(130.0,228.0,99.0)/255.0)
+  responseTime: 0.333
+history
+  frames: 7
+  filter: nearest
+program
+  width: 100%
+  height: 100%
+  filter: linear
+  wrap: border
+  fragment: pass1.fs
+program
+  width: 100%
+  filter: linear
+  wrap: border
+  vertex: pass2.vs
+  fragment: pass2.fs
+program
+  filter: linear
+  wrap: border
+  vertex: pass3.vs
+  fragment: pass3.fs
+output
+  filter: nearest
diff --git a/higan-hack/shaders/Display Emulation/Gameboy-Display-Emulation.shader/pass1.fs b/higan-hack/shaders/Display Emulation/Gameboy-Display-Emulation.shader/pass1.fs
new file mode 100644
index 0000000..cae668d
--- /dev/null
+++ b/higan-hack/shaders/Display Emulation/Gameboy-Display-Emulation.shader/pass1.fs	
@@ -0,0 +1,55 @@
+// This is a port of the original CG shader to the quark format
+// the original shader can be found here :
+// https://github.com/libretro/common-shaders/tree/master/handheld/gameboy
+
+///////////////////////////////////////////////////////////////////////////
+//                                                                       //
+// Gameboy Classic Shader v0.2.2                                         //
+//                                                                       //
+// Copyright (C) 2013 Harlequin : unknown92835@gmail.com                 //
+//                                                                       //
+// This program is free software: you can redistribute it and/or modify  //
+// it under the terms of the GNU General Public License as published by  //
+// the Free Software Foundation, either version 3 of the License, or     //
+// (at your option) any later version.                                   //
+//                                                                       //
+// This program is distributed in the hope that it will be useful,       //
+// but WITHOUT ANY WARRANTY; without even the implied warranty of        //
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
+// GNU General Public License for more details.                          //
+//                                                                       //
+// You should have received a copy of the GNU General Public License     //
+// along with this program.  If not, see <http://www.gnu.org/licenses/>. //
+//                                                                       //
+///////////////////////////////////////////////////////////////////////////
+
+#version 150
+
+#in forceMonochromeGameBoy
+#in responseTime
+#in baselineAlpha
+
+
+uniform sampler2D source[];
+uniform sampler2D frame[];
+uniform float baseline_alpha;
+in Vertex {
+  vec2 texCoord;
+};
+out vec4 fragColor;
+#ifdef  forceMonochromeGameBoy
+#define GET_ALPHA(src,coord) (1.0-clamp((1.0-texture(src, coord)[2])*(31.54-25.87+47.225),0.0,1.0))
+#else
+#define GET_ALPHA(src,coord) (1.0-clamp((1.0-texture(src, coord)[2])*(0.2126+0.7152+0.0722),0.0,1.0))
+#endif
+void main(void) {	
+	float  c0=GET_ALPHA(source[0],texCoord);
+	c0+=(GET_ALPHA(frame[0],texCoord) - c0) * responseTime;
+	c0+=(GET_ALPHA(frame[0],texCoord) - c0) * pow(responseTime,2.0);
+	c0+=(GET_ALPHA(frame[0],texCoord) - c0) * pow(responseTime,3.0);
+	c0+=(GET_ALPHA(frame[0],texCoord) - c0) * pow(responseTime,4.0);
+	c0+=(GET_ALPHA(frame[0],texCoord) - c0) * pow(responseTime,5.0);
+	c0+=(GET_ALPHA(frame[0],texCoord) - c0) * pow(responseTime,6.0);
+	c0+=(GET_ALPHA(frame[0],texCoord) - c0) * pow(responseTime,7.0);
+	fragColor=vec4(c0*(1.0-baselineAlpha)+baselineAlpha);
+}
diff --git a/higan-hack/shaders/Display Emulation/Gameboy-Display-Emulation.shader/pass2.fs b/higan-hack/shaders/Display Emulation/Gameboy-Display-Emulation.shader/pass2.fs
new file mode 100644
index 0000000..37b1089
--- /dev/null
+++ b/higan-hack/shaders/Display Emulation/Gameboy-Display-Emulation.shader/pass2.fs	
@@ -0,0 +1,67 @@
+// This is a port of the original CG shader to the quark format
+// the original shader can be found here :
+// https://github.com/libretro/common-shaders/tree/master/handheld/gameboy
+
+///////////////////////////////////////////////////////////////////////////
+//                                                                       //
+// Gameboy Classic Shader v0.2.2                                         //
+//                                                                       //
+// Copyright (C) 2013 Harlequin : unknown92835@gmail.com                 //
+//                                                                       //
+// This program is free software: you can redistribute it and/or modify  //
+// it under the terms of the GNU General Public License as published by  //
+// the Free Software Foundation, either version 3 of the License, or     //
+// (at your option) any later version.                                   //
+//                                                                       //
+// This program is distributed in the hope that it will be useful,       //
+// but WITHOUT ANY WARRANTY; without even the implied warranty of        //
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
+// GNU General Public License for more details.                          //
+//                                                                       //
+// You should have received a copy of the GNU General Public License     //
+// along with this program.  If not, see <http://www.gnu.org/licenses/>. //
+//                                                                       //
+///////////////////////////////////////////////////////////////////////////
+
+#version 150
+
+#in blend
+#in spacing
+#in shadowOffsetY
+
+uniform sampler2D source[];
+uniform sampler2D frame[];
+uniform sampler2D pixmap[];
+uniform vec4 sourceSize[];
+uniform vec4 targetSize;
+in Vertex {
+  vec2 texCoord;
+  vec4 newSize;
+};
+
+out vec4 fragColor;
+#define pi			3.14159265358
+#define GAUSS(X) (0.5)*exp(-(X)*(X)*pi*0.25)
+void main(void) {
+	float offset	= fract(texCoord.y * sourceSize[0].y);
+	float  c0=texture(source[0],texCoord.xy-vec2(0.0,(offset-0.5)*sourceSize[0].w)).r;
+
+	float a=1.0-spacing*newSize.y*sourceSize[0].w;
+	a=max(a,0.0);	
+	a=(offset > sourceSize[0].y*newSize.w)?1.0:a;
+#ifdef blend
+	c0=(offset > sourceSize[0].y*newSize.w)?c0:texture(source[0],texCoord.xy).r;
+#endif
+	
+	vec2 shadowCoords=texCoord.xy;
+	shadowCoords.y-=shadowOffsetY*sourceSize[0].w;
+	offset=fract((shadowCoords.y * sourceSize[0].y)-0.5);
+	float blur;
+	blur =texture(source[0],shadowCoords.xy-vec2(0.0,(offset-0.0)*sourceSize[0].w)).g*GAUSS(offset-0.0);
+	blur+=texture(source[0],shadowCoords.xy-vec2(0.0,(offset-1.0)*sourceSize[0].w)).g*GAUSS(offset-1.0);	
+	blur+=texture(source[0],shadowCoords.xy-vec2(0.0,(offset-2.0)*sourceSize[0].w)).g*GAUSS(offset-2.0);
+	blur+=texture(source[0],shadowCoords.xy-vec2(0.0,(offset+1.0)*sourceSize[0].w)).g*GAUSS(offset+1.0);	
+
+	fragColor=vec4(c0,blur,a,a);
+
+}
diff --git a/higan-hack/shaders/Display Emulation/Gameboy-Display-Emulation.shader/pass2.vs b/higan-hack/shaders/Display Emulation/Gameboy-Display-Emulation.shader/pass2.vs
new file mode 100644
index 0000000..2fca668
--- /dev/null
+++ b/higan-hack/shaders/Display Emulation/Gameboy-Display-Emulation.shader/pass2.vs	
@@ -0,0 +1,48 @@
+// This is a port of the original CG shader to the quark format
+// the original shader can be found here :
+// https://github.com/libretro/common-shaders/tree/master/handheld/gameboy
+
+///////////////////////////////////////////////////////////////////////////
+//                                                                       //
+// Gameboy Classic Shader v0.2.2                                         //
+//                                                                       //
+// Copyright (C) 2013 Harlequin : unknown92835@gmail.com                 //
+//                                                                       //
+// This program is free software: you can redistribute it and/or modify  //
+// it under the terms of the GNU General Public License as published by  //
+// the Free Software Foundation, either version 3 of the License, or     //
+// (at your option) any later version.                                   //
+//                                                                       //
+// This program is distributed in the hope that it will be useful,       //
+// but WITHOUT ANY WARRANTY; without even the implied warranty of        //
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
+// GNU General Public License for more details.                          //
+//                                                                       //
+// You should have received a copy of the GNU General Public License     //
+// along with this program.  If not, see <http://www.gnu.org/licenses/>. //
+//                                                                       //
+///////////////////////////////////////////////////////////////////////////
+
+#version 150 
+in vec4 position;
+in vec2 texCoord;
+ 
+out Vertex {
+   vec2 texCoord;
+   vec4 newSize;
+} vertexOut;
+ 
+uniform vec4 targetSize;
+uniform vec4 sourceSize[];
+
+void main() {
+	gl_Position=position;
+	
+	float video_scale=floor(targetSize.y * sourceSize[0].w); 		
+	vertexOut.newSize.xy=sourceSize[0].xy*video_scale;
+    vertexOut.newSize.zw=sourceSize[0].zw/video_scale;
+	vec2 coord=texCoord*targetSize.xy;
+	coord-=floor((targetSize.xy-vertexOut.newSize.xy)/2.0);	
+	vertexOut.texCoord.x=texCoord.x;
+	vertexOut.texCoord.y=coord.y*vertexOut.newSize.w;
+}
diff --git a/higan-hack/shaders/Display Emulation/Gameboy-Display-Emulation.shader/pass3.fs b/higan-hack/shaders/Display Emulation/Gameboy-Display-Emulation.shader/pass3.fs
new file mode 100644
index 0000000..59bdfde
--- /dev/null
+++ b/higan-hack/shaders/Display Emulation/Gameboy-Display-Emulation.shader/pass3.fs	
@@ -0,0 +1,82 @@
+// This is a port of the original CG shader to the quark format
+// the original shader can be found here :
+// https://github.com/libretro/common-shaders/tree/master/handheld/gameboy
+
+///////////////////////////////////////////////////////////////////////////
+//                                                                       //
+// Gameboy Classic Shader v0.2.2                                         //
+//                                                                       //
+// Copyright (C) 2013 Harlequin : unknown92835@gmail.com                 //
+//                                                                       //
+// This program is free software: you can redistribute it and/or modify  //
+// it under the terms of the GNU General Public License as published by  //
+// the Free Software Foundation, either version 3 of the License, or     //
+// (at your option) any later version.                                   //
+//                                                                       //
+// This program is distributed in the hope that it will be useful,       //
+// but WITHOUT ANY WARRANTY; without even the implied warranty of        //
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
+// GNU General Public License for more details.                          //
+//                                                                       //
+// You should have received a copy of the GNU General Public License     //
+// along with this program.  If not, see <http://www.gnu.org/licenses/>. //
+//                                                                       //
+///////////////////////////////////////////////////////////////////////////
+
+#version 150
+
+#in blend
+#in spacing
+#in shadowOffsetX
+#in contrast
+#in shadowOpacity
+#in foregroundColor
+#in backgroundColor
+
+uniform sampler2D source[];
+uniform sampler2D frame[];
+uniform sampler2D pixmap[];
+uniform vec4 sourceSize[2];
+uniform vec4 targetSize;
+
+in Vertex {
+  vec2 texCoord;
+  vec4 newSize;
+};
+
+
+out vec4 fragColor;
+
+#define pi			3.14159265358
+#define GAUSS(X) (0.5)*exp(-(X)*(X)*pi*0.25)
+
+void main(void) {
+	float offset	= fract(texCoord.x * sourceSize[0].x);
+	vec4  c0=texture(source[0],texCoord.xy-vec2((offset-0.5)*sourceSize[0].z,0.0));
+	
+	float a=1.0-spacing*newSize.x*sourceSize[0].z;
+	a=max(a,0.0);	
+	a=(offset > sourceSize[0].x*newSize.z)?c0.a:a;
+
+#ifdef blend
+	c0.r=(offset > sourceSize[0].x*newSize.z)?c0.r:texture(source[0],texCoord.xy).r;
+#endif
+
+	a*=c0.r;
+	
+	vec2 shadowCoords=texCoord.xy;
+	shadowCoords.x-=shadowOffsetX*sourceSize[0].z;
+	offset=fract((shadowCoords.x * sourceSize[0].x)-0.5);
+	float blur;	
+	blur =texture(source[0],shadowCoords.xy-vec2((offset-0.0)*sourceSize[0].z,0.0)).g*GAUSS(offset-0.0);
+	blur+=texture(source[0],shadowCoords.xy-vec2((offset-2.0)*sourceSize[0].z,0.0)).g*GAUSS(offset-2.0);
+	blur+=texture(source[0],shadowCoords.xy-vec2((offset-1.0)*sourceSize[0].z,0.0)).g*GAUSS(offset-1.0);
+	blur+=texture(source[0],shadowCoords.xy-vec2((offset+1.0)*sourceSize[0].z,0.0)).g*GAUSS(offset+1.0);
+
+	
+    vec3 outColor =  backgroundColor * (1.0 - blur * contrast * shadowOpacity);
+    outColor = outColor + a * contrast *( foregroundColor - outColor);
+	fragColor=vec4(outColor,1.0);
+	// fragColor=vec4(1.0-a);
+
+}
diff --git a/higan-hack/shaders/Display Emulation/Gameboy-Display-Emulation.shader/pass3.vs b/higan-hack/shaders/Display Emulation/Gameboy-Display-Emulation.shader/pass3.vs
new file mode 100644
index 0000000..45fe09a
--- /dev/null
+++ b/higan-hack/shaders/Display Emulation/Gameboy-Display-Emulation.shader/pass3.vs	
@@ -0,0 +1,48 @@
+// This is a port of the original CG shader to the quark format
+// the original shader can be found here :
+// https://github.com/libretro/common-shaders/tree/master/handheld/gameboy
+
+///////////////////////////////////////////////////////////////////////////
+//                                                                       //
+// Gameboy Classic Shader v0.2.2                                         //
+//                                                                       //
+// Copyright (C) 2013 Harlequin : unknown92835@gmail.com                 //
+//                                                                       //
+// This program is free software: you can redistribute it and/or modify  //
+// it under the terms of the GNU General Public License as published by  //
+// the Free Software Foundation, either version 3 of the License, or     //
+// (at your option) any later version.                                   //
+//                                                                       //
+// This program is distributed in the hope that it will be useful,       //
+// but WITHOUT ANY WARRANTY; without even the implied warranty of        //
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         //
+// GNU General Public License for more details.                          //
+//                                                                       //
+// You should have received a copy of the GNU General Public License     //
+// along with this program.  If not, see <http://www.gnu.org/licenses/>. //
+//                                                                       //
+///////////////////////////////////////////////////////////////////////////
+
+#version 150 
+in vec4 position;
+in vec2 texCoord;
+ 
+out Vertex {
+   vec2 texCoord;
+   vec4 newSize;
+} vertexOut;
+ 
+uniform vec4 targetSize;
+uniform vec4 sourceSize[];
+
+void main() {
+	gl_Position=position;
+	
+	float video_scale=floor(targetSize.y * sourceSize[1].w); 		
+	vertexOut.newSize.xy=sourceSize[1].xy*video_scale;
+    vertexOut.newSize.zw=sourceSize[1].zw/video_scale;
+	vec2 coord=texCoord*targetSize.xy;
+	coord-=floor((targetSize.xy-vertexOut.newSize.xy)/2.0);
+	vertexOut.texCoord.x=coord.x*vertexOut.newSize.z;	
+	vertexOut.texCoord.y=texCoord.y;
+}
diff --git a/higan-hack/shaders/Display Emulation/PlayChoice-10.shader/manifest.bml b/higan-hack/shaders/Display Emulation/PlayChoice-10.shader/manifest.bml
new file mode 100644
index 0000000..7cadb62
--- /dev/null
+++ b/higan-hack/shaders/Display Emulation/PlayChoice-10.shader/manifest.bml	
@@ -0,0 +1,6 @@
+input
+  filter: nearest
+  wrap: border
+
+program
+  fragment: playchoice-10.fs
diff --git a/higan-hack/shaders/Display Emulation/PlayChoice-10.shader/playchoice-10.fs b/higan-hack/shaders/Display Emulation/PlayChoice-10.shader/playchoice-10.fs
new file mode 100644
index 0000000..f21a770
--- /dev/null
+++ b/higan-hack/shaders/Display Emulation/PlayChoice-10.shader/playchoice-10.fs	
@@ -0,0 +1,18 @@
+#version 150
+
+uniform sampler2D source[];
+
+in Vertex {
+  vec2 texCoord;
+};
+
+out vec4 fragColor;
+
+void main() {
+  vec4 rgbs = texture(source[0], texCoord);
+  if(rgbs[3] < 1.0) { // Game display
+    fragColor = rgbs;
+  } else {            // Menu/instructions display
+    fragColor = vec4(rgbs[0], rgbs[1], rgbs[2], 0.0);
+  }
+}
diff --git a/higan-hack/shaders/Display Emulation/Super Famicom.shader/manifest.bml b/higan-hack/shaders/Display Emulation/Super Famicom.shader/manifest.bml
new file mode 100644
index 0000000..f0b2b33
--- /dev/null
+++ b/higan-hack/shaders/Display Emulation/Super Famicom.shader/manifest.bml	
@@ -0,0 +1,7 @@
+settings
+  //coloremulation
+input
+  filter: nearest
+  wrap: border
+program
+  fragment: super-famicom.fs
diff --git a/higan-hack/shaders/Display Emulation/Super Famicom.shader/super-famicom.fs b/higan-hack/shaders/Display Emulation/Super Famicom.shader/super-famicom.fs
new file mode 100644
index 0000000..db1675b
--- /dev/null
+++ b/higan-hack/shaders/Display Emulation/Super Famicom.shader/super-famicom.fs	
@@ -0,0 +1,41 @@
+#version 150
+
+#in coloremulation
+
+#ifdef coloremulation
+const uint gamma_ramp[32] = {
+  0x00, 0x01, 0x03, 0x06, 0x0a, 0x0f, 0x15, 0x1c,
+  0x24, 0x2d, 0x37, 0x42, 0x4e, 0x5b, 0x69, 0x78,
+  0x88, 0x90, 0x98, 0xa0, 0xa8, 0xb0, 0xb8, 0xc0,
+  0xc8, 0xd0, 0xd8, 0xe0, 0xe8, 0xf0, 0xf8, 0xff
+};
+#endif
+
+uniform sampler2D source[];
+
+in Vertex {
+  vec2 texCoord;
+};
+
+out vec4 fragColor;
+
+void main() {
+  vec4 rgbl = texture(source[0], texCoord);
+  float r = rgbl[0];
+  float g = rgbl[1];
+  float b = rgbl[2];
+  float l = rgbl[3];
+  #ifdef coloremulation
+  r = gamma_ramp[uint(rgbl[0] * 31)] / 255.0;
+  g = gamma_ramp[uint(rgbl[1] * 31)] / 255.0;
+  b = gamma_ramp[uint(rgbl[2] * 31)] / 255.0;
+  #endif
+  float L = (1.0 + l * 15) / 16.0;
+  if(l == 0.0) L *= 0.5;
+  fragColor = vec4(
+    L * r,
+    L * g,
+    L * b,
+    0.0
+  );
+}
diff --git a/higan-hack/shaders/Display Emulation/VS. System.shader/manifest.bml b/higan-hack/shaders/Display Emulation/VS. System.shader/manifest.bml
new file mode 100644
index 0000000..09267d5
--- /dev/null
+++ b/higan-hack/shaders/Display Emulation/VS. System.shader/manifest.bml	
@@ -0,0 +1,6 @@
+input
+  filter: nearest
+  wrap: border
+
+program
+  fragment: vs-system.fs
diff --git a/higan-hack/shaders/Display Emulation/VS. System.shader/vs-system.fs b/higan-hack/shaders/Display Emulation/VS. System.shader/vs-system.fs
new file mode 100644
index 0000000..24283b7
--- /dev/null
+++ b/higan-hack/shaders/Display Emulation/VS. System.shader/vs-system.fs	
@@ -0,0 +1,14 @@
+#version 150
+
+uniform sampler2D source[];
+
+in Vertex {
+  vec2 texCoord;
+};
+
+out vec4 fragColor;
+
+void main() {
+  vec4 rgba = texture(source[0], texCoord);
+  fragColor = rgba;
+}
diff --git a/higan-hack/shaders/Edge Detection.shader/manifest.bml b/higan-hack/shaders/Edge Detection.shader/manifest.bml
index 166db6d..d921065 100644
--- a/higan-hack/shaders/Edge Detection.shader/manifest.bml	
+++ b/higan-hack/shaders/Edge Detection.shader/manifest.bml	
@@ -1,4 +1,6 @@
-program
+input
   filter: linear
   wrap: edge
+
+program
   fragment: edge-detection.fs
diff --git a/higan-hack/shaders/Makefile b/higan-hack/shaders/GNUmakefile
similarity index 64%
rename from higan-hack/shaders/Makefile
rename to higan-hack/shaders/GNUmakefile
index 80d315c..42e2eae 100644
--- a/higan-hack/shaders/Makefile
+++ b/higan-hack/shaders/GNUmakefile
@@ -2,4 +2,6 @@ install:
 	if [ -d /usr/share/higan/Video\ Shaders ]; then sudo rm -r /usr/share/higan/Video\ Shaders; fi
 	sudo mkdir -p /usr/share/higan/Video\ Shaders
 	sudo cp -r *.shader /usr/share/higan/Video\ Shaders
+	sudo mkdir -p /usr/share/higan/Video\ Shaders/Display\ Emulation
+	sudo cp -r /Display\ Emulation/*.shader /usr/share/higan/Video\ Shaders/Display\ Emulation
 	sudo chmod -R 777 /usr/share/higan/Video\ Shaders
diff --git a/higan-hack/shaders/Scanline.shader/manifest.bml b/higan-hack/shaders/Scanline.shader/manifest.bml
index a5db635..b09323a 100644
--- a/higan-hack/shaders/Scanline.shader/manifest.bml
+++ b/higan-hack/shaders/Scanline.shader/manifest.bml
@@ -1,4 +1,6 @@
-program
+input
   filter: linear
   wrap: border
+
+program
   fragment: scanline.fs

