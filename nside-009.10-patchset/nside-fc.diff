diff --git a/higan/higan/fc/GNUmakefile b/nSide/higan/fc/GNUmakefile
index 9eed6a4..171af99 100644
--- a/higan/higan/fc/GNUmakefile
+++ b/nSide/higan/fc/GNUmakefile
@@ -1,13 +1,23 @@
-processors += r6502
+processors += mos6502 z80
 
 objects += fc-interface fc-system fc-controller
-objects += fc-memory fc-cartridge fc-cpu fc-apu fc-ppu
-
-obj/fc-interface.o:  fc/interface/interface.cpp $(call rwildcard,fc/interface/)
-obj/fc-system.o:     fc/system/system.cpp $(call rwildcard,fc/system/)
-obj/fc-controller.o: fc/controller/controller.cpp $(call rwildcard,fc/controller/)
-obj/fc-memory.o:     fc/memory/memory.cpp $(call rwildcard,fc/memory/)
-obj/fc-cartridge.o:  fc/cartridge/cartridge.cpp $(call rwildcard,fc/cartridge/)
-obj/fc-cpu.o:        fc/cpu/cpu.cpp $(call rwildcard,fc/cpu/)
-obj/fc-apu.o:        fc/apu/apu.cpp $(call rwildcard,fc/apu/)
-obj/fc-ppu.o:        fc/ppu/ppu.cpp $(call rwildcard,fc/ppu/)
+objects += fc-cartridge fc-memory
+objects += fc-cpu fc-apu fc-ppu
+objects += fc-expansion
+objects += fc-vssystem fc-playchoice10 fc-famicombox
+
+obj/fc-interface.o:    fc/interface/interface.cpp $(call rwildcard,fc/interface/)
+obj/fc-system.o:       fc/system/system.cpp $(call rwildcard,fc/system/)
+obj/fc-controller.o:   fc/controller/controller.cpp $(call rwildcard,fc/controller/)
+obj/fc-cartridge.o:    fc/cartridge/cartridge.cpp $(call rwildcard,fc/cartridge/)
+obj/fc-memory.o:       fc/memory/memory.cpp $(call rwildcard,fc/memory/)
+
+obj/fc-cpu.o:          fc/cpu/cpu.cpp $(call rwildcard,fc/cpu/)
+obj/fc-apu.o:          fc/apu/apu.cpp $(call rwildcard,fc/apu/)
+obj/fc-ppu.o:          fc/ppu/ppu.cpp $(call rwildcard,fc/ppu/)
+
+obj/fc-expansion.o:    fc/expansion/expansion.cpp $(call rwildcard,fc/expansion/)
+
+obj/fc-vssystem.o:     fc/arcade/vssystem/vssystem.cpp $(call rwildcard,fc/arcade/vssystem/)
+obj/fc-playchoice10.o: fc/arcade/playchoice10/playchoice10.cpp $(call rwildcard,fc/arcade/playchoice10/)
+obj/fc-famicombox.o:   fc/arcade/famicombox/famicombox.cpp $(call rwildcard,fc/arcade/famicombox/)
diff --git a/higan/higan/fc/apu/apu.cpp b/nSide/higan/fc/apu/apu.cpp
index 2f4e4c6..ea92b64 100644
--- a/higan/higan/fc/apu/apu.cpp
+++ b/nSide/higan/fc/apu/apu.cpp
@@ -2,6 +2,8 @@
 
 namespace Famicom {
 
+APU apu;
+
 #include "envelope.cpp"
 #include "sweep.cpp"
 #include "pulse.cpp"
@@ -9,7 +11,6 @@ namespace Famicom {
 #include "noise.cpp"
 #include "dmc.cpp"
 #include "serialization.cpp"
-APU apu;
 
 APU::APU() {
   for(uint amp : range(32)) {
@@ -63,7 +64,11 @@ auto APU::main() -> void {
 }
 
 auto APU::tick() -> void {
-  Thread::step(12);
+  switch(system.region()) {
+  case System::Region::NTSC:  Thread::step(12); break;
+  case System::Region::PAL:   Thread::step(16); break;
+  case System::Region::Dendy: Thread::step(15); break;
+  }
   synchronize(cpu);
 }
 
@@ -75,6 +80,37 @@ auto APU::setSample(int16 sample) -> void {
   cartridgeSample = sample;
 }
 
+auto APU::load(Markup::Node node) -> bool {
+  if(system.vs()) return true;
+
+  string versionString;
+  if(system.fc()) {
+    if(system.region() == System::Region::NTSC)  versionString = node["apu/ntsc-version"].text();
+    if(system.region() == System::Region::PAL)   versionString = node["apu/pal-version"].text();
+    if(system.region() == System::Region::Dendy) versionString = node["apu/dendy-version"].text();
+  } else {
+    versionString = node["apu/version"].text();
+  }
+
+  //NTSC
+  if(versionString == "RP2A03")         version = Version::RP2A03;
+  if(versionString == "RP2A03A")        version = Version::RP2A03A;
+  if(versionString == "RP2A03C")        version = Version::RP2A03C;
+  if(versionString == "RP2A03E")        version = Version::RP2A03E;
+  if(versionString == "RP2A03F")        version = Version::RP2A03F;
+  if(versionString == "RP2A03G")        version = Version::RP2A03G;
+  if(versionString == "RP2A03H")        version = Version::RP2A03H;
+
+  //PAL
+  if(versionString == "RP2A07G")        version = Version::RP2A07G;
+
+  //Dendy
+  if(versionString == "UA6527P")        version = Version::UA6527P;
+  if(versionString == "TA-03NP1-6527P") version = Version::TA_03NP1_6527P;
+
+  return true;
+}
+
 auto APU::power() -> void {
   filter.hipassStrong = 0;
   filter.hipassWeak = 0;
@@ -89,7 +125,13 @@ auto APU::power() -> void {
 
 auto APU::reset() -> void {
   create(APU::Enter, system.colorburst() * 6.0);
-  stream = Emulator::audio.createStream(1, system.colorburst() / 2.0);
+  double clockDivider;
+  switch(system.region()) {
+  case System::Region::NTSC:  clockDivider = 12.0; break;
+  case System::Region::PAL:   clockDivider = 16.0; break;
+  case System::Region::Dendy: clockDivider = 15.0; break;
+  }
+  stream = Emulator::audio.createStream(1, (system.colorburst() * 6.0) / clockDivider);
 
   pulse[0].reset();
   pulse[1].reset();
@@ -204,8 +246,10 @@ auto APU::writeIO(uint16 addr, uint8 data) -> void {
   }
 
   case 0x400e: {
-    noise.shortMode = data & 0x80;
-    noise.period = data & 0x0f;
+    //TODO: Check if the RP2A03E and prior versions support short mode.
+    //Currently assuming that the RP2A03F is bugged. See noise.cpp for bug implementation.
+    if(version != Version::RP2A03) noise.shortMode = data.bit(7);
+    noise.period = data.bits(0,3);
     return;
   }
 
@@ -266,7 +310,7 @@ auto APU::writeIO(uint16 addr, uint8 data) -> void {
       frame.irqPending = false;
       setIRQ();
     }
-    frame.divider = FrameCounter::NtscPeriod;
+    frame.divider = system.region() != System::Region::PAL ? FrameCounter::NtscPeriod : FrameCounter::PalPeriod;
     return;
   }
 
@@ -306,7 +350,7 @@ auto APU::clockFrameCounter() -> void {
   noise.envelope.clock();
 
   if(frame.counter == 0) {
-    if(frame.mode & 2) frame.divider += FrameCounter::NtscPeriod;
+    if(frame.mode & 2) frame.divider += system.region() == System::Region::NTSC ? FrameCounter::NtscPeriod : FrameCounter::PalPeriod;
     if(frame.mode == 0) {
       frame.irqPending = true;
       setIRQ();
@@ -318,7 +362,7 @@ auto APU::clockFrameCounterDivider() -> void {
   frame.divider -= 2;
   if(frame.divider <= 0) {
     clockFrameCounter();
-    frame.divider += FrameCounter::NtscPeriod;
+    frame.divider += system.region() == System::Region::NTSC ? FrameCounter::NtscPeriod : FrameCounter::PalPeriod;
   }
 }
 
@@ -332,7 +376,7 @@ const uint16 APU::noisePeriodTableNTSC[16] = {
 };
 
 const uint16 APU::noisePeriodTablePAL[16] = {
-  4, 7, 14, 30, 60, 88, 118, 148, 188, 236, 354, 472, 708,  944, 1890, 3778,
+  4, 8, 14, 30, 60, 88, 118, 148, 188, 236, 354, 472, 708,  944, 1890, 3778,
 };
 
 const uint16 APU::dmcPeriodTableNTSC[16] = {
diff --git a/higan/higan/fc/apu/apu.hpp b/nSide/higan/fc/apu/apu.hpp
index d0cc83f..afc2307 100644
--- a/higan/higan/fc/apu/apu.hpp
+++ b/nSide/higan/fc/apu/apu.hpp
@@ -1,6 +1,24 @@
 struct APU : Thread {
   shared_pointer<Emulator::Stream> stream;
 
+  enum class Version : uint {
+    //NTSC
+    RP2A03,
+    RP2A03A,
+    RP2A03C,
+    RP2A03E,
+    RP2A03F,
+    RP2A03G,
+    RP2A03H,
+
+    //PAL
+    RP2A07G,
+
+    //Dendy
+    UA6527P,
+    TA_03NP1_6527P,
+  } version;
+
   APU();
 
   static auto Enter() -> void;
@@ -9,6 +27,7 @@ struct APU : Thread {
   auto setIRQ() -> void;
   auto setSample(int16 sample) -> void;
 
+  auto load(Markup::Node) -> bool;
   auto power() -> void;
   auto reset() -> void;
 
@@ -17,6 +36,8 @@ struct APU : Thread {
 
   auto serialize(serializer&) -> void;
 
+  bool side; // VS. System; 0: main, 1: sub
+
   struct Filter {
     auto runHipassStrong(int sample) -> int;
     auto runHipassWeak(int sample) -> int;
@@ -169,7 +190,10 @@ struct APU : Thread {
   struct FrameCounter {
     auto serialize(serializer&) -> void;
 
-    enum : uint { NtscPeriod = 14915 };  //~(21.477MHz / 6 / 240hz)
+    enum : uint {
+      NtscPeriod = 14915,  //~(21.477MHz / 6 / 240hz)
+      PalPeriod = 18473, // conjectural
+    };
 
     bool irqPending;
 
diff --git a/higan/higan/fc/apu/dmc.cpp b/nSide/higan/fc/apu/dmc.cpp
index e829ebd..dc0c233 100644
--- a/higan/higan/fc/apu/dmc.cpp
+++ b/nSide/higan/fc/apu/dmc.cpp
@@ -57,7 +57,8 @@ auto APU::DMC::clock() -> uint8 {
       }
     }
 
-    periodCounter = dmcPeriodTableNTSC[period];
+    if(system.region() != System::Region::PAL) periodCounter = dmcPeriodTableNTSC[period];
+    else                                       periodCounter = dmcPeriodTablePAL[period];
   }
 
   if(lengthCounter > 0 && !dmaBufferValid && dmaDelayCounter == 0) {
@@ -76,7 +77,8 @@ auto APU::DMC::reset() -> void {
   irqPending = 0;
 
   period = 0;
-  periodCounter = dmcPeriodTableNTSC[0];
+  if(system.region() != System::Region::PAL) periodCounter = dmcPeriodTableNTSC[0];
+  else                                       periodCounter = dmcPeriodTablePAL[0];
   irqEnable = 0;
   loopMode = 0;
   dacLatch = 0;
diff --git a/higan/higan/fc/apu/noise.cpp b/nSide/higan/fc/apu/noise.cpp
index dcd9ce9..2b53ffc 100644
--- a/higan/higan/fc/apu/noise.cpp
+++ b/nSide/higan/fc/apu/noise.cpp
@@ -12,14 +12,15 @@ auto APU::Noise::clock() -> uint8 {
   if(--periodCounter == 0) {
     uint feedback;
 
-    if(shortMode) {
+    //TODO: Check if the RP2A03E and prior versions support short mode.
+    if(shortMode && apu.version != APU::Version::RP2A03 && apu.version != APU::Version::RP2A03F) {
       feedback = ((lfsr >> 0) & 1) ^ ((lfsr >> 6) & 1);
     } else {
       feedback = ((lfsr >> 0) & 1) ^ ((lfsr >> 1) & 1);
     }
 
     lfsr = (lfsr >> 1) | (feedback << 14);
-    periodCounter = apu.noisePeriodTableNTSC[period];
+    periodCounter = system.region() != System::Region::PAL ? apu.noisePeriodTableNTSC[period] : apu.noisePeriodTablePAL[period];
   }
 
   return result;
diff --git a/higan/higan/fc/apu/pulse.cpp b/nSide/higan/fc/apu/pulse.cpp
index 4650128..14f20ae 100644
--- a/higan/higan/fc/apu/pulse.cpp
+++ b/nSide/higan/fc/apu/pulse.cpp
@@ -9,7 +9,9 @@ auto APU::Pulse::clock() -> uint8 {
   if(lengthCounter == 0) return 0;
 
   static const uint dutyTable[] = {1, 2, 4, 6};
-  uint8 result = (dutyCounter < dutyTable[duty]) ? envelope.volume() : 0;
+  static const uint umcDutyTable[] = {1, 4, 2, 6};
+  uint dutyLimit = apu.version != APU::Version::UA6527P ? dutyTable[duty] : umcDutyTable[duty];
+  uint8 result = (dutyCounter < dutyLimit) ? envelope.volume() : 0;
   if(sweep.pulsePeriod < 0x008) result = 0;
 
   if(--periodCounter == 0) {
diff --git a/nSide/higan/fc/arcade/arcade.hpp b/nSide/higan/fc/arcade/arcade.hpp
new file mode 100644
index 0000000..c2ecb86
--- /dev/null
+++ b/nSide/higan/fc/arcade/arcade.hpp
@@ -0,0 +1,3 @@
+#include <fc/arcade/vssystem/vssystem.hpp>
+#include <fc/arcade/playchoice10/playchoice10.hpp>
+#include <fc/arcade/famicombox/famicombox.hpp>
diff --git a/nSide/higan/fc/arcade/famicombox/famicombox.cpp b/nSide/higan/fc/arcade/famicombox/famicombox.cpp
new file mode 100644
index 0000000..8e3b762
--- /dev/null
+++ b/nSide/higan/fc/arcade/famicombox/famicombox.cpp
@@ -0,0 +1,399 @@
+#include <fc/fc.hpp>
+
+namespace Famicom {
+
+FamicomBox famicombox;
+
+#include "serialization.cpp"
+
+auto FamicomBox::Enter() -> void {
+  while(true) scheduler.synchronize(), famicombox.main();
+}
+
+auto FamicomBox::main() -> void {
+  if(--counter == 0) {
+    if(--attractionTimer == 0x7fff) trap(Exception::AttractionTimer);
+    //if(++watchdog        == 0x0000) trap(Exception::Watchdog);
+    counter = 3 * 0x2000;
+  }
+  step(1);
+  synchronize(cpu);
+}
+
+auto FamicomBox::init() -> void {
+  dip = 0x3da;
+}
+
+auto FamicomBox::load(Markup::Node node) -> bool {
+  if(auto bios_prg = node["prg/rom/name"].text()) {
+    if(auto fp = interface->open(ID::System, bios_prg, File::Read, File::Required)) {
+      fp->read(famicombox.bios_prg, 32768);
+    } else return false;
+  }
+
+  if(auto bios_chr = node["chr/rom/name"].text()) {
+    if(auto fp = interface->open(ID::System, bios_chr, File::Read, File::Required)) {
+      fp->read(famicombox.bios_chr, 8192);
+    } else return false;
+  }
+
+  return true;
+}
+
+auto FamicomBox::unload() -> void {
+}
+
+auto FamicomBox::power() -> void {
+  exceptionEnable = 0x00;
+}
+
+auto FamicomBox::reset() -> void {
+  create(FamicomBox::Enter, system.colorburst() * 6.0);
+
+  function<auto (uint16, uint8) -> uint8> reader;
+  function<auto (uint16, uint8) -> void> writer;
+
+  reader = {&FamicomBox::wramRead, this};
+  writer = {&FamicomBox::wramWrite, this};
+  bus.map(reader, writer, "0800-1fff");
+
+  reader = {&FamicomBox::portRead, this};
+  writer = {&FamicomBox::portWrite, this};
+  bus.map(reader, writer, "4016-4017");
+  bus.map(reader, writer, "5000-5fff");
+
+  reader = {&FamicomBox::sramRead, this};
+  writer = {&FamicomBox::sramWrite, this};
+  bus.map(reader, writer, "6000-7fff");
+
+  reader = {&FamicomBox::cartridgeRead, this};
+  writer = {&FamicomBox::cartridgeWrite, this};
+  bus.map(reader, writer, "8000-ffff");
+
+  // The cartridge is only mapped to $8000-ffff, not $4018-ffff.
+
+  exceptionTrap = 0xff;
+  ramProtect = 7;
+  counter = 3 * 0x2000;
+  attractionTimer.bits(14,7) = 0xff;
+  watchdog.bits(13,10) = 0x00;
+
+  cartridgeSelect = 1;
+  cartridgeRowSelect = 1;
+  registerLock = false;
+}
+
+auto FamicomBox::setDip(uint10 dip) -> void {
+  this->dip = dip;
+}
+
+auto FamicomBox::trap(Exception exceptionId) -> void {
+  if(exceptionId != Exception::ControllerRead) print("Trap Exception ", (uint)exceptionId, "\n");
+  if(exceptionId != Exception::Watchdog
+  && exceptionEnable.bit((int)exceptionId) == (exceptionId == Exception::Interrupt6_82Hz)) return;
+  exceptionTrap.bit((int)exceptionId) = 0;
+  cartridge.reset();
+  cpu.reset();
+  apu.reset();
+}
+
+auto FamicomBox::wramRead(uint16 addr, uint8 data) -> uint8 {
+  if(addr >= 0x0800 && addr <= 0x1fff) print("read  $", hex(addr, 4U), "\n");
+  switch(addr & 0xf800) {
+  case 0x0000: data = cpu.ram[addr]; break;
+  case 0x0800:
+  case 0x1000:
+  case 0x1800: data = bios_ram[addr - 0x800]; break;
+  }
+}
+
+auto FamicomBox::portRead(uint16 addr, uint8 data) -> uint8 {
+  if((addr & 0xf000) == 0x5000) print("read  $", hex(addr, 4U), "\n");
+
+  if(addr == 0x4016 || addr == 0x4017) {
+    data = cpu.readCPU(addr, data);
+    if(data == 0x4017 && !dip.bit(9)) data.bits(4,3) = 0;
+    watchdog.bits(13,10) = 0;
+    trap(Exception::ControllerRead);
+  }
+
+  if(!registerLock) {
+    switch(addr & 0xf007) {
+
+    //Exception trap flags
+    case 0x5000: {
+      data = exceptionTrap;
+      exceptionTrap = 0xff;
+      return data;
+    }
+
+    //Not used
+    case 0x5001: {
+      return data;
+    }
+
+    //DIP Switches
+    case 0x5002: {
+      return dip & 0xff;
+    }
+
+    //Keyswitch position and coin module status
+    case 0x5003: {
+      return 0x08;
+    }
+
+    //Test connector (25-pin) inputs 2, 15, 3, 16, 4, 17, 5, 18
+    case 0x5004: {
+      return data;
+    }
+
+    //Expansion connector (50-pin) input pin 28
+    case 0x5005: {
+      return data;
+    }
+
+    //Expansion connector (50-pin) input pin 27
+    case 0x5006: {
+      return data;
+    }
+
+    //Misc. status
+    case 0x5007: {
+      return 0x00;
+    }
+
+    }
+  }
+
+  return data;
+}
+
+auto FamicomBox::sramRead(uint16 addr, uint8 data) -> uint8 {
+  return test_ram[addr & 0x1fff];
+}
+
+auto FamicomBox::cartridgeRead(uint16 addr, uint8 data) -> uint8 {
+  switch(cartridgeRowSelect) {
+  case 0:
+    if(cartridgeSelect == 0) return bios_prg[addr];
+    break;
+  case 1:
+    switch(cartridgeSelect) {
+    case  1: return cartridge.readPRG(addr);
+    case  2: return data;
+    case  3: return data;
+    case  4: return data;
+    case  5: return data;
+    }
+    break;
+  case 2:
+    switch(cartridgeSelect) {
+    case  6: return data;
+    case  7: return data;
+    case  8: return data;
+    case  9: return data;
+    case 10: return data;
+    }
+    break;
+  case 3:
+    switch(cartridgeSelect) {
+    case 11: return data;
+    case 12: return data;
+    case 13: return data;
+    case 14: return data;
+    case 15: return data;
+    }
+    break;
+  }
+  return data;
+}
+
+auto FamicomBox::portWrite(uint16 addr, uint8 data) -> void {
+  if((addr & 0xf000) == 0x5000) print("write $", hex(addr, 4U), " 0x", hex(data, 2U), "\n");
+
+  if(addr >= 0x4016 && addr <= 0x4017) return cpu.writeCPU(addr, data);
+
+  if(!registerLock) {
+    switch(addr & 0xf007) {
+
+    //Exception enable flags
+    case 0x5000: {
+      exceptionEnable = data & 0xbf;
+      break;
+    }
+
+    //Coin module flags and CATV output
+    case 0x5001: {
+      break;
+    }
+
+    //Cartridge slot LED and RAM protect register
+    case 0x5002: {
+      //ramProtect = data.bits(6,4);
+      break;
+    }
+
+    //Attraction timer
+    case 0x5003: {
+      attractionTimer.bits(14,7) = 0x00;
+      break;
+    }
+
+    //Cartridge selection register
+    case 0x5004: {
+      cartridgeSelect = data.bits(3,0);
+      cartridgeRowSelect = data.bits(5,4);
+      registerLock |= data.bit(6);
+      break;
+    }
+
+    //Misc. control
+    case 0x5005: {
+      break;
+    }
+
+    //Test connector DB-25 outputs 6, 15, 7, 16, 8, 17, 9, 18
+    case 0x5006: {
+      break;
+    }
+
+    //Expansion connector (50-pin) output pin 26
+    case 0x5007: {
+      break;
+    }
+
+    }
+  }
+}
+
+auto FamicomBox::wramWrite(uint16 addr, uint8 data) -> void {
+  if(addr >= 0x0800 && addr <= 0x1fff) print("write $", hex(addr, 4U), " 0x", hex(data, 2U), "\n");
+  switch(addr & 0xf800) {
+  case 0x0000: {
+    if(ramProtect >= 1) cpu.ram[addr] = data;
+    return;
+  }
+
+  case 0x0800: {
+    if(ramProtect >= 2) bios_ram[addr - 0x800] = data;
+    return;
+  }
+
+  case 0x1000: {
+    if(ramProtect >= 3) bios_ram[addr - 0x800] = data;
+    return;
+  }
+
+  case 0x1800: {
+    if(ramProtect >= 4) bios_ram[addr - 0x800] = data;
+    return;
+  }
+
+  }
+}
+
+auto FamicomBox::sramWrite(uint16 addr, uint8 data) -> void {
+  test_ram[addr & 0x1fff] = data;
+}
+
+auto FamicomBox::cartridgeWrite(uint16 addr, uint8 data) -> void {
+  switch(cartridgeRowSelect) {
+  case 1:
+    switch(cartridgeSelect) {
+    case  1: return cartridge.writePRG(addr, data);
+    case  2: return;
+    case  3: return;
+    case  4: return;
+    case  5: return;
+    }
+    break;
+  case 2:
+    switch(cartridgeSelect) {
+    case  6: return;
+    case  7: return;
+    case  8: return;
+    case  9: return;
+    case 10: return;
+    }
+    break;
+  case 3:
+    switch(cartridgeSelect) {
+    case 11: return;
+    case 12: return;
+    case 13: return;
+    case 14: return;
+    case 15: return;
+    }
+    break;
+  }
+}
+
+auto FamicomBox::chrRead(uint14 addr) -> uint8 {
+  if(cartridgeRowSelect == 0 && cartridgeSelect == 0) {
+    return bios_chr[addr];
+  }
+  switch(cartridgeRowSelect) {
+  case 1:
+    switch(cartridgeSelect) {
+    case  1: return cartridge.readCHR(addr);
+    case  2: break;
+    case  3: break;
+    case  4: break;
+    case  5: break;
+    }
+    break;
+  case 2:
+    switch(cartridgeSelect) {
+    case  6: break;
+    case  7: break;
+    case  8: break;
+    case  9: break;
+    case 10: break;
+    }
+    break;
+  case 3:
+    switch(cartridgeSelect) {
+    case 11: break;
+    case 12: break;
+    case 13: break;
+    case 14: break;
+    case 15: break;
+    }
+    break;
+  }
+  return ppu.io.mdr;
+}
+
+auto FamicomBox::chrWrite(uint14 addr, uint8 data) -> void {
+  switch(cartridgeRowSelect) {
+  case 1:
+    switch(cartridgeSelect) {
+    case  1: return cartridge.writeCHR(addr, data);
+    case  2: break;
+    case  3: break;
+    case  4: break;
+    case  5: break;
+    }
+    break;
+  case 2:
+    switch(cartridgeSelect) {
+    case  6: break;
+    case  7: break;
+    case  8: break;
+    case  9: break;
+    case 10: break;
+    }
+    break;
+  case 3:
+    switch(cartridgeSelect) {
+    case 11: break;
+    case 12: break;
+    case 13: break;
+    case 14: break;
+    case 15: break;
+    }
+    break;
+  }
+}
+
+}
diff --git a/nSide/higan/fc/arcade/famicombox/famicombox.hpp b/nSide/higan/fc/arcade/famicombox/famicombox.hpp
new file mode 100644
index 0000000..82c46e4
--- /dev/null
+++ b/nSide/higan/fc/arcade/famicombox/famicombox.hpp
@@ -0,0 +1,70 @@
+struct FamicomBox : Thread {
+  enum class Exception : uint {
+    Interrupt6_82Hz = 0,
+    AttractionTimer = 1,
+    ControllerRead  = 2,
+    KeyswitchRotate = 3,
+    Coin            = 4,
+    ResetButton     = 5,
+    Watchdog        = 6,
+    CATVPin1        = 7,
+  };
+
+  static auto Enter() -> void;
+  auto main() -> void;
+
+  auto init() -> void;
+  auto load(Markup::Node node) -> bool;
+  auto unload() -> void;
+  auto power() -> void;
+  auto reset() -> void;
+
+  auto setDip(uint10 dip) -> void;
+  auto trap(Exception exceptionId) -> void;
+
+  auto wramRead(uint16 addr, uint8 data) -> uint8;
+  auto portRead(uint16 addr, uint8 data) -> uint8;
+  auto sramRead(uint16 addr, uint8 data) -> uint8;
+  auto cartridgeRead(uint16 addr, uint8 data) -> uint8;
+  auto wramWrite(uint16 addr, uint8 data) -> void;
+  auto portWrite(uint16 addr, uint8 data) -> void;
+  auto sramWrite(uint16 addr, uint8 data) -> void;
+  auto cartridgeWrite(uint16 addr, uint8 data) -> void;
+
+  auto chrRead(uint14 addr) -> uint8;
+  auto chrWrite(uint14 addr, uint8 data) -> void;
+
+  auto serialize(serializer& s) -> void;
+
+  //memory map
+  //0000-07ff: Game RAM
+  //0800-1fff: BIOS RAM
+  //2000-3fff: PPU Registers
+  //4000-4015: APU/CPU Registers
+  //4016-4017: APU/CPU Registers and Watchdog
+  //5000-5fff: FamciomBox registers
+  //6000-7fff: FamicomBox TEST Mode RAM
+  //8000-ffff: cartridge ROM
+  uint8 bios_prg[0x8000];
+  uint8 bios_chr[0x2000];
+
+  uint8 bios_ram[0x1800]; // actually 0x2000, but 0x800 of it is game RAM
+  uint8 test_ram[0x2000];
+
+  uint10 dip;
+
+  uint8 exceptionEnable;
+  uint8 exceptionTrap;
+
+  uint3 ramProtect;
+
+  uint counter;
+  uint15 attractionTimer;
+  uint14 watchdog;
+
+  uint4 cartridgeSelect;
+  uint2 cartridgeRowSelect;
+  bool registerLock;
+};
+
+extern FamicomBox famicombox;
diff --git a/nSide/higan/fc/arcade/famicombox/serialization.cpp b/nSide/higan/fc/arcade/famicombox/serialization.cpp
new file mode 100644
index 0000000..f970bc4
--- /dev/null
+++ b/nSide/higan/fc/arcade/famicombox/serialization.cpp
@@ -0,0 +1,6 @@
+auto FamicomBox::serialize(serializer& s) -> void {
+  s.array(bios_ram);
+  s.array(test_ram);
+
+  s.integer(dip);
+}
diff --git a/nSide/higan/fc/arcade/playchoice10/bus.cpp b/nSide/higan/fc/arcade/playchoice10/bus.cpp
new file mode 100644
index 0000000..8839a7e
--- /dev/null
+++ b/nSide/higan/fc/arcade/playchoice10/bus.cpp
@@ -0,0 +1,95 @@
+auto PlayChoice10::Bus::read(uint16 addr) -> uint8 {
+  if(addr < 0x8000) return bios[addr & 0x3fff];
+  if(addr < 0x8800) return wram[addr & 0x07ff];
+  if(addr < 0x8c00) return sram[addr & 0x03ff];
+  if(addr < 0x9000) return sram[(addr & 0x03ff) | (sramBank << 10)];
+  if(addr < 0x9800) return 0x00;  //VRAM is write-only
+  if(addr < 0xc000) return 0x00;  //open bus
+  if(addr < 0xe000) return cartridge.board->instrom.read(addr & 0x1fff);
+
+  uint8 data = 0xe7;
+  if(!promTest || promAddress < 0x40) {
+    data |= (((cartridge.board->keyrom.read(promAddress >> 3) >> (promAddress & 7)) & 1) << 3) ^ 0x08;
+  } else {
+    data |= (promAddress & 2 ? (uint8)0x00 : cartridge.board->keyrom.read(8)) ^ 0x08;
+  }
+  data |= ((promAddress & 0x20) >> 1) ^ 0x10;
+  return data;
+}
+
+auto PlayChoice10::Bus::write(uint16 addr, uint8 data) -> void {
+  if(addr < 0x8000) return;
+  if(addr < 0x8800) { wram[addr & 0x07ff] = data; return; }
+  if(addr < 0x8c00) { sram[addr & 0x03ff] = data; return; }
+  if(addr < 0x9000) { sram[(addr & 0x03ff) | (sramBank << 10)] = data; return; }
+  if(addr < 0x9800) { playchoice10.videoCircuit.vram[addr & 0x07ff] = data; return; }
+  if(addr < 0xc000) return;
+  if(addr < 0xe000) return;
+
+  promTest = data & 0x10;
+  if(promClock && (data & 0x08) == 0) promAddress++;
+  promClock = data & 0x08;
+  if((data & 0x01) == 0) promAddress = 0;
+  return;
+}
+
+auto PlayChoice10::Bus::in(uint8 addr) -> uint8 {
+  uint8 data = 0x00;
+  bool channelSelect = false;
+  bool enter         = false;
+  bool reset         = false;
+  bool coin2         = false;
+  bool service       = false;
+  bool coin1         = false;
+  switch(addr & 0x03) {
+  case 0x00:
+    data |= channelSelect  << 0;
+    data |= enter          << 1;
+    data |= reset          << 2;
+    data |= cpu.io.nmiLine << 3;
+    data |= 0              << 4;
+    data |= coin2          << 5;
+    data |= service        << 6;
+    data |= coin1          << 7;
+    break;
+  case 0x01: data = (playchoice10.dip >> 0) & 0xff; break;
+  case 0x02: data = (playchoice10.dip >> 8) & 0xff; break;
+  case 0x03: data = 0x00; break;
+  }
+  return data;
+}
+
+auto PlayChoice10::Bus::out(uint8 addr, uint8 data) -> void {
+  data &= 0x01;
+  switch(addr & 0x1f) {
+  case 0x00: playchoice10.vramAccess = data; break;
+  case 0x01: playchoice10.controls   = data; break;
+  case 0x02: playchoice10.ppuOutput  = data; break;
+  case 0x03: playchoice10.apuOutput  = data; break;
+  case 0x04: playchoice10.cpuReset   = data; break;
+  case 0x05: playchoice10.cpuStop    = data; break;
+  case 0x06: playchoice10.display    = data; break;
+  case 0x08: playchoice10.z80NMI     = data; break;
+  case 0x09: playchoice10.watchdog   = data; break;
+  case 0x0a: playchoice10.ppuReset   = data; break;
+  case 0x0b: channel.bit(0)          = data; break;
+  case 0x0c: channel.bit(1)          = data; break;
+  case 0x0d: channel.bit(2)          = data; break;
+  case 0x0e: channel.bit(3)          = data; break;
+  case 0x0f: sramBank                = data; break;
+  }
+  switch(addr & 0x13) {
+  case 0x10: break;
+  case 0x11: break;
+  case 0x12: break;
+  case 0x13: break;
+  }
+}
+
+auto PlayChoice10::Bus::power() -> void {
+  channel    = 0;  //channel 1 on-screen
+  sramBank   = 1;
+}
+
+auto PlayChoice10::Bus::reset() -> void {
+}
diff --git a/nSide/higan/fc/arcade/playchoice10/cpu.cpp b/nSide/higan/fc/arcade/playchoice10/cpu.cpp
new file mode 100644
index 0000000..d59d55b
--- /dev/null
+++ b/nSide/higan/fc/arcade/playchoice10/cpu.cpp
@@ -0,0 +1,23 @@
+auto PlayChoice10::CPU::Enter() -> void {
+  while(true) scheduler.synchronize(), playchoice10.pc10cpu.main();
+}
+
+auto PlayChoice10::CPU::main() -> void {
+  instruction();
+}
+
+auto PlayChoice10::CPU::step(uint clocks) -> void {
+  Thread::step(clocks);
+  synchronize(playchoice10.videoCircuit);
+  synchronize(cpu);
+}
+
+auto PlayChoice10::CPU::power() -> void {
+  Processor::Z80::bus = &playchoice10.pc10bus;
+  Processor::Z80::power();
+}
+
+auto PlayChoice10::CPU::reset() -> void {
+  Processor::Z80::reset();
+  create(PlayChoice10::CPU::Enter, 4'000'000.0);
+}
diff --git a/nSide/higan/fc/arcade/playchoice10/playchoice10.cpp b/nSide/higan/fc/arcade/playchoice10/playchoice10.cpp
new file mode 100644
index 0000000..d81e3fb
--- /dev/null
+++ b/nSide/higan/fc/arcade/playchoice10/playchoice10.cpp
@@ -0,0 +1,69 @@
+#include <fc/fc.hpp>
+
+namespace Famicom {
+
+PlayChoice10 playchoice10;
+
+#include "bus.cpp"
+#include "cpu.cpp"
+#include "video-circuit.cpp"
+#include "serialization.cpp"
+
+auto PlayChoice10::init() -> void {
+  dip = 0;
+  screenConfig = ScreenConfig::Single;
+}
+
+auto PlayChoice10::load(Markup::Node node) -> bool {
+  if(auto firmware = node["cpu/rom/name"].text()) {
+    if(auto fp = interface->open(ID::System, firmware, File::Read, File::Required)) {
+      fp->read(pc10bus.bios, 16384);
+    } else return false;
+  }
+
+  if(auto character = node["pc10/video-circuit/vrom/name"].text()) {
+    if(auto fp = interface->open(ID::System, character, File::Read, File::Required)) {
+      fp->read(videoCircuit.chrrom, 24576);
+    } else return false;
+  }
+
+  if(auto palette = node["pc10/video-circuit/cgrom/name"].text()) {
+    if(auto fp = interface->open(ID::System, palette, File::Read, File::Required)) {
+      fp->read(videoCircuit.cgrom, 768);
+    } else return false;
+  }
+
+  screenConfig = min(max(node["pc10/screen/mode"].integer(), 1), 2);
+  return true;
+}
+
+auto PlayChoice10::unload() -> void {
+}
+
+auto PlayChoice10::power() -> void {
+  pc10bus.power();
+  pc10cpu.power();
+  videoCircuit.power();
+  vramAccess = 1; // 0: Z80,                  1: video circuit
+  controls   = 1; // 0: disable START/SELECT, 1: enable START/SELECT
+  ppuOutput  = 1; // 0: disable,              1: enable
+  apuOutput  = 1; // 0: disable,              1: enable
+  cpuReset   = 1; // 0: reset,                1: run
+  cpuStop    = 1; // 0: stop,                 1: run
+  display    = 1; // 0: video circuit,        1: PPU
+  z80NMI     = 0; // 0: disable,              1: enable
+  watchdog   = 1; // 0: enable,               1: disable
+  ppuReset   = 1; // 0: reset,                1: run
+}
+
+auto PlayChoice10::reset() -> void {
+  pc10bus.reset();
+  pc10cpu.reset();
+  videoCircuit.reset();
+}
+
+auto PlayChoice10::setDip(uint16 dip) -> void {
+  this->dip = dip;
+}
+
+}
diff --git a/nSide/higan/fc/arcade/playchoice10/playchoice10.hpp b/nSide/higan/fc/arcade/playchoice10/playchoice10.hpp
new file mode 100644
index 0000000..39199d8
--- /dev/null
+++ b/nSide/higan/fc/arcade/playchoice10/playchoice10.hpp
@@ -0,0 +1,96 @@
+struct PlayChoice10 {
+  struct ScreenConfig { enum : uint {
+    Dual = 2,
+    Single = 1,
+  };};
+
+  auto init() -> void;
+  auto load(Markup::Node node) -> bool;
+  auto unload() -> void;
+  auto power() -> void;
+  auto reset() -> void;
+
+  auto setDip(uint16 dip) -> void;
+
+  auto serialize(serializer& s) -> void;
+
+  uint16 dip;
+  uint screenConfig;
+
+  bool vramAccess;
+  bool controls;
+  bool ppuOutput;
+  bool apuOutput;
+  bool cpuReset;
+  bool cpuStop;
+  bool display;
+  bool z80NMI;
+  bool watchdog;
+  bool ppuReset;
+
+  struct Bus : Processor::Z80::Bus {
+    auto read(uint16 addr) -> uint8 override;
+    auto write(uint16 addr, uint8 data) -> void override;
+
+    auto in(uint8 addr) -> uint8 override;
+    auto out(uint8 addr, uint8 data) -> void override;
+
+    auto power() -> void;
+    auto reset() -> void;
+
+    auto serialize(serializer& s) -> void;
+
+    uint8 bios[0x4000];
+
+  private:
+    //memory map
+    //8000-87ff: WRAM
+    //8800-8bff: SRAM bank 0
+    //8c00-8fff: SRAM switchable bank (0 or 1)
+    //9000-97ff: VRAM
+    //9800-bfff: open bus
+    //c000-dfff: cartridge instruction ROM
+    //e000-ffff: cartridge IO registers
+    uint8 wram[0x800];
+    uint8 sram[0x800];
+
+    uint4 channel;
+    bool sramBank;
+    bool promTest;
+    bool promClock;
+    uint7 promAddress;
+  } pc10bus;
+
+  struct CPU : Processor::Z80, Thread {
+    static auto Enter() -> void;
+    auto main() -> void;
+    auto step(uint clocks) -> void;
+
+    auto power() -> void;
+    auto reset() -> void;
+
+    auto serialize(serializer& s) -> void;
+  } pc10cpu;
+
+  struct VideoCircuit : Thread {
+    static auto Enter() -> void;
+    auto main() -> void;
+    auto step(uint clocks) -> void;
+    auto refresh() -> void;
+
+    auto power() -> void;
+    auto reset() -> void;
+
+    auto run(uint x, uint y) -> void;
+
+    uint8 chrrom[0x2000 * 3];
+    uint8 cgrom[0x100 * 3];
+
+    uint8 vram[2048];
+
+  private:
+    uint32 buffer[256 * 240];
+  } videoCircuit;
+};
+
+extern PlayChoice10 playchoice10;
diff --git a/nSide/higan/fc/arcade/playchoice10/serialization.cpp b/nSide/higan/fc/arcade/playchoice10/serialization.cpp
new file mode 100644
index 0000000..3afc7a0
--- /dev/null
+++ b/nSide/higan/fc/arcade/playchoice10/serialization.cpp
@@ -0,0 +1,32 @@
+auto PlayChoice10::serialize(serializer& s) -> void {
+  pc10bus.serialize(s);
+  pc10cpu.serialize(s);
+
+  s.integer(dip);
+
+  s.integer(vramAccess);
+  s.integer(controls);
+  s.integer(ppuOutput);
+  s.integer(apuOutput);
+  s.integer(cpuReset);
+  s.integer(cpuStop);
+  s.integer(display);
+  s.integer(z80NMI);
+  s.integer(watchdog);
+  s.integer(ppuReset);
+
+  s.array(videoCircuit.vram);
+}
+
+auto PlayChoice10::Bus::serialize(serializer& s) -> void {
+  s.integer(channel);
+  s.integer(sramBank);
+
+  s.array(wram);
+  s.array(sram);
+}
+
+auto PlayChoice10::CPU::serialize(serializer& s) -> void {
+  Processor::Z80::serialize(s);
+  Thread::serialize(s);
+}
diff --git a/nSide/higan/fc/arcade/playchoice10/video-circuit.cpp b/nSide/higan/fc/arcade/playchoice10/video-circuit.cpp
new file mode 100644
index 0000000..e7f84a9
--- /dev/null
+++ b/nSide/higan/fc/arcade/playchoice10/video-circuit.cpp
@@ -0,0 +1,205 @@
+auto PlayChoice10::VideoCircuit::Enter() -> void {
+  while(true) scheduler.synchronize(), playchoice10.videoCircuit.main();
+}
+
+auto PlayChoice10::VideoCircuit::main() -> void {
+  for(uint y : range(256)) {
+    for(uint x : range(327)) {
+      run(x, y);
+    }
+    step(4 * 327);
+  }
+}
+
+auto PlayChoice10::VideoCircuit::step(uint clocks) -> void {
+  Thread::step(clocks);
+  synchronize(playchoice10.pc10cpu);
+}
+
+auto PlayChoice10::VideoCircuit::refresh() -> void {
+  if(playchoice10.screenConfig == ScreenConfig::Dual) {
+    Emulator::video.refreshRegion(buffer, 256 * sizeof(uint32), 0, 0, 256, 224, 1 << 9);
+  }
+}
+
+auto PlayChoice10::VideoCircuit::power() -> void {
+  uint8 defaultVRAM[0x0780] = {
+0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,
+0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,
+0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,
+0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,
+
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+
+0xff,0x1b,0xdb,0x1b,0xdc,0x1b,0xdc,0x1b,0xdc,0x1b,0xdc,0x1b,0xdc,0x1b,0xdc,0x1b,
+0xdc,0x1b,0xdc,0x1b,0xdc,0x1b,0xdc,0x1b,0xdc,0x1b,0xdc,0x1b,0xdc,0x1b,0xdc,0x1b,
+0xdc,0x1b,0xdc,0x1b,0xdc,0x1b,0xdc,0x1b,0xdc,0x1b,0xdc,0x1b,0xdc,0x1b,0xdc,0x1b,
+0xdc,0x1b,0xdc,0x1b,0xdc,0x1b,0xdc,0x1b,0xdc,0x1b,0xdc,0x1b,0xdd,0x1b,0xff,0x1b,
+
+0xff,0x1b,0xe2,0x1b,0xfa,0x1b,0xfa,0x1b,0xfa,0x1b,0xfa,0x1b,0xfa,0x1b,0xfa,0x1b,
+0xfa,0x1b,0xfa,0x1b,0xfa,0x1b,0xfa,0x1b,0xfa,0x1b,0xfa,0x1b,0xfa,0x1b,0xfa,0x1b,
+0xfa,0x1b,0xfa,0x1b,0xfa,0x1b,0xfa,0x1b,0xfa,0x1b,0xfa,0x1b,0xfa,0x1b,0xfa,0x1b,
+0xfa,0x1b,0xfa,0x1b,0xfa,0x1b,0x64,0x1b,0x65,0x1b,0xfa,0x1b,0xde,0x1b,0xff,0x1b,
+
+0xff,0x1b,0xe2,0x1b,0xd8,0x1b,0xd8,0x1b,0x66,0x1b,0x67,0x1b,0x68,0x1b,0x69,0x1b,
+0x6a,0x1b,0xd8,0x1b,0xd8,0x1b,0xd8,0x1b,0xd8,0x1b,0x6b,0x1b,0x6c,0x1b,0x6d,0x1b,
+0x6e,0x1b,0xd8,0x1b,0xd8,0x1b,0x6f,0x1b,0xd8,0x1b,0xd8,0x1b,0xd8,0x1b,0xd8,0x1b,
+0xd8,0x1b,0x70,0x1b,0x71,0x1b,0x72,0x1b,0xd8,0x1b,0xd8,0x1b,0xde,0x1b,0xff,0x1b,
+
+0xff,0x1b,0xe2,0x1b,0xd9,0x1b,0xd9,0x1b,0x73,0x1b,0x74,0x1b,0x75,0x1b,0x76,0x1b,
+0x77,0x1b,0x78,0x1b,0x79,0x1b,0x7a,0x1b,0x7b,0x1b,0x7c,0x1b,0x7d,0x1b,0x7e,0x1b,
+0x7f,0x1b,0x80,0x1b,0x81,0x1b,0x82,0x1b,0x83,0x1b,0x84,0x1b,0x85,0x1b,0xd9,0x1b,
+0xd9,0x1b,0x86,0x1b,0x87,0x1b,0x88,0x1b,0x89,0x1b,0xd9,0x1b,0xde,0x1b,0xff,0x1b,
+
+0xff,0x1b,0xe2,0x1b,0xfa,0x1b,0xfa,0x1b,0x8a,0x1b,0x8b,0x1b,0x8c,0x1b,0x8d,0x1b,
+0x8e,0x1b,0x8f,0x1b,0x90,0x1b,0x91,0x1b,0x92,0x1b,0x93,0x1b,0x94,0x1b,0x95,0x1b,
+0x96,0x1b,0x97,0x1b,0x98,0x1b,0x99,0x1b,0x9a,0x1b,0x9b,0x1b,0x9c,0x1b,0xfa,0x1b,
+0xfa,0x1b,0x9d,0x1b,0x9e,0x1b,0x9f,0x1b,0xa0,0x1b,0xfa,0x1b,0xde,0x1b,0xff,0x1b,
+
+0xff,0x1b,0xe2,0x1b,0xfa,0x1b,0xa1,0x1b,0xa2,0x1b,0xa3,0x1b,0xa4,0x1b,0xa5,0x1b,
+0xa6,0x1b,0xa7,0x1b,0xa8,0x1b,0xa9,0x1b,0xaa,0x1b,0xab,0x1b,0xac,0x1b,0xad,0x1b,
+0xae,0x1b,0xaf,0x1b,0xb0,0x1b,0xb1,0x1b,0xb2,0x1b,0xb3,0x1b,0xb4,0x1b,0xb5,0x1b,
+0xb6,0x1b,0xb7,0x1b,0xb8,0x1b,0xb9,0x1b,0xba,0x1b,0xfa,0x1b,0xde,0x1b,0xff,0x1b,
+
+0xff,0x1b,0xe2,0x1b,0xda,0x1b,0xbb,0x1b,0xbc,0x1b,0xbd,0x1b,0xbe,0x1b,0xbf,0x1b,
+0xc0,0x1b,0xc1,0x1b,0xc2,0x1b,0xc3,0x1b,0xc4,0x1b,0xc5,0x1b,0xc6,0x1b,0xc7,0x1b,
+0xc8,0x1b,0xc9,0x1b,0xca,0x1b,0xcb,0x1b,0xcc,0x1b,0xcd,0x1b,0xce,0x1b,0xda,0x1b,
+0xcf,0x1b,0xd0,0x1b,0xd1,0x1b,0xd2,0x1b,0xda,0x1b,0xda,0x1b,0xde,0x1b,0xff,0x1b,
+
+0xff,0x1b,0xe2,0x1b,0xd8,0x1b,0xd8,0x1b,0xd8,0x1b,0xd8,0x1b,0xd8,0x1b,0xd8,0x1b,
+0xd3,0x1b,0xd4,0x1b,0xd5,0x1b,0xd8,0x1b,0xd8,0x1b,0xd8,0x1b,0xd8,0x1b,0xd8,0x1b,
+0xd8,0x1b,0xd8,0x1b,0xd8,0x1b,0xd8,0x1b,0xd8,0x1b,0xd8,0x1b,0xd8,0x1b,0xd8,0x1b,
+0xd8,0x1b,0xd8,0x1b,0xd8,0x1b,0xd8,0x1b,0xd8,0x1b,0xd8,0x1b,0xde,0x1b,0xff,0x1b,
+
+0xff,0x1b,0xe2,0x1b,0xfa,0x1b,0xfa,0x1b,0xfa,0x1b,0xfa,0x1b,0xfa,0x1b,0xfa,0x1b,
+0xd6,0x1b,0xd7,0x1b,0xfa,0x1b,0xfa,0x1b,0xfa,0x1b,0xfa,0x1b,0xfa,0x1b,0xfa,0x1b,
+0xfa,0x1b,0xfa,0x1b,0xfa,0x1b,0xfa,0x1b,0xfa,0x1b,0xfa,0x1b,0xfa,0x1b,0xfa,0x1b,
+0xfa,0x1b,0xfa,0x1b,0xfa,0x1b,0xfa,0x1b,0xfa,0x1b,0xfa,0x1b,0xde,0x1b,0xff,0x1b,
+
+0xff,0x1b,0xe1,0x1b,0xe0,0x1b,0xe0,0x1b,0xe0,0x1b,0xe0,0x1b,0xe0,0x1b,0xe0,0x1b,
+0xe0,0x1b,0xe0,0x1b,0xe0,0x1b,0xe0,0x1b,0xe0,0x1b,0xe0,0x1b,0xe0,0x1b,0xe0,0x1b,
+0xe0,0x1b,0xe0,0x1b,0xe0,0x1b,0xe0,0x1b,0xe0,0x1b,0xe0,0x1b,0xe0,0x1b,0xe0,0x1b,
+0xe0,0x1b,0xe0,0x1b,0xe0,0x1b,0xe0,0x1b,0xe0,0x1b,0xe0,0x1b,0xdf,0x1b,0xff,0x1b,
+
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xe3,0x1b,0xe4,0x1b,0xe5,0x1b,0xe6,0x1b,0xe7,0x1b,0xe8,0x1b,
+0xe9,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xea,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xeb,0x1b,0xec,0x1b,0xed,0x1b,0xee,0x1b,0xef,0x1b,0xf0,0x1b,
+0xf1,0x1b,0xf2,0x1b,0xf3,0x1b,0xf4,0x1b,0xf5,0x1b,0xf6,0x1b,0xf7,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+
+0x14,0xf9,0x15,0xf9,0x15,0xf9,0x15,0xf9,0x15,0xf9,0x15,0xf9,0x15,0xf9,0x15,0xf9,
+0x15,0xf9,0x15,0xf9,0x15,0xf9,0x15,0xf9,0x15,0xf9,0x15,0xf9,0x15,0xf9,0x15,0xf9,
+0x15,0xf9,0x15,0xf9,0x15,0xf9,0x15,0xf9,0x16,0xf9,0x14,0xf9,0x15,0xf9,0x15,0xf9,
+0x15,0xf9,0x15,0xf9,0x15,0xf9,0x15,0xf9,0x15,0xf9,0x15,0xf9,0x15,0xf9,0x16,0xf9,
+
+0x1b,0xf9,0xff,0xf9,0xff,0xf9,0xff,0xf9,0xff,0xf9,0xff,0xf9,0xff,0xf9,0xff,0xf9,
+0xff,0xf9,0xff,0xf9,0xff,0xf9,0xff,0xf9,0xff,0xf9,0xff,0xf9,0xff,0xf9,0xff,0xf9,
+0xff,0xf9,0xff,0xf9,0xff,0xf9,0xff,0xf9,0x17,0xf9,0x1b,0xf9,0x1c,0xf9,0x1d,0xf9,
+0x1e,0xf9,0x1f,0xf9,0x20,0xf9,0xff,0xf9,0xff,0xf9,0xff,0xf9,0x00,0xf9,0x17,0xf9,
+
+0x1b,0xf9,0xff,0xf9,0xff,0xf9,0xff,0xf9,0xff,0xf9,0x26,0xf9,0x27,0xf9,0x28,0xf9,
+0x29,0xf9,0x2a,0xf9,0x2b,0xf9,0x2c,0xf9,0x2d,0xf9,0x2e,0xf9,0xff,0xf9,0x2f,0xf9,
+0x2f,0xf9,0xff,0xf9,0xff,0xf9,0xff,0xf9,0x17,0xf9,0x1b,0xf9,0x21,0xf9,0x22,0xf9,
+0x23,0xf9,0x24,0xf9,0x25,0xf9,0xff,0xf9,0xff,0xf9,0xff,0xf9,0x01,0xf9,0x17,0xf9,
+
+0x1a,0xf9,0x19,0xf9,0x19,0xf9,0x19,0xf9,0x19,0xf9,0x19,0xf9,0x19,0xf9,0x19,0xf9,
+0x19,0xf9,0x19,0xf9,0x19,0xf9,0x19,0xf9,0x19,0xf9,0x19,0xf9,0x19,0xf9,0x19,0xf9,
+0x19,0xf9,0x19,0xf9,0x19,0xf9,0x19,0xf9,0x18,0xf9,0x1a,0xf9,0x19,0xf9,0x19,0xf9,
+0x19,0xf9,0x19,0xf9,0x19,0xf9,0x19,0xf9,0x19,0xf9,0x19,0xf9,0x19,0xf9,0x18,0xf9,
+
+0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,
+0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,
+0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,
+0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,
+  };
+  for(uint addr = 0x9040; addr <= 0x97bf; addr++) {
+    vram[addr & 0x07ff] = defaultVRAM[(addr & 0x07ff) - 0x40];
+  }
+}
+
+auto PlayChoice10::VideoCircuit::reset() -> void {
+  create(VideoCircuit::Enter, 20'160'000.0);
+}
+
+auto PlayChoice10::VideoCircuit::run(uint x, uint y) -> void {
+  if(y < 16 || y >= 240 || x >= 256) return;
+
+  uint tileY = y >> 3;
+  uint tileX = x >> 3;
+  uint16 addr = (tileY * 32 + tileX) << 1;
+  uint tileID = ((vram[addr | 0] & 0xff) << 0) + ((vram[addr | 1] & 0x07) << 8);
+
+  uint pixelY = y & 7;
+  uint pixelX = x & 7;
+
+  uint32 color = vram[addr | 1].bits(3,7) << 3;
+  uint8 byte;
+  for(uint plane : range(3)) {
+    byte = chrrom[(plane << 13) + (tileID << 3) + pixelY];
+    color.bit(plane) = byte.bit(7 - pixelX);
+  }
+
+  buffer[(y - 16) * 256 + x] = color;
+}
diff --git a/nSide/higan/fc/arcade/vssystem/control.cpp b/nSide/higan/fc/arcade/vssystem/control.cpp
new file mode 100644
index 0000000..4bfc735
--- /dev/null
+++ b/nSide/higan/fc/arcade/vssystem/control.cpp
@@ -0,0 +1,60 @@
+auto VSSystem::resetButtons() -> void {
+  mainControlLatched = 0;
+  mainControlCounter1 = 0;
+  mainControlCounter2 = 0;
+
+  subControlLatched = 0;
+  subControlCounter1 = 0;
+  subControlCounter2 = 0;
+
+  for(bool& button : mainButtons) button = false;
+  for(bool& button : subButtons) button = false;
+}
+
+auto VSSystem::poll(bool side, uint input) -> int16 {
+  return interface->inputPoll(ID::Port::Arcade, ID::Device::VSPanel, input);
+}
+
+auto VSSystem::data1(bool side) -> bool {
+  uint& counter = side == 0 ? mainControlCounter1 : subControlCounter1;
+  bool* buttons = side == 0 ? mainButtons : subButtons;
+  bool data;
+  if(!swapControllers) data = peripherals.controllerPort1->data() & 0x01;
+  else                 data = peripherals.controllerPort2->data() & 0x01;
+  if(counter == 2) return buttons[Button1];
+  if(counter == 3) return buttons[Button3];
+  return data;
+}
+
+auto VSSystem::data2(bool side) -> bool {
+  uint& counter = side == 0 ? mainControlCounter2 : subControlCounter2;
+  bool* buttons = side == 0 ? mainButtons : subButtons;
+  bool data;
+  if(!swapControllers) data = peripherals.controllerPort2->data() & 0x01;
+  else                 data = peripherals.controllerPort1->data() & 0x01;
+  if(counter == 2) return buttons[Button2];
+  if(counter == 3) return buttons[Button4];
+  return data;
+}
+
+auto VSSystem::latch(bool side, bool data) -> void {
+  if(side == 0) {
+    if(mainControlLatched == data) return;
+    mainControlLatched = data;
+    mainControlCounter1 = 0;
+    mainControlCounter2 = 0;
+
+    if(mainControlLatched == 0) {
+      for(uint i : {Button1, Button2, Button3, Button4}) mainButtons[i] = poll(0, i);
+    }
+  } else {
+    if(subControlLatched == data) return;
+    subControlLatched = data;
+    subControlCounter1 = 0;
+    subControlCounter2 = 0;
+
+    if(subControlLatched == 0) {
+      for(uint i : {Button1, Button2, Button3, Button4}) subButtons[i] = poll(1, i);
+    }
+  }
+}
diff --git a/nSide/higan/fc/arcade/vssystem/serialization.cpp b/nSide/higan/fc/arcade/vssystem/serialization.cpp
new file mode 100644
index 0000000..43b9c5e
--- /dev/null
+++ b/nSide/higan/fc/arcade/vssystem/serialization.cpp
@@ -0,0 +1,9 @@
+auto VSSystem::serialize(serializer& s) -> void {
+  s.array(ram);
+  s.integer(ramSide);
+
+  s.integer(swapControllers);
+  s.integer(mainDip);
+  s.integer(subDip);
+  s.integer(watchdog);
+}
diff --git a/nSide/higan/fc/arcade/vssystem/vssystem.cpp b/nSide/higan/fc/arcade/vssystem/vssystem.cpp
new file mode 100644
index 0000000..064cd85
--- /dev/null
+++ b/nSide/higan/fc/arcade/vssystem/vssystem.cpp
@@ -0,0 +1,115 @@
+#include <fc/fc.hpp>
+
+namespace Famicom {
+
+VSSystem vssystem;
+
+#include "control.cpp"
+#include "serialization.cpp"
+
+auto VSSystem::Enter() -> void {
+  while(true) scheduler.synchronize(), vssystem.main();
+}
+
+auto VSSystem::main() -> void {
+  //if(++watchdog > system.cpuFrequency() * 4 / 3) {
+  //  watchdog = 0;
+  //  cpu.reset();
+  //  //ppu.reset();
+  //}
+  step(1);
+  synchronize(cpu);
+}
+
+auto VSSystem::init() -> void {
+  forceSubRAM = false;
+  gameCount = GameCount::Uni;
+}
+
+auto VSSystem::load() -> bool {
+  return true;
+}
+
+auto VSSystem::unload() -> void {
+}
+
+auto VSSystem::power() -> void {
+  reset();
+}
+
+auto VSSystem::reset() -> void {
+  create(VSSystem::Enter, system.colorburst() * 6.0);
+
+  function<auto (uint16, uint8) -> uint8> reader;
+  function<auto (uint16, uint8) -> void> writer;
+  reader = [](uint16 addr, uint8 data) -> uint8 { return vssystem.read(cpu.side, addr, data); };
+  writer = [](uint16 addr, uint8 data) -> void { vssystem.write(cpu.side, addr, data); };
+  bus.map(reader, writer, "4016-4017");
+  bus.map(reader, writer, "4020-5fff", 0, 0, 0x0020);
+  bus.map(reader, writer, "6000-7fff");
+
+  ramSide = forceSubRAM ? 1 : 0;
+  resetButtons();
+}
+
+auto VSSystem::setDip(bool side, uint8 dip) -> void {
+  if(side == 0) mainDip = dip;
+  if(side == 1) subDip = dip;
+}
+
+auto VSSystem::read(bool side, uint16 addr, uint8 data) -> uint8 {
+  if(addr == 0x4016) {
+    data = (!side) << 7; // 0x00 for slave CPU, 0x80 for master CPU
+    data |= data1(side);
+    uint& counter = side == 0 ? mainControlCounter1 : subControlCounter1;
+    counter++;
+    if(side == 0) data |= (mainDip & 0x03) << 3;
+    if(side == 1) data |= (subDip & 0x03) << 3;
+    data |= (
+      poll(side, ServiceButton) << 2 |
+      poll(side, Coin1) << 5 |
+      poll(side, Coin2) << 6
+    );
+    return data;
+  }
+
+  if(addr == 0x4017) {
+    if(side == 1) watchdog = 0;
+    data = 0x00;
+    data |= data2(side); // buttons 2 and 4
+    uint& counter = side == 0 ? mainControlCounter2 : subControlCounter2;
+    counter++;
+    if(side == 0) data |= mainDip & 0xfc;
+    if(side == 1) data |= subDip & 0xfc;
+    return data;
+  }
+
+  if(addr >= 0x4020 && addr <= 0x5fff) {
+    write(side, addr, data);
+    return data;
+  }
+
+  if(addr >= 0x6000 && addr <= 0x7fff) {
+    return side == ramSide ? ram[addr & 0x07ff] : data;
+  }
+}
+
+auto VSSystem::write(bool side, uint16 addr, uint8 data) -> void {
+  if(addr == 0x4016) {
+    peripherals.controllerPort1->latch(data.bit(0));
+    peripherals.controllerPort2->latch(data.bit(0));
+    peripherals.expansionPort->write(data.bit(0));
+    latch(side, data & 1);
+    if(side == 0 && !forceSubRAM) ramSide = !data.bit(1);
+  }
+
+  if(addr >= 0x4020 && addr <= 0x5fff) {
+    // increment coin counter
+  }
+
+  if(addr >= 0x6000 && addr <= 0x7fff) {
+    if(side == ramSide) ram[addr & 0x07ff] = data;
+  }
+}
+
+}
diff --git a/nSide/higan/fc/arcade/vssystem/vssystem.hpp b/nSide/higan/fc/arcade/vssystem/vssystem.hpp
new file mode 100644
index 0000000..6109bf3
--- /dev/null
+++ b/nSide/higan/fc/arcade/vssystem/vssystem.hpp
@@ -0,0 +1,57 @@
+struct VSSystem : Thread {
+  enum : uint {
+    Button1, Button2, Button3, Button4, ServiceButton, Coin1, Coin2,
+  };
+
+  struct GameCount { enum : uint {
+    Uni = 1,
+    Dual = 2,
+  };};
+
+  static auto Enter() -> void;
+  auto main() -> void;
+
+  auto init() -> void;
+  auto load() -> bool;
+  auto unload() -> void;
+  auto power() -> void;
+  auto reset() -> void;
+
+  auto setDip(bool side, uint8 dip) -> void;
+  auto read(bool side, uint16 addr, uint8 data) -> uint8;
+  auto write(bool side, uint16 addr, uint8 data) -> void;
+
+  auto serialize(serializer& s) -> void;
+
+  bool forceSubRAM;
+  uint gameCount;
+
+private:
+  uint8 ram[0x800];
+  bool ramSide; // 0: main, 1: sub
+
+  bool swapControllers;
+  uint8 mainDip;
+  uint8 subDip;
+  uint watchdog;
+
+  //control.cpp
+  bool mainControlLatched;
+  uint mainControlCounter1;
+  uint mainControlCounter2;
+  bool mainButtons[4];
+  bool subControlLatched;
+  uint subControlCounter1;
+  uint subControlCounter2;
+  bool subButtons[4];
+
+  auto resetButtons() -> void;
+  auto poll(bool side, uint input) -> int16;
+  auto data1(bool side) -> bool;
+  auto data2(bool side) -> bool;
+  auto latch(bool side, bool data) -> void;
+
+  friend class Cartridge;
+};
+
+extern VSSystem vssystem;
diff --git a/nSide/higan/fc/cartridge/board/bandai-74-161-02-74.cpp b/nSide/higan/fc/cartridge/board/bandai-74-161-02-74.cpp
new file mode 100644
index 0000000..e17dfd2
--- /dev/null
+++ b/nSide/higan/fc/cartridge/board/bandai-74-161-02-74.cpp
@@ -0,0 +1,74 @@
+  //BANDAI-74*161/02/74
+
+struct Bandai74_161_02_74 : Board {
+  Bandai74_161_02_74(Markup::Node& boardNode) : Board(boardNode) {
+  }
+
+  auto main() -> void {
+    chrAddressBusTest(ppu.io.chrAddressBus);
+    tick();
+  }
+
+  auto readPRG(uint addr) -> uint8 {
+    if(addr & 0x8000) return read(prgrom, (prgBank << 15) | (addr & 0x7fff));
+    return cpu.mdr();
+  }
+
+  auto writePRG(uint addr, uint8 data) -> void {
+    if(addr & 0x8000) {
+      data &= readPRG(addr);
+      prgBank = (data & 0x03) >> 0;
+      chrPlane = (data & 0x04) >> 2;
+    }
+  }
+
+  auto chrAddress(uint addr) -> uint {
+    switch(addr & 0x1000) {
+    case 0x0000: return (addr & 0x0fff) | (chrPlane << 14) | (chrBank << 12);
+    case 0x1000: return (addr & 0x0fff) | (chrPlane << 14);
+    }
+  }
+
+  auto readCHR(uint addr) -> uint8 {
+    chrAddressBusTest(addr);
+    if(addr & 0x2000) return ppu.readCIRAM(addr & 0x07ff);
+    return Board::readCHR(chrAddress(addr));
+  }
+
+  auto writeCHR(uint addr, uint8 data) -> void {
+    chrAddressBusTest(addr);
+    if(addr & 0x2000) return ppu.writeCIRAM(addr & 0x07ff, data);
+    Board::writeCHR(chrAddress(addr), data);
+  }
+
+  auto chrAddressBusTest(uint addr) -> void {
+    if((addr & 0x3000) != (chrAddressBus & 0x3000) && (addr & 0x3000) == 0x2000) {
+      // NOR logic reverses bank numbers
+      chrBank = (((addr & 0x0300) ^ 0x0300) >> 8);
+    }
+    chrAddressBus = addr & 0x3000;
+  }
+
+  auto power() -> void {
+  }
+
+  auto reset() -> void {
+    prgBank = 0;
+    chrPlane = 0;
+    chrBank = 0;
+    chrAddressBus = 0;
+  }
+
+  auto serialize(serializer& s) -> void {
+    Board::serialize(s);
+    s.integer(prgBank);
+    s.integer(chrPlane);
+    s.integer(chrBank);
+    s.integer(chrAddressBus);
+  }
+
+  uint2 prgBank;
+  bool chrPlane;
+  uint2 chrBank;
+  uint16 chrAddressBus;
+};
diff --git a/nSide/higan/fc/cartridge/board/bandai-74-161-161-32.cpp b/nSide/higan/fc/cartridge/board/bandai-74-161-161-32.cpp
new file mode 100644
index 0000000..2637051
--- /dev/null
+++ b/nSide/higan/fc/cartridge/board/bandai-74-161-161-32.cpp
@@ -0,0 +1,61 @@
+  //BANDAI-74*161/161/32
+
+struct Bandai74_161_161_32 : Board {
+  Bandai74_161_161_32(Markup::Node& boardNode) : Board(boardNode) {
+    settings.mirror = boardNode["mirror/mode"].text() == "horizontal";
+  }
+
+  auto readPRG(uint addr) -> uint8 {
+    if((addr & 0x8000) == 0x0000) return cpu.mdr();
+    if((addr & 0xc000) == 0x8000) return read(prgrom, (prgBank << 14) | (addr & 0x3fff));
+    else                          return read(prgrom, (   0x0f << 14) | (addr & 0x3fff));
+  }
+
+  auto writePRG(uint addr, uint8 data) -> void {
+    if(addr & 0x8000) {
+      //TODO: check for bus conflicts
+      data &= readPRG(addr);
+      prgBank = (data & 0xf0) >> 4;
+      chrBank = (data & 0x0f) >> 0;
+    }
+  }
+
+  auto readCHR(uint addr) -> uint8 {
+    if(addr & 0x2000) {
+      if(settings.mirror == 1) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+      return ppu.readCIRAM(addr);
+    }
+    addr = (chrBank * 0x2000) + (addr & 0x1fff);
+    return Board::readCHR(addr);
+  }
+
+  auto writeCHR(uint addr, uint8 data) -> void {
+    if(addr & 0x2000) {
+      if(settings.mirror == 1) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+      return ppu.writeCIRAM(addr, data);
+    }
+    addr = (chrBank * 0x2000) + (addr & 0x1fff);
+    Board::writeCHR(addr, data);
+  }
+
+  auto power() -> void {
+  }
+
+  auto reset() -> void {
+    prgBank = 0;
+    chrBank = 0;
+  }
+
+  auto serialize(serializer& s) -> void {
+    Board::serialize(s);
+    s.integer(prgBank);
+    s.integer(chrBank);
+  }
+
+  struct Settings {
+    bool mirror;  //0 = vertical, 1 = horizontal
+  } settings;
+
+  uint4 prgBank;
+  uint4 chrBank;
+};
diff --git a/higan/higan/fc/cartridge/board/bandai-fcg.cpp b/nSide/higan/fc/cartridge/board/bandai-fcg.cpp
index 3d77bd0..733e743 100644
--- a/higan/higan/fc/cartridge/board/bandai-fcg.cpp
+++ b/nSide/higan/fc/cartridge/board/bandai-fcg.cpp
@@ -1,109 +1,98 @@
 //BANDAI-FCG
+//BANDAI-FCG-1
+//BANDAI-FCG-2
+//BANDAI-JUMP2
+//BANDAI-LZ93D50
 
 struct BandaiFCG : Board {
-  BandaiFCG(Markup::Node& document) : Board(document) {
+  BandaiFCG(Markup::Node& boardNode) : Board(boardNode), fcg(*this, boardNode) {
+    string type = boardNode["id"].text();
+    revision = Revision::FCGAll;
+    if(type.match("*FCG-1*"  )) revision = Revision::FCG1;
+    if(type.match("*FCG-2*"  )) revision = Revision::FCG2;
+    if(type.match("*JUMP2*"  )) revision = Revision::JUMP2;
+    if(type.match("*LZ93D50*")) revision = Revision::LZ93D50;
   }
 
   auto main() -> void {
-    if(irqCounterEnable) {
-      if(--irqCounter == 0xffff) {
-        cpu.irqLine(1);
-        irqCounterEnable = false;
-      }
-    }
-
-    tick();
-  }
-
-  auto addrCIRAM(uint addr) const -> uint {
-    switch(mirror) {
-    case 0: return ((addr & 0x0400) >> 0) | (addr & 0x03ff);
-    case 1: return ((addr & 0x0800) >> 1) | (addr & 0x03ff);
-    case 2: return 0x0000 | (addr & 0x03ff);
-    case 3: return 0x0400 | (addr & 0x03ff);
-    }
+    fcg.main();
   }
 
   auto readPRG(uint addr) -> uint8 {
-    if(addr & 0x8000) {
-      bool region = addr & 0x4000;
-      uint bank = (region == 0 ? prgBank : (uint8)0x0f);
-      return prgrom.read((bank << 14) | (addr & 0x3fff));
+    if((addr & 0xe000) == 0x6000) {
+      switch(revision) {
+      case Revision::LZ93D50:
+        //TODO: serial EEPROM support
+        return 0x00 | (cpu.mdr() & 0xef);
+      case Revision::JUMP2:
+        return fcg.eepromI2C_SCL ? fcg.ramRead(addr) : cpu.mdr();
+      }
+    }
+    if((addr & 0x8000) == 0x8000) {
+      if(revision != Revision::JUMP2)
+        return read(prgrom, fcg.prgAddress(addr));
+      else
+        return read(prgrom, fcg.prgAddress(addr) | ((fcg.chrBank[(ppu.io.chrAddressBus >> 10) & 3] & 1) << 18));
     }
     return cpu.mdr();
   }
 
   auto writePRG(uint addr, uint8 data) -> void {
-    if(addr >= 0x6000) {
-      switch(addr & 15) {
-      case 0x00: case 0x01: case 0x02: case 0x03:
-      case 0x04: case 0x05: case 0x06: case 0x07:
-        chrBank[addr & 7] = data;
-        break;
-      case 0x08:
-        prgBank = data & 0x0f;
-        break;
-      case 0x09:
-        mirror = data & 0x03;
-        break;
-      case 0x0a:
-        cpu.irqLine(0);
-        irqCounterEnable = data & 0x01;
-        irqCounter = irqLatch;
-        break;
-      case 0x0b:
-        irqLatch = (irqLatch & 0xff00) | (data << 0);
-        break;
-      case 0x0c:
-        irqLatch = (irqLatch & 0x00ff) | (data << 8);
-        break;
-      case 0x0d:
-        //todo: serial EEPROM support
+    if((addr & 0xe000) == 0x6000) {
+      switch(revision) {
+      case Revision::FCGAll:
+      case Revision::FCG1:
+      case Revision::FCG2:
+        return fcg.regWrite(addr, data);
+      case Revision::LZ93D50:
+        //TODO: serial EEPROM support
         break;
+      case Revision::JUMP2:
+        if(fcg.eepromI2C_SCL) return fcg.ramWrite(addr, data);
+        else                   break;
+      }
+    }
+    if((addr & 0x8000) == 0x8000) {
+      switch(revision) {
+      case Revision::FCGAll:
+      case Revision::LZ93D50:
+      case Revision::JUMP2:
+        return fcg.regWrite(addr, data);
       }
     }
   }
 
   auto readCHR(uint addr) -> uint8 {
-    if(addr & 0x2000) return ppu.readCIRAM(addrCIRAM(addr));
-    addr = (chrBank[addr >> 10] << 10) | (addr & 0x03ff);
-    return Board::readCHR(addr);
+    if(addr & 0x2000) return ppu.readCIRAM(fcg.ciramAddress(addr));
+    if(chrrom.size()) return Board::readCHR(fcg.chrAddress(addr));
+    if(chrram.size()) return Board::readCHR(addr);
   }
 
   auto writeCHR(uint addr, uint8 data) -> void {
-    if(addr & 0x2000) return ppu.writeCIRAM(addrCIRAM(addr), data);
-    addr = (chrBank[addr >> 10] << 10) | (addr & 0x03ff);
-    return Board::writeCHR(addr, data);
+    if(addr & 0x2000) return ppu.writeCIRAM(fcg.ciramAddress(addr), data);
+    if(chrram.size()) Board::writeCHR(addr, data);
   }
 
   auto power() -> void {
-    reset();
+    fcg.power();
   }
 
   auto reset() -> void {
-    for(auto& n : chrBank) n = 0;
-    prgBank = 0;
-    mirror = 0;
-    irqCounterEnable = 0;
-    irqCounter = 0;
-    irqLatch = 0;
+    fcg.reset();
   }
 
   auto serialize(serializer& s) -> void {
     Board::serialize(s);
-
-    s.array(chrBank);
-    s.integer(prgBank);
-    s.integer(mirror);
-    s.integer(irqCounterEnable);
-    s.integer(irqCounter);
-    s.integer(irqLatch);
+    fcg.serialize(s);
   }
 
-  uint8 chrBank[8];
-  uint8 prgBank;
-  uint2 mirror;
-  bool irqCounterEnable;
-  uint16 irqCounter;
-  uint16 irqLatch;
+  enum class Revision : uint {
+    FCGAll,
+    FCG1,
+    FCG2,
+    JUMP2,
+    LZ93D50,
+  } revision;
+
+  FCG fcg;
 };
diff --git a/higan/higan/fc/cartridge/board/board.cpp b/nSide/higan/fc/cartridge/board/board.cpp
index 93d92c2..0d4f281 100644
--- a/higan/higan/fc/cartridge/board/board.cpp
+++ b/nSide/higan/fc/cartridge/board/board.cpp
@@ -1,131 +1,104 @@
+#include "bandai-74-161-02-74.cpp"
+#include "bandai-74-161-161-32.cpp"
 #include "bandai-fcg.cpp"
+#include "hvc-axrom.cpp"
+#include "hvc-cxrom.cpp"
+#include "hvc-exrom.cpp"
+#include "hvc-fxrom.cpp"
+#include "hvc-gxrom.cpp"
+#include "hvc-nrom.cpp"
+#include "hvc-pxrom.cpp"
+#include "hvc-sxrom.cpp"
+#include "hvc-txrom.cpp"
+#include "hvc-uxrom.cpp"
+#include "irem-74-161-161-21-138.cpp"
+#include "irem-g101.cpp"
+#include "irem-h3001.cpp"
+#include "irem-holydiver.cpp"
+#include "irem-i-im.cpp"
+#include "irem-tam-s1.cpp"
+#include "jaleco-jf-0x.cpp"
+#include "jaleco-jf-16.cpp"
+#include "jaleco-jf-2x.cpp"
 #include "konami-vrc1.cpp"
 #include "konami-vrc2.cpp"
 #include "konami-vrc3.cpp"
 #include "konami-vrc4.cpp"
 #include "konami-vrc6.cpp"
 #include "konami-vrc7.cpp"
-#include "nes-axrom.cpp"
-#include "nes-bnrom.cpp"
-#include "nes-cnrom.cpp"
-#include "nes-exrom.cpp"
-#include "nes-fxrom.cpp"
-#include "nes-gxrom.cpp"
+#include "namco-163.cpp"
+#include "namco-34xx.cpp"
+#include "nes-event.cpp"
 #include "nes-hkrom.cpp"
-#include "nes-nrom.cpp"
-#include "nes-pxrom.cpp"
-#include "nes-sxrom.cpp"
-#include "nes-txrom.cpp"
-#include "nes-uxrom.cpp"
+#include "nes-qj.cpp"
+#include "pal-zz.cpp"
+#include "sunsoft-4.cpp"
 #include "sunsoft-5b.cpp"
-
-Board::Board(Markup::Node& document) {
+#include "taito-tc.cpp"
+#include "fds.cpp"
+#include "vs.cpp"
+
+// Unlicensed board definitions; feel free to remove
+#include "unlicensed/camerica.cpp"
+#include "unlicensed/colordreams-74-377.cpp"
+#include "unlicensed/mlt-action52.cpp"
+#include "unlicensed/nina.cpp"
+// Homebrew board definitions; feel free to remove
+#include "unlicensed/noconflicts-cnrom.cpp"
+#include "unlicensed/single-chip.cpp"
+
+Board::Board(Markup::Node& boardNode) {
   cartridge.board = this;
-  auto board = document["board"];
-
-  information.type = board["id"].text();
-  information.battery = (bool)board["prg/ram/name"];
-
-  auto prom = board["prg/rom"];
-  auto pram = board["prg/ram"];
-  auto crom = board["chr/rom"];
-  auto cram = board["chr/ram"];
-
-  prgrom.size = prom["size"].natural();
-  prgram.size = pram["size"].natural();
-  chrrom.size = crom["size"].natural();
-  chrram.size = cram["size"].natural();
-
-  if(prgrom.size) prgrom.data = new uint8_t[prgrom.size]();
-  if(prgram.size) prgram.data = new uint8_t[prgram.size]();
-  if(chrrom.size) chrrom.data = new uint8_t[chrrom.size]();
-  if(chrram.size) chrram.data = new uint8_t[chrram.size]();
-
-  if(prgrom.name = prom["name"].text()) {
-    if(auto fp = interface->open(cartridge.pathID(), prgrom.name, File::Read, File::Required)) {
-      fp->read(prgrom.data, min(prgrom.size, fp->size()));
-    }
-  }
-  if(prgram.name = pram["name"].text()) {
-    if(auto fp = interface->open(cartridge.pathID(), prgram.name, File::Read)) {
-      fp->read(prgram.data, min(prgram.size, fp->size()));
-    }
-  }
-  if(chrrom.name = crom["name"].text()) {
-    if(auto fp = interface->open(cartridge.pathID(), chrrom.name, File::Read, File::Required)) {
-      fp->read(chrrom.data, min(chrrom.size, fp->size()));
-    }
-  }
-  if(chrram.name = cram["name"].text()) {
-    if(auto fp = interface->open(cartridge.pathID(), chrram.name, File::Read)) {
-      fp->read(chrram.data, min(chrram.size, fp->size()));
-    }
-  }
-
-  prgram.writable = true;
-  chrram.writable = true;
 }
 
-auto Board::save() -> void {
-  auto document = BML::unserialize(cartridge.manifest());
-
-  if(auto name = document["board/prg/ram/name"].text()) {
-    if(auto fp = interface->open(cartridge.pathID(), name, File::Write)) {
-      fp->write(prgram.data, prgram.size);
-    }
-  }
-
-  if(auto name = document["board/chr/ram/name"].text()) {
-    if(auto fp = interface->open(cartridge.pathID(), name, File::Write)) {
-      fp->write(chrram.data, chrram.size);
-    }
-  }
+Board::~Board() {
 }
 
-auto Board::Memory::read(uint addr) const -> uint8 {
-  return data[mirror(addr, size)];
+auto Board::read(MappedRAM& memory, uint addr) -> uint8 {
+  return memory.readDirect(mirror(addr, memory.size()));
 }
 
-auto Board::Memory::write(uint addr, uint8 byte) -> void {
-  if(writable) data[mirror(addr, size)] = byte;
+auto Board::write(MappedRAM& memory, uint addr, uint8 byte) -> void {
+  memory.writeDirect(mirror(addr, memory.size()), byte);
 }
 
 auto Board::mirror(uint addr, uint size) -> uint {
+  if(size == 0) return 0;
   uint base = 0;
-  if(size) {
-    uint mask = 1 << 23;
-    while(addr >= size) {
-      while(!(addr & mask)) mask >>= 1;
-      addr -= mask;
-      if(size > mask) {
-        size -= mask;
-        base += mask;
-      }
-      mask >>= 1;
+  uint mask = 1 << 23;
+  while(addr >= size) {
+    while(!(addr & mask)) mask >>= 1;
+    addr -= mask;
+    if(size > mask) {
+      size -= mask;
+      base += mask;
     }
-    base += addr;
+    mask >>= 1;
   }
-  return base;
+  return base + addr;
 }
 
 auto Board::main() -> void {
-  cartridge.step(12 * 4095);
   tick();
 }
 
 auto Board::tick() -> void {
-  cartridge.step(12);
+  switch(system.region()) {
+  case System::Region::NTSC:  cartridge.step(12); break;
+  case System::Region::PAL:   cartridge.step(16); break;
+  case System::Region::Dendy: cartridge.step(15); break;
+  }
   cartridge.synchronize(cpu);
 }
 
 auto Board::readCHR(uint addr) -> uint8 {
-  if(chrram.size) return chrram.data[mirror(addr, chrram.size)];
-  if(chrrom.size) return chrrom.data[mirror(addr, chrrom.size)];
-  return 0u;
+  if(chrram.size()) return read(chrram, addr);
+  if(chrrom.size()) return read(chrrom, addr);
+  return ppu.io.mdr;
 }
 
 auto Board::writeCHR(uint addr, uint8 data) -> void {
-  if(chrram.size) chrram.data[mirror(addr, chrram.size)] = data;
+  if(chrram.size()) write(chrram, addr, data);
 }
 
 auto Board::power() -> void {
@@ -135,98 +108,236 @@ auto Board::reset() -> void {
 }
 
 auto Board::serialize(serializer& s) -> void {
-  if(prgram.size) s.array(prgram.data, prgram.size);
-  if(chrram.size) s.array(chrram.data, chrram.size);
+  if(prgram.size()) s.array(prgram.data(), prgram.size());
+  if(chrram.size()) s.array(chrram.data(), chrram.size());
 }
 
-auto Board::load(string manifest) -> Board* {
-  auto document = BML::unserialize(manifest);
-  cartridge.information.title = document["information/title"].text();
-
-  string type = document["board/id"].text();
-
-  if(type == "BANDAI-FCG"  ) return new BandaiFCG(document);
-
-  if(type == "KONAMI-VRC-1") return new KonamiVRC1(document);
-  if(type == "KONAMI-VRC-2") return new KonamiVRC2(document);
-  if(type == "KONAMI-VRC-3") return new KonamiVRC3(document);
-  if(type == "KONAMI-VRC-4") return new KonamiVRC4(document);
-  if(type == "KONAMI-VRC-6") return new KonamiVRC6(document);
-  if(type == "KONAMI-VRC-7") return new KonamiVRC7(document);
-
-  if(type == "NES-AMROM"   ) return new NES_AxROM(document);
-  if(type == "NES-ANROM"   ) return new NES_AxROM(document);
-  if(type == "NES-AN1ROM"  ) return new NES_AxROM(document);
-  if(type == "NES-AOROM"   ) return new NES_AxROM(document);
-
-  if(type == "NES-BNROM"   ) return new NES_BNROM(document);
-
-  if(type == "NES-CNROM"   ) return new NES_CNROM(document);
-
-  if(type == "NES-EKROM"   ) return new NES_ExROM(document);
-  if(type == "NES-ELROM"   ) return new NES_ExROM(document);
-  if(type == "NES-ETROM"   ) return new NES_ExROM(document);
-  if(type == "NES-EWROM"   ) return new NES_ExROM(document);
-
-  if(type == "NES-FJROM"   ) return new NES_FxROM(document);
-  if(type == "NES-FKROM"   ) return new NES_FxROM(document);
-
-  if(type == "NES-GNROM"   ) return new NES_GxROM(document);
-  if(type == "NES-MHROM"   ) return new NES_GxROM(document);
-
-  if(type == "NES-HKROM"   ) return new NES_HKROM(document);
-
-  if(type == "NES-NROM"    ) return new NES_NROM(document);
-  if(type == "NES-NROM-128") return new NES_NROM(document);
-  if(type == "NES-NROM-256") return new NES_NROM(document);
-
-  if(type == "NES-PEEOROM" ) return new NES_PxROM(document);
-  if(type == "NES-PNROM"   ) return new NES_PxROM(document);
-
-  if(type == "NES-SAROM"   ) return new NES_SxROM(document);
-  if(type == "NES-SBROM"   ) return new NES_SxROM(document);
-  if(type == "NES-SCROM"   ) return new NES_SxROM(document);
-  if(type == "NES-SC1ROM"  ) return new NES_SxROM(document);
-  if(type == "NES-SEROM"   ) return new NES_SxROM(document);
-  if(type == "NES-SFROM"   ) return new NES_SxROM(document);
-  if(type == "NES-SFEXPROM") return new NES_SxROM(document);
-  if(type == "NES-SGROM"   ) return new NES_SxROM(document);
-  if(type == "NES-SHROM"   ) return new NES_SxROM(document);
-  if(type == "NES-SH1ROM"  ) return new NES_SxROM(document);
-  if(type == "NES-SIROM"   ) return new NES_SxROM(document);
-  if(type == "NES-SJROM"   ) return new NES_SxROM(document);
-  if(type == "NES-SKROM"   ) return new NES_SxROM(document);
-  if(type == "NES-SLROM"   ) return new NES_SxROM(document);
-  if(type == "NES-SL1ROM"  ) return new NES_SxROM(document);
-  if(type == "NES-SL2ROM"  ) return new NES_SxROM(document);
-  if(type == "NES-SL3ROM"  ) return new NES_SxROM(document);
-  if(type == "NES-SLRROM"  ) return new NES_SxROM(document);
-  if(type == "NES-SMROM"   ) return new NES_SxROM(document);
-  if(type == "NES-SNROM"   ) return new NES_SxROM(document);
-  if(type == "NES-SOROM"   ) return new NES_SxROM(document);
-  if(type == "NES-SUROM"   ) return new NES_SxROM(document);
-  if(type == "NES-SXROM"   ) return new NES_SxROM(document);
-
-  if(type == "NES-TBROM"   ) return new NES_TxROM(document);
-  if(type == "NES-TEROM"   ) return new NES_TxROM(document);
-  if(type == "NES-TFROM"   ) return new NES_TxROM(document);
-  if(type == "NES-TGROM"   ) return new NES_TxROM(document);
-  if(type == "NES-TKROM"   ) return new NES_TxROM(document);
-  if(type == "NES-TKSROM"  ) return new NES_TxROM(document);
-  if(type == "NES-TLROM"   ) return new NES_TxROM(document);
-  if(type == "NES-TL1ROM"  ) return new NES_TxROM(document);
-  if(type == "NES-TL2ROM"  ) return new NES_TxROM(document);
-  if(type == "NES-TLSROM"  ) return new NES_TxROM(document);
-  if(type == "NES-TNROM"   ) return new NES_TxROM(document);
-  if(type == "NES-TQROM"   ) return new NES_TxROM(document);
-  if(type == "NES-TR1ROM"  ) return new NES_TxROM(document);
-  if(type == "NES-TSROM"   ) return new NES_TxROM(document);
-  if(type == "NES-TVROM"   ) return new NES_TxROM(document);
-
-  if(type == "NES-UNROM"   ) return new NES_UxROM(document);
-  if(type == "NES-UOROM"   ) return new NES_UxROM(document);
-
-  if(type == "SUNSOFT-5B"  ) return new Sunsoft5B(document);
+Board* Board::load(Markup::Node boardNode) {
+  if(system.vs()) return new VS(boardNode);
+
+  string type = boardNode["id"].text();
+
+  if(slice(type,0,4) == "HVC-"
+  || slice(type,0,4) == "NES-"
+  || slice(type,0,4) == "PAL-") {
+    type = slice(type,4);
+    if(type == "AMROM"   ) return new HVC_AxROM(boardNode);
+    if(type == "ANROM"   ) return new HVC_AxROM(boardNode);
+    if(type == "AN1ROM"  ) return new HVC_AxROM(boardNode);
+    if(type == "AOROM"   ) return new HVC_AxROM(boardNode);
+
+    if(type == "BNROM"   ) return new IremIIM(boardNode);
+
+    if(type == "BTR"     ) return new Sunsoft5B(boardNode);
+
+    if(type == "CNROM"   ) return new HVC_CxROM(boardNode);
+    if(type == "CPROM"   ) return new HVC_CxROM(boardNode);
+
+    if(type == "DEROM"   ) return new Namco34xx(boardNode);
+    if(type == "DE1ROM"  ) return new Namco34xx(boardNode);
+    if(type == "DRROM"   ) return new Namco34xx(boardNode);
+
+    if(type == "EVENT"   ) return new NES_Event(boardNode);
+
+    if(type == "EKROM"   ) return new HVC_ExROM(boardNode);
+    if(type == "ELROM"   ) return new HVC_ExROM(boardNode);
+    if(type == "ETROM"   ) return new HVC_ExROM(boardNode);
+    if(type == "EWROM"   ) return new HVC_ExROM(boardNode);
+
+    if(type == "FJROM"   ) return new HVC_FxROM(boardNode);
+    if(type == "FKROM"   ) return new HVC_FxROM(boardNode);
+
+    if(type == "GNROM"   ) return new HVC_GxROM(boardNode);
+    if(type == "MHROM"   ) return new HVC_GxROM(boardNode);
+
+    if(type == "HKROM"   ) return new NES_HKROM(boardNode);
+
+    if(type == "JLROM"   ) return new Sunsoft5B(boardNode);
+    if(type == "JSROM"   ) return new Sunsoft5B(boardNode);
+
+    if(type == "FAMILYBASIC") return new HVC_NROM(boardNode);
+    if(type == "HROM"       ) return new HVC_NROM(boardNode);
+    if(type == "NROM"       ) return new HVC_NROM(boardNode);
+    if(type == "NROM-128"   ) return new HVC_NROM(boardNode);
+    if(type == "NROM-256"   ) return new HVC_NROM(boardNode);
+    if(type == "RROM"       ) return new HVC_NROM(boardNode);
+    if(type == "RROM-128"   ) return new HVC_NROM(boardNode);
+    if(type == "RTROM"      ) return new HVC_NROM(boardNode);
+    if(type == "SROM"       ) return new HVC_NROM(boardNode);
+    if(type == "STROM"      ) return new HVC_NROM(boardNode);
+
+    if(type == "PEEOROM" ) return new HVC_PxROM(boardNode);
+    if(type == "PNROM"   ) return new HVC_PxROM(boardNode);
+
+    if(type == "QJ"      ) return new NES_QJ(boardNode);
+
+    if(type == "SAROM"   ) return new HVC_SxROM(boardNode);
+    if(type == "SBROM"   ) return new HVC_SxROM(boardNode);
+    if(type == "SCROM"   ) return new HVC_SxROM(boardNode);
+    if(type == "SC1ROM"  ) return new HVC_SxROM(boardNode);
+    if(type == "SEROM"   ) return new HVC_SxROM(boardNode);
+    if(type == "SFROM"   ) return new HVC_SxROM(boardNode);
+    if(type == "SF1ROM"  ) return new HVC_SxROM(boardNode);
+    if(type == "SFEXPROM") return new HVC_SxROM(boardNode);
+    if(type == "SGROM"   ) return new HVC_SxROM(boardNode);
+    if(type == "SHROM"   ) return new HVC_SxROM(boardNode);
+    if(type == "SH1ROM"  ) return new HVC_SxROM(boardNode);
+    if(type == "SIROM"   ) return new HVC_SxROM(boardNode);
+    if(type == "SJROM"   ) return new HVC_SxROM(boardNode);
+    if(type == "SKROM"   ) return new HVC_SxROM(boardNode);
+    if(type == "SLROM"   ) return new HVC_SxROM(boardNode);
+    if(type == "SL1ROM"  ) return new HVC_SxROM(boardNode);
+    if(type == "SL2ROM"  ) return new HVC_SxROM(boardNode);
+    if(type == "SL3ROM"  ) return new HVC_SxROM(boardNode);
+    if(type == "SLRROM"  ) return new HVC_SxROM(boardNode);
+    if(type == "SMROM"   ) return new HVC_SxROM(boardNode);
+    if(type == "SNROM"   ) return new HVC_SxROM(boardNode);
+    if(type == "SNWEPROM") return new HVC_SxROM(boardNode);
+    if(type == "SOROM"   ) return new HVC_SxROM(boardNode);
+    if(type == "SUROM"   ) return new HVC_SxROM(boardNode);
+    if(type == "SXROM"   ) return new HVC_SxROM(boardNode);
+
+    if(type == "TBROM"   ) return new HVC_TxROM(boardNode);
+    if(type == "TEROM"   ) return new HVC_TxROM(boardNode);
+    if(type == "TFROM"   ) return new HVC_TxROM(boardNode);
+    if(type == "TGROM"   ) return new HVC_TxROM(boardNode);
+    if(type == "TKROM"   ) return new HVC_TxROM(boardNode);
+    if(type == "TKEPROM" ) return new HVC_TxROM(boardNode);
+    if(type == "TKSROM"  ) return new HVC_TxROM(boardNode);
+    if(type == "TLROM"   ) return new HVC_TxROM(boardNode);
+    if(type == "TL1ROM"  ) return new HVC_TxROM(boardNode);
+    if(type == "TL2ROM"  ) return new HVC_TxROM(boardNode);
+    if(type == "TLSROM"  ) return new HVC_TxROM(boardNode);
+    if(type == "TNROM"   ) return new HVC_TxROM(boardNode);
+    if(type == "TQROM"   ) return new HVC_TxROM(boardNode);
+    if(type == "TR1ROM"  ) return new HVC_TxROM(boardNode);
+    if(type == "TSROM"   ) return new HVC_TxROM(boardNode);
+    if(type == "TVROM"   ) return new HVC_TxROM(boardNode);
+
+    if(type == "UNROM"   ) return new HVC_UxROM(boardNode);
+    if(type == "UN1ROM"  ) return new HVC_UxROM(boardNode);
+    if(type == "UOROM"   ) return new HVC_UxROM(boardNode);
+
+    if(type == "ZZ"      ) return new PAL_ZZ(boardNode);
+  }
+
+  if(type == "ACCLAIM-MC-ACC") return new HVC_TxROM(boardNode);
+
+  if(type == "BANDAI-74*161/02/74" ) return new Bandai74_161_02_74(boardNode);
+  if(type == "BANDAI-74*161/32"    ) return new HVC_CxROM(boardNode);
+  if(type == "BANDAI-74*161/161/32") return new Bandai74_161_161_32(boardNode);
+  if(type == "BANDAI-CNROM"        ) return new HVC_CxROM(boardNode);
+  if(type == "BANDAI-FCG"          ) return new BandaiFCG(boardNode);
+  if(type == "BANDAI-FCG-1"        ) return new BandaiFCG(boardNode);
+  if(type == "BANDAI-FCG-2"        ) return new BandaiFCG(boardNode);
+  if(type == "BANDAI-GNROM"        ) return new HVC_GxROM(boardNode);
+  if(type == "BANDAI-JUMP2"        ) return new BandaiFCG(boardNode);
+  if(type == "BANDAI-LZ93D50"      ) return new BandaiFCG(boardNode);
+  if(type == "BANDAI-NROM-128"     ) return new HVC_NROM(boardNode);
+  if(type == "BANDAI-NROM-256"     ) return new HVC_NROM(boardNode);
+  if(type == "BANDAI-PT-554"       ) return new HVC_CxROM(boardNode);
+
+  if(type == "IREM-74*161/161/21/138") return new Irem74_161_161_21_138(boardNode);
+  if(type == "IREM-BNROM"            ) return new IremIIM(boardNode);
+  if(type == "IREM-FCG-1"            ) return new BandaiFCG(boardNode);
+  if(type == "IREM-G101"             ) return new IremG101(boardNode);
+  if(type == "IREM-H3001"            ) return new IremH3001(boardNode);
+  if(type == "IREM-HOLYDIVER"        ) return new IremHolyDiver(boardNode);
+  if(type == "IREM-NROM-128"         ) return new HVC_NROM(boardNode);
+  if(type == "IREM-NROM-256"         ) return new HVC_NROM(boardNode);
+  if(type == "IREM-TAM-S1"           ) return new IremTamS1(boardNode);
+  if(type == "IREM-UNROM"            ) return new HVC_UxROM(boardNode);
+
+  if(type == "JALECO-JF-05") return new JalecoJF0x(boardNode);
+  if(type == "JALECO-JF-06") return new JalecoJF0x(boardNode);
+  if(type == "JALECO-JF-07") return new JalecoJF0x(boardNode);
+  if(type == "JALECO-JF-08") return new JalecoJF0x(boardNode);
+  if(type == "JALECO-JF-09") return new JalecoJF0x(boardNode);
+  if(type == "JALECO-JF-10") return new JalecoJF0x(boardNode);
+  if(type == "JALECO-JF-11") return new JalecoJF0x(boardNode);
+  if(type == "JALECO-JF-14") return new JalecoJF0x(boardNode);
+  if(type == "JALECO-JF-16") return new JalecoJF16(boardNode);
+  if(type == "JALECO-JF-22") return new KonamiVRC1(boardNode);
+  if(type == "JALECO-JF-23") return new JalecoJF2x(boardNode);
+  if(type == "JALECO-JF-24") return new JalecoJF2x(boardNode);
+  if(type == "JALECO-JF-25") return new JalecoJF2x(boardNode);
+  if(type == "JALECO-JF-27") return new JalecoJF2x(boardNode);
+  if(type == "JALECO-JF-29") return new JalecoJF2x(boardNode);
+  if(type == "JALECO-JF-37") return new JalecoJF2x(boardNode);
+  if(type == "JALECO-JF-40") return new JalecoJF2x(boardNode);
+
+  if(type == "KONAMI-74*139/74") return new JalecoJF0x(boardNode);
+  if(type == "KONAMI-CNROM"    ) return new HVC_CxROM(boardNode);
+  if(type == "KONAMI-NROM-128" ) return new HVC_NROM(boardNode);
+  if(type == "KONAMI-SLROM"    ) return new HVC_SxROM(boardNode);
+  if(type == "KONAMI-TLROM"    ) return new HVC_TxROM(boardNode);
+  if(type == "KONAMI-UNROM"    ) return new HVC_UxROM(boardNode);
+  if(type == "KONAMI-VRC-1"    ) return new KonamiVRC1(boardNode);
+  if(type == "KONAMI-VRC-2"    ) return new KonamiVRC2(boardNode);
+  if(type == "KONAMI-VRC-3"    ) return new KonamiVRC3(boardNode);
+  if(type == "KONAMI-VRC-4"    ) return new KonamiVRC4(boardNode);
+  if(type == "KONAMI-VRC-6"    ) return new KonamiVRC6(boardNode);
+  if(type == "KONAMI-VRC-7"    ) return new KonamiVRC7(boardNode);
+
+  if(type == "NAMCOT-129" ) return new Namco163(boardNode);
+  if(type == "NAMCOT-163" ) return new Namco163(boardNode);
+  if(type == "NAMCOT-175" ) return new Namco163(boardNode);
+  if(type == "NAMCOT-340" ) return new Namco163(boardNode);
+  if(type == "NAMCOT-3301") return new HVC_NROM(boardNode);
+  if(type == "NAMCOT-3302") return new HVC_NROM(boardNode);
+  if(type == "NAMCOT-3303") return new HVC_NROM(boardNode);
+  if(type == "NAMCOT-3304") return new HVC_NROM(boardNode);
+  if(type == "NAMCOT-3305") return new HVC_NROM(boardNode);
+  if(type == "NAMCOT-3311") return new HVC_NROM(boardNode);
+  if(type == "NAMCOT-3312") return new HVC_NROM(boardNode);
+  if(type == "NAMCOT-3401") return new Namco34xx(boardNode);
+  if(type == "NAMCOT-3406") return new Namco34xx(boardNode);
+  if(type == "NAMCOT-3407") return new Namco34xx(boardNode);
+  if(type == "NAMCOT-3413") return new Namco34xx(boardNode);
+  if(type == "NAMCOT-3414") return new Namco34xx(boardNode);
+  if(type == "NAMCOT-3415") return new Namco34xx(boardNode);
+  if(type == "NAMCOT-3416") return new Namco34xx(boardNode);
+  if(type == "NAMCOT-3417") return new Namco34xx(boardNode);
+  if(type == "NAMCOT-3425") return new Namco34xx(boardNode);
+  if(type == "NAMCOT-3443") return new Namco34xx(boardNode);
+  if(type == "NAMCOT-3446") return new Namco34xx(boardNode);
+  if(type == "NAMCOT-3451") return new Namco34xx(boardNode);
+  if(type == "NAMCOT-3453") return new Namco34xx(boardNode);
+
+  if(type == "SUNSOFT-4" ) return new Sunsoft4(boardNode);
+  if(type == "SUNSOFT-5B") return new Sunsoft5B(boardNode);
+
+  if(type == "TAITO-CNROM"    ) return new HVC_CxROM(boardNode);
+  if(type == "TAITO-TC0190FMC") return new TaitoTC(boardNode);
+  if(type == "TAITO-TC0350FMR") return new TaitoTC(boardNode);
+  if(type == "TAITO-TC0690FMR") return new TaitoTC(boardNode);
+
+  if(type == "FDS") return new FDS(boardNode);
+
+  // Unlicensed boards below; feel free to remove
+  if(type == "AVE-NINA-01"       ) return new Nina(boardNode);
+  if(type == "AVE-NINA-02"       ) return new Nina(boardNode);
+  if(type == "AVE-NINA-03"       ) return new Nina(boardNode);
+  if(type == "AVE-NINA-06"       ) return new Nina(boardNode);
+  if(type == "CAMERICA-ALGN"     ) return new Camerica(boardNode);
+  if(type == "CAMERICA-ALGQ"     ) return new Camerica(boardNode);
+  if(type == "CAMERICA-BF9093"   ) return new Camerica(boardNode);
+  if(type == "CAMERICA-BF9096"   ) return new Camerica(boardNode);
+  if(type == "CAMERICA-BF9097"   ) return new Camerica(boardNode);
+  if(type == "CODEMASTERS-NR8N"  ) return new Camerica(boardNode);
+  if(type == "COLORDREAMS-74*377") return new ColorDreams74_377(boardNode);
+  if(type == "MLT-ACTION52"      ) return new MLT_Action52(boardNode);
+  if(type == "TENGEN-800002"     ) return new Namco34xx(boardNode);
+  if(type == "TENGEN-800003"     ) return new HVC_NROM(boardNode);
+  if(type == "TENGEN-800004"     ) return new Namco34xx(boardNode);
+  if(type == "TENGEN-800008"     ) return new HVC_CxROM(boardNode);
+  if(type == "TENGEN-800030"     ) return new Namco34xx(boardNode);
+  if(type == "TENGEN-800042"     ) return new Sunsoft4(boardNode);
+  // Homebrew boards; feel free to remove
+  if(type == "NoConflicts-CNROM") return new NoConflicts_CNROM(boardNode);
+  if(type == "SingleChip") return new SingleChip(boardNode);
+
+  interface->notify(string{"Unrecognized board ID: ", type});
 
   return nullptr;
 }
diff --git a/higan/higan/fc/cartridge/board/board.hpp b/nSide/higan/fc/cartridge/board/board.hpp
index e4440ec..13fca16 100644
--- a/higan/higan/fc/cartridge/board/board.hpp
+++ b/nSide/higan/fc/cartridge/board/board.hpp
@@ -1,30 +1,16 @@
 struct Board {
-  struct Memory {
-    inline Memory(uint8_t* data, uint size) : data(data), size(size) {}
-    inline Memory() : data(nullptr), size(0u), writable(false) {}
-    inline ~Memory() { if(data) delete[] data; }
-
-    inline auto read(uint addr) const -> uint8;
-    inline auto write(uint addr, uint8 data) -> void;
-
-    string name;
-    uint8_t* data = nullptr;
-    uint size = 0;
-    bool writable = false;
-  };
-
-  virtual ~Board() = default;
+  Board(Markup::Node& boardNode);
+  virtual ~Board();
 
+  static auto read(MappedRAM& memory, uint addr) -> uint8;
+  static auto write(MappedRAM& memory, uint addr, uint8 byte) -> void;
   static auto mirror(uint addr, uint size) -> uint;
 
-  Board(Markup::Node& document);
-  auto save() -> void;
-
   virtual auto main() -> void;
   virtual auto tick() -> void;
 
-  virtual auto readPRG(uint addr) -> uint8 = 0;
-  virtual auto writePRG(uint addr, uint8 data) -> void = 0;
+  virtual uint8 readPRG(uint addr) = 0;
+  virtual void writePRG(uint addr, uint8 data) = 0;
 
   virtual auto readCHR(uint addr) -> uint8;
   virtual auto writeCHR(uint addr, uint8 data) -> void;
@@ -36,15 +22,14 @@ struct Board {
 
   virtual auto serialize(serializer&) -> void;
 
-  static auto load(string manifest) -> Board*;
+  static Board* load(Markup::Node boardNode);
 
-  struct Information {
-    string type;
-    bool battery;
-  } information;
+  Chip* chip = nullptr;
 
-  Memory prgrom;
-  Memory prgram;
-  Memory chrrom;
-  Memory chrram;
+  MappedRAM prgrom;
+  MappedRAM prgram;
+  MappedRAM chrrom;
+  MappedRAM chrram;
+  MappedRAM instrom;
+  MappedRAM keyrom;
 };
diff --git a/nSide/higan/fc/cartridge/board/fds.cpp b/nSide/higan/fc/cartridge/board/fds.cpp
new file mode 100644
index 0000000..45a2bd4
--- /dev/null
+++ b/nSide/higan/fc/cartridge/board/fds.cpp
@@ -0,0 +1,230 @@
+struct FDS : Board {
+  FDS(Markup::Node& boardNode) : Board(boardNode) {
+  }
+
+  auto main() -> void {
+    if(irqEnable && irqCounter > 0 && --irqCounter == 0) {
+      cpu.irqLine(1);
+      if(irqRepeat) irqCounter = irqLatch;
+      else           irqEnable = false;
+      irqLatch = 0; // for Kaettekita Mario Bros.?
+    } else {
+      //TODO: Drive timer emulation
+    }
+    tick();
+  }
+
+  auto readPRG(uint addr) -> uint8 {
+    switch(addr) {
+    case 0x4030: {
+      uint8 data = (irqPending | (byteTransferred << 1));
+      irqPending = false;
+      byteTransferred = false;
+      // 0x10: CRC 0=pass; 1=fail
+      // 0x40: End of disk head
+      // 0x80: Disk read/write enable
+      cpu.irqLine(0);
+      return 0;
+    }
+
+    case 0x4031: {
+      return dataRegister;
+    }
+
+    case 0x4032: {
+      return (
+        (diskSlotEmpty      << 0) |
+        (diskNotReady       << 1) |
+        (diskWriteProtected << 2)
+      );
+    }
+
+    case 0x4033: {
+      // 7-bit expansion input; 0x80 means low battery
+      return 0x00;
+    }
+
+    case 0x4090: {
+      return cpu.mdr() & 0xc0;
+    }
+
+    case 0x4092: {
+      return cpu.mdr() & 0xc0;
+    }
+
+    }
+
+    if((addr & 0xffc0) == 0x4040) {
+      return wavetable[addr & 0x3f] | (cpu.mdr() & 0xc0);
+    }
+    switch(addr & 0xe000) {
+    case 0x6000:
+    case 0x8000:
+    case 0xa000:
+    case 0xc000: return read(prgram, addr);
+    case 0xe000: return read(prgrom, addr);
+    }
+    return cpu.mdr();
+  }
+
+  auto writePRG(uint addr, uint8 data) -> void {
+    switch(addr) {
+    case 0x4020: irqLatch = (irqLatch & 0xff00) | (data << 0); break;
+    case 0x4021: irqLatch = (irqLatch & 0x00ff) | (data << 8); break;
+    case 0x4022: {
+      irqRepeat = data & 0x01;
+      irqEnable = data & 0x02;
+      irqCounter = irqLatch;
+      byteTransferred = false;
+      cpu.irqLine(0); // if pending IRQ flag is clear
+      break;
+    }
+
+    case 0x4023: {
+      diskIOEnable = data & 0x01;
+      soundIOEnable = data & 0x02;
+      break;
+    }
+
+    case 0x4024: {
+      // clear pending IRQ flag
+      if(!byteTransferred) cpu.irqLine(0);
+      break;
+    }
+
+    case 0x4025: {
+      fdsControl = data & 0xf7;
+      mirror = data & 0x08;
+      break;
+    }
+
+    case 0x4026: {
+      // 7-bit expansion output
+      break;
+    }
+
+    case 0x4080: break;
+    case 0x4082: break;
+    case 0x4083: break;
+    case 0x4084: break;
+    case 0x4085: break;
+    case 0x4086: break;
+    case 0x4087: break;
+    case 0x4088: break;
+    case 0x4089: {
+      wavetableWriteEnable = data & 0x80;
+      break;
+    }
+
+    case 0x408a: break;
+
+    }
+
+    if((addr & 0xffc0) == 0x4040) {
+      if(wavetableWriteEnable) wavetable[addr & 0x3f] = data & 0x3f;
+    }
+
+    switch(addr & 0xe000) {
+    case 0x6000:
+    case 0x8000:
+    case 0xa000:
+    case 0xc000: write(prgram, addr, data); break;
+    }
+  }
+
+  auto readCHR(uint addr) -> uint8 {
+    if(addr & 0x2000) {
+      if(mirror) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+      return ppu.readCIRAM(addr);
+    }
+    return Board::readCHR(addr);
+  }
+
+  auto writeCHR(uint addr, uint8 data) -> void {
+    if(addr & 0x2000) {
+      if(mirror) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+      return ppu.writeCIRAM(addr, data);
+    }
+    return Board::writeCHR(addr, data);
+  }
+
+  auto power() -> void {
+    reset();
+  }
+
+  auto reset() -> void {
+    irqCounter = 0;
+    irqLatch = 0;
+    irqRepeat = false;
+    irqEnable = false;
+
+    diskIOEnable = false;
+    soundIOEnable = false;
+
+    fdsControl = 0x26;
+    mirror = false;
+
+    irqPending = false;
+    byteTransferred = false;
+
+    dataRegister = 0x00;
+
+    diskSlotEmpty = true;
+    diskNotReady = true;
+    diskWriteProtected = true;
+
+    for(auto& n : wavetable) n = 0x00;
+    wavetableWriteEnable = false;
+  }
+
+  auto serialize(serializer& s) -> void {
+    Board::serialize(s);
+
+    s.integer(irqCounter);
+    s.integer(irqLatch);
+    s.integer(irqRepeat);
+    s.integer(irqEnable);
+
+    s.integer(diskIOEnable);
+    s.integer(soundIOEnable);
+
+    s.integer(fdsControl);
+    s.integer(mirror);
+
+    s.integer(irqPending);
+    s.integer(byteTransferred);
+
+    s.integer(dataRegister);
+
+    s.integer(diskSlotEmpty);
+    s.integer(diskNotReady);
+    s.integer(diskWriteProtected);
+
+    s.array(wavetable);
+    s.integer(wavetableWriteEnable);
+  }
+
+  uint16 irqCounter;
+  uint16 irqLatch;
+  bool irqRepeat;
+  bool irqEnable;
+
+  bool diskIOEnable;
+  bool soundIOEnable;
+
+  uint8 fdsControl;
+  bool mirror;
+
+  bool irqPending;
+  bool byteTransferred;
+
+  uint8 dataRegister;
+
+  bool diskSlotEmpty;
+  bool diskNotReady;
+  bool diskWriteProtected;
+
+  uint6 wavetable[0x40];
+  bool wavetableWriteEnable;
+
+};
diff --git a/higan/higan/fc/cartridge/board/nes-axrom.cpp b/nSide/higan/fc/cartridge/board/hvc-axrom.cpp
similarity index 57%
rename from higan/higan/fc/cartridge/board/nes-axrom.cpp
rename to nSide/higan/fc/cartridge/board/hvc-axrom.cpp
index b773a0c..ecd088c 100644
--- a/higan/higan/fc/cartridge/board/nes-axrom.cpp
+++ b/nSide/higan/fc/cartridge/board/hvc-axrom.cpp
@@ -1,19 +1,26 @@
-//NES-AMROM
+//HVC-AMROM
 //NES-ANROM
 //NES-AN1ROM
-//NES-AOROM
+//HVC-AOROM
 
-struct NES_AxROM : Board {
-  NES_AxROM(Markup::Node& document) : Board(document) {
+struct HVC_AxROM : Board {
+  HVC_AxROM(Markup::Node& boardNode) : Board(boardNode) {
+    string type = boardNode["id"].text();
+    if(type.match("*AMROM" )) revision = Revision::AMROM;
+    if(type.match("*ANROM" )) revision = Revision::ANROM;
+    if(type.match("*AN1ROM")) revision = Revision::AN1ROM;
+    if(type.match("*AOROM" )) revision = Revision::AOROM;
   }
 
   auto readPRG(uint addr) -> uint8 {
-    if(addr & 0x8000) return prgrom.read((prgBank << 15) | (addr & 0x7fff));
+    if(addr & 0x8000) return read(prgrom, (prgBank << 15) | (addr & 0x7fff));
     return cpu.mdr();
   }
 
   auto writePRG(uint addr, uint8 data) -> void {
     if(addr & 0x8000) {
+      // Bus conflicts
+      if(revision == Revision::AMROM) data &= readPRG(addr);
       prgBank = data & 0x0f;
       mirrorSelect = data & 0x10;
     }
@@ -44,6 +51,13 @@ struct NES_AxROM : Board {
     s.integer(mirrorSelect);
   }
 
+  enum class Revision : uint {
+    AMROM,
+    ANROM,
+    AN1ROM,
+    AOROM,
+  } revision;
+
   uint4 prgBank;
   bool mirrorSelect;
 };
diff --git a/nSide/higan/fc/cartridge/board/hvc-cxrom.cpp b/nSide/higan/fc/cartridge/board/hvc-cxrom.cpp
new file mode 100644
index 0000000..c2401cb
--- /dev/null
+++ b/nSide/higan/fc/cartridge/board/hvc-cxrom.cpp
@@ -0,0 +1,102 @@
+//HVC-CNROM
+//NES-CPROM
+
+struct HVC_CxROM : Board {
+  HVC_CxROM(Markup::Node& boardNode) : Board(boardNode) {
+    string type = boardNode["id"].text();
+    if(type.match("*CNROM" )) revision = Revision::CNROM;
+    if(type.match("*CPROM" )) revision = Revision::CPROM;
+    if(type.match("*PT-554")) revision = Revision::CNROM;
+    if(type == "TENGEN-800008") revision = Revision::CNROM;
+
+    settings.mirror = boardNode["mirror/mode"].text() == "horizontal";
+    settings.security = (bool)boardNode["security"];
+    if(settings.security) {
+      settings.pass = boardNode["security/pass"].natural();
+    }
+  }
+
+  auto readPRG(uint addr) -> uint8 {
+    if(addr & 0x8000) return read(prgrom, addr & 0x7fff);
+    return cpu.mdr();
+  }
+
+  auto writePRG(uint addr, uint8 data) -> void {
+    if(addr & 0x8000) {
+      data &= readPRG(addr); // Bus conflicts
+      chrBank = data & 0x03;
+    }
+  }
+
+  auto readCHR(uint addr) -> uint8 {
+    if(addr & 0x2000) {
+      if(settings.mirror == 1) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+      return ppu.readCIRAM(addr);
+    }
+    if(settings.security) {
+      if(chrBank != settings.pass) return ppu.io.mdr;
+    }
+    switch(revision) {
+    case Revision::CNROM: {
+      addr = (chrBank * 0x2000) + (addr & 0x1fff);
+      break;
+    }
+
+    case Revision::CPROM: {
+      if(addr < 0x1000) addr = addr & 0x1fff;
+      else              addr = (chrBank * 0x1000) + (addr & 0x0fff);
+      break;
+    }
+
+    }
+
+    return Board::readCHR(addr);
+  }
+
+  auto writeCHR(uint addr, uint8 data) -> void {
+    if(addr & 0x2000) {
+      if(settings.mirror == 1) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+      return ppu.writeCIRAM(addr, data);
+    }
+
+    switch(revision) {
+    case Revision::CNROM: {
+      addr = (chrBank * 0x2000) + (addr & 0x1fff);
+      break;
+    }
+
+    case Revision::CPROM: {
+      if(addr < 0x1000) addr = addr & 0x1fff;
+      else              addr = (chrBank * 0x1000) + (addr & 0x0fff);
+      break;
+    }
+
+    }
+    Board::writeCHR(addr, data);
+  }
+
+  auto power() -> void {
+  }
+
+  auto reset() -> void {
+    chrBank = 0;
+  }
+
+  auto serialize(serializer& s) -> void {
+    Board::serialize(s);
+    s.integer(chrBank);
+  }
+
+  enum class Revision : uint {
+    CNROM,
+    CPROM,
+  } revision;
+
+  struct Settings {
+    bool mirror;  //0 = vertical, 1 = horizontal
+    bool security;
+    uint2 pass;
+  } settings;
+
+  uint2 chrBank;
+};
diff --git a/higan/higan/fc/cartridge/board/nes-exrom.cpp b/nSide/higan/fc/cartridge/board/hvc-exrom.cpp
similarity index 64%
rename from higan/higan/fc/cartridge/board/nes-exrom.cpp
rename to nSide/higan/fc/cartridge/board/hvc-exrom.cpp
index 02229d8..4365a47 100644
--- a/higan/higan/fc/cartridge/board/nes-exrom.cpp
+++ b/nSide/higan/fc/cartridge/board/hvc-exrom.cpp
@@ -1,6 +1,11 @@
-struct NES_ExROM : Board {
-  NES_ExROM(Markup::Node& document) : Board(document), mmc5(*this) {
-    revision = Revision::ELROM;
+struct HVC_ExROM : Board {
+  HVC_ExROM(Markup::Node& boardNode) : Board(boardNode), mmc5(*this, boardNode) {
+    chip = &mmc5;
+    string type = boardNode["id"].text();
+    if(type.match("*EKROM*")) revision = Revision::EKROM;
+    if(type.match("*ELROM*")) revision = Revision::ELROM;
+    if(type.match("*ETROM*")) revision = Revision::ETROM;
+    if(type.match("*EWROM*")) revision = Revision::EWROM;
   }
 
   auto main() -> void {
diff --git a/higan/higan/fc/cartridge/board/nes-fxrom.cpp b/nSide/higan/fc/cartridge/board/hvc-fxrom.cpp
similarity index 77%
rename from higan/higan/fc/cartridge/board/nes-fxrom.cpp
rename to nSide/higan/fc/cartridge/board/hvc-fxrom.cpp
index b4a3316..b75b9fb 100644
--- a/higan/higan/fc/cartridge/board/nes-fxrom.cpp
+++ b/nSide/higan/fc/cartridge/board/hvc-fxrom.cpp
@@ -1,20 +1,22 @@
 //MMC4
 
-struct NES_FxROM : Board {
-  NES_FxROM(Markup::Node& document) : Board(document) {
-    revision = Revision::FKROM;
+struct HVC_FxROM : Board {
+  HVC_FxROM(Markup::Node& boardNode) : Board(boardNode) {
+    string type = boardNode["id"].text();
+    if(type.match("*FJROM*" )) revision = Revision::FJROM;
+    if(type.match("*FKROM*" )) revision = Revision::FKROM;
   }
 
   auto readPRG(uint addr) -> uint8 {
     if(addr < 0x6000) return cpu.mdr();
-    if(addr < 0x8000) return prgram.read(addr);
+    if(addr < 0x8000) return read(prgram, addr);
     uint bank = addr < 0xc000 ? prgBank : (uint4)0x0f;
-    return prgrom.read((bank * 0x4000) | (addr & 0x3fff));
+    return read(prgrom, (bank * 0x4000) | (addr & 0x3fff));
   }
 
   auto writePRG(uint addr, uint8 data) -> void {
     if(addr < 0x6000) return;
-    if(addr < 0x8000) return prgram.write(addr, data);
+    if(addr < 0x8000) return write(prgram, addr, data);
 
     switch(addr & 0xf000) {
     case 0xa000: prgBank = data & 0x0f; break;
@@ -26,7 +28,7 @@ struct NES_FxROM : Board {
     }
   }
 
-  auto addrCIRAM(uint addr) const -> uint {
+  auto ciramAddress(uint addr) const -> uint {
     switch(mirror) {
     case 0: return ((addr & 0x0400) >> 0) | (addr & 0x03ff);  //vertical mirroring
     case 1: return ((addr & 0x0800) >> 1) | (addr & 0x03ff);  //horizontal mirroring
@@ -34,7 +36,7 @@ struct NES_FxROM : Board {
   }
 
   auto readCHR(uint addr) -> uint8 {
-    if(addr & 0x2000) return ppu.readCIRAM(addrCIRAM(addr));
+    if(addr & 0x2000) return ppu.readCIRAM(ciramAddress(addr));
     bool region = addr & 0x1000;
     uint bank = chrBank[region][latch[region]];
     if((addr & 0x0ff8) == 0x0fd8) latch[region] = 0;
@@ -43,7 +45,7 @@ struct NES_FxROM : Board {
   }
 
   auto writeCHR(uint addr, uint8 data) -> void {
-    if(addr & 0x2000) return ppu.writeCIRAM(addrCIRAM(addr), data);
+    if(addr & 0x2000) return ppu.writeCIRAM(ciramAddress(addr), data);
     bool region = addr & 0x1000;
     uint bank = chrBank[region][latch[region]];
     if((addr & 0x0ff8) == 0x0fd8) latch[region] = 0;
diff --git a/higan/higan/fc/cartridge/board/nes-gxrom.cpp b/nSide/higan/fc/cartridge/board/hvc-gxrom.cpp
similarity index 62%
rename from higan/higan/fc/cartridge/board/nes-gxrom.cpp
rename to nSide/higan/fc/cartridge/board/hvc-gxrom.cpp
index 547d296..d0662b2 100644
--- a/higan/higan/fc/cartridge/board/nes-gxrom.cpp
+++ b/nSide/higan/fc/cartridge/board/hvc-gxrom.cpp
@@ -1,18 +1,20 @@
 //NES-GNROM
 //NES-MHROM
 
-struct NES_GxROM : Board {
-  NES_GxROM(Markup::Node& document) : Board(document) {
-    settings.mirror = document["board/mirror/mode"].text() == "vertical" ? 1 : 0;
+struct HVC_GxROM : Board {
+  HVC_GxROM(Markup::Node& boardNode) : Board(boardNode) {
+    settings.mirror = boardNode["mirror/mode"].text() == "horizontal";
   }
 
   auto readPRG(uint addr) -> uint8 {
-    if(addr & 0x8000) return prgrom.read((prgBank << 15) | (addr & 0x7fff));
+    if(addr & 0x8000) return read(prgrom, (prgBank << 15) | (addr & 0x7fff));
     return cpu.mdr();
   }
 
   auto writePRG(uint addr, uint8 data) -> void {
     if(addr & 0x8000) {
+      // Bus conflicts
+      data &= readPRG(addr);
       prgBank = (data & 0x30) >> 4;
       chrBank = (data & 0x03) >> 0;
     }
@@ -20,8 +22,8 @@ struct NES_GxROM : Board {
 
   auto readCHR(uint addr) -> uint8 {
     if(addr & 0x2000) {
-      if(settings.mirror == 0) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
-      return ppu.readCIRAM(addr & 0x07ff);
+      if(settings.mirror == 1) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+      return ppu.readCIRAM(addr);
     }
     addr = (chrBank * 0x2000) + (addr & 0x1fff);
     return Board::readCHR(addr);
@@ -29,8 +31,8 @@ struct NES_GxROM : Board {
 
   auto writeCHR(uint addr, uint8 data) -> void {
     if(addr & 0x2000) {
-      if(settings.mirror == 0) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
-      return ppu.writeCIRAM(addr & 0x07ff, data);
+      if(settings.mirror == 1) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+      return ppu.writeCIRAM(addr, data);
     }
     addr = (chrBank * 0x2000) + (addr & 0x1fff);
     Board::writeCHR(addr, data);
@@ -51,7 +53,7 @@ struct NES_GxROM : Board {
   }
 
   struct Settings {
-    bool mirror;  //0 = horizontal, 1 = vertical
+    bool mirror;  //0 = vertical, 1 = horizontal
   } settings;
 
   uint2 prgBank;
diff --git a/nSide/higan/fc/cartridge/board/hvc-nrom.cpp b/nSide/higan/fc/cartridge/board/hvc-nrom.cpp
new file mode 100644
index 0000000..41d5565
--- /dev/null
+++ b/nSide/higan/fc/cartridge/board/hvc-nrom.cpp
@@ -0,0 +1,71 @@
+//HVC-FAMILYBASIC
+//HVC-HROM
+//HVC-NROM-128
+//HVC-NROM-256
+//HVC-RROM
+//HVC-RROM-128
+//HVC-RTROM
+//HVC-SROM
+//HVC-STROM
+
+struct HVC_NROM : Board {
+  HVC_NROM(Markup::Node& boardNode) : Board(boardNode) {
+    string type = boardNode["id"].text();
+    if(type.match("*FAMILYBASIC*")) revision = Revision::FAMILYBASIC;
+    if(type.match("*HROM*"       )) revision = Revision::HROM;
+    if(type.match("*NROM*"       )) revision = Revision::NROM;
+    if(type.match("*RROM*"       )) revision = Revision::RROM;
+    if(type.match("*RTROM*"      )) revision = Revision::RTROM;
+    if(type.match("*SROM*"       )) revision = Revision::SROM;
+    if(type.match("*STROM*"      )) revision = Revision::STROM;
+    if(revision == Revision::HROM) {
+      settings.mirror = 0;
+    } else {
+      settings.mirror = boardNode["mirror/mode"].text() == "horizontal";
+    }
+  }
+
+  auto readPRG(uint addr) -> uint8 {
+    if((addr & 0x8000) == 0x8000) return read(prgrom, addr);
+    if(revision == Revision::FAMILYBASIC && (addr & 0xe000) == 0x6000) return read(prgram, addr);
+    return cpu.mdr();
+  }
+
+  auto writePRG(uint addr, uint8 data) -> void {
+    if(revision == Revision::FAMILYBASIC && (addr & 0xe000) == 0x6000) write(prgram, addr, data);
+  }
+
+  auto readCHR(uint addr) -> uint8 {
+    if(addr & 0x2000) {
+      if(settings.mirror == 1) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+      return ppu.readCIRAM(addr & 0x07ff);
+    }
+    return Board::readCHR(addr);
+  }
+
+  auto writeCHR(uint addr, uint8 data) -> void {
+    if(addr & 0x2000) {
+      if(settings.mirror == 1) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+      return ppu.writeCIRAM(addr, data);
+    }
+    return Board::writeCHR(addr, data);
+  }
+
+  auto serialize(serializer& s) -> void {
+    Board::serialize(s);
+  }
+
+  enum class Revision : uint {
+    FAMILYBASIC,
+    HROM,
+    NROM,
+    RROM,
+    RTROM,
+    SROM,
+    STROM,
+  } revision;
+
+  struct Settings {
+    bool mirror;  //0 = vertical, 1 = horizontal
+  } settings;
+};
diff --git a/higan/higan/fc/cartridge/board/nes-pxrom.cpp b/nSide/higan/fc/cartridge/board/hvc-pxrom.cpp
similarity index 78%
rename from higan/higan/fc/cartridge/board/nes-pxrom.cpp
rename to nSide/higan/fc/cartridge/board/hvc-pxrom.cpp
index 79dfd75..1562204 100644
--- a/higan/higan/fc/cartridge/board/nes-pxrom.cpp
+++ b/nSide/higan/fc/cartridge/board/hvc-pxrom.cpp
@@ -1,13 +1,15 @@
 //MMC2
 
-struct NES_PxROM : Board {
-  NES_PxROM(Markup::Node& document) : Board(document) {
-    revision = Revision::PNROM;
+struct HVC_PxROM : Board {
+  HVC_PxROM(Markup::Node& boardNode) : Board(boardNode) {
+    string type = boardNode["id"].text();
+    if(type.match("*PEEOROM*")) revision = Revision::PEEOROM;
+    if(type.match("*PNROM*"  )) revision = Revision::PNROM;
   }
 
   auto readPRG(uint addr) -> uint8 {
     if(addr < 0x6000) return cpu.mdr();
-    if(addr < 0x8000) return prgram.read(addr);
+    if(addr < 0x8000) return read(prgram, addr);
     uint bank = 0;
     switch((addr / 0x2000) & 3) {
     case 0: bank = prgBank; break;
@@ -15,12 +17,12 @@ struct NES_PxROM : Board {
     case 2: bank = 0x0e; break;
     case 3: bank = 0x0f; break;
     }
-    return prgrom.read((bank * 0x2000) | (addr & 0x1fff));
+    return read(prgrom, (bank * 0x2000) | (addr & 0x1fff));
   }
 
   auto writePRG(uint addr, uint8 data) -> void {
     if(addr < 0x6000) return;
-    if(addr < 0x8000) return prgram.write(addr, data);
+    if(addr < 0x8000) return write(prgram, addr, data);
 
     switch(addr & 0xf000) {
     case 0xa000: prgBank = data & 0x0f; break;
@@ -32,7 +34,7 @@ struct NES_PxROM : Board {
     }
   }
 
-  auto addrCIRAM(uint addr) const -> uint {
+  auto ciramAddress(uint addr) const -> uint {
     switch(mirror) {
     case 0: return ((addr & 0x0400) >> 0) | (addr & 0x03ff);  //vertical mirroring
     case 1: return ((addr & 0x0800) >> 1) | (addr & 0x03ff);  //horizontal mirroring
@@ -40,7 +42,7 @@ struct NES_PxROM : Board {
   }
 
   auto readCHR(uint addr) -> uint8 {
-    if(addr & 0x2000) return ppu.readCIRAM(addrCIRAM(addr));
+    if(addr & 0x2000) return ppu.readCIRAM(ciramAddress(addr));
     bool region = addr & 0x1000;
     uint bank = chrBank[region][latch[region]];
     if((addr & 0x0ff8) == 0x0fd8) latch[region] = 0;
@@ -49,7 +51,7 @@ struct NES_PxROM : Board {
   }
 
   auto writeCHR(uint addr, uint8 data) -> void {
-    if(addr & 0x2000) return ppu.writeCIRAM(addrCIRAM(addr), data);
+    if(addr & 0x2000) return ppu.writeCIRAM(ciramAddress(addr), data);
     bool region = addr & 0x1000;
     uint bank = chrBank[region][latch[region]];
     if((addr & 0x0ff8) == 0x0fd8) latch[region] = 0;
diff --git a/nSide/higan/fc/cartridge/board/hvc-sxrom.cpp b/nSide/higan/fc/cartridge/board/hvc-sxrom.cpp
new file mode 100644
index 0000000..290ac95
--- /dev/null
+++ b/nSide/higan/fc/cartridge/board/hvc-sxrom.cpp
@@ -0,0 +1,145 @@
+struct HVC_SxROM : Board {
+  HVC_SxROM(Markup::Node& boardNode) : Board(boardNode), mmc1(*this, boardNode) {
+    string type = boardNode["id"].text();
+    if(type.match("*SAROM"   )) revision = Revision::SAROM;
+    if(type.match("*SBROM"   )) revision = Revision::SBROM;
+    if(type.match("*SCROM"   )) revision = Revision::SCROM;
+    if(type.match("*SC1ROM"  )) revision = Revision::SC1ROM;
+    if(type.match("*SEROM"   )) revision = Revision::SEROM;
+    if(type.match("*SFROM"   )) revision = Revision::SFROM;
+    if(type.match("*SF1ROM"  )) revision = Revision::SF1ROM;
+    if(type.match("*SFEXPROM")) revision = Revision::SFEXPROM;
+    if(type.match("*SGROM"   )) revision = Revision::SGROM;
+    if(type.match("*SHROM"   )) revision = Revision::SHROM;
+    if(type.match("*SH1ROM"  )) revision = Revision::SH1ROM;
+    if(type.match("*SIROM"   )) revision = Revision::SIROM;
+    if(type.match("*SJROM"   )) revision = Revision::SJROM;
+    if(type.match("*SKROM"   )) revision = Revision::SKROM;
+    if(type.match("*SLROM"   )) revision = Revision::SLROM;
+    if(type.match("*SL1ROM"  )) revision = Revision::SL1ROM;
+    if(type.match("*SL2ROM"  )) revision = Revision::SL2ROM;
+    if(type.match("*SL3ROM"  )) revision = Revision::SL3ROM;
+    if(type.match("*SLRROM"  )) revision = Revision::SLRROM;
+    if(type.match("*SMROM"   )) revision = Revision::SMROM;
+    if(type.match("*SNROM"   )) revision = Revision::SNROM;
+    if(type.match("*SNWEPROM")) revision = Revision::SNWEPROM;
+    if(type.match("*SOROM"   )) revision = Revision::SOROM;
+    if(type.match("*SUROM"   )) revision = Revision::SUROM;
+    if(type.match("*SXROM"   )) revision = Revision::SXROM;
+  }
+
+  auto main() -> void {
+    mmc1.main();
+  }
+
+  auto ramAddress(uint addr) -> uint {
+    uint bank = 0;
+    if(revision == Revision::SOROM) bank = (mmc1.chrBank[0] & 0x08) >> 3;
+    if(revision == Revision::SXROM) bank = (mmc1.chrBank[0] & 0x0c) >> 2;
+    return (bank << 13) | (addr & 0x1fff);
+  }
+
+  auto readPRG(uint addr) -> uint8 {
+    if((addr & 0xe000) == 0x6000) {
+      if(revision == Revision::SNROM) {
+        if((mmc1.chrAddress(ppu.io.chrAddressBus) >> 16) & 1) return cpu.mdr();
+      }
+      if(mmc1.ramDisable) return cpu.mdr();
+      if(prgram.size() > 0) return read(prgram, ramAddress(addr));
+    }
+
+    if(addr & 0x8000) {
+      switch(revision) {
+      default:
+        addr = mmc1.prgAddress(addr);
+        if(revision == Revision::SUROM || revision == Revision::SXROM) {
+          addr |= ((mmc1.chrAddress(ppu.io.chrAddressBus) >> 16) & 1) << 18;
+        }
+        break;
+      case Revision::SEROM:
+      case Revision::SHROM:
+      case Revision::SH1ROM:
+        break;
+      case Revision::SFEXPROM:
+        addr = mmc1.prgAddress(addr);
+        if((expLock & 0x20) && (addr & 0x7fff) == 0x0180) return 0x05;
+        break;
+      }
+      return read(prgrom, addr);
+    }
+
+    return cpu.mdr();
+  }
+
+  auto writePRG(uint addr, uint8 data) -> void {
+    if((addr & 0xe000) == 0x6000) {
+      if(revision == Revision::SNROM) {
+        if(mmc1.chrBank[0] & 0x10) return;
+      } else if(revision == Revision::SFEXPROM) {
+        expLock = data;
+      }
+      if(mmc1.ramDisable) return;
+      if(prgram.size() > 0) return write(prgram, ramAddress(addr), data);
+    }
+
+    if(addr & 0x8000) return mmc1.mmioWrite(addr, data);
+  }
+
+  auto readCHR(uint addr) -> uint8 {
+    if(addr & 0x2000) return ppu.readCIRAM(mmc1.ciramAddress(addr));
+    return Board::readCHR(mmc1.chrAddress(addr));
+  }
+
+  auto writeCHR(uint addr, uint8 data) -> void {
+    if(addr & 0x2000) return ppu.writeCIRAM(mmc1.ciramAddress(addr), data);
+    return Board::writeCHR(mmc1.chrAddress(addr), data);
+  }
+
+  auto power() -> void {
+    mmc1.power();
+  }
+
+  auto reset() -> void {
+    mmc1.reset();
+    expLock = 0x00;
+  }
+
+  auto serialize(serializer& s) -> void {
+    Board::serialize(s);
+    mmc1.serialize(s);
+    if(revision == Revision::SFEXPROM) {
+      s.integer(expLock);
+    }
+  }
+
+  enum class Revision : uint {
+    SAROM,
+    SBROM,
+    SCROM,
+    SC1ROM,
+    SEROM,
+    SFROM,
+    SF1ROM,
+    SFEXPROM,
+    SGROM,
+    SHROM,
+    SH1ROM,
+    SIROM,
+    SJROM,
+    SKROM,
+    SLROM,
+    SL1ROM,
+    SL2ROM,
+    SL3ROM,
+    SLRROM,
+    SMROM,
+    SNROM,
+    SNWEPROM,
+    SOROM,
+    SUROM,
+    SXROM,
+  } revision;
+
+  MMC1 mmc1;
+  uint8 expLock;
+};
diff --git a/nSide/higan/fc/cartridge/board/hvc-txrom.cpp b/nSide/higan/fc/cartridge/board/hvc-txrom.cpp
new file mode 100644
index 0000000..e9dd294
--- /dev/null
+++ b/nSide/higan/fc/cartridge/board/hvc-txrom.cpp
@@ -0,0 +1,106 @@
+struct HVC_TxROM : Board {
+  HVC_TxROM(Markup::Node& boardNode) : Board(boardNode), mmc3(*this, boardNode) {
+    string type = boardNode["id"].text();
+    if(type.match("*TBROM"  )) revision = Revision::TBROM;
+    if(type.match("*TEROM"  )) revision = Revision::TEROM;
+    if(type.match("*TFROM"  )) revision = Revision::TFROM;
+    if(type.match("*TGROM"  )) revision = Revision::TGROM;
+    if(type.match("*TKROM"  )) revision = Revision::TKROM;
+    if(type.match("*TKEPROM")) revision = Revision::TKEPROM;
+    if(type.match("*TKSROM" )) revision = Revision::TKSROM;
+    if(type.match("*TLROM"  )) revision = Revision::TLROM;
+    if(type.match("*TL1ROM" )) revision = Revision::TL1ROM;
+    if(type.match("*TL2ROM" )) revision = Revision::TL2ROM;
+    if(type.match("*TLSROM" )) revision = Revision::TLSROM;
+    if(type.match("*TNROM"  )) revision = Revision::TNROM;
+    if(type.match("*TQROM"  )) revision = Revision::TQROM;
+    if(type.match("*TR1ROM" )) revision = Revision::TR1ROM;
+    if(type.match("*TSROM"  )) revision = Revision::TSROM;
+    if(type.match("*TVROM"  )) revision = Revision::TVROM;
+    if(type.match("*MC-ACC" )) revision = Revision::MCACC;
+  }
+
+  auto main() -> void {
+    mmc3.main();
+  }
+
+  auto readPRG(uint addr) -> uint8 {
+    if((addr & 0xe000) == 0x6000 && prgram.size() > 0) return mmc3.ramRead(addr);
+    if(addr & 0x8000) return read(prgrom, mmc3.prgAddress(addr));
+    return cpu.mdr();
+  }
+
+  auto writePRG(uint addr, uint8 data) -> void {
+    if((addr & 0xe000) == 0x6000 && prgram.size() > 0) return mmc3.ramWrite(addr, data);
+    if(addr & 0x8000) return mmc3.regWrite(addr, data);
+  }
+
+  auto readCHR(uint addr) -> uint8 {
+    if(revision == Revision::TR1ROM || revision == Revision::TVROM) {
+      if(addr & 0x2000) return read(chrram, addr);
+      return read(chrrom, mmc3.chrAddress(addr));
+    }
+    if(addr & 0x2000) return ppu.readCIRAM(ciramAddress(addr));
+    if(revision == Revision::TQROM) {
+      if(mmc3.chrAddress(addr) & (0x40 << 10))
+        return read(chrram, mmc3.chrAddress(addr));
+      else
+        return read(chrrom, mmc3.chrAddress(addr));
+    }
+    return Board::readCHR(mmc3.chrAddress(addr));
+  }
+
+  auto writeCHR(uint addr, uint8 data) -> void {
+    if(revision == Revision::TR1ROM || revision == Revision::TVROM) {
+      if(addr & 0x2000) write(chrram, addr, data);
+      return;
+    }
+    if(addr & 0x2000) return ppu.writeCIRAM(ciramAddress(addr), data);
+    return Board::writeCHR(mmc3.chrAddress(addr), data);
+  }
+
+  auto ciramAddress(uint addr) -> uint {
+    switch(revision) {
+    default:
+      return mmc3.ciramAddress(addr);
+    case Revision::TKSROM:
+    case Revision::TLSROM:
+      return ((mmc3.chrAddress(addr & 0xfff) & 0x20000) >> 7) | (addr & 0x3ff);
+    }
+  }
+
+  auto power() -> void {
+    mmc3.power();
+  }
+
+  auto reset() -> void {
+    mmc3.reset();
+  }
+
+  auto serialize(serializer& s) -> void {
+    Board::serialize(s);
+    mmc3.serialize(s);
+  }
+
+  enum class Revision : uint {
+    TBROM,
+    TEROM,
+    TFROM,
+    TGROM,
+    TKROM,
+    TKEPROM,
+    TKSROM,
+    TLROM,
+    TL1ROM,
+    TL2ROM,
+    TLSROM,
+    TNROM,
+    TQROM,
+    TR1ROM,
+    TSROM,
+    TVROM,
+    MCACC,
+  } revision;
+
+  MMC3 mmc3;
+};
diff --git a/nSide/higan/fc/cartridge/board/hvc-uxrom.cpp b/nSide/higan/fc/cartridge/board/hvc-uxrom.cpp
new file mode 100644
index 0000000..d5bdd38
--- /dev/null
+++ b/nSide/higan/fc/cartridge/board/hvc-uxrom.cpp
@@ -0,0 +1,87 @@
+//HVC-UNROM
+//HVC-UN1ROM
+//HVC-UOROM
+
+struct HVC_UxROM : Board {
+  HVC_UxROM(Markup::Node& boardNode) : Board(boardNode) {
+    settings.mirror = boardNode["mirror/mode"].text() == "horizontal";
+    string type = boardNode["id"].text();
+    if(type.match("*UNROM" )) revision = Revision::UNROM;
+    if(type.match("*UN1ROM")) revision = Revision::UN1ROM;
+    if(type.match("*UOROM" )) revision = Revision::UOROM;
+    type = boardNode["chip/type"].text();
+    if(type.match("74*32")) chipType = ChipType::_7432;
+    if(type.match("74*08")) chipType = ChipType::_7408;
+  }
+
+  auto readPRG(uint addr) -> uint8 {
+    if((addr & 0x8000) == 0x0000) return cpu.mdr();
+    switch(chipType) {
+    case ChipType::_7432:
+      switch(addr & 0xc000) {
+      case 0x8000: return read(prgrom, (prgBank << 14) | (addr & 0x3fff));
+      case 0xc000: return read(prgrom, (   0x0f << 14) | (addr & 0x3fff));
+      }
+    case ChipType::_7408:
+      switch(addr & 0xc000) {
+      case 0x8000: return read(prgrom, (   0x00 << 14) | (addr & 0x3fff));
+      case 0xc000: return read(prgrom, (prgBank << 14) | (addr & 0x3fff));
+      }
+    }
+  }
+
+  auto writePRG(uint addr, uint8 data) -> void {
+    if(addr & 0x8000) {
+      // Bus conflicts
+      data &= readPRG(addr);
+      if(revision != Revision::UN1ROM) prgBank = data & 0x0f;
+      if(revision == Revision::UN1ROM) prgBank = (data & 0x1c) >> 2;
+    }
+  }
+
+  auto readCHR(uint addr) -> uint8 {
+    if(addr & 0x2000) {
+      if(settings.mirror == 1) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+      return ppu.readCIRAM(addr);
+    }
+    return Board::readCHR(addr);
+  }
+
+  auto writeCHR(uint addr, uint8 data) -> void {
+    if(addr & 0x2000) {
+      if(settings.mirror == 1) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+      return ppu.writeCIRAM(addr, data);
+    }
+    return Board::writeCHR(addr, data);
+  }
+
+  auto power() -> void {
+  }
+
+  auto reset() -> void {
+    prgBank = 0;
+  }
+
+  auto serialize(serializer& s) -> void {
+    Board::serialize(s);
+
+    s.integer(prgBank);
+  }
+
+  enum class Revision : uint {
+    UNROM,
+    UN1ROM,
+    UOROM,
+  } revision;
+
+  enum class ChipType : uint {
+    _7432,
+    _7408,
+  } chipType;
+
+  struct Settings {
+    bool mirror;    //0 = vertical, 1 = horizontal
+  } settings;
+
+  uint4 prgBank;
+};
diff --git a/nSide/higan/fc/cartridge/board/irem-74-161-161-21-138.cpp b/nSide/higan/fc/cartridge/board/irem-74-161-161-21-138.cpp
new file mode 100644
index 0000000..c0dc879
--- /dev/null
+++ b/nSide/higan/fc/cartridge/board/irem-74-161-161-21-138.cpp
@@ -0,0 +1,62 @@
+//IREM-74*161/161/21/138
+
+struct Irem74_161_161_21_138 : Board {
+  Irem74_161_161_21_138(Markup::Node& boardNode) : Board(boardNode) {
+  }
+
+  auto readPRG(uint addr) -> uint8 {
+    if(addr & 0x8000) return read(prgrom, (prgBank << 15) | (addr & 0x7fff));
+    return cpu.mdr();
+  }
+
+  auto writePRG(uint addr, uint8 data) -> void {
+    if(addr & 0x8000) {
+      // Bus conflicts
+      data &= readPRG(addr);
+      prgBank = (data & 0x0f) >> 0;
+      chrBank = (data & 0xf0) >> 4;
+    }
+  }
+
+  auto readCHR(uint addr) -> uint8 {
+    if(addr & 0x2000) return ciramRead(addr);
+    if((addr & 0x1800) == 0x0000) return read(chrrom, (addr & 0x07ff) | (chrBank << 11));
+    return read(chrram, addr);
+  }
+
+  auto writeCHR(uint addr, uint8 data) -> void {
+    if(addr & 0x2000) return ciramWrite(addr, data);
+    if((addr & 0x1800) != 0x0000) return write(chrram, addr & 0x1fff, data);
+  }
+
+  auto ciramRead(uint addr) -> uint8 {
+    switch(addr & 0x0800) {
+    case 0x0000: return read(chrram, addr & 0x1fff);
+    case 0x0800: return ppu.readCIRAM(addr);
+    }
+  }
+
+  auto ciramWrite(uint addr, uint8 data) -> void {
+    switch(addr & 0x0800) {
+    case 0x0000: return write(chrram, addr & 0x1fff, data);
+    case 0x0800: return ppu.writeCIRAM(addr, data);
+    }
+  }
+
+  auto power() -> void {
+  }
+
+  auto reset() -> void {
+    prgBank = 0;
+    chrBank = 0;
+  }
+
+  auto serialize(serializer& s) -> void {
+    Board::serialize(s);
+    s.integer(prgBank);
+    s.integer(chrBank);
+  }
+
+  uint4 prgBank;
+  uint4 chrBank;
+};
diff --git a/nSide/higan/fc/cartridge/board/irem-g101.cpp b/nSide/higan/fc/cartridge/board/irem-g101.cpp
new file mode 100644
index 0000000..f28d386
--- /dev/null
+++ b/nSide/higan/fc/cartridge/board/irem-g101.cpp
@@ -0,0 +1,59 @@
+struct IremG101 : Board {
+  IremG101(Markup::Node& boardNode) : Board(boardNode), g101(*this, boardNode) {
+    if(!boardNode["mirror"]) {
+      settings.mirror = 0;
+    } else {
+      string mirror = boardNode["mirror/mode"].text();
+      if(mirror == "screen-0") settings.mirror = 1;
+      if(mirror == "screen-1") settings.mirror = 2;
+    }
+  }
+
+  auto readPRG(uint addr) -> uint8 {
+    if((addr & 0x8000) == 0x8000) return read(prgrom, g101.prgAddress(addr));
+    if((addr & 0xe000) == 0x6000) return read(prgram, addr & 0x1fff);
+    return cpu.mdr();
+  }
+
+  auto writePRG(uint addr, uint8 data) -> void {
+    if((addr & 0x8000) == 0x8000) return g101.regWrite(addr, data);
+    if((addr & 0xe000) == 0x6000) return write(prgram, addr & 0x1fff, data);
+  }
+
+  auto readCHR(uint addr) -> uint8 {
+    if(addr & 0x2000) switch(settings.mirror) {
+    case 0: return ppu.readCIRAM(g101.ciramAddress(addr));
+    case 1: return ppu.readCIRAM((addr & 0x03ff) | 0x0400);
+    case 2: return ppu.readCIRAM((addr & 0x03ff) | 0x0800);
+    }
+    return Board::readCHR(g101.chrAddress(addr));
+  }
+
+  auto writeCHR(uint addr, uint8 data) -> void {
+    if(addr & 0x2000) switch(settings.mirror) {
+    case 0: return ppu.writeCIRAM(g101.ciramAddress(addr), data);
+    case 1: return ppu.writeCIRAM((addr & 0x03ff) | 0x0400, data);
+    case 2: return ppu.writeCIRAM((addr & 0x03ff) | 0x0800, data);
+    }
+    return Board::writeCHR(g101.chrAddress(addr), data);
+  }
+
+  auto power() -> void {
+    g101.power();
+  }
+
+  auto reset() -> void {
+    g101.reset();
+  }
+
+  auto serialize(serializer& s) -> void {
+    Board::serialize(s);
+    g101.serialize(s);
+  }
+
+  struct Settings {
+    uint2 mirror;  //0 = G101-controlled, 1 = screen 0, 2 = screen 1
+  } settings;
+
+  G101 g101;
+};
diff --git a/nSide/higan/fc/cartridge/board/irem-h3001.cpp b/nSide/higan/fc/cartridge/board/irem-h3001.cpp
new file mode 100644
index 0000000..cf9ed66
--- /dev/null
+++ b/nSide/higan/fc/cartridge/board/irem-h3001.cpp
@@ -0,0 +1,44 @@
+struct IremH3001 : Board {
+  IremH3001(Markup::Node& boardNode) : Board(boardNode), ifh3001(*this, boardNode) {
+  }
+
+  auto main() -> void {
+    ifh3001.main();
+  }
+
+  auto readPRG(uint addr) -> uint8 {
+    if((addr & 0x8000) == 0x8000) return read(prgrom, ifh3001.prgAddress(addr));
+    if((addr & 0xe000) == 0x6000) return read(prgram, addr & 0x1fff);
+    return cpu.mdr();
+  }
+
+  auto writePRG(uint addr, uint8 data) -> void {
+    if((addr & 0x8000) == 0x8000) return ifh3001.regWrite(addr, data);
+    if((addr & 0xe000) == 0x6000) return write(prgram, addr & 0x1fff, data);
+  }
+
+  auto readCHR(uint addr) -> uint8 {
+    if(addr & 0x2000) return ppu.readCIRAM(ifh3001.ciramAddress(addr));
+    return Board::readCHR(ifh3001.chrAddress(addr));
+  }
+
+  auto writeCHR(uint addr, uint8 data) -> void {
+    if(addr & 0x2000) return ppu.writeCIRAM(ifh3001.ciramAddress(addr), data);
+    return Board::writeCHR(ifh3001.chrAddress(addr), data);
+  }
+
+  auto power() -> void {
+    ifh3001.power();
+  }
+
+  auto reset() -> void {
+    ifh3001.reset();
+  }
+
+  auto serialize(serializer& s) -> void {
+    Board::serialize(s);
+    ifh3001.serialize(s);
+  }
+
+  IFH3001 ifh3001;
+};
diff --git a/nSide/higan/fc/cartridge/board/irem-holydiver.cpp b/nSide/higan/fc/cartridge/board/irem-holydiver.cpp
new file mode 100644
index 0000000..ebe1bea
--- /dev/null
+++ b/nSide/higan/fc/cartridge/board/irem-holydiver.cpp
@@ -0,0 +1,59 @@
+//IREM-HOLYDIVER
+
+struct IremHolyDiver : Board {
+  IremHolyDiver(Markup::Node& boardNode) : Board(boardNode) {
+  }
+
+  auto readPRG(uint addr) -> uint8 {
+    switch(addr & 0xc000) {
+    case 0x8000: return read(prgrom, (prgBank << 14) | (addr & 0x3fff));
+    case 0xc000: return read(prgrom, (   0x07 << 14) | (addr & 0x3fff));
+    }
+  }
+
+  auto writePRG(uint addr, uint8 data) -> void {
+    if(addr & 0x8000) {
+      // Bus conflicts
+      data &= readPRG(addr);
+      prgBank = (data & 0x07) >> 0;
+      mirror = data & 0x08;
+      chrBank = (data & 0xf0) >> 4;
+    }
+  }
+
+  auto readCHR(uint addr) -> uint8 {
+    if(addr & 0x2000) {
+      if(mirror == 0) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+      return ppu.readCIRAM(addr);
+    }
+    return Board::readCHR((chrBank * 0x2000) + (addr & 0x1fff));
+  }
+
+  auto writeCHR(uint addr, uint8 data) -> void {
+    if(addr & 0x2000) {
+      if(mirror == 0) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+      return ppu.writeCIRAM(addr, data);
+    }
+    Board::writeCHR((chrBank * 0x2000) + (addr & 0x1fff), data);
+  }
+
+  auto power() -> void {
+  }
+
+  auto reset() -> void {
+    prgBank = 0;
+    chrBank = 0;
+    mirror = 0;
+  }
+
+  auto serialize(serializer& s) -> void {
+    Board::serialize(s);
+    s.integer(prgBank);
+    s.integer(chrBank);
+    s.integer(mirror);
+  }
+
+  uint3 prgBank;
+  uint4 chrBank;
+  bool mirror;
+};
diff --git a/higan/higan/fc/cartridge/board/nes-bnrom.cpp b/nSide/higan/fc/cartridge/board/irem-i-im.cpp
similarity index 55%
rename from higan/higan/fc/cartridge/board/nes-bnrom.cpp
rename to nSide/higan/fc/cartridge/board/irem-i-im.cpp
index e0163e4..5a4098c 100644
--- a/higan/higan/fc/cartridge/board/nes-bnrom.cpp
+++ b/nSide/higan/fc/cartridge/board/irem-i-im.cpp
@@ -1,22 +1,27 @@
-//NES-BN-ROM-01
+//IREM-BNROM
+//NES-BNROM
 
-struct NES_BNROM : Board {
-  NES_BNROM(Markup::Node& document) : Board(document) {
-    settings.mirror = document["board/mirror/mode"].text() == "vertical" ? 1 : 0;
+struct IremIIM : Board {
+  IremIIM(Markup::Node& boardNode) : Board(boardNode) {
+    settings.mirror = boardNode["mirror/mode"].text() == "horizontal";
   }
 
   auto readPRG(uint addr) -> uint8 {
-    if(addr & 0x8000) return prgrom.read((prgBank << 15) | (addr & 0x7fff));
+    if(addr & 0x8000) return read(prgrom, (prgBank << 15) | (addr & 0x7fff));
     return cpu.mdr();
   }
 
   auto writePRG(uint addr, uint8 data) -> void {
-    if(addr & 0x8000) prgBank = data & 0x03;
+    if(addr & 0x8000) {
+      // Bus conflicts
+      data &= readPRG(addr);
+      prgBank = data & 0x03;
+    }
   }
 
   auto readCHR(uint addr) -> uint8 {
     if(addr & 0x2000) {
-      if(settings.mirror == 0) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+      if(settings.mirror == 1) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
       return ppu.readCIRAM(addr);
     }
     return Board::readCHR(addr);
@@ -24,7 +29,7 @@ struct NES_BNROM : Board {
 
   auto writeCHR(uint addr, uint8 data) -> void {
     if(addr & 0x2000) {
-      if(settings.mirror == 0) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+      if(settings.mirror == 1) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
       return ppu.writeCIRAM(addr, data);
     }
     return Board::writeCHR(addr, data);
@@ -43,7 +48,7 @@ struct NES_BNROM : Board {
   }
 
   struct Settings {
-    bool mirror;  //0 = horizontal, 1 = vertical
+    bool mirror;  //0 = vertical, 1 = horizontal
   } settings;
 
   uint2 prgBank;
diff --git a/nSide/higan/fc/cartridge/board/irem-tam-s1.cpp b/nSide/higan/fc/cartridge/board/irem-tam-s1.cpp
new file mode 100644
index 0000000..a0d70bf
--- /dev/null
+++ b/nSide/higan/fc/cartridge/board/irem-tam-s1.cpp
@@ -0,0 +1,67 @@
+//IREM-TAM-S1
+
+struct IremTamS1 : Board {
+  IremTamS1(Markup::Node& boardNode) : Board(boardNode) {
+  }
+
+  auto readPRG(uint addr) -> uint8 {
+    if((addr & 0x8000) == 0x0000) return cpu.mdr();
+    switch(addr & 0xc000) {
+    case 0x8000: return read(prgrom, (   0x0f << 14) | (addr & 0x3fff));
+    case 0xc000: return read(prgrom, (prgBank << 14) | (addr & 0x3fff));
+    }
+  }
+
+  auto writePRG(uint addr, uint8 data) -> void {
+    if(addr & 0x8000) {
+      //TODO: check for bus conflicts
+      //data &= readPRG(addr);
+      prgBank = data & 0x0f;
+      mirror = (data & 0xc0) >> 6;
+    }
+  }
+
+  auto readCHR(uint addr) -> uint8 {
+    if(addr & 0x2000) {
+      switch(mirror) {
+      case 0: addr = (0x0000              ) | (addr & 0x03ff); break;
+      case 1: addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff); break;
+      case 2: addr = ((addr & 0x0400) >> 0) | (addr & 0x03ff); break;
+      case 3: addr = (0x0400              ) | (addr & 0x03ff); break;
+      }
+      return ppu.readCIRAM(addr);
+    }
+    return Board::readCHR(addr);
+  }
+
+  auto writeCHR(uint addr, uint8 data) -> void {
+    if(addr & 0x2000) {
+      switch(mirror) {
+      case 0: addr = (0x0000              ) | (addr & 0x03ff); break;
+      case 1: addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff); break;
+      case 2: addr = ((addr & 0x0400) >> 0) | (addr & 0x03ff); break;
+      case 3: addr = (0x0400              ) | (addr & 0x03ff); break;
+      }
+      return ppu.writeCIRAM(addr, data);
+    }
+    return Board::writeCHR(addr, data);
+  }
+
+  auto power() -> void {
+  }
+
+  auto reset() -> void {
+    prgBank = 0;
+    mirror = 0;
+  }
+
+  auto serialize(serializer& s) -> void {
+    Board::serialize(s);
+
+    s.integer(prgBank);
+    s.integer(mirror);
+  }
+
+  uint4 prgBank;
+  uint2 mirror; //0 = screen 0, 1 = horizontal, 2 = vertical, 3 = screen 1
+};
diff --git a/nSide/higan/fc/cartridge/board/jaleco-jf-0x.cpp b/nSide/higan/fc/cartridge/board/jaleco-jf-0x.cpp
new file mode 100644
index 0000000..c75793d
--- /dev/null
+++ b/nSide/higan/fc/cartridge/board/jaleco-jf-0x.cpp
@@ -0,0 +1,98 @@
+//JALECO-JF-05
+//JALECO-JF-06
+//JALECO-JF-07
+//JALECO-JF-08
+//JALECO-JF-09
+//JALECO-JF-10
+//JALECO-JF-11
+//JALECO-JF-14
+
+struct JalecoJF0x : Board {
+  JalecoJF0x(Markup::Node& boardNode) : Board(boardNode) {
+    string type = boardNode["id"].text();
+    if(type.match("*JF-05*")) revision = Revision::JF_05;
+    if(type.match("*JF-06*")) revision = Revision::JF_06;
+    if(type.match("*JF-07*")) revision = Revision::JF_07;
+    if(type.match("*JF-08*")) revision = Revision::JF_08;
+    if(type.match("*JF-09*")) revision = Revision::JF_09;
+    if(type.match("*JF-10*")) revision = Revision::JF_10;
+    if(type.match("*JF-11*")) revision = Revision::JF_11;
+    if(type.match("*JF-14*")) revision = Revision::JF_14;
+
+    settings.mirror = boardNode["mirror/mode"].text() == "horizontal";
+  }
+
+  auto readPRG(uint addr) -> uint8 {
+    if(addr & 0x8000) return read(prgrom, (prgBank << 15) | (addr & 0x7fff));
+    return cpu.mdr();
+  }
+
+  auto writePRG(uint addr, uint8 data) -> void {
+    if((addr & 0xe000) == 0x6000) {
+      switch(revision) {
+      case Revision::JF_05: case Revision::JF_06: case Revision::JF_07:
+      case Revision::JF_08: case Revision::JF_09: case Revision::JF_10: {
+        chrBank = ((data & 0x01) << 1) | ((data & 0x02) >> 1);
+        break;
+      }
+
+      case Revision::JF_11: case Revision::JF_14: {
+        prgBank = (data & 0x30) >> 4;
+        chrBank = (data & 0x0f) >> 0;
+        break;
+      }
+
+      }
+    }
+  }
+
+  auto readCHR(uint addr) -> uint8 {
+    if(addr & 0x2000) {
+      if(settings.mirror == 1) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+      return ppu.readCIRAM(addr);
+    }
+    addr = (chrBank * 0x2000) + (addr & 0x1fff);
+    return Board::readCHR(addr);
+  }
+
+  auto writeCHR(uint addr, uint8 data) -> void {
+    if(addr & 0x2000) {
+      if(settings.mirror == 1) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+      return ppu.writeCIRAM(addr, data);
+    }
+    addr = (chrBank * 0x2000) + (addr & 0x1fff);
+    Board::writeCHR(addr, data);
+  }
+
+  auto power() -> void {
+  }
+
+  auto reset() -> void {
+    prgBank = 0;
+    chrBank = 0;
+  }
+
+  auto serialize(serializer& s) -> void {
+    Board::serialize(s);
+    s.integer(prgBank);
+    s.integer(chrBank);
+  }
+
+  enum class Revision : uint {
+    JF_05,
+    JF_06,
+    JF_07,
+    JF_08,
+    JF_09,
+    JF_10,
+    JF_11,
+    JF_14,
+  } revision;
+
+  struct Settings {
+    bool mirror;  //0 = vertical, 1 = horizontal
+  } settings;
+
+  uint2 prgBank;
+  uint4 chrBank;
+};
diff --git a/nSide/higan/fc/cartridge/board/jaleco-jf-16.cpp b/nSide/higan/fc/cartridge/board/jaleco-jf-16.cpp
new file mode 100644
index 0000000..ad62ba1
--- /dev/null
+++ b/nSide/higan/fc/cartridge/board/jaleco-jf-16.cpp
@@ -0,0 +1,59 @@
+  //JALECO-JF-16
+
+struct JalecoJF16 : Board {
+  JalecoJF16(Markup::Node& boardNode) : Board(boardNode) {
+  }
+
+  auto readPRG(uint addr) -> uint8 {
+    switch(addr & 0xc000) {
+    case 0x8000: return read(prgrom, (prgBank << 14) | (addr & 0x3fff));
+    case 0xc000: return read(prgrom, (   0x07 << 14) | (addr & 0x3fff));
+    }
+  }
+
+  auto writePRG(uint addr, uint8 data) -> void {
+    if(addr & 0x8000) {
+      // Bus conflicts
+      data &= readPRG(addr);
+      prgBank = (data & 0x07) >> 0;
+      nametable = data & 0x08;
+      chrBank = (data & 0xf0) >> 4;
+    }
+  }
+
+  auto readCHR(uint addr) -> uint8 {
+    if(addr & 0x2000) {
+      addr = (nametable << 10) | (addr & 0x03ff);
+      return ppu.readCIRAM(addr);
+    }
+    return Board::readCHR((chrBank * 0x2000) + (addr & 0x1fff));
+  }
+
+  auto writeCHR(uint addr, uint8 data) -> void {
+    if(addr & 0x2000) {
+      addr = (nametable << 10) | (addr & 0x03ff);
+      return ppu.writeCIRAM(addr, data);
+    }
+    Board::writeCHR((chrBank * 0x2000) + (addr & 0x1fff), data);
+  }
+
+  auto power() -> void {
+  }
+
+  auto reset() -> void {
+    prgBank = 0;
+    chrBank = 0;
+    nametable = 0;
+  }
+
+  auto serialize(serializer& s) -> void {
+    Board::serialize(s);
+    s.integer(prgBank);
+    s.integer(chrBank);
+    s.integer(nametable);
+  }
+
+  uint3 prgBank;
+  uint4 chrBank;
+  bool nametable;
+};
diff --git a/nSide/higan/fc/cartridge/board/jaleco-jf-2x.cpp b/nSide/higan/fc/cartridge/board/jaleco-jf-2x.cpp
new file mode 100644
index 0000000..6435abd
--- /dev/null
+++ b/nSide/higan/fc/cartridge/board/jaleco-jf-2x.cpp
@@ -0,0 +1,65 @@
+//JALECO-JF-24
+//JALECO-JF-25
+
+struct JalecoJF2x : Board {
+  JalecoJF2x(Markup::Node& boardNode) : Board(boardNode), ss88006(*this, boardNode) {
+    string type = boardNode["id"].text();
+    if(type.match("*JF-23")) revision = Revision::JF_23;
+    if(type.match("*JF-24")) revision = Revision::JF_24;
+    if(type.match("*JF-25")) revision = Revision::JF_25;
+    if(type.match("*JF-27")) revision = Revision::JF_27;
+    if(type.match("*JF-29")) revision = Revision::JF_29;
+    if(type.match("*JF-37")) revision = Revision::JF_37;
+    if(type.match("*JF-40")) revision = Revision::JF_40;
+  }
+
+  auto main() -> void {
+    ss88006.main();
+  }
+
+  auto readPRG(uint addr) -> uint8 {
+    if((addr & 0x8000) == 0x8000) return read(prgrom, ss88006.prgAddress(addr));
+    if((addr & 0xe000) == 0x6000) return ss88006.ramRead(addr);
+    return cpu.mdr();
+  }
+
+  auto writePRG(uint addr, uint8 data) -> void {
+    if((addr & 0x8000) == 0x8000) return ss88006.regWrite(addr, data);
+    if((addr & 0xe000) == 0x6000) return ss88006.ramWrite(addr, data);
+  }
+
+  auto readCHR(uint addr) -> uint8 {
+    if(addr & 0x2000) return ppu.readCIRAM(ss88006.ciramAddress(addr));
+    return Board::readCHR(ss88006.chrAddress(addr));
+  }
+
+  auto writeCHR(uint addr, uint8 data) -> void {
+    if(addr & 0x2000) return ppu.writeCIRAM(ss88006.ciramAddress(addr), data);
+    return Board::writeCHR(ss88006.chrAddress(addr), data);
+  }
+
+  auto power() -> void {
+    ss88006.power();
+  }
+
+  auto reset() -> void {
+    ss88006.reset();
+  }
+
+  auto serialize(serializer& s) -> void {
+    Board::serialize(s);
+    ss88006.serialize(s);
+  }
+
+  enum class Revision : uint {
+    JF_23,
+    JF_24,
+    JF_25,
+    JF_27,
+    JF_29,
+    JF_37,
+    JF_40,
+  } revision;
+
+  SS88006 ss88006;
+};
diff --git a/higan/higan/fc/cartridge/board/konami-vrc1.cpp b/nSide/higan/fc/cartridge/board/konami-vrc1.cpp
index 7c2a416..82c22b6 100644
--- a/higan/higan/fc/cartridge/board/konami-vrc1.cpp
+++ b/nSide/higan/fc/cartridge/board/konami-vrc1.cpp
@@ -1,24 +1,24 @@
 struct KonamiVRC1 : Board {
-  KonamiVRC1(Markup::Node& document) : Board(document), vrc1(*this) {
+  KonamiVRC1(Markup::Node& boardNode) : Board(boardNode), vrc1(*this) {
   }
 
   auto readPRG(uint addr) -> uint8 {
-    if(addr & 0x8000) return prgrom.read(vrc1.addrPRG(addr));
+    if(addr & 0x8000) return read(prgrom, vrc1.prgAddress(addr));
     return cpu.mdr();
   }
 
   auto writePRG(uint addr, uint8 data) -> void {
-    if(addr & 0x8000) return vrc1.writeIO(addr, data);
+    if(addr & 0x8000) return vrc1.regWrite(addr, data);
   }
 
   auto readCHR(uint addr) -> uint8 {
-    if(addr & 0x2000) return ppu.readCIRAM(vrc1.addrCIRAM(addr));
-    return Board::readCHR(vrc1.addrCHR(addr));
+    if(addr & 0x2000) return ppu.readCIRAM(vrc1.ciramAddress(addr));
+    return Board::readCHR(vrc1.chrAddress(addr));
   }
 
   auto writeCHR(uint addr, uint8 data) -> void {
-    if(addr & 0x2000) return ppu.writeCIRAM(vrc1.addrCIRAM(addr), data);
-    return Board::writeCHR(vrc1.addrCHR(addr), data);
+    if(addr & 0x2000) return ppu.writeCIRAM(vrc1.ciramAddress(addr), data);
+    return Board::writeCHR(vrc1.chrAddress(addr), data);
   }
 
   auto power() -> void {
diff --git a/higan/higan/fc/cartridge/board/konami-vrc2.cpp b/nSide/higan/fc/cartridge/board/konami-vrc2.cpp
index 00952b3..16a953e 100644
--- a/higan/higan/fc/cartridge/board/konami-vrc2.cpp
+++ b/nSide/higan/fc/cartridge/board/konami-vrc2.cpp
@@ -1,34 +1,37 @@
 struct KonamiVRC2 : Board {
-  KonamiVRC2(Markup::Node& document) : Board(document), vrc2(*this) {
-    settings.pinout.a0 = 1 << document["board/chip/pinout/a0"].natural();
-    settings.pinout.a1 = 1 << document["board/chip/pinout/a1"].natural();
+  KonamiVRC2(Markup::Node& boardNode) : Board(boardNode), vrc2(*this) {
+    settings.pinout.a0 = 1 << boardNode["chip/pinout/a0"].natural();
+    settings.pinout.a1 = 1 << boardNode["chip/pinout/a1"].natural();
+    settings.pinout.chrShift = boardNode["chip/pinout/chr-shift"].natural();
   }
 
   auto readPRG(uint addr) -> uint8 {
     if(addr < 0x6000) return cpu.mdr();
-    if(addr < 0x8000) return vrc2.readRAM(addr);
-    return prgrom.read(vrc2.addrPRG(addr));
+    if(addr < 0x8000) return vrc2.ramRead(addr);
+    return read(prgrom, vrc2.prgAddress(addr));
   }
 
   auto writePRG(uint addr, uint8 data) -> void {
     if(addr < 0x6000) return;
-    if(addr < 0x8000) return vrc2.writeRAM(addr, data);
+    if(addr < 0x8000) return vrc2.ramWrite(addr, data);
 
     bool a0 = (addr & settings.pinout.a0);
     bool a1 = (addr & settings.pinout.a1);
     addr &= 0xfff0;
     addr |= (a0 << 0) | (a1 << 1);
-    return vrc2.writeIO(addr, data);
+    return vrc2.regWrite(addr, data);
   }
 
   auto readCHR(uint addr) -> uint8 {
-    if(addr & 0x2000) return ppu.readCIRAM(vrc2.addrCIRAM(addr));
-    return Board::readCHR(vrc2.addrCHR(addr));
+    if(addr & 0x2000) return ppu.readCIRAM(vrc2.ciramAddress(addr));
+    addr = vrc2.chrAddress(addr);
+    addr = ((addr >> settings.pinout.chrShift) & ~0x3ff) | (addr & 0x3ff);
+    return Board::readCHR(addr);
   }
 
   auto writeCHR(uint addr, uint8 data) -> void {
-    if(addr & 0x2000) return ppu.writeCIRAM(vrc2.addrCIRAM(addr), data);
-    return Board::writeCHR(vrc2.addrCHR(addr), data);
+    if(addr & 0x2000) return ppu.writeCIRAM(vrc2.ciramAddress(addr), data);
+    return Board::writeCHR(vrc2.chrAddress(addr), data);
   }
 
   auto power() -> void {
@@ -48,6 +51,7 @@ struct KonamiVRC2 : Board {
     struct Pinout {
       uint a0;
       uint a1;
+      uint chrShift;
     } pinout;
   } settings;
 
diff --git a/higan/higan/fc/cartridge/board/konami-vrc3.cpp b/nSide/higan/fc/cartridge/board/konami-vrc3.cpp
index f71b4a5..677ea2f 100644
--- a/higan/higan/fc/cartridge/board/konami-vrc3.cpp
+++ b/nSide/higan/fc/cartridge/board/konami-vrc3.cpp
@@ -1,6 +1,6 @@
 struct KonamiVRC3 : Board {
-  KonamiVRC3(Markup::Node& document) : Board(document), vrc3(*this) {
-    settings.mirror = document["board/mirror/mode"].text() == "vertical" ? 1 : 0;
+  KonamiVRC3(Markup::Node& boardNode) : Board(boardNode), vrc3(*this) {
+    settings.mirror = boardNode["mirror/mode"].text() == "vertical" ? 1 : 0;
   }
 
   auto main() -> void {
@@ -8,30 +8,30 @@ struct KonamiVRC3 : Board {
   }
 
   auto readPRG(uint addr) -> uint8 {
-    if((addr & 0xe000) == 0x6000) return prgram.read(addr & 0x1fff);
-    if(addr & 0x8000) return prgrom.read(vrc3.addrPRG(addr));
+    if((addr & 0xe000) == 0x6000) return read(prgram, addr & 0x1fff);
+    if(addr & 0x8000) return read(prgrom, vrc3.prgAddress(addr));
     return cpu.mdr();
   }
 
   auto writePRG(uint addr, uint8 data) -> void {
-    if((addr & 0xe000) == 0x6000) return prgram.write(addr & 0x1fff, data);
-    if(addr & 0x8000) return vrc3.writeIO(addr, data);
+    if((addr & 0xe000) == 0x6000) return write(prgram, addr & 0x1fff, data);
+    if(addr & 0x8000) return vrc3.regWrite(addr, data);
   }
 
   auto readCHR(uint addr) -> uint8 {
     if(addr & 0x2000) {
       if(settings.mirror == 0) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
-      return ppu.readCIRAM(addr & 0x07ff);
+      return ppu.readCIRAM(addr);
     }
-    return chrram.read(addr);
+    return Board::readCHR(addr);
   }
 
   auto writeCHR(uint addr, uint8 data) -> void {
     if(addr & 0x2000) {
       if(settings.mirror == 0) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
-      return ppu.writeCIRAM(addr & 0x07ff, data);
+      return ppu.writeCIRAM(addr, data);
     }
-    return chrram.write(addr, data);
+    return Board::writeCHR(addr, data);
   }
 
   auto power() -> void {
diff --git a/higan/higan/fc/cartridge/board/konami-vrc4.cpp b/nSide/higan/fc/cartridge/board/konami-vrc4.cpp
index a8b9f3f..f6ef8d6 100644
--- a/higan/higan/fc/cartridge/board/konami-vrc4.cpp
+++ b/nSide/higan/fc/cartridge/board/konami-vrc4.cpp
@@ -1,7 +1,7 @@
 struct KonamiVRC4 : Board {
-  KonamiVRC4(Markup::Node& document) : Board(document), vrc4(*this) {
-    settings.pinout.a0 = 1 << document["board/chip/pinout/a0"].natural();
-    settings.pinout.a1 = 1 << document["board/chip/pinout/a1"].natural();
+  KonamiVRC4(Markup::Node& boardNode) : Board(boardNode), vrc4(*this) {
+    settings.pinout.a0 = 1 << boardNode["chip/pinout/a0"].natural();
+    settings.pinout.a1 = 1 << boardNode["chip/pinout/a1"].natural();
   }
 
   auto main() -> void {
@@ -10,29 +10,29 @@ struct KonamiVRC4 : Board {
 
   auto readPRG(uint addr) -> uint8 {
     if(addr < 0x6000) return cpu.mdr();
-    if(addr < 0x8000) return prgram.read(addr);
-    return prgrom.read(vrc4.addrPRG(addr));
+    if(addr < 0x8000) return read(prgram, addr);
+    return read(prgrom, vrc4.prgAddress(addr));
   }
 
   auto writePRG(uint addr, uint8 data) -> void {
     if(addr < 0x6000) return;
-    if(addr < 0x8000) return prgram.write(addr, data);
+    if(addr < 0x8000) return write(prgram, addr, data);
 
     bool a0 = (addr & settings.pinout.a0);
     bool a1 = (addr & settings.pinout.a1);
-    addr &= 0xfff0;
+    addr &= 0xff00;
     addr |= (a1 << 1) | (a0 << 0);
-    return vrc4.writeIO(addr, data);
+    return vrc4.regWrite(addr, data);
   }
 
   auto readCHR(uint addr) -> uint8 {
-    if(addr & 0x2000) return ppu.readCIRAM(vrc4.addrCIRAM(addr));
-    return Board::readCHR(vrc4.addrCHR(addr));
+    if(addr & 0x2000) return ppu.readCIRAM(vrc4.ciramAddress(addr));
+    return Board::readCHR(vrc4.chrAddress(addr));
   }
 
   auto writeCHR(uint addr, uint8 data) -> void {
-    if(addr & 0x2000) return ppu.writeCIRAM(vrc4.addrCIRAM(addr), data);
-    return Board::writeCHR(vrc4.addrCHR(addr), data);
+    if(addr & 0x2000) return ppu.writeCIRAM(vrc4.ciramAddress(addr), data);
+    return Board::writeCHR(vrc4.chrAddress(addr), data);
   }
 
   auto power() -> void {
diff --git a/higan/higan/fc/cartridge/board/konami-vrc6.cpp b/nSide/higan/fc/cartridge/board/konami-vrc6.cpp
index 00a7d6b..de3fe85 100644
--- a/higan/higan/fc/cartridge/board/konami-vrc6.cpp
+++ b/nSide/higan/fc/cartridge/board/konami-vrc6.cpp
@@ -1,30 +1,34 @@
 struct KonamiVRC6 : Board {
-  KonamiVRC6(Markup::Node& document) : Board(document), vrc6(*this) {
+  KonamiVRC6(Markup::Node& boardNode) : Board(boardNode), vrc6(*this) {
+    settings.pinout.a0 = 1 << boardNode["chip/pinout/a0"].natural();
+    settings.pinout.a1 = 1 << boardNode["chip/pinout/a1"].natural();
   }
 
-  auto readPRG(uint addr) -> uint8{
-    if((addr & 0xe000) == 0x6000) return vrc6.readRAM(addr);
-    if(addr & 0x8000) return prgrom.read(vrc6.addrPRG(addr));
-    return cpu.mdr();
+  auto readPRG(uint addr) -> uint8 {
+    if(addr < 0x6000) return cpu.mdr();
+    if(addr < 0x8000) return vrc6.ramRead(addr);
+    return read(prgrom, vrc6.prgAddress(addr));
   }
 
   auto writePRG(uint addr, uint8 data) -> void {
-    if((addr & 0xe000) == 0x6000) return vrc6.writeRAM(addr, data);
-    if(addr & 0x8000) {
-      addr = (addr & 0xf003);
-      if(prgram.size) addr = (addr & ~3) | ((addr & 2) >> 1) | ((addr & 1) << 1);
-      return vrc6.writeIO(addr, data);
-    }
+    if(addr < 0x6000) return;
+    if(addr < 0x8000) return vrc6.ramWrite(addr, data);
+
+    bool a0 = (addr & settings.pinout.a0);
+    bool a1 = (addr & settings.pinout.a1);
+    addr &= 0xf000;
+    addr |= (a1 << 1) | (a0 << 0);
+    return vrc6.regWrite(addr, data);
   }
 
   auto readCHR(uint addr) -> uint8 {
-    if(addr & 0x2000) return ppu.readCIRAM(vrc6.addrCIRAM(addr));
-    return Board::readCHR(vrc6.addrCHR(addr));
+    if(addr & 0x2000) return ppu.readCIRAM(vrc6.ciramAddress(addr));
+    return Board::readCHR(vrc6.chrAddress(addr));
   }
 
   auto writeCHR(uint addr, uint8 data) -> void {
-    if(addr & 0x2000) return ppu.writeCIRAM(vrc6.addrCIRAM(addr), data);
-    return Board::writeCHR(vrc6.addrCHR(addr), data);
+    if(addr & 0x2000) return ppu.writeCIRAM(vrc6.ciramAddress(addr), data);
+    return Board::writeCHR(vrc6.chrAddress(addr), data);
   }
 
   auto serialize(serializer& s) -> void {
@@ -36,5 +40,12 @@ struct KonamiVRC6 : Board {
   auto power() -> void { vrc6.power(); }
   auto reset() -> void { vrc6.reset(); }
 
+  struct Settings {
+    struct Pinout {
+      uint a0;
+      uint a1;
+    } pinout;
+  } settings;
+
   VRC6 vrc6;
 };
diff --git a/higan/higan/fc/cartridge/board/konami-vrc7.cpp b/nSide/higan/fc/cartridge/board/konami-vrc7.cpp
index 1f706c0..e268827 100644
--- a/higan/higan/fc/cartridge/board/konami-vrc7.cpp
+++ b/nSide/higan/fc/cartridge/board/konami-vrc7.cpp
@@ -1,39 +1,34 @@
 struct KonamiVRC7 : Board {
-  KonamiVRC7(Markup::Node& document) : Board(document), vrc7(*this) {
-  }
-
-  auto main() -> void {
-    return vrc7.main();
+  KonamiVRC7(Markup::Node& boardNode) : Board(boardNode), vrc7(*this) {
+    settings.pinout.a0 = 1 << boardNode["chip/pinout/a0"].natural();
+    settings.pinout.a1 = 1 << boardNode["chip/pinout/a1"].natural();
   }
 
   auto readPRG(uint addr) -> uint8 {
     if(addr < 0x6000) return cpu.mdr();
-    if(addr < 0x8000) return prgram.read(addr);
-    return prgrom.read(vrc7.addrPRG(addr));
+    if(addr < 0x8000) return read(prgram, addr);
+    return read(prgrom, vrc7.prgAddress(addr));
   }
 
   auto writePRG(uint addr, uint8 data) -> void {
     if(addr < 0x6000) return;
-    if(addr < 0x8000) return prgram.write(addr, data);
-    return vrc7.writeIO(addr, data);
+    if(addr < 0x8000) return write(prgram, addr, data);
+
+    bool a0 = (addr & settings.pinout.a0);
+    bool a1 = (addr & settings.pinout.a1);
+    addr &= 0xf000;
+    addr |= (a1 << 1) | (a0 << 0);
+    return vrc7.regWrite(addr, data);
   }
 
   auto readCHR(uint addr) -> uint8 {
-    if(addr & 0x2000) return ppu.readCIRAM(vrc7.addrCIRAM(addr));
-    return chrram.read(vrc7.addrCHR(addr));
+    if(addr & 0x2000) return ppu.readCIRAM(vrc7.ciramAddress(addr));
+    return Board::readCHR(vrc7.chrAddress(addr));
   }
 
   auto writeCHR(uint addr, uint8 data) -> void {
-    if(addr & 0x2000) return ppu.writeCIRAM(vrc7.addrCIRAM(addr), data);
-    return chrram.write(vrc7.addrCHR(addr), data);
-  }
-
-  auto power() -> void {
-    vrc7.power();
-  }
-
-  auto reset() -> void {
-    vrc7.reset();
+    if(addr & 0x2000) return ppu.writeCIRAM(vrc7.ciramAddress(addr), data);
+    return Board::writeCHR(vrc7.chrAddress(addr), data);
   }
 
   auto serialize(serializer& s) -> void {
@@ -41,5 +36,16 @@ struct KonamiVRC7 : Board {
     vrc7.serialize(s);
   }
 
+  auto main() -> void { vrc7.main(); }
+  auto power() -> void { vrc7.power(); }
+  auto reset() -> void { vrc7.reset(); }
+
+  struct Settings {
+    struct Pinout {
+      uint a0;
+      uint a1;
+    } pinout;
+  } settings;
+
   VRC7 vrc7;
 };
diff --git a/nSide/higan/fc/cartridge/board/namco-163.cpp b/nSide/higan/fc/cartridge/board/namco-163.cpp
new file mode 100644
index 0000000..05e2e2e
--- /dev/null
+++ b/nSide/higan/fc/cartridge/board/namco-163.cpp
@@ -0,0 +1,40 @@
+struct Namco163 : Board {
+  Namco163(Markup::Node& boardNode) : Board(boardNode), n163(*this, boardNode) {
+    chip = &n163;
+  }
+
+  auto main() -> void {
+    n163.main();
+  }
+
+  auto readPRG(uint addr) -> uint8 {
+    n163.readPRG(addr);
+  }
+
+  auto writePRG(uint addr, uint8 data) -> void {
+    n163.writePRG(addr, data);
+  }
+
+  auto readCHR(uint addr) -> uint8 {
+    n163.readCHR(addr);
+  }
+
+  auto writeCHR(uint addr, uint8 data) -> void {
+    n163.writeCHR(addr, data);
+  }
+
+  auto serialize(serializer& s) -> void {
+    Board::serialize(s);
+    n163.serialize(s);
+  }
+
+  auto power() -> void {
+    n163.power();
+  }
+
+  auto reset() -> void {
+    n163.reset();
+  }
+
+  N163 n163;
+};
diff --git a/nSide/higan/fc/cartridge/board/namco-34xx.cpp b/nSide/higan/fc/cartridge/board/namco-34xx.cpp
new file mode 100644
index 0000000..372b784
--- /dev/null
+++ b/nSide/higan/fc/cartridge/board/namco-34xx.cpp
@@ -0,0 +1,148 @@
+//NAMCOT-3401 (bankswitching used even if PRG is 32KB - バベルの塔/Tower of Babel)
+//NAMCOT-3406
+//NAMCOT-3407
+//NAMCOT-3413
+//NAMCOT-3414
+//NAMCOT-3415
+//NAMCOT-3416
+//NAMCOT-3417
+//NAMCOT-3425
+//NAMCOT-3443
+//NAMCOT-3446
+//NAMCOT-3451
+//NAMCOT-3453
+//NES-DEROM
+//NES-DE1ROM
+//NES-DRROM
+
+struct Namco34xx : Board {
+  Namco34xx(Markup::Node& boardNode) : Board(boardNode), n108(*this, boardNode) {
+    string type = boardNode["id"].text();
+    if(type.match("*3401")) revision = Revision::Namco3401;
+    if(type.match("*3406")) revision = Revision::Namco3406;
+    if(type.match("*3407")) revision = Revision::Namco3407;
+    if(type.match("*3413")) revision = Revision::Namco3413;
+    if(type.match("*3414")) revision = Revision::Namco3414;
+    if(type.match("*3415")) revision = Revision::Namco3415;
+    if(type.match("*3416")) revision = Revision::Namco3416;
+    if(type.match("*3417")) revision = Revision::Namco3417;
+    if(type.match("*3425")) revision = Revision::Namco3425;
+    if(type.match("*3443")) revision = Revision::Namco3443;
+    if(type.match("*3446")) revision = Revision::Namco3446;
+    if(type.match("*3451")) revision = Revision::Namco3451;
+    if(type.match("*3453")) revision = Revision::Namco3453;
+    if(type.match("*DEROM")) revision = Revision::DEROM;
+    if(type.match("*DE1ROM")) revision = Revision::DE1ROM;
+    if(type.match("*DRROM")) revision = Revision::DRROM;
+    if(type == "TENGEN-800002") revision = Revision::DEROM;
+    if(type == "TENGEN-800030") revision = Revision::DE1ROM;
+    if(type == "TENGEN-800004") revision = Revision::DRROM;
+
+    if(revision != Revision::Namco3425 && revision != Revision::Namco3453)
+      settings.mirror = boardNode["mirror/mode"].text() == "horizontal";
+  }
+
+  auto prgAddress(uint addr) -> uint {
+    if(revision == Revision::Namco3401 || prgrom.size() > 0x8000) return n108.prgAddress(addr);
+    else return addr & 0x7fff;
+  }
+
+  auto readPRG(uint addr) -> uint8 {
+    if(addr & 0x8000) return read(prgrom, prgAddress(addr));
+    return cpu.mdr();
+  }
+
+  auto writePRG(uint addr, uint8 data) -> void {
+    if(addr & 0x8000) {
+      n108.regWrite(addr, data);
+      if(revision == Revision::Namco3453) nametable = data & 0x40;
+    }
+  }
+
+  auto chrAddress(uint addr) -> uint {
+    switch(revision) {
+    case Revision::Namco3443:
+    case Revision::Namco3453:
+      return n108.chrAddress(addr) | ((addr & 0x1000) << 4);
+    case Revision::Namco3446:
+      if(addr <= 0x07ff) return (n108.chrAddress(0x1000) << 1) | (addr & 0x07ff);
+      if(addr <= 0x0fff) return (n108.chrAddress(0x1400) << 1) | (addr & 0x07ff);
+      if(addr <= 0x17ff) return (n108.chrAddress(0x1800) << 1) | (addr & 0x07ff);
+      if(addr <= 0x1fff) return (n108.chrAddress(0x1c00) << 1) | (addr & 0x07ff);
+    default:
+      return n108.chrAddress(addr);
+    }
+  }
+
+  auto readCHR(uint addr) -> uint8 {
+    if(revision == Revision::DRROM) {
+      if(addr & 0x2000) {
+        if(!(addr & 0x0800)) return ppu.readCIRAM(addr & 0x07ff);
+        else                 return read(chrram, addr & 0x07ff);
+      }
+      return read(chrrom, n108.chrAddress(addr));
+    }
+    if(addr & 0x2000) return ppu.readCIRAM(ciramAddress(addr));
+    return Board::readCHR(chrAddress(addr));
+  }
+
+  auto writeCHR(uint addr, uint8 data) -> void {
+    if(revision == Revision::DRROM) {
+      if(addr & 0x2000) {
+        if(!(addr & 0x0800)) ppu.writeCIRAM(addr & 0x07ff, data);
+        else                 write(chrram, addr & 0x07ff, data);
+      }
+      return;
+    }
+    if(addr & 0x2000) return ppu.writeCIRAM(ciramAddress(addr), data);
+    return Board::writeCHR(chrAddress(addr), data);
+  }
+
+  auto ciramAddress(uint addr) const -> uint {
+    switch(revision) {
+    default:
+      if(settings.mirror == 0) return ((addr & 0x0400) >> 0) | (addr & 0x03ff);
+      if(settings.mirror == 1) return ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    case Revision::Namco3425:
+      return ((n108.chrAddress(addr & 0x1fff) & 0x8000) >> 5) | (addr & 0x03ff);
+    case Revision::Namco3453:
+      return (addr & 0x03ff) | (nametable ? 0x0400 : 0x0000);
+    }
+  }
+
+  auto reset() -> void {
+    nametable = 0;
+  }
+
+  auto serialize(serializer& s) -> void {
+    Board::serialize(s);
+    if(revision == Revision::Namco3453) s.integer(nametable);
+  }
+
+  enum class Revision : uint {
+    Namco3401,
+    Namco3406,
+    Namco3407,
+    Namco3413,
+    Namco3414,
+    Namco3415,
+    Namco3416,
+    Namco3417,
+    Namco3425,
+    Namco3443,
+    Namco3446,
+    Namco3451,
+    Namco3453,
+    DEROM,
+    DE1ROM,
+    DRROM,
+  } revision;
+
+  struct Settings {
+    bool mirror;  //0 = vertical, 1 = horizontal
+  } settings;
+
+  N108 n108;
+
+  bool nametable; // for Namco3453, used only by Devil Man
+};
diff --git a/nSide/higan/fc/cartridge/board/nes-event.cpp b/nSide/higan/fc/cartridge/board/nes-event.cpp
new file mode 100644
index 0000000..b939fae
--- /dev/null
+++ b/nSide/higan/fc/cartridge/board/nes-event.cpp
@@ -0,0 +1,101 @@
+struct NES_Event : Board {
+  NES_Event(Markup::Node& boardNode) : Board(boardNode), mmc1(*this, boardNode) {
+    dip = interface->dipSettings(BML::unserialize({
+      "setting name=Time\n",
+      "  option value=4 name=6:14.96\n",
+      "  option value=0 name=4:59.97\n",
+      "  option value=1 name=5:18.71\n",
+      "  option value=2 name=5:37.46\n",
+      "  option value=3 name=5:56.21\n",
+      "  option value=5 name=6:33.71\n",
+      "  option value=6 name=6:52.45\n",
+      "  option value=7 name=7:11.20\n",
+      "  option value=8 name=7:29.95\n",
+      "  option value=9 name=7:48.70\n",
+      "  option value=10 name=8:07.44\n",
+      "  option value=11 name=8:26.19\n",
+      "  option value=12 name=8:44.94\n",
+      "  option value=13 name=9:03.69\n",
+      "  option value=14 name=9:22.44\n",
+      "  option value=15 name=9:41.18\n",
+    }));
+  }
+
+  auto main() -> void {
+    switch(prgLock) {
+    case 0: if((mmc1.chrBank[0] & 0x10) == 0x10) prgLock++; break;
+    case 1: if((mmc1.chrBank[0] & 0x10) == 0x00) prgLock++; break;
+    case 2:
+      if((mmc1.chrBank[0] & 0x10) == 0x00) irqCounter++;
+      if((mmc1.chrBank[0] & 0x10) == 0x10) {
+        irqCounter = 0x00000000;
+        cpu.irqLine(0);
+      }
+      break;
+    }
+    if(irqCounter == (0x20000000 | (dip << 25))) cpu.irqLine(1);
+    mmc1.main();
+  }
+
+  auto prgAddress(uint addr) -> uint {
+    if(prgLock < 2) return addr & 0x7fff;
+    switch(mmc1.chrBank[0] & 0x08) {
+    case 0: return ((mmc1.chrBank[0] & 0x06) << 14) | (addr & 0x7fff);
+    case 8: return mmc1.prgAddress(addr) | 0x20000;
+    }
+  }
+
+  auto readPRG(uint addr) -> uint8 {
+    if((addr & 0xe000) == 0x6000) {
+      if(mmc1.ramDisable) return 0x00;
+      if(prgram.size() > 0) return read(prgram, addr);
+    }
+
+    if(addr & 0x8000) {
+      return read(prgrom, prgAddress(addr));
+    }
+
+    return cpu.mdr();
+  }
+
+  auto writePRG(uint addr, uint8 data) -> void {
+    if((addr & 0xe000) == 0x6000) {
+      if(mmc1.ramDisable) return;
+      if(prgram.size() > 0) return write(prgram, addr, data);
+    }
+
+    if(addr & 0x8000) return mmc1.mmioWrite(addr, data);
+  }
+
+  auto readCHR(uint addr) -> uint8 {
+    if(addr & 0x2000) return ppu.readCIRAM(mmc1.ciramAddress(addr));
+    return Board::readCHR(addr);
+  }
+
+  auto writeCHR(uint addr, uint8 data) -> void {
+    if(addr & 0x2000) return ppu.writeCIRAM(mmc1.ciramAddress(addr), data);
+    return Board::writeCHR(addr, data);
+  }
+
+  auto power() -> void {
+    mmc1.power();
+  }
+
+  auto reset() -> void {
+    mmc1.reset();
+    prgLock = 0;
+    irqCounter = 0x00000000;
+  }
+
+  auto serialize(serializer& s) -> void {
+    Board::serialize(s);
+    mmc1.serialize(s);
+    s.integer(prgLock);
+    s.integer(irqCounter);
+  }
+
+  MMC1 mmc1;
+  uint2 prgLock;
+  uint30 irqCounter;
+  uint4 dip;
+};
diff --git a/higan/higan/fc/cartridge/board/nes-hkrom.cpp b/nSide/higan/fc/cartridge/board/nes-hkrom.cpp
index 35c1ac1..4275e7e 100644
--- a/higan/higan/fc/cartridge/board/nes-hkrom.cpp
+++ b/nSide/higan/fc/cartridge/board/nes-hkrom.cpp
@@ -1,5 +1,5 @@
 struct NES_HKROM : Board {
-  NES_HKROM(Markup::Node& document) : Board(document), mmc6(*this) {
+  NES_HKROM(Markup::Node& boardNode) : Board(boardNode), mmc6(*this) {
   }
 
   auto main() -> void {
@@ -7,26 +7,26 @@ struct NES_HKROM : Board {
   }
 
   auto readPRG(uint addr) -> uint8 {
-    if((addr & 0xf000) == 0x7000) return mmc6.readRAM(addr);
-    if(addr & 0x8000) return prgrom.read(mmc6.addrPRG(addr));
+    if((addr & 0xf000) == 0x7000) return mmc6.ramRead(addr);
+    if(addr & 0x8000) return read(prgrom, mmc6.prgAddress(addr));
     return cpu.mdr();
   }
 
   auto writePRG(uint addr, uint8 data) -> void {
-    if((addr & 0xf000) == 0x7000) return mmc6.writeRAM(addr, data);
-    if(addr & 0x8000) return mmc6.writeIO(addr, data);
+    if((addr & 0xf000) == 0x7000) return mmc6.ramWrite(addr, data);
+    if(addr & 0x8000) return mmc6.regWrite(addr, data);
   }
 
   auto readCHR(uint addr) -> uint8 {
     mmc6.irqTest(addr);
-    if(addr & 0x2000) return ppu.readCIRAM(mmc6.addrCIRAM(addr));
-    return Board::readCHR(mmc6.addrCHR(addr));
+    if(addr & 0x2000) return ppu.readCIRAM(mmc6.ciramAddress(addr));
+    return Board::readCHR(mmc6.chrAddress(addr));
   }
 
   auto writeCHR(uint addr, uint8 data) -> void {
     mmc6.irqTest(addr);
-    if(addr & 0x2000) return ppu.writeCIRAM(mmc6.addrCIRAM(addr), data);
-    return Board::writeCHR(mmc6.addrCHR(addr), data);
+    if(addr & 0x2000) return ppu.writeCIRAM(mmc6.ciramAddress(addr), data);
+    return Board::writeCHR(mmc6.chrAddress(addr), data);
   }
 
   auto power() -> void {
diff --git a/higan/higan/fc/cartridge/board/nes-nrom.cpp b/higan/higan/fc/cartridge/board/nes-nrom.cpp
deleted file mode 100644
index c352f9a..0000000
--- a/higan/higan/fc/cartridge/board/nes-nrom.cpp
+++ /dev/null
@@ -1,41 +0,0 @@
-//NES-NROM-128
-//NES-NROM-256
-
-struct NES_NROM : Board {
-  NES_NROM(Markup::Node& document) : Board(document) {
-    settings.mirror = document["board/mirror/mode"].text() == "vertical" ? 1 : 0;
-  }
-
-  auto readPRG(uint addr) -> uint8 {
-    if(addr & 0x8000) return prgrom.read(addr);
-    return cpu.mdr();
-  }
-
-  auto writePRG(uint addr, uint8 data) -> void {
-  }
-
-  auto readCHR(uint addr) -> uint8 {
-    if(addr & 0x2000) {
-      if(settings.mirror == 0) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
-      return ppu.readCIRAM(addr & 0x07ff);
-    }
-    if(chrram.size) return chrram.read(addr);
-    return chrrom.read(addr);
-  }
-
-  auto writeCHR(uint addr, uint8 data) -> void {
-    if(addr & 0x2000) {
-      if(settings.mirror == 0) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
-      return ppu.writeCIRAM(addr & 0x07ff, data);
-    }
-    if(chrram.size) return chrram.write(addr, data);
-  }
-
-  auto serialize(serializer& s) -> void {
-    Board::serialize(s);
-  }
-
-  struct Settings {
-    bool mirror;  //0 = horizontal, 1 = vertical
-  } settings;
-};
diff --git a/nSide/higan/fc/cartridge/board/nes-qj.cpp b/nSide/higan/fc/cartridge/board/nes-qj.cpp
new file mode 100644
index 0000000..3f4901a
--- /dev/null
+++ b/nSide/higan/fc/cartridge/board/nes-qj.cpp
@@ -0,0 +1,55 @@
+struct NES_QJ : Board {
+  NES_QJ(Markup::Node& boardNode) : Board(boardNode), mmc3(*this, boardNode) {
+  }
+
+  auto main() -> void {
+    mmc3.main();
+  }
+
+  auto readPRG(uint addr) -> uint8 {
+    if(addr & 0x8000) {
+      addr = (mmc3.prgAddress(addr) & 0x1ffff) | (bank << 17);
+      return read(prgrom, addr);
+    }
+    return cpu.mdr();
+  }
+
+  auto writePRG(uint addr, uint8 data) -> void {
+    if((addr & 0xe000) == 0x6000 && mmc3.ramEnable && !mmc3.ramWriteProtect) {
+      bank = data & 0x01;
+    }
+    if(addr & 0x8000) return mmc3.regWrite(addr, data);
+  }
+
+  auto readCHR(uint addr) -> uint8 {
+    if(addr & 0x2000) return ppu.readCIRAM(mmc3.ciramAddress(addr));
+    return Board::readCHR((mmc3.chrAddress(addr) & 0x1ffff) | (bank << 17));
+  }
+
+  auto writeCHR(uint addr, uint8 data) -> void {
+    if(addr & 0x2000) return ppu.writeCIRAM(mmc3.ciramAddress(addr), data);
+    return Board::writeCHR((mmc3.chrAddress(addr) & 0x1ffff) | (bank << 17), data);
+  }
+
+  auto ciramAddress(uint addr) -> uint {
+    return mmc3.ciramAddress(addr);
+  }
+
+  auto power() -> void {
+    mmc3.power();
+  }
+
+  auto reset() -> void {
+    mmc3.reset();
+    bank = 0;
+  }
+
+  auto serialize(serializer& s) -> void {
+    Board::serialize(s);
+    mmc3.serialize(s);
+    s.integer(bank);
+  }
+
+  MMC3 mmc3;
+  bool bank;
+};
diff --git a/higan/higan/fc/cartridge/board/nes-sxrom.cpp b/higan/higan/fc/cartridge/board/nes-sxrom.cpp
deleted file mode 100644
index 85ca378..0000000
--- a/higan/higan/fc/cartridge/board/nes-sxrom.cpp
+++ /dev/null
@@ -1,99 +0,0 @@
-struct NES_SxROM : Board {
-  NES_SxROM(Markup::Node& document) : Board(document), mmc1(*this) {
-    revision = Revision::SXROM;
-  }
-
-  auto main() -> void {
-    return mmc1.main();
-  }
-
-  auto addrRAM(uint addr) -> uint {
-    uint bank = 0;
-    if(revision == Revision::SOROM) bank = (mmc1.chrBank[0] & 0x08) >> 3;
-    if(revision == Revision::SUROM) bank = (mmc1.chrBank[0] & 0x0c) >> 2;
-    if(revision == Revision::SXROM) bank = (mmc1.chrBank[0] & 0x0c) >> 2;
-    return (bank << 13) | (addr & 0x1fff);
-  }
-
-  auto readPRG(uint addr) -> uint8 {
-    if((addr & 0xe000) == 0x6000) {
-      if(revision == Revision::SNROM) {
-        if(mmc1.chrBank[0] & 0x10) return cpu.mdr();
-      }
-      if(mmc1.ramDisable) return 0x00;
-      return prgram.read(addrRAM(addr));
-    }
-
-    if(addr & 0x8000) {
-      addr = mmc1.addrPRG(addr);
-      if(revision == Revision::SXROM) {
-        addr |= ((mmc1.chrBank[0] & 0x10) >> 4) << 18;
-      }
-      return prgrom.read(addr);
-    }
-
-    return cpu.mdr();
-  }
-
-  auto writePRG(uint addr, uint8 data) -> void {
-    if((addr & 0xe000) == 0x6000) {
-      if(revision == Revision::SNROM) {
-        if(mmc1.chrBank[0] & 0x10) return;
-      }
-      if(mmc1.ramDisable) return;
-      return prgram.write(addrRAM(addr), data);
-    }
-
-    if(addr & 0x8000) return mmc1.writeIO(addr, data);
-  }
-
-  auto readCHR(uint addr) -> uint8 {
-    if(addr & 0x2000) return ppu.readCIRAM(mmc1.addrCIRAM(addr));
-    return Board::readCHR(mmc1.addrCHR(addr));
-  }
-
-  auto writeCHR(uint addr, uint8 data) -> void {
-    if(addr & 0x2000) return ppu.writeCIRAM(mmc1.addrCIRAM(addr), data);
-    return Board::writeCHR(mmc1.addrCHR(addr), data);
-  }
-
-  auto power() -> void {
-    mmc1.power();
-  }
-
-  auto reset() -> void {
-    mmc1.reset();
-  }
-
-  auto serialize(serializer& s) -> void {
-    Board::serialize(s);
-    mmc1.serialize(s);
-  }
-
-  enum class Revision : uint {
-    SAROM,
-    SBROM,
-    SCROM,
-    SC1ROM,
-    SEROM,
-    SFROM,
-    SGROM,
-    SHROM,
-    SH1ROM,
-    SIROM,
-    SJROM,
-    SKROM,
-    SLROM,
-    SL1ROM,
-    SL2ROM,
-    SL3ROM,
-    SLRROM,
-    SMROM,
-    SNROM,
-    SOROM,
-    SUROM,
-    SXROM,
-  } revision;
-
-  MMC1 mmc1;
-};
diff --git a/higan/higan/fc/cartridge/board/nes-txrom.cpp b/higan/higan/fc/cartridge/board/nes-txrom.cpp
deleted file mode 100644
index c3d8125..0000000
--- a/higan/higan/fc/cartridge/board/nes-txrom.cpp
+++ /dev/null
@@ -1,65 +0,0 @@
-struct NES_TxROM : Board {
-  NES_TxROM(Markup::Node& document) : Board(document), mmc3(*this) {
-    revision = Revision::TLROM;
-  }
-
-  auto main() -> void {
-    mmc3.main();
-  }
-
-  auto readPRG(uint addr) -> uint8 {
-    if((addr & 0xe000) == 0x6000) return mmc3.readRAM(addr);
-    if(addr & 0x8000) return prgrom.read(mmc3.addrPRG(addr));
-    return cpu.mdr();
-  }
-
-  auto writePRG(uint addr, uint8 data) -> void {
-    if((addr & 0xe000) == 0x6000) return mmc3.writeRAM(addr, data);
-    if(addr & 0x8000) return mmc3.writeIO(addr, data);
-  }
-
-  auto readCHR(uint addr) -> uint8 {
-    mmc3.irqTest(addr);
-    if(addr & 0x2000) return ppu.readCIRAM(mmc3.addrCIRAM(addr));
-    return Board::readCHR(mmc3.addrCHR(addr));
-  }
-
-  auto writeCHR(uint addr, uint8 data) -> void {
-    mmc3.irqTest(addr);
-    if(addr & 0x2000) return ppu.writeCIRAM(mmc3.addrCIRAM(addr), data);
-    return Board::writeCHR(mmc3.addrCHR(addr), data);
-  }
-
-  auto power() -> void {
-    mmc3.power();
-  }
-
-  auto reset() -> void {
-    mmc3.reset();
-  }
-
-  auto serialize(serializer& s) -> void {
-    Board::serialize(s);
-    mmc3.serialize(s);
-  }
-
-  enum class Revision : uint {
-    TBROM,
-    TEROM,
-    TFROM,
-    TGROM,
-    TKROM,
-    TKSROM,
-    TLROM,
-    TL1ROM,
-    TL2ROM,
-    TLSROM,
-    TNROM,
-    TQROM,
-    TR1ROM,
-    TSROM,
-    TVROM,
-  } revision;
-
-  MMC3 mmc3;
-};
diff --git a/higan/higan/fc/cartridge/board/nes-uxrom.cpp b/higan/higan/fc/cartridge/board/nes-uxrom.cpp
deleted file mode 100644
index ff4f542..0000000
--- a/higan/higan/fc/cartridge/board/nes-uxrom.cpp
+++ /dev/null
@@ -1,53 +0,0 @@
-//NES-UNROM
-//NES-UOROM
-
-struct NES_UxROM : Board {
-  NES_UxROM(Markup::Node& document) : Board(document) {
-    settings.mirror = document["board/mirror/mode"].text() == "vertical" ? 1 : 0;
-  }
-
-  auto readPRG(uint addr) -> uint8 {
-    if((addr & 0xc000) == 0x8000) return prgrom.read((prgBank << 14) | (addr & 0x3fff));
-    if((addr & 0xc000) == 0xc000) return prgrom.read((   0x0f << 14) | (addr & 0x3fff));
-    return cpu.mdr();
-  }
-
-  auto writePRG(uint addr, uint8 data) -> void {
-    if(addr & 0x8000) prgBank = data & 0x0f;
-  }
-
-  auto readCHR(uint addr) -> uint8 {
-    if(addr & 0x2000) {
-      if(settings.mirror == 0) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
-      return ppu.readCIRAM(addr);
-    }
-    return Board::readCHR(addr);
-  }
-
-  auto writeCHR(uint addr, uint8 data) -> void {
-    if(addr & 0x2000) {
-      if(settings.mirror == 0) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
-      return ppu.writeCIRAM(addr, data);
-    }
-    return Board::writeCHR(addr, data);
-  }
-
-  auto power() -> void {
-  }
-
-  auto reset() -> void {
-    prgBank = 0;
-  }
-
-  auto serialize(serializer& s) -> void {
-    Board::serialize(s);
-
-    s.integer(prgBank);
-  }
-
-  struct Settings {
-    bool mirror;  //0 = horizontal, 1 = vertical
-  } settings;
-
-  uint4 prgBank;
-};
diff --git a/nSide/higan/fc/cartridge/board/pal-zz.cpp b/nSide/higan/fc/cartridge/board/pal-zz.cpp
new file mode 100644
index 0000000..e3efb21
--- /dev/null
+++ b/nSide/higan/fc/cartridge/board/pal-zz.cpp
@@ -0,0 +1,67 @@
+struct PAL_ZZ : Board {
+  PAL_ZZ(Markup::Node& boardNode) : Board(boardNode), mmc3(*this, boardNode) {
+  }
+
+  auto main() -> void {
+    mmc3.main();
+  }
+
+  auto readPRG(uint addr) -> uint8 {
+    if(addr & 0x8000) {
+      addr = (mmc3.prgAddress(addr) & (0xffff | (bank << 16))) | (bank << 17);
+      addr |= (prgA16Force == 0x03) << 16;
+      return read(prgrom, addr);
+    }
+    return cpu.mdr();
+  }
+
+  auto writePRG(uint addr, uint8 data) -> void {
+    if((addr & 0xe000) == 0x6000 && mmc3.ramEnable && !mmc3.ramWriteProtect) {
+      prgA16Force = data & 0x03;
+      bank = data & 0x04;
+    }
+    if(addr & 0x8000) return mmc3.regWrite(addr, data);
+  }
+
+  auto readCHR(uint addr) -> uint8 {
+    if(addr & 0x2000) return ppu.readCIRAM(mmc3.ciramAddress(addr));
+    return Board::readCHR((mmc3.chrAddress(addr) & 0x1ffff) | (bank << 17));
+  }
+
+  auto writeCHR(uint addr, uint8 data) -> void {
+    if(addr & 0x2000) return ppu.writeCIRAM(mmc3.ciramAddress(addr), data);
+    return Board::writeCHR((mmc3.chrAddress(addr) & 0x1ffff) | (bank << 17), data);
+  }
+
+  auto ciramAddress(uint addr) -> uint {
+    return mmc3.ciramAddress(addr);
+  }
+
+  auto power() -> void {
+    mmc3.power();
+  }
+
+  auto reset() -> void {
+    mmc3.reset();
+    cicReset();
+  }
+
+  auto cicReset() -> void {
+    // this register is cleared by the CIC reset line.
+    // On a Famicom or toploader, only a power cycle can clear it.
+    //TODO: Check if Europe got the toploader.
+    prgA16Force = 0;
+    bank = 0;
+  }
+
+  auto serialize(serializer& s) -> void {
+    Board::serialize(s);
+    mmc3.serialize(s);
+    s.integer(prgA16Force);
+    s.integer(bank);
+  }
+
+  MMC3 mmc3;
+  uint2 prgA16Force;
+  bool bank;
+};
diff --git a/nSide/higan/fc/cartridge/board/sunsoft-4.cpp b/nSide/higan/fc/cartridge/board/sunsoft-4.cpp
new file mode 100644
index 0000000..09dd593
--- /dev/null
+++ b/nSide/higan/fc/cartridge/board/sunsoft-4.cpp
@@ -0,0 +1,85 @@
+//SUNSOFT-4
+
+struct Sunsoft4 : Board {
+  Sunsoft4(Markup::Node& boardNode) : Board(boardNode) {
+  }
+
+  auto readPRG(uint addr) -> uint8 {
+    if((addr & 0xc000) == 0x8000) return read(prgrom, (prgBank << 14) | (addr & 0x3fff));
+    if((addr & 0xc000) == 0xc000) return read(prgrom, (    0xff << 14) | (addr & 0x3fff));
+    return cpu.mdr();
+  }
+
+  auto writePRG(uint addr, uint8 data) -> void {
+    switch(addr & 0xf000) {
+    case 0x8000: chrBank[0] = data; break;
+    case 0x9000: chrBank[1] = data; break;
+    case 0xa000: chrBank[2] = data; break;
+    case 0xb000: chrBank[3] = data; break;
+    case 0xc000: ntromBank[0] = data | 0x80; break;
+    case 0xd000: ntromBank[1] = data | 0x80; break;
+    case 0xe000:
+      mirror = data & 0x03;
+      nametableMode = data & 0x10;
+      break;
+    case 0xf000: prgBank = data; break;
+    }
+  }
+
+  auto ciramAddress(uint addr) -> uint {
+    switch(mirror) {
+    case 0: return ((addr & 0x0400) >> 0) | (addr & 0x03ff);
+    case 1: return ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    case 2: return 0x0000 | (addr & 0x03ff);
+    case 3: return 0x0400 | (addr & 0x03ff);
+    }
+  }
+
+  auto readCHR(uint addr) -> uint8 {
+    if(addr & 0x2000) {
+      addr = ciramAddress(addr);
+      if(nametableMode) return Board::readCHR(((ntromBank[(addr & 0x0400) >> 10] | 0x80) << 10) | (addr & 0x03FF));
+      else              return ppu.readCIRAM(addr);
+    }
+    addr = (chrBank[(addr & 0x1800) >> 11] << 11) | (addr & 0x07ff);
+    return Board::readCHR(addr);
+  }
+
+  auto writeCHR(uint addr, uint8 data) -> void {
+    if(addr & 0x2000) {
+      if(nametableMode == 0) return ppu.writeCIRAM(ciramAddress(addr), data);
+    } else {
+      return Board::writeCHR(addr, data);
+    }
+  }
+
+  auto power() -> void {
+  }
+
+  auto reset() -> void {
+    chrBank[0] = 0;
+    chrBank[1] = 0;
+    chrBank[2] = 0;
+    chrBank[3] = 0;
+    ntromBank[0] = 0;
+    ntromBank[1] = 0;
+    mirror = 0;
+    nametableMode = 0;
+    prgBank = 0;
+  }
+
+  auto serialize(serializer& s) -> void {
+    Board::serialize(s);
+    s.array(chrBank);
+    s.array(ntromBank);
+    s.integer(mirror);
+    s.integer(nametableMode);
+    s.integer(prgBank);
+  }
+
+  uint8 chrBank[4];
+  uint7 ntromBank[2];
+  uint2 mirror;
+  bool nametableMode;
+  uint8 prgBank;
+};
diff --git a/higan/higan/fc/cartridge/board/sunsoft-5b.cpp b/nSide/higan/fc/cartridge/board/sunsoft-5b.cpp
index a300798..56e0971 100644
--- a/higan/higan/fc/cartridge/board/sunsoft-5b.cpp
+++ b/nSide/higan/fc/cartridge/board/sunsoft-5b.cpp
@@ -1,10 +1,18 @@
 //SUNSOFT-5B
 
 struct Sunsoft5B : Board {
-  Sunsoft5B(Markup::Node& document) : Board(document) {
+  Sunsoft5B(Markup::Node& boardNode) : Board(boardNode) {
   }
 
   struct Pulse {
+    bool disable;
+    uint12 frequency;
+    uint4 volume;
+
+    uint16 counter;  //12-bit countdown + 4-bit phase
+    uint1 duty;
+    uint4 output;
+
     auto clock() -> void {
       if(--counter == 0) {
         counter = frequency << 4;
@@ -33,14 +41,6 @@ struct Sunsoft5B : Board {
       s.integer(duty);
       s.integer(output);
     }
-
-    bool disable;
-    uint12 frequency;
-    uint4 volume;
-
-    uint16 counter;  //12-bit countdown + 4-bit phase
-    uint1 duty;
-    uint4 output;
   } pulse[3];
 
   auto main() -> void {
@@ -73,17 +73,16 @@ struct Sunsoft5B : Board {
     bank &= 0x3f;
 
     if(ramSelect) {
-      if(!ramEnable) return cpu.mdr();
-      return prgram.data[addr & 0x1fff];
+      if(ramEnable == false) return cpu.mdr();
+      return read(prgram, addr & 0x1fff);
     }
 
-    addr = (bank << 13) | (addr & 0x1fff);
-    return prgrom.read(addr);
+    return read(prgrom, (bank << 13) | (addr & 0x1fff));
   }
 
   auto writePRG(uint addr, uint8 data) -> void {
     if((addr & 0xe000) == 0x6000) {
-      prgram.data[addr & 0x1fff] = data;
+      write(prgram, addr & 0x1fff, data);
     }
 
     if(addr == 0x8000) {
@@ -139,12 +138,12 @@ struct Sunsoft5B : Board {
     }
   }
 
-  auto addrCHR(uint addr) -> uint {
+  auto chrAddress(uint addr) -> uint {
     uint8 bank = (addr >> 10) & 7;
     return (chrBank[bank] << 10) | (addr & 0x03ff);
   }
 
-  auto addrCIRAM(uint addr) -> uint {
+  auto ciramAddress(uint addr) -> uint {
     switch(mirror) {
     case 0: return ((addr & 0x0400) >> 0) | (addr & 0x03ff);  //vertical
     case 1: return ((addr & 0x0800) >> 1) | (addr & 0x03ff);  //horizontal
@@ -154,17 +153,17 @@ struct Sunsoft5B : Board {
   }
 
   auto readCHR(uint addr) -> uint8 {
-    if(addr & 0x2000) return ppu.readCIRAM(addrCIRAM(addr));
-    return Board::readCHR(addrCHR(addr));
+    if(addr & 0x2000) return ppu.readCIRAM(ciramAddress(addr));
+    return Board::readCHR(chrAddress(addr));
   }
 
   auto writeCHR(uint addr, uint8 data) -> void {
-    if(addr & 0x2000) return ppu.writeCIRAM(addrCIRAM(addr), data);
-    return Board::writeCHR(addrCHR(addr), data);
+    if(addr & 0x2000) return ppu.writeCIRAM(ciramAddress(addr), data);
+    return Board::writeCHR(chrAddress(addr), data);
   }
 
   auto power() -> void {
-    for(signed n : range(16)) {
+    for(int n = 0; n < 16; n++) {
       double volume = 1.0 / pow(2, 1.0 / 2 * (15 - n));
       dac[n] = volume * 8192.0;
     }
diff --git a/nSide/higan/fc/cartridge/board/taito-tc.cpp b/nSide/higan/fc/cartridge/board/taito-tc.cpp
new file mode 100644
index 0000000..bad640c
--- /dev/null
+++ b/nSide/higan/fc/cartridge/board/taito-tc.cpp
@@ -0,0 +1,42 @@
+struct TaitoTC : Board {
+  TaitoTC(Markup::Node& boardNode) : Board(boardNode), tc(*this, boardNode) {
+  }
+
+  auto main() -> void {
+    tc.main();
+  }
+
+  auto readPRG(uint addr) -> uint8 {
+    if(addr & 0x8000) return read(prgrom, tc.prgAddress(addr));
+    return cpu.mdr();
+  }
+
+  auto writePRG(uint addr, uint8 data) -> void {
+    if(addr & 0x8000) return tc.regWrite(addr, data);
+  }
+
+  auto readCHR(uint addr) -> uint8 {
+    if(addr & 0x2000) return ppu.readCIRAM(tc.ciramAddress(addr));
+    return Board::readCHR(tc.chrAddress(addr));
+  }
+
+  auto writeCHR(uint addr, uint8 data) -> void {
+    if(addr & 0x2000) return ppu.writeCIRAM(tc.ciramAddress(addr), data);
+    return Board::writeCHR(tc.chrAddress(addr), data);
+  }
+
+  auto power() -> void {
+    tc.power();
+  }
+
+  auto reset() -> void {
+    tc.reset();
+  }
+
+  auto serialize(serializer& s) -> void {
+    Board::serialize(s);
+    tc.serialize(s);
+  }
+
+  TC tc;
+};
diff --git a/nSide/higan/fc/cartridge/board/unlicensed/camerica.cpp b/nSide/higan/fc/cartridge/board/unlicensed/camerica.cpp
new file mode 100644
index 0000000..a6867a8
--- /dev/null
+++ b/nSide/higan/fc/cartridge/board/unlicensed/camerica.cpp
@@ -0,0 +1,103 @@
+struct Camerica : Board {
+  Camerica(Markup::Node& boardNode) : Board(boardNode) {
+    string type = boardNode["id"].text();
+    if(type.match("*ALGN*"  )) revision = Revision::ALGN;
+    if(type.match("*ALGQ*"  )) revision = Revision::ALGQ;
+    if(type.match("*BF9093*")) revision = Revision::BF9093;
+    if(type.match("*BF9096*")) revision = Revision::BF9096;
+    if(type.match("*BF9097*")) revision = Revision::BF9097;
+
+    settings.mirror = boardNode["mirror/mode"].text() == "horizontal";
+  }
+
+  auto readPRG(uint addr) -> uint8 {
+    if((addr & 0x8000) == 0x0000) return cpu.mdr();
+    if((addr & 0xc000) == 0x8000) {
+      return read(prgrom, (prgBlock << 16) | (prgBank << 14) | (addr & 0x3fff));
+    } else {
+      if(revision != Revision::ALGQ && revision != Revision::BF9096)
+        return read(prgrom, (0x0f << 14) | (addr & 0x3fff));
+      else
+        return read(prgrom, (prgBlock << 16) | (0x03 << 14) | (addr & 0x3fff));
+    }
+  }
+
+  auto writePRG(uint addr, uint8 data) -> void {
+    switch(revision) {
+    case Revision::ALGQ:
+    case Revision::BF9096:
+      if((addr & 0xc000) == 0x8000) {
+        prgBlock = (data & 0x18) >> 3;
+      }
+      break;
+    case Revision::BF9097:
+      if((addr & 0xe000) == 0x8000) {
+        nametable = data & 0x10;
+      }
+      break;
+    }
+    if((addr & 0xc000) == 0xc000) {
+      switch(revision) {
+      case Revision::ALGN:
+      case Revision::BF9093: prgBank = data & 0x0f; break;
+      case Revision::ALGQ:
+      case Revision::BF9096: prgBank = data & 0x03; break;
+      case Revision::BF9097: prgBank = data & 0x07; break;
+      }
+    }
+  }
+
+  auto readCHR(uint addr) -> uint8 {
+    if(addr & 0x2000) return ppu.readCIRAM(ciramAddress(addr));
+    return Board::readCHR(addr);
+  }
+
+  auto writeCHR(uint addr, uint8 data) -> void {
+    if(addr & 0x2000) return ppu.writeCIRAM(ciramAddress(addr), data);
+    return Board::writeCHR(addr, data);
+  }
+
+  auto ciramAddress(uint addr) const -> uint {
+    if(revision != Revision::BF9097) {
+      switch(settings.mirror) {
+      case 0: return ((addr & 0x0400) >> 0) | (addr & 0x03ff);
+      case 1: return ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+      }
+    } else {
+      return (addr & 0x03ff) | (nametable << 10);
+    }
+  }
+
+  auto power() -> void {
+  }
+
+  auto reset() -> void {
+    prgBank = 0;
+    prgBlock = 0;
+    nametable = 0;
+  }
+
+  auto serialize(serializer& s) -> void {
+    Board::serialize(s);
+
+    s.integer(prgBank);
+    s.integer(prgBlock);
+    s.integer(nametable);
+  }
+
+  enum class Revision : uint {
+    ALGN, // Aladdin Game Enhancer
+    ALGQ, // Aladdin Game Enhancer (Quattro Multicarts)
+    BF9093,
+    BF9096,
+    BF9097,
+  } revision;
+
+  struct Settings {
+    bool mirror;    //0 = vertical, 1 = horizontal
+  } settings;
+
+  uint4 prgBank;
+  uint2 prgBlock; // for ALGQ and BF9096
+  bool nametable; // for BF9097
+};
diff --git a/nSide/higan/fc/cartridge/board/unlicensed/colordreams-74-377.cpp b/nSide/higan/fc/cartridge/board/unlicensed/colordreams-74-377.cpp
new file mode 100644
index 0000000..30d0d43
--- /dev/null
+++ b/nSide/higan/fc/cartridge/board/unlicensed/colordreams-74-377.cpp
@@ -0,0 +1,62 @@
+//COLORDREAMS-74*377
+
+struct ColorDreams74_377 : Board {
+  ColorDreams74_377(Markup::Node& boardNode) : Board(boardNode) {
+    settings.mirror = boardNode["mirror/mode"].text() == "horizontal";
+  }
+
+  auto readPRG(uint addr) -> uint8 {
+    if(addr & 0x8000) return read(prgrom, (prgBank << 15) | (addr & 0x7fff));
+    return cpu.mdr();
+  }
+
+  auto writePRG(uint addr, uint8 data) -> void {
+    if(addr & 0x8000) {
+      // Bus conflicts
+      data &= readPRG(addr);
+      // PRG and CHR bits are swapped relative to NES-GxROM.
+      // Additionally, up to 16 CHR banks are available instead of 4.
+      prgBank = (data & 0x03) >> 0;
+      chrBank = (data & 0xf0) >> 4;
+    }
+  }
+
+  auto readCHR(uint addr) -> uint8 {
+    if(addr & 0x2000) {
+      if(settings.mirror == 1) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+      return ppu.readCIRAM(addr);
+    }
+    addr = (chrBank * 0x2000) + (addr & 0x1fff);
+    return Board::readCHR(addr);
+  }
+
+  auto writeCHR(uint addr, uint8 data) -> void {
+    if(addr & 0x2000) {
+      if(settings.mirror == 1) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+      return ppu.writeCIRAM(addr, data);
+    }
+    addr = (chrBank * 0x2000) + (addr & 0x1fff);
+    Board::writeCHR(addr, data);
+  }
+
+  auto power() -> void {
+  }
+
+  auto reset() -> void {
+    prgBank = 0;
+    chrBank = 0;
+  }
+
+  auto serialize(serializer& s) -> void {
+    Board::serialize(s);
+    s.integer(prgBank);
+    s.integer(chrBank);
+  }
+
+  struct Settings {
+    bool mirror;  //0 = vertical, 1 = horizontal
+  } settings;
+
+  uint2 prgBank;
+  uint4 chrBank;
+};
diff --git a/nSide/higan/fc/cartridge/board/unlicensed/mlt-action52.cpp b/nSide/higan/fc/cartridge/board/unlicensed/mlt-action52.cpp
new file mode 100644
index 0000000..0ba2d3b
--- /dev/null
+++ b/nSide/higan/fc/cartridge/board/unlicensed/mlt-action52.cpp
@@ -0,0 +1,80 @@
+//MLT-ACTION52
+
+struct MLT_Action52 : Board {
+  MLT_Action52(Markup::Node& boardNode) : Board(boardNode) {
+    settings.connectedChips = boardNode["connected-chips"].natural();
+    uint2 chipBlock = 0;
+    for(uint chipID = 0; chipID < 4; chipID++) {
+      if(settings.connectedChips & (0x1 << chipID)) settings.chipMap[chipID] = chipBlock++;
+    }
+  }
+
+  auto readPRG(uint addr) -> uint8 {
+    if(addr & 0x8000 && settings.connectedChips & (1 << prgChip)) {
+      uint targetBank = prgBank;
+      targetBank |= settings.chipMap[prgChip] << 5;
+      if(prgMode) return read(prgrom, (targetBank << 14) | (addr & 0x3fff));
+      else        return read(prgrom, (targetBank << 14) | (addr & 0x7fff));
+    }
+    return cpu.mdr();
+  }
+
+  auto writePRG(uint addr, uint8 data) -> void {
+    if(addr & 0x8000) {
+      mirror  = (addr & 0x2000) >> 13;
+      prgChip = (addr & 0x1800) >> 11;
+      prgBank = (addr & 0x07c0) >> 6;
+      prgMode = (addr & 0x0020) >> 5;
+      chrBank = ((addr & 0x000f) << 2) + (data & 0x03);
+    }
+  }
+
+  auto readCHR(uint addr) -> uint8 {
+    if(addr & 0x2000) {
+      if(mirror) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+      return ppu.readCIRAM(addr);
+    }
+    addr = (chrBank * 0x2000) + (addr & 0x1fff);
+    return Board::readCHR(addr);
+  }
+
+  auto writeCHR(uint addr, uint8 data) -> void {
+    if(addr & 0x2000) {
+      if(mirror) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+      return ppu.writeCIRAM(addr, data);
+    }
+    addr = (chrBank * 0x2000) + (addr & 0x1fff);
+    Board::writeCHR(addr, data);
+  }
+
+  auto power() -> void {
+  }
+
+  auto reset() -> void {
+    mirror = 0;
+    prgChip = 0;
+    prgBank = 0;
+    prgMode = 0;
+    chrBank = 0;
+  }
+
+  auto serialize(serializer &s) -> void {
+    Board::serialize(s);
+    s.integer(mirror);
+    s.integer(prgChip);
+    s.integer(prgBank);
+    s.integer(prgMode);
+    s.integer(chrBank);
+  }
+
+  struct Settings {
+    uint4 connectedChips;
+    uint2 chipMap[4];
+  } settings;
+
+  bool mirror;
+  uint2 prgChip;
+  uint5 prgBank;
+  bool prgMode;
+  uint6 chrBank;
+};
diff --git a/nSide/higan/fc/cartridge/board/unlicensed/nina.cpp b/nSide/higan/fc/cartridge/board/unlicensed/nina.cpp
new file mode 100644
index 0000000..1e75777
--- /dev/null
+++ b/nSide/higan/fc/cartridge/board/unlicensed/nina.cpp
@@ -0,0 +1,91 @@
+//AVE-NINA-01
+//AVE-NINA-02
+//AVE-NINA-03
+//AVE-NINA-06
+
+struct Nina : Board {
+  Nina(Markup::Node& boardNode) : Board(boardNode) {
+    string type = boardNode["id"].text();
+    if(type.match("*NINA-01")) revision =  1;
+    if(type.match("*NINA-02")) revision =  2;
+    if(type.match("*NINA-03")) revision =  3;
+    if(type.match("*NINA-06")) revision =  6;
+
+    if(revision ==  1 || revision ==  2) {
+      settings.mirror = 1;
+    } else {
+      settings.mirror = boardNode["mirror/mode"].text() == "horizontal";
+    }
+  }
+
+  auto readPRG(uint addr) -> uint8 {
+    if(addr & 0x8000) return read(prgrom, (prgBank << 15) | (addr & 0x7fff));
+    if((addr & 0xe000) == 0x6000) {
+      if(prgram.size() > 0) return read(prgram, addr);
+    }
+    return cpu.mdr();
+  }
+
+  auto writePRG(uint addr, uint8 data) -> void {
+    switch(revision) {
+    case  1:
+    case  2:
+      switch(addr) {
+      case 0x7ffd: prgBank    = data & 0x01; break;
+      case 0x7ffe: chrBank[0] = data & 0x0f; break;
+      case 0x7fff: chrBank[1] = data & 0x0f; break;
+      }
+      break;
+    case  3:
+    case  6:
+      if((addr & 0xe100) == 0x4100) {
+        prgBank    = (data & 0x08) >> 3;
+        chrBank[0] = ((data & 0x07) << 1) | 0;
+        chrBank[1] = ((data & 0x07) << 1) | 1;
+      }
+      break;
+    }
+    if((addr & 0xe000) == 0x6000 && prgram.size() > 0) write(prgram, addr, data);
+  }
+
+  auto readCHR(uint addr) -> uint8 {
+    if(addr & 0x2000) {
+      if(settings.mirror == 1) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+      return ppu.readCIRAM(addr);
+    }
+    return Board::readCHR((addr & 0x0fff) | (chrBank[(addr & 0x1000) >> 12] << 12));
+  }
+
+  auto writeCHR(uint addr, uint8 data) -> void {
+    if(addr & 0x2000) {
+      if(settings.mirror == 1) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+      return ppu.writeCIRAM(addr, data);
+    }
+    return Board::writeCHR((addr & 0x0fff) | (chrBank[(addr & 0x1000) >> 12] << 12), data);
+  }
+
+  auto power() -> void {
+    reset();
+  }
+
+  auto reset() -> void {
+    prgBank = 0;
+    chrBank[0] = 0;
+    chrBank[1] = 0;
+  }
+
+  auto serialize(serializer& s) -> void {
+    Board::serialize(s);
+    s.integer(prgBank);
+    s.array(chrBank);
+  }
+
+  uint revision;
+
+  struct Settings {
+    bool mirror;  //0 = vertical, 1 = horizontal
+  } settings;
+
+  bool prgBank;
+  uint4 chrBank[2];
+};
diff --git a/higan/higan/fc/cartridge/board/nes-cnrom.cpp b/nSide/higan/fc/cartridge/board/unlicensed/noconflicts-cnrom.cpp
similarity index 52%
rename from higan/higan/fc/cartridge/board/nes-cnrom.cpp
rename to nSide/higan/fc/cartridge/board/unlicensed/noconflicts-cnrom.cpp
index 3316320..41b311f 100644
--- a/higan/higan/fc/cartridge/board/nes-cnrom.cpp
+++ b/nSide/higan/fc/cartridge/board/unlicensed/noconflicts-cnrom.cpp
@@ -1,12 +1,14 @@
-//NES-CNROM
+// This board is intended for homebrew games that do not account for bus
+// conflicts. Many Sachen and Panesian games require this board, but they were
+// not the reason for its inclusion.
 
-struct NES_CNROM : Board {
-  NES_CNROM(Markup::Node& document) : Board(document) {
-    settings.mirror = document["board/mirror/mode"].text() == "vertical" ? 1 : 0;
+struct NoConflicts_CNROM : Board {
+  NoConflicts_CNROM(Markup::Node& boardNode) : Board(boardNode) {
+    settings.mirror = boardNode["mirror/mode"].text() == "horizontal";
   }
 
   auto readPRG(uint addr) -> uint8 {
-    if(addr & 0x8000) return prgrom.read(addr & 0x7fff);
+    if(addr & 0x8000) return read(prgrom, addr & 0x7fff);
     return cpu.mdr();
   }
 
@@ -16,8 +18,8 @@ struct NES_CNROM : Board {
 
   auto readCHR(uint addr) -> uint8 {
     if(addr & 0x2000) {
-      if(settings.mirror == 0) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
-      return ppu.readCIRAM(addr & 0x07ff);
+      if(settings.mirror == 1) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+      return ppu.readCIRAM(addr);
     }
     addr = (chrBank * 0x2000) + (addr & 0x1fff);
     return Board::readCHR(addr);
@@ -25,8 +27,8 @@ struct NES_CNROM : Board {
 
   auto writeCHR(uint addr, uint8 data) -> void {
     if(addr & 0x2000) {
-      if(settings.mirror == 0) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
-      return ppu.writeCIRAM(addr & 0x07ff, data);
+      if(settings.mirror == 1) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+      return ppu.writeCIRAM(addr, data);
     }
     addr = (chrBank * 0x2000) + (addr & 0x1fff);
     Board::writeCHR(addr, data);
@@ -45,7 +47,7 @@ struct NES_CNROM : Board {
   }
 
   struct Settings {
-    bool mirror;  //0 = horizontal, 1 = vertical
+    bool mirror;  //0 = vertical, 1 = horizontal
   } settings;
 
   uint2 chrBank;
diff --git a/nSide/higan/fc/cartridge/board/unlicensed/single-chip.cpp b/nSide/higan/fc/cartridge/board/unlicensed/single-chip.cpp
new file mode 100644
index 0000000..8ca9a14
--- /dev/null
+++ b/nSide/higan/fc/cartridge/board/unlicensed/single-chip.cpp
@@ -0,0 +1,31 @@
+struct SingleChip : Board {
+  SingleChip(Markup::Node& boardNode) : Board(boardNode) {
+    settings.va10 = boardNode["va10"].natural();
+  }
+
+  auto readPRG(uint addr) -> uint8 {
+    if(addr & 0x8000) return read(prgrom, addr);
+    return cpu.mdr();
+  }
+
+  auto writePRG(uint addr, uint8 data) -> void {
+  }
+
+  auto readCHR(uint addr) -> uint8 {
+    addr = ((addr & (1 << settings.va10)) >> (settings.va10 - 10)) | (addr & 0x03ff);
+    return ppu.readCIRAM(addr);
+  }
+
+  auto writeCHR(uint addr, uint8 data) -> void {
+    addr = ((addr & (1 << settings.va10)) >> (settings.va10 - 10)) | (addr & 0x03ff);
+    return ppu.writeCIRAM(addr, data);
+  }
+
+  auto serialize(serializer& s) -> void {
+    Board::serialize(s);
+  }
+
+  struct Settings {
+    uint4 va10;  //10 = vertical, 11 = horizontal, 12 = BLK0, 13 = BLK1
+  } settings;
+};
diff --git a/nSide/higan/fc/cartridge/board/vs.cpp b/nSide/higan/fc/cartridge/board/vs.cpp
new file mode 100644
index 0000000..7305725
--- /dev/null
+++ b/nSide/higan/fc/cartridge/board/vs.cpp
@@ -0,0 +1,155 @@
+//VS
+
+struct VS : Board {
+  VS(Markup::Node& boardNode) : Board(boardNode),
+  mmc1(*this, boardNode),
+  n108(*this, boardNode) {
+    chipType = ChipType::None;
+    string type = boardNode["chip/type"].text();
+    if(type.match("74HC32")) chipType = ChipType::_74HC32;
+    if(type.match("MMC1*" )) chipType = ChipType::MMC1;
+    if(type.match("108"   )) chipType = ChipType::N108;
+    if(type.match("109"   )) chipType = ChipType::N108;
+    if(type.match("118"   )) chipType = ChipType::N108;
+    if(type.match("119"   )) chipType = ChipType::N108;
+  }
+
+  auto main() -> void {
+    if(chipType == ChipType::MMC1) return mmc1.main();
+    tick();
+  }
+
+  auto readPRG(uint addr) -> uint8 {
+    switch(chipType) {
+    case ChipType::None: {
+      if(addr & 0x8000) {
+        if(addr < 0xe000 && prgrom.size() < 0x2000) return cpu.mdr();
+        if(addr < 0xc000 && prgrom.size() < 0x4000) return cpu.mdr();
+        if(addr < 0xa000 && prgrom.size() < 0x6000) return cpu.mdr();
+        addr &= 0x7fff;
+        if(prgrom.size() > 0x8000) { // Games with oversize 1D such as VS. Gumshoe
+          if(addr >= 0x2000 || bank == 1) addr += 0x2000;
+        }
+        return read(prgrom, addr);
+      }
+      break;
+    }
+
+    case ChipType::_74HC32: {
+      if(addr & 0x8000) {
+        if((addr & 0xc000) == 0x8000)
+          return read(prgrom, (bank << 14) | (addr & 0x3fff));
+        else
+          return read(prgrom, (0x0f << 14) | (addr & 0x3fff));
+      }
+      break;
+    }
+
+    case ChipType::MMC1: {
+      if(addr & 0x8000) return read(prgrom, mmc1.prgAddress(addr));
+      //if(revision == Revision::SUROM || revision == Revision::SXROM) {
+      //  addr |= ((mmc1.chrBank[lastCHRBank] & 0x10) >> 4) << 18;
+      //}
+      break;
+    }
+
+    case ChipType::N108: {
+      if(addr & 0x8000) return read(prgrom, n108.prgAddress(addr));
+      break;
+    }
+
+    }
+    if((addr & 0xe000) == 0x6000) {
+      if(prgram.size() == 0) return vssystem.read(cpu.side, addr, cpu.mdr());
+      else                   return read(prgram, addr);
+    }
+    return cpu.mdr();
+  }
+
+  auto writePRG(uint addr, uint8 data) -> void {
+    switch(chipType) {
+    case ChipType::None:
+      if(addr == 0x4016) bank = (data & 0x04) >> 2;
+      break;
+    case ChipType::_74HC32:
+      //TODO: Check if VS. UNROM has bus conflicts
+      //data &= readPRG(addr);
+      if(addr & 0x8000) bank = data & 0x0f;
+      break;
+    case ChipType::MMC1:
+      if(addr & 0x8000) return mmc1.mmioWrite(addr, data);
+      break;
+    case ChipType::N108:
+      if(addr & 0x8000) return n108.regWrite(addr, data);
+      break;
+    }
+    if((addr & 0xe000) == 0x6000) {
+      if(prgram.size() == 0) vssystem.write(cpu.side, addr, data);
+      else                   write(prgram, addr, data);
+    }
+  }
+
+  auto readCHR(uint addr) -> uint8 {
+    if(addr & 0x2000) return ppu.readCIRAM(addr);
+    switch(chipType) {
+    case ChipType::None:
+      if(chrrom.size() < bank << 13) return ppu.io.mdr;
+      return read(chrrom, ((bank << 13) + (addr & 0x1fff)));
+    case ChipType::_74HC32:
+      return Board::readCHR(addr);
+    case ChipType::MMC1:
+      return Board::readCHR(mmc1.chrAddress(addr));
+    case ChipType::N108:
+      return Board::readCHR(n108.chrAddress(addr));
+    }
+  }
+
+  auto writeCHR(uint addr, uint8 data) -> void {
+    if(addr & 0x2000) return ppu.writeCIRAM(addr, data);
+    switch(chipType) {
+    case ChipType::None:
+      break;
+    case ChipType::_74HC32:
+      return Board::writeCHR(addr, data);
+    case ChipType::MMC1:
+      return Board::writeCHR(mmc1.chrAddress(addr), data);
+    case ChipType::N108:
+      return Board::writeCHR(n108.chrAddress(addr), data);
+    }
+  }
+
+  auto power() -> void {
+    switch(chipType) {
+    case ChipType::MMC1: mmc1.power(); break;
+    case ChipType::N108: n108.power(); break;
+    }
+  }
+
+  auto reset() -> void {
+    bank = 0;
+    switch(chipType) {
+    case ChipType::MMC1: mmc1.reset(); break;
+    case ChipType::N108: n108.reset(); break;
+    }
+  }
+
+  auto serialize(serializer& s) -> void {
+    Board::serialize(s);
+    s.integer(bank);
+    switch(chipType) {
+    case ChipType::MMC1: mmc1.serialize(s); break;
+    case ChipType::N108: n108.serialize(s); break;
+    }
+  }
+
+  enum class ChipType : uint {
+    None,
+    _74HC32,
+    MMC1,
+    N108,
+  } chipType;
+
+  uint4 bank;
+  MMC1 mmc1;
+  N108 n108;
+};
diff --git a/higan/higan/fc/cartridge/cartridge.cpp b/nSide/higan/fc/cartridge/cartridge.cpp
index 6c40e57..fe8ad0f 100644
--- a/higan/higan/fc/cartridge/cartridge.cpp
+++ b/nSide/higan/fc/cartridge/cartridge.cpp
@@ -2,10 +2,25 @@
 
 namespace Famicom {
 
+#include "load.cpp"
+#include "save.cpp"
 #include "chip/chip.cpp"
 #include "board/board.cpp"
+#include "serialization.cpp"
 Cartridge cartridge;
 
+auto Cartridge::manifest() const -> string {
+  string manifest = information.manifest.cartridge;
+  if(information.manifest.famicomDiskSystem) manifest.append("\n[[Famicom Disk System]]\n\n", information.manifest.famicomDiskSystem);
+  return manifest;
+}
+
+auto Cartridge::title() const -> string {
+  string title = information.title.cartridge;
+  if(information.title.famicomDiskSystem) title.append(" + ", information.title.famicomDiskSystem);
+  return title;
+}
+
 auto Cartridge::Enter() -> void {
   while(true) scheduler.synchronize(), cartridge.main();
 }
@@ -15,33 +30,74 @@ auto Cartridge::main() -> void {
 }
 
 auto Cartridge::load() -> bool {
-  if(auto pathID = interface->load(ID::Famicom, "Famicom", "fc")) {
-    information.pathID = pathID();
-  } else return false;
+  information = Information();
+
+  switch(system.model()) {
+  case Model::Famicom:
+    if(auto pathID = interface->load(ID::Famicom, "Famicom", "fc")) {
+      information.pathID = pathID();
+    } else return false;
+    break;
+  case Model::VSSystem:
+    if(auto pathID = interface->load(ID::VSSystem, "VS. System", "vs")) {
+      information.pathID = pathID();
+    } else return false;
+    break;
+  case Model::PlayChoice10:
+    if(auto pathID = interface->load(ID::PlayChoice10, "PlayChoice-10", "pc10")) {
+      information.pathID = pathID();
+    } else return false;
+    break;
+  //case Model::FamicomBox:
+  //  if(auto pathID = interface->load(ID::FamicomBox, "FamicomBox", "fcb")) {
+  //    information.pathID = pathID();
+  //  } else return false;
+  //  break;
+  }
 
   if(auto fp = interface->open(pathID(), "manifest.bml", File::Read, File::Required)) {
-    information.manifest = fp->reads();
-  } else {
-    return false;
+    information.manifest.cartridge = fp->reads();
+  } else return false;
+  auto document = BML::unserialize(information.manifest.cartridge);
+  loadCartridge(document);
+  if(!board) return false;
+
+  //Famicom Disk System
+  if(false) {
+
   }
 
-  Board::load(information.manifest);  //this call will set Cartridge::board if successful
-  if(!board) return false;
+  //Famicom
+  else {
+    Hash::SHA256 sha;
+    //hash each ROM image that exists; any with size() == 0 is ignored by sha256_chunk()
+    sha.input(board->prgrom.data(), board->prgrom.size());
+    sha.input(board->chrrom.data(), board->chrrom.size());
+    sha.input(board->instrom.data(), board->instrom.size());
+    sha.input(board->keyrom.data(), board->keyrom.size());
+    //finalize hash
+    information.sha256 = sha.digest();
+  }
 
-  Hash::SHA256 sha;
-  sha.input(board->prgrom.data, board->prgrom.size);
-  sha.input(board->chrrom.data, board->chrrom.size);
-  information.sha256 = sha.digest();
+  board->prgrom.writeProtect(true);
+  board->prgram.writeProtect(false);
+  board->chrrom.writeProtect(true);
+  board->chrram.writeProtect(false);
+  if(board->chip) board->chip->ram.writeProtect(false);
+  board->instrom.writeProtect(true);
+  board->keyrom.writeProtect(true);
   return true;
 }
 
 auto Cartridge::save() -> void {
-  board->save();
+  saveCartridge(BML::unserialize(information.manifest.cartridge));
 }
 
 auto Cartridge::unload() -> void {
-  delete board;
-  board = nullptr;
+  board->prgrom.reset();
+  board->chrrom.reset();
+  board->instrom.reset();
+  board->keyrom.reset();
 }
 
 auto Cartridge::power() -> void {
@@ -73,9 +129,4 @@ auto Cartridge::scanline(uint y) -> void {
   return board->scanline(y);
 }
 
-auto Cartridge::serialize(serializer& s) -> void {
-  Thread::serialize(s);
-  return board->serialize(s);
-}
-
 }
diff --git a/higan/higan/fc/cartridge/cartridge.hpp b/nSide/higan/fc/cartridge/cartridge.hpp
index a3676cc..f6ee7de 100644
--- a/higan/higan/fc/cartridge/cartridge.hpp
+++ b/nSide/higan/fc/cartridge/cartridge.hpp
@@ -2,13 +2,16 @@
 #include "board/board.hpp"
 
 struct Cartridge : Thread {
-  static auto Enter() -> void;
-  auto main() -> void;
+  enum class Region : uint { NTSC, PAL, Dendy };
+
+  static void Enter();
+  void main();
 
   auto pathID() const -> uint { return information.pathID; }
   auto sha256() const -> string { return information.sha256; }
-  auto manifest() const -> string { return information.manifest; }
-  auto title() const -> string { return information.title; }
+  auto region() const -> Region { return information.region; }
+  auto manifest() const -> string;
+  auto title() const -> string;
 
   auto load() -> bool;
   auto save() -> void;
@@ -22,12 +25,21 @@ struct Cartridge : Thread {
   struct Information {
     uint pathID = 0;
     string sha256;
-    string manifest;
-    string title;
+    Region region = Region::NTSC;
+
+    struct Manifest {
+      string cartridge;
+      string famicomDiskSystem;
+    } manifest;
+
+    struct Title {
+      string cartridge;
+      string famicomDiskSystem;
+    } title;
   } information;
 
 //privileged:
-  Board* board = nullptr;
+  Board* board;
 
   auto readPRG(uint addr) -> uint8;
   auto writePRG(uint addr, uint8 data) -> void;
@@ -38,6 +50,20 @@ struct Cartridge : Thread {
   //scanline() is for debugging purposes only:
   //boards must detect scanline edges on their own
   auto scanline(uint y) -> void;
+
+private:
+  //load.cpp
+  auto loadCartridge(Markup::Node) -> void;
+  auto setupVS(Markup::Node&, Markup::Node&) -> void;
+
+  auto loadMemory(MappedRAM&, Markup::Node, bool required, maybe<uint> id = nothing) -> void;
+
+  //save.cpp
+  auto saveCartridge(Markup::Node) -> void;
+
+  auto saveMemory(MappedRAM&, Markup::Node, maybe<uint> = nothing) -> void;
+
+  friend class Interface;
 };
 
 extern Cartridge cartridge;
diff --git a/higan/higan/fc/cartridge/chip/chip.cpp b/nSide/higan/fc/cartridge/chip/chip.cpp
index 7bb7afc..11d6f9e 100644
--- a/higan/higan/fc/cartridge/chip/chip.cpp
+++ b/nSide/higan/fc/cartridge/chip/chip.cpp
@@ -1,7 +1,14 @@
+#include "fcg.cpp"
+#include "g101.cpp"
+#include "ifh3001.cpp"
 #include "mmc1.cpp"
 #include "mmc3.cpp"
 #include "mmc5.cpp"
 #include "mmc6.cpp"
+#include "n108.cpp"
+#include "n163.cpp"
+#include "ss88006.cpp"
+#include "tc.cpp"
 #include "vrc1.cpp"
 #include "vrc2.cpp"
 #include "vrc3.cpp"
diff --git a/higan/higan/fc/cartridge/chip/chip.hpp b/nSide/higan/fc/cartridge/chip/chip.hpp
index 028acb2..88078d0 100644
--- a/higan/higan/fc/cartridge/chip/chip.hpp
+++ b/nSide/higan/fc/cartridge/chip/chip.hpp
@@ -5,4 +5,5 @@ struct Chip {
   auto tick() -> void;
 
   Board& board;
+  MappedRAM ram;
 };
diff --git a/nSide/higan/fc/cartridge/chip/fcg.cpp b/nSide/higan/fc/cartridge/chip/fcg.cpp
new file mode 100644
index 0000000..72ec4f4
--- /dev/null
+++ b/nSide/higan/fc/cartridge/chip/fcg.cpp
@@ -0,0 +1,128 @@
+struct FCG : Chip {
+  FCG(Board& board, Markup::Node& boardNode) : Chip(board) {
+    string type = boardNode["chip[0]/type"].text();
+    if(type == "FCG-1"  ) revision = Revision::FCG1;
+    if(type == "FCG-2"  ) revision = Revision::FCG2;
+    if(type == "LZ93D50") revision = Revision::LZ93D50;
+
+    eeprom = EEPROM::None;
+    type = boardNode["chip[1]/type"].text();
+    if(type == "24C01") eeprom = EEPROM::_24C01;
+    if(type == "24C02") eeprom = EEPROM::_24C02;
+  }
+
+  auto main() -> void {
+    if(irqCounterEnable) {
+      if(--irqCounter == 0xffff) {
+        cpu.irqLine(1);
+        irqCounterEnable = false;
+      }
+    }
+
+    tick();
+  }
+
+  auto prgAddress(uint addr) const -> uint {
+    bool region = addr & 0x4000;
+    return ((region == 0 ? prgBank : (uint8)0x0f) << 14) | (addr & 0x3fff);
+  }
+
+  auto chrAddress(uint addr) const -> uint {
+    return (chrBank[addr >> 10] << 10) | (addr & 0x03ff);
+  }
+
+  auto ciramAddress(uint addr) const -> uint {
+    switch(mirror) {
+    case 0: return ((addr & 0x0400) >> 0) | (addr & 0x03ff);
+    case 1: return ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    case 2: return 0x0000 | (addr & 0x03ff);
+    case 3: return 0x0400 | (addr & 0x03ff);
+    }
+  }
+
+  auto ramRead(uint addr) -> uint8 {
+    return board.read(board.prgram, addr & 0x1fff);
+  }
+
+  auto ramWrite(uint addr, uint8 data) -> void {
+    board.write(board.prgram, addr & 0x1fff, data);
+  }
+
+  auto regWrite(uint addr, uint8 data) -> void {
+    switch(addr & 0x0f) {
+    case 0x00: case 0x01: case 0x02: case 0x03:
+    case 0x04: case 0x05: case 0x06: case 0x07:
+      chrBank[addr & 7] = data;
+      break;
+    case 0x08:
+      prgBank = data & 0x0f;
+      break;
+    case 0x09:
+      mirror = data & 0x03;
+      break;
+    case 0x0a:
+      cpu.irqLine(0);
+      irqCounterEnable = data & 0x01;
+      irqCounter = irqLatch;
+      break;
+    case 0x0b:
+      irqLatch = (irqLatch & 0xff00) | (data << 0);
+      break;
+    case 0x0c:
+      irqLatch = (irqLatch & 0x00ff) | (data << 8);
+      break;
+    case 0x0d:
+      //TODO: serial EEPROM support
+      eepromI2C_SCL = data & 0x20;
+      eepromEnableRead = data & 0x80;
+      break;
+    }
+  }
+
+  auto power() -> void {
+    reset();
+  }
+
+  auto reset() -> void {
+    for(auto &n : chrBank) n = 0;
+    prgBank = 0;
+    mirror = 0;
+    irqCounterEnable = 0;
+    irqCounter = 0;
+    irqLatch = 0;
+    eepromI2C_SCL = 0;
+    eepromEnableRead = 0;
+  }
+
+  auto serialize(serializer& s) -> void {
+    s.array(chrBank);
+    s.integer(prgBank);
+    s.integer(mirror);
+    s.integer(irqCounterEnable);
+    s.integer(irqCounter);
+    s.integer(irqLatch);
+    s.integer(eepromI2C_SCL);
+    s.integer(eepromEnableRead);
+  }
+
+  enum class Revision : uint {
+    FCG1,
+    FCG2,
+    LZ93D50,
+  } revision;
+
+  enum class EEPROM : uint {
+    None,
+    _24C01,
+    _24C02
+  } eeprom;
+
+  uint8 chrBank[8];
+  uint8 prgBank;
+  uint2 mirror;
+  bool irqCounterEnable;
+  uint16 irqCounter;
+  uint16 irqLatch;
+  bool eepromI2C_SCL; // When using SRAM, enables RAM chip
+  bool eepromEnableRead;
+};
diff --git a/nSide/higan/fc/cartridge/chip/g101.cpp b/nSide/higan/fc/cartridge/chip/g101.cpp
new file mode 100644
index 0000000..1245e38
--- /dev/null
+++ b/nSide/higan/fc/cartridge/chip/g101.cpp
@@ -0,0 +1,78 @@
+struct G101 : Chip {
+  G101(Board& board, Markup::Node& boardNode) : Chip(board) {
+  }
+
+  auto prgAddress(uint addr) const -> uint {
+    switch(addr & 0xe000) {
+    case 0x8000:
+      if(prgMode == 1) return (0x1e << 13) | (addr & 0x1fff);
+      return (prgBank[0] << 13) | (addr & 0x1fff);
+    case 0xa000:
+      return (prgBank[1] << 13) | (addr & 0x1fff);
+    case 0xc000:
+      if(prgMode == 0) return (0x1e << 13) | (addr & 0x1fff);
+      return (prgBank[0] << 13) | (addr & 0x1fff);
+    case 0xe000:
+      return (0x1f << 13) | (addr & 0x1fff);
+    }
+  }
+
+  auto chrAddress(uint addr) const -> uint {
+    return (chrBank[addr >> 10] << 10) | (addr & 0x03ff);
+  }
+
+  auto ciramAddress(uint addr) const -> uint {
+    switch(mirror) {
+    case 0: return (addr & 0x03ff) | ((addr & 0x0400) >> 0);
+    case 1: return (addr & 0x03ff) | ((addr & 0x0800) >> 1);
+    }
+  }
+
+  auto regWrite(uint addr, uint8 data) -> void {
+    switch(addr & 0xf000) {
+    case 0x8000:
+      prgBank[0] = data & 0x1f;
+      break;
+    case 0x9000:
+      mirror = data & 0x01;
+      prgMode = data & 0x02;
+      break;
+    case 0xa000:
+      prgBank[1] = data & 0x1f;
+      break;
+    case 0xb000:
+      chrBank[addr & 0x0007] = data;
+      break;
+    }
+  }
+
+  auto power() -> void {
+    prgMode = 0;
+    prgBank[0] = 0x00;
+    prgBank[1] = 0x1e;
+    chrBank[0] = 0;
+    chrBank[1] = 0;
+    chrBank[2] = 0;
+    chrBank[3] = 0;
+    chrBank[4] = 0;
+    chrBank[5] = 0;
+    chrBank[6] = 0;
+    chrBank[7] = 0;
+    mirror = 0;
+  }
+
+  auto reset() -> void {
+  }
+
+  auto serialize(serializer& s) -> void {
+    s.integer(prgMode);
+    s.array(prgBank);
+    s.array(chrBank);
+    s.integer(mirror);
+  }
+
+  bool prgMode;
+  uint5 prgBank[2];
+  uint8 chrBank[8];
+  bool mirror;
+};
diff --git a/nSide/higan/fc/cartridge/chip/ifh3001.cpp b/nSide/higan/fc/cartridge/chip/ifh3001.cpp
new file mode 100644
index 0000000..08890d5
--- /dev/null
+++ b/nSide/higan/fc/cartridge/chip/ifh3001.cpp
@@ -0,0 +1,117 @@
+struct IFH3001 : Chip {
+  IFH3001(Board& board, Markup::Node& boardNode) : Chip(board) {
+  }
+
+  auto main() -> void {
+    if(irqEnable && irqCounter) {
+      if(--irqCounter == 0) cpu.irqLine(1);
+    }
+    tick();
+  }
+
+  auto prgAddress(uint addr) const -> uint {
+    switch(addr & 0xe000) {
+    case 0x8000: return (prgBank[0] << 13) | (addr & 0x1fff);
+    case 0xa000: return (prgBank[1] << 13) | (addr & 0x1fff);
+    case 0xc000: return (prgBank[2] << 13) | (addr & 0x1fff);
+    case 0xe000: return (0xff << 13) | (addr & 0x1fff);
+    }
+  }
+
+  auto chrAddress(uint addr) const -> uint {
+    return (chrBank[addr >> 10] << 10) | (addr & 0x03ff);
+  }
+
+  auto ciramAddress(uint addr) const -> uint {
+    switch(mirror) {
+    case 0: return (addr & 0x03ff) | ((addr & 0x0400) >> 0);
+    case 1: return (addr & 0x03ff) | ((addr & 0x0800) >> 1);
+    }
+  }
+
+  auto regWrite(uint addr, uint8 data) -> void {
+    switch(addr & 0xf007) {
+    case 0x8000:
+    case 0x8001:
+    case 0x8002:
+    case 0x8003:
+    case 0x8004:
+    case 0x8005:
+    case 0x8006:
+    case 0x8007: prgBank[0] = data; break;
+    case 0x9001: mirror = data & 0x80; break;
+    case 0x9003:
+      irqEnable = data & 0x80;
+      cpu.irqLine(0);
+      break;
+    case 0x9004:
+      irqCounter = irqLatch;
+      cpu.irqLine(0);
+      break;
+    case 0x9005: irqLatch = (irqLatch & 0x00ff) | (data << 8); break;
+    case 0x9006: irqLatch = (irqLatch & 0xff00) | (data << 0); break;
+    case 0xa000:
+    case 0xa001:
+    case 0xa002:
+    case 0xa003:
+    case 0xa004:
+    case 0xa005:
+    case 0xa006:
+    case 0xa007: prgBank[1] = data; break;
+    case 0xb000: chrBank[0] = data; break;
+    case 0xb001: chrBank[1] = data; break;
+    case 0xb002: chrBank[2] = data; break;
+    case 0xb003: chrBank[3] = data; break;
+    case 0xb004: chrBank[4] = data; break;
+    case 0xb005: chrBank[5] = data; break;
+    case 0xb006: chrBank[6] = data; break;
+    case 0xb007: chrBank[7] = data; break;
+    case 0xc000:
+    case 0xc001:
+    case 0xc002:
+    case 0xc003:
+    case 0xc004:
+    case 0xc005:
+    case 0xc006:
+    case 0xc007: prgBank[2] = data; break;
+    }
+  }
+
+  auto power() -> void {
+  }
+
+  auto reset() -> void {
+    prgBank[0] = 0x00;
+    prgBank[1] = 0x01;
+    prgBank[2] = 0xfe;
+    chrBank[0] = 0;
+    chrBank[1] = 0;
+    chrBank[2] = 0;
+    chrBank[3] = 0;
+    chrBank[4] = 0;
+    chrBank[5] = 0;
+    chrBank[6] = 0;
+    chrBank[7] = 0;
+    mirror = 0;
+    irqCounter = 0;
+    irqLatch = 0;
+    irqEnable = false;
+  }
+
+  auto serialize(serializer& s) -> void {
+    s.array(prgBank);
+    s.array(chrBank);
+    s.integer(mirror);
+    s.integer(irqCounter);
+    s.integer(irqLatch);
+    s.integer(irqEnable);
+  }
+
+  bool prgMode;
+  uint8 prgBank[3];
+  uint8 chrBank[8];
+  bool mirror;
+  uint16 irqCounter;
+  uint16 irqLatch;
+  bool irqEnable;
+};
diff --git a/higan/higan/fc/cartridge/chip/mmc1.cpp b/nSide/higan/fc/cartridge/chip/mmc1.cpp
index 92846b9..ff5be44 100644
--- a/higan/higan/fc/cartridge/chip/mmc1.cpp
+++ b/nSide/higan/fc/cartridge/chip/mmc1.cpp
@@ -1,6 +1,14 @@
 struct MMC1 : Chip {
-  MMC1(Board& board) : Chip(board) {
-    revision = Revision::MMC1B2;
+  MMC1(Board& board, Markup::Node& boardNode) : Chip(board) {
+    string type = boardNode["chip/type"].text();
+
+    if(type == "MMC1"    ) revision = Revision::MMC1;
+    if(type == "MMC1A"   ) revision = Revision::MMC1A;
+    if(type == "MMC1B1"  ) revision = Revision::MMC1B1;
+    if(type == "MMC1B1-H") revision = Revision::MMC1B1;
+    if(type == "MMC1B2"  ) revision = Revision::MMC1B2;
+    if(type == "MMC1B3"  ) revision = Revision::MMC1B3;
+    if(type == "MMC1C"   ) revision = Revision::MMC1C;
   }
 
   auto main() -> void {
@@ -8,7 +16,7 @@ struct MMC1 : Chip {
     tick();
   }
 
-  auto addrPRG(uint addr) -> uint {
+  auto prgAddress(uint addr) -> uint {
     bool region = addr & 0x4000;
     uint bank = (prgBank & ~1) + region;
 
@@ -20,14 +28,14 @@ struct MMC1 : Chip {
     return (bank << 14) | (addr & 0x3fff);
   }
 
-  auto addrCHR(uint addr) -> uint {
+  auto chrAddress(uint addr) -> uint {
     bool region = addr & 0x1000;
     uint bank = chrBank[region];
     if(chrMode == 0) bank = (chrBank[0] & ~1) | region;
     return (bank << 12) | (addr & 0x0fff);
   }
 
-  auto addrCIRAM(uint addr) -> uint {
+  auto ciramAddress(uint addr) -> uint {
     switch(mirror) {
     case 0: return 0x0000 | (addr & 0x03ff);
     case 1: return 0x0400 | (addr & 0x03ff);
@@ -36,7 +44,7 @@ struct MMC1 : Chip {
     }
   }
 
-  auto writeIO(uint addr, uint8 data) -> void {
+  auto mmioWrite(uint addr, uint8 data) -> void {
     if(writedelay) return;
     writedelay = 2;
 
@@ -65,7 +73,7 @@ struct MMC1 : Chip {
           break;
 
         case 3:
-          ramDisable = (shiftdata & 0x10);
+          ramDisable = ((shiftdata & 0x10) && revision != Revision::MMC1 && revision != Revision::MMC1A);
           prgBank = (shiftdata & 0x0f);
           break;
         }
@@ -87,7 +95,7 @@ struct MMC1 : Chip {
     mirror = 0;
     chrBank[0] = 0;
     chrBank[1] = 1;
-    ramDisable = 0;
+    ramDisable = revision == Revision::MMC1C;
     prgBank = 0;
   }
 
diff --git a/higan/higan/fc/cartridge/chip/mmc3.cpp b/nSide/higan/fc/cartridge/chip/mmc3.cpp
index e23b605..1aad131 100644
--- a/higan/higan/fc/cartridge/chip/mmc3.cpp
+++ b/nSide/higan/fc/cartridge/chip/mmc3.cpp
@@ -1,15 +1,27 @@
 struct MMC3 : Chip {
-  MMC3(Board& board) : Chip(board) {
+  MMC3(Board& board, Markup::Node& boardNode) : Chip(board) {
+    string type = boardNode["chip/type"].text();
+    if(type == "MMC3"  ) revision = Revision::MMC3;
+    if(type == "MMC3A" ) revision = Revision::MMC3A;
+    if(type == "MMC3B" ) revision = Revision::MMC3B;
+    if(type == "MMC3C" ) revision = Revision::MMC3C;
+    if(type == "MC-ACC") revision = Revision::MC_ACC;
   }
 
   auto main() -> void {
     if(irqDelay) irqDelay--;
+    irqTest(ppu.io.chrAddressBus);
     cpu.irqLine(irqLine);
     tick();
   }
 
   auto irqTest(uint addr) -> void {
-    if(!(chrAbus & 0x1000) && (addr & 0x1000)) {
+    bool edge;
+    if(revision != Revision::MC_ACC)
+      edge = !(chrAddressBus & 0x1000) && (addr & 0x1000);
+    else
+      edge = (chrAddressBus & 0x1000) && !(addr & 0x1000);
+    if(edge) {
       if(irqDelay == 0) {
         if(irqCounter == 0) {
           irqCounter = irqLatch;
@@ -19,10 +31,10 @@ struct MMC3 : Chip {
       }
       irqDelay = 6;
     }
-    chrAbus = addr;
+    chrAddressBus = addr;
   }
 
-  auto addrPRG(uint addr) const -> uint {
+  auto prgAddress(uint addr) const -> uint {
     switch((addr >> 13) & 3) {
     case 0:
       if(prgMode == 1) return (0x3e << 13) | (addr & 0x1fff);
@@ -37,7 +49,7 @@ struct MMC3 : Chip {
     }
   }
 
-  auto addrCHR(uint addr) const -> uint {
+  auto chrAddress(uint addr) const -> uint {
     if(chrMode == 0) {
       if(addr <= 0x07ff) return (chrBank[0] << 10) | (addr & 0x07ff);
       if(addr <= 0x0fff) return (chrBank[1] << 10) | (addr & 0x07ff);
@@ -55,21 +67,21 @@ struct MMC3 : Chip {
     }
   }
 
-  auto addrCIRAM(uint addr) const -> uint {
+  auto ciramAddress(uint addr) const -> uint {
     if(mirror == 0) return ((addr & 0x0400) >> 0) | (addr & 0x03ff);
     if(mirror == 1) return ((addr & 0x0800) >> 1) | (addr & 0x03ff);
   }
 
-  auto readRAM(uint addr) -> uint8 {
-    if(ramEnable) return board.prgram.data[addr & 0x1fff];
+  auto ramRead(uint addr) -> uint8 {
+    if(ramEnable) return board.read(board.prgram, addr & 0x1fff);
     return 0x00;
   }
 
-  auto writeRAM(uint addr, uint8 data) -> void {
-    if(ramEnable && !ramWriteProtect) board.prgram.data[addr & 0x1fff] = data;
+  auto ramWrite(uint addr, uint8 data) -> void {
+    if(ramEnable && !ramWriteProtect) board.write(board.prgram, addr & 0x1fff, data);
   }
 
-  auto writeIO(uint addr, uint8 data) -> void {
+  auto regWrite(uint addr, uint8 data) -> void {
     switch(addr & 0xe001) {
     case 0x8000:
       chrMode = data & 0x80;
@@ -142,7 +154,7 @@ struct MMC3 : Chip {
     irqDelay = 0;
     irqLine = 0;
 
-    chrAbus = 0;
+    chrAddressBus = 0;
   }
 
   auto serialize(serializer& s) -> void {
@@ -160,9 +172,17 @@ struct MMC3 : Chip {
     s.integer(irqDelay);
     s.integer(irqLine);
 
-    s.integer(chrAbus);
+    s.integer(chrAddressBus);
   }
 
+  enum class Revision : uint {
+    MMC3,
+    MMC3A,
+    MMC3B,
+    MMC3C,
+    MC_ACC,
+  } revision;
+
   bool chrMode;
   bool prgMode;
   uint3 bankSelect;
@@ -177,5 +197,5 @@ struct MMC3 : Chip {
   uint irqDelay;
   bool irqLine;
 
-  uint16 chrAbus;
+  uint16 chrAddressBus;
 };
diff --git a/higan/higan/fc/cartridge/chip/mmc5.cpp b/nSide/higan/fc/cartridge/chip/mmc5.cpp
index 1bddfa6..1c70016 100644
--- a/higan/higan/fc/cartridge/chip/mmc5.cpp
+++ b/nSide/higan/fc/cartridge/chip/mmc5.cpp
@@ -1,6 +1,9 @@
 struct MMC5 : Chip {
-  MMC5(Board& board) : Chip(board) {
-    revision = Revision::MMC5;
+  MMC5(Board& board, Markup::Node& boardNode) : Chip(board) {
+    string type = boardNode["chip/type"].text();
+
+    if(type == "MMC5" ) revision = Revision::MMC5;
+    if(type == "MMC5B") revision = Revision::MMC5B;
   }
 
   auto main() -> void {
@@ -16,7 +19,7 @@ struct MMC5 : Chip {
   //if(y != vcounter && y <= 240) print(y, " vs ", vcounter, "\n");
   }
 
-  auto accessPRG(bool write, uint addr, uint8 data = 0x00) -> uint8 {
+  auto prgAccess(bool write, uint addr, uint8 data = 0x00) -> uint8 {
     uint bank;
 
     if((addr & 0xe000) == 0x6000) {
@@ -48,16 +51,16 @@ struct MMC5 : Chip {
 
     if(write == false) {
       if(rom) {
-        return board.prgrom.read((bank << 13) | addr);
+        return board.read(board.prgrom, (bank << 13) | addr);
       } else {
-        return board.prgram.read((bank << 13) | addr);
+        return board.read(board.prgram, (bank << 13) | addr);
       }
     } else {
       if(rom) {
-        board.prgrom.write((bank << 13) | addr, data);
+        board.write(board.prgrom, (bank << 13) | addr, data);
       } else {
         if(prgramWriteProtect[0] == 2 && prgramWriteProtect[1] == 1) {
-          board.prgram.write((bank << 13) | addr, data);
+          board.write(board.prgram, (bank << 13) | addr, data);
         }
       }
       return 0x00;
@@ -66,12 +69,12 @@ struct MMC5 : Chip {
 
   auto readPRG(uint addr) -> uint8 {
     if((addr & 0xfc00) == 0x5c00) {
-      if(exramMode >= 2) return exram[addr & 0x03ff];
+      if(exramMode >= 2) return ram.read(addr & 0x03ff);
       return cpu.mdr();
     }
 
     if(addr >= 0x6000) {
-      return accessPRG(0, addr);
+      return prgAccess(0, addr);
     }
 
     switch(addr) {
@@ -88,25 +91,27 @@ struct MMC5 : Chip {
   auto writePRG(uint addr, uint8 data) -> void {
     if((addr & 0xfc00) == 0x5c00) {
       //writes 0x00 *during* Vblank (not during screen rendering ...)
-      if(exramMode == 0 || exramMode == 1) exram[addr & 0x03ff] = inFrame ? data : (uint8)0x00;
-      if(exramMode == 2) exram[addr & 0x03ff] = data;
+      if(exramMode == 0 || exramMode == 1) ram.write(addr & 0x03ff, inFrame ? data : (uint8)0x00);
+      if(exramMode == 2) ram.write(addr & 0x03ff, data);
       return;
     }
 
     if(addr >= 0x6000) {
-      accessPRG(1, addr, data);
+      prgAccess(1, addr, data);
       return;
     }
 
     switch(addr) {
-    case 0x2000:
-      sprite8x16 = data & 0x20;
+    case 0x2000: {
+      sprite_8x16 = data & 0x20;
       break;
+    }
 
-    case 0x2001:
+    case 0x2001: {
       //if BG+sprites are disabled; enter video blanking period
       if((data & 0x18) == 0) blank();
       break;
+    }
 
     case 0x5100: prgMode = data & 3; break;
     case 0x5101: chrMode = data & 3; break;
@@ -114,31 +119,36 @@ struct MMC5 : Chip {
     case 0x5102: prgramWriteProtect[0] = data & 3; break;
     case 0x5103: prgramWriteProtect[1] = data & 3; break;
 
-    case 0x5104:
+    case 0x5104: {
       exramMode = data & 3;
       break;
+    }
 
-    case 0x5105:
+    case 0x5105: {
       nametableMode[0] = (data & 0x03) >> 0;
       nametableMode[1] = (data & 0x0c) >> 2;
       nametableMode[2] = (data & 0x30) >> 4;
       nametableMode[3] = (data & 0xc0) >> 6;
       break;
+    }
 
-    case 0x5106:
+    case 0x5106: {
       fillmodeTile = data;
       break;
+    }
 
-    case 0x5107:
+    case 0x5107: {
       fillmodeColor = data & 3;
       fillmodeColor |= fillmodeColor << 2;
       fillmodeColor |= fillmodeColor << 4;
       break;
+    }
 
-    case 0x5113:
+    case 0x5113: {
       ramSelect = data & 0x04;
       ramBank = data & 0x03;
       break;
+    }
 
     case 0x5114: prgBank[0] = data; break;
     case 0x5115: prgBank[1] = data; break;
@@ -159,43 +169,52 @@ struct MMC5 : Chip {
     case 0x512a: chrBGBank[2] = (chrBankHi << 8) | data; chrActive = 1; break;
     case 0x512b: chrBGBank[3] = (chrBankHi << 8) | data; chrActive = 1; break;
 
-    case 0x5130:
+    case 0x5130: {
       chrBankHi = data & 3;
       break;
+    }
 
-    case 0x5200:
+    case 0x5200: {
       vsEnable = data & 0x80;
       vsSide = data & 0x40;
       vsTile = data & 0x1f;
       break;
+    }
 
-    case 0x5201:
+    case 0x5201: {
       vsScroll = data;
       break;
+    }
 
-    case 0x5202:
+    case 0x5202: {
       vsBank = data;
       break;
+    }
 
-    case 0x5203:
+    case 0x5203: {
       irqLine = data;
       break;
+    }
 
-    case 0x5204:
+    case 0x5204: {
       irqEnable = data & 0x80;
       break;
+    }
 
-    case 0x5205:
+    case 0x5205: {
       multiplicand = data;
       break;
+    }
 
-    case 0x5206:
+    case 0x5206: {
       multiplier = data;
       break;
     }
+
+    }
   }
 
-  auto chrSpriteAddr(uint addr) -> uint {
+  auto chrOBJAddress(uint addr) -> uint {
     if(chrMode == 0) {
       auto bank = chrSpriteBank[7];
       return (bank * 0x2000) + (addr & 0x1fff);
@@ -217,14 +236,14 @@ struct MMC5 : Chip {
     }
   }
 
-  auto chrBGAddr(uint addr) -> uint {
-    addr &= 0x0fff;
-
+  auto chrBGAddress(uint addr) -> uint {
     if(chrMode == 0) {
       auto bank = chrBGBank[3];
-      return (bank * 0x2000) + (addr & 0x0fff);
+      return (bank * 0x2000) + (addr & 0x1fff);
     }
 
+    addr &= 0x0fff;
+
     if(chrMode == 1) {
       auto bank = chrBGBank[3];
       return (bank * 0x1000) + (addr & 0x0fff);
@@ -241,8 +260,8 @@ struct MMC5 : Chip {
     }
   }
 
-  auto chrVSAddr(uint addr) -> uint {
-    return (vsBank * 0x1000) + (addr & 0x0ff8) + (vsVpos & 7);
+  auto chrVerticalSplitAddress(uint addr) -> uint {
+    return (vsBank * 0x1000) + (addr & 0x0ff8) + (vsVPos & 7);
   }
 
   auto blank() -> void {
@@ -264,14 +283,14 @@ struct MMC5 : Chip {
     cpuCycleCounter = 0;
   }
 
-  auto readCIRAM(uint addr) -> uint8 {
-    if(vsFetch && (hcounter & 2) == 0) return exram[vsVpos / 8 * 32 + vsHpos / 8];
-    if(vsFetch && (hcounter & 2) != 0) return exram[vsVpos / 32 * 8 + vsHpos / 32 + 0x03c0];
+  auto ciramRead(uint addr) -> uint8 {
+    if(vsFetch && (hcounter & 2) == 0) return ram.read(vsVPos / 8 * 32 + vsHPos / 8);
+    if(vsFetch && (hcounter & 2) != 0) return ram.read(vsVPos / 32 * 8 + vsHPos / 32 + 0x03c0);
 
     switch(nametableMode[(addr >> 10) & 3]) {
     case 0: return ppu.readCIRAM(0x0000 | (addr & 0x03ff));
     case 1: return ppu.readCIRAM(0x0400 | (addr & 0x03ff));
-    case 2: return exramMode < 2 ? exram[addr & 0x03ff] : (uint8)0x00;
+    case 2: return exramMode < 2 ? ram.read(addr & 0x03ff) : (uint8)0x00;
     case 3: return (hcounter & 2) == 0 ? fillmodeTile : fillmodeColor;
     }
   }
@@ -290,34 +309,34 @@ struct MMC5 : Chip {
 
     if(inFrame == false) {
       vsFetch = false;
-      if(addr & 0x2000) return readCIRAM(addr);
-      return board.chrrom.read(chrActive ? chrBGAddr(addr) : chrSpriteAddr(addr));
+      if(addr & 0x2000) return ciramRead(addr);
+      return board.read(board.chrrom, (chrActive ? chrBGAddress(addr) : chrOBJAddress(addr)));
     }
 
     bool bgFetch = (hcounter < 256 || hcounter >= 320);
     uint8 result = 0x00;
 
     if((hcounter & 7) == 0) {
-      vsHpos  = hcounter >= 320 ? hcounter - 320 : hcounter + 16;
-      vsVpos  = vcounter + vsScroll;
+      vsHPos  = hcounter >= 320 ? hcounter - 320 : hcounter + 16;
+      vsVPos  = vcounter + vsScroll;
       vsFetch = vsEnable && bgFetch && exramMode < 2
-      && (vsSide ? vsHpos / 8 >= vsTile : vsHpos / 8 < vsTile);
-      if(vsVpos >= 240) vsVpos -= 240;
+      && (vsSide ? vsHPos / 8 >= vsTile : vsHPos / 8 < vsTile);
+      if(vsVPos >= 240) vsVPos -= 240;
 
-      result = readCIRAM(addr);
+      result = ciramRead(addr);
 
-      exbank = (chrBankHi << 6) | (exram[addr & 0x03ff] & 0x3f);
-      exattr = exram[addr & 0x03ff] >> 6;
+      exbank = (chrBankHi << 6) | (ram.read(addr & 0x03ff) & 0x3f);
+      exattr = ram.read(addr & 0x03ff) >> 6;
       exattr |= exattr << 2;
       exattr |= exattr << 4;
     } else if((hcounter & 7) == 2) {
-      result = readCIRAM(addr);
+      result = ciramRead(addr);
       if(bgFetch && exramMode == 1) result = exattr;
     } else {
-      if(vsFetch) result = board.chrrom.read(chrVSAddr(addr));
-      else if(sprite8x16 ? bgFetch : chrActive) result = board.chrrom.read(chrBGAddr(addr));
-      else result = board.chrrom.read(chrSpriteAddr(addr));
-      if(bgFetch && exramMode == 1) result = board.chrrom.read(exbank * 0x1000 + (addr & 0x0fff));
+      if(vsFetch) result = board.read(board.chrrom, (chrVerticalSplitAddress(addr)));
+      else if(sprite_8x16 ? bgFetch : chrActive) result = board.read(board.chrrom, (chrBGAddress(addr)));
+      else result = board.read(board.chrrom, (chrOBJAddress(addr)));
+      if(bgFetch && exramMode == 1) result = board.read(board.chrrom, (exbank * 0x1000 + (addr & 0x0fff)));
     }
 
     hcounter += 2;
@@ -329,7 +348,7 @@ struct MMC5 : Chip {
       switch(nametableMode[(addr >> 10) & 3]) {
       case 0: return ppu.writeCIRAM(0x0000 | (addr & 0x03ff), data);
       case 1: return ppu.writeCIRAM(0x0400 | (addr & 0x03ff), data);
-      case 2: exram[addr & 0x03ff] = data; break;
+      case 2: ram.write(addr & 0x03ff, data); break;
       }
     }
   }
@@ -338,7 +357,7 @@ struct MMC5 : Chip {
   }
 
   auto reset() -> void {
-    for(auto& n : exram) n = 0xff;
+    for(uint i = 0; i < ram.size(); i++) ram.write(i, 0xff);
 
     prgMode = 3;
     chrMode = 0;
@@ -374,18 +393,18 @@ struct MMC5 : Chip {
     hcounter = 0;
     for(auto& n : chrAccess) n = 0;
     chrActive = 0;
-    sprite8x16 = 0;
+    sprite_8x16 = 0;
 
     exbank = 0;
     exattr = 0;
 
     vsFetch = 0;
-    vsVpos = 0;
-    vsHpos = 0;
+    vsVPos = 0;
+    vsHPos = 0;
   }
 
   auto serialize(serializer& s) -> void {
-    s.array(exram);
+    s.array(ram.data(), ram.size());
 
     s.integer(prgMode);
     s.integer(chrMode);
@@ -419,14 +438,14 @@ struct MMC5 : Chip {
     s.integer(hcounter);
     for(auto& n : chrAccess) s.integer(n);
     s.integer(chrActive);
-    s.integer(sprite8x16);
+    s.integer(sprite_8x16);
 
     s.integer(exbank);
     s.integer(exattr);
 
     s.integer(vsFetch);
-    s.integer(vsVpos);
-    s.integer(vsHpos);
+    s.integer(vsVPos);
+    s.integer(vsHPos);
   }
 
   enum class Revision : uint {
@@ -434,8 +453,6 @@ struct MMC5 : Chip {
     MMC5B,
   } revision;
 
-  uint8 exram[1024];
-
   //programmable registers
 
   uint2 prgMode;  //$5100
@@ -448,9 +465,9 @@ struct MMC5 : Chip {
   uint8 fillmodeTile;      //$5106
   uint8 fillmodeColor;     //$5107
 
-  bool ramSelect;           //$5113
-  uint2 ramBank;            //$5113
-  uint8 prgBank[4];         //$5114-5117
+  bool ramSelect;            //$5113
+  uint2 ramBank;             //$5113
+  uint8 prgBank[4];          //$5114-5117
   uint10 chrSpriteBank[8];  //$5120-5127
   uint10 chrBGBank[4];      //$5128-512b
   uint2 chrBankHi;          //$5130
@@ -478,12 +495,12 @@ struct MMC5 : Chip {
   uint hcounter;
   uint16 chrAccess[4];
   bool chrActive;
-  bool sprite8x16;
+  bool sprite_8x16;
 
   uint8 exbank;
   uint8 exattr;
 
   bool vsFetch;
-  uint8 vsVpos;
-  uint8 vsHpos;
+  uint8 vsVPos;
+  uint8 vsHPos;
 };
diff --git a/higan/higan/fc/cartridge/chip/mmc6.cpp b/nSide/higan/fc/cartridge/chip/mmc6.cpp
index f21c95d..3fb9b17 100644
--- a/higan/higan/fc/cartridge/chip/mmc6.cpp
+++ b/nSide/higan/fc/cartridge/chip/mmc6.cpp
@@ -9,7 +9,7 @@ struct MMC6 : Chip {
   }
 
   auto irqTest(uint addr) -> void {
-    if(!(chrAbus & 0x1000) && (addr & 0x1000)) {
+    if(!(chrAddressBus & 0x1000) && (addr & 0x1000)) {
       if(irqDelay == 0) {
         if(irqCounter == 0) {
           irqCounter = irqLatch;
@@ -19,10 +19,10 @@ struct MMC6 : Chip {
       }
       irqDelay = 6;
     }
-    chrAbus = addr;
+    chrAddressBus = addr;
   }
 
-  auto addrPRG(uint addr) const -> uint {
+  auto prgAddress(uint addr) const -> uint {
     switch((addr >> 13) & 3) {
     case 0:
       if(prgMode == 1) return (0x3e << 13) | (addr & 0x1fff);
@@ -37,7 +37,7 @@ struct MMC6 : Chip {
     }
   }
 
-  auto addrCHR(uint addr) const -> uint {
+  auto chrAddress(uint addr) const -> uint {
     if(chrMode == 0) {
       if(addr <= 0x07ff) return (chrBank[0] << 10) | (addr & 0x07ff);
       if(addr <= 0x0fff) return (chrBank[1] << 10) | (addr & 0x07ff);
@@ -55,27 +55,27 @@ struct MMC6 : Chip {
     }
   }
 
-  auto addrCIRAM(uint addr) const -> uint {
+  auto ciramAddress(uint addr) const -> uint {
     if(mirror == 0) return ((addr & 0x0400) >> 0) | (addr & 0x03ff);
     if(mirror == 1) return ((addr & 0x0800) >> 1) | (addr & 0x03ff);
   }
 
-  auto readRAM(uint addr) -> uint8 {
+  auto ramRead(uint addr) -> uint8 {
     if(ramEnable == false) return cpu.mdr();
     if(ramReadable[0] == false && ramReadable[1] == false) return cpu.mdr();
     bool region = addr & 0x0200;
     if(ramReadable[region] == false) return 0x00;
-    return board.prgram.read((region * 0x0200) + (addr & 0x01ff));
+    return board.read(board.prgram, (region * 0x0200) + (addr & 0x01ff));
   }
 
-  auto writeRAM(uint addr, uint8 data) -> void {
+  auto ramWrite(uint addr, uint8 data) -> void {
     if(ramEnable == false) return;
     bool region = addr & 0x0200;
     if(ramWritable[region] == false) return;
-    return board.prgram.write((region * 0x0200) + (addr & 0x01ff), data);
+    return board.write(board.prgram, (region * 0x0200) + (addr & 0x01ff), data);
   }
 
-  auto writeIO(uint addr, uint8 data) -> void {
+  auto regWrite(uint addr, uint8 data) -> void {
     switch(addr & 0xe001) {
     case 0x8000:
       chrMode = data & 0x80;
@@ -151,7 +151,7 @@ struct MMC6 : Chip {
     irqDelay = 0;
     irqLine = 0;
 
-    chrAbus = 0;
+    chrAddressBus = 0;
   }
 
   auto serialize(serializer& s) -> void {
@@ -170,7 +170,7 @@ struct MMC6 : Chip {
     s.integer(irqDelay);
     s.integer(irqLine);
 
-    s.integer(chrAbus);
+    s.integer(chrAddressBus);
   }
 
   bool chrMode;
@@ -188,5 +188,5 @@ struct MMC6 : Chip {
   uint irqDelay;
   bool irqLine;
 
-  uint16 chrAbus;
+  uint16 chrAddressBus;
 };
diff --git a/nSide/higan/fc/cartridge/chip/n108.cpp b/nSide/higan/fc/cartridge/chip/n108.cpp
new file mode 100644
index 0000000..846cfaa
--- /dev/null
+++ b/nSide/higan/fc/cartridge/chip/n108.cpp
@@ -0,0 +1,81 @@
+struct N108 : Chip {
+  N108(Board& board, Markup::Node& boardNode) : Chip(board) {
+    string type = boardNode["chip/type"].text();
+
+    if(type.match("*108*")) revision = Revision::N108;
+    if(type.match("*109*")) revision = Revision::N109;
+    if(type.match("*118*")) revision = Revision::N118;
+    if(type.match("*119*")) revision = Revision::N119;
+  }
+
+  auto prgAddress(uint addr) const -> uint {
+    switch((addr >> 13) & 3) {
+    case 0: return (prgBank[0] << 13) | (addr & 0x1fff);
+    case 1: return (prgBank[1] << 13) | (addr & 0x1fff);
+    case 2: return (0x0e << 13) | (addr & 0x1fff);
+    case 3: return (0x0f << 13) | (addr & 0x1fff);
+    }
+  }
+
+  auto chrAddress(uint addr) const -> uint {
+    if(addr <= 0x07ff) return (chrBank[0] << 10) | (addr & 0x07ff);
+    if(addr <= 0x0fff) return (chrBank[1] << 10) | (addr & 0x07ff);
+    if(addr <= 0x13ff) return (chrBank[2] << 10) | (addr & 0x03ff);
+    if(addr <= 0x17ff) return (chrBank[3] << 10) | (addr & 0x03ff);
+    if(addr <= 0x1bff) return (chrBank[4] << 10) | (addr & 0x03ff);
+    if(addr <= 0x1fff) return (chrBank[5] << 10) | (addr & 0x03ff);
+  }
+
+  auto regWrite(uint addr, uint8 data) -> void {
+    switch(addr & 0x8001) {
+    case 0x8000:
+      bankSelect = data & 0x07;
+      break;
+
+    case 0x8001:
+      switch(bankSelect) {
+      case 0: chrBank[0] = data & 0x3e; break;
+      case 1: chrBank[1] = data & 0x3e; break;
+      case 2: chrBank[2] = data & 0x3f; break;
+      case 3: chrBank[3] = data & 0x3f; break;
+      case 4: chrBank[4] = data & 0x3f; break;
+      case 5: chrBank[5] = data & 0x3f; break;
+      case 6: prgBank[0] = data & 0x0f; break;
+      case 7: prgBank[1] = data & 0x0f; break;
+      }
+      break;
+    }
+  }
+
+  auto power() -> void {
+  }
+
+  auto reset() -> void {
+    bankSelect = 0;
+    prgBank[0] = 0;
+    prgBank[1] = 0;
+    chrBank[0] = 0;
+    chrBank[1] = 0;
+    chrBank[2] = 0;
+    chrBank[3] = 0;
+    chrBank[4] = 0;
+    chrBank[5] = 0;
+  }
+
+  auto serialize(serializer& s) -> void {
+    s.integer(bankSelect);
+    s.array(prgBank);
+    s.array(chrBank);
+  }
+
+  enum class Revision : uint {
+    N108,
+    N109,
+    N118,
+    N119,
+  } revision;
+
+  uint3 bankSelect;
+  uint8 prgBank[2];
+  uint8 chrBank[6];
+};
diff --git a/nSide/higan/fc/cartridge/chip/n163.cpp b/nSide/higan/fc/cartridge/chip/n163.cpp
new file mode 100644
index 0000000..0f87aed
--- /dev/null
+++ b/nSide/higan/fc/cartridge/chip/n163.cpp
@@ -0,0 +1,217 @@
+struct N163 : Chip {
+  N163(Board& board, Markup::Node& boardNode) : Chip(board) {
+    string type = boardNode["chip/type"].text();
+
+    if(type == "129") revision = Revision::N129;
+    if(type == "163") revision = Revision::N163;
+    if(type == "175") revision = Revision::N175;
+    if(type == "340") revision = Revision::N340;
+  }
+
+  auto main() -> void {
+    if(!audioDisable) {
+      if(++audioChannelTimer == 15) {
+        audioChannelTimer = 0;
+      }
+    }
+    tick();
+  }
+
+  auto readPRG(uint addr) -> uint8 {
+    switch(addr & 0xf800) {
+    case 0x4800:
+      if(revision == Revision::N129 || revision == Revision::N163) {
+        uint8 byte = ram.read(audioAddress);
+        if(audioAutoIncrement) audioAddress++;
+        return byte;
+      }
+      break;
+    case 0x5000: return irqCounter & 0xff;
+    case 0x5800: return ((irqCounter >> 8) & 0x7f) | (irqEnable << 7);
+    case 0x6000: case 0x6800: case 0x7000: case 0x7800:
+      if(ramEnable) return board.read(board.prgram, addr & 0x1fff);
+    case 0x8000: case 0x8800: case 0x9000: case 0x9800:
+    case 0xa000: case 0xa800: case 0xb000: case 0xb800:
+    case 0xc000: case 0xc800: case 0xd000: case 0xd800:
+      return board.read(board.prgrom, (prgBank[(addr & 0x6000) >> 13] << 13) | (addr & 0x1fff));
+    case 0xe000: case 0xe800: case 0xf000: case 0xf800:
+      return board.read(board.prgrom, (0x3f << 13) | (addr & 0x1fff));
+    default: return cpu.mdr();
+    }
+  }
+
+  auto writePRG(uint addr, uint8 data) -> void {
+    if((addr & 0xe000) == 0x6000) {
+      if(ramEnable) {
+        board.write(board.prgram, addr & 0x1fff, data);
+      }
+    } else regWrite(addr, data);
+  }
+
+  auto regWrite(uint addr, uint8 data) -> void {
+    switch(addr & 0xf800) {
+    case 0x4800: // Audio
+      if(revision == Revision::N129 || revision == Revision::N163) {
+        ram.write(audioAddress, data);
+        if(audioAutoIncrement) audioAddress++;
+      }
+      break;
+    case 0x5000: // IRQ Low
+      if(revision == Revision::N129 || revision == Revision::N163) {
+        irqCounter = (irqCounter & 0xff00) | data;
+        cpu.irqLine(0);
+      }
+      break;
+    case 0x5800: // IRQ High
+      if(revision == Revision::N129 || revision == Revision::N163) {
+        irqCounter = (irqCounter & 0x00ff) | ((data & 0x7f) << 8);
+        irqEnable = data & 0x80;
+        cpu.irqLine(0);
+      }
+      break;
+    case 0x8000: case 0x8800: case 0x9000: case 0x9800: // CHR Select
+    case 0xa000: case 0xa800: case 0xb000: case 0xb800:
+      chrBank[(addr & 0x7800) >> 11] = data;
+      break;
+    case 0xc000: // Nametable Select/RAM Enable
+      if(revision == Revision::N175) {
+        ramEnable = data & 0x01;
+      }
+    case 0xc800: case 0xd000: case 0xd800: // Nametable Select
+      if(revision == Revision::N129 || revision == Revision::N163) {
+        chrBank[(addr & 0x7800) >> 11] = data;
+      }
+      break;
+    case 0xe000: // PRG Select 8000
+      prgBank[0] = data & 0x3f;
+      if(revision == Revision::N129 || revision == Revision::N163) {
+        audioDisable = data & 0x40;
+      } else if(revision == Revision::N340) {
+        mirror = (data & 0xc0) >> 6;
+      }
+      break;
+    case 0xe800: // PRG Select A000
+      prgBank[1] = data & 0x3f;
+      if(revision == Revision::N129 || revision == Revision::N163) {
+        chrramDisable = (data & 0xc0) >> 6;
+      }
+      break;
+    case 0xf000: // PRG Select C000
+      prgBank[2] = data & 0x3f;
+      break;
+    case 0xf800: // Sound RAM Address/Write Protection for External RAM
+      if(revision == Revision::N129 || revision == Revision::N163) {
+        audioAddress = data & 0x7f;
+        audioAutoIncrement = data & 0x80;
+      }
+      break;
+    }
+  }
+
+  auto ciramAddress(uint addr) -> uint {
+    switch(mirror) {
+    case 0: return (addr & 0x03ff) | (0x0000);
+    case 1: return (addr & 0x03ff) | ((addr & 0x400) >> 0);
+    case 2: return (addr & 0x03ff) | ((addr & 0x800) >> 1);
+    case 3: return (addr & 0x03ff) | (0x0400);
+    }
+  }
+
+  auto readCHR(uint addr) -> uint8 {
+    if(addr & 0x2000) {
+      if(revision == Revision::N175 || revision == Revision::N340) {
+        return ppu.readCIRAM(ciramAddress(addr));
+      }
+      addr &= 0x2fff;
+    }
+    uint8 bank = chrBank[(addr & 0x3c00) >> 10];
+    if(bank >= 0xe0 && ((addr & 0x2000) | !(chrramDisable & (1 << ((addr & 0x1000) >> 12))))) {
+      addr = (addr & 0x03ff) | (bank << 10);
+      if(board.chrram.size()) return board.read(board.chrram, addr);
+      else                    return ppu.readCIRAM(addr);
+    } else return board.read(board.chrrom, ((bank << 10) | (addr & 0x3ff)));
+  }
+
+  auto writeCHR(uint addr, uint8 data) -> void {
+    if(addr & 0x2000) {
+      if(revision == Revision::N175 || revision == Revision::N340) {
+        return ppu.writeCIRAM(ciramAddress(addr), data);
+      }
+      addr &= 0x2fff;
+    }
+    uint8 bank = chrBank[(addr & 0x3c00) >> 10];
+    if(bank >= 0xe0 && ((addr & 0x2000) | !(chrramDisable & (1 << ((addr & 0x1000) >> 12))))) {
+      addr = (addr & 0x03ff) | (bank << 10);
+      if(board.chrram.size()) return board.write(board.chrram, addr, data);
+      else                    return ppu.writeCIRAM(addr, data);
+    }
+  }
+
+  auto serialize(serializer& s) -> void {
+    s.array(ram.data(), ram.size());
+
+    s.array(prgBank);
+    s.array(chrBank);
+    if(revision == Revision::N129 || revision == Revision::N163) {
+      s.integer(irqCounter);
+      s.integer(irqEnable);
+      s.integer(chrramDisable);
+      s.integer(audioDisable);
+      s.integer(audioAddress);
+      s.integer(audioAutoIncrement);
+    } else if(revision == Revision::N175) {
+      s.integer(ramEnable);
+    } else if(revision == Revision::N340) {
+      s.integer(mirror);
+    }
+  }
+
+  auto power() -> void {
+  }
+
+  auto reset() -> void {
+    prgBank[0] = 0;
+    prgBank[1] = 0;
+    prgBank[2] = 0;
+    chrBank[0] = 0;
+    chrBank[1] = 0;
+    chrBank[2] = 0;
+    chrBank[3] = 0;
+    chrBank[4] = 0;
+    chrBank[5] = 0;
+    chrBank[6] = 0;
+    chrBank[7] = 0;
+    chrBank[8] = 0;
+    chrBank[9] = 0;
+    chrBank[10] = 0;
+    chrBank[11] = 0;
+    irqCounter = 0;
+    irqEnable = false;
+    chrramDisable = 0;
+    audioDisable = true;
+    audioAddress = 0x00;
+    audioAutoIncrement = false;
+    ramEnable = revision != Revision::N175;
+    mirror = 0;
+  }
+
+  enum class Revision : uint {
+    N129,
+    N163,
+    N175,
+    N340,
+  } revision;
+
+  uint6 prgBank[3];
+  uint8 chrBank[12];
+  uint15 irqCounter;
+  bool irqEnable;
+  uint2 chrramDisable;
+  bool audioDisable;
+  uint7 audioAddress;
+  bool audioAutoIncrement;
+  uint3 audioChannel;
+  uint4 audioChannelTimer;
+  bool ramEnable;
+  uint2 mirror;
+};
diff --git a/nSide/higan/fc/cartridge/chip/ss88006.cpp b/nSide/higan/fc/cartridge/chip/ss88006.cpp
new file mode 100644
index 0000000..7b8f1ca
--- /dev/null
+++ b/nSide/higan/fc/cartridge/chip/ss88006.cpp
@@ -0,0 +1,135 @@
+struct SS88006 : Chip {
+  SS88006(Board& board, Markup::Node& boardNode) : Chip(board) {
+  }
+
+  auto main() -> void {
+    if(irqEnable) {
+      irqCounter = (irqCounter & ~irqMask) | ((irqCounter - 1) & irqMask);
+      if((irqCounter & irqMask) == irqMask) cpu.irqLine(1);
+    }
+    tick();
+  }
+
+  auto prgAddress(uint addr) const -> uint {
+    switch((addr >> 13) & 3) {
+    case 0: return (prgBank[0] << 13) | (addr & 0x1fff);
+    case 1: return (prgBank[1] << 13) | (addr & 0x1fff);
+    case 2: return (prgBank[2] << 13) | (addr & 0x1fff);
+    case 3: return (0xff << 13) | (addr & 0x1fff);
+    }
+  }
+
+  auto chrAddress(uint addr) const -> uint {
+    return (chrBank[addr >> 10] << 10) | (addr & 0x03ff);
+  }
+
+  auto ciramAddress(uint addr) const -> uint {
+    switch(mirror) {
+    case 0: return (addr & 0x03ff) | ((addr & 0x0800) >> 1);
+    case 1: return (addr & 0x03ff) | ((addr & 0x0400) >> 0);
+    case 2: return (addr & 0x03ff) | 0x0000;
+    case 3: return (addr & 0x03ff) | 0x0400;
+    }
+  }
+
+  auto ramRead(uint addr) -> uint8 {
+    if(ramEnable) return board.read(board.prgram, addr & 0x1fff);
+  }
+
+  auto ramWrite(uint addr, uint8 data) -> void {
+    if(ramEnable && ramWriteEnable) board.write(board.prgram, addr & 0x1fff, data);
+  }
+
+  auto regWrite(uint addr, uint8 data) -> void {
+    data &= 0x0f;
+    switch(addr & 0xf003) {
+    case 0x8000: prgBank[0] = (prgBank[0] & 0xf0) | (data << 0); break;
+    case 0x8001: prgBank[0] = (prgBank[0] & 0x0f) | (data << 4); break;
+    case 0x8002: prgBank[1] = (prgBank[1] & 0xf0) | (data << 0); break;
+    case 0x8003: prgBank[1] = (prgBank[1] & 0x0f) | (data << 4); break;
+    case 0x9000: prgBank[2] = (prgBank[2] & 0xf0) | (data << 0); break;
+    case 0x9001: prgBank[2] = (prgBank[2] & 0x0f) | (data << 4); break;
+    case 0x9002:
+      ramEnable = data & 0x01;
+      ramWriteEnable = data & 0x02;
+      break;
+    case 0xa000: chrBank[0] = (chrBank[0] & 0xf0) | (data << 0); break;
+    case 0xa001: chrBank[0] = (chrBank[0] & 0x0f) | (data << 4); break;
+    case 0xa002: chrBank[1] = (chrBank[1] & 0xf0) | (data << 0); break;
+    case 0xa003: chrBank[1] = (chrBank[1] & 0x0f) | (data << 4); break;
+    case 0xb000: chrBank[2] = (chrBank[2] & 0xf0) | (data << 0); break;
+    case 0xb001: chrBank[2] = (chrBank[2] & 0x0f) | (data << 4); break;
+    case 0xb002: chrBank[3] = (chrBank[3] & 0xf0) | (data << 0); break;
+    case 0xb003: chrBank[3] = (chrBank[3] & 0x0f) | (data << 4); break;
+    case 0xc000: chrBank[4] = (chrBank[4] & 0xf0) | (data << 0); break;
+    case 0xc001: chrBank[4] = (chrBank[4] & 0x0f) | (data << 4); break;
+    case 0xc002: chrBank[5] = (chrBank[5] & 0xf0) | (data << 0); break;
+    case 0xc003: chrBank[5] = (chrBank[5] & 0x0f) | (data << 4); break;
+    case 0xd000: chrBank[6] = (chrBank[6] & 0xf0) | (data << 0); break;
+    case 0xd001: chrBank[6] = (chrBank[6] & 0x0f) | (data << 4); break;
+    case 0xd002: chrBank[7] = (chrBank[7] & 0xf0) | (data << 0); break;
+    case 0xd003: chrBank[7] = (chrBank[7] & 0x0f) | (data << 4); break;
+    case 0xe000: irqLatch = (irqLatch & 0xfff0) | (data << 0x0); break;
+    case 0xe001: irqLatch = (irqLatch & 0xff0f) | (data << 0x4); break;
+    case 0xe002: irqLatch = (irqLatch & 0xf0ff) | (data << 0x8); break;
+    case 0xe003: irqLatch = (irqLatch & 0x0fff) | (data << 0xc); break;
+    case 0xf000:
+      cpu.irqLine(0);
+      irqCounter = irqLatch;
+      break;
+    case 0xf001:
+      cpu.irqLine(0);
+      irqEnable = data & 0x01;
+      irqMask = data & 0x08 ? 0x000f : (data & 0x04 ? 0x00ff : (data & 0x02 ? 0x0fff : 0xffff));
+      break;
+    case 0xf002: mirror = data & 0x03; break;
+    case 0xf003: break; //TODO: μPD7756C ADPCM sound IC
+    }
+  }
+
+  auto power() -> void {
+  }
+
+  auto reset() -> void {
+    prgBank[0] = 0;
+    prgBank[1] = 0;
+    prgBank[2] = 0;
+    chrBank[0] = 0;
+    chrBank[1] = 0;
+    chrBank[2] = 0;
+    chrBank[3] = 0;
+    chrBank[4] = 0;
+    chrBank[5] = 0;
+    chrBank[6] = 0;
+    chrBank[7] = 0;
+    mirror = 0;
+    ramEnable = 0;
+    ramWriteEnable = 0;
+    irqCounter = 0;
+    irqLatch = 0;
+    irqEnable = false;
+    irqMask = 0xffff;
+  }
+
+  auto serialize(serializer& s) -> void {
+    s.array(prgBank);
+    s.array(chrBank);
+    s.integer(mirror);
+    s.integer(ramEnable);
+    s.integer(ramWriteEnable);
+    s.integer(irqCounter);
+    s.integer(irqLatch);
+    s.integer(irqEnable);
+    s.integer(irqMask);
+  }
+
+  uint8 prgBank[3];
+  uint8 chrBank[8];
+  uint2 mirror;
+  bool ramEnable;
+  bool ramWriteEnable;
+  uint16 irqCounter;
+  uint16 irqLatch;
+  bool irqEnable;
+  uint16 irqMask;
+};
diff --git a/nSide/higan/fc/cartridge/chip/tc.cpp b/nSide/higan/fc/cartridge/chip/tc.cpp
new file mode 100644
index 0000000..83d7832
--- /dev/null
+++ b/nSide/higan/fc/cartridge/chip/tc.cpp
@@ -0,0 +1,160 @@
+struct TC : Chip {
+  TC(Board& board, Markup::Node& boardNode) : Chip(board) {
+    auto chip = boardNode.find("chip");
+    string type = chip(0)["type"].text();
+    if(type == "TC0190FMC") revision = Revision::TC0190FMC;
+    if(type == "TC0350FMR") revision = Revision::TC0350FMR;
+    if(type == "TC0690FMR") revision = Revision::TC0690FMR;
+    settings.pal16r4 = chip(1)["type"].text() == "PAL16R4";
+  }
+
+  auto main() -> void {
+    if(revision != Revision::TC0190FMC) {
+      if(irqDelay) irqDelay--;
+      irqTest(ppu.io.chrAddressBus);
+      cpu.irqLine(irqLine);
+    }
+    tick();
+  }
+
+  auto irqTest(uint addr) -> void {
+    bool edge;
+    // IRQs occur a little after they would on the MMC3.
+    // Do they use the MC-ACC's behavior instead?
+    edge = (chrAddressBus & 0x1000) && !(addr & 0x1000);
+    if(edge) {
+      if(irqDelay == 0) {
+        if(irqCounter == 0xff) {
+          irqCounter = irqLatch;
+        } else if(++irqCounter == 0xff) {
+          if(irqEnable) irqLine = 1;
+        }
+      }
+      irqDelay = 6;
+    }
+    chrAddressBus = addr;
+  }
+
+  auto prgAddress(uint addr) const -> uint {
+    switch((addr >> 13) & 3) {
+    case 0: return (prgBank[0] << 13) | (addr & 0x1fff);
+    case 1: return (prgBank[1] << 13) | (addr & 0x1fff);
+    case 2: return (0x3e << 13) | (addr & 0x1fff);
+    case 3: return (0x3f << 13) | (addr & 0x1fff);
+    }
+  }
+
+  auto chrAddress(uint addr) const -> uint {
+    if(addr <= 0x07ff) return (chrBank[0] << 11) | (addr & 0x07ff);
+    if(addr <= 0x0fff) return (chrBank[1] << 11) | (addr & 0x07ff);
+    if(addr <= 0x13ff) return (chrBank[2] << 10) | (addr & 0x03ff);
+    if(addr <= 0x17ff) return (chrBank[3] << 10) | (addr & 0x03ff);
+    if(addr <= 0x1bff) return (chrBank[4] << 10) | (addr & 0x03ff);
+    if(addr <= 0x1fff) return (chrBank[5] << 10) | (addr & 0x03ff);
+  }
+
+  auto ciramAddress(uint addr) const -> uint {
+    if(mirror == 0) return ((addr & 0x0400) >> 0) | (addr & 0x03ff);
+    if(mirror == 1) return ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+  }
+
+  auto regWrite(uint addr, uint8 data) -> void {
+    switch(addr & 0xe003) {
+    case 0x8000:
+      prgBank[0] = data & 0x3f;
+      if(revision != Revision::TC0690FMR && !settings.pal16r4) mirror = data & 0x40;
+      break;
+    case 0x8001:
+      prgBank[1] = data & 0x3f;
+      break;
+
+    case 0x8002: chrBank[0] = data; break;
+    case 0x8003: chrBank[1] = data; break;
+    case 0xa000: chrBank[2] = data; break;
+    case 0xa001: chrBank[3] = data; break;
+    case 0xa002: chrBank[4] = data; break;
+    case 0xa003: chrBank[5] = data; break;
+
+    case 0xc000:
+      if(revision != Revision::TC0190FMC) break;
+      irqLatch = data;
+      break;
+
+    case 0xc001:
+      if(revision != Revision::TC0190FMC) break;
+      irqCounter = 0xff;
+      break;
+
+    case 0xc002:
+      if(revision != Revision::TC0190FMC) break;
+      irqEnable = true;
+      break;
+
+    case 0xc003:
+      if(revision != Revision::TC0190FMC) break;
+      irqEnable = false;
+      irqLine = 0;
+      break;
+
+    case 0xe000:
+      if(revision == Revision::TC0690FMR || settings.pal16r4) mirror = data & 0x40;
+      break;
+    }
+  }
+
+  auto power() -> void {
+  }
+
+  auto reset() -> void {
+    prgBank[0] = 0;
+    prgBank[1] = 0;
+    chrBank[0] = 0;
+    chrBank[1] = 0;
+    chrBank[2] = 0;
+    chrBank[3] = 0;
+    chrBank[4] = 0;
+    chrBank[5] = 0;
+    mirror = 0;
+    irqLatch = 0;
+    irqCounter = 0;
+    irqEnable = false;
+    irqDelay = 0;
+    irqLine = 0;
+
+    chrAddressBus = 0;
+  }
+
+  auto serialize(serializer& s) -> void {
+    s.array(prgBank);
+    s.array(chrBank);
+    s.integer(mirror);
+    s.integer(irqLatch);
+    s.integer(irqCounter);
+    s.integer(irqEnable);
+    s.integer(irqDelay);
+    s.integer(irqLine);
+
+    s.integer(chrAddressBus);
+  }
+
+  enum class Revision : uint {
+    TC0190FMC, // No IRQ
+    TC0350FMR, // identical to TC0190 except with IRQ that no game uses
+    TC0690FMR,
+  } revision;
+
+  struct Settings {
+    bool pal16r4;
+  } settings;
+
+  uint8 prgBank[2];
+  uint8 chrBank[6];
+  bool mirror;
+  uint8 irqLatch;
+  uint8 irqCounter;
+  bool irqEnable;
+  uint irqDelay;
+  bool irqLine;
+
+  uint16 chrAddressBus;
+};
diff --git a/higan/higan/fc/cartridge/chip/vrc1.cpp b/nSide/higan/fc/cartridge/chip/vrc1.cpp
index 0d6ae0e..6f6e53b 100644
--- a/higan/higan/fc/cartridge/chip/vrc1.cpp
+++ b/nSide/higan/fc/cartridge/chip/vrc1.cpp
@@ -2,7 +2,7 @@ struct VRC1 : Chip {
   VRC1(Board& board) : Chip(board) {
   }
 
-  auto addrPRG(uint addr) const -> uint {
+  auto prgAddress(uint addr) const -> uint {
     uint bank = 0x0f;
     if((addr & 0xe000) == 0x8000) bank = prgBank[0];
     if((addr & 0xe000) == 0xa000) bank = prgBank[1];
@@ -10,13 +10,13 @@ struct VRC1 : Chip {
     return (bank * 0x2000) + (addr & 0x1fff);
   }
 
-  auto addrCHR(uint addr) const -> uint {
-    uint bank = chrBankLo[(bool)(addr & 0x1000)];
-    bank |= chrBankHi[(bool)(addr & 0x1000)] << 4;
-    return (bank * 0x1000) + (addr & 0x0fff);  
+  auto chrAddress(uint addr) const -> uint {
+    uint bank = chrBanklo[(bool)(addr & 0x1000)];
+    bank |= chrBankhi[(bool)(addr & 0x1000)] << 4;
+    return (bank * 0x1000) + (addr & 0x0fff);
   }
 
-  auto addrCIRAM(uint addr) const -> uint {
+  auto ciramAddress(uint addr) const -> uint {
     switch(mirror) {
     case 0: return ((addr & 0x0400) >> 0) | (addr & 0x03ff);  //vertical mirroring
     case 1: return ((addr & 0x0800) >> 1) | (addr & 0x03ff);  //horizontal mirroring
@@ -24,15 +24,15 @@ struct VRC1 : Chip {
     throw;
   }
 
-  auto writeIO(uint addr, uint8 data) -> void {
+  auto regWrite(uint addr, uint8 data) -> void {
     switch(addr & 0xf000) {
     case 0x8000:
       prgBank[0] = data & 0x0f;
       break;
 
     case 0x9000:
-      chrBankHi[1] = data & 0x04;
-      chrBankHi[0] = data & 0x02;
+      chrBankhi[1] = data & 0x04;
+      chrBankhi[0] = data & 0x02;
       mirror = data & 0x01;
       break;
 
@@ -45,11 +45,11 @@ struct VRC1 : Chip {
       break;
 
     case 0xe000:
-      chrBankLo[0] = data & 0x0f;
+      chrBanklo[0] = data & 0x0f;
       break;
 
     case 0xf000:
-      chrBankLo[1] = data & 0x0f;
+      chrBanklo[1] = data & 0x0f;
       break;
     }
   }
@@ -59,20 +59,20 @@ struct VRC1 : Chip {
 
   auto reset() -> void {
     for(auto& n : prgBank) n = 0;
-    for(auto& n : chrBankLo) n = 0;
-    for(auto& n : chrBankHi) n = 0;
+    for(auto& n : chrBanklo) n = 0;
+    for(auto& n : chrBankhi) n = 0;
     mirror = 0;
   }
 
   auto serialize(serializer& s) -> void {
     for(auto& n : prgBank) s.integer(n);
-    for(auto& n : chrBankLo) s.integer(n);
-    for(auto& n : chrBankHi) s.integer(n);
+    for(auto& n : chrBanklo) s.integer(n);
+    for(auto& n : chrBankhi) s.integer(n);
     s.integer(mirror);
   }
 
   uint4 prgBank[3];
-  uint4 chrBankLo[2];
-  bool chrBankHi[2];
+  uint4 chrBanklo[2];
+  bool chrBankhi[2];
   bool mirror;
 };
diff --git a/higan/higan/fc/cartridge/chip/vrc2.cpp b/nSide/higan/fc/cartridge/chip/vrc2.cpp
index 54e3644..bc7b04c 100644
--- a/higan/higan/fc/cartridge/chip/vrc2.cpp
+++ b/nSide/higan/fc/cartridge/chip/vrc2.cpp
@@ -2,7 +2,7 @@ struct VRC2 : Chip {
   VRC2(Board& board) : Chip(board) {
   }
 
-  auto addrPRG(uint addr) const -> uint {
+  auto prgAddress(uint addr) const -> uint {
     uint bank;
     switch(addr & 0xe000) {
     case 0x8000: bank = prgBank[0]; break;
@@ -13,12 +13,12 @@ struct VRC2 : Chip {
     return (bank * 0x2000) + (addr & 0x1fff);
   }
 
-  auto addrCHR(uint addr) const -> uint {
+  auto chrAddress(uint addr) const -> uint {
     uint bank = chrBank[addr / 0x0400];
     return (bank * 0x0400) + (addr & 0x03ff);
   }
 
-  auto addrCIRAM(uint addr) const -> uint {
+  auto ciramAddress(uint addr) const -> uint {
     switch(mirror) {
     case 0: return ((addr & 0x0400) >> 0) | (addr & 0x03ff);  //vertical mirroring
     case 1: return ((addr & 0x0800) >> 1) | (addr & 0x03ff);  //horizontal mirroring
@@ -28,23 +28,23 @@ struct VRC2 : Chip {
     throw;
   }
 
-  auto readRAM(uint addr) -> uint8 {
-    if(board.prgram.size == 0) {
+  auto ramRead(uint addr) -> uint8 {
+    if(board.prgram.size() == 0) {
       if((addr & 0xf000) == 0x6000) return cpu.mdr() | latch;
       return cpu.mdr();
     }
-    return board.prgram.read(addr & 0x1fff);
+    return board.read(board.prgram, addr & 0x1fff);
   }
 
-  auto writeRAM(uint addr, uint8 data) -> void {
-    if(board.prgram.size == 0) {
+  auto ramWrite(uint addr, uint8 data) -> void {
+    if(board.prgram.size() == 0) {
       if((addr & 0xf000) == 0x6000) latch = data & 0x01;
       return;
     }
-    return board.prgram.write(addr & 0x1fff, data);
+    return board.write(board.prgram, addr & 0x1fff, data);
   }
 
-  auto writeIO(uint addr, uint8 data) -> void {
+  auto regWrite(uint addr, uint8 data) -> void {
     switch(addr) {
     case 0x8000: case 0x8001: case 0x8002: case 0x8003:
       prgBank[0] = data & 0x1f;
diff --git a/higan/higan/fc/cartridge/chip/vrc3.cpp b/nSide/higan/fc/cartridge/chip/vrc3.cpp
index 60437d5..a8002ab 100644
--- a/higan/higan/fc/cartridge/chip/vrc3.cpp
+++ b/nSide/higan/fc/cartridge/chip/vrc3.cpp
@@ -24,12 +24,12 @@ struct VRC3 : Chip {
     tick();
   }
 
-  auto addrPRG(uint addr) const -> uint {
+  auto prgAddress(uint addr) const -> uint {
     uint bank = (addr < 0xc000 ? (uint)prgBank : 0x0f);
     return (bank * 0x4000) + (addr & 0x3fff);
   }
 
-  auto writeIO(uint addr, uint8 data) -> void {
+  auto regWrite(uint addr, uint8 data) -> void {
     switch(addr & 0xf000) {
     case 0x8000: irqLatch = (irqLatch & 0xfff0) | ((data & 0x0f) <<  0); break;
     case 0x9000: irqLatch = (irqLatch & 0xff0f) | ((data & 0x0f) <<  4); break;
diff --git a/higan/higan/fc/cartridge/chip/vrc4.cpp b/nSide/higan/fc/cartridge/chip/vrc4.cpp
index d9488ec..ee09c62 100644
--- a/higan/higan/fc/cartridge/chip/vrc4.cpp
+++ b/nSide/higan/fc/cartridge/chip/vrc4.cpp
@@ -31,8 +31,8 @@ struct VRC4 : Chip {
     tick();
   }
 
-  auto addrPRG(uint addr) const -> uint {
-    uint bank = 0, banks = board.prgrom.size / 0x2000;
+  auto prgAddress(uint addr) const -> uint {
+    uint bank = 0, banks = board.prgrom.size() / 0x2000;
     switch(addr & 0xe000) {
     case 0x8000: bank = prgMode == 0 ? (uint)prgBank[0] : banks - 2; break;
     case 0xa000: bank = prgBank[1]; break;
@@ -42,12 +42,12 @@ struct VRC4 : Chip {
     return (bank * 0x2000) + (addr & 0x1fff);
   }
 
-  auto addrCHR(uint addr) const -> uint {
+  auto chrAddress(uint addr) const -> uint {
     uint bank = chrBank[addr / 0x0400];
     return (bank * 0x0400) + (addr & 0x03ff);
   }
 
-  auto addrCIRAM(uint addr) const -> uint {
+  auto ciramAddress(uint addr) const -> uint {
     switch(mirror) {
     case 0: return ((addr & 0x0400) >> 0) | (addr & 0x03ff);  //vertical mirroring
     case 1: return ((addr & 0x0800) >> 1) | (addr & 0x03ff);  //horizontal mirroring
@@ -57,7 +57,7 @@ struct VRC4 : Chip {
     throw;
   }
 
-  auto writeIO(uint addr, uint8 data) -> void {
+  auto regWrite(uint addr, uint8 data) -> void {
     switch(addr) {
     case 0x8000: case 0x8001: case 0x8002: case 0x8003:
       prgBank[0] = data & 0x1f;
diff --git a/higan/higan/fc/cartridge/chip/vrc6.cpp b/nSide/higan/fc/cartridge/chip/vrc6.cpp
index 0b23a42..3c21ede 100644
--- a/higan/higan/fc/cartridge/chip/vrc6.cpp
+++ b/nSide/higan/fc/cartridge/chip/vrc6.cpp
@@ -3,6 +3,16 @@ struct VRC6 : Chip {
   }
 
   struct Pulse {
+    bool mode;
+    uint3 duty;
+    uint4 volume;
+    bool enable;
+    uint12 frequency;
+
+    uint12 divider;
+    uint4 cycle;
+    uint4 output;
+
     auto clock() -> void {
       if(--divider == 0) {
         divider = frequency + 1;
@@ -24,19 +34,19 @@ struct VRC6 : Chip {
       s.integer(cycle);
       s.integer(output);
     }
+  } pulse1, pulse2;
 
-    bool mode;
-    uint3 duty;
-    uint4 volume;
+  struct Sawtooth {
+    uint6 rate;
     bool enable;
     uint12 frequency;
 
     uint12 divider;
-    uint4 cycle;
-    uint4 output;
-  } pulse1, pulse2;
+    uint1 phase;
+    uint3 stage;
+    uint8 accumulator;
+    uint5 output;
 
-  struct Sawtooth {
     auto clock() -> void {
       if(--divider == 0) {
         divider = frequency + 1;
@@ -64,16 +74,6 @@ struct VRC6 : Chip {
       s.integer(accumulator);
       s.integer(output);
     }
-
-    uint6 rate;
-    bool enable;
-    uint12 frequency;
-
-    uint12 divider;
-    uint1 phase;
-    uint3 stage;
-    uint8 accumulator;
-    uint5 output;
   } sawtooth;
 
   auto main() -> void {
@@ -111,18 +111,18 @@ struct VRC6 : Chip {
     tick();
   }
 
-  auto addrPRG(uint addr) const -> uint {
+  auto prgAddress(uint addr) const -> uint {
     if((addr & 0xc000) == 0x8000) return (prgBank[0] << 14) | (addr & 0x3fff);
     if((addr & 0xe000) == 0xc000) return (prgBank[1] << 13) | (addr & 0x1fff);
-    if((addr & 0xe000) == 0xe000) return (      0xff << 13) | (addr & 0x1fff);
+    if((addr & 0xe000) == 0xe000) return (       0xff << 13) | (addr & 0x1fff);
   }
 
-  auto addrCHR(uint addr) const -> uint {
+  auto chrAddress(uint addr) const -> uint {
     uint bank = chrBank[(addr >> 10) & 7];
     return (bank << 10) | (addr & 0x03ff);
   }
 
-  auto addrCIRAM(uint addr) const -> uint {
+  auto ciramAddress(uint addr) const -> uint {
     switch(mirror) {
     case 0: return ((addr & 0x0400) >> 0) | (addr & 0x03ff);  //vertical mirroring
     case 1: return ((addr & 0x0800) >> 1) | (addr & 0x03ff);  //horizontal mirroring
@@ -131,15 +131,15 @@ struct VRC6 : Chip {
     }
   }
 
-  auto readRAM(uint addr) -> uint8 {
-    return board.prgram.data[addr & 0x1fff];
+  auto ramRead(uint addr) -> uint8 {
+    return board.read(board.prgram, addr & 0x1fff);
   }
 
-  auto writeRAM(uint addr, uint8 data) -> void {
-    board.prgram.data[addr & 0x1fff] = data;
+  auto ramWrite(uint addr, uint8 data) -> void {
+    board.write(board.prgram, addr & 0x1fff, data);
   }
 
-  auto writeIO(uint addr, uint8 data) -> void {
+  auto regWrite(uint addr, uint8 data) -> void {
     switch(addr) {
     case 0x8000: case 0x8001: case 0x8002: case 0x8003:
       prgBank[0] = data;
diff --git a/higan/higan/fc/cartridge/chip/vrc7.cpp b/nSide/higan/fc/cartridge/chip/vrc7.cpp
index 5a5e38a..538bff6 100644
--- a/higan/higan/fc/cartridge/chip/vrc7.cpp
+++ b/nSide/higan/fc/cartridge/chip/vrc7.cpp
@@ -34,28 +34,29 @@ struct VRC7 : Chip {
     tick();
   }
 
-  auto writeIO(uint addr, uint8 data) -> void {
+  auto regWrite(uint addr, uint8 data) -> void {
     switch(addr) {
     case 0x8000: prgBank[0] = data; break;
-    case 0x8010: prgBank[1] = data; break;
+    case 0x8001: prgBank[1] = data; break;
     case 0x9000: prgBank[2] = data; break;
-    case 0x9010: break;  //APU addr port
-    case 0x9030: break;  //APU data port
+    case 0x9001: break;  //APU addr port
+    case 0x9003: break;  //APU data port
     case 0xa000: chrBank[0] = data; break;
-    case 0xa010: chrBank[1] = data; break;
+    case 0xa001: chrBank[1] = data; break;
     case 0xb000: chrBank[2] = data; break;
-    case 0xb010: chrBank[3] = data; break;
+    case 0xb001: chrBank[3] = data; break;
     case 0xc000: chrBank[4] = data; break;
-    case 0xc010: chrBank[5] = data; break;
+    case 0xc001: chrBank[5] = data; break;
     case 0xd000: chrBank[6] = data; break;
-    case 0xd010: chrBank[7] = data; break;
+    case 0xd001: chrBank[7] = data; break;
     case 0xe000: mirror = data & 0x03; break;
 
-    case 0xe010:
+    case 0xe001: {
       irqLatch = data;
       break;
+    }
 
-    case 0xf000:
+    case 0xf000: {
       irqMode = data & 0x04;
       irqEnable = data & 0x02;
       irqAcknowledge = data & 0x01;
@@ -65,15 +66,18 @@ struct VRC7 : Chip {
       }
       irqLine = 0;
       break;
+    }
 
-    case 0xf010:
+    case 0xf001: {
       irqEnable = irqAcknowledge;
       irqLine = 0;
       break;
     }
+
+    }
   }
 
-  auto addrPRG(uint addr) const -> uint {
+  auto prgAddress(uint addr) const -> uint {
     uint bank = 0;
     switch(addr & 0xe000) {
     case 0x8000: bank = prgBank[0]; break;
@@ -84,12 +88,12 @@ struct VRC7 : Chip {
     return (bank * 0x2000) + (addr & 0x1fff);
   }
 
-  auto addrCHR(uint addr) const -> uint {
+  auto chrAddress(uint addr) const -> uint {
     uint bank = chrBank[addr / 0x0400];
     return (bank * 0x0400) + (addr & 0x03ff);
   }
 
-  auto addrCIRAM(uint addr) const -> uint {
+  auto ciramAddress(uint addr) const -> uint {
     switch(mirror) {
     case 0: return ((addr & 0x0400) >> 0) | (addr & 0x03ff);  //vertical mirroring
     case 1: return ((addr & 0x0800) >> 1) | (addr & 0x03ff);  //horizontal mirroring
diff --git a/nSide/higan/fc/cartridge/load.cpp b/nSide/higan/fc/cartridge/load.cpp
new file mode 100644
index 0000000..a3b1d96
--- /dev/null
+++ b/nSide/higan/fc/cartridge/load.cpp
@@ -0,0 +1,93 @@
+auto Cartridge::loadCartridge(Markup::Node node) -> void {
+  information.title.cartridge = node["information/title"].text();
+  auto boardNode = node["board"];
+  if(boardNode["region"].text() == "ntsc")  information.region = Region::NTSC;
+  if(boardNode["region"].text() == "pal")   information.region = Region::PAL;
+  if(boardNode["region"].text() == "dendy") information.region = Region::Dendy;
+
+  if(system.vs()) setupVS(node, boardNode);
+
+  Board::load(boardNode);  //this call will set Cartridge::board if successful
+  if(!board) return;
+  if(auto node = boardNode["prg/rom"]) loadMemory(board->prgrom, node, File::Required, pathID());
+  if(auto node = boardNode["prg/ram"]) loadMemory(board->prgram, node, File::Optional, pathID());
+  if(auto node = boardNode["chr/rom"]) loadMemory(board->chrrom, node, File::Required, pathID());
+  if(auto node = boardNode["chr/ram"]) loadMemory(board->chrram, node, File::Optional, pathID());
+  if(board->chip) if(auto node = boardNode["chip/ram"]) loadMemory(board->chip->ram, node, File::Optional, pathID());
+
+  if(system.pc10()) {
+    auto rom = boardNode["pc10"].find("rom");
+    loadMemory(board->instrom, rom(0), File::Required, pathID());
+    loadMemory(board->keyrom,  rom(1), File::Required, pathID());
+  }
+}
+
+auto Cartridge::setupVS(Markup::Node& node, Markup::Node& boardNode) -> void {
+  vssystem.gameCount = 0;
+  auto side = node.find("side");
+  bool primarySide;
+  if(side(0)["ppu"]) {
+    primarySide = 2 - side.size();
+    boardNode = side(0);
+    vssystem.gameCount++;
+  }
+  if(side(1)["ppu"]) {
+    if(vssystem.gameCount == 0) {
+      primarySide = 1;
+      boardNode = side(1);
+    }
+    vssystem.gameCount++;
+  }
+  cpu.side = primarySide;
+  apu.side = primarySide;
+  ppu.side = primarySide;
+
+  auto controller = boardNode.find("controller");
+  vssystem.swapControllers = controller(0)["port"].integer() == 2;
+  string device1 = boardNode.find("controller(port=1)/device")(0).text();
+  string device2 = boardNode.find("controller(port=2)/device")(0).text();
+  if(device1 == "gamepad") {
+    peripherals.connect(ID::Port::Controller1, ID::Device::Gamepad);
+  } else if(device1 == "none") {
+    peripherals.connect(ID::Port::Controller1, ID::Device::None);
+  }
+  if(device2 == "gamepad") {
+    peripherals.connect(ID::Port::Controller2, ID::Device::Gamepad);
+  } else if(device2 == "zapper") {
+    peripherals.connect(ID::Port::Controller2, ID::Device::Zapper);
+  } else if(device2 == "none") {
+    peripherals.connect(ID::Port::Controller2, ID::Device::None);
+  }
+  vssystem.setDip(primarySide, interface->dipSettings(boardNode));
+
+  string cpuVersion = side(0)["cpu/version"].text();
+  vssystem.forceSubRAM = cpuVersion == "RP2A04";
+
+  string ppuVersion = boardNode["ppu/version"].text();
+  if(ppuVersion == "RP2C02C")     ppu.version = PPU::Version::RP2C02C;
+  if(ppuVersion == "RP2C02G")     ppu.version = PPU::Version::RP2C02G;
+  if(ppuVersion == "RP2C03B")     ppu.version = PPU::Version::RP2C03B;
+  if(ppuVersion == "RP2C03G")     ppu.version = PPU::Version::RP2C03G;
+  if(ppuVersion == "RP2C04-0001") ppu.version = PPU::Version::RP2C04_0001;
+  if(ppuVersion == "RP2C04-0002") ppu.version = PPU::Version::RP2C04_0002;
+  if(ppuVersion == "RP2C04-0003") ppu.version = PPU::Version::RP2C04_0003;
+  if(ppuVersion == "RP2C04-0004") ppu.version = PPU::Version::RP2C04_0004;
+  if(ppuVersion == "RC2C03B")     ppu.version = PPU::Version::RC2C03B;
+  if(ppuVersion == "RC2C03C")     ppu.version = PPU::Version::RC2C03C;
+  if(ppuVersion == "RC2C05-01")   ppu.version = PPU::Version::RC2C05_01;
+  if(ppuVersion == "RC2C05-02")   ppu.version = PPU::Version::RC2C05_02;
+  if(ppuVersion == "RC2C05-03")   ppu.version = PPU::Version::RC2C05_03;
+  if(ppuVersion == "RC2C05-04")   ppu.version = PPU::Version::RC2C05_04;
+  if(ppuVersion == "RC2C05-05")   ppu.version = PPU::Version::RC2C05_05;
+}
+
+//
+
+auto Cartridge::loadMemory(MappedRAM& ram, Markup::Node node, bool required, maybe<uint> id) -> void {
+  string name = node["name"].text();
+  uint size = node["size"].natural();
+  ram.allocate(size);
+  if(auto fp = interface->open(id(), name, File::Read, required)) {
+    fp->read(ram.data(), ram.size());
+  }
+}
diff --git a/nSide/higan/fc/cartridge/save.cpp b/nSide/higan/fc/cartridge/save.cpp
new file mode 100644
index 0000000..64d89c9
--- /dev/null
+++ b/nSide/higan/fc/cartridge/save.cpp
@@ -0,0 +1,21 @@
+auto Cartridge::saveCartridge(Markup::Node node) -> void {
+  auto boardNode = node["board"];
+
+  if(auto node = boardNode["prg/ram"]) saveMemory(board->prgram, node);
+  if(auto node = boardNode["chr/ram"]) saveMemory(board->chrram, node);
+  if(board->chip) {
+    if(auto node = boardNode["chip/ram"]) saveMemory(board->chip->ram, node);
+  }
+}
+
+//
+
+auto Cartridge::saveMemory(MappedRAM& memory, Markup::Node node, maybe<uint> id) -> void {
+  if(!id) id = pathID();
+  if(!node || node["volatile"]) return;
+  auto name = node["name"].text();
+  auto size = node["size"].natural();
+  if(auto fp = interface->open(id(), name, File::Write)) {
+    fp->write(memory.data(), memory.size());
+  }
+}
diff --git a/nSide/higan/fc/cartridge/serialization.cpp b/nSide/higan/fc/cartridge/serialization.cpp
new file mode 100644
index 0000000..a74dc19
--- /dev/null
+++ b/nSide/higan/fc/cartridge/serialization.cpp
@@ -0,0 +1,4 @@
+auto Cartridge::serialize(serializer& s) -> void {
+  Thread::serialize(s);
+  return board->serialize(s);
+}
diff --git a/higan/higan/fc/controller/controller.cpp b/nSide/higan/fc/controller/controller.cpp
index 836861e..cec3cb8 100644
--- a/higan/higan/fc/controller/controller.cpp
+++ b/nSide/higan/fc/controller/controller.cpp
@@ -3,6 +3,13 @@
 namespace Famicom {
 
 #include "gamepad/gamepad.cpp"
+#include "gamepad-mic/gamepad-mic.cpp"
+#include "four-score/four-score.cpp"
+#include "zapper/zapper.cpp"
+#include "power-pad/power-pad.cpp"
+#include "vaus/vaus.cpp"
+#include "snes-gamepad/snes-gamepad.cpp"
+#include "mouse/mouse.cpp"
 
 Controller::Controller(bool port) : port(port) {
   if(!handle()) create(Controller::Enter, 1);
diff --git a/higan/higan/fc/controller/controller.hpp b/nSide/higan/fc/controller/controller.hpp
index 4515a6a..f90990d 100644
--- a/higan/higan/fc/controller/controller.hpp
+++ b/nSide/higan/fc/controller/controller.hpp
@@ -1,4 +1,4 @@
-//Famicom controller port pinout:
+//NES/AV Famicom controller port pinout:
 //  ____
 // |    \
 // |(7)  \
@@ -9,7 +9,7 @@
 //
 // pin  name   port1           port2
 //  1:  +5v
-//  2:  clock  $4016 read      $4016.d0 write
+//  2:  clock  $4016 read      $4017 read
 //  3:  latch  $4016.d0 write  $4016.d0 write
 //  4:  data0  $4016.d0 read   $4017.d0 read
 //  5:  data3  $4016.d3 read   $4017.d3 read
@@ -17,7 +17,7 @@
 //  7:  gnd
 
 struct Controller : Thread {
-  enum : bool { Port1 = 0, Port2 = 1 };
+  enum : uint { Port1 = 0, Port2 = 1 };
 
   Controller(bool port);
   virtual ~Controller();
@@ -25,9 +25,17 @@ struct Controller : Thread {
 
   virtual auto main() -> void;
   virtual auto data() -> uint3 { return 0; }
+  virtual auto mic() -> bool { return 0; }
   virtual auto latch(bool data) -> void {}
 
   const bool port;
 };
 
 #include "gamepad/gamepad.hpp"
+#include "gamepad-mic/gamepad-mic.hpp"
+#include "four-score/four-score.hpp"
+#include "zapper/zapper.hpp"
+#include "power-pad/power-pad.hpp"
+#include "vaus/vaus.hpp"
+#include "snes-gamepad/snes-gamepad.hpp"
+#include "mouse/mouse.hpp"
diff --git a/nSide/higan/fc/controller/four-score/four-score.cpp b/nSide/higan/fc/controller/four-score/four-score.cpp
new file mode 100644
index 0000000..41f63aa
--- /dev/null
+++ b/nSide/higan/fc/controller/four-score/four-score.cpp
@@ -0,0 +1,60 @@
+FourScore::FourScore(bool port) : Controller(port) {
+  latched = 0;
+  counter = 0;
+}
+
+auto FourScore::data() -> uint3 {
+  if(counter >= 24) return 1;
+  if(latched) return interface->inputPoll(port, ID::Device::FourScore, 0 + A);
+
+  auto& A = gamepads[0];
+  auto& B = gamepads[1];
+
+  switch(counter++) {
+  case  0: return A.a;
+  case  1: return A.b;
+  case  2: return A.select;
+  case  3: return A.start;
+  case  4: return (A.up & !A.down);
+  case  5: return (A.down & !A.up);
+  case  6: return (A.left & !A.right);
+  case  7: return (A.right & !A.left);
+  case  8: return B.a;
+  case  9: return B.b;
+  case 10: return B.select;
+  case 11: return B.start;
+  case 12: return (B.up & !B.down);
+  case 13: return (B.down & !B.up);
+  case 14: return (B.left & !B.right);
+  case 15: return (B.right & !B.left);
+  case 16: return 0;
+  case 17: return 0;
+  case 18: return port == 1;
+  case 19: return port == 0;
+  case 20: return 0;
+  case 21: return 0;
+  case 22: return 0;
+  case 23: return 0;
+  }
+  unreachable;
+}
+
+auto FourScore::latch(bool data) -> void {
+  if(latched == data) return;
+  latched = data;
+  counter = 0;
+
+  if(latched == 0) {
+    for(uint id : range(2)) {
+      auto& gamepad = gamepads[id];
+      gamepad.a      = interface->inputPoll(port, ID::Device::FourScore, id * 8 + A);
+      gamepad.b      = interface->inputPoll(port, ID::Device::FourScore, id * 8 + B);
+      gamepad.select = interface->inputPoll(port, ID::Device::FourScore, id * 8 + Select);
+      gamepad.start  = interface->inputPoll(port, ID::Device::FourScore, id * 8 + Start);
+      gamepad.up     = interface->inputPoll(port, ID::Device::FourScore, id * 8 + Up);
+      gamepad.down   = interface->inputPoll(port, ID::Device::FourScore, id * 8 + Down);
+      gamepad.left   = interface->inputPoll(port, ID::Device::FourScore, id * 8 + Left);
+      gamepad.right  = interface->inputPoll(port, ID::Device::FourScore, id * 8 + Right);
+    }
+  }
+}
diff --git a/nSide/higan/fc/controller/four-score/four-score.hpp b/nSide/higan/fc/controller/four-score/four-score.hpp
new file mode 100644
index 0000000..1da2ca1
--- /dev/null
+++ b/nSide/higan/fc/controller/four-score/four-score.hpp
@@ -0,0 +1,19 @@
+struct FourScore : Controller {
+  enum : uint {
+    Up, Down, Left, Right, B, A, Select, Start,
+  };
+
+  FourScore(bool port);
+
+  auto data() -> uint3;
+  auto latch(bool data) -> void;
+
+private:
+  bool latched;
+  uint counter;
+
+  struct Gamepad {
+    boolean a, b, select, start;
+    boolean up, down, left, right;
+  } gamepads[2];
+};
diff --git a/higan/higan/fc/controller/gamepad/gamepad.cpp b/nSide/higan/fc/controller/gamepad/gamepad.cpp
index e6621cc..b4b3f88 100644
--- a/higan/higan/fc/controller/gamepad/gamepad.cpp
+++ b/nSide/higan/fc/controller/gamepad/gamepad.cpp
@@ -1,19 +1,22 @@
 Gamepad::Gamepad(bool port) : Controller(port) {
+  latched = 0;
+  counter = 0;
 }
 
 auto Gamepad::data() -> uint3 {
   if(counter >= 8) return 1;
   if(latched == 1) return interface->inputPoll(port, ID::Device::Gamepad, A);
 
+  //note: D-pad physically prevents up+down and left+right from being pressed at the same time
   switch(counter++) {
   case 0: return a;
   case 1: return b;
   case 2: return select;
   case 3: return start;
-  case 4: return up && !down;
-  case 5: return down && !up;
-  case 6: return left && !right;
-  case 7: return right && !left;
+  case 4: return up & !down;
+  case 5: return down & !up;
+  case 6: return left & !right;
+  case 7: return right & !left;
   }
   unreachable;
 }
diff --git a/higan/higan/fc/controller/gamepad/gamepad.hpp b/nSide/higan/fc/controller/gamepad/gamepad.hpp
index 23883b5..aafdfcb 100644
--- a/higan/higan/fc/controller/gamepad/gamepad.hpp
+++ b/nSide/higan/fc/controller/gamepad/gamepad.hpp
@@ -4,19 +4,14 @@ struct Gamepad : Controller {
   };
 
   Gamepad(bool port);
+
   auto data() -> uint3;
   auto latch(bool data) -> void;
 
 private:
-  bool latched = 0;
-  uint counter = 0;
+  bool latched;
+  uint counter;
 
-  bool a = 0;
-  bool b = 0;
-  bool select = 0;
-  bool start = 0;
-  bool up = 0;
-  bool down = 0;
-  bool left = 0;
-  bool right = 0;
+  boolean a, b, select, start;
+  boolean up, down, left, right;
 };
diff --git a/nSide/higan/fc/controller/gamepad-mic/gamepad-mic.cpp b/nSide/higan/fc/controller/gamepad-mic/gamepad-mic.cpp
new file mode 100644
index 0000000..7511890
--- /dev/null
+++ b/nSide/higan/fc/controller/gamepad-mic/gamepad-mic.cpp
@@ -0,0 +1,41 @@
+GamepadMic::GamepadMic(bool port) : Controller(port) {
+  latched = 0;
+  counter = 0;
+}
+
+auto GamepadMic::data() -> uint3 {
+  if(counter >= 8) return 1;
+  if(latched == 1) return interface->inputPoll(port, ID::Device::GamepadMic, A);
+
+  //note: D-pad physically prevents up+down and left+right from being pressed at the same time
+  switch(counter++) {
+  case 0: return a;
+  case 1: return b;
+  case 2: return 0;
+  case 3: return 0;
+  case 4: return up & !down;
+  case 5: return down & !up;
+  case 6: return left & !right;
+  case 7: return right & !left;
+  }
+  unreachable;
+}
+
+auto GamepadMic::mic() -> bool {
+  return interface->inputPoll(port, ID::Device::GamepadMic, Mic) && nall::random() & 1;
+}
+
+auto GamepadMic::latch(bool data) -> void {
+  if(latched == data) return;
+  latched = data;
+  counter = 0;
+
+  if(latched == 0) {
+    a      = interface->inputPoll(port, ID::Device::GamepadMic, A);
+    b      = interface->inputPoll(port, ID::Device::GamepadMic, B);
+    up     = interface->inputPoll(port, ID::Device::GamepadMic, Up);
+    down   = interface->inputPoll(port, ID::Device::GamepadMic, Down);
+    left   = interface->inputPoll(port, ID::Device::GamepadMic, Left);
+    right  = interface->inputPoll(port, ID::Device::GamepadMic, Right);
+  }
+}
diff --git a/nSide/higan/fc/controller/gamepad-mic/gamepad-mic.hpp b/nSide/higan/fc/controller/gamepad-mic/gamepad-mic.hpp
new file mode 100644
index 0000000..afceb5a
--- /dev/null
+++ b/nSide/higan/fc/controller/gamepad-mic/gamepad-mic.hpp
@@ -0,0 +1,18 @@
+struct GamepadMic : Controller {
+  enum : uint {
+    Up, Down, Left, Right, B, A, Mic,
+  };
+
+  GamepadMic(bool port);
+
+  auto data() -> uint3;
+  auto mic() -> bool;
+  auto latch(bool data) -> void;
+
+private:
+  bool latched;
+  uint counter;
+
+  boolean a, b;
+  boolean up, down, left, right;
+};
diff --git a/nSide/higan/fc/controller/mouse/mouse.cpp b/nSide/higan/fc/controller/mouse/mouse.cpp
new file mode 100644
index 0000000..b615fbf
--- /dev/null
+++ b/nSide/higan/fc/controller/mouse/mouse.cpp
@@ -0,0 +1,86 @@
+Mouse::Mouse(bool port) : Controller(port) {
+  latched = 0;
+  counter = 0;
+
+  speed = 0;
+  x = 0;
+  y = 0;
+  dx = 0;
+  dy = 0;
+  l = 0;
+  r = 0;
+}
+
+auto Mouse::data() -> uint3 {
+  if(latched == 1) {
+    speed = (speed + 1) % 3;
+    return 0;
+  }
+
+  if(counter >= 32) return 1;
+
+  switch(counter++) { default:
+  case  0: return 0;
+  case  1: return 0;
+  case  2: return 0;
+  case  3: return 0;
+  case  4: return 0;
+  case  5: return 0;
+  case  6: return 0;
+  case  7: return 0;
+
+  case  8: return r;
+  case  9: return l;
+  case 10: return (speed >> 1) & 1;
+  case 11: return (speed >> 0) & 1;
+
+  case 12: return 0;  //signature
+  case 13: return 0;  // ||
+  case 14: return 0;  // ||
+  case 15: return 1;  // ||
+
+  case 16: return dy;
+  case 17: return (y >> 6) & 1;
+  case 18: return (y >> 5) & 1;
+  case 19: return (y >> 4) & 1;
+  case 20: return (y >> 3) & 1;
+  case 21: return (y >> 2) & 1;
+  case 22: return (y >> 1) & 1;
+  case 23: return (y >> 0) & 1;
+
+  case 24: return dx;
+  case 25: return (x >> 6) & 1;
+  case 26: return (x >> 5) & 1;
+  case 27: return (x >> 4) & 1;
+  case 28: return (x >> 3) & 1;
+  case 29: return (x >> 2) & 1;
+  case 30: return (x >> 1) & 1;
+  case 31: return (x >> 0) & 1;
+  }
+}
+
+auto Mouse::latch(bool data) -> void {
+  if(latched == data) return;
+  latched = data;
+  counter = 0;
+
+  x = interface->inputPoll(port, ID::Device::Mouse, X);  //-n = left, 0 = center, +n = right
+  y = interface->inputPoll(port, ID::Device::Mouse, Y);  //-n = up,   0 = center, +n = down
+  l = interface->inputPoll(port, ID::Device::Mouse, Left);
+  r = interface->inputPoll(port, ID::Device::Mouse, Right);
+
+  dx = x < 0;  //0 = right, 1 = left
+  dy = y < 0;  //0 = down,  1 = up
+
+  if(x < 0) x = -x;  //abs(position_x)
+  if(y < 0) y = -y;  //abs(position_y)
+
+  double multiplier = 1.0;
+  if(speed == 1) multiplier = 1.5;
+  if(speed == 2) multiplier = 2.0;
+  x = (double)x * multiplier;
+  y = (double)y * multiplier;
+
+  x = min(127, x);
+  y = min(127, y);
+}
diff --git a/nSide/higan/fc/controller/mouse/mouse.hpp b/nSide/higan/fc/controller/mouse/mouse.hpp
new file mode 100644
index 0000000..02a572b
--- /dev/null
+++ b/nSide/higan/fc/controller/mouse/mouse.hpp
@@ -0,0 +1,22 @@
+struct Mouse : Controller {
+  enum : uint {
+    X, Y, Left, Right,
+  };
+
+  Mouse(bool port);
+
+  auto data() -> uint3;
+  auto latch(bool data) -> void;
+
+private:
+  bool latched;
+  uint counter;
+
+  uint speed;  //0 = slow, 1 = normal, 2 = fast
+  int x;       //x-coordinate
+  int y;       //y-coordinate
+  bool dx;     //x-direction
+  bool dy;     //y-direction
+  bool l;      //left button
+  bool r;      //right button
+};
diff --git a/nSide/higan/fc/controller/power-pad/power-pad.cpp b/nSide/higan/fc/controller/power-pad/power-pad.cpp
new file mode 100644
index 0000000..326565e
--- /dev/null
+++ b/nSide/higan/fc/controller/power-pad/power-pad.cpp
@@ -0,0 +1,46 @@
+PowerPad::PowerPad(bool port) : Controller(port) {
+  latched = 0;
+  counter = 0;
+
+  b1 = b2  = b3  = b4  = 0;
+  b5 = b6  = b7  = b8  = 0;
+  b9 = b10 = b11 = b12 = 0;
+}
+
+auto PowerPad::data() -> uint3 {
+  if(counter >= 8) return 0x6;
+  if(latched == 1) return (interface->inputPoll(port, ID::Device::PowerPad, 1) << 1) | (interface->inputPoll(port, ID::Device::PowerPad, 3) << 2);
+
+  switch(counter++) {
+  case  0: return (b2  << 1) | (b4  << 2);
+  case  1: return (b1  << 1) | (b3  << 2);
+  case  2: return (b5  << 1) | (b12 << 2);
+  case  3: return (b9  << 1) | (b8  << 2);
+  case  4: return (b6  << 1) | (1   << 2);
+  case  5: return (b10 << 1) | (1   << 2);
+  case  6: return (b11 << 1) | (1   << 2);
+  case  7: return (b7  << 1) | (1   << 2);
+  }
+}
+
+auto PowerPad::latch(bool data) -> void {
+  if(latched == data) return;
+  latched = data;
+  counter = 0;
+
+  if(latched == 0) {
+    auto id = ID::Device::PowerPad;
+    b1  = interface->inputPoll(port, id,  0);
+    b2  = interface->inputPoll(port, id,  1);
+    b3  = interface->inputPoll(port, id,  2);
+    b4  = interface->inputPoll(port, id,  3);
+    b5  = interface->inputPoll(port, id,  4);
+    b6  = interface->inputPoll(port, id,  5);
+    b7  = interface->inputPoll(port, id,  6);
+    b8  = interface->inputPoll(port, id,  7);
+    b9  = interface->inputPoll(port, id,  8);
+    b10 = interface->inputPoll(port, id,  9);
+    b11 = interface->inputPoll(port, id, 10);
+    b12 = interface->inputPoll(port, id, 11);
+  }
+}
diff --git a/nSide/higan/fc/controller/power-pad/power-pad.hpp b/nSide/higan/fc/controller/power-pad/power-pad.hpp
new file mode 100644
index 0000000..0179663
--- /dev/null
+++ b/nSide/higan/fc/controller/power-pad/power-pad.hpp
@@ -0,0 +1,14 @@
+struct PowerPad : Controller {
+  PowerPad(bool port);
+
+  auto data() -> uint3;
+  auto latch(bool data) -> void;
+
+private:
+  bool latched;
+  uint counter;
+
+  bool b1, b2,  b3,  b4;
+  bool b5, b6,  b7,  b8;
+  bool b9, b10, b11, b12;
+};
diff --git a/nSide/higan/fc/controller/snes-gamepad/snes-gamepad.cpp b/nSide/higan/fc/controller/snes-gamepad/snes-gamepad.cpp
new file mode 100644
index 0000000..ea2c19b
--- /dev/null
+++ b/nSide/higan/fc/controller/snes-gamepad/snes-gamepad.cpp
@@ -0,0 +1,48 @@
+SNESGamepad::SNESGamepad(bool port) : Controller(port) {
+  latched = 0;
+  counter = 0;
+}
+
+auto SNESGamepad::data() -> uint3 {
+  if(counter >= 16) return 1;
+  if(latched == 1) return interface->inputPoll(port, ID::Device::SNESGamepad, B);
+
+  //note: D-pad physically prevents up+down and left+right from being pressed at the same time
+  switch(counter++) {
+  case  0: return b;
+  case  1: return y;
+  case  2: return select;
+  case  3: return start;
+  case  4: return up & !down;
+  case  5: return down & !up;
+  case  6: return left & !right;
+  case  7: return right & !left;
+  case  8: return a;
+  case  9: return x;
+  case 10: return l;
+  case 11: return r;
+  }
+
+  return 0;  //12-15: signature
+}
+
+auto SNESGamepad::latch(bool data) -> void {
+  if(latched == data) return;
+  latched = data;
+  counter = 0;
+
+  if(latched == 0) {
+    b      = interface->inputPoll(port, ID::Device::SNESGamepad, B);
+    y      = interface->inputPoll(port, ID::Device::SNESGamepad, Y);
+    select = interface->inputPoll(port, ID::Device::SNESGamepad, Select);
+    start  = interface->inputPoll(port, ID::Device::SNESGamepad, Start);
+    up     = interface->inputPoll(port, ID::Device::SNESGamepad, Up);
+    down   = interface->inputPoll(port, ID::Device::SNESGamepad, Down);
+    left   = interface->inputPoll(port, ID::Device::SNESGamepad, Left);
+    right  = interface->inputPoll(port, ID::Device::SNESGamepad, Right);
+    a      = interface->inputPoll(port, ID::Device::SNESGamepad, A);
+    x      = interface->inputPoll(port, ID::Device::SNESGamepad, X);
+    l      = interface->inputPoll(port, ID::Device::SNESGamepad, L);
+    r      = interface->inputPoll(port, ID::Device::SNESGamepad, R);
+  }
+}
diff --git a/nSide/higan/fc/controller/snes-gamepad/snes-gamepad.hpp b/nSide/higan/fc/controller/snes-gamepad/snes-gamepad.hpp
new file mode 100644
index 0000000..7aa4517
--- /dev/null
+++ b/nSide/higan/fc/controller/snes-gamepad/snes-gamepad.hpp
@@ -0,0 +1,18 @@
+struct SNESGamepad : Controller {
+  enum : uint {
+    Up, Down, Left, Right, B, A, Y, X, L, R, Select, Start,
+  };
+
+  SNESGamepad(bool port);
+
+  auto data() -> uint3;
+  auto latch(bool data) -> void;
+
+private:
+  bool latched;
+  uint counter;
+
+  boolean b, y, select, start;
+  boolean up, down, left, right;
+  boolean a, x, l, r;
+};
diff --git a/nSide/higan/fc/controller/vaus/vaus.cpp b/nSide/higan/fc/controller/vaus/vaus.cpp
new file mode 100644
index 0000000..b04c880
--- /dev/null
+++ b/nSide/higan/fc/controller/vaus/vaus.cpp
@@ -0,0 +1,41 @@
+Vaus::Vaus(bool port) : Controller(port) {
+  create(Controller::Enter, system.colorburst() * 6.0);
+  latched = 0;
+  counter = 0;
+
+  x = 0;
+  control = 0;
+
+  prev = 0;
+}
+
+auto Vaus::main() -> void {
+  uint next = ppu.vcounter() * 341 + ppu.hcounter();
+
+  if(next < prev) {
+    //Vcounter wrapped back to zero; update control knob for start of new frame
+    int nx = interface->inputPoll(port, ID::Device::Vaus, Control) * 160 / 256;
+    const uint8_t trimpot = 0x0d;
+    x = max(trimpot, min(trimpot + 0xa0, x - nx));
+  }
+
+  prev = next;
+  step(3);
+  synchronize(cpu);
+}
+
+auto Vaus::data() -> uint3 {
+  bool fire = interface->inputPoll(port, ID::Device::Vaus, Fire);
+  if(latched == 1) return fire << 1 | control.bit(7) << 2;
+  if(counter >= 8) return 0;
+
+  return fire << 1 | control.bit(7 - counter++) << 2;
+}
+
+auto Vaus::latch(bool data) -> void {
+  if(latched == data) return;
+  latched = data;
+  counter = 0;
+
+  control = x & 0xff;
+}
diff --git a/nSide/higan/fc/controller/vaus/vaus.hpp b/nSide/higan/fc/controller/vaus/vaus.hpp
new file mode 100644
index 0000000..0c47253
--- /dev/null
+++ b/nSide/higan/fc/controller/vaus/vaus.hpp
@@ -0,0 +1,20 @@
+struct Vaus : Controller {
+  enum : uint {
+    Control, Fire,
+  };
+
+  Vaus(bool port);
+
+  auto main() -> void;
+  auto data() -> uint3;
+  auto latch(bool data) -> void;
+
+private:
+  bool latched;
+  uint counter;
+
+  int x;
+  uint8 control;
+
+  uint prev;
+};
diff --git a/nSide/higan/fc/controller/zapper/zapper.cpp b/nSide/higan/fc/controller/zapper/zapper.cpp
new file mode 100644
index 0000000..90a3506
--- /dev/null
+++ b/nSide/higan/fc/controller/zapper/zapper.cpp
@@ -0,0 +1,127 @@
+Zapper::Zapper(bool port) : Controller(port) {
+  create(Controller::Enter, system.colorburst() * 6.0);
+  sprite = Emulator::video.createSprite(16, 16);
+  sprite->setPixels(Resource::Sprite::CrosshairRedSmall);
+
+  latched = 0;
+  counter = 0;
+
+  //center cursor onscreen
+  x = 256 / 2;
+  y = 240 / 2;
+
+  light       = false;
+  trigger     = false;
+  lighttime   = 0;
+  triggertime = 0;
+  offscreen   = false;
+
+  triggerlock = false;
+
+  prev = 0;
+}
+
+Zapper::~Zapper() {
+  Emulator::video.removeSprite(sprite);
+}
+
+auto Zapper::main() -> void {
+  uint next = ppu.vcounter() * 341 + ppu.hcounter();
+
+  if(lighttime > 0) {
+    lighttime -= 1;
+  }
+
+  if(!offscreen) {
+    uint target = y * 341 + x + 8;
+    if(next >= target && prev < target) {
+      //CRT raster detected
+      //light remains in the gun for 10-25 scanlines
+      if(readLight()) lighttime = 341 * 16;
+    }
+  }
+
+  if(next < prev) {
+    if(triggertime > 0) triggertime -= 1;
+    //Vcounter wrapped back to zero; update cursor coordinates for start of new frame
+    int nx = interface->inputPoll(port, ID::Device::Zapper, X);
+    int ny = interface->inputPoll(port, ID::Device::Zapper, Y);
+    nx += x;
+    ny += y;
+    x = max(-16, min(256 + 16, nx));
+    y = max(-16, min(240 + 16, ny));
+    offscreen = (x < 0 || y < 0 || x >= 256 || y >= 240);
+    sprite->setPosition(x - 8, y - 8);
+    sprite->setVisible(true);
+  }
+
+  prev = next;
+  step(3);
+  synchronize(cpu);
+}
+
+auto Zapper::data() -> uint3 {
+  if(!system.vs()) {
+    bool newtrigger = interface->inputPoll(port, ID::Device::Zapper, Trigger);
+    if(newtrigger && !triggerlock) {
+      triggertime = 3;
+      triggerlock = true;
+    } else if(!newtrigger) {
+      triggerlock = false;
+    }
+    light = lighttime > 0;
+    trigger = triggertime > 0;
+
+    return (trigger << 2) | ((!light) << 1);
+  } else {
+    if(counter >= 8) return 1;
+    if(latched == 1) return 0;
+
+    switch(counter++) {
+    case 0: return 0;
+    case 1: return 0;
+    case 2: return 0;
+    case 3: return 0;
+    case 4: return 1; // connected
+    case 5: return 0;
+    case 6: return light;
+    case 7: return trigger;
+    }
+  }
+}
+
+auto Zapper::readLight() -> bool {
+  if(offscreen) return false;
+  uint32 paletteIndex = ppu.output[y * 256 + x];
+  uint color;
+  switch(ppu.version) {
+  default:
+    return ((paletteIndex & 0x20) && ((paletteIndex & 0x0f) < 0x0d));
+  case PPU::Version::RP2C04_0001:
+    color = PPU::RP2C04_0001[paletteIndex & 63];
+    break;
+  case PPU::Version::RP2C04_0002:
+    color = PPU::RP2C04_0002[paletteIndex & 63];
+    break;
+  case PPU::Version::RP2C04_0003:
+    color = PPU::RP2C04_0003[paletteIndex & 63];
+    break;
+  case PPU::Version::RP2C04_0004:
+    color = PPU::RP2C04_0004[paletteIndex & 63];
+    break;
+  }
+  if((color & 0xf00) > 0x600) return true;
+  if((color & 0x0f0) > 0x060) return true;
+  if((color & 0x00f) > 0x006) return true;
+  return false;
+}
+
+auto Zapper::latch(bool data) -> void {
+  if(latched == data) return;
+  latched = data;
+  if(system.vs() && latched == 0) {
+    counter = 0;
+    trigger = interface->inputPoll(port, ID::Device::Zapper, Trigger);
+    light = lighttime > 0;
+  }
+}
diff --git a/nSide/higan/fc/controller/zapper/zapper.hpp b/nSide/higan/fc/controller/zapper/zapper.hpp
new file mode 100644
index 0000000..98f092a
--- /dev/null
+++ b/nSide/higan/fc/controller/zapper/zapper.hpp
@@ -0,0 +1,32 @@
+struct Zapper : Controller {
+  shared_pointer<Emulator::Sprite> sprite;
+
+  enum : uint {
+    X, Y, Trigger,
+  };
+
+  Zapper(bool port);
+  ~Zapper();
+
+  auto main() -> void;
+  auto data() -> uint3;
+  auto readLight() -> bool;
+  auto latch(bool data) -> void;
+
+private:
+  bool latched;
+  uint counter; // VS. System
+
+  int x;
+  int y;
+
+  bool light;
+  bool trigger;
+  uint lighttime;
+  uint triggertime;
+  bool offscreen;
+
+  bool triggerlock;
+
+  uint prev;
+};
diff --git a/higan/higan/fc/cpu/cpu.cpp b/nSide/higan/fc/cpu/cpu.cpp
index c39000f..56563d9 100644
--- a/higan/higan/fc/cpu/cpu.cpp
+++ b/nSide/higan/fc/cpu/cpu.cpp
@@ -2,10 +2,14 @@
 
 namespace Famicom {
 
+CPU cpu;
 #include "memory.cpp"
+#include "io.cpp"
 #include "timing.cpp"
 #include "serialization.cpp"
-CPU cpu;
+
+CPU::CPU() : Processor::MOS6502(false) {
+}
 
 auto CPU::Enter() -> void {
   while(true) scheduler.synchronize(), cpu.main();
@@ -16,16 +20,12 @@ auto CPU::main() -> void {
   instruction();
 }
 
-auto CPU::step(uint clocks) -> void {
-  Thread::step(clocks);
-  synchronize(apu);
-  synchronize(ppu);
-  synchronize(cartridge);
-  for(auto peripheral : peripherals) synchronize(*peripheral);
+auto CPU::load(Markup::Node node) -> bool {
+  return true;
 }
 
 auto CPU::power() -> void {
-  R6502::power();
+  MOS6502::power();
 
   for(auto addr : range(0x0800)) ram[addr] = 0xff;
   ram[0x0008] = 0xf7;
@@ -35,14 +35,36 @@ auto CPU::power() -> void {
 }
 
 auto CPU::reset() -> void {
-  R6502::reset();
-  create(CPU::Enter, system.colorburst() * 6.0);
+  MOS6502::reset();
+  create(Enter, system.colorburst() * 6.0);
+
+  function<auto (uint16, uint8) -> uint8> reader;
+  function<auto (uint16, uint8) -> void> writer;
 
-  regs.pc  = bus.read(0xfffc) << 0;
-  regs.pc |= bus.read(0xfffd) << 8;
+  reader = [](uint16 addr, uint8) -> uint8 { return cpu.ram[addr]; };
+  writer = [](uint16 addr, uint8 data) -> void { cpu.ram[addr] = data; };
+  bus.map(reader, writer, "0000-1fff", 0x800);
+
+  reader = {&CPU::readCPU, this};
+  writer = {&CPU::writeCPU, this};
+  bus.map(reader, writer, "4000-4017");
+
+  //CPU
+  r.pc  = bus.read(0xfffc, r.mdr) << 0;
+  r.pc |= bus.read(0xfffd, r.mdr) << 8;
+
+  io.interruptPending = false;
+  io.nmiPending = false;
+  io.nmiLine = 0;
+  io.irqLine = 0;
+  io.apuLine = 0;
 
-  memory::fill(&io, sizeof(IO));
   io.rdyLine = 1;
+  io.rdyAddrValid = false;
+  io.rdyAddrValue = 0x0000;
+
+  io.oamdmaPending = false;
+  io.oamdmaPage = 0x00;
 }
 
 }
diff --git a/higan/higan/fc/cpu/cpu.hpp b/nSide/higan/fc/cpu/cpu.hpp
index a530fa7..74020ab 100644
--- a/higan/higan/fc/cpu/cpu.hpp
+++ b/nSide/higan/fc/cpu/cpu.hpp
@@ -1,27 +1,25 @@
-struct CPU : Processor::R6502, Thread {
+struct CPU : Processor::MOS6502, Thread {
+  CPU();
+
   static auto Enter() -> void;
   auto main() -> void;
-  auto step(uint clocks) -> void;
-
+  auto load(Markup::Node) -> bool;
   auto power() -> void;
   auto reset() -> void;
 
   //memory.cpp
-  auto readRAM(uint11 addr) -> uint8;
-  auto writeRAM(uint11 addr, uint8 data) -> void;
-
-  auto readIO(uint16 addr) -> uint8;
-  auto writeIO(uint16 addr, uint8 data) -> void;
+  auto read(uint16 addr) -> uint8 override;
+  auto write(uint16 addr, uint8 data) -> void override;
+  auto readDisassembler(uint16 addr) -> uint8 override;
 
-  auto readDebugger(uint16 addr) -> uint8 override;
-
-  auto serialize(serializer&) -> void;
+  //mmio.cpp
+  auto readCPU(uint16 addr, uint8 data) -> uint8;
+  auto writeCPU(uint16 addr, uint8 data) -> void;
 
   //timing.cpp
-  auto read(uint16 addr) -> uint8 override;
-  auto write(uint16 addr, uint8 data) -> void override;
-  auto lastCycle() -> void override;
-  auto nmi(uint16& vector) -> void override;
+  auto step(uint clocks) -> void;
+  auto lastCycle() -> void;
+  auto nmi(uint16 &vector) -> void;
 
   auto oamdma() -> void;
 
@@ -32,11 +30,16 @@ struct CPU : Processor::R6502, Thread {
   auto rdyLine(bool) -> void;
   auto rdyAddr(bool valid, uint16 value = 0) -> void;
 
-//protected:
+  //serialization.cpp
+  auto serialize(serializer&) -> void;
+
+  uint8 ram[2 * 1024];
+  vector<Thread*> coprocessors;
   vector<Thread*> peripherals;
 
-  uint8 ram[0x0800];
+  bool side; // VS. System; 0: main, 1: sub
 
+//privileged:
   struct IO {
     bool interruptPending;
     bool nmiPending;
diff --git a/nSide/higan/fc/cpu/io.cpp b/nSide/higan/fc/cpu/io.cpp
new file mode 100644
index 0000000..16c8625
--- /dev/null
+++ b/nSide/higan/fc/cpu/io.cpp
@@ -0,0 +1,50 @@
+auto CPU::readCPU(uint16 addr, uint8 data) -> uint8 {
+  switch(addr) {
+
+  case 0x4016: {
+    if(system.vs()) return vssystem.read(side, addr, data);
+    uint8 data1 = Famicom::peripherals.controllerPort1->data();
+    uint8 data2 = Famicom::peripherals.controllerPort2->mic() << 2;
+    uint8 data3 = Famicom::peripherals.expansionPort->data1() << 1;
+    data1 = data1.bit(2) << 4 | data1.bit(1) << 3 | data1.bit(0) << 0;
+    return (mdr() & 0xe0) | data1 | data2 | data3;
+  }
+
+  case 0x4017: {
+    if(system.vs()) return vssystem.read(side, addr, data);
+    uint8 data2 = Famicom::peripherals.controllerPort2->data();
+    uint8 data3 = Famicom::peripherals.expansionPort->data2();
+    data2 = data2.bit(2) << 4 | data2.bit(1) << 3 | data2.bit(0) << 0;
+    return (mdr() & 0xe0)         | data2 | data3;
+  }
+
+  }
+
+  if(system.vs() && addr >= 0x4018 && addr <= 0x5fff) return vssystem.read(side, addr, data);
+
+  return apu.readIO(addr);
+}
+
+auto CPU::writeCPU(uint16 addr, uint8 data) -> void {
+  switch(addr) {
+
+  case 0x4014: {
+    io.oamdmaPage = data;
+    io.oamdmaPending = true;
+    return;
+  }
+
+  case 0x4016: {
+    if(system.vs()) return vssystem.write(side, addr, data);
+    Famicom::peripherals.controllerPort1->latch(data.bit(0));
+    Famicom::peripherals.controllerPort2->latch(data.bit(0));
+    Famicom::peripherals.expansionPort->write(data.bits(0,2));
+    return;
+  }
+
+  }
+
+  if(system.vs() && addr >= 0x4017 && addr <= 0x5fff) vssystem.write(side, addr, data);
+
+  return apu.writeIO(addr, data);
+}
diff --git a/higan/higan/fc/cpu/memory.cpp b/nSide/higan/fc/cpu/memory.cpp
index d174602..039f72a 100644
--- a/higan/higan/fc/cpu/memory.cpp
+++ b/nSide/higan/fc/cpu/memory.cpp
@@ -1,49 +1,25 @@
-auto CPU::readRAM(uint11 addr) -> uint8 {
-  return ram[addr];
-}
-
-auto CPU::writeRAM(uint11 addr, uint8 data) -> void {
-  ram[addr] = data;
-}
-
-auto CPU::readIO(uint16 addr) -> uint8 {
-  switch(addr) {
-
-  case 0x4016: {
-    auto data = Famicom::peripherals.controllerPort1->data();
-    return (mdr() & 0xc0) | data.bit(2) << 4 | data.bit(1) << 3 | data.bit(0) << 0;
-  }
-
-  case 0x4017: {
-    auto data = Famicom::peripherals.controllerPort2->data();
-    return (mdr() & 0xc0) | data.bit(2) << 4 | data.bit(1) << 3 | data.bit(0) << 0;
+auto CPU::read(uint16 addr) -> uint8 {
+  if(io.oamdmaPending) {
+    io.oamdmaPending = false;
+    read(addr);
+    oamdma();
   }
 
+  while(io.rdyLine == 0) {
+    r.mdr = bus.read(io.rdyAddrValid ? io.rdyAddrValue : addr, r.mdr);
+    step(system.region() == System::Region::NTSC ? 12 : system.region() == System::Region::PAL ? 16 : 15);
   }
 
-  return apu.readIO(addr);
+  r.mdr = bus.read(addr, r.mdr);
+  step(system.region() == System::Region::NTSC ? 12 : system.region() == System::Region::PAL ? 16 : 15);
+  return r.mdr;
 }
 
-auto CPU::writeIO(uint16 addr, uint8 data) -> void {
-  switch(addr) {
-
-  case 0x4014: {
-    io.oamdmaPage = data;
-    io.oamdmaPending = true;
-    return;
-  }
-
-  case 0x4016: {
-    Famicom::peripherals.controllerPort1->latch(data.bit(0));
-    Famicom::peripherals.controllerPort2->latch(data.bit(0));
-    return;
-  }
-
-  }
-
-  return apu.writeIO(addr, data);
+auto CPU::write(uint16 addr, uint8 data) -> void {
+  bus.write(addr, r.mdr = data);
+  step(system.region() == System::Region::NTSC ? 12 : system.region() == System::Region::PAL ? 16 : 15);
 }
 
-auto CPU::readDebugger(uint16 addr) -> uint8 {
-  return bus.read(addr);
+auto CPU::readDisassembler(uint16 addr) -> uint8 {
+  return bus.read(addr, r.mdr);
 }
diff --git a/higan/higan/fc/cpu/serialization.cpp b/nSide/higan/fc/cpu/serialization.cpp
index fbd9e64..ef9ddb8 100644
--- a/higan/higan/fc/cpu/serialization.cpp
+++ b/nSide/higan/fc/cpu/serialization.cpp
@@ -1,5 +1,5 @@
 auto CPU::serialize(serializer& s) -> void {
-  R6502::serialize(s);
+  MOS6502::serialize(s);
   Thread::serialize(s);
 
   s.array(ram);
diff --git a/higan/higan/fc/cpu/timing.cpp b/nSide/higan/fc/cpu/timing.cpp
index 14a864f..93f35e8 100644
--- a/higan/higan/fc/cpu/timing.cpp
+++ b/nSide/higan/fc/cpu/timing.cpp
@@ -1,30 +1,18 @@
-auto CPU::read(uint16 addr) -> uint8 {
-  if(io.oamdmaPending) {
-    io.oamdmaPending = false;
-    read(addr);
-    oamdma();
-  }
-
-  while(io.rdyLine == 0) {
-    regs.mdr = bus.read(io.rdyAddrValid ? io.rdyAddrValue : addr);
-    step(12);
-  }
-
-  regs.mdr = bus.read(addr);
-  step(12);
-  return regs.mdr;
-}
+auto CPU::step(uint clocks) -> void {
+  Thread::step(clocks);
+  for(auto peripheral : peripherals) synchronize(*peripheral);
 
-auto CPU::write(uint16 addr, uint8 data) -> void {
-  bus.write(addr, regs.mdr = data);
-  step(12);
+  synchronize(apu);
+  synchronize(ppu);
+  synchronize(cartridge);
+  for(auto coprocessor : coprocessors) synchronize(*coprocessor);
 }
 
 auto CPU::lastCycle() -> void {
-  io.interruptPending = ((io.irqLine | io.apuLine) & ~regs.p.i) | io.nmiPending;
+  io.interruptPending = ((io.irqLine | io.apuLine) & ~r.p.i) | io.nmiPending;
 }
 
-auto CPU::nmi(uint16& vector) -> void {
+auto CPU::nmi(uint16 &vector) -> void {
   if(io.nmiPending) {
     io.nmiPending = false;
     vector = 0xfffa;
@@ -32,8 +20,8 @@ auto CPU::nmi(uint16& vector) -> void {
 }
 
 auto CPU::oamdma() -> void {
-  for(uint n : range(256)) {
-    uint8 data = read(io.oamdmaPage << 8 | n);
+  for(uint n = 0; n < 256; n++) {
+    uint8 data = read((io.oamdmaPage << 8) + n);
     write(0x2004, data);
   }
 }
diff --git a/nSide/higan/fc/expansion/beam-gun/beam-gun.cpp b/nSide/higan/fc/expansion/beam-gun/beam-gun.cpp
new file mode 100644
index 0000000..65b20fe
--- /dev/null
+++ b/nSide/higan/fc/expansion/beam-gun/beam-gun.cpp
@@ -0,0 +1,131 @@
+BeamGun::BeamGun() {
+  create(Expansion::Enter, system.colorburst() * 6.0);
+  sprite = Emulator::video.createSprite(16, 16);
+  sprite->setPixels(Resource::Sprite::CrosshairGreenSmall);
+
+  latched = 0;
+  counter = 0;
+
+  //center cursor onscreen
+  x = 256 / 2;
+  y = 240 / 2;
+
+  light       = false;
+  trigger     = false;
+  lighttime   = 0;
+  triggertime = 0;
+  offscreen   = false;
+
+  triggerlock = false;
+
+  prev = 0;
+}
+
+BeamGun::~BeamGun() {
+  Emulator::video.removeSprite(sprite);
+}
+
+auto BeamGun::main() -> void {
+  uint next = ppu.vcounter() * 341 + ppu.hcounter();
+
+  if(lighttime > 0) {
+    lighttime -= 1;
+  }
+
+  if(!offscreen) {
+    uint target = y * 341 + x + 8;
+    if(next >= target && prev < target) {
+      //CRT raster detected
+      //light remains in the gun for 10-25 scanlines
+      if(readLight()) lighttime = 341 * 16;
+    }
+  }
+
+  if(next < prev) {
+    if(triggertime > 0) triggertime -= 1;
+    //Vcounter wrapped back to zero; update cursor coordinates for start of new frame
+    int nx = interface->inputPoll(ID::Port::Expansion, ID::Device::BeamGun, X);
+    int ny = interface->inputPoll(ID::Port::Expansion, ID::Device::BeamGun, Y);
+    nx += x;
+    ny += y;
+    x = max(-16, min(256 + 16, nx));
+    y = max(-16, min(240 + 16, ny));
+    offscreen = (x < 0 || y < 0 || x >= 256 || y >= 240);
+    sprite->setPosition(x - 8, y - 8);
+    sprite->setVisible(true);
+  }
+
+  prev = next;
+  step(3);
+  synchronize(cpu);
+}
+
+auto BeamGun::data1() -> bool {
+  return 0;
+}
+
+auto BeamGun::data2() -> uint5 {
+  if(!system.vs()) {
+    bool newtrigger = interface->inputPoll(ID::Port::Expansion, ID::Device::BeamGun, Trigger);
+    if(newtrigger && !triggerlock) {
+      triggertime = 3;
+      triggerlock = true;
+    } else if(!newtrigger) {
+      triggerlock = false;
+    }
+    light = lighttime > 0;
+    trigger = triggertime > 0;
+
+    return (trigger << 4) | ((!light) << 3);
+  } else {
+    if(counter >= 8) return 1;
+    if(latched == 1) return 0;
+
+    switch(counter++) {
+    case 0: return 0;
+    case 1: return 0;
+    case 2: return 0;
+    case 3: return 0;
+    case 4: return 1; // connected
+    case 5: return 0;
+    case 6: return light;
+    case 7: return trigger;
+    }
+  }
+}
+
+auto BeamGun::readLight() -> bool {
+  if(offscreen) return false;
+  uint32 paletteIndex = ppu.output[y * 256 + x];
+  uint color;
+  switch(ppu.version) {
+  default:
+    return ((paletteIndex & 0x20) && ((paletteIndex & 0x0f) < 0x0d));
+  case PPU::Version::RP2C04_0001:
+    color = PPU::RP2C04_0001[paletteIndex & 63];
+    break;
+  case PPU::Version::RP2C04_0002:
+    color = PPU::RP2C04_0002[paletteIndex & 63];
+    break;
+  case PPU::Version::RP2C04_0003:
+    color = PPU::RP2C04_0003[paletteIndex & 63];
+    break;
+  case PPU::Version::RP2C04_0004:
+    color = PPU::RP2C04_0004[paletteIndex & 63];
+    break;
+  }
+  if((color & 0xf00) > 0x600) return true;
+  if((color & 0x0f0) > 0x060) return true;
+  if((color & 0x00f) > 0x006) return true;
+  return false;
+}
+
+auto BeamGun::write(uint3 data) -> void {
+  if(latched == data.bit(0)) return;
+  latched = data.bit(0);
+  if(system.vs() && latched == 0) {
+    counter = 0;
+    trigger = interface->inputPoll(ID::Port::Expansion, ID::Device::BeamGun, Trigger);
+    light = lighttime > 0;
+  }
+}
diff --git a/nSide/higan/fc/expansion/beam-gun/beam-gun.hpp b/nSide/higan/fc/expansion/beam-gun/beam-gun.hpp
new file mode 100644
index 0000000..bc7816c
--- /dev/null
+++ b/nSide/higan/fc/expansion/beam-gun/beam-gun.hpp
@@ -0,0 +1,33 @@
+struct BeamGun : Expansion {
+  shared_pointer<Emulator::Sprite> sprite;
+
+  enum : uint {
+    X, Y, Trigger,
+  };
+
+  BeamGun();
+  ~BeamGun();
+
+  auto main() -> void;
+  auto data1() -> bool;
+  auto data2() -> uint5;
+  auto readLight() -> bool;
+  auto write(uint3 data) -> void;
+
+private:
+  bool latched;
+  uint counter; // VS. System
+
+  int x;
+  int y;
+
+  bool light;
+  bool trigger;
+  uint lighttime;
+  uint triggertime;
+  bool offscreen;
+
+  bool triggerlock;
+
+  uint prev;
+};
diff --git a/nSide/higan/fc/expansion/expansion.cpp b/nSide/higan/fc/expansion/expansion.cpp
new file mode 100644
index 0000000..c4039c8
--- /dev/null
+++ b/nSide/higan/fc/expansion/expansion.cpp
@@ -0,0 +1,32 @@
+#include <fc/fc.hpp>
+
+namespace Famicom {
+
+#include "gamepad/gamepad.cpp"
+#include "joypair/joypair.cpp"
+#include "four-players/four-players.cpp"
+#include "beam-gun/beam-gun.cpp"
+#include "family-keyboard/family-keyboard.cpp"
+#include "family-trainer/family-trainer.cpp"
+#include "vaus/vaus.cpp"
+#include "sfc-gamepad/sfc-gamepad.cpp"
+#include "mouse/mouse.cpp"
+
+Expansion::Expansion() {
+  if(!handle()) create(Expansion::Enter, 1);
+}
+
+Expansion::~Expansion() {
+  scheduler.remove(*this);
+}
+
+auto Expansion::Enter() -> void {
+  while(true) scheduler.synchronize(), peripherals.expansionPort->main();
+}
+
+auto Expansion::main() -> void {
+  step(1);
+  synchronize(cpu);
+}
+
+}
diff --git a/nSide/higan/fc/expansion/expansion.hpp b/nSide/higan/fc/expansion/expansion.hpp
new file mode 100644
index 0000000..20d846a
--- /dev/null
+++ b/nSide/higan/fc/expansion/expansion.hpp
@@ -0,0 +1,43 @@
+// Famicom expansion port pinout:
+//              console                             device
+// /--------------------------------\ /--------------------------------\
+// \(01)(02)(03)(04)(05)(06)(07)(08)/ \(08)(07)(06)(05)(04)(03)(02)(01)/
+//  \ (09)(10)(11)(12)(13)(14)(15) /   \ (15)(14)(13)(12)(11)(10)(09) /
+//   \----------------------------/     \----------------------------/
+// pin  name     register
+// 01:  gnd
+// 02:  sound
+// 03:  irq
+// 04:  data2.4  $4017.d4 read
+// 05:  data2.3  $4017.d3 read
+// 06:  data2.2  $4017.d2 read
+// 07:  data2.1  $4017.d1 read
+// 08:  data2.0  $4017.d0 read
+// 09:  clock 2  $4017 read
+// 10:  out 2    $4016.d2 write
+// 11:  out 1    $4016.d1 write
+// 12:  latch    $4016.d0 write
+// 13:  data1.1  $4016.d1 read
+// 14:  clock 1  $4016 read
+// 15:  +5v
+
+struct Expansion : Thread {
+  Expansion();
+  virtual ~Expansion();
+  static auto Enter() -> void;
+
+  virtual auto main() -> void;
+  virtual auto data1() -> bool { return 0; }
+  virtual auto data2() -> uint5 { return 0; }
+  virtual auto write(uint3 data) -> void {}
+};
+
+#include "gamepad/gamepad.hpp"
+#include "joypair/joypair.hpp"
+#include "four-players/four-players.hpp"
+#include "beam-gun/beam-gun.hpp"
+#include "family-keyboard/family-keyboard.hpp"
+#include "family-trainer/family-trainer.hpp"
+#include "vaus/vaus.hpp"
+#include "sfc-gamepad/sfc-gamepad.hpp"
+#include "mouse/mouse.hpp"
diff --git a/nSide/higan/fc/expansion/family-keyboard/family-keyboard.cpp b/nSide/higan/fc/expansion/family-keyboard/family-keyboard.cpp
new file mode 100644
index 0000000..33eae11
--- /dev/null
+++ b/nSide/higan/fc/expansion/family-keyboard/family-keyboard.cpp
@@ -0,0 +1,57 @@
+FamilyKeyboard::FamilyKeyboard() {
+  column = 0;
+  row    = 0;
+}
+
+auto FamilyKeyboard::data1() -> bool {
+  //Data Recorder
+  return 0;
+}
+
+auto FamilyKeyboard::data2() -> uint5 {
+  static const uint matrix0[] = {
+    F8,        RETURN,     LeftBracket, RightBracket,
+    F7,        AtSign,     Colon,       Semicolon,
+    F6,        O,          L,           K,
+    F5,        I,          U,           J,
+    F4,        Y,          G,           H,
+    F3,        T,          R,           D,
+    F2,        W,          S,           A,
+    F1,        ESC,        Q,           CTR,
+    CLR_HOME,  Up,         Right,       Left,
+  };
+  static const uint matrix1[] = {
+    Kana,      SHIFTRight, En,          STOP,
+    KanaN,     Solidus,    HyphenMinus, Circumflex,
+    FullStop,  Comma,      P,           Digit0,
+    M,         N,          Digit9,      Digit8,
+    B,         V,          Digit7,      Digit6,
+    F,         C,          Digit5,      Digit4,
+    X,         Z,          E,           Digit3,
+    SHIFTLeft, GRPH,       Digit1,      Digit2,
+    Down,      Space,      DEL,         INS,
+  };
+
+  if(row == 9) return 0x1e;
+  const uint* matrix = column ? matrix1 : matrix0;
+  uint keys[] = {
+    matrix[(row << 2) | 0],
+    matrix[(row << 2) | 1],
+    matrix[(row << 2) | 2],
+    matrix[(row << 2) | 3],
+  };
+  return (
+    !interface->inputPoll(ID::Port::Expansion, ID::Device::FamilyKeyboard, keys[0]) << 1
+  | !interface->inputPoll(ID::Port::Expansion, ID::Device::FamilyKeyboard, keys[1]) << 2
+  | !interface->inputPoll(ID::Port::Expansion, ID::Device::FamilyKeyboard, keys[2]) << 3
+  | !interface->inputPoll(ID::Port::Expansion, ID::Device::FamilyKeyboard, keys[3]) << 4
+  );
+}
+
+auto FamilyKeyboard::write(uint3 data) -> void {
+  if(data.bit(2)) {
+    if(column && !data.bit(1)) row = (row + 1) % 10;
+    column = data.bit(1);
+    if(data.bit(0)) row = 0;
+  }
+}
diff --git a/nSide/higan/fc/expansion/family-keyboard/family-keyboard.hpp b/nSide/higan/fc/expansion/family-keyboard/family-keyboard.hpp
new file mode 100644
index 0000000..bb9fcb9
--- /dev/null
+++ b/nSide/higan/fc/expansion/family-keyboard/family-keyboard.hpp
@@ -0,0 +1,23 @@
+struct FamilyKeyboard : Expansion {
+  enum : uint {
+    F1, F2, F3, F4, F5, F6, F7, F8,
+    Digit1, Digit2, Digit3, Digit4, Digit5, Digit6, Digit7, Digit8, Digit9, Digit0,
+    HyphenMinus, Circumflex, En, STOP,
+    ESC,     Q, W, E, R, T, Y, U, I, O, P, AtSign, LeftBracket, RETURN,
+    CTR,      A, S, D, F, G, H, J, K, L, Semicolon, Colon, RightBracket, Kana,
+    SHIFTLeft, Z, X, C, V, B, N, M, Comma, FullStop, Solidus, KanaN, SHIFTRight,
+    GRPH, Space,
+    CLR_HOME, INS, DEL,
+    Up, Left, Right, Down,
+  };
+
+  FamilyKeyboard();
+
+  auto data1() -> bool;
+  auto data2() -> uint5;
+  auto write(uint3 data) -> void;
+
+private:
+  bool column;
+  uint row;
+};
diff --git a/nSide/higan/fc/expansion/family-trainer/family-trainer.cpp b/nSide/higan/fc/expansion/family-trainer/family-trainer.cpp
new file mode 100644
index 0000000..45306ec
--- /dev/null
+++ b/nSide/higan/fc/expansion/family-trainer/family-trainer.cpp
@@ -0,0 +1,46 @@
+FamilyTrainer::FamilyTrainer() {
+  latched = 0;
+  counter = 0;
+}
+
+auto FamilyTrainer::data1() -> bool {
+  return 0;
+}
+
+auto FamilyTrainer::data2() -> uint5 {
+  if(counter >= 8) return 0x18;
+  if(latched == 1) return (interface->inputPoll(ID::Port::Expansion, ID::Device::FamilyTrainer, 1) << 1) | (interface->inputPoll(ID::Port::Expansion, ID::Device::FamilyTrainer, 3) << 2);
+
+  switch(counter++) {
+  case 0: return (b2  << 3) | (b4  << 4);
+  case 1: return (b1  << 3) | (b3  << 4);
+  case 2: return (b5  << 3) | (b12 << 4);
+  case 3: return (b9  << 3) | (b8  << 4);
+  case 4: return (b6  << 3) | (1   << 4);
+  case 5: return (b10 << 3) | (1   << 4);
+  case 6: return (b11 << 3) | (1   << 4);
+  case 7: return (b7  << 3) | (1   << 4);
+  }
+  unreachable;
+}
+
+auto FamilyTrainer::write(uint3 data) -> void {
+  if(latched == data.bit(0)) return;
+  latched = data.bit(0);
+  counter = 0;
+
+  if(latched == 0) {
+    b1  = interface->inputPoll(ID::Port::Expansion, ID::Device::FamilyTrainer,  0);
+    b2  = interface->inputPoll(ID::Port::Expansion, ID::Device::FamilyTrainer,  1);
+    b3  = interface->inputPoll(ID::Port::Expansion, ID::Device::FamilyTrainer,  2);
+    b4  = interface->inputPoll(ID::Port::Expansion, ID::Device::FamilyTrainer,  3);
+    b5  = interface->inputPoll(ID::Port::Expansion, ID::Device::FamilyTrainer,  4);
+    b6  = interface->inputPoll(ID::Port::Expansion, ID::Device::FamilyTrainer,  5);
+    b7  = interface->inputPoll(ID::Port::Expansion, ID::Device::FamilyTrainer,  6);
+    b8  = interface->inputPoll(ID::Port::Expansion, ID::Device::FamilyTrainer,  7);
+    b9  = interface->inputPoll(ID::Port::Expansion, ID::Device::FamilyTrainer,  8);
+    b10 = interface->inputPoll(ID::Port::Expansion, ID::Device::FamilyTrainer,  9);
+    b11 = interface->inputPoll(ID::Port::Expansion, ID::Device::FamilyTrainer, 10);
+    b12 = interface->inputPoll(ID::Port::Expansion, ID::Device::FamilyTrainer, 11);
+  }
+}
diff --git a/nSide/higan/fc/expansion/family-trainer/family-trainer.hpp b/nSide/higan/fc/expansion/family-trainer/family-trainer.hpp
new file mode 100644
index 0000000..6d89389
--- /dev/null
+++ b/nSide/higan/fc/expansion/family-trainer/family-trainer.hpp
@@ -0,0 +1,15 @@
+struct FamilyTrainer : Expansion {
+  FamilyTrainer();
+
+  auto data1() -> bool;
+  auto data2() -> uint5;
+  auto write(uint3 data) -> void;
+
+private:
+  bool latched;
+  uint counter;
+
+  boolean b1, b2,  b3,  b4;
+  boolean b5, b6,  b7,  b8;
+  boolean b9, b10, b11, b12;
+};
diff --git a/nSide/higan/fc/expansion/four-players/four-players.cpp b/nSide/higan/fc/expansion/four-players/four-players.cpp
new file mode 100644
index 0000000..a62b70e
--- /dev/null
+++ b/nSide/higan/fc/expansion/four-players/four-players.cpp
@@ -0,0 +1,98 @@
+FourPlayers::FourPlayers() {
+  latched = 0;
+  counter1 = 0;
+  counter2 = 0;
+}
+
+auto FourPlayers::data1() -> bool {
+  if(counter1 >= 24) return 1;
+  if(latched) return interface->inputPoll(ID::Port::Expansion, ID::Device::FourPlayers, 0 + A);
+
+  auto& A = gamepads[0];
+  auto& B = gamepads[2];
+
+  switch(counter1++) {
+  case  0: return A.a;
+  case  1: return A.b;
+  case  2: return A.select;
+  case  3: return A.start;
+  case  4: return A.up & !A.down;
+  case  5: return A.down & !A.up;
+  case  6: return A.left & !A.right;
+  case  7: return A.right & !A.left;
+  case  8: return B.a;
+  case  9: return B.b;
+  case 10: return B.select;
+  case 11: return B.start;
+  case 12: return B.up & !B.down;
+  case 13: return B.down & !B.up;
+  case 14: return B.left & !B.right;
+  case 15: return B.right & !B.left;
+  case 16: return 0;
+  case 17: return 0;
+  case 18: return 1;
+  case 19: return 0;
+  case 20: return 0;
+  case 21: return 0;
+  case 22: return 0;
+  case 23: return 0;
+  }
+  unreachable;
+}
+
+auto FourPlayers::data2() -> uint5 {
+  if(counter2 >= 24) return 2;
+  if(latched) return interface->inputPoll(ID::Port::Expansion, ID::Device::FourPlayers, 8 + A) << 1;
+
+  auto& A = gamepads[1];
+  auto& B = gamepads[3];
+
+  switch(counter2++) {
+  case  0: return A.a << 1;
+  case  1: return A.b << 1;
+  case  2: return A.select << 1;
+  case  3: return A.start << 1;
+  case  4: return (A.up & !A.down) << 1;
+  case  5: return (A.down & !A.up) << 1;
+  case  6: return (A.left & !A.right) << 1;
+  case  7: return (A.right & !A.left) << 1;
+  case  8: return B.a << 1;
+  case  9: return B.b << 1;
+  case 10: return B.select << 1;
+  case 11: return B.start << 1;
+  case 12: return (B.up & !B.down) << 1;
+  case 13: return (B.down & !B.up) << 1;
+  case 14: return (B.left & !B.right) << 1;
+  case 15: return (B.right & !B.left) << 1;
+  case 16: return 0;
+  case 17: return 0;
+  case 18: return 0;
+  case 19: return 2;
+  case 20: return 0;
+  case 21: return 0;
+  case 22: return 0;
+  case 23: return 0;
+  }
+  unreachable;
+}
+
+auto FourPlayers::write(uint3 data) -> void {
+  if(latched == data.bit(0)) return;
+  latched = data.bit(0);
+  counter1 = 0;
+  counter2 = 0;
+
+  if(latched == 0) {
+    for(uint id : range(4)) {
+      auto& gamepad = gamepads[id];
+      gamepad.a      = interface->inputPoll(ID::Port::Expansion, ID::Device::FourPlayers, id * 8 + A);
+      gamepad.b      = interface->inputPoll(ID::Port::Expansion, ID::Device::FourPlayers, id * 8 + B);
+      gamepad.select = interface->inputPoll(ID::Port::Expansion, ID::Device::FourPlayers, id * 8 + Select);
+      gamepad.start  = interface->inputPoll(ID::Port::Expansion, ID::Device::FourPlayers, id * 8 + Start);
+      gamepad.up     = interface->inputPoll(ID::Port::Expansion, ID::Device::FourPlayers, id * 8 + Up);
+      gamepad.down   = interface->inputPoll(ID::Port::Expansion, ID::Device::FourPlayers, id * 8 + Down);
+      gamepad.left   = interface->inputPoll(ID::Port::Expansion, ID::Device::FourPlayers, id * 8 + Left);
+      gamepad.right  = interface->inputPoll(ID::Port::Expansion, ID::Device::FourPlayers, id * 8 + Right);
+    }
+  }
+}
diff --git a/nSide/higan/fc/expansion/four-players/four-players.hpp b/nSide/higan/fc/expansion/four-players/four-players.hpp
new file mode 100644
index 0000000..3c4e2a3
--- /dev/null
+++ b/nSide/higan/fc/expansion/four-players/four-players.hpp
@@ -0,0 +1,21 @@
+struct FourPlayers : Expansion {
+  enum : uint {
+    Up, Down, Left, Right, B, A, Select, Start,
+  };
+
+  FourPlayers();
+
+  auto data1() -> bool;
+  auto data2() -> uint5;
+  auto write(uint3 data) -> void;
+
+private:
+  bool latched;
+  uint counter1;
+  uint counter2;
+
+  struct Gamepad {
+    boolean a, b, select, start;
+    boolean up, down, left, right;
+  } gamepads[4];
+};
diff --git a/nSide/higan/fc/expansion/gamepad/gamepad.cpp b/nSide/higan/fc/expansion/gamepad/gamepad.cpp
new file mode 100644
index 0000000..b61adfb
--- /dev/null
+++ b/nSide/higan/fc/expansion/gamepad/gamepad.cpp
@@ -0,0 +1,43 @@
+GamepadE::GamepadE() {
+  latched = 0;
+  counter = 0;
+}
+
+auto GamepadE::data1() -> bool {
+  if(counter >= 8) return 1;
+  if(latched == 1) return interface->inputPoll(ID::Port::Expansion, ID::Device::GamepadE, A);
+
+  //note: D-pad physically prevents up+down and left+right from being pressed at the same time
+  switch(counter++) {
+  case 0: return a;
+  case 1: return b;
+  case 2: return select;
+  case 3: return start;
+  case 4: return up & !down;
+  case 5: return down & !up;
+  case 6: return left & !right;
+  case 7: return right & !left;
+  }
+  unreachable;
+}
+
+auto GamepadE::data2() -> uint5 {
+  return 0;
+}
+
+auto GamepadE::write(uint3 data) -> void {
+  if(latched == data.bit(0)) return;
+  latched = data.bit(0);
+  counter = 0;
+
+  if(latched == 0) {
+    a      = interface->inputPoll(ID::Port::Expansion, ID::Device::GamepadE, A);
+    b      = interface->inputPoll(ID::Port::Expansion, ID::Device::GamepadE, B);
+    select = interface->inputPoll(ID::Port::Expansion, ID::Device::GamepadE, Select);
+    start  = interface->inputPoll(ID::Port::Expansion, ID::Device::GamepadE, Start);
+    up     = interface->inputPoll(ID::Port::Expansion, ID::Device::GamepadE, Up);
+    down   = interface->inputPoll(ID::Port::Expansion, ID::Device::GamepadE, Down);
+    left   = interface->inputPoll(ID::Port::Expansion, ID::Device::GamepadE, Left);
+    right  = interface->inputPoll(ID::Port::Expansion, ID::Device::GamepadE, Right);
+  }
+}
diff --git a/nSide/higan/fc/expansion/gamepad/gamepad.hpp b/nSide/higan/fc/expansion/gamepad/gamepad.hpp
new file mode 100644
index 0000000..fc7a07e
--- /dev/null
+++ b/nSide/higan/fc/expansion/gamepad/gamepad.hpp
@@ -0,0 +1,18 @@
+struct GamepadE : Expansion {
+  enum : uint {
+    Up, Down, Left, Right, B, A, Select, Start,
+  };
+
+  GamepadE();
+
+  auto data1() -> bool;
+  auto data2() -> uint5;
+  auto write(uint3 data) -> void;
+
+private:
+  bool latched;
+  uint counter;
+
+  boolean a, b, select, start;
+  boolean up, down, left, right;
+};
diff --git a/nSide/higan/fc/expansion/joypair/joypair.cpp b/nSide/higan/fc/expansion/joypair/joypair.cpp
new file mode 100644
index 0000000..7c0d323
--- /dev/null
+++ b/nSide/higan/fc/expansion/joypair/joypair.cpp
@@ -0,0 +1,64 @@
+JoyPair::JoyPair() {
+  latched = 0;
+  counter1 = 0;
+  counter2 = 0;
+}
+
+auto JoyPair::data1() -> bool {
+  if(counter1 >= 8) return 1;
+  if(latched) return interface->inputPoll(ID::Port::Expansion, ID::Device::JoyPair, 0 + A);
+
+  auto& A = gamepads[0];
+
+  switch(counter1++) {
+  case 0: return A.a;
+  case 1: return A.b;
+  case 2: return A.select;
+  case 3: return A.start;
+  case 4: return A.up & !A.down;
+  case 5: return A.down & !A.up;
+  case 6: return A.left & !A.right;
+  case 7: return A.right & !A.left;
+  }
+  unreachable;
+}
+
+auto JoyPair::data2() -> uint5 {
+  if(counter2 >= 8) return 2;
+  if(latched) return interface->inputPoll(ID::Port::Expansion, ID::Device::JoyPair, 8 + A) << 1;
+
+  auto& B = gamepads[1];
+
+  switch(counter2++) {
+  case 0: return B.a << 1;
+  case 1: return B.b << 1;
+  case 2: return B.select << 1;
+  case 3: return B.start << 1;
+  case 4: return (B.up & !B.down) << 1;
+  case 5: return (B.down & !B.up) << 1;
+  case 6: return (B.left & !B.right) << 1;
+  case 7: return (B.right & !B.left) << 1;
+  }
+  unreachable;
+}
+
+auto JoyPair::write(uint3 data) -> void {
+  if(latched == data.bit(0)) return;
+  latched = data.bit(0);
+  counter1 = 0;
+  counter2 = 0;
+
+  if(latched == 0) {
+    for(uint id : range(2)) {
+      auto& gamepad = gamepads[id];
+      gamepad.a      = interface->inputPoll(ID::Port::Expansion, ID::Device::JoyPair, id * 8 + A);
+      gamepad.b      = interface->inputPoll(ID::Port::Expansion, ID::Device::JoyPair, id * 8 + B);
+      gamepad.select = interface->inputPoll(ID::Port::Expansion, ID::Device::JoyPair, id * 8 + Select);
+      gamepad.start  = interface->inputPoll(ID::Port::Expansion, ID::Device::JoyPair, id * 8 + Start);
+      gamepad.up     = interface->inputPoll(ID::Port::Expansion, ID::Device::JoyPair, id * 8 + Up);
+      gamepad.down   = interface->inputPoll(ID::Port::Expansion, ID::Device::JoyPair, id * 8 + Down);
+      gamepad.left   = interface->inputPoll(ID::Port::Expansion, ID::Device::JoyPair, id * 8 + Left);
+      gamepad.right  = interface->inputPoll(ID::Port::Expansion, ID::Device::JoyPair, id * 8 + Right);
+    }
+  }
+}
diff --git a/nSide/higan/fc/expansion/joypair/joypair.hpp b/nSide/higan/fc/expansion/joypair/joypair.hpp
new file mode 100644
index 0000000..3e67c31
--- /dev/null
+++ b/nSide/higan/fc/expansion/joypair/joypair.hpp
@@ -0,0 +1,21 @@
+struct JoyPair : Expansion {
+  enum : uint {
+    Up, Down, Left, Right, B, A, Select, Start,
+  };
+
+  JoyPair();
+
+  auto data1() -> bool;
+  auto data2() -> uint5;
+  auto write(uint3 data) -> void;
+
+private:
+  bool latched;
+  uint counter1;
+  uint counter2;
+
+  struct Gamepad {
+    boolean a, b, select, start;
+    boolean up, down, left, right;
+  } gamepads[2];
+};
diff --git a/nSide/higan/fc/expansion/mouse/mouse.cpp b/nSide/higan/fc/expansion/mouse/mouse.cpp
new file mode 100644
index 0000000..c522c4e
--- /dev/null
+++ b/nSide/higan/fc/expansion/mouse/mouse.cpp
@@ -0,0 +1,90 @@
+MouseE::MouseE() {
+  latched = 0;
+  counter = 0;
+
+  speed = 0;
+  x = 0;
+  y = 0;
+  dx = 0;
+  dy = 0;
+  l = 0;
+  r = 0;
+}
+
+auto MouseE::data1() -> bool {
+  if(latched == 1) {
+    speed = (speed + 1) % 3;
+    return 0;
+  }
+
+  if(counter >= 32) return 1;
+
+  switch(counter++) { default:
+  case  0: return 0;
+  case  1: return 0;
+  case  2: return 0;
+  case  3: return 0;
+  case  4: return 0;
+  case  5: return 0;
+  case  6: return 0;
+  case  7: return 0;
+
+  case  8: return r;
+  case  9: return l;
+  case 10: return (speed >> 1) & 1;
+  case 11: return (speed >> 0) & 1;
+
+  case 12: return 0;  //signature
+  case 13: return 0;  // ||
+  case 14: return 0;  // ||
+  case 15: return 1;  // ||
+
+  case 16: return dy;
+  case 17: return (y >> 6) & 1;
+  case 18: return (y >> 5) & 1;
+  case 19: return (y >> 4) & 1;
+  case 20: return (y >> 3) & 1;
+  case 21: return (y >> 2) & 1;
+  case 22: return (y >> 1) & 1;
+  case 23: return (y >> 0) & 1;
+
+  case 24: return dx;
+  case 25: return (x >> 6) & 1;
+  case 26: return (x >> 5) & 1;
+  case 27: return (x >> 4) & 1;
+  case 28: return (x >> 3) & 1;
+  case 29: return (x >> 2) & 1;
+  case 30: return (x >> 1) & 1;
+  case 31: return (x >> 0) & 1;
+  }
+}
+
+auto MouseE::data2() -> uint5 {
+  return 0;
+}
+
+auto MouseE::write(uint3 data) -> void {
+  if(latched == data.bit(0)) return;
+  latched = data.bit(0);
+  counter = 0;
+
+  x = interface->inputPoll(ID::Port::Expansion, ID::Device::MouseE, X);  //-n = left, 0 = center, +n = right
+  y = interface->inputPoll(ID::Port::Expansion, ID::Device::MouseE, Y);  //-n = up,   0 = center, +n = down
+  l = interface->inputPoll(ID::Port::Expansion, ID::Device::MouseE, Left);
+  r = interface->inputPoll(ID::Port::Expansion, ID::Device::MouseE, Right);
+
+  dx = x < 0;  //0 = right, 1 = left
+  dy = y < 0;  //0 = down,  1 = up
+
+  if(x < 0) x = -x;  //abs(position_x)
+  if(y < 0) y = -y;  //abs(position_y)
+
+  double multiplier = 1.0;
+  if(speed == 1) multiplier = 1.5;
+  if(speed == 2) multiplier = 2.0;
+  x = (double)x * multiplier;
+  y = (double)y * multiplier;
+
+  x = min(127, x);
+  y = min(127, y);
+}
diff --git a/nSide/higan/fc/expansion/mouse/mouse.hpp b/nSide/higan/fc/expansion/mouse/mouse.hpp
new file mode 100644
index 0000000..7831f0f
--- /dev/null
+++ b/nSide/higan/fc/expansion/mouse/mouse.hpp
@@ -0,0 +1,23 @@
+struct MouseE : Expansion {
+  enum : uint {
+    X, Y, Left, Right,
+  };
+
+  MouseE();
+
+  auto data1() -> bool;
+  auto data2() -> uint5;
+  auto write(uint3 data) -> void;
+
+private:
+  bool latched;
+  uint counter;
+
+  uint speed;  //0 = slow, 1 = normal, 2 = fast
+  int x;       //x-coordinate
+  int y;       //y-coordinate
+  bool dx;     //x-direction
+  bool dy;     //y-direction
+  bool l;      //left button
+  bool r;      //right button
+};
diff --git a/nSide/higan/fc/expansion/sfc-gamepad/sfc-gamepad.cpp b/nSide/higan/fc/expansion/sfc-gamepad/sfc-gamepad.cpp
new file mode 100644
index 0000000..042dc37
--- /dev/null
+++ b/nSide/higan/fc/expansion/sfc-gamepad/sfc-gamepad.cpp
@@ -0,0 +1,52 @@
+SFCGamepad::SFCGamepad() {
+  latched = 0;
+  counter = 0;
+}
+
+auto SFCGamepad::data1() -> bool {
+  if(counter >= 16) return 1;
+  if(latched == 1) return interface->inputPoll(ID::Port::Expansion, ID::Device::SFCGamepad, 0);
+
+  //note: D-pad physically prevents up+down and left+right from being pressed at the same time
+  switch(counter++) {
+  case  0: return b;
+  case  1: return y;
+  case  2: return select;
+  case  3: return start;
+  case  4: return up & !down;
+  case  5: return down & !up;
+  case  6: return left & !right;
+  case  7: return right & !left;
+  case  8: return a;
+  case  9: return x;
+  case 10: return l;
+  case 11: return r;
+  }
+
+  return 0;  //12-15: signature
+}
+
+auto SFCGamepad::data2() -> uint5 {
+  return 0;
+}
+
+auto SFCGamepad::write(uint3 data) -> void {
+  if(latched == data.bit(0)) return;
+  latched = data.bit(0);
+  counter = 0;
+
+  if(latched == 0) {
+    b      = interface->inputPoll(ID::Port::Expansion, ID::Device::SFCGamepad, B);
+    y      = interface->inputPoll(ID::Port::Expansion, ID::Device::SFCGamepad, Y);
+    select = interface->inputPoll(ID::Port::Expansion, ID::Device::SFCGamepad, Select);
+    start  = interface->inputPoll(ID::Port::Expansion, ID::Device::SFCGamepad, Start);
+    up     = interface->inputPoll(ID::Port::Expansion, ID::Device::SFCGamepad, Up);
+    down   = interface->inputPoll(ID::Port::Expansion, ID::Device::SFCGamepad, Down);
+    left   = interface->inputPoll(ID::Port::Expansion, ID::Device::SFCGamepad, Left);
+    right  = interface->inputPoll(ID::Port::Expansion, ID::Device::SFCGamepad, Right);
+    a      = interface->inputPoll(ID::Port::Expansion, ID::Device::SFCGamepad, A);
+    x      = interface->inputPoll(ID::Port::Expansion, ID::Device::SFCGamepad, X);
+    l      = interface->inputPoll(ID::Port::Expansion, ID::Device::SFCGamepad, L);
+    r      = interface->inputPoll(ID::Port::Expansion, ID::Device::SFCGamepad, R);
+  }
+}
diff --git a/nSide/higan/fc/expansion/sfc-gamepad/sfc-gamepad.hpp b/nSide/higan/fc/expansion/sfc-gamepad/sfc-gamepad.hpp
new file mode 100644
index 0000000..1189058
--- /dev/null
+++ b/nSide/higan/fc/expansion/sfc-gamepad/sfc-gamepad.hpp
@@ -0,0 +1,19 @@
+struct SFCGamepad : Expansion {
+  enum : uint {
+    Up, Down, Left, Right, B, A, Y, X, L, R, Select, Start,
+  };
+
+  SFCGamepad();
+
+  auto data1() -> bool;
+  auto data2() -> uint5;
+  auto write(uint3 data) -> void;
+
+private:
+  bool latched;
+  uint counter;
+
+  boolean b, y, select, start;
+  boolean up, down, left, right;
+  boolean a, x, l, r;
+};
diff --git a/nSide/higan/fc/expansion/vaus/vaus.cpp b/nSide/higan/fc/expansion/vaus/vaus.cpp
new file mode 100644
index 0000000..d8b312b
--- /dev/null
+++ b/nSide/higan/fc/expansion/vaus/vaus.cpp
@@ -0,0 +1,44 @@
+VausE::VausE() {
+  create(Expansion::Enter, system.colorburst() * 6.0);
+  latched = 0;
+  counter = 0;
+
+  x = 0;
+  control = 0;
+
+  prev = 0;
+}
+
+auto VausE::main() -> void {
+  uint next = ppu.vcounter() * 341 + ppu.hcounter();
+
+  if(next < prev) {
+    //Vcounter wrapped back to zero; update control knob for start of new frame
+    int nx = interface->inputPoll(ID::Port::Expansion, ID::Device::VausE, Control) * 160 / 256;
+    const uint8_t trimpot = 0x0d;
+    x = max(trimpot, min(trimpot + 0xa0, x - nx));
+  }
+
+  prev = next;
+  step(3);
+  synchronize(cpu);
+}
+
+auto VausE::data1() -> bool {
+  return interface->inputPoll(ID::Port::Expansion, ID::Device::VausE, Fire);
+}
+
+auto VausE::data2() -> uint5 {
+  if(latched == 1) return control.bit(7) << 1;
+  if(counter >= 8) return 0;
+
+  return control.bit(7 - counter++) << 1;
+}
+
+auto VausE::write(uint3 data) -> void {
+  if(latched == data.bit(0)) return;
+  latched = data.bit(0);
+  counter = 0;
+
+  control = x & 0xff;
+}
diff --git a/nSide/higan/fc/expansion/vaus/vaus.hpp b/nSide/higan/fc/expansion/vaus/vaus.hpp
new file mode 100644
index 0000000..a2667af
--- /dev/null
+++ b/nSide/higan/fc/expansion/vaus/vaus.hpp
@@ -0,0 +1,21 @@
+struct VausE : Expansion {
+  enum : uint {
+    Control, Fire,
+  };
+
+  VausE();
+
+  auto main() -> void;
+  auto data1() -> bool;
+  auto data2() -> uint5;
+  auto write(uint3 data) -> void;
+
+private:
+  bool latched;
+  uint counter;
+
+  int x;
+  uint8 control;
+
+  uint prev;
+};
diff --git a/higan/higan/fc/fc.hpp b/nSide/higan/fc/fc.hpp
index 8d241c3..4cc77e0 100644
--- a/higan/higan/fc/fc.hpp
+++ b/nSide/higan/fc/fc.hpp
@@ -8,7 +8,8 @@
 #include <emulator/scheduler.hpp>
 #include <emulator/cheat.hpp>
 
-#include <processor/r6502/r6502.hpp>
+#include <processor/mos6502/mos6502.hpp>
+#include <processor/z80/z80.hpp>
 
 namespace Famicom {
   using File = Emulator::File;
@@ -17,6 +18,13 @@ namespace Famicom {
   extern Scheduler scheduler;
   extern Cheat cheat;
 
+  enum class Model : uint {
+    Famicom,
+    VSSystem,
+    PlayChoice10,
+    FamicomBox,
+  };
+
   struct Thread : Emulator::Thread {
     auto create(auto (*entrypoint)() -> void, double frequency) -> void {
       Emulator::Thread::create(entrypoint, frequency);
@@ -29,12 +37,21 @@ namespace Famicom {
   };
 
   #include <fc/controller/controller.hpp>
-  #include <fc/system/system.hpp>
+  #include <fc/expansion/expansion.hpp>
+
   #include <fc/memory/memory.hpp>
-  #include <fc/cartridge/cartridge.hpp>
+  #include <fc/ppu/counter/counter.hpp>
+
   #include <fc/cpu/cpu.hpp>
   #include <fc/apu/apu.hpp>
   #include <fc/ppu/ppu.hpp>
+
+  #include <fc/system/system.hpp>
+  #include <fc/arcade/arcade.hpp>
+  #include <fc/cartridge/cartridge.hpp>
+
+  #include <fc/memory/memory-inline.hpp>
+  #include <fc/ppu/counter/counter-inline.hpp>
 }
 
 #include <fc/interface/interface.hpp>
diff --git a/higan/higan/fc/interface/interface.cpp b/nSide/higan/fc/interface/interface.cpp
index 17de2fe..16cc0dd 100644
--- a/higan/higan/fc/interface/interface.cpp
+++ b/nSide/higan/fc/interface/interface.cpp
@@ -7,7 +7,9 @@ Settings settings;
 
 Interface::Interface() {
   interface = this;
+  system.init();
 
+  information.preAlpha     = false;
   information.manufacturer = "Nintendo";
   information.name         = "Famicom";
   information.overscan     = true;
@@ -16,14 +18,21 @@ Interface::Interface() {
   information.capability.states = true;
   information.capability.cheats = true;
 
-  media.append({ID::Famicom, "Famicom", "fc"});
+  media.append({ID::Famicom,      "Famicom",       "fc",   Domain::Home});
+  media.append({ID::VSSystem,     "VS. System",    "vs",   Domain::Arcade});
+  media.append({ID::PlayChoice10, "PlayChoice-10", "pc10", Domain::Arcade});
+//media.append({ID::FamicomBox,   "FamicomBox",    "fcb",  Domain::Arcade});
 
-  Port controllerPort1{ID::Port::Controller1, "Controller Port 1"};
-  Port controllerPort2{ID::Port::Controller2, "Controller Port 2"};
+  Port controllerPort1{ID::Port::Controller1, "Controller Port 1", PlugAndPlay};
+  Port controllerPort2{ID::Port::Controller2, "Controller Port 2", PlugAndPlay};
+  Port expansionPort{ID::Port::Expansion, "Expansion Port", PlugAndPlay};
+  Port arcadePanel{ID::Port::Arcade, "Arcade Panel", Hardwired};
 
   { Device device{ID::Device::None, "None"};
     controllerPort1.devices.append(device);
     controllerPort2.devices.append(device);
+    expansionPort.devices.append(device);
+    arcadePanel.devices.append(device);
   }
 
   { Device device{ID::Device::Gamepad, "Gamepad"};
@@ -39,8 +48,266 @@ Interface::Interface() {
     controllerPort2.devices.append(device);
   }
 
+  { Device device{ID::Device::GamepadMic, "Gamepad Mic"};
+    device.inputs.append({0, "Up"    });
+    device.inputs.append({0, "Down"  });
+    device.inputs.append({0, "Left"  });
+    device.inputs.append({0, "Right" });
+    device.inputs.append({0, "B"     });
+    device.inputs.append({0, "A"     });
+    device.inputs.append({0, "Mic"   });
+    controllerPort2.devices.append(device);
+  }
+
+  { Device device{ID::Device::FourScore, "Four Score"};
+    for(uint p : {1,3}) {
+      device.inputs.append({0, {"Port ", p, " - ", "Up"    }});
+      device.inputs.append({0, {"Port ", p, " - ", "Down"  }});
+      device.inputs.append({0, {"Port ", p, " - ", "Left"  }});
+      device.inputs.append({0, {"Port ", p, " - ", "Right" }});
+      device.inputs.append({0, {"Port ", p, " - ", "B"     }});
+      device.inputs.append({0, {"Port ", p, " - ", "A"     }});
+      device.inputs.append({0, {"Port ", p, " - ", "Select"}});
+      device.inputs.append({0, {"Port ", p, " - ", "Start" }});
+    }
+    controllerPort1.devices.append(device);
+  }
+
+  { Device device{ID::Device::FourScore, "Four Score"};
+    for(uint p : {2,4}) {
+      device.inputs.append({0, {"Port ", p, " - ", "Up"    }});
+      device.inputs.append({0, {"Port ", p, " - ", "Down"  }});
+      device.inputs.append({0, {"Port ", p, " - ", "Left"  }});
+      device.inputs.append({0, {"Port ", p, " - ", "Right" }});
+      device.inputs.append({0, {"Port ", p, " - ", "B"     }});
+      device.inputs.append({0, {"Port ", p, " - ", "A"     }});
+      device.inputs.append({0, {"Port ", p, " - ", "Select"}});
+      device.inputs.append({0, {"Port ", p, " - ", "Start" }});
+    }
+    controllerPort2.devices.append(device);
+  }
+
+  { Device device{ID::Device::Zapper, "Zapper"};
+    device.inputs.append({1, "X-axis" });
+    device.inputs.append({1, "Y-axis" });
+    device.inputs.append({0, "Trigger"});
+    controllerPort2.devices.append(device);
+  }
+
+  { Device device{ID::Device::PowerPad, "Power Pad"};
+    for(uint n : range(12)) {
+      device.inputs.append({0, {"Button ", n + 1}});
+    }
+    controllerPort2.devices.append(device);
+  }
+
+  { Device device{ID::Device::Vaus, "Arkanoid Vaus"};
+    device.inputs.append({1, "Control Knob"});
+    device.inputs.append({0, "Fire Button" });
+    controllerPort2.devices.append(device);
+  }
+
+  { Device device{ID::Device::SNESGamepad, "SNES Gamepad"};
+    device.inputs.append({0, "Up"    });
+    device.inputs.append({0, "Down"  });
+    device.inputs.append({0, "Left"  });
+    device.inputs.append({0, "Right" });
+    device.inputs.append({0, "B"     });
+    device.inputs.append({0, "A"     });
+    device.inputs.append({0, "Y"     });
+    device.inputs.append({0, "X"     });
+    device.inputs.append({0, "L"     });
+    device.inputs.append({0, "R"     });
+    device.inputs.append({0, "Select"});
+    device.inputs.append({0, "Start" });
+    controllerPort1.devices.append(device);
+    controllerPort2.devices.append(device);
+  }
+
+  { Device device{ID::Device::Mouse, "Mouse"};
+    device.inputs.append({1, "X-axis"});
+    device.inputs.append({1, "Y-axis"});
+    device.inputs.append({0, "Left"  });
+    device.inputs.append({0, "Right" });
+    controllerPort1.devices.append(device);
+    controllerPort2.devices.append(device);
+  }
+
+  { Device device{ID::Device::GamepadE, "Gamepad"};
+    device.inputs.append({0, "Up"    });
+    device.inputs.append({0, "Down"  });
+    device.inputs.append({0, "Left"  });
+    device.inputs.append({0, "Right" });
+    device.inputs.append({0, "B"     });
+    device.inputs.append({0, "A"     });
+    device.inputs.append({0, "Select"});
+    device.inputs.append({0, "Start" });
+    expansionPort.devices.append(device);
+  }
+
+  { Device device{ID::Device::JoyPair, "JoyPair"};
+    for(uint p : {3,4}) {
+      device.inputs.append({0, {"Port ", p, " - ", "Up"    }});
+      device.inputs.append({0, {"Port ", p, " - ", "Down"  }});
+      device.inputs.append({0, {"Port ", p, " - ", "Left"  }});
+      device.inputs.append({0, {"Port ", p, " - ", "Right" }});
+      device.inputs.append({0, {"Port ", p, " - ", "B"     }});
+      device.inputs.append({0, {"Port ", p, " - ", "A"     }});
+      device.inputs.append({0, {"Port ", p, " - ", "Select"}});
+      device.inputs.append({0, {"Port ", p, " - ", "Start" }});
+    }
+    expansionPort.devices.append(device);
+  }
+
+  { Device device{ID::Device::FourPlayers, "4-Players Adaptor"};
+    for(uint p : {1,2,3,4}) {
+      device.inputs.append({0, {"Port ", p, " - ", "Up"    }});
+      device.inputs.append({0, {"Port ", p, " - ", "Down"  }});
+      device.inputs.append({0, {"Port ", p, " - ", "Left"  }});
+      device.inputs.append({0, {"Port ", p, " - ", "Right" }});
+      device.inputs.append({0, {"Port ", p, " - ", "B"     }});
+      device.inputs.append({0, {"Port ", p, " - ", "A"     }});
+      device.inputs.append({0, {"Port ", p, " - ", "Select"}});
+      device.inputs.append({0, {"Port ", p, " - ", "Start" }});
+    }
+    expansionPort.devices.append(device);
+  }
+
+  { Device device{ID::Device::BeamGun, "Beam Gun"};
+    device.inputs.append({1, "X-axis" });
+    device.inputs.append({1, "Y-axis" });
+    device.inputs.append({0, "Trigger"});
+    expansionPort.devices.append(device);
+  }
+
+  { Device device{ID::Device::FamilyKeyboard, "Family BASIC Keyboard"};
+    device.inputs.append({0, "F1"});
+    device.inputs.append({0, "F2"});
+    device.inputs.append({0, "F3"});
+    device.inputs.append({0, "F4"});
+    device.inputs.append({0, "F5"});
+    device.inputs.append({0, "F6"});
+    device.inputs.append({0, "F7"});
+    device.inputs.append({0, "F8"});
+    device.inputs.append({0, "1 - Exclamation Mark"});
+    device.inputs.append({0, "2 - Quotation Mark"});
+    device.inputs.append({0, "3 - Number Sign"});
+    device.inputs.append({0, "4 - Dollar Sign"});
+    device.inputs.append({0, "5 - Percent Sign"});
+    device.inputs.append({0, "6 - Ampersand"});
+    device.inputs.append({0, "7 - Apostrophe"});
+    device.inputs.append({0, "8 - Left Parenthesis"});
+    device.inputs.append({0, "9 - Right Parenthesis"});
+    device.inputs.append({0, "0"});
+    device.inputs.append({0, "Hyphen-Minus - Equals Sign"});
+    device.inputs.append({0, "Circumflex Accent"});
+    device.inputs.append({0, "En Sign"});
+    device.inputs.append({0, "STOP"});
+    device.inputs.append({0, "ESC"});
+    device.inputs.append({0, "Q"});
+    device.inputs.append({0, "W"});
+    device.inputs.append({0, "E"});
+    device.inputs.append({0, "R"});
+    device.inputs.append({0, "T"});
+    device.inputs.append({0, "Y"});
+    device.inputs.append({0, "U"});
+    device.inputs.append({0, "I"});
+    device.inputs.append({0, "O"});
+    device.inputs.append({0, "P"});
+    device.inputs.append({0, "Commercial At"});
+    device.inputs.append({0, "Left Square Bracket"});
+    device.inputs.append({0, "RETURN"});
+    device.inputs.append({0, "CTR"});
+    device.inputs.append({0, "A"});
+    device.inputs.append({0, "S"});
+    device.inputs.append({0, "D"});
+    device.inputs.append({0, "F"});
+    device.inputs.append({0, "G"});
+    device.inputs.append({0, "H"});
+    device.inputs.append({0, "J"});
+    device.inputs.append({0, "K"});
+    device.inputs.append({0, "L"});
+    device.inputs.append({0, "Semicolon - Plus Sign"});
+    device.inputs.append({0, "Colon - Asterisk"});
+    device.inputs.append({0, "Right Square Bracket"});
+    device.inputs.append({0, "Kana"});
+    device.inputs.append({0, "SHIFT Left"});
+    device.inputs.append({0, "Z"});
+    device.inputs.append({0, "X"});
+    device.inputs.append({0, "C"});
+    device.inputs.append({0, "V"});
+    device.inputs.append({0, "B"});
+    device.inputs.append({0, "N"});
+    device.inputs.append({0, "M"});
+    device.inputs.append({0, "Comma - Less-Than Sign"});
+    device.inputs.append({0, "Full Stop - Greater-Than Sign"});
+    device.inputs.append({0, "Solidus - Question Mark"});
+    device.inputs.append({0, "Kana N - Low Line"});
+    device.inputs.append({0, "SHIFT Right"});
+    device.inputs.append({0, "GRPH"});
+    device.inputs.append({0, "Spacebar"});
+    device.inputs.append({0, "CLR HOME"});
+    device.inputs.append({0, "INS"});
+    device.inputs.append({0, "DEL"});
+    device.inputs.append({0, "Up"});
+    device.inputs.append({0, "Left"});
+    device.inputs.append({0, "Right"});
+    device.inputs.append({0, "Down"});
+    expansionPort.devices.append(device);
+  }
+
+  { Device device{ID::Device::FamilyTrainer, "Family Trainer"};
+    for(uint n : range(12)) {
+      device.inputs.append({0, {"Button ", n + 1}});
+    }
+    expansionPort.devices.append(device);
+  }
+
+  { Device device{ID::Device::VausE, "Arkanoid Vaus"};
+    device.inputs.append({1, "Control Knob"});
+    device.inputs.append({0, "Fire Button" });
+    expansionPort.devices.append(device);
+  }
+
+  { Device device{ID::Device::SFCGamepad, "SFC Gamepad"};
+    device.inputs.append({0, "Up"    });
+    device.inputs.append({0, "Down"  });
+    device.inputs.append({0, "Left"  });
+    device.inputs.append({0, "Right" });
+    device.inputs.append({0, "B"     });
+    device.inputs.append({0, "A"     });
+    device.inputs.append({0, "Y"     });
+    device.inputs.append({0, "X"     });
+    device.inputs.append({0, "L"     });
+    device.inputs.append({0, "R"     });
+    device.inputs.append({0, "Select"});
+    device.inputs.append({0, "Start" });
+    expansionPort.devices.append(device);
+  }
+
+  { Device device{ID::Device::MouseE, "Mouse"};
+    device.inputs.append({1, "X-axis"});
+    device.inputs.append({1, "Y-axis"});
+    device.inputs.append({0, "Left"  });
+    device.inputs.append({0, "Right" });
+    expansionPort.devices.append(device);
+  }
+
+  { Device device{ID::Device::VSPanel, "VS. Panel"};
+    device.inputs.append({0, "Button 1"      });
+    device.inputs.append({0, "Button 2"      });
+    device.inputs.append({0, "Button 3"      });
+    device.inputs.append({0, "Button 4"      });
+    device.inputs.append({0, "Service Button"});
+    device.inputs.append({0, "Coin 1"        });
+    device.inputs.append({0, "Coin 2"        });
+    arcadePanel.devices.append(device);
+  }
+
   ports.append(move(controllerPort1));
   ports.append(move(controllerPort2));
+  ports.append(move(expansionPort));
+  ports.append(move(arcadePanel));
 }
 
 auto Interface::manifest() -> string {
@@ -52,77 +319,255 @@ auto Interface::title() -> string {
 }
 
 auto Interface::videoSize() -> VideoSize {
-  return {256, 240};
+  return {256 * vssystem.gameCount, 240 + playchoice10.screenConfig * 224};
 }
 
 auto Interface::videoSize(uint width, uint height, bool arc) -> VideoSize {
-  uint w = 256 * (arc ? 8.0 / 7.0 : 1.0);
-  uint h = 240;
-  uint m = min(width / w, height / h);
-  return {w * m, h * m};
+  double w = 256 / playchoice10.screenConfig;
+  if(arc) {
+    double squarePixelRate = system.region() == System::Region::NTSC
+    ? 135.0 / 22.0 * 1'000'000.0
+    : 7'375'000.0;
+    w *= squarePixelRate / (system.colorburst() * 6.0 / (system.region() == System::Region::NTSC ? 4.0 : 5.0));
+  }
+  uint h = 240 / vssystem.gameCount;
+  if(system.pc10() && playchoice10.screenConfig == 2) h = (240 + 224) / 2;
+  uint m = min((uint)(width / w), height / h);
+  return {(uint)(w * m), h * m};
 }
 
 auto Interface::videoFrequency() -> double {
-  return 21477272.0 / (262.0 * 1364.0 - 4.0);
+  switch(system.region()) { default:
+  case System::Region::NTSC:  return (system.colorburst() * 6.0) / (262.0 * 1364.0 - 4.0);
+  case System::Region::PAL:   return (system.colorburst() * 6.0) / (312.0 * 1705.0);
+  case System::Region::Dendy: return (system.colorburst() * 6.0) / (312.0 * 1705.0);
+  }
 }
 
 auto Interface::videoColors() -> uint32 {
-  return 1 << 9;
+  return ((1 << 9) << system.vs()) + system.pc10() * (1 << 8);
 }
 
 auto Interface::videoColor(uint32 n) -> uint64 {
-  double saturation = 2.0;
-  double hue = 0.0;
-  double contrast = 1.0;
-  double brightness = 1.0;
-  double gamma = settings.colorEmulation ? 1.8 : 2.2;
-
-  int color = (n & 0x0f), level = color < 0xe ? (n >> 4) & 3 : 1;
-
-  static const double black = 0.518, white = 1.962, attenuation = 0.746;
-  static const double levels[8] = {
-    0.350, 0.518, 0.962, 1.550,
-    1.094, 1.506, 1.962, 1.962,
-  };
+  //YIQ decoder by Bisqwit (http://forums.nesdev.com/viewtopic.php?p=85060)
+  static auto generateNTSCColor = [](uint9 n, double saturation, double hue, double contrast, double brightness, double gamma) -> uint64 {
+    int color = n.bits(0,3), level = color < 0xe ? n.bits(4,5) : 1;
+
+    static const double  lowLevels[4] = {0.350, 0.518, 0.962, 1.550};
+    static const double highLevels[4] = {1.094, 1.506, 1.962, 1.962};
+
+    static const double black = lowLevels[1], white = highLevels[3];
+    static const double attenuation = 0.746;
+
+    double lo_and_hi[2] = {
+      (color == 0x0 ? highLevels : lowLevels)[level],
+      (color <  0xd ? highLevels : lowLevels)[level],
+    };
+
+    double y = 0.0, i = 0.0, q = 0.0;
+    auto wave = [](int phase, int color) -> bool { return (color + phase + 8) % 12 < 6; };
+    for(int phase : range(12)) {
+      double spot = lo_and_hi[wave(phase, color)];
+
+      if(color < 0xe && (
+         ((n.bit(6)) && wave(phase, 12))
+      || ((n.bit(7)) && wave(phase,  4))
+      || ((n.bit(8)) && wave(phase,  8))
+      )) spot *= attenuation;
+
+      double voltage = (spot - black) / (white - black);
+
+      voltage = (voltage - 0.5) * contrast + 0.5;
+      voltage *= brightness / 12.0;
 
-  double lo_and_hi[2] = {
-    levels[level + 4 * (color == 0x0)],
-    levels[level + 4 * (color <  0xd)],
+      y += voltage;
+      i += voltage * std::cos((Math::Pi / 6.0) * (phase + hue));
+      q += voltage * std::sin((Math::Pi / 6.0) * (phase + hue));
+    }
+
+    i *= saturation;
+    q *= saturation;
+
+    auto gammaAdjust = [=](double f) -> double { return f < 0.0 ? 0.0 : std::pow(f, 2.2 / gamma); };
+    //This matrix is from FCC's 1953 NTSC standard.
+    //The Famicom and American NES are older than the SMPTE C standard that followed in 1987.
+    uint64 r = uclamp<16>(65535.0 * gammaAdjust(y +  0.946882 * i +  0.623557 * q));
+    uint64 g = uclamp<16>(65535.0 * gammaAdjust(y + -0.274788 * i + -0.635691 * q));
+    uint64 b = uclamp<16>(65535.0 * gammaAdjust(y + -1.108545 * i +  1.709007 * q));
+
+    return r << 32 | g << 16 | b << 0;
   };
 
-  double y = 0.0, i = 0.0, q = 0.0;
-  auto wave = [](int p, int color) { return (color + p + 8) % 12 < 6; };
-  for(int p : range(12)) {
-    double spot = lo_and_hi[wave(p, color)];
+  static auto generatePALColor = [](uint9 n, double saturation, double hue, double contrast, double brightness, double gamma) -> uint64 {
+    int color = n.bits(0,3), level = color < 0xe ? n.bits(4,5) : 1;
 
-    if(((n & 0x040) && wave(p, 12))
-    || ((n & 0x080) && wave(p,  4))
-    || ((n & 0x100) && wave(p,  8))
-    ) spot *= attenuation;
+    static const double  lowLevels[4] = {0.350, 0.518, 0.962, 1.550};
+    static const double highLevels[4] = {1.094, 1.506, 1.962, 1.962};
 
-    double v = (spot - black) / (white - black);
+    static const double black = lowLevels[1], white = highLevels[3];
+    static const double attenuation = 0.746;
 
-    v = (v - 0.5) * contrast + 0.5;
-    v *= brightness / 12.0;
+    double lo_and_hi[2] = {
+      (color == 0x0 ? highLevels : lowLevels)[level],
+      (color <  0xd ? highLevels : lowLevels)[level],
+    };
 
-    y += v;
-    i += v * cos((Math::Pi / 6.0) * (p + hue));
-    q += v * sin((Math::Pi / 6.0) * (p + hue));
-  }
+    double ys[2] = {0.0, 0.0}, us[2] = {0.0, 0.0}, vs[2] = {0.0, 0.0};
+    //Add 12 to work around C++ modulus implementation
+    auto wave0 = [](int phase, int color) -> bool { return (color + 10 - phase + 12) % 12 < 6; };
+    auto wave1 = [](int phase, int color) -> bool { return (color +  1 + phase +  0) % 12 < 6; };
+    for(int phase : range(12)) {
+      double spot[] = {lo_and_hi[wave0(phase, color)], lo_and_hi[wave1(phase, color)]};
+
+      //swap red and green
+      if(color < 0xe && (
+         ((n.bit(6)) && wave0(phase,  4))
+      || ((n.bit(7)) && wave0(phase, 12))
+      || ((n.bit(8)) && wave0(phase,  8))
+      )) spot[0] *= attenuation;
+
+      if(color < 0xe && (
+         ((n.bit(6)) && wave1(phase,  4))
+      || ((n.bit(7)) && wave1(phase, 12))
+      || ((n.bit(8)) && wave1(phase,  8))
+      )) spot[1] *= attenuation;
+
+      for(uint i : range(2)) {
+        double voltage = (spot[i] - black) / (white - black);
+
+        voltage = (voltage - 0.5) * contrast + 0.5;
+        voltage *= brightness / 12.0;
 
-  i *= saturation;
-  q *= saturation;
+        ys[i] += voltage;
+        us[i] += voltage * std::cos((Math::Pi / 6.0) * (phase + hue));
+        vs[i] += voltage * std::sin((Math::Pi / 6.0) * (phase + hue));
+      }
+    }
+
+    double y = (ys[0] + ys[1]) / 2.0, u = (us[0] + us[1]) / 2.0, v = (vs[0] - vs[1]) / 2.0;
+
+    u *= saturation;
+    v *= saturation;
+
+    auto gammaAdjust = [=](double f) -> double { return f < 0.0 ? 0.0 : std::pow(f, 2.2 / gamma); };
+    uint64 r = uclamp<16>(65535.0 * gammaAdjust(y                 +  1.139837 * v));
+    uint64 g = uclamp<16>(65535.0 * gammaAdjust(y + -0.394652 * u + -0.580599 * v));
+    uint64 b = uclamp<16>(65535.0 * gammaAdjust(y +  2.032110 * u                ));
+
+    return r << 32 | g << 16 | b << 0;
+  };
+
+  static auto generateRGBColor = [](uint9 color, const uint9* palette) -> uint64 {
+    uint3 r = color.bit(6) ? 7 : palette[color.bits(5,0)] >> 6 & 7;
+    uint3 g = color.bit(7) ? 7 : palette[color.bits(5,0)] >> 3 & 7;
+    uint3 b = color.bit(8) ? 7 : palette[color.bits(5,0)] >> 0 & 7;
+
+    uint64 R = image::normalize(r, 3, 16);
+    uint64 G = image::normalize(g, 3, 16);
+    uint64 B = image::normalize(b, 3, 16);
+
+    if(settings.colorEmulation) {
+      //TODO: check how arcade displays alter the signal.
+      //The red, green, and blue channels are connected directly without any
+      //conversion to YIQ/YUV/YPbPr/etc. and back.
+      static const uint8 gammaRamp[8] = {
+        0x00, 0x0a,
+        0x2d, 0x5b,
+        0x98, 0xb8,
+        0xe0, 0xff,
+      };
+      R = gammaRamp[r] * 0x0101;
+      G = gammaRamp[g] * 0x0101;
+      B = gammaRamp[b] * 0x0101;
+    }
+
+    return R << 32 | G << 16 | B << 0;
+  };
 
-  auto gammaAdjust = [=](double f) { return f < 0.0 ? 0.0 : pow(f, 2.2 / gamma); };
-  uint64 r = uclamp<16>(65535.0 * gammaAdjust(y +  0.946882 * i +  0.623557 * q));
-  uint64 g = uclamp<16>(65535.0 * gammaAdjust(y + -0.274788 * i + -0.635691 * q));
-  uint64 b = uclamp<16>(65535.0 * gammaAdjust(y + -1.108545 * i +  1.709007 * q));
+  static auto generatePC10Color = [](uint9 color) -> uint64 {
+    uint r = 15 - playchoice10.videoCircuit.cgrom[color + 0x000];
+    uint g = 15 - playchoice10.videoCircuit.cgrom[color + 0x100];
+    uint b = 15 - playchoice10.videoCircuit.cgrom[color + 0x200];
+
+    uint64 R = image::normalize(r, 4, 16);
+    uint64 G = image::normalize(g, 4, 16);
+    uint64 B = image::normalize(b, 4, 16);
+
+    if(settings.colorEmulation) {
+      //TODO: check the menu monitor's gamma ramp
+      static const uint8 gammaRamp[16] = {
+        0x00, 0x03, 0x0a, 0x15,
+        0x24, 0x37, 0x4e, 0x69,
+        0x90, 0xa0, 0xb0, 0xc0,
+        0xd0, 0xe0, 0xf0, 0xff,
+      };
+      R = gammaRamp[r] * 0x0101;
+      G = gammaRamp[g] * 0x0101;
+      B = gammaRamp[b] * 0x0101;
+    }
+
+    return R << 32 | G << 16 | B << 0;
+  };
 
-  return r << 32 | g << 16 | b << 0;
+  if(!system.pc10() || n < (1 << 9)) {
+    if(ppu.ntsc()) { //NTSC
+      double saturation = 2.0;
+      double hue = 0.0;
+      double contrast = 1.0;
+      double brightness = 1.0;
+      double gamma = settings.colorEmulation ? 1.8 : 2.2;
+
+      return generateNTSCColor(n & 0x1ff, saturation, hue, contrast, brightness, gamma);
+
+    } else if(ppu.pal()) { //PAL
+      double saturation = 2.0;
+      double hue = 0.0;
+      double contrast = 1.0;
+      double brightness = 1.0;
+      double gamma = settings.colorEmulation ? 1.8 : 2.2;
+
+      return generatePALColor(n & 0x1ff, saturation, hue, contrast, brightness, gamma);
+
+    } else if(ppu.rgb()) { //Arcade
+      const uint9* palette = nullptr;
+      switch(ppu.version) {
+      case PPU::Version::RP2C03B:
+      case PPU::Version::RP2C03G:
+      case PPU::Version::RC2C03B:
+      case PPU::Version::RC2C03C:
+      case PPU::Version::RC2C05_01:
+      case PPU::Version::RC2C05_02:
+      case PPU::Version::RC2C05_03:
+      case PPU::Version::RC2C05_04:
+      case PPU::Version::RC2C05_05:
+        palette = PPU::RP2C03;
+        break;
+      case PPU::Version::RP2C04_0001:
+        palette = PPU::RP2C04_0001;
+        break;
+      case PPU::Version::RP2C04_0002:
+        palette = PPU::RP2C04_0002;
+        break;
+      case PPU::Version::RP2C04_0003:
+        palette = PPU::RP2C04_0003;
+        break;
+      case PPU::Version::RP2C04_0004:
+        palette = PPU::RP2C04_0004;
+        break;
+      }
+      return generateRGBColor(n & 0x1ff, palette);
+    }
+  } else {
+    return generatePC10Color(n - (1 << 9));
+  }
 }
 
 auto Interface::audioFrequency() -> double {
-  return 21477272.0 / 12.0;
+  switch(system.region()) { default:
+  case System::Region::NTSC:  return (system.colorburst() * 6.0) / 12.0;
+  case System::Region::PAL:   return (system.colorburst() * 6.0) / 16.0;
+  case System::Region::Dendy: return (system.colorburst() * 6.0) / 15.0;
+  }
 }
 
 auto Interface::loaded() -> bool {
@@ -134,7 +579,10 @@ auto Interface::sha256() -> string {
 }
 
 auto Interface::load(uint id) -> bool {
-  return system.load();
+  if(id == ID::Famicom) return system.load(Model::Famicom);
+  if(id == ID::VSSystem) return system.load(Model::VSSystem); 
+  if(id == ID::PlayChoice10) return system.load(Model::PlayChoice10);
+  if(id == ID::FamicomBox) return system.load(Model::FamicomBox);
 }
 
 auto Interface::save() -> void {
@@ -147,7 +595,32 @@ auto Interface::unload() -> void {
 }
 
 auto Interface::connect(uint port, uint device) -> void {
+  if(system.vs() || port == ID::Port::Arcade) return;
+
+  if((port == ID::Port::Controller1 && settings.controllerPort1 == ID::Device::FourScore)
+  || (port == ID::Port::Controller2 && settings.controllerPort2 == ID::Device::FourScore)) {
+    switch(port) {
+    case ID::Port::Controller1:
+      interface->deviceChanged(ID::Port::Controller2, ID::Device::None);
+      break;
+    case ID::Port::Controller2:
+      interface->deviceChanged(ID::Port::Controller1, ID::Device::None);
+      break;
+    }
+  }
+
   Famicom::peripherals.connect(port, device);
+
+  if(device == ID::Device::FourScore || device == ID::Device::FourScore) {
+    switch(port) {
+    case ID::Port::Controller1:
+      interface->deviceChanged(ID::Port::Controller2, ID::Device::FourScore);
+      break;
+    case ID::Port::Controller2:
+      interface->deviceChanged(ID::Port::Controller1, ID::Device::FourScore);
+      break;
+    }
+  }
 }
 
 auto Interface::power() -> void {
@@ -172,6 +645,7 @@ auto Interface::unserialize(serializer& s) -> bool {
 }
 
 auto Interface::cheatSet(const string_vector& list) -> void {
+  cheat.reset();
   cheat.assign(list);
 }
 
@@ -193,8 +667,29 @@ auto Interface::set(const string& name, const any& value) -> bool {
     system.configureVideoPalette();
     return true;
   }
-  if(name == "Scanline Emulation" && value.is<bool>()) return settings.scanlineEmulation = value.get<bool>(), true;
+  if(name == "Scanline Emulation" && value.is<bool>()) {
+    settings.scanlineEmulation = value.get<bool>();
+    system.configureVideoEffects();
+    return true;
+  }
   return false;
 }
 
+auto Interface::exportMemory() -> void {
+  string pathname = {path(cartridge.pathID()), "debug/"};
+  directory::create(pathname);
+
+  if(auto fp = interface->open(cartridge.pathID(), "debug/work.ram", File::Write)) fp->write(cpu.ram, 0x800);
+  if(cartridge.board->prgram.size()) if(auto fp = interface->open(cartridge.pathID(), "debug/program.ram", File::Write)) {
+    fp->write(cartridge.board->prgram.data(), cartridge.board->prgram.size());
+  }
+  if(cartridge.board->chrram.size()) if(auto fp = interface->open(cartridge.pathID(), "debug/character.ram", File::Write)) {
+    fp->write(cartridge.board->chrram.data(), cartridge.board->chrram.size());
+  }
+  if(!cartridge.board->chip) return;
+  if(cartridge.board->chip->ram.size()) if(auto fp = interface->open(cartridge.pathID(), "debug/chip.ram", File::Write)) {
+    fp->write(cartridge.board->chip->ram.data(), cartridge.board->chip->ram.size());
+  }
+}
+
 }
diff --git a/higan/higan/fc/interface/interface.hpp b/nSide/higan/fc/interface/interface.hpp
index c710aa8..674c0cf 100644
--- a/higan/higan/fc/interface/interface.hpp
+++ b/nSide/higan/fc/interface/interface.hpp
@@ -4,17 +4,40 @@ struct ID {
   enum : uint {
     System,
     Famicom,
+    VSSystem,
+    PlayChoice10,
+    FamicomBox,
   };
 
   struct Port { enum : uint {
     Controller1,
     Controller2,
     Expansion,
+    Arcade,
   };};
 
   struct Device { enum : uint {
     None,
     Gamepad,
+    GamepadMic,
+    FourScore,
+    Zapper,
+    PowerPad,
+    Vaus,
+    SNESGamepad,
+    Mouse,
+
+    GamepadE,
+    JoyPair,
+    FourPlayers,
+    BeamGun,
+    FamilyKeyboard,
+    FamilyTrainer,
+    VausE,
+    SFCGamepad,
+    MouseE,
+
+    VSPanel,
   };};
 };
 
@@ -53,6 +76,9 @@ struct Interface : Emulator::Interface {
   auto cap(const string& name) -> bool override;
   auto get(const string& name) -> any override;
   auto set(const string& name, const any& value) -> bool override;
+
+  //debugger functions
+  auto exportMemory() -> void override;
 };
 
 struct Settings {
@@ -62,6 +88,7 @@ struct Settings {
   uint controllerPort1 = 0;
   uint controllerPort2 = 0;
   uint expansionPort = 0;
+  uint arcadePanel = 0;
 };
 
 extern Interface* interface;
diff --git a/nSide/higan/fc/memory/memory-inline.hpp b/nSide/higan/fc/memory/memory-inline.hpp
new file mode 100644
index 0000000..7eb8b79
--- /dev/null
+++ b/nSide/higan/fc/memory/memory-inline.hpp
@@ -0,0 +1,90 @@
+//Memory
+
+auto Memory::size() const -> uint { return 0; }
+
+//StaticRAM
+
+StaticRAM::StaticRAM(uint size) : _size(size) { _data = new uint8[_size]; }
+StaticRAM::~StaticRAM() { delete[] _data; }
+
+auto StaticRAM::data() -> uint8* { return _data; }
+auto StaticRAM::size() const -> uint { return _size; }
+
+auto StaticRAM::read(uint16 addr, uint8) -> uint8 { return _data[addr]; }
+auto StaticRAM::write(uint16 addr, uint8 data) -> void { _data[addr] = data; }
+auto StaticRAM::operator[](uint16 addr) -> uint8& { return _data[addr]; }
+auto StaticRAM::operator[](uint16 addr) const -> const uint8& { return _data[addr]; }
+
+//MappedRAM
+
+auto MappedRAM::reset() -> void {
+  delete[] _data;
+  _data = nullptr;
+  _size = 0;
+  _writeProtect = false;
+}
+
+auto MappedRAM::allocate(uint size) -> void {
+  reset();
+  _data = new uint8[_size = size];
+  memory::fill(_data, _size, 0xff);
+}
+
+auto MappedRAM::writeProtect(bool writeProtect) -> void { _writeProtect = writeProtect; }
+auto MappedRAM::data() -> uint8* { return _data; }
+auto MappedRAM::size() const -> uint { return _size; }
+
+auto MappedRAM::read(uint16 addr, uint8) -> uint8 { return _data[addr]; }
+auto MappedRAM::write(uint16 addr, uint8 data) -> void { if(!_writeProtect) _data[addr] = data; }
+auto MappedRAM::operator[](uint16 addr) const -> const uint8& { return _data[addr]; }
+
+auto MappedRAM::readDirect(uint addr, uint8) -> uint8 { return _data[addr]; }
+auto MappedRAM::writeDirect(uint addr, uint8 data) -> void { if(!_writeProtect) _data[addr] = data; }
+
+//Bus
+
+auto Bus::mirror(uint addr, uint size) -> uint {
+  if(size == 0) return 0;
+  uint base = 0;
+  uint mask = 1 << 15;
+  while(addr >= size) {
+    while(!(addr & mask)) mask >>= 1;
+    addr -= mask;
+    if(size > mask) {
+      size -= mask;
+      base += mask;
+    }
+    mask >>= 1;
+  }
+  return base + addr;
+}
+
+auto Bus::reduce(uint addr, uint mask) -> uint {
+  while(mask) {
+    uint bits = (mask & -mask) - 1;
+    addr = ((addr >> 1) & ~bits) | (addr & bits);
+    mask = (mask & (mask - 1)) >> 1;
+  }
+  return addr;
+}
+
+//$0000-07ff = RAM (2KB)
+//$0800-1fff = RAM (mirror)
+//$2000-2007 = PPU
+//$2008-3fff = PPU (mirror)
+//$4000-4017 = APU + I/O
+//$4018-ffff = Cartridge
+
+auto Bus::read(uint16 addr, uint8 data) -> uint8 {
+  if(!system.fcb()) data = cartridge.readPRG(addr);
+  data = reader[lookup[addr]](target[addr], data);
+  if(cheat) {
+    if(auto result = cheat.find<1>(addr, data)) return result();
+  }
+  return data;
+}
+
+auto Bus::write(uint16 addr, uint8 data) -> void {
+  if(!system.fcb()) cartridge.writePRG(addr, data);
+  return writer[lookup[addr]](target[addr], data);
+}
diff --git a/higan/higan/fc/memory/memory.cpp b/nSide/higan/fc/memory/memory.cpp
index e2eaa4c..7eaba57 100644
--- a/higan/higan/fc/memory/memory.cpp
+++ b/nSide/higan/fc/memory/memory.cpp
@@ -4,31 +4,88 @@ namespace Famicom {
 
 Bus bus;
 
-//$0000-07ff = RAM (2KB)
-//$0800-1fff = RAM (mirror)
-//$2000-2007 = PPU
-//$2008-3fff = PPU (mirror)
-//$4000-4017 = APU + I/O
-//$4018-ffff = Cartridge
+Bus::~Bus() {
+  if(lookup) delete[] lookup;
+  if(target) delete[] target;
+}
 
-auto Bus::read(uint16 addr) -> uint8 {
-  uint8 data = cartridge.readPRG(addr);
-       if(addr <= 0x1fff) data = cpu.readRAM(addr);
-  else if(addr <= 0x3fff) data = ppu.readIO(addr);
-  else if(addr <= 0x4017) data = cpu.readIO(addr);
+auto Bus::reset() -> void {
+  for(auto id : range(256)) {
+    reader[id].reset();
+    writer[id].reset();
+    counter[id] = 0;
+  }
+
+  if(lookup) delete[] lookup;
+  if(target) delete[] target;
+
+  lookup = new uint8 [16 * 1024 * 1024]();
+  target = new uint32[16 * 1024 * 1024]();
 
-  if(cheat) {
-    if(auto result = cheat.find(addr, data)) return result();
+  reader[0] = [](uint16, uint8 data) -> uint8 { return data; };
+  writer[0] = [](uint16, uint8) -> void {};
+}
+
+auto Bus::map(
+  const function<uint8 (uint16, uint8)>& read,
+  const function<void (uint16, uint8)>& write,
+  const string& addr, uint size, uint base, uint mask
+) -> void {
+  uint id = 1;
+  while(counter[id]) {
+    if(++id >= 256) return print("FC error: bus map exhausted\n");
   }
 
-  return data;
+  reader[id] = read;
+  writer[id] = write;
+
+  auto addrs = addr.split(",");
+  for(auto& addr : addrs) {
+    auto addrRange = addr.split("-", 1L);
+    uint addrLo = addrRange(0).hex();
+    uint addrHi = addrRange(1, addrRange(0)).hex();
+
+    for(uint addr = addrLo; addr <= addrHi; addr++) {
+      uint pid = lookup[addr];
+      if(pid && --counter[pid] == 0) {
+        reader[pid].reset();
+        writer[pid].reset();
+      }
+
+      uint offset = reduce(addr, mask);
+      if(size) offset = base + mirror(offset, size - base);
+      lookup[addr] = id;
+      target[addr] = offset;
+      counter[id]++;
+    }
+  }
 }
 
-auto Bus::write(uint16 addr, uint8 data) -> void {
-  cartridge.writePRG(addr, data);
-  if(addr <= 0x1fff) return cpu.writeRAM(addr, data);
-  if(addr <= 0x3fff) return ppu.writeIO(addr, data);
-  if(addr <= 0x4017) return cpu.writeIO(addr, data);
+auto Bus::unmap(const string& addr) -> void {
+  auto addrs = addr.split(",");
+  for(auto& addr : addrs) {
+    auto addrRange = addr.split("-", 1L);
+    uint addrLo = addrRange(0).hex();
+    uint addrHi = addrRange(1, addrRange(1)).hex();
+
+    for(uint addr = addrLo; addr <= addrHi; addr++) {
+      uint pid = lookup[addr];
+      if(pid && --counter[pid] == 0) {
+        reader[pid].reset();
+        writer[pid].reset();
+      }
+
+      lookup[addr] = 0;
+      target[addr] = 0;
+    }
+  }
 }
 
+//$0000-07ff = RAM (2KB)
+//$0800-1fff = RAM (mirror)
+//$2000-2007 = PPU
+//$2008-3fff = PPU (mirror)
+//$4000-4017 = APU + I/O
+//$4018-ffff = Cartridge
+
 }
diff --git a/higan/higan/fc/memory/memory.hpp b/nSide/higan/fc/memory/memory.hpp
index 5a9596a..5f69bf7 100644
--- a/higan/higan/fc/memory/memory.hpp
+++ b/nSide/higan/fc/memory/memory.hpp
@@ -1,6 +1,71 @@
+struct Memory {
+  virtual inline auto size() const -> uint;
+  virtual auto read(uint16 addr, uint8 data = 0) -> uint8 = 0;
+  virtual auto write(uint16 addr, uint8 data) -> void = 0;
+};
+
+struct StaticRAM : Memory {
+  inline StaticRAM(uint size);
+  inline ~StaticRAM();
+
+  inline auto data() -> uint8*;
+  inline auto size() const -> uint;
+
+  inline auto read(uint16 addr, uint8 data = 0) -> uint8;
+  inline auto write(uint16 addr, uint8 data) -> void;
+  inline auto operator[](uint16 addr) -> uint8&;
+  inline auto operator[](uint16 addr) const -> const uint8&;
+
+private:
+  uint8* _data = nullptr;
+  uint _size = 0;
+};
+
+struct MappedRAM : Memory {
+  inline auto reset() -> void;
+  inline auto allocate(uint) -> void;
+
+  inline auto writeProtect(bool writeProtect) -> void;
+  inline auto data() -> uint8*;
+  inline auto size() const -> uint;
+
+  inline auto read(uint16 addr, uint8 data = 0) -> uint8;
+  inline auto write(uint16 addr, uint8 data) -> void;
+  inline auto operator[](uint16 addr) const -> const uint8&;
+
+  inline auto readDirect(uint addr, uint8 data = 0) -> uint8;
+  inline auto writeDirect(uint addr, uint8 data) -> void;
+
+private:
+  uint8* _data = nullptr;
+  uint _size = 0;
+  bool _writeProtect = false;
+};
+
 struct Bus {
-  auto read(uint16 addr) -> uint8;
-  auto write(uint16 addr, uint8 data) -> void;
+  alwaysinline static auto mirror(uint addr, uint size) -> uint;
+  alwaysinline static auto reduce(uint addr, uint mask) -> uint;
+
+  ~Bus();
+
+  alwaysinline auto read(uint16 addr, uint8 data) -> uint8;
+  alwaysinline auto write(uint16 addr, uint8 data) -> void;
+
+  auto reset() -> void;
+  auto map(
+    const function<uint8 (uint16, uint8)>& read,
+    const function<void (uint16, uint8)>& write,
+    const string& addr, uint size = 0, uint base = 0, uint mask = 0
+  ) -> void;
+  auto unmap(const string& addr) -> void;
+
+private:
+  uint8* lookup = nullptr;
+  uint32* target = nullptr;
+
+  function<auto (uint16, uint8) -> uint8> reader[256];
+  function<auto (uint16, uint8) -> void> writer[256];
+  uint16 counter[256];
 };
 
 extern Bus bus;
diff --git a/nSide/higan/fc/ppu/counter/counter-inline.hpp b/nSide/higan/fc/ppu/counter/counter-inline.hpp
new file mode 100644
index 0000000..eb72fa7
--- /dev/null
+++ b/nSide/higan/fc/ppu/counter/counter-inline.hpp
@@ -0,0 +1,40 @@
+auto PPUcounter::tick(uint clocks) -> void {
+  status.hcounter += clocks;
+  if(status.hcounter == 337) status.skip = 341 - lineclocks();
+  if(status.hcounter == 341 - status.skip) {
+    status.hcounter = 0;
+    status.skip = false;
+    vcounterTick();
+  }
+}
+
+//internal
+auto PPUcounter::vcounterTick() -> void {
+  status.vcounter++;
+
+  if((system.region() == System::Region::NTSC && status.vcounter == 262)
+  || (system.region() != System::Region::NTSC && status.vcounter == 312)
+  ) {
+    status.vcounter = 0;
+    status.field = !status.field;
+  }
+  if(scanline) scanline();
+}
+
+auto PPUcounter::field() const -> bool { return status.field; }
+auto PPUcounter::vcounter() const -> uint16 { return status.vcounter; }
+auto PPUcounter::hcounter() const -> uint16 { return status.hcounter; }
+
+//one PPU dot = 4 CPU clocks (1/3 CPU cycle)
+
+auto PPUcounter::lineclocks() const -> uint16 {
+  if(system.region() == System::Region::NTSC && ppu.ntsc() && ppu.enable() && vcounter() == 261 && field() == 1) return 340;
+  return 341;
+}
+
+auto PPUcounter::reset() -> void {
+  status.field    = 0;
+  status.vcounter = 0;
+  status.hcounter = 0;
+  status.skip     = false;
+}
diff --git a/nSide/higan/fc/ppu/counter/counter.hpp b/nSide/higan/fc/ppu/counter/counter.hpp
new file mode 100644
index 0000000..bfb8d28
--- /dev/null
+++ b/nSide/higan/fc/ppu/counter/counter.hpp
@@ -0,0 +1,23 @@
+struct PPUcounter {
+  alwaysinline auto tick(uint clocks) -> void;
+
+  alwaysinline auto field() const -> bool;
+  alwaysinline auto vcounter() const -> uint16;
+  alwaysinline auto hcounter() const -> uint16;
+  alwaysinline auto skip() const -> bool;
+  inline auto lineclocks() const -> uint16;
+
+  inline auto reset() -> void;
+  function<auto () -> void> scanline;
+  auto serialize(serializer&) -> void;
+
+//private:
+  inline auto vcounterTick() -> void;
+
+  struct {
+    bool field;
+    uint16 vcounter;
+    uint16 hcounter;
+    bool skip;
+  } status;
+};
diff --git a/nSide/higan/fc/ppu/io.cpp b/nSide/higan/fc/ppu/io.cpp
new file mode 100644
index 0000000..d757c7e
--- /dev/null
+++ b/nSide/higan/fc/ppu/io.cpp
@@ -0,0 +1,192 @@
+auto PPU::readCIRAM(uint12 addr) -> uint8 {
+  if(!system.vs()) addr &= 0x7ff;
+  return ciram[addr];
+}
+
+auto PPU::writeCIRAM(uint12 addr, uint8 data) -> void {
+  if(!system.vs()) addr &= 0x7ff;
+  ciram[addr] = data;
+}
+
+auto PPU::readCGRAM(uint5 addr) -> uint8 {
+  if((addr & 0x13) == 0x10) addr &= ~0x10;
+  uint8 data = cgram[addr];
+  if(io.grayscale) data &= 0x30;
+  return data;
+}
+
+auto PPU::writeCGRAM(uint5 addr, uint8 data) -> void {
+  if((addr & 0x13) == 0x10) addr &= ~0x10;
+  cgram[addr] = data;
+}
+
+auto PPU::readIO(uint16 addr, uint8 data) -> uint8 {
+  switch(addr.bits(0,2)) {
+
+  case 0: case 1: case 3:
+  case 5: case 6: {
+    return io.mdr;
+  }
+
+  //PPUSTATUS
+  case 2: {
+    data = 0x00;
+    switch(version) {
+    default:
+      data |= io.mdr.bits(0,4);
+      data |= io.spriteOverflow << 5;
+      break;
+    case Version::RC2C05_01:
+    case Version::RC2C05_04: data |= 0x1b; break;
+    case Version::RC2C05_02: data |= 0x3d; break;
+    case Version::RC2C05_03: data |= 0x1c; break;
+    }
+    data |= io.spriteZeroHit << 6;
+    data |= io.nmiFlag << 7;
+    io.v.latch = 0;
+    io.nmiHold = 0;
+    cpu.nmiLine(io.nmiFlag = 0);
+    return data;
+  }
+
+  //OAMDATA
+  case 4: {
+    switch(version) {
+    case Version::RP2C02C:
+      return io.mdr;
+    default:
+      io.mdr = oam[io.oamAddress];
+      for(uint i = 0; i < 8; i++) io.mdrDecay[i] = 3221591;
+      break;
+    }
+    return io.mdr;
+  }
+
+  //PPUDATA
+  case 7: {
+    if(enable() && (vcounter() <= 240 || vcounter() == (system.region() == System::Region::NTSC ? 261 : 311))) return 0x00;
+
+    addr = (uint14)io.v.address;
+    if(addr <= 0x3eff) {
+      io.mdr = io.busData;
+    } else if(addr <= 0x3fff) {
+      io.mdr = (io.mdr & 0xc0) | readCGRAM(addr);
+    }
+    io.busData = cartridge.readCHR(io.chrAddressBus = addr);
+    io.v.address += io.vramIncrement;
+    io.chrAddressBus = io.v.address;
+    return io.mdr;
+  }
+
+  }
+
+  return data;
+}
+
+auto PPU::writeIO(uint16 addr, uint8 data) -> void {
+  io.mdr = data;
+  // Decay rate can vary depending on the system and temperature.
+  // Value used here is PPU's NTSC clock rate * 0.6 rounded to nearest integer.
+  for(uint i = 0; i < 8; i++) io.mdrDecay[i] = 3221591;
+
+  switch(version) {
+  case Version::RC2C05_01:
+  case Version::RC2C05_02:
+  case Version::RC2C05_03:
+  case Version::RC2C05_04:
+  case Version::RC2C05_05: if(addr.bits(1,2) == 0) addr ^= 1; break;
+  }
+
+  switch(addr.bits(0,2)) {
+
+  //PPUCTRL
+  case 0: {
+    io.t.nametable   = data.bits(0,1);
+    io.vramIncrement = data.bit (2) ? 32 : 1;
+    io.objAddress    = data.bit (3) ? 0x1000 : 0x0000;
+    io.bgAddress     = data.bit (4) ? 0x1000 : 0x0000;
+    io.spriteHeight  = data.bit (5) ? 16 : 8;
+    io.masterSelect  = data.bit (6);
+    io.nmiEnable     = data.bit (7);
+    cpu.nmiLine(io.nmiEnable && io.nmiHold && io.nmiFlag);
+    return;
+  }
+
+  //PPUMASK
+  case 1: {
+    io.grayscale     = data.bit (0);
+    io.bgEdgeEnable  = data.bit (1);
+    io.objEdgeEnable = data.bit (2);
+    io.bgEnable      = data.bit (3);
+    io.objEnable     = data.bit (4);
+    io.emphasis      = data.bits(5,7);
+    return;
+  }
+
+  //PPUSTATUS
+  case 2: {
+    return;
+  }
+
+  //OAMADDR
+  case 3: {
+    if(version != Version::RP2C07) {
+      // below corruption code only applies for preferred CPU-PPU alignment.
+      // on an actual Famicom/NES, waiting a while after writing to OAM will
+      // make this corruption happen because the OAM will have decayed at the
+      // spot being written to.
+      for(int i = 0; i < 8; i++) oam[((addr & 0xf800) >> 8) + i] = oam[(io.oamAddress & 0xf8) + i];
+    }
+    io.oamAddress = data;
+    return;
+  }
+
+  //OAMDATA
+  case 4: {
+    if(io.oamAddress.bits(0,1) == 2) data.bits(2,4) = 0;  //clear non-existent bits (always read back as 0)
+    oam[io.oamAddress++] = data;
+    return;
+  }
+
+  //PPUSCROLL
+  case 5: {
+    if(!io.v.latch) {
+      io.v.fineX = data.bits(0,2);
+      io.t.tileX = data.bits(3,7);
+    } else {
+      io.t.fineY = data.bits(0,2);
+      io.t.tileY = data.bits(3,7);
+    }
+    io.v.latch ^= 1;
+    return;
+  }
+
+  //PPUADDR
+  case 6: {
+    if(!io.v.latch) {
+      io.t.addressHi = data.bits(0,5);
+    } else {
+      io.t.addressLo = data.bits(0,7);
+      io.chrAddressBus = io.v.address = io.t.address;
+    }
+    io.v.latch ^= 1;
+    return;
+  }
+
+  //PPUDATA
+  case 7: {
+    if(enable() && (vcounter() <= 240 || vcounter() == (system.region() != System::Region::PAL ? 261 : 311))) return;
+
+    addr = (uint14)io.v.address;
+    if(addr <= 0x3eff) {
+      cartridge.writeCHR(io.chrAddressBus = addr, data);
+    } else if(addr <= 0x3fff) {
+      writeCGRAM(addr, data);
+    }
+    io.v.address += io.vramIncrement;
+    io.chrAddressBus = io.v.address;
+    return;
+  }
+
+  }
+}
diff --git a/higan/higan/fc/ppu/memory.cpp b/higan/higan/fc/ppu/memory.cpp
deleted file mode 100644
index 3188b2a..0000000
--- a/higan/higan/fc/ppu/memory.cpp
+++ /dev/null
@@ -1,144 +0,0 @@
-auto PPU::readCIRAM(uint11 addr) -> uint8 {
-  return ciram[addr];
-}
-
-auto PPU::writeCIRAM(uint11 addr, uint8 data) -> void {
-  ciram[addr] = data;
-}
-
-auto PPU::readCGRAM(uint5 addr) -> uint8 {
-  if((addr & 0x13) == 0x10) addr &= ~0x10;
-  uint8 data = cgram[addr];
-  if(io.grayscale) data &= 0x30;
-  return data;
-}
-
-auto PPU::writeCGRAM(uint5 addr, uint8 data) -> void {
-  if((addr & 0x13) == 0x10) addr &= ~0x10;
-  cgram[addr] = data;
-}
-
-auto PPU::readIO(uint16 addr) -> uint8 {
-  uint8 result = 0x00;
-
-  switch(addr.bits(0,2)) {
-
-  //PPUSTATUS
-  case 2:
-    result |= io.mdr.bits(0,4);
-    result |= io.spriteOverflow << 5;
-    result |= io.spriteZeroHit << 6;
-    result |= io.nmiFlag << 7;
-    io.v.latch = 0;
-    io.nmiHold = 0;
-    cpu.nmiLine(io.nmiFlag = 0);
-    break;
-
-  //OAMDATA
-  case 4:
-    result = oam[io.oamAddress];
-    break;
-
-  //PPUDATA
-  case 7:
-    if(enable() && (io.ly <= 240 || io.ly == 261)) return 0x00;
-
-    addr = (uint14)io.v.address;
-    if(addr <= 0x1fff) {
-      result = io.busData;
-      io.busData = cartridge.readCHR(addr);
-    } else if(addr <= 0x3eff) {
-      result = io.busData;
-      io.busData = cartridge.readCHR(addr);
-    } else if(addr <= 0x3fff) {
-      result = readCGRAM(addr);
-      io.busData = cartridge.readCHR(addr);
-    }
-    io.v.address += io.vramIncrement;
-    break;
-
-  }
-
-  return result;
-}
-
-auto PPU::writeIO(uint16 addr, uint8 data) -> void {
-  io.mdr = data;
-
-  switch(addr.bits(0,2)) {
-
-  //PPUCTRL
-  case 0:
-    io.t.nametable   = data.bits(0,1);
-    io.vramIncrement = data.bit (2) ? 32 : 1;
-    io.spriteAddress = data.bit (3) ? 0x1000 : 0x0000;
-    io.bgAddress     = data.bit (4) ? 0x1000 : 0x0000;
-    io.spriteHeight  = data.bit (5) ? 16 : 8;
-    io.masterSelect  = data.bit (6);
-    io.nmiEnable     = data.bit (7);
-    cpu.nmiLine(io.nmiEnable && io.nmiHold && io.nmiFlag);
-    break;
-
-  //PPUMASK
-  case 1:
-    io.grayscale        = data.bit (0);
-    io.bgEdgeEnable     = data.bit (1);
-    io.spriteEdgeEnable = data.bit (2);
-    io.bgEnable         = data.bit (3);
-    io.spriteEnable     = data.bit (4);
-    io.emphasis         = data.bits(5,7);
-    break;
-
-  //PPUSTATUS
-  case 2:
-    break;
-
-  //OAMADDR
-  case 3:
-    io.oamAddress = data;
-    break;
-
-  //OAMDATA
-  case 4:
-    if(io.oamAddress.bits(0,1) == 2) data.bits(2,4) = 0;  //clear non-existent bits (always read back as 0)
-    oam[io.oamAddress++] = data;
-    break;
-
-  //PPUSCROLL
-  case 5:
-    if(io.v.latch++ == 0) {
-      io.v.fineX = data.bits(0,2);
-      io.t.tileX = data.bits(3,7);
-    } else {
-      io.t.fineY = data.bits(0,2);
-      io.t.tileY = data.bits(3,7);
-    }
-    break;
-
-  //PPUADDR
-  case 6:
-    if(io.v.latch++ == 0) {
-      io.t.addressHi = data.bits(0,5);
-    } else {
-      io.t.addressLo = data.bits(0,7);
-      io.v.address = io.t.address;
-    }
-    break;
-
-  //PPUDATA
-  case 7:
-    if(enable() && (io.ly <= 240 || io.ly == 261)) return;
-
-    addr = (uint14)io.v.address;
-    if(addr <= 0x1fff) {
-      cartridge.writeCHR(addr, data);
-    } else if(addr <= 0x3eff) {
-      cartridge.writeCHR(addr, data);
-    } else if(addr <= 0x3fff) {
-      writeCGRAM(addr, data);
-    }
-    io.v.address += io.vramIncrement;
-    break;
-
-  }
-}
diff --git a/higan/higan/fc/ppu/ppu.cpp b/nSide/higan/fc/ppu/ppu.cpp
index 299ac4b..121c675 100644
--- a/higan/higan/fc/ppu/ppu.cpp
+++ b/nSide/higan/fc/ppu/ppu.cpp
@@ -3,70 +3,221 @@
 namespace Famicom {
 
 PPU ppu;
-#include "memory.cpp"
+
+#include "io.cpp"
 #include "render.cpp"
 #include "serialization.cpp"
 
-auto PPU::Enter() -> void {
-  while(true) scheduler.synchronize(), ppu.main();
+PPU::PPU() {
+  output = new uint32[256 * 240];
 }
 
-auto PPU::main() -> void {
-  renderScanline();
+PPU::~PPU() {
+  delete[] output;
 }
 
 auto PPU::step(uint clocks) -> void {
+  const uint vbl = system.region() != System::Region::Dendy ? 241 : 291;
+  const uint pre = system.region() == System::Region::NTSC ? 261 : 311;
+
   while(clocks--) {
-    if(io.ly == 240 && io.lx == 340) io.nmiHold = 1;
-    if(io.ly == 241 && io.lx ==   0) io.nmiFlag = io.nmiHold;
-    if(io.ly == 241 && io.lx ==   2) cpu.nmiLine(io.nmiEnable && io.nmiFlag);
+    if(vcounter() == vbl - 1 && hcounter() == 340) io.nmiHold = 1;
 
-    if(io.ly == 260 && io.lx == 340) io.spriteZeroHit = 0, io.spriteOverflow = 0;
+    if(vcounter() == vbl && hcounter() ==   0) io.chrAddressBus = (uint12)io.v.address;
+    if(vcounter() == vbl && hcounter() ==   1) io.nmiFlag = io.nmiHold;
+    if(vcounter() == vbl && hcounter() ==   2) cpu.nmiLine(io.nmiEnable && io.nmiFlag);
 
-    if(io.ly == 260 && io.lx == 340) io.nmiHold = 0;
-    if(io.ly == 261 && io.lx ==   0) io.nmiFlag = io.nmiHold;
-    if(io.ly == 261 && io.lx ==   2) cpu.nmiLine(io.nmiEnable && io.nmiFlag);
+    if(vcounter() == pre - 1 && hcounter() == 340) io.nmiHold = 0;
+    if(vcounter() == pre     && hcounter() ==   1) io.nmiFlag = io.nmiHold;
+    if(vcounter() == pre     && hcounter() ==   1) io.spriteZeroHit = 0, io.spriteOverflow = 0;
+    if(vcounter() == pre     && hcounter() ==   2) cpu.nmiLine(io.nmiEnable && io.nmiFlag);
 
-    Thread::step(4);
+    Thread::step(system.region() == System::Region::NTSC ? 4 : 5);
     synchronize(cpu);
 
-    io.lx++;
+    for(uint i = 0; i < 8; i++) {
+      if(--io.mdrDecay[i] == 0) io.mdr &= ~(1 << i);
+    }
+
+    tick(1);
+  }
+}
+
+auto PPU::Enter() -> void {
+  while(true) scheduler.synchronize(), ppu.main();
+}
+
+auto PPU::main() -> void {
+  renderScanline();
+}
+
+auto PPU::load(Markup::Node node) -> bool {
+  if(system.vs()) return true;
+
+  string versionString;
+  if(system.fc()) {
+    if(system.region() == System::Region::NTSC)  versionString = node["ppu/ntsc-version"].text();
+    if(system.region() == System::Region::PAL)   versionString = node["ppu/pal-version"].text();
+    if(system.region() == System::Region::Dendy) versionString = node["ppu/dendy-version"].text();
+  } else {
+    versionString = node["ppu/version"].text();
   }
+
+  //YIQ
+  if(versionString == "RP2C02C")     version = Version::RP2C02C;
+  if(versionString == "RP2C02G")     version = Version::RP2C02G;
+
+  //RGB
+  if(versionString == "RP2C03B")     version = Version::RP2C03B;
+  if(versionString == "RP2C03G")     version = Version::RP2C03G;
+  if(versionString == "RP2C04-0001") version = Version::RP2C04_0001;
+  if(versionString == "RP2C04-0002") version = Version::RP2C04_0002;
+  if(versionString == "RP2C04-0003") version = Version::RP2C04_0003;
+  if(versionString == "RP2C04-0004") version = Version::RP2C04_0004;
+  if(versionString == "RC2C03B")     version = Version::RC2C03B;
+  if(versionString == "RC2C03C")     version = Version::RC2C03C;
+  if(versionString == "RC2C05-01")   version = Version::RC2C05_01;
+  if(versionString == "RC2C05-02")   version = Version::RC2C05_02;
+  if(versionString == "RC2C05-03")   version = Version::RC2C05_03;
+  if(versionString == "RC2C05-04")   version = Version::RC2C05_04;
+  if(versionString == "RC2C05-05")   version = Version::RC2C05_05;
+
+  //YUV
+  if(versionString == "RP2C07")      version = Version::RP2C07;
+  if(versionString == "UA6538")      version = Version::UA6538;
+
+  return true;
+}
+
+auto PPU::power() -> void {
+  io.v.address = 0x0000;
+
+  io.nmiHold = 0;
+  io.nmiFlag = 1;
+
+  //$2003  OAMADDR
+  io.oamAddress = 0x00;
+
+  for(auto& n : ciram) n = 0xff;
+}
+
+auto PPU::reset() -> void {
+  create(Enter, system.colorburst() * 6.0);
+  PPUcounter::reset();
+  memory::fill(output, 256 * 240 * sizeof(uint32));
+
+  function<auto (uint16, uint8) -> uint8> reader{&PPU::readIO, this};
+  function<auto (uint16, uint8) -> void> writer{&PPU::writeIO, this};
+  bus.map(reader, writer, "2000-3fff");
+
+  io.mdr = 0x00;
+  io.busData = 0x00;
+  io.v.latch = 0;
+  io.v.fineX = 0;
+  io.t.tileX = 0;
+  io.t.fineY = 0;
+  io.t.tileY = 0;
+  io.t.address = 0x0000;
+
+  //$2000  PPUCTRL
+  io.nmiEnable = false;
+  io.masterSelect = 0;
+  io.spriteHeight = 8;
+  io.bgAddress = 0x0000;
+  io.objAddress = 0x0000;
+  io.vramIncrement = 1;
+
+  //$2001  PPUMASK
+  io.emphasis = 0;
+  io.objEnable = false;
+  io.bgEnable = false;
+  io.objEdgeEnable = false;
+  io.bgEdgeEnable = false;
+  io.grayscale = false;
+
+  //$2002  PPUSTATUS
+  io.spriteZeroHit = 0;
+  io.spriteOverflow = 0;
+
+  _extOut = 0;
+
+  for(auto& n : cgram) n = 0;
+  for(auto& n : oam) n = 0;
 }
 
 auto PPU::scanline() -> void {
-  io.lx = 0;
-  if(++io.ly == 262) {
-    io.ly = 0;
-    frame();
+  if(vcounter() == 0) frame();
+  cartridge.scanline(vcounter());
+
+  if(vcounter() == 241) {
+    scheduler.exit(Scheduler::Event::Frame);
   }
-  cartridge.scanline(io.ly);
 }
 
 auto PPU::frame() -> void {
-  io.field++;
-  scheduler.exit(Scheduler::Event::Frame);
+  //TODO: Verify whether putting the scheduler exit event at vcounter() == 241 reduces lag as opposed to here
 }
 
-auto PPU::refresh() -> void {
-  Emulator::video.refresh(buffer, 256 * sizeof(uint32), 256, 240);
+auto PPU::originX() -> uint {
+  return (system.vs() && vssystem.gameCount == 2) ? side * 256 : 0;
 }
 
-auto PPU::power() -> void {
+auto PPU::originY() -> uint {
+  return system.pc10() ? (playchoice10.screenConfig - 1) * 224 : 0;
 }
 
-auto PPU::reset() -> void {
-  create(PPU::Enter, system.colorburst() * 6.0);
+auto PPU::refresh() -> void {
+  auto output = this->output;
+  Emulator::video.refreshRegion(output, 256 * sizeof(uint32), originX(), originY(), 256, 240);
+}
 
-  memory::fill(&io, sizeof(IO));
-  memory::fill(&latch, sizeof(Latches));
-  io.vramIncrement = 1;
+//
 
-  for(auto& n : ciram ) n = 0;
-  for(auto& n : cgram ) n = 0;
-  for(auto& n : oam   ) n = 0;
+auto PPU::extIn() -> uint4 {
+  if( io.masterSelect) return 0;  //always 0 in slave mode
+  if(!io.masterSelect) return 0;  //EXT pins are tied to ground
+}
 
-  for(auto& n : buffer) n = 0;
+auto PPU::extOut() -> uint4 {
+  if( io.masterSelect) return _extOut;
+  if(!io.masterSelect) return 0;  //does not output anything in master mode
 }
 
+// Arcade RGB palettes
+
+const uint9 PPU::RP2C03[16 * 4] = {
+  0333,0014,0006,0326,0403,0503,0510,0420,0320,0120,0031,0040,0022,0000,0000,0000,
+  0555,0036,0027,0407,0507,0704,0700,0630,0430,0140,0040,0053,0044,0000,0000,0000,
+  0777,0357,0447,0637,0707,0737,0740,0750,0660,0360,0070,0276,0077,0000,0000,0000,
+  0777,0567,0657,0757,0747,0755,0764,0772,0773,0572,0473,0276,0467,0000,0000,0000,
+};
+
+const uint9 PPU::RP2C04_0001[16 * 4] = {
+  0755,0637,0700,0447,0044,0120,0222,0704,0777,0333,0750,0503,0403,0660,0320,0777,
+  0357,0653,0310,0360,0467,0657,0764,0027,0760,0276,0000,0200,0666,0444,0707,0014,
+  0003,0567,0757,0070,0077,0022,0053,0507,0000,0420,0747,0510,0407,0006,0740,0000,
+  0000,0140,0555,0031,0572,0326,0770,0630,0020,0036,0040,0111,0773,0737,0430,0473,
+};
+
+const uint9 PPU::RP2C04_0002[16 * 4] = {
+  0000,0750,0430,0572,0473,0737,0044,0567,0700,0407,0773,0747,0777,0637,0467,0040,
+  0020,0357,0510,0666,0053,0360,0200,0447,0222,0707,0003,0276,0657,0320,0000,0326,
+  0403,0764,0740,0757,0036,0310,0555,0006,0507,0760,0333,0120,0027,0000,0660,0777,
+  0653,0111,0070,0630,0022,0014,0704,0140,0000,0077,0420,0770,0755,0503,0031,0444,
+};
+
+const uint9 PPU::RP2C04_0003[16 * 4] = {
+  0507,0737,0473,0555,0040,0777,0567,0120,0014,0000,0764,0320,0704,0666,0653,0467,
+  0447,0044,0503,0027,0140,0430,0630,0053,0333,0326,0000,0006,0700,0510,0747,0755,
+  0637,0020,0003,0770,0111,0750,0740,0777,0360,0403,0357,0707,0036,0444,0000,0310,
+  0077,0200,0572,0757,0420,0070,0660,0222,0031,0000,0657,0773,0407,0276,0760,0022,
+};
+
+const uint9 PPU::RP2C04_0004[16 * 4] = {
+  0430,0326,0044,0660,0000,0755,0014,0630,0555,0310,0070,0003,0764,0770,0040,0572,
+  0737,0200,0027,0747,0000,0222,0510,0740,0653,0053,0447,0140,0403,0000,0473,0357,
+  0503,0031,0420,0006,0407,0507,0333,0704,0022,0666,0036,0020,0111,0773,0444,0707,
+  0757,0777,0320,0700,0760,0276,0777,0467,0000,0750,0637,0567,0360,0657,0077,0120,
+};
+
 }
diff --git a/higan/higan/fc/ppu/ppu.hpp b/nSide/higan/fc/ppu/ppu.hpp
index 21b7341..c0797f2 100644
--- a/higan/higan/fc/ppu/ppu.hpp
+++ b/nSide/higan/fc/ppu/ppu.hpp
@@ -1,28 +1,70 @@
-struct PPU : Thread {
+struct PPU : Thread, PPUcounter {
+  enum class Version : uint {
+    //YIQ
+    RP2C02C,
+    RP2C02G,
+
+    //RGB
+    RP2C03B,
+    RP2C03G,
+    RP2C04_0001,
+    RP2C04_0002,
+    RP2C04_0003,
+    RP2C04_0004,
+    RC2C03B,
+    RC2C03C,
+    RC2C05_01,
+    RC2C05_02,
+    RC2C05_03,
+    RC2C05_04,
+    RC2C05_05,
+
+    //YUV
+    RP2C07,
+    UA6538,
+  } version;
+
+  alwaysinline auto ntsc() const -> bool { return version >= Version::RP2C02C && version <= Version::RP2C02G; }
+  alwaysinline auto pal()  const -> bool { return version >= Version::RP2C07  && version <= Version::UA6538;  }
+  alwaysinline auto rgb()  const -> bool { return version >= Version::RP2C03B && version <= Version::RC2C05_05; }
+
+  PPU();
+  ~PPU();
+
+  alwaysinline auto step(uint clocks) -> void;
+
   static auto Enter() -> void;
   auto main() -> void;
-  auto step(uint clocks) -> void;
-
-  auto scanline() -> void;
-  auto frame() -> void;
-  auto refresh() -> void;
-
+  auto load(Markup::Node) -> bool;
   auto power() -> void;
   auto reset() -> void;
 
-  //memory.cpp
-  auto readCIRAM(uint11 addr) -> uint8;
-  auto writeCIRAM(uint11 addr, uint8 data) -> void;
+  alwaysinline auto originX() -> uint;
+  alwaysinline auto originY() -> uint;
+
+  auto extIn() -> uint4;
+  auto extOut() -> uint4;
+
+  //mmio.cpp
+  auto readCIRAM(uint12 addr) -> uint8;
+  auto writeCIRAM(uint12 addr, uint8 data) -> void;
 
-  auto readCGRAM(uint5 addr) -> uint8;
-  auto writeCGRAM(uint5 addr, uint8 data) -> void;
+  alwaysinline auto readCGRAM(uint5 addr) -> uint8;
+  alwaysinline auto writeCGRAM(uint5 addr, uint8 data) -> void;
 
-  auto readIO(uint16 addr) -> uint8;
+  auto readIO(uint16 addr, uint8 data) -> uint8;
   auto writeIO(uint16 addr, uint8 data) -> void;
 
   //render.cpp
   auto enable() const -> bool;
-  auto loadCHR(uint16 addr) -> uint8;
+  auto nametableAddress() const -> uint;
+  auto scrollX() const -> uint;
+  auto scrollY() const -> uint;
+
+  auto loadCHR(uint14 addr) -> uint8;
+
+  auto scrollX_increment() -> void;
+  auto scrollY_increment() -> void;
 
   auto renderPixel() -> void;
   auto renderSprite() -> void;
@@ -31,13 +73,22 @@ struct PPU : Thread {
   //serialization.cpp
   auto serialize(serializer&) -> void;
 
+  uint8 ciram[4096];  //2048 in Famicom and PlayChoice-10
+  uint8 cgram[32];
+  uint8 oam[256];
+
+  bool side;  //VS. System; 0: main, 1: sub
+
+  static const uint9 RP2C03[16 * 4];
+  static const uint9 RP2C04_0001[16 * 4];
+  static const uint9 RP2C04_0002[16 * 4];
+  static const uint9 RP2C04_0003[16 * 4];
+  static const uint9 RP2C04_0004[16 * 4];
+
   struct IO {
-    //internal
+    uint14 chrAddressBus;
     uint8 mdr;
-
-    uint1 field;
-    uint lx;
-    uint ly;
+    uint mdrDecay[8];
 
     uint8 busData;
 
@@ -59,27 +110,27 @@ struct PPU : Thread {
     bool nmiHold;
     bool nmiFlag;
 
-    //$2000
-    uint vramIncrement;
-    uint spriteAddress;
-    uint bgAddress;
-    uint spriteHeight;
-    bool masterSelect;
+    //$2000  PPUCTRL
     bool nmiEnable;
+    bool masterSelect;
+    uint spriteHeight;
+    uint bgAddress;
+    uint objAddress;
+    uint vramIncrement;
 
-    //$2001
-    bool grayscale;
-    bool bgEdgeEnable;
-    bool spriteEdgeEnable;
-    bool bgEnable;
-    bool spriteEnable;
+    //$2001  PPUMASK
     uint3 emphasis;
+    bool objEnable;
+    bool bgEnable;
+    bool objEdgeEnable;
+    bool bgEdgeEnable;
+    bool grayscale;
 
-    //$2002
-    bool spriteOverflow;
+    //$2002  PPUSTATUS
     bool spriteZeroHit;
+    bool spriteOverflow;
 
-    //$2003
+    //$2003  OAMADDR
     uint8 oamAddress;
   } io;
 
@@ -108,13 +159,20 @@ struct PPU : Thread {
 
     OAM oam[8];   //primary
     OAM soam[8];  //secondary
-  } latch;
+  } l;
 
-  uint8 ciram[2048];
-  uint8 cgram[32];
-  uint8 oam[256];
+privileged:
+  uint32* output = nullptr;
+
+  uint4 _extOut;
+
+  auto scanline() -> void;
+  auto frame() -> void;
+  auto refresh() -> void;
 
-  uint32 buffer[256 * 262];
+  friend class Zapper;
+  friend class BeamGun;
+  friend class System;
 };
 
 extern PPU ppu;
diff --git a/higan/higan/fc/ppu/render.cpp b/nSide/higan/fc/ppu/render.cpp
index ec5863b..935a068 100644
--- a/higan/higan/fc/ppu/render.cpp
+++ b/nSide/higan/fc/ppu/render.cpp
@@ -1,24 +1,23 @@
 auto PPU::enable() const -> bool {
-  return io.bgEnable || io.spriteEnable;
+  return io.bgEnable || io.objEnable;
 }
 
-auto PPU::loadCHR(uint16 addr) -> uint8 {
-  return enable() ? cartridge.readCHR(addr) : (uint8)0x00;
+auto PPU::loadCHR(uint14 addr) -> uint8 {
+  return enable() ? cartridge.readCHR(io.chrAddressBus = addr) : (uint8)0x00;
 }
 
 auto PPU::renderPixel() -> void {
-  uint32* output = buffer + io.ly * 256;
-
-  uint x = io.lx - 1;
+  if(vcounter() >= 240) return;
+  uint x = hcounter() - 1;
   uint mask = 0x8000 >> (io.v.fineX + (x & 7));
   uint palette = 0;
   uint objectPalette = 0;
   bool objectPriority = 0;
 
-  palette |= latch.tiledataLo & mask ? 1 : 0;
-  palette |= latch.tiledataHi & mask ? 2 : 0;
+  palette |= l.tiledataLo & mask ? 1 : 0;
+  palette |= l.tiledataHi & mask ? 2 : 0;
   if(palette) {
-    uint attr = latch.attribute;
+    uint attr = l.attribute;
     if(mask >= 256) attr >>= 2;
     palette |= (attr & 3) << 2;
   }
@@ -26,25 +25,25 @@ auto PPU::renderPixel() -> void {
   if(!io.bgEnable) palette = 0;
   if(!io.bgEdgeEnable && x < 8) palette = 0;
 
-  if(io.spriteEnable)
+  if(io.objEnable)
   for(int sprite = 7; sprite >= 0; sprite--) {
-    if(!io.spriteEdgeEnable && x < 8) continue;
-    if(latch.oam[sprite].id == 64) continue;
+    if(!io.objEdgeEnable && x < 8) continue;
+    if(l.oam[sprite].id == 64) continue;
 
-    uint spriteX = x - latch.oam[sprite].x;
+    uint spriteX = x - l.oam[sprite].x;
     if(spriteX >= 8) continue;
 
-    if(latch.oam[sprite].attr & 0x40) spriteX ^= 7;
+    if(l.oam[sprite].attr & 0x40) spriteX ^= 7;
     uint mask = 0x80 >> spriteX;
     uint spritePalette = 0;
-    spritePalette |= latch.oam[sprite].tiledataLo & mask ? 1 : 0;
-    spritePalette |= latch.oam[sprite].tiledataHi & mask ? 2 : 0;
+    spritePalette |= l.oam[sprite].tiledataLo & mask ? 1 : 0;
+    spritePalette |= l.oam[sprite].tiledataHi & mask ? 2 : 0;
     if(spritePalette == 0) continue;
 
-    if(latch.oam[sprite].id == 0 && palette && x != 255) io.spriteZeroHit = 1;
-    spritePalette |= (latch.oam[sprite].attr & 3) << 2;
+    if(l.oam[sprite].id == 0 && palette && x != 255) io.spriteZeroHit = 1;
+    spritePalette |= (l.oam[sprite].attr & 3) << 2;
 
-    objectPriority = latch.oam[sprite].attr & 0x20;
+    objectPriority = l.oam[sprite].attr & 0x20;
     objectPalette = 16 + spritePalette;
   }
 
@@ -52,24 +51,35 @@ auto PPU::renderPixel() -> void {
     if(palette == 0 || objectPriority == 0) palette = objectPalette;
   }
 
-  if(!enable()) palette = 0;
-  output[x] = io.emphasis << 6 | readCGRAM(palette);
+  if(version >= Version::RP2C07 && (x < 2 || x >= 254 || vcounter() <= 0)) {
+    output[vcounter() * 256 + x] = (io.emphasis << 6) | 0x1d;
+    return;
+  } else if(!enable()) {
+    if((io.v.addressHi & 0x3f) != 0x3f) palette = extIn();
+    else palette = io.v.addressLo;
+    _extOut = io.v.addressLo;
+  } else {
+    if(!palette) palette = extIn();
+    _extOut = 0;
+  }
+  output[vcounter() * 256 + x] = io.emphasis << 6 | readCGRAM(palette);
 }
 
 auto PPU::renderSprite() -> void {
   if(!enable()) return;
 
-  uint n = latch.oamIterator++;
-  int ly = io.ly == 261 ? -1 : io.ly;
+  uint n = l.oamIterator++;
+  uint lastScanline = system.region() == System::Region::NTSC ? 261 : 311;
+  int ly = vcounter() == lastScanline ? -1 : (int)vcounter();
   uint y = ly - oam[n * 4 + 0];
 
   if(y >= io.spriteHeight) return;
-  if(latch.oamCounter == 8) {
+  if(l.oamCounter == 8) {
     io.spriteOverflow = 1;
     return;
   }
 
-  auto& o = latch.soam[latch.oamCounter++];
+  auto& o = l.soam[l.oamCounter++];
   o.id   = n;
   o.y    = oam[n * 4 + 0];
   o.tile = oam[n * 4 + 1];
@@ -78,13 +88,14 @@ auto PPU::renderSprite() -> void {
 }
 
 auto PPU::renderScanline() -> void {
+  uint lastScanline = system.region() == System::Region::NTSC ? 261 : 311;
   //Vblank
-  if(io.ly >= 240 && io.ly <= 260) return step(341), scanline();
+  if((vcounter() >= 240 && vcounter() < lastScanline)) return step(341), scanline();
 
-  latch.oamIterator = 0;
-  latch.oamCounter = 0;
+  l.oamIterator = 0;
+  l.oamCounter = 0;
 
-  for(auto n : range(8)) latch.soam[n] = {};
+  for(auto n : range(8)) l.soam[n] = {};
 
   //  0
   step(1);
@@ -105,8 +116,8 @@ auto PPU::renderScanline() -> void {
     renderPixel();
     step(1);
 
-    if(enable() && ++io.v.tileX == 0) io.v.nametableX++;
-    if(enable() && tile == 31 && ++io.v.fineY == 0 && ++io.v.tileY == 30) io.v.nametableY++, io.v.tileY = 0;
+    if(enable() && ++io.v.tileX == 0) io.v.nametableX ^= 1;
+    if(enable() && tile == 31 && ++io.v.fineY == 0 && ++io.v.tileY == 30) io.v.nametableY ^= 1, io.v.tileY = 0;
     renderPixel();
     renderSprite();
     step(1);
@@ -126,13 +137,13 @@ auto PPU::renderScanline() -> void {
     renderSprite();
     step(1);
 
-    latch.nametable = latch.nametable << 8 | nametable;
-    latch.attribute = latch.attribute << 2 | (attribute & 3);
-    latch.tiledataLo = latch.tiledataLo << 8 | tiledataLo;
-    latch.tiledataHi = latch.tiledataHi << 8 | tiledataHi;
+    l.nametable = l.nametable << 8 | nametable;
+    l.attribute = l.attribute << 2 | (attribute & 3);
+    l.tiledataLo = l.tiledataLo << 8 | tiledataLo;
+    l.tiledataHi = l.tiledataHi << 8 | tiledataHi;
   }
 
-  for(auto n : range(8)) latch.oam[n] = latch.soam[n];
+  for(auto n : range(8)) l.oam[n] = l.soam[n];
 
   //257-320
   for(uint sprite : range(8)) {
@@ -148,21 +159,21 @@ auto PPU::renderScanline() -> void {
 
     uint attribute = loadCHR(0x23c0 | io.v.nametable << 10 | (io.v.tileY >> 2) << 3 | io.v.tileX >> 2);
     uint tileaddr = io.spriteHeight == 8
-    ? io.spriteAddress + latch.oam[sprite].tile * 16
-    : (latch.oam[sprite].tile & ~1) * 16 + (latch.oam[sprite].tile & 1) * 0x1000;
+    ? io.objAddress + l.oam[sprite].tile * 16
+    : (l.oam[sprite].tile & ~1) * 16 + (l.oam[sprite].tile & 1) * 0x1000;
     step(2);
 
-    uint spriteY = (io.ly - latch.oam[sprite].y) & (io.spriteHeight - 1);
-    if(latch.oam[sprite].attr & 0x80) spriteY ^= io.spriteHeight - 1;
+    uint spriteY = (vcounter() - l.oam[sprite].y) & (io.spriteHeight - 1);
+    if(l.oam[sprite].attr & 0x80) spriteY ^= io.spriteHeight - 1;
     tileaddr += spriteY + (spriteY & 8);
 
-    latch.oam[sprite].tiledataLo = loadCHR(tileaddr + 0);
+    l.oam[sprite].tiledataLo = loadCHR(tileaddr + 0);
     step(2);
 
-    latch.oam[sprite].tiledataHi = loadCHR(tileaddr + 8);
+    l.oam[sprite].tiledataHi = loadCHR(tileaddr + 8);
     step(2);
 
-    if(enable() && sprite == 6 && io.ly == 261) {
+    if(enable() && sprite == 6 && vcounter() == lastScanline) {
       //305
       io.v.address = io.t.address;
     }
@@ -179,7 +190,7 @@ auto PPU::renderScanline() -> void {
     if(io.v.tileX & 2) attribute >>= 2;
     step(1);
 
-    if(enable() && ++io.v.tileX == 0) io.v.nametableX++;
+    if(enable() && ++io.v.tileX == 0) io.v.nametableX ^= 1;
     step(1);
 
     uint tiledataLo = loadCHR(tileaddr + 0);
@@ -188,24 +199,22 @@ auto PPU::renderScanline() -> void {
     uint tiledataHi = loadCHR(tileaddr + 8);
     step(2);
 
-    latch.nametable = latch.nametable << 8 | nametable;
-    latch.attribute = latch.attribute << 2 | (attribute & 3);
-    latch.tiledataLo = latch.tiledataLo << 8 | tiledataLo;
-    latch.tiledataHi = latch.tiledataHi << 8 | tiledataHi;
+    l.nametable = l.nametable << 8 | nametable;
+    l.attribute = l.attribute << 2 | (attribute & 3);
+    l.tiledataLo = l.tiledataLo << 8 | tiledataLo;
+    l.tiledataHi = l.tiledataHi << 8 | tiledataHi;
   }
 
   //337-338
   loadCHR(0x2000 | (uint12)io.v.address);
-  step(1);
-  bool skip = enable() && io.field == 1 && io.ly == 261;
-  step(1);
+  step(2);
 
   //339
   loadCHR(0x2000 | (uint12)io.v.address);
   step(1);
 
   //340
-  if(!skip) step(1);
+  if(hcounter() > 0) step(1);
 
   return scanline();
 }
diff --git a/higan/higan/fc/ppu/serialization.cpp b/nSide/higan/fc/ppu/serialization.cpp
index 15ea30f..e58fef8 100644
--- a/higan/higan/fc/ppu/serialization.cpp
+++ b/nSide/higan/fc/ppu/serialization.cpp
@@ -1,11 +1,16 @@
+auto PPUcounter::serialize(serializer& s) -> void {
+  s.integer(status.field);
+  s.integer(status.hcounter);
+  s.integer(status.vcounter);
+}
+
 auto PPU::serialize(serializer& s) -> void {
   Thread::serialize(s);
+  PPUcounter::serialize(s);
 
+  s.integer(io.chrAddressBus);
   s.integer(io.mdr);
-
-  s.integer(io.field);
-  s.integer(io.lx);
-  s.integer(io.ly);
+  s.array(io.mdrDecay);
 
   s.integer(io.busData);
 
@@ -16,7 +21,7 @@ auto PPU::serialize(serializer& s) -> void {
   s.integer(io.nmiFlag);
 
   s.integer(io.vramIncrement);
-  s.integer(io.spriteAddress);
+  s.integer(io.objAddress);
   s.integer(io.bgAddress);
   s.integer(io.spriteHeight);
   s.integer(io.masterSelect);
@@ -24,9 +29,9 @@ auto PPU::serialize(serializer& s) -> void {
 
   s.integer(io.grayscale);
   s.integer(io.bgEdgeEnable);
-  s.integer(io.spriteEdgeEnable);
+  s.integer(io.objEdgeEnable);
   s.integer(io.bgEnable);
-  s.integer(io.spriteEnable);
+  s.integer(io.objEnable);
   s.integer(io.emphasis);
 
   s.integer(io.spriteOverflow);
@@ -34,22 +39,20 @@ auto PPU::serialize(serializer& s) -> void {
 
   s.integer(io.oamAddress);
 
-  s.integer(latch.nametable);
-  s.integer(latch.attribute);
-  s.integer(latch.tiledataLo);
-  s.integer(latch.tiledataHi);
+  s.integer(l.nametable);
+  s.integer(l.attribute);
+  s.integer(l.tiledataLo);
+  s.integer(l.tiledataHi);
 
-  s.integer(latch.oamIterator);
-  s.integer(latch.oamCounter);
+  s.integer(l.oamIterator);
+  s.integer(l.oamCounter);
 
-  for(auto& o : latch.oam) o.serialize(s);
-  for(auto& o : latch.soam) o.serialize(s);
+  for(auto& o : l.oam) o.serialize(s);
+  for(auto& o : l.soam) o.serialize(s);
 
-  s.array(ciram);
+  s.array(ciram, !system.vs() ? 0x0800 : 0x1000);
   s.array(cgram);
   s.array(oam);
-
-  s.array(buffer);
 }
 
 auto PPU::OAM::serialize(serializer& s) -> void {
diff --git a/higan/higan/fc/system/peripherals.cpp b/nSide/higan/fc/system/peripherals.cpp
index 35aab59..08c96b0 100644
--- a/higan/higan/fc/system/peripherals.cpp
+++ b/nSide/higan/fc/system/peripherals.cpp
@@ -3,13 +3,17 @@ Peripherals peripherals;
 auto Peripherals::unload() -> void {
   delete controllerPort1;
   delete controllerPort2;
+  delete expansionPort;
   controllerPort1 = nullptr;
   controllerPort2 = nullptr;
+  expansionPort = nullptr;
 }
 
 auto Peripherals::reset() -> void {
   connect(ID::Port::Controller1, settings.controllerPort1);
   connect(ID::Port::Controller2, settings.controllerPort2);
+  connect(ID::Port::Expansion, settings.expansionPort);
+  connect(ID::Port::Arcade, settings.arcadePanel);
 }
 
 auto Peripherals::connect(uint port, uint device) -> void {
@@ -19,8 +23,17 @@ auto Peripherals::connect(uint port, uint device) -> void {
 
     delete controllerPort1;
     switch(device) { default:
-    case ID::Device::None: controllerPort1 = new Controller(0); break;
-    case ID::Device::Gamepad: controllerPort1 = new Gamepad(0); break;
+    case ID::Device::None:        controllerPort1 = new Controller(0); break;
+    case ID::Device::Gamepad:     controllerPort1 = new Gamepad(0); break;
+    case ID::Device::FourScore:   controllerPort1 = new FourScore(0); break;
+    case ID::Device::SNESGamepad: controllerPort1 = new SNESGamepad(0); break;
+    case ID::Device::Mouse:       controllerPort1 = new Mouse(0); break;
+    }
+
+    if(device == ID::Device::FourScore && settings.controllerPort2 != ID::Device::FourScore) {
+      connect(ID::Port::Controller2, ID::Device::FourScore);
+    } else if(device != ID::Device::FourScore && settings.controllerPort2 == ID::Device::FourScore) {
+      connect(ID::Port::Controller2, ID::Device::None);
     }
   }
 
@@ -30,17 +43,50 @@ auto Peripherals::connect(uint port, uint device) -> void {
 
     delete controllerPort2;
     switch(device) { default:
-    case ID::Device::None: controllerPort2 = new Controller(1); break;
-    case ID::Device::Gamepad: controllerPort2 = new Gamepad(1); break;
+    case ID::Device::None:        controllerPort2 = new Controller(1); break;
+    case ID::Device::Gamepad:     controllerPort2 = new Gamepad(1); break;
+    case ID::Device::GamepadMic:  controllerPort2 = new GamepadMic(1); break;
+    case ID::Device::FourScore:   controllerPort2 = new FourScore(1); break;
+    case ID::Device::Zapper:      controllerPort2 = new Zapper(1); break;
+    case ID::Device::PowerPad:    controllerPort2 = new PowerPad(1); break;
+    case ID::Device::Vaus:        controllerPort2 = new Vaus(1); break;
+    case ID::Device::SNESGamepad: controllerPort2 = new SNESGamepad(1); break;
+    case ID::Device::Mouse:       controllerPort2 = new Mouse(1); break;
+    }
+
+    if(device == ID::Device::FourScore && settings.controllerPort1 != ID::Device::FourScore) {
+      connect(ID::Port::Controller1, ID::Device::FourScore);
+    } else if(device != ID::Device::FourScore && settings.controllerPort1 == ID::Device::FourScore) {
+      connect(ID::Port::Controller1, ID::Device::None);
     }
   }
 
   if(port == ID::Port::Expansion) {
     settings.expansionPort = device;
     if(!system.loaded()) return;
+
+    delete expansionPort;
+    switch(device) { default:
+    case ID::Device::None:           expansionPort = new Expansion; break;
+    case ID::Device::GamepadE:       expansionPort = new GamepadE; break;
+    case ID::Device::JoyPair:        expansionPort = new JoyPair; break;
+    case ID::Device::FourPlayers:    expansionPort = new FourPlayers; break;
+    case ID::Device::BeamGun:        expansionPort = new BeamGun; break;
+    case ID::Device::FamilyKeyboard: expansionPort = new FamilyKeyboard; break;
+    case ID::Device::FamilyTrainer:  expansionPort = new FamilyTrainer; break;
+    case ID::Device::VausE:          expansionPort = new VausE; break;
+    case ID::Device::SFCGamepad:     expansionPort = new SFCGamepad; break;
+    case ID::Device::MouseE:         expansionPort = new MouseE; break;
+    }
+  }
+
+  if(port == ID::Port::Arcade) {
+    settings.arcadePanel = device;
+    if(!system.loaded()) return;
   }
 
   cpu.peripherals.reset();
   cpu.peripherals.append(controllerPort1);
   cpu.peripherals.append(controllerPort2);
+  cpu.peripherals.append(expansionPort);
 }
diff --git a/higan/higan/fc/system/serialization.cpp b/nSide/higan/fc/system/serialization.cpp
index ddfe098..b5be797 100644
--- a/higan/higan/fc/system/serialization.cpp
+++ b/nSide/higan/fc/system/serialization.cpp
@@ -1,10 +1,10 @@
 auto System::serialize() -> serializer {
-  serializer s(_serializeSize);
+  serializer s(serializeSize);
 
   uint signature = 0x31545342;
-  char version[16] = {0};
-  char hash[64] = {0};
-  char description[512] = {0};
+  char version[16] = {};
+  char hash[64] = {};
+  char description[512] = {};
   memory::copy(&version, (const char*)Emulator::SerializerVersion, Emulator::SerializerVersion.size());
   memory::copy(&hash, (const char*)cartridge.sha256(), 64);
 
@@ -18,10 +18,10 @@ auto System::serialize() -> serializer {
 }
 
 auto System::unserialize(serializer& s) -> bool {
-  uint signature;
-  char version[16];
-  char hash[64];
-  char description[512];
+  uint signature = 0;
+  char version[16] = {};
+  char hash[64] = {};
+  char description[512] = {};
 
   s.integer(signature);
   s.array(version);
@@ -36,24 +36,33 @@ auto System::unserialize(serializer& s) -> bool {
   return true;
 }
 
+//internal
+
 auto System::serialize(serializer& s) -> void {
+  s.integer((uint&)information.region);
 }
 
 auto System::serializeAll(serializer& s) -> void {
-  system.serialize(s);
   cartridge.serialize(s);
+  system.serialize(s);
   cpu.serialize(s);
   apu.serialize(s);
   ppu.serialize(s);
+
+  if(model() == Model::VSSystem) vssystem.serialize(s);
+  if(model() == Model::PlayChoice10) playchoice10.serialize(s);
 }
 
+//perform dry-run state save:
+//determines exactly how many bytes are needed to save state for this cartridge,
+//as amount varies per game (eg different RAM sizes, etc.)
 auto System::serializeInit() -> void {
   serializer s;
 
   uint signature = 0;
-  char version[16];
-  char hash[64];
-  char description[512];
+  char version[16] = {};
+  char hash[64] = {};
+  char description[512] = {};
 
   s.integer(signature);
   s.array(version);
@@ -61,5 +70,5 @@ auto System::serializeInit() -> void {
   s.array(description);
 
   serializeAll(s);
-  _serializeSize = s.size();
+  serializeSize = s.size();
 }
diff --git a/higan/higan/fc/system/system.cpp b/nSide/higan/fc/system/system.cpp
index 05ae377..c67dcbc 100644
--- a/higan/higan/fc/system/system.cpp
+++ b/nSide/higan/fc/system/system.cpp
@@ -2,15 +2,18 @@
 
 namespace Famicom {
 
-#include "peripherals.cpp"
-#include "video.cpp"
-#include "serialization.cpp"
 System system;
 Scheduler scheduler;
 Cheat cheat;
+#include "video.cpp"
+#include "peripherals.cpp"
+#include "serialization.cpp"
 
 auto System::run() -> void {
-  if(scheduler.enter() == Scheduler::Event::Frame) ppu.refresh();
+  if(scheduler.enter() == Scheduler::Event::Frame) {
+    ppu.refresh();
+    if(pc10()) playchoice10.videoCircuit.refresh();
+  }
 }
 
 auto System::runToSave() -> void {
@@ -18,30 +21,99 @@ auto System::runToSave() -> void {
   scheduler.synchronize(apu);
   scheduler.synchronize(ppu);
   scheduler.synchronize(cartridge);
+  for(auto coprocessor : cpu.coprocessors) scheduler.synchronize(*coprocessor);
   for(auto peripheral : cpu.peripherals) scheduler.synchronize(*peripheral);
 }
 
-auto System::load() -> bool {
+auto System::init() -> void {
+  assert(interface != nullptr);
+
+  vssystem.init();
+  playchoice10.init();
+  famicombox.init();
+}
+
+auto System::term() -> void {
+}
+
+auto System::load(Model model) -> bool {
   information = Information();
+
+  information.model = model;
+
   if(auto fp = interface->open(ID::System, "manifest.bml", File::Read, File::Required)) {
     information.manifest = fp->reads();
-  } else {
-    return false;
-  }
+  } else return false;
+
   auto document = BML::unserialize(information.manifest);
+  auto system = document["system"];
+
+  bus.reset();
   if(!cartridge.load()) return false;
-  information.colorburst = Emulator::Constants::Colorburst::NTSC;
+
+  switch(cartridge.region()) {
+  case Cartridge::Region::NTSC:  information.region = Region::NTSC;  break;
+  case Cartridge::Region::PAL:   information.region = Region::PAL;   break;
+  case Cartridge::Region::Dendy: information.region = Region::Dendy; break;
+  }
+  if(system["region"].text() == "NTSC" ) information.region = Region::NTSC;
+  if(system["region"].text() == "PAL"  ) information.region = Region::PAL;
+  if(system["region"].text() == "Dendy") information.region = Region::Dendy;
+
+  if(!cpu.load(system)) return false;
+  if(!apu.load(system)) return false;
+  if(!ppu.load(system)) return false;
+
+  information.colorburst = region() == Region::NTSC
+  ? Emulator::Constants::Colorburst::NTSC
+  : Emulator::Constants::Colorburst::PAL;
+
+  switch(model) {
+
+  case Model::Famicom: {
+    peripherals.connect(ID::Port::Arcade, ID::Device::None);
+    break;
+  }
+
+  case Model::VSSystem: {
+    vssystem.load();
+    peripherals.connect(ID::Port::Arcade, ID::Device::VSPanel);
+    break;
+  }
+
+  case Model::PlayChoice10: {
+    if(!playchoice10.load(system)) return false;
+    peripherals.connect(ID::Port::Arcade, ID::Device::None);
+    break;
+  }
+
+  case Model::FamicomBox: {
+    if(!famicombox.load(system)) return false;
+    peripherals.connect(ID::Port::Arcade, ID::Device::None);
+    break;
+  }
+
+  }
+
   serializeInit();
   return information.loaded = true;
 }
 
 auto System::save() -> void {
+  if(!loaded()) return;
   cartridge.save();
 }
 
 auto System::unload() -> void {
   if(!loaded()) return;
   peripherals.unload();
+
+  switch(model()) {
+  case Model::VSSystem:     vssystem.unload(); break;
+  case Model::PlayChoice10: playchoice10.unload(); break;
+  case Model::FamicomBox:   famicombox.unload(); break;
+  }
+
   cartridge.unload();
   information.loaded = false;
 }
@@ -51,12 +123,21 @@ auto System::power() -> void {
   cpu.power();
   apu.power();
   ppu.power();
+
+  switch(model()) {
+  case Model::VSSystem:     vssystem.power(); break;
+  case Model::PlayChoice10: playchoice10.power(); break;
+  case Model::FamicomBox:   famicombox.power(); break;
+  }
+
+//ppu.reset();
   reset();
 }
 
 auto System::reset() -> void {
   Emulator::video.reset();
   Emulator::video.setInterface(interface);
+  //Emulator::video.resize() is called in configureVideoEffects()
   configureVideoPalette();
   configureVideoEffects();
 
@@ -67,16 +148,24 @@ auto System::reset() -> void {
   cartridge.reset();
   cpu.reset();
   apu.reset();
+  //Only the NES front-loader's PPU will reset. The Famicom's and NES top-loader's PPU will not.
+  //Because of a limitation of the Scheduler, the PPU must reset when the system resets.
   ppu.reset();
-  scheduler.primary(cpu);
-  peripherals.reset();
-}
 
-auto System::init() -> void {
-  assert(interface != nullptr);
-}
+  switch(model()) {
+  case Model::VSSystem:     vssystem.reset(); break;
+  case Model::PlayChoice10: playchoice10.reset(); break;
+  case Model::FamicomBox:   famicombox.reset(); break;
+  }
 
-auto System::term() -> void {
+  switch(model()) {
+  case Model::VSSystem:     cpu.coprocessors.append(&vssystem); break;
+  case Model::PlayChoice10: cpu.coprocessors.append(&playchoice10.pc10cpu); break;
+  case Model::FamicomBox:   cpu.coprocessors.append(&famicombox); break;
+  }
+
+  scheduler.primary(cpu);
+  peripherals.reset();
 }
 
 }
diff --git a/higan/higan/fc/system/system.hpp b/nSide/higan/fc/system/system.hpp
index c28aec4..fd0e54b 100644
--- a/higan/higan/fc/system/system.hpp
+++ b/nSide/higan/fc/system/system.hpp
@@ -1,19 +1,29 @@
+struct Interface;
+
 struct System {
-  auto loaded() const -> bool { return information.loaded; }
-  auto colorburst() const -> double { return information.colorburst; }
+  enum class Region : uint { NTSC = 0, PAL = 1, Dendy = 2 };
+
+  inline auto loaded() const -> bool { return information.loaded; }
+  inline auto model() const -> Model { return information.model; }
+  inline auto region() const -> Region { return information.region; }
+  inline auto colorburst() const -> double { return information.colorburst; }
+
+  inline auto fc()   const { return information.model == Model::Famicom; }
+  inline auto vs()   const { return information.model == Model::VSSystem; }
+  inline auto pc10() const { return information.model == Model::PlayChoice10; }
+  inline auto fcb()  const { return information.model == Model::FamicomBox; }
 
   auto run() -> void;
   auto runToSave() -> void;
 
-  auto load() -> bool;
+  auto init() -> void;
+  auto term() -> void;
+  auto load(Model) -> bool;
   auto save() -> void;
   auto unload() -> void;
   auto power() -> void;
   auto reset() -> void;
 
-  auto init() -> void;
-  auto term() -> void;
-
   //video.cpp
   auto configureVideoPalette() -> void;
   auto configureVideoEffects() -> void;
@@ -22,18 +32,22 @@ struct System {
   auto serialize() -> serializer;
   auto unserialize(serializer&) -> bool;
 
-  auto serialize(serializer&) -> void;
-  auto serializeAll(serializer&) -> void;
-  auto serializeInit() -> void;
-
+private:
   struct Information {
+    string manifest;
     bool loaded = false;
+    Model model = Model::Famicom;
+    Region region = Region::NTSC;
     double colorburst = 0.0;
-    string manifest;
   } information;
 
-private:
-  uint _serializeSize = 0;
+  uint serializeSize = 0;
+
+  auto serialize(serializer&) -> void;
+  auto serializeAll(serializer&) -> void;
+  auto serializeInit() -> void;
+
+  friend class Cartridge;
 };
 
 struct Peripherals {
@@ -43,6 +57,7 @@ struct Peripherals {
 
   Controller* controllerPort1 = nullptr;
   Controller* controllerPort2 = nullptr;
+  Expansion* expansionPort = nullptr;
 };
 
 extern System system;
diff --git a/higan/higan/fc/system/video.cpp b/nSide/higan/fc/system/video.cpp
index 66d0929..e6804b9 100644
--- a/higan/higan/fc/system/video.cpp
+++ b/nSide/higan/fc/system/video.cpp
@@ -3,4 +3,12 @@ auto System::configureVideoPalette() -> void {
 }
 
 auto System::configureVideoEffects() -> void {
+  Emulator::video.setEffect(Emulator::Video::Effect::Scanlines, settings.scanlineEmulation);
+  if(fc() || fcb()) {
+    Emulator::video.resize(256, 240);
+  } else if(vs()) {
+    Emulator::video.resize(256 * vssystem.gameCount, 240);
+  } else if(pc10()) {
+    Emulator::video.resize(256, 240 + (playchoice10.screenConfig - 1) * 224);
+  }
 }

