diff -Nru higan/GNUmakefile higan/GNUmakefile
--- higan/GNUmakefile	2015-09-16 02:20:06.353574578 +0900
+++ higan/GNUmakefile	2015-09-16 13:08:13.885563402 +0900
@@ -97,15 +106,18 @@
 	if [ -d ./nall ]; then rm -r ./nall; fi
 	if [ -d ./ruby ]; then rm -r ./ruby; fi
 	if [ -d ./hiro ]; then rm -r ./hiro; fi
+	if [ -d ./phoenix ]; then rm -r ./phoenix; fi
 	cp -r ../libco ./libco
 	cp -r ../nall ./nall
 	cp -r ../ruby ./ruby
 	cp -r ../hiro ./hiro
+	cp -r ../phoenix ./phoenix
 	rm -r libco/doc
 	rm -r libco/-test
 	rm -r nall/-test
 	rm -r ruby/-test
 	rm -r hiro/-test
+	rm -r phoenix/.test
 endif
 
 help:;
diff -Nru higan/phoenix/cocoa/action/action.cpp nSide/phoenix/cocoa/action/action.cpp
--- higan/phoenix/cocoa/action/action.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/action/action.cpp	2015-09-16 13:08:13.596563372 +0900
@@ -0,0 +1,21 @@
+namespace phoenix {
+
+void pAction::setEnabled(bool enabled) {
+  @autoreleasepool {
+    [cocoaAction setEnabled:enabled];
+  }
+}
+
+void pAction::setVisible(bool visible) {
+  @autoreleasepool {
+    [cocoaAction setHidden:!visible];
+  }
+}
+
+void pAction::constructor() {
+}
+
+void pAction::destructor() {
+}
+
+}
diff -Nru higan/phoenix/cocoa/action/action.hpp nSide/phoenix/cocoa/action/action.hpp
--- higan/phoenix/cocoa/action/action.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/action/action.hpp	2015-09-16 13:08:13.596563372 +0900
@@ -0,0 +1,15 @@
+namespace phoenix {
+
+struct pAction : public pObject {
+  Action& action;
+  NSMenuItem* cocoaAction = nullptr;
+
+  void setEnabled(bool enabled);
+  void setVisible(bool visible);
+
+  pAction(Action& action) : pObject(action), action(action) {}
+  void constructor();
+  void destructor();
+};
+
+}
diff -Nru higan/phoenix/cocoa/action/check-item.cpp nSide/phoenix/cocoa/action/check-item.cpp
--- higan/phoenix/cocoa/action/check-item.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/action/check-item.cpp	2015-09-16 13:08:13.596563372 +0900
@@ -0,0 +1,49 @@
+@implementation CocoaCheckItem : NSMenuItem
+
+-(id) initWith:(phoenix::CheckItem&)checkItemReference {
+  if(self = [super initWithTitle:@"" action:@selector(activate) keyEquivalent:@""]) {
+    checkItem = &checkItemReference;
+
+    [self setTarget:self];
+  }
+  return self;
+}
+
+-(void) activate {
+  checkItem->state.checked = !checkItem->state.checked;
+  auto state = checkItem->state.checked ? NSOnState : NSOffState;
+  [self setState:state];
+  if(checkItem->onToggle) checkItem->onToggle();
+}
+
+@end
+
+namespace phoenix {
+
+void pCheckItem::setChecked(bool checked) {
+  @autoreleasepool {
+    auto state = checked ? NSOnState : NSOffState;
+    [cocoaAction setState:state];
+  }
+}
+
+void pCheckItem::setText(string text) {
+  @autoreleasepool {
+    [cocoaAction setTitle:[NSString stringWithUTF8String:text]];
+  }
+}
+
+void pCheckItem::constructor() {
+  @autoreleasepool {
+    cocoaAction = cocoaCheckItem = [[CocoaCheckItem alloc] initWith:checkItem];
+    setText(checkItem.state.text);
+  }
+}
+
+void pCheckItem::destructor() {
+  @autoreleasepool {
+    [cocoaAction release];
+  }
+}
+
+}
diff -Nru higan/phoenix/cocoa/action/check-item.hpp nSide/phoenix/cocoa/action/check-item.hpp
--- higan/phoenix/cocoa/action/check-item.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/action/check-item.hpp	2015-09-16 13:08:13.596563372 +0900
@@ -0,0 +1,23 @@
+@interface CocoaCheckItem : NSMenuItem {
+@public
+  phoenix::CheckItem* checkItem;
+}
+-(id) initWith:(phoenix::CheckItem&)checkItem;
+-(void) activate;
+@end
+
+namespace phoenix {
+
+struct pCheckItem : public pAction {
+  CheckItem& checkItem;
+  CocoaCheckItem* cocoaCheckItem = nullptr;
+
+  void setChecked(bool checked);
+  void setText(string text);
+
+  pCheckItem(CheckItem& checkItem) : pAction(checkItem), checkItem(checkItem) {}
+  void constructor();
+  void destructor();
+};
+
+}
diff -Nru higan/phoenix/cocoa/action/item.cpp nSide/phoenix/cocoa/action/item.cpp
--- higan/phoenix/cocoa/action/item.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/action/item.cpp	2015-09-16 13:08:13.597563372 +0900
@@ -0,0 +1,45 @@
+@implementation CocoaItem : NSMenuItem
+
+-(id) initWith:(phoenix::Item&)itemReference {
+  if(self = [super initWithTitle:@"" action:@selector(activate) keyEquivalent:@""]) {
+    item = &itemReference;
+
+    [self setTarget:self];
+  }
+  return self;
+}
+
+-(void) activate {
+  if(item->onActivate) item->onActivate();
+}
+
+@end
+
+namespace phoenix {
+
+void pItem::setImage(const image& image) {
+  @autoreleasepool {
+    unsigned size = 15;  //there is no API to retrieve the optimal size
+    [cocoaAction setImage:NSMakeImage(image, size, size)];
+  }
+}
+
+void pItem::setText(string text) {
+  @autoreleasepool {
+    [cocoaAction setTitle:[NSString stringWithUTF8String:text]];
+  }
+}
+
+void pItem::constructor() {
+  @autoreleasepool {
+    cocoaAction = cocoaItem = [[CocoaItem alloc] initWith:item];
+  }
+}
+
+void pItem::destructor() {
+  @autoreleasepool {
+    [cocoaAction release];
+  }
+}
+
+}
diff -Nru higan/phoenix/cocoa/action/item.hpp nSide/phoenix/cocoa/action/item.hpp
--- higan/phoenix/cocoa/action/item.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/action/item.hpp	2015-09-16 13:08:13.596563372 +0900
@@ -0,0 +1,23 @@
+@interface CocoaItem : NSMenuItem {
+@public
+  phoenix::Item* item;
+}
+-(id) initWith:(phoenix::Item&)item;
+-(void) activate;
+@end
+
+namespace phoenix {
+
+struct pItem : public pAction {
+  Item& item;
+  CocoaItem* cocoaItem = nullptr;
+
+  void setImage(const image& image);
+  void setText(string text);
+
+  pItem(Item& item) : pAction(item), item(item) {}
+  void constructor();
+  void destructor();
+};
+
+}
diff -Nru higan/phoenix/cocoa/action/menu.cpp nSide/phoenix/cocoa/action/menu.cpp
--- higan/phoenix/cocoa/action/menu.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/action/menu.cpp	2015-09-16 13:08:13.597563372 +0900
@@ -0,0 +1,61 @@
+@implementation CocoaMenu : NSMenuItem
+
+-(id) initWith:(phoenix::Menu&)menuReference {
+  if(self = [super initWithTitle:@"" action:nil keyEquivalent:@""]) {
+    menu = &menuReference;
+
+    cocoaMenu = [[NSMenu alloc] initWithTitle:@""];
+    [self setSubmenu:cocoaMenu];
+  }
+  return self;
+}
+
+-(NSMenu*) cocoaMenu {
+  return cocoaMenu;
+}
+
+@end
+
+namespace phoenix {
+
+void pMenu::append(Action& action) {
+  @autoreleasepool {
+    [[cocoaAction cocoaMenu] addItem:action.p.cocoaAction];
+  }
+}
+
+void pMenu::remove(Action& action) {
+  @autoreleasepool {
+    [[cocoaAction cocoaMenu] removeItem:action.p.cocoaAction];
+  }
+}
+
+void pMenu::setImage(const image& image) {
+  @autoreleasepool {
+    unsigned size = 15;  //there is no API to retrieve the optimal size
+    [cocoaAction setImage:NSMakeImage(image, size, size)];
+  }
+}
+
+void pMenu::setText(string text) {
+  @autoreleasepool {
+    [[cocoaAction cocoaMenu] setTitle:[NSString stringWithUTF8String:text]];
+    [cocoaAction setTitle:[NSString stringWithUTF8String:text]];
+  }
+}
+
+void pMenu::constructor() {
+  @autoreleasepool {
+    cocoaAction = cocoaMenu = [[CocoaMenu alloc] initWith:menu];
+    setText(menu.state.text);
+  }
+}
+
+void pMenu::destructor() {
+  @autoreleasepool {
+    [[cocoaAction cocoaMenu] release];
+    [cocoaAction release];
+  }
+}
+
+}
diff -Nru higan/phoenix/cocoa/action/menu.hpp nSide/phoenix/cocoa/action/menu.hpp
--- higan/phoenix/cocoa/action/menu.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/action/menu.hpp	2015-09-16 13:08:13.596563372 +0900
@@ -0,0 +1,26 @@
+@interface CocoaMenu : NSMenuItem {
+@public
+  phoenix::Menu* menu;
+  NSMenu* cocoaMenu;
+}
+-(id) initWith:(phoenix::Menu&)menu;
+-(NSMenu*) cocoaMenu;
+@end
+
+namespace phoenix {
+
+struct pMenu : public pAction {
+  Menu& menu;
+  CocoaMenu* cocoaMenu = nullptr;
+
+  void append(Action& action);
+  void remove(Action& action);
+  void setImage(const image& image);
+  void setText(string text);
+
+  pMenu(Menu& menu) : pAction(menu), menu(menu) {}
+  void constructor();
+  void destructor();
+};
+
+}
diff -Nru higan/phoenix/cocoa/action/radio-item.cpp nSide/phoenix/cocoa/action/radio-item.cpp
--- higan/phoenix/cocoa/action/radio-item.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/action/radio-item.cpp	2015-09-16 13:08:13.596563372 +0900
@@ -0,0 +1,53 @@
+@implementation CocoaRadioItem : NSMenuItem
+
+-(id) initWith:(phoenix::RadioItem&)radioItemReference {
+  if(self = [super initWithTitle:@"" action:@selector(activate) keyEquivalent:@""]) {
+    radioItem = &radioItemReference;
+
+    [self setTarget:self];
+    [self setOnStateImage:[NSImage imageNamed:@"NSMenuRadio"]];
+  }
+  return self;
+}
+
+-(void) activate {
+  radioItem->setChecked();
+  if(radioItem->onActivate) radioItem->onActivate();
+}
+
+@end
+
+namespace phoenix {
+
+void pRadioItem::setChecked() {
+  @autoreleasepool {
+    for(auto& item : radioItem.state.group) {
+      auto state = (&item == &radioItem) ? NSOnState : NSOffState;
+      [item.p.cocoaAction setState:state];
+    }
+  }
+}
+
+void pRadioItem::setGroup(const group<RadioItem>& group) {
+}
+
+void pRadioItem::setText(string text) {
+  @autoreleasepool {
+    [cocoaAction setTitle:[NSString stringWithUTF8String:text]];
+  }
+}
+
+void pRadioItem::constructor() {
+  @autoreleasepool {
+    cocoaAction = cocoaRadioItem = [[CocoaRadioItem alloc] initWith:radioItem];
+    setText(radioItem.state.text);
+  }
+}
+
+void pRadioItem::destructor() {
+  @autoreleasepool {
+    [cocoaAction release];
+  }
+}
+
+}
diff -Nru higan/phoenix/cocoa/action/radio-item.hpp nSide/phoenix/cocoa/action/radio-item.hpp
--- higan/phoenix/cocoa/action/radio-item.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/action/radio-item.hpp	2015-09-16 13:08:13.597563372 +0900
@@ -0,0 +1,24 @@
+@interface CocoaRadioItem : NSMenuItem {
+@public
+  phoenix::RadioItem* radioItem;
+}
+-(id) initWith:(phoenix::RadioItem&)radioItem;
+-(void) activate;
+@end
+
+namespace phoenix {
+
+struct pRadioItem : public pAction {
+  RadioItem& radioItem;
+  CocoaRadioItem* cocoaRadioItem = nullptr;
+
+  void setChecked();
+  void setGroup(const group<RadioItem>& group);
+  void setText(string text);
+
+  pRadioItem(RadioItem& radioItem) : pAction(radioItem), radioItem(radioItem) {}
+  void constructor();
+  void destructor();
+};
+
+}
diff -Nru higan/phoenix/cocoa/action/separator.cpp nSide/phoenix/cocoa/action/separator.cpp
--- higan/phoenix/cocoa/action/separator.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/action/separator.cpp	2015-09-16 13:08:13.596563372 +0900
@@ -0,0 +1,15 @@
+namespace phoenix {
+
+void pSeparator::constructor() {
+  @autoreleasepool {
+    cocoaAction = cocoaSeparator = [[NSMenuItem separatorItem] retain];
+  }
+}
+
+void pSeparator::destructor() {
+  @autoreleasepool {
+    [cocoaAction release];
+  }
+}
+
+}
diff -Nru higan/phoenix/cocoa/action/separator.hpp nSide/phoenix/cocoa/action/separator.hpp
--- higan/phoenix/cocoa/action/separator.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/action/separator.hpp	2015-09-16 13:08:13.597563372 +0900
@@ -0,0 +1,12 @@
+namespace phoenix {
+
+struct pSeparator : public pAction {
+  Separator& separator;
+  NSMenuItem* cocoaSeparator = nullptr;
+
+  pSeparator(Separator& separator) : pAction(separator), separator(separator) {}
+  void constructor();
+  void destructor();
+};
+
+}
diff -Nru higan/phoenix/cocoa/application.cpp nSide/phoenix/cocoa/application.cpp
--- higan/phoenix/cocoa/application.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/application.cpp	2015-09-16 13:08:13.606563373 +0900
@@ -0,0 +1,91 @@
+@implementation CocoaDelegate : NSObject
+
+-(NSApplicationTerminateReply) applicationShouldTerminate:(NSApplication*)sender {
+  using phoenix::Application;
+  if(Application::Cocoa::onQuit) Application::Cocoa::onQuit();
+  else Application::quit();
+  return NSTerminateCancel;
+}
+
+-(BOOL) applicationShouldHandleReopen:(NSApplication*)application hasVisibleWindows:(BOOL)flag {
+  using phoenix::Application;
+  if(Application::Cocoa::onActivate) Application::Cocoa::onActivate();
+  return NO;
+}
+
+-(void) run:(NSTimer*)timer {
+  using phoenix::Application;
+  if(Application::main) Application::main();
+}
+
+-(void) updateInDock:(NSTimer*)timer {
+  NSArray* windows = [NSApp windows];
+  for(unsigned n = 0; n < [windows count]; n++) {
+    NSWindow* window = [windows objectAtIndex:n];
+    if([window isMiniaturized]) {
+      [window updateInDock];
+    }
+  }
+}
+
+@end
+
+CocoaDelegate* cocoaDelegate = nullptr;
+
+namespace phoenix {
+
+void pApplication::run() {
+//NSTimer* timer = [NSTimer scheduledTimerWithTimeInterval:0.1667 target:cocoaDelegate selector:@selector(updateInDock:) userInfo:nil repeats:YES];
+
+  if(Application::main) {
+    NSTimer* timer = [NSTimer scheduledTimerWithTimeInterval:0.0 target:cocoaDelegate selector:@selector(run:) userInfo:nil repeats:YES];
+
+    //below line is needed to run application during window resize; however it has a large performance penalty on the resize smoothness
+    //[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSEventTrackingRunLoopMode];
+  }
+
+  @autoreleasepool {
+    [NSApp run];
+  }
+}
+
+bool pApplication::pendingEvents() {
+  bool result = false;
+  @autoreleasepool {
+    NSEvent* event = [NSApp nextEventMatchingMask:NSAnyEventMask untilDate:[NSDate distantPast] inMode:NSDefaultRunLoopMode dequeue:NO];
+    if(event != nil) result = true;
+  }
+  return result;
+}
+
+void pApplication::processEvents() {
+  @autoreleasepool {
+    while(applicationState.quit == false) {
+      NSEvent* event = [NSApp nextEventMatchingMask:NSAnyEventMask untilDate:[NSDate distantPast] inMode:NSDefaultRunLoopMode dequeue:YES];
+      if(event == nil) break;
+      [event retain];
+      [NSApp sendEvent:event];
+      [event release];
+    }
+  }
+}
+
+void pApplication::quit() {
+  @autoreleasepool {
+    [NSApp stop:nil];
+    NSEvent* event = [NSEvent otherEventWithType:NSApplicationDefined location:NSMakePoint(0, 0) modifierFlags:0 timestamp:0.0 windowNumber:0 context:nil subtype:0 data1:0 data2:0];
+    [NSApp postEvent:event atStart:true];
+  }
+}
+
+void pApplication::initialize() {
+  @autoreleasepool {
+    [NSApplication sharedApplication];
+    cocoaDelegate = [[CocoaDelegate alloc] init];
+    [NSApp setDelegate:cocoaDelegate];
+    //every window has the default application menu; call this so it is displayed at startup
+    [NSApp setMainMenu:[pWindow::none().p.cocoaWindow menu]];
+  }
+}
+
+}
diff -Nru higan/phoenix/cocoa/application.hpp nSide/phoenix/cocoa/application.hpp
--- higan/phoenix/cocoa/application.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/application.hpp	2015-09-16 13:08:13.617563374 +0900
@@ -0,0 +1,20 @@
+@interface CocoaDelegate : NSObject <NSApplicationDelegate> {
+}
+-(NSApplicationTerminateReply) applicationShouldTerminate:(NSApplication*)sender;
+-(BOOL) applicationShouldHandleReopen:(NSApplication*)application hasVisibleWindows:(BOOL)flag;
+-(void) run:(NSTimer*)timer;
+-(void) updateInDock:(NSTimer*)timer;
+@end
+
+namespace phoenix {
+
+struct pApplication {
+  static void run();
+  static bool pendingEvents();
+  static void processEvents();
+  static void quit();
+
+  static void initialize();
+};
+
+}
diff -Nru higan/phoenix/cocoa/browser-window.cpp nSide/phoenix/cocoa/browser-window.cpp
--- higan/phoenix/cocoa/browser-window.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/browser-window.cpp	2015-09-16 13:08:13.618563374 +0900
@@ -0,0 +1,69 @@
+namespace phoenix {
+
+string pBrowserWindow::directory(BrowserWindow::State& state) {
+  string result;
+
+  @autoreleasepool {
+    NSOpenPanel* panel = [NSOpenPanel openPanel];
+    if(state.title) [panel setTitle:[NSString stringWithUTF8String:state.title]];
+    [panel setCanChooseDirectories:YES];
+    [panel setCanChooseFiles:NO];
+    if([panel runModalForDirectory:[NSString stringWithUTF8String:state.path] file:nil] == NSOKButton) {
+      NSArray* names = [panel filenames];
+      const char* name = [[names objectAtIndex:0] UTF8String];
+      if(name) result = name;
+    }
+  }
+
+  return result;
+}
+
+string pBrowserWindow::open(BrowserWindow::State& state) {
+  string result;
+
+  @autoreleasepool {
+    NSMutableArray* filters = [[NSMutableArray alloc] init];
+    for(auto& rule : state.filters) {
+      string pattern = rule.split("(", 1L)(1).rtrim(")");
+      if(!pattern.empty()) [filters addObject:[NSString stringWithUTF8String:pattern]];
+    }
+    NSOpenPanel* panel = [NSOpenPanel openPanel];
+    if(state.title) [panel setTitle:[NSString stringWithUTF8String:state.title]];
+    [panel setCanChooseDirectories:NO];
+    [panel setCanChooseFiles:YES];
+    [panel setAllowedFileTypes:filters];
+    if([panel runModalForDirectory:[NSString stringWithUTF8String:state.path] file:nil] == NSOKButton) {
+      NSArray* names = [panel filenames];
+      const char* name = [[names objectAtIndex:0] UTF8String];
+      if(name) result = name;
+    }
+    [filters release];
+  }
+
+  return result;
+}
+
+string pBrowserWindow::save(BrowserWindow::State& state) {
+  string result;
+
+  @autoreleasepool {
+    NSMutableArray* filters = [[NSMutableArray alloc] init];
+    for(auto& rule : state.filters) {
+      string pattern = rule.split("(", 1L)(1).rtrim(")");
+      if(!pattern.empty()) [filters addObject:[NSString stringWithUTF8String:pattern]];
+    }
+    NSSavePanel* panel = [NSSavePanel savePanel];
+    if(state.title) [panel setTitle:[NSString stringWithUTF8String:state.title]];
+    [panel setAllowedFileTypes:filters];
+    if([panel runModalForDirectory:[NSString stringWithUTF8String:state.path] file:nil] == NSOKButton) {
+      NSArray* names = [panel filenames];
+      const char* name = [[names objectAtIndex:0] UTF8String];
+      if(name) result = name;
+    }
+    [filters release];
+  }
+
+  return result;
+}
+
+}
diff -Nru higan/phoenix/cocoa/browser-window.hpp nSide/phoenix/cocoa/browser-window.hpp
--- higan/phoenix/cocoa/browser-window.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/browser-window.hpp	2015-09-16 13:08:13.618563374 +0900
@@ -0,0 +1,9 @@
+namespace phoenix {
+
+struct pBrowserWindow {
+  static string directory(BrowserWindow::State& state);
+  static string open(BrowserWindow::State& state);
+  static string save(BrowserWindow::State& state);
+};
+
+}
diff -Nru higan/phoenix/cocoa/desktop.cpp nSide/phoenix/cocoa/desktop.cpp
--- higan/phoenix/cocoa/desktop.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/desktop.cpp	2015-09-16 13:08:13.595563372 +0900
@@ -0,0 +1,18 @@
+namespace phoenix {
+
+Size pDesktop::size() {
+  @autoreleasepool {
+    NSRect primary = [[[NSScreen screens] objectAtIndex:0] frame];
+    return {primary.size.width, primary.size.height};
+  }
+}
+
+Geometry pDesktop::workspace() {
+  @autoreleasepool {
+    auto screen = Desktop::size();
+    NSRect area = [[[NSScreen screens] objectAtIndex:0] visibleFrame];
+    return {area.origin.x, screen.height - area.size.height - area.origin.y, area.size.width, area.size.height};
+  }
+}
+
+}
diff -Nru higan/phoenix/cocoa/desktop.hpp nSide/phoenix/cocoa/desktop.hpp
--- higan/phoenix/cocoa/desktop.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/desktop.hpp	2015-09-16 13:08:13.618563374 +0900
@@ -0,0 +1,8 @@
+namespace phoenix {
+
+struct pDesktop {
+  static Size size();
+  static Geometry workspace();
+};
+
+}
diff -Nru higan/phoenix/cocoa/font.cpp nSide/phoenix/cocoa/font.cpp
--- higan/phoenix/cocoa/font.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/font.cpp	2015-09-16 13:08:13.605563373 +0900
@@ -0,0 +1,59 @@
+namespace phoenix {
+
+string pFont::serif(unsigned size, string style) {
+  if(size == 0) size = 8;
+  if(style == "") style = "Normal";
+  return {"Georgia, ", size, ", ", style};
+}
+
+string pFont::sans(unsigned size, string style) {
+  if(size == 0) size = 8;
+  if(style == "") style = "Normal";
+  return {"Lucida Grande, ", size, ", ", style};
+}
+
+string pFont::monospace(unsigned size, string style) {
+  if(size == 0) size = 8;
+  if(style == "") style = "Normal";
+  return {"Menlo, ", size, ", ", style};
+}
+
+Size pFont::size(string font, string text) {
+  @autoreleasepool {
+    if(NSFont* nsFont = cocoaFont(font)) {
+      return size(nsFont, text);
+    }
+  }
+  return {0, 0};
+}
+
+NSFont* pFont::cocoaFont(string description) {
+  lstring part = description.split(",", 2L).strip();
+
+  NSString* family = @"Lucida Grande";
+  NSFontTraitMask traits = 0;
+  CGFloat size = 8.0;
+
+  if(!part(0).empty()) family = [NSString stringWithUTF8String:part(0)];
+  if(!part(1).empty()) size = decimal(part(1));
+  if(part(2).ifind("bold")) traits |= NSBoldFontMask;
+  if(part(2).ifind("italic")) traits |= NSItalicFontMask;
+  if(part(2).ifind("narrow")) traits |= NSNarrowFontMask;
+  if(part(2).ifind("expanded")) traits |= NSExpandedFontMask;
+  if(part(2).ifind("condensed")) traits |= NSCondensedFontMask;
+  if(part(2).ifind("smallcaps")) traits |= NSSmallCapsFontMask;
+
+  size *= 1.5;  //scale to point sizes (for consistency with other operating systems)
+  return [[NSFontManager sharedFontManager] fontWithFamily:family traits:traits weight:5 size:size];
+}
+
+Size pFont::size(NSFont* font, string text) {
+  @autoreleasepool {
+    NSString* cocoaText = [NSString stringWithUTF8String:text];
+    NSDictionary* fontAttributes = [NSDictionary dictionaryWithObjectsAndKeys:font, NSFontAttributeName, nil];
+    NSSize size = [cocoaText sizeWithAttributes:fontAttributes];
+    return {size.width, size.height};
+  }
+}
+
+}
diff -Nru higan/phoenix/cocoa/font.hpp nSide/phoenix/cocoa/font.hpp
--- higan/phoenix/cocoa/font.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/font.hpp	2015-09-16 13:08:13.597563372 +0900
@@ -0,0 +1,13 @@
+namespace phoenix {
+
+struct pFont {
+  static string serif(unsigned size, string style);
+  static string sans(unsigned size, string style);
+  static string monospace(unsigned size, string style);
+  static Size size(string font, string text);
+
+  static NSFont* cocoaFont(string description);
+  static Size size(NSFont* font, string text);
+};
+
+}
diff -Nru higan/phoenix/cocoa/header.hpp nSide/phoenix/cocoa/header.hpp
--- higan/phoenix/cocoa/header.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/header.hpp	2015-09-16 13:08:13.606563373 +0900
@@ -0,0 +1,4 @@
+#define decimal CocoaDecimal
+#import <Cocoa/Cocoa.h>
+#import <Carbon/Carbon.h>
+#undef decimal
diff -Nru higan/phoenix/cocoa/keyboard.cpp nSide/phoenix/cocoa/keyboard.cpp
--- higan/phoenix/cocoa/keyboard.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/keyboard.cpp	2015-09-16 13:08:13.618563374 +0900
@@ -0,0 +1,14 @@
+namespace phoenix {
+
+bool pKeyboard::pressed(Keyboard::Scancode scancode) {
+  return false;
+}
+
+vector<bool> pKeyboard::state() {
+  vector<bool> output;
+  output.resize((unsigned)Keyboard::Scancode::Limit);
+  for(auto& n : output) n = false;
+  return output;
+}
+
+}
diff -Nru higan/phoenix/cocoa/keyboard.hpp nSide/phoenix/cocoa/keyboard.hpp
--- higan/phoenix/cocoa/keyboard.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/keyboard.hpp	2015-09-16 13:08:13.618563374 +0900
@@ -0,0 +1,8 @@
+namespace phoenix {
+
+struct pKeyboard {
+  static bool pressed(Keyboard::Scancode scancode);
+  static vector<bool> state();
+};
+
+}
diff -Nru higan/phoenix/cocoa/message-window.cpp nSide/phoenix/cocoa/message-window.cpp
--- higan/phoenix/cocoa/message-window.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/message-window.cpp	2015-09-16 13:08:13.606563373 +0900
@@ -0,0 +1,79 @@
+namespace phoenix {
+
+enum class MessageWindowType : unsigned { Error, Information, Question, Warning };
+
+MessageWindow::Response MessageWindow_dialog(MessageWindow::State& state, MessageWindowType type) {
+  @autoreleasepool {
+    NSAlert* alert = [[[NSAlert alloc] init] autorelease];
+    if(state.title) [alert setMessageText:[NSString stringWithUTF8String:state.title]];
+    [alert setInformativeText:[NSString stringWithUTF8String:state.text]];
+
+    switch(state.buttons) {
+    case MessageWindow::Buttons::Ok:
+      [alert addButtonWithTitle:@"Ok"];
+      break;
+    case MessageWindow::Buttons::OkCancel:
+      [alert addButtonWithTitle:@"Ok"];
+      [alert addButtonWithTitle:@"Cancel"];
+      break;
+    case MessageWindow::Buttons::YesNo:
+      [alert addButtonWithTitle:@"Yes"];
+      [alert addButtonWithTitle:@"No"];
+      break;
+    case MessageWindow::Buttons::YesNoCancel:
+      [alert addButtonWithTitle:@"Yes"];
+      [alert addButtonWithTitle:@"No"];
+      [alert addButtonWithTitle:@"Cancel"];
+      break;
+    }
+
+    switch(type) {
+    case MessageWindowType::Error: [alert setAlertStyle:NSCriticalAlertStyle]; break;
+    case MessageWindowType::Information: [alert setAlertStyle:NSInformationalAlertStyle]; break;
+    case MessageWindowType::Question: [alert setAlertStyle:NSInformationalAlertStyle]; break;
+    case MessageWindowType::Warning: [alert setAlertStyle:NSWarningAlertStyle]; break;
+    }
+
+    NSInteger response = [alert runModal];
+  //[alert beginSheetModalForWindow:parent.p.cocoaWindow modalDelegate:self didEndSelector:@selector(...) contextInfo:nil];
+
+    switch(state.buttons) {
+    case MessageWindow::Buttons::Ok:
+      if(response == NSAlertFirstButtonReturn) return MessageWindow::Response::Ok;
+      break;
+    case MessageWindow::Buttons::OkCancel:
+      if(response == NSAlertFirstButtonReturn) return MessageWindow::Response::Ok;
+      if(response == NSAlertSecondButtonReturn) return MessageWindow::Response::Cancel;
+      break;
+    case MessageWindow::Buttons::YesNo:
+      if(response == NSAlertFirstButtonReturn) return MessageWindow::Response::Yes;
+      if(response == NSAlertSecondButtonReturn) return MessageWindow::Response::No;
+      break;
+    case MessageWindow::Buttons::YesNoCancel:
+      if(response == NSAlertFirstButtonReturn) return MessageWindow::Response::Yes;
+      if(response == NSAlertSecondButtonReturn) return MessageWindow::Response::No;
+      if(response == NSAlertThirdButtonReturn) return MessageWindow::Response::Cancel;
+      break;
+    }
+  }
+
+  throw;
+}
+
+MessageWindow::Response pMessageWindow::error(MessageWindow::State& state) {
+  return MessageWindow_dialog(state, MessageWindowType::Error);
+}
+
+MessageWindow::Response pMessageWindow::information(MessageWindow::State& state) {
+  return MessageWindow_dialog(state, MessageWindowType::Information);
+}
+
+MessageWindow::Response pMessageWindow::question(MessageWindow::State& state) {
+  return MessageWindow_dialog(state, MessageWindowType::Question);
+}
+
+MessageWindow::Response pMessageWindow::warning(MessageWindow::State& state) {
+  return MessageWindow_dialog(state, MessageWindowType::Warning);
+}
+
+}
diff -Nru higan/phoenix/cocoa/message-window.hpp nSide/phoenix/cocoa/message-window.hpp
--- higan/phoenix/cocoa/message-window.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/message-window.hpp	2015-09-16 13:08:13.618563374 +0900
@@ -0,0 +1,10 @@
+namespace phoenix {
+
+struct pMessageWindow {
+  static MessageWindow::Response error(MessageWindow::State& state);
+  static MessageWindow::Response information(MessageWindow::State& state);
+  static MessageWindow::Response question(MessageWindow::State& state);
+  static MessageWindow::Response warning(MessageWindow::State& state);
+};
+
+}
diff -Nru higan/phoenix/cocoa/monitor.cpp nSide/phoenix/cocoa/monitor.cpp
--- higan/phoenix/cocoa/monitor.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/monitor.cpp	2015-09-16 13:08:13.619563374 +0900
@@ -0,0 +1,21 @@
+namespace phoenix {
+
+unsigned pMonitor::count() {
+  @autoreleasepool {
+    return [[NSScreen screens] count];
+  }
+}
+
+Geometry pMonitor::geometry(unsigned monitor) {
+  @autoreleasepool {
+    NSRect rectangle = [[[NSScreen screens] objectAtIndex:monitor] frame];
+    return {rectangle.origin.x, rectangle.origin.y, rectangle.size.width, rectangle.size.height};
+  }
+}
+
+unsigned pMonitor::primary() {
+  //on OS X, the primary monitor is always the first monitor
+  return 0;
+}
+
+}
diff -Nru higan/phoenix/cocoa/monitor.hpp nSide/phoenix/cocoa/monitor.hpp
--- higan/phoenix/cocoa/monitor.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/monitor.hpp	2015-09-16 13:08:13.596563372 +0900
@@ -0,0 +1,9 @@
+namespace phoenix {
+
+struct pMonitor {
+  static unsigned count();
+  static Geometry geometry(unsigned monitor);
+  static unsigned primary();
+};
+
+}
diff -Nru higan/phoenix/cocoa/mouse.cpp nSide/phoenix/cocoa/mouse.cpp
--- higan/phoenix/cocoa/mouse.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/mouse.cpp	2015-09-16 13:08:13.606563373 +0900
@@ -0,0 +1,11 @@
+namespace phoenix {
+
+Position pMouse::position() {
+  return {0, 0};
+}
+
+bool pMouse::pressed(Mouse::Button button) {
+  return false;
+}
+
+}
diff -Nru higan/phoenix/cocoa/mouse.hpp nSide/phoenix/cocoa/mouse.hpp
--- higan/phoenix/cocoa/mouse.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/mouse.hpp	2015-09-16 13:08:13.606563373 +0900
@@ -0,0 +1,8 @@
+namespace phoenix {
+
+struct pMouse {
+  static Position position();
+  static bool pressed(Mouse::Button button);
+};
+
+}
diff -Nru higan/phoenix/cocoa/object.cpp nSide/phoenix/cocoa/object.cpp
--- higan/phoenix/cocoa/object.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/object.cpp	2015-09-16 13:08:13.595563372 +0900
@@ -0,0 +1,9 @@
+namespace phoenix {
+
+void pObject::constructor() {
+}
+
+void pObject::destructor() {
+}
+
+}
diff -Nru higan/phoenix/cocoa/object.hpp nSide/phoenix/cocoa/object.hpp
--- higan/phoenix/cocoa/object.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/object.hpp	2015-09-16 13:08:13.597563372 +0900
@@ -0,0 +1,14 @@
+namespace phoenix {
+
+struct pObject {
+  Object& object;
+  bool locked;
+
+  pObject(Object& object) : object(object), locked(false) {}
+  virtual ~pObject() {}
+
+  void constructor();
+  void destructor();
+};
+
+}
diff -Nru higan/phoenix/cocoa/platform.cpp nSide/phoenix/cocoa/platform.cpp
--- higan/phoenix/cocoa/platform.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/platform.cpp	2015-09-16 13:08:13.618563374 +0900
@@ -0,0 +1,45 @@
+#include "platform.hpp"
+#include "utility.cpp"
+
+#include "font.cpp"
+#include "desktop.cpp"
+#include "monitor.cpp"
+#include "keyboard.cpp"
+#include "mouse.cpp"
+#include "browser-window.cpp"
+#include "message-window.cpp"
+#include "object.cpp"
+#include "timer.cpp"
+#include "window.cpp"
+
+#include "action/action.cpp"
+#include "action/menu.cpp"
+#include "action/separator.cpp"
+#include "action/item.cpp"
+#include "action/check-item.cpp"
+#include "action/radio-item.cpp"
+
+#include "widget/widget.cpp"
+#include "widget/button.cpp"
+#include "widget/canvas.cpp"
+#include "widget/check-button.cpp"
+#include "widget/check-label.cpp"
+#include "widget/combo-button.cpp"
+#include "widget/console.cpp"
+#include "widget/frame.cpp"
+#include "widget/hex-edit.cpp"
+#include "widget/horizontal-scroller.cpp"
+#include "widget/horizontal-slider.cpp"
+#include "widget/label.cpp"
+#include "widget/line-edit.cpp"
+#include "widget/list-view.cpp"
+#include "widget/progress-bar.cpp"
+#include "widget/radio-button.cpp"
+#include "widget/radio-label.cpp"
+#include "widget/tab-frame.cpp"
+#include "widget/text-edit.cpp"
+#include "widget/vertical-scroller.cpp"
+#include "widget/vertical-slider.cpp"
+#include "widget/viewport.cpp"
+
+#include "application.cpp"
diff -Nru higan/phoenix/cocoa/platform.hpp nSide/phoenix/cocoa/platform.hpp
--- higan/phoenix/cocoa/platform.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/platform.hpp	2015-09-16 13:08:13.597563372 +0900
@@ -0,0 +1,52 @@
+namespace phoenix {
+  struct pFont;
+  struct pWindow;
+  struct pMenu;
+  struct pLayout;
+  struct pWidget;
+}
+
+#include "font.hpp"
+#include "desktop.hpp"
+#include "monitor.hpp"
+#include "keyboard.hpp"
+#include "mouse.hpp"
+#include "browser-window.hpp"
+#include "message-window.hpp"
+#include "object.hpp"
+#include "timer.hpp"
+#include "window.hpp"
+
+#include "action/action.hpp"
+#include "action/menu.hpp"
+#include "action/separator.hpp"
+#include "action/item.hpp"
+#include "action/check-item.hpp"
+#include "action/radio-item.hpp"
+
+#include "widget/sizable.hpp"
+#include "widget/layout.hpp"
+#include "widget/widget.hpp"
+#include "widget/button.hpp"
+#include "widget/canvas.hpp"
+#include "widget/check-button.hpp"
+#include "widget/check-label.hpp"
+#include "widget/combo-button.hpp"
+#include "widget/console.hpp"
+#include "widget/frame.hpp"
+#include "widget/hex-edit.hpp"
+#include "widget/horizontal-scroller.hpp"
+#include "widget/horizontal-slider.hpp"
+#include "widget/label.hpp"
+#include "widget/line-edit.hpp"
+#include "widget/list-view.hpp"
+#include "widget/progress-bar.hpp"
+#include "widget/radio-button.hpp"
+#include "widget/radio-label.hpp"
+#include "widget/tab-frame.hpp"
+#include "widget/text-edit.hpp"
+#include "widget/vertical-scroller.hpp"
+#include "widget/vertical-slider.hpp"
+#include "widget/viewport.hpp"
+
+#include "application.hpp"
diff -Nru higan/phoenix/cocoa/timer.cpp nSide/phoenix/cocoa/timer.cpp
--- higan/phoenix/cocoa/timer.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/timer.cpp	2015-09-16 13:08:13.606563373 +0900
@@ -0,0 +1,60 @@
+@implementation CocoaTimer : NSObject
+
+-(id) initWith:(phoenix::Timer&)timerReference {
+  if(self = [super init]) {
+    timer = &timerReference;
+    instance = nil;
+  }
+  return self;
+}
+
+-(NSTimer*) instance {
+  return instance;
+}
+
+-(void) update {
+  if(instance) {
+    [instance invalidate];
+    instance = nil;
+  }
+  if(timer->state.enabled == false) return;
+  instance = [NSTimer
+    scheduledTimerWithTimeInterval:timer->state.interval / 1000.0
+    target:self selector:@selector(run:) userInfo:nil repeats:YES
+  ];
+}
+
+-(void) run:(NSTimer*)instance {
+  if(timer->onActivate) timer->onActivate();
+}
+
+@end
+
+namespace phoenix {
+
+void pTimer::setEnabled(bool enabled) {
+  @autoreleasepool {
+    [cocoaTimer update];
+  }
+}
+
+void pTimer::setInterval(unsigned interval) {
+  @autoreleasepool {
+    [cocoaTimer update];
+  }
+}
+
+void pTimer::constructor() {
+  @autoreleasepool {
+    cocoaTimer = [[CocoaTimer alloc] initWith:timer];
+  }
+}
+
+void pTimer::destructor() {
+  @autoreleasepool {
+    if([cocoaTimer instance]) [[cocoaTimer instance] invalidate];
+    [cocoaTimer release];
+  }
+}
+
+}
diff -Nru higan/phoenix/cocoa/timer.hpp nSide/phoenix/cocoa/timer.hpp
--- higan/phoenix/cocoa/timer.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/timer.hpp	2015-09-16 13:08:13.597563372 +0900
@@ -0,0 +1,26 @@
+@interface CocoaTimer : NSObject {
+@public
+  phoenix::Timer* timer;
+  NSTimer* instance;
+}
+-(id) initWith:(phoenix::Timer&)timer;
+-(NSTimer*) instance;
+-(void) update;
+-(void) run:(NSTimer*)instance;
+@end
+
+namespace phoenix {
+
+struct pTimer : public pObject {
+  Timer& timer;
+  CocoaTimer* cocoaTimer = nullptr;
+
+  void setEnabled(bool enabled);
+  void setInterval(unsigned interval);
+
+  pTimer(Timer& timer) : pObject(timer), timer(timer) {}
+  void constructor();
+  void destructor();
+};
+
+}
diff -Nru higan/phoenix/cocoa/utility.cpp nSide/phoenix/cocoa/utility.cpp
--- higan/phoenix/cocoa/utility.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/utility.cpp	2015-09-16 13:08:13.618563374 +0900
@@ -0,0 +1,41 @@
+NSImage* NSMakeImage(nall::image image, unsigned width = 0, unsigned height = 0) {
+  if(image.empty()) return nil;
+  if(width && height) image.scale(width, height, Interpolation::Linear);
+  image.transform(0, 32, 255u << 24, 255u << 0, 255u << 8, 255u << 16);
+  NSImage* cocoaImage = [[[NSImage alloc] initWithSize:NSMakeSize(image.width(), image.height())] autorelease];
+  NSBitmapImageRep* bitmap = [[[NSBitmapImageRep alloc]
+    initWithBitmapDataPlanes:nil
+    pixelsWide:image.width() pixelsHigh:image.height()
+    bitsPerSample:8 samplesPerPixel:4 hasAlpha:YES
+    isPlanar:NO colorSpaceName:NSCalibratedRGBColorSpace
+    bitmapFormat:NSAlphaNonpremultipliedBitmapFormat
+    bytesPerRow:image.pitch bitsPerPixel:32
+  ] autorelease];
+  memcpy([bitmap bitmapData], image.data(), image.height() * image.pitch);
+  [cocoaImage addRepresentation:bitmap];
+  return cocoaImage;
+}
+
+NSDragOperation DropPathsOperation(id<NSDraggingInfo> sender) {
+  NSPasteboard* pboard = [sender draggingPasteboard];
+  if([[pboard types] containsObject:NSFilenamesPboardType]) {
+    if([sender draggingSourceOperationMask] & NSDragOperationGeneric) {
+      return NSDragOperationGeneric;
+    }
+  }
+  return NSDragOperationNone;
+}
+
+lstring DropPaths(id<NSDraggingInfo> sender) {
+  lstring paths;
+  NSPasteboard* pboard = [sender draggingPasteboard];
+  if([[pboard types] containsObject:NSFilenamesPboardType]) {
+    NSArray* files = [pboard propertyListForType:NSFilenamesPboardType];
+    for(unsigned n = 0; n < [files count]; n++) {
+      string path = [[files objectAtIndex:n] UTF8String];
+      if(directory::exists(path) && !path.endsWith("/")) path.append("/");
+      paths.append(path);
+    }
+  }
+  return paths;
+}
diff -Nru higan/phoenix/cocoa/widget/button.cpp nSide/phoenix/cocoa/widget/button.cpp
--- higan/phoenix/cocoa/widget/button.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/widget/button.cpp	2015-09-16 13:08:13.598563372 +0900
@@ -0,0 +1,80 @@
+@implementation CocoaButton : NSButton
+
+-(id) initWith:(phoenix::Button&)buttonReference {
+  if(self = [super initWithFrame:NSMakeRect(0, 0, 0, 0)]) {
+    button = &buttonReference;
+    [self setTarget:self];
+    [self setAction:@selector(activate:)];
+    //NSRoundedBezelStyle has a fixed height; which breaks both icons and larger/smaller text
+    [self setBezelStyle:NSRegularSquareBezelStyle];
+  }
+  return self;
+}
+
+-(IBAction) activate:(id)sender {
+  if(button->onActivate) button->onActivate();
+}
+
+@end
+
+namespace phoenix {
+
+Size pButton::minimumSize() {
+  Size size = Font::size(button.font(), button.state.text);
+
+  if(button.state.orientation == Orientation::Horizontal) {
+    size.width += button.state.image.width();
+    size.height = max(button.state.image.height(), size.height);
+  }
+
+  if(button.state.orientation == Orientation::Vertical) {
+    size.width = max(button.state.image.width(), size.width);
+    size.height += button.state.image.height();
+  }
+
+  return {size.width + (button.state.text ? 20 : 4), size.height + 4};
+}
+
+void pButton::setBordered(bool bordered) {
+}
+
+void pButton::setGeometry(Geometry geometry) {
+  pWidget::setGeometry({
+    geometry.x - 2, geometry.y - 2,
+    geometry.width + 4, geometry.height + 4
+  });
+}
+
+void pButton::setImage(const image& image, Orientation orientation) {
+  @autoreleasepool {
+    if(image.empty()) {
+      [cocoaView setImage:nil];
+      return;
+    }
+
+    [cocoaView setImage:NSMakeImage(image)];
+
+    if(orientation == Orientation::Horizontal) [cocoaView setImagePosition:NSImageLeft];
+    if(orientation == Orientation::Vertical  ) [cocoaView setImagePosition:NSImageAbove];
+  }
+}
+
+void pButton::setText(string text) {
+  @autoreleasepool {
+    [cocoaView setTitle:[NSString stringWithUTF8String:text]];
+  }
+}
+
+void pButton::constructor() {
+  @autoreleasepool {
+    cocoaView = cocoaButton = [[CocoaButton alloc] initWith:button];
+  }
+}
+
+void pButton::destructor() {
+  @autoreleasepool {
+    [cocoaView release];
+  }
+}
+
+}
diff -Nru higan/phoenix/cocoa/widget/button.hpp nSide/phoenix/cocoa/widget/button.hpp
--- higan/phoenix/cocoa/widget/button.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/widget/button.hpp	2015-09-16 13:08:13.598563372 +0900
@@ -0,0 +1,26 @@
+@interface CocoaButton : NSButton {
+@public
+  phoenix::Button* button;
+}
+-(id) initWith:(phoenix::Button&)button;
+-(IBAction) activate:(id)sender;
+@end
+
+namespace phoenix {
+
+struct pButton : public pWidget {
+  Button& button;
+  CocoaButton* cocoaButton = nullptr;
+
+  Size minimumSize();
+  void setBordered(bool bordered);
+  void setGeometry(Geometry geometry);
+  void setImage(const image& image, Orientation orientation);
+  void setText(string text);
+
+  pButton(Button& button) : pWidget(button), button(button) {}
+  void constructor();
+  void destructor();
+};
+
+}
diff -Nru higan/phoenix/cocoa/widget/canvas.cpp nSide/phoenix/cocoa/widget/canvas.cpp
--- higan/phoenix/cocoa/widget/canvas.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/widget/canvas.cpp	2015-09-16 13:08:13.599563372 +0900
@@ -0,0 +1,214 @@
+@implementation CocoaCanvas : NSImageView
+
+-(id) initWith:(phoenix::Canvas&)canvasReference {
+  if(self = [super initWithFrame:NSMakeRect(0, 0, 0, 0)]) {
+    canvas = &canvasReference;
+    [self setEditable:NO];  //disable image drag-and-drop functionality
+    NSTrackingArea* area = [[[NSTrackingArea alloc] initWithRect:[self frame]
+      options:NSTrackingMouseMoved | NSTrackingMouseEnteredAndExited | NSTrackingActiveInKeyWindow | NSTrackingInVisibleRect
+      owner:self userInfo:nil
+    ] autorelease];
+    [self addTrackingArea:area];
+  }
+  return self;
+}
+
+-(NSDragOperation) draggingEntered:(id<NSDraggingInfo>)sender {
+  return DropPathsOperation(sender);
+}
+
+-(BOOL) performDragOperation:(id<NSDraggingInfo>)sender {
+  lstring paths = DropPaths(sender);
+  if(paths.empty()) return NO;
+  if(canvas->onDrop) canvas->onDrop(paths);
+  return YES;
+}
+
+-(void) mouseButton:(NSEvent*)event down:(BOOL)isDown {
+  if(auto& callback = isDown ? canvas->onMousePress : canvas->onMouseRelease) {
+    switch([event buttonNumber]) {
+    case 0: return callback(phoenix::Mouse::Button::Left);
+    case 1: return callback(phoenix::Mouse::Button::Right);
+    case 2: return callback(phoenix::Mouse::Button::Middle);
+    }
+  }
+}
+
+-(void) mouseExited:(NSEvent*)event {
+  if(canvas->onMouseLeave) canvas->onMouseLeave();
+}
+
+-(void) mouseMove:(NSEvent*)event {
+  if([event window] == nil) return;
+  NSPoint location = [self convertPoint:[event locationInWindow] fromView:nil];
+  if(canvas->onMouseMove) canvas->onMouseMove({location.x, [self frame].size.height - 1 - location.y});
+}
+
+-(void) mouseDown:(NSEvent*)event {
+  [self mouseButton:event down:YES];
+}
+
+-(void) mouseUp:(NSEvent*)event {
+  [self mouseButton:event down:NO];
+}
+
+-(void) mouseDragged:(NSEvent*)event {
+  [self mouseMove:event];
+}
+
+-(void) rightMouseDown:(NSEvent*)event {
+  [self mouseButton:event down:YES];
+}
+
+-(void) rightMouseUp:(NSEvent*)event {
+  [self mouseButton:event down:NO];
+}
+
+-(void) rightMouseDragged:(NSEvent*)event {
+  [self mouseMove:event];
+}
+
+-(void) otherMouseDown:(NSEvent*)event {
+  [self mouseButton:event down:YES];
+}
+
+-(void) otherMouseUp:(NSEvent*)event {
+  [self mouseButton:event down:NO];
+}
+
+-(void) otherMouseDragged:(NSEvent*)event {
+  [self mouseMove:event];
+}
+
+@end
+
+namespace phoenix {
+
+void pCanvas::setDroppable(bool droppable) {
+  @autoreleasepool {
+    if(droppable) {
+      [cocoaCanvas registerForDraggedTypes:[NSArray arrayWithObject:NSFilenamesPboardType]];
+    } else {
+      [cocoaCanvas unregisterDraggedTypes];
+    }
+  }
+}
+
+void pCanvas::setGeometry(Geometry geometry) {
+  if(canvas.state.width == 0 || canvas.state.height == 0) rasterize();
+
+  unsigned width = canvas.state.width;
+  unsigned height = canvas.state.height;
+  if(width == 0) width = widget.state.geometry.width;
+  if(height == 0) height = widget.state.geometry.height;
+
+  if(width < geometry.width) {
+    geometry.x += (geometry.width - width) / 2;
+    geometry.width = width;
+  }
+
+  if(height < geometry.height) {
+    geometry.y += (geometry.height - height) / 2;
+    geometry.height = height;
+  }
+
+  pWidget::setGeometry(geometry);
+}
+
+void pCanvas::setMode(Canvas::Mode mode) {
+  rasterize(), redraw();
+}
+
+void pCanvas::setSize(Size size) {
+  rasterize(), redraw();
+}
+
+void pCanvas::constructor() {
+  @autoreleasepool {
+    cocoaView = cocoaCanvas = [[CocoaCanvas alloc] initWith:canvas];
+  }
+  setSize(canvas.size());
+}
+
+void pCanvas::destructor() {
+  @autoreleasepool {
+    [cocoaView release];
+  }
+}
+
+void pCanvas::rasterize() {
+  @autoreleasepool {
+    unsigned width = canvas.state.width;
+    unsigned height = canvas.state.height;
+    if(width == 0) width = widget.state.geometry.width;
+    if(height == 0) height = widget.state.geometry.height;
+
+    if(width != surfaceWidth || height != surfaceHeight) {
+      NSImage* image = [[[NSImage alloc] initWithSize:NSMakeSize(width, height)] autorelease];
+      NSBitmapImageRep* bitmap = [[[NSBitmapImageRep alloc]
+        initWithBitmapDataPlanes:nil
+        pixelsWide:width pixelsHigh:height
+        bitsPerSample:8 samplesPerPixel:4 hasAlpha:YES
+        isPlanar:NO colorSpaceName:NSCalibratedRGBColorSpace
+        bitmapFormat:NSAlphaNonpremultipliedBitmapFormat
+        bytesPerRow:width * 4 bitsPerPixel:32
+      ] autorelease];
+
+      [image addRepresentation:bitmap];
+      [cocoaView setImage:image];
+
+      surfaceWidth = width;
+      surfaceHeight = height;
+    }
+
+    if(NSBitmapImageRep* bitmap = [[[cocoaView image] representations] objectAtIndex:0]) {
+      uint32_t* target = (uint32_t*)[bitmap bitmapData];
+
+      if(canvas.state.mode == Canvas::Mode::Color) {
+        nall::image image;
+        image.allocate(width, height);
+        image.fill(canvas.state.color.argb());
+        memcpy(target, image.data(), image.size());
+      }
+
+      if(canvas.state.mode == Canvas::Mode::Gradient) {
+        nall::image image;
+        image.allocate(width, height);
+        image.gradient(
+          canvas.state.gradient[0].argb(), canvas.state.gradient[1].argb(), canvas.state.gradient[2].argb(), canvas.state.gradient[3].argb()
+        );
+        memcpy(target, image.data(), image.size());
+      }
+
+      if(canvas.state.mode == Canvas::Mode::Image) {
+        nall::image image = canvas.state.image;
+        image.scale(width, height);
+        image.transform(0, 32, 255u << 24, 255u << 16, 255u << 8, 255u << 0);
+        memcpy(target, image.data(), image.size());
+      }
+
+      if(canvas.state.mode == Canvas::Mode::Data) {
+        if(width == canvas.state.width && height == canvas.state.height) {
+          memcpy(target, canvas.state.data, width * height * sizeof(uint32_t));
+        } else {
+          memset(target, 0x00, width * height * sizeof(uint32_t));
+        }
+      }
+
+     //ARGB -> ABGR transformation
+      for(unsigned n = 0; n < width * height; n++) {
+        uint32_t color = *target;
+        color = (color & 0xff00ff00) | ((color & 0xff0000) >> 16) | ((color & 0x0000ff) << 16);
+        *target++ = color;
+      }
+    }
+  }
+}
+
+void pCanvas::redraw() {
+  @autoreleasepool {
+    [cocoaView setNeedsDisplay:YES];
+  }
+}
+
+}
diff -Nru higan/phoenix/cocoa/widget/canvas.hpp nSide/phoenix/cocoa/widget/canvas.hpp
--- higan/phoenix/cocoa/widget/canvas.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/widget/canvas.hpp	2015-09-16 13:08:13.600563372 +0900
@@ -0,0 +1,42 @@
+@interface CocoaCanvas : NSImageView {
+@public
+  phoenix::Canvas* canvas;
+}
+-(id) initWith:(phoenix::Canvas&)canvas;
+-(NSDragOperation) draggingEntered:(id<NSDraggingInfo>)sender;
+-(BOOL) performDragOperation:(id<NSDraggingInfo>)sender;
+-(void) mouseButton:(NSEvent*)event down:(BOOL)isDown;
+-(void) mouseExited:(NSEvent*)event;
+-(void) mouseMove:(NSEvent*)event;
+-(void) mouseDown:(NSEvent*)event;
+-(void) mouseUp:(NSEvent*)event;
+-(void) mouseDragged:(NSEvent*)event;
+-(void) rightMouseDown:(NSEvent*)event;
+-(void) rightMouseUp:(NSEvent*)event;
+-(void) rightMouseDragged:(NSEvent*)event;
+-(void) otherMouseDown:(NSEvent*)event;
+-(void) otherMouseUp:(NSEvent*)event;
+-(void) otherMouseDragged:(NSEvent*)event;
+@end
+
+namespace phoenix {
+
+struct pCanvas : public pWidget {
+  Canvas& canvas;
+  CocoaCanvas* cocoaCanvas = nullptr;
+  unsigned surfaceWidth = 0;
+  unsigned surfaceHeight = 0;
+
+  void setDroppable(bool droppable);
+  void setGeometry(Geometry geometry);
+  void setMode(Canvas::Mode mode);
+  void setSize(Size size);
+
+  pCanvas(Canvas& canvas) : pWidget(canvas), canvas(canvas) {}
+  void constructor();
+  void destructor();
+  void rasterize();
+  void redraw();
+};
+
+}
diff -Nru higan/phoenix/cocoa/widget/check-button.cpp nSide/phoenix/cocoa/widget/check-button.cpp
--- higan/phoenix/cocoa/widget/check-button.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/widget/check-button.cpp	2015-09-16 13:08:13.599563372 +0900
@@ -0,0 +1,85 @@
+@implementation CocoaCheckButton : NSButton
+
+-(id) initWith:(phoenix::CheckButton&)checkButtonReference {
+  if(self = [super initWithFrame:NSMakeRect(0, 0, 0, 0)]) {
+    checkButton = &checkButtonReference;
+
+    [self setTarget:self];
+    [self setAction:@selector(activate:)];
+    [self setBezelStyle:NSRegularSquareBezelStyle];
+    [self setButtonType:NSOnOffButton];
+  }
+  return self;
+}
+
+-(IBAction) activate:(id)sender {
+  checkButton->state.checked = [self state] != NSOffState;
+  if(checkButton->onToggle) checkButton->onToggle();
+}
+
+@end
+
+namespace phoenix {
+
+Size pCheckButton::minimumSize() {
+  Size size = Font::size(checkButton.font(), checkButton.state.text);
+
+  if(checkButton.state.orientation == Orientation::Horizontal) {
+    size.width += checkButton.state.image.width();
+    size.height = max(checkButton.state.image.height(), size.height);
+  }
+
+  if(checkButton.state.orientation == Orientation::Vertical) {
+    size.width = max(checkButton.state.image.width(), size.width);
+    size.height += checkButton.state.image.height();
+  }
+
+  return {size.width + 20, size.height + 4};
+}
+
+void pCheckButton::setChecked(bool checked) {
+  @autoreleasepool {
+    [cocoaView setState:checked ? NSOnState : NSOffState];
+  }
+}
+
+void pCheckButton::setGeometry(Geometry geometry) {
+  pWidget::setGeometry({
+    geometry.x - 2, geometry.y - 2,
+    geometry.width + 4, geometry.height + 4
+  });
+}
+
+void pCheckButton::setImage(const image& image, Orientation orientation) {
+  @autoreleasepool {
+    if(image.empty()) {
+      [cocoaView setImage:nil];
+      return;
+    }
+
+    [cocoaView setImage:NSMakeImage(image)];
+
+    if(orientation == Orientation::Horizontal) [cocoaView setImagePosition:NSImageLeft];
+    if(orientation == Orientation::Vertical  ) [cocoaView setImagePosition:NSImageAbove];
+  }
+}
+
+void pCheckButton::setText(string text) {
+  @autoreleasepool {
+    [cocoaView setTitle:[NSString stringWithUTF8String:text]];
+  }
+}
+
+void pCheckButton::constructor() {
+  @autoreleasepool {
+    cocoaView = cocoaCheckButton = [[CocoaCheckButton alloc] initWith:checkButton];
+  }
+}
+
+void pCheckButton::destructor() {
+  @autoreleasepool {
+    [cocoaView release];
+  }
+}
+
+}
diff -Nru higan/phoenix/cocoa/widget/check-button.hpp nSide/phoenix/cocoa/widget/check-button.hpp
--- higan/phoenix/cocoa/widget/check-button.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/widget/check-button.hpp	2015-09-16 13:08:13.598563372 +0900
@@ -0,0 +1,26 @@
+@interface CocoaCheckButton : NSButton {
+@public
+  phoenix::CheckButton* checkButton;
+}
+-(id) initWith:(phoenix::CheckButton&)checkButton;
+-(IBAction) activate:(id)sender;
+@end
+
+namespace phoenix {
+
+struct pCheckButton : public pWidget {
+  CheckButton& checkButton;
+  CocoaCheckButton* cocoaCheckButton = nullptr;
+
+  Size minimumSize();
+  void setChecked(bool checked);
+  void setGeometry(Geometry geometry);
+  void setImage(const image& image, Orientation orientation);
+  void setText(string text);
+
+  pCheckButton(CheckButton& checkButton) : pWidget(checkButton), checkButton(checkButton) {}
+  void constructor();
+  void destructor();
+};
+
+}
diff -Nru higan/phoenix/cocoa/widget/check-label.cpp nSide/phoenix/cocoa/widget/check-label.cpp
--- higan/phoenix/cocoa/widget/check-label.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/widget/check-label.cpp	2015-09-16 13:08:13.599563372 +0900
@@ -0,0 +1,61 @@
+@implementation CocoaCheckLabel : NSButton
+
+-(id) initWith:(phoenix::CheckLabel&)checkLabelReference {
+  if(self = [super initWithFrame:NSMakeRect(0, 0, 0, 0)]) {
+    checkLabel = &checkLabelReference;
+
+    [self setTarget:self];
+    [self setAction:@selector(activate:)];
+    [self setButtonType:NSSwitchButton];
+  }
+  return self;
+}
+
+-(IBAction) activate:(id)sender {
+  checkLabel->state.checked = [self state] != NSOffState;
+  if(checkLabel->onToggle) checkLabel->onToggle();
+}
+
+@end
+
+namespace phoenix {
+
+Size pCheckLabel::minimumSize() {
+  Size size = Font::size(checkLabel.font(), checkLabel.state.text);
+  return {size.width + 20, size.height};
+}
+
+void pCheckLabel::setChecked(bool checked) {
+  @autoreleasepool {
+    [cocoaView setState:checked ? NSOnState : NSOffState];
+  }
+}
+
+void pCheckLabel::setGeometry(Geometry geometry) {
+  pWidget::setGeometry({
+    geometry.x - 2, geometry.y,
+    geometry.width + 4, geometry.height
+  });
+}
+
+void pCheckLabel::setText(string text) {
+  @autoreleasepool {
+    [cocoaView setTitle:[NSString stringWithUTF8String:text]];
+  }
+}
+
+void pCheckLabel::constructor() {
+  @autoreleasepool {
+    cocoaView = cocoaCheckLabel = [[CocoaCheckLabel alloc] initWith:checkLabel];
+    setChecked(checkLabel.state.checked);
+    setText(checkLabel.state.text);
+  }
+}
+
+void pCheckLabel::destructor() {
+  @autoreleasepool {
+    [cocoaView release];
+  }
+}
+
+}
diff -Nru higan/phoenix/cocoa/widget/check-label.hpp nSide/phoenix/cocoa/widget/check-label.hpp
--- higan/phoenix/cocoa/widget/check-label.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/widget/check-label.hpp	2015-09-16 13:08:13.600563372 +0900
@@ -0,0 +1,25 @@
+@interface CocoaCheckLabel : NSButton {
+@public
+  phoenix::CheckLabel* checkLabel;
+}
+-(id) initWith:(phoenix::CheckLabel&)checkLabel;
+-(IBAction) activate:(id)sender;
+@end
+
+namespace phoenix {
+
+struct pCheckLabel : public pWidget {
+  CheckLabel& checkLabel;
+  CocoaCheckLabel* cocoaCheckLabel = nullptr;
+
+  Size minimumSize();
+  void setChecked(bool checked);
+  void setGeometry(Geometry geometry);
+  void setText(string text);
+
+  pCheckLabel(CheckLabel& checkLabel) : pWidget(checkLabel), checkLabel(checkLabel) {}
+  void constructor();
+  void destructor();
+};
+
+}
diff -Nru higan/phoenix/cocoa/widget/combo-button.cpp nSide/phoenix/cocoa/widget/combo-button.cpp
--- higan/phoenix/cocoa/widget/combo-button.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/widget/combo-button.cpp	2015-09-16 13:08:13.600563372 +0900
@@ -0,0 +1,78 @@
+@implementation CocoaComboButton : NSPopUpButton
+
+-(id) initWith:(phoenix::ComboButton&)comboButtonReference {
+  if(self = [super initWithFrame:NSMakeRect(0, 0, 0, 0) pullsDown:NO]) {
+    comboButton = &comboButtonReference;
+
+    [self setTarget:self];
+    [self setAction:@selector(activate:)];
+  }
+  return self;
+}
+
+-(IBAction) activate:(id)sender {
+  comboButton->state.selection = [self indexOfSelectedItem];
+  if(comboButton->onChange) comboButton->onChange();
+}
+
+@end
+
+namespace phoenix {
+
+void pComboButton::append(string text) {
+  @autoreleasepool {
+    [cocoaView addItemWithTitle:[NSString stringWithUTF8String:text]];
+  }
+}
+
+Size pComboButton::minimumSize() {
+  unsigned maximumWidth = 0;
+  for(auto& text : comboButton.state.text) maximumWidth = max(maximumWidth, Font::size(comboButton.font(), text).width);
+  Size size = Font::size(comboButton.font(), " ");
+  return {maximumWidth + 36, size.height + 6};
+}
+
+void pComboButton::remove(unsigned selection) {
+  @autoreleasepool {
+    [cocoaView removeItemAtIndex:selection];
+  }
+}
+
+void pComboButton::reset() {
+  @autoreleasepool {
+    [cocoaView removeAllItems];
+  }
+}
+
+void pComboButton::setGeometry(Geometry geometry) {
+  pWidget::setGeometry({
+    geometry.x - 2, geometry.y,
+    geometry.width + 4, geometry.height
+  });
+}
+
+void pComboButton::setSelection(unsigned selection) {
+  @autoreleasepool {
+    [cocoaView selectItemAtIndex:selection];
+  }
+}
+
+void pComboButton::setText(unsigned selection, string text) {
+  @autoreleasepool {
+    [[cocoaView itemAtIndex:selection] setTitle:[NSString stringWithUTF8String:text]];
+  }
+}
+
+void pComboButton::constructor() {
+  @autoreleasepool {
+    cocoaView = cocoaComboButton = [[CocoaComboButton alloc] initWith:comboButton];
+  }
+}
+
+void pComboButton::destructor() {
+  @autoreleasepool {
+    [cocoaView release];
+  }
+}
+
+}
diff -Nru higan/phoenix/cocoa/widget/combo-button.hpp nSide/phoenix/cocoa/widget/combo-button.hpp
--- higan/phoenix/cocoa/widget/combo-button.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/widget/combo-button.hpp	2015-09-16 13:08:13.601563373 +0900
@@ -0,0 +1,28 @@
+@interface CocoaComboButton : NSPopUpButton {
+@public
+  phoenix::ComboButton* comboButton;
+}
+-(id) initWith:(phoenix::ComboButton&)comboButton;
+-(IBAction) activate:(id)sender;
+@end
+
+namespace phoenix {
+
+struct pComboButton : public pWidget {
+  ComboButton& comboButton;
+  CocoaComboButton* cocoaComboButton = nullptr;
+
+  void append(string text);
+  Size minimumSize();
+  void remove(unsigned selection);
+  void reset();
+  void setGeometry(Geometry geometry);
+  void setSelection(unsigned selection);
+  void setText(unsigned selection, string text);
+
+  pComboButton(ComboButton& comboButton) : pWidget(comboButton), comboButton(comboButton) {}
+  void constructor();
+  void destructor();
+};
+
+}
diff -Nru higan/phoenix/cocoa/widget/console.cpp nSide/phoenix/cocoa/widget/console.cpp
--- higan/phoenix/cocoa/widget/console.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/widget/console.cpp	2015-09-16 13:08:13.600563372 +0900
@@ -0,0 +1,41 @@
+@implementation CocoaConsole : NSScrollView
+
+-(id) initWith:(phoenix::Console&)consoleReference {
+  if(self = [super initWithFrame:NSMakeRect(0, 0, 0, 0)]) {
+    console = &consoleReference;
+  }
+  return self;
+}
+
+@end
+
+namespace phoenix {
+
+void pConsole::print(string text) {
+}
+
+void pConsole::reset() {
+}
+
+void pConsole::setBackgroundColor(Color color) {
+}
+
+void pConsole::setForegroundColor(Color color) {
+}
+
+void pConsole::setPrompt(string prompt) {
+}
+
+void pConsole::constructor() {
+  @autoreleasepool {
+    cocoaView = cocoaConsole = [[CocoaConsole alloc] initWith:console];
+  }
+}
+
+void pConsole::destructor() {
+  @autoreleasepool {
+    [cocoaView release];
+  }
+}
+
+}
diff -Nru higan/phoenix/cocoa/widget/console.hpp nSide/phoenix/cocoa/widget/console.hpp
--- higan/phoenix/cocoa/widget/console.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/widget/console.hpp	2015-09-16 13:08:13.604563373 +0900
@@ -0,0 +1,25 @@
+@interface CocoaConsole : NSScrollView {
+@public
+  phoenix::Console* console;
+}
+-(id) initWith:(phoenix::Console&)console;
+@end
+
+namespace phoenix {
+
+struct pConsole : public pWidget {
+  Console& console;
+  CocoaConsole* cocoaConsole = nullptr;
+
+  void print(string text);
+  void reset();
+  void setBackgroundColor(Color color);
+  void setForegroundColor(Color color);
+  void setPrompt(string prompt);
+
+  pConsole(Console& console) : pWidget(console), console(console) {}
+  void constructor();
+  void destructor();
+};
+
+}
diff -Nru higan/phoenix/cocoa/widget/frame.cpp nSide/phoenix/cocoa/widget/frame.cpp
--- higan/phoenix/cocoa/widget/frame.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/widget/frame.cpp	2015-09-16 13:08:13.600563372 +0900
@@ -0,0 +1,68 @@
+@implementation CocoaFrame : NSBox
+
+-(id) initWith:(phoenix::Frame&)frameReference {
+  if(self = [super initWithFrame:NSMakeRect(0, 0, 0, 0)]) {
+    frame = &frameReference;
+
+    [self setTitle:@""];
+  }
+  return self;
+}
+
+@end
+
+namespace phoenix {
+
+void pFrame::setEnabled(bool enabled) {
+  if(frame.state.layout) frame.state.layout->setEnabled(frame.state.layout->enabled());
+  pWidget::setEnabled(enabled);
+}
+
+void pFrame::setFont(string font) {
+  @autoreleasepool {
+    [cocoaView setTitleFont:pFont::cocoaFont(font)];
+  }
+}
+
+void pFrame::setGeometry(Geometry geometry) {
+  bool empty = frame.state.text.empty();
+  Size size = Font::size(frame.font(), frame.state.text);
+  pWidget::setGeometry({
+    geometry.x - 3, geometry.y - (empty ? size.height - 2 : 1),
+    geometry.width + 6, geometry.height + (empty ? size.height + 2 : 5)
+  });
+  if(frame.state.layout == nullptr) return;
+  geometry.x += 1, geometry.y += (empty ? 1 : size.height - 2);
+  geometry.width -= 2, geometry.height -= (empty ? 1 : size.height - 1);
+  frame.state.layout->setGeometry(geometry);
+}
+
+void pFrame::setText(string text) {
+  @autoreleasepool {
+    [cocoaView setTitle:[NSString stringWithUTF8String:text]];
+  }
+}
+
+void pFrame::setVisible(bool visible) {
+  if(frame.state.layout) frame.state.layout->setVisible(frame.state.layout->visible());
+  pWidget::setVisible(visible);
+}
+
+void pFrame::constructor() {
+  @autoreleasepool {
+    cocoaView = cocoaFrame = [[CocoaFrame alloc] initWith:frame];
+  }
+}
+
+void pFrame::destructor() {
+  @autoreleasepool {
+    [cocoaView release];
+  }
+}
+
+void pFrame::orphan() {
+  destructor();
+  constructor();
+}
+
+}
diff -Nru higan/phoenix/cocoa/widget/frame.hpp nSide/phoenix/cocoa/widget/frame.hpp
--- higan/phoenix/cocoa/widget/frame.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/widget/frame.hpp	2015-09-16 13:08:13.603563373 +0900
@@ -0,0 +1,26 @@
+@interface CocoaFrame : NSBox {
+@public
+  phoenix::Frame* frame;
+}
+-(id) initWith:(phoenix::Frame&)frame;
+@end
+
+namespace phoenix {
+
+struct pFrame : public pWidget {
+  Frame& frame;
+  CocoaFrame* cocoaFrame = nullptr;
+
+  void setEnabled(bool enabled);
+  void setFont(string font);
+  void setGeometry(Geometry geometry);
+  void setText(string text);
+  void setVisible(bool visible);
+
+  pFrame(Frame& frame) : pWidget(frame), frame(frame) {}
+  void constructor();
+  void destructor();
+  void orphan();
+};
+
+}
diff -Nru higan/phoenix/cocoa/widget/hex-edit.cpp nSide/phoenix/cocoa/widget/hex-edit.cpp
--- higan/phoenix/cocoa/widget/hex-edit.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/widget/hex-edit.cpp	2015-09-16 13:08:13.605563373 +0900
@@ -0,0 +1,47 @@
+@implementation CocoaHexEdit : NSScrollView
+
+-(id) initWith:(phoenix::HexEdit&)hexEditReference {
+  if(self = [super initWithFrame:NSMakeRect(0, 0, 0, 0)]) {
+    hexEdit = &hexEditReference;
+  }
+  return self;
+}
+
+@end
+
+namespace phoenix {
+
+void pHexEdit::setBackgroundColor(Color color) {
+}
+
+void pHexEdit::setColumns(unsigned columns) {
+}
+
+void pHexEdit::setForegroundColor(Color color) {
+}
+
+void pHexEdit::setLength(unsigned length) {
+}
+
+void pHexEdit::setOffset(unsigned offset) {
+}
+
+void pHexEdit::setRows(unsigned rows) {
+}
+
+void pHexEdit::update() {
+}
+
+void pHexEdit::constructor() {
+  @autoreleasepool {
+    cocoaView = cocoaHexEdit = [[CocoaHexEdit alloc] initWith:hexEdit];
+  }
+}
+
+void pHexEdit::destructor() {
+  @autoreleasepool {
+    [cocoaView release];
+  }
+}
+
+}
diff -Nru higan/phoenix/cocoa/widget/hex-edit.hpp nSide/phoenix/cocoa/widget/hex-edit.hpp
--- higan/phoenix/cocoa/widget/hex-edit.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/widget/hex-edit.hpp	2015-09-16 13:08:13.600563372 +0900
@@ -0,0 +1,27 @@
+@interface CocoaHexEdit : NSScrollView {
+@public
+  phoenix::HexEdit* hexEdit;
+}
+-(id) initWith:(phoenix::HexEdit&)hexEdit;
+@end
+
+namespace phoenix {
+
+struct pHexEdit : public pWidget {
+  HexEdit& hexEdit;
+  CocoaHexEdit* cocoaHexEdit = nullptr;
+
+  void setBackgroundColor(Color color);
+  void setColumns(unsigned columns);
+  void setForegroundColor(Color color);
+  void setLength(unsigned length);
+  void setOffset(unsigned offset);
+  void setRows(unsigned rows);
+  void update();
+
+  pHexEdit(HexEdit& hexEdit) : pWidget(hexEdit), hexEdit(hexEdit) {}
+  void constructor();
+  void destructor();
+};
+
+}
diff -Nru higan/phoenix/cocoa/widget/horizontal-scroller.cpp nSide/phoenix/cocoa/widget/horizontal-scroller.cpp
--- higan/phoenix/cocoa/widget/horizontal-scroller.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/widget/horizontal-scroller.cpp	2015-09-16 13:08:13.603563373 +0900
@@ -0,0 +1,85 @@
+@implementation CocoaHorizontalScroller : NSScroller
+
+-(id) initWith:(phoenix::HorizontalScroller&)horizontalScrollerReference {
+  if(self = [super initWithFrame:NSMakeRect(0, 0, 1, 0)]) {
+    horizontalScroller = &horizontalScrollerReference;
+
+    [self setTarget:self];
+    [self setAction:@selector(scroll:)];
+
+    [self setControlSize:NSRegularControlSize];
+    [self setScrollerStyle:NSScrollerStyleLegacy];
+    [self setEnabled:YES];
+
+    [self update];
+  }
+  return self;
+}
+
+-(void) update {
+  double d = 1.0 / horizontalScroller->state.length;
+  double f = d * horizontalScroller->state.position;
+
+  [self setDoubleValue:f];
+  [self setKnobProportion:d];
+}
+
+-(IBAction) scroll:(id)sender {
+  auto& state = horizontalScroller->state;
+
+  switch([self hitPart]) {
+  case NSScrollerIncrementLine:
+  case NSScrollerIncrementPage:
+    if(state.position < state.length - 1) state.position++;
+    [self update];
+    break;
+
+  case NSScrollerDecrementLine:
+  case NSScrollerDecrementPage:
+    if(state.position) state.position--;
+    [self update];
+    break;
+
+  case NSScrollerKnob:
+    state.position = [self doubleValue] * state.length;
+    break;
+  }
+
+  if(horizontalScroller->onChange) horizontalScroller->onChange();
+}
+
+@end
+
+namespace phoenix {
+
+Size pHorizontalScroller::minimumSize() {
+  @autoreleasepool {
+    return {32, [NSScroller scrollerWidthForControlSize:NSRegularControlSize scrollerStyle:NSScrollerStyleLegacy]};
+  }
+}
+
+void pHorizontalScroller::setLength(unsigned length) {
+  @autoreleasepool {
+    [cocoaView update];
+  }
+}
+
+void pHorizontalScroller::setPosition(unsigned position) {
+  @autoreleasepool {
+    [cocoaView update];
+  }
+}
+
+void pHorizontalScroller::constructor() {
+  @autoreleasepool {
+    cocoaView = cocoaHorizontalScroller = [[CocoaHorizontalScroller alloc] initWith:horizontalScroller];
+  }
+}
+
+void pHorizontalScroller::destructor() {
+  @autoreleasepool {
+    [cocoaView release];
+  }
+}
+
+}
diff -Nru higan/phoenix/cocoa/widget/horizontal-scroller.hpp nSide/phoenix/cocoa/widget/horizontal-scroller.hpp
--- higan/phoenix/cocoa/widget/horizontal-scroller.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/widget/horizontal-scroller.hpp	2015-09-16 13:08:13.602563373 +0900
@@ -0,0 +1,25 @@
+@interface CocoaHorizontalScroller : NSScroller {
+@public
+  phoenix::HorizontalScroller* horizontalScroller;
+}
+-(id) initWith:(phoenix::HorizontalScroller&)horizontalScroller;
+-(void) update;
+-(IBAction) scroll:(id)sender;
+@end
+
+namespace phoenix {
+
+struct pHorizontalScroller : public pWidget {
+  HorizontalScroller& horizontalScroller;
+  CocoaHorizontalScroller* cocoaHorizontalScroller = nullptr;
+
+  Size minimumSize();
+  void setLength(unsigned length);
+  void setPosition(unsigned position);
+
+  pHorizontalScroller(HorizontalScroller& horizontalScroller) : pWidget(horizontalScroller), horizontalScroller(horizontalScroller) {}
+  void constructor();
+  void destructor();
+};
+
+}
diff -Nru higan/phoenix/cocoa/widget/horizontal-slider.cpp nSide/phoenix/cocoa/widget/horizontal-slider.cpp
--- higan/phoenix/cocoa/widget/horizontal-slider.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/widget/horizontal-slider.cpp	2015-09-16 13:08:13.598563372 +0900
@@ -0,0 +1,61 @@
+@implementation CocoaHorizontalSlider : NSSlider
+
+-(id) initWith:(phoenix::HorizontalSlider&)horizontalSliderReference {
+  if(self = [super initWithFrame:NSMakeRect(0, 0, 1, 0)]) {
+    horizontalSlider = &horizontalSliderReference;
+
+    [self setTarget:self];
+    [self setAction:@selector(activate:)];
+    [self setMinValue:0];
+  }
+  return self;
+}
+
+-(IBAction) activate:(id)sender {
+  horizontalSlider->state.position = [self doubleValue];
+  if(horizontalSlider->onChange) horizontalSlider->onChange();
+}
+
+@end
+
+namespace phoenix {
+
+Size pHorizontalSlider::minimumSize() {
+  return {48, 20};
+}
+
+void pHorizontalSlider::setGeometry(Geometry geometry) {
+  pWidget::setGeometry({
+    geometry.x - 2, geometry.y,
+    geometry.width + 4, geometry.height
+  });
+}
+
+void pHorizontalSlider::setLength(unsigned length) {
+  @autoreleasepool {
+    [cocoaView setMaxValue:length];
+  }
+}
+
+void pHorizontalSlider::setPosition(unsigned position) {
+  @autoreleasepool {
+    [cocoaView setDoubleValue:position];
+  }
+}
+
+void pHorizontalSlider::constructor() {
+  @autoreleasepool {
+    cocoaView = cocoaHorizontalSlider = [[CocoaHorizontalSlider alloc] initWith:horizontalSlider];
+
+    setLength(horizontalSlider.state.length);
+    setPosition(horizontalSlider.state.position);
+  }
+}
+
+void pHorizontalSlider::destructor() {
+  @autoreleasepool {
+    [cocoaView release];
+  }
+}
+
+}
diff -Nru higan/phoenix/cocoa/widget/horizontal-slider.hpp nSide/phoenix/cocoa/widget/horizontal-slider.hpp
--- higan/phoenix/cocoa/widget/horizontal-slider.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/widget/horizontal-slider.hpp	2015-09-16 13:08:13.600563372 +0900
@@ -0,0 +1,25 @@
+@interface CocoaHorizontalSlider : NSSlider {
+@public
+  phoenix::HorizontalSlider* horizontalSlider;
+}
+-(id) initWith:(phoenix::HorizontalSlider&)horizontalSlider;
+-(IBAction) activate:(id)sender;
+@end
+
+namespace phoenix {
+
+struct pHorizontalSlider : public pWidget {
+  HorizontalSlider& horizontalSlider;
+  CocoaHorizontalSlider* cocoaHorizontalSlider = nullptr;
+
+  Size minimumSize();
+  void setGeometry(Geometry geometry);
+  void setLength(unsigned length);
+  void setPosition(unsigned position);
+
+  pHorizontalSlider(HorizontalSlider& horizontalSlider) : pWidget(horizontalSlider), horizontalSlider(horizontalSlider) {}
+  void constructor();
+  void destructor();
+};
+
+}
diff -Nru higan/phoenix/cocoa/widget/label.cpp nSide/phoenix/cocoa/widget/label.cpp
--- higan/phoenix/cocoa/widget/label.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/widget/label.cpp	2015-09-16 13:08:13.602563373 +0900
@@ -0,0 +1,62 @@
+@implementation CocoaLabel : NSTextField
+
+-(id) initWith:(phoenix::Label&)labelReference {
+  if(self = [super initWithFrame:NSMakeRect(0, 0, 0, 0)]) {
+    label = &labelReference;
+
+    [self setAlignment:NSLeftTextAlignment];
+    [self setBordered:NO];
+    [self setDrawsBackground:NO];
+    [self setEditable:NO];
+  }
+  return self;
+}
+
+@end
+
+namespace phoenix {
+
+Size pLabel::minimumSize() {
+  Size size = Font::size(label.font(), label.state.text);
+  return {size.width, size.height};
+}
+
+void pLabel::setGeometry(Geometry geometry) {
+  //NSTextField does not support vertical text centering:
+  //simulate this by adjusting the geometry placement (reduce height, move view down)
+  unsigned height = Font::size(label.font(), " ").height;
+  unsigned widgetHeight = geometry.height + 4;  //+4 compensates for margin adjust
+  auto offset = geometry;
+
+  if(widgetHeight > height) {
+    unsigned diff = widgetHeight - height;
+    offset.y += diff >> 1;
+    offset.height -= diff >> 1;
+  }
+
+  pWidget::setGeometry({
+    offset.x - 3, offset.y - 3,
+    offset.width + 6, offset.height + 6
+  });
+}
+
+void pLabel::setText(string text) {
+  @autoreleasepool {
+    [cocoaView setStringValue:[NSString stringWithUTF8String:text]];
+  }
+}
+
+void pLabel::constructor() {
+  @autoreleasepool {
+    cocoaView = cocoaLabel = [[CocoaLabel alloc] initWith:label];
+    setText(label.state.text);
+  }
+}
+
+void pLabel::destructor() {
+  @autoreleasepool {
+    [cocoaView release];
+  }
+}
+
+}
diff -Nru higan/phoenix/cocoa/widget/label.hpp nSide/phoenix/cocoa/widget/label.hpp
--- higan/phoenix/cocoa/widget/label.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/widget/label.hpp	2015-09-16 13:08:13.600563372 +0900
@@ -0,0 +1,23 @@
+@interface CocoaLabel : NSTextField {
+@public
+  phoenix::Label* label;
+}
+-(id) initWith:(phoenix::Label&)label;
+@end
+
+namespace phoenix {
+
+struct pLabel : public pWidget {
+  Label& label;
+  CocoaLabel* cocoaLabel = nullptr;
+
+  Size minimumSize();
+  void setGeometry(Geometry geometry);
+  void setText(string text);
+
+  pLabel(Label& label) : pWidget(label), label(label) {}
+  void constructor();
+  void destructor();
+};
+
+}
diff -Nru higan/phoenix/cocoa/widget/layout.hpp nSide/phoenix/cocoa/widget/layout.hpp
--- higan/phoenix/cocoa/widget/layout.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/widget/layout.hpp	2015-09-16 13:08:13.605563373 +0900
@@ -0,0 +1,9 @@
+namespace phoenix {
+
+struct pLayout : public pSizable {
+  Layout& layout;
+
+  pLayout(Layout& layout) : pSizable(layout), layout(layout) {}
+};
+
+}
diff -Nru higan/phoenix/cocoa/widget/line-edit.cpp nSide/phoenix/cocoa/widget/line-edit.cpp
--- higan/phoenix/cocoa/widget/line-edit.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/widget/line-edit.cpp	2015-09-16 13:08:13.604563373 +0900
@@ -0,0 +1,71 @@
+@implementation CocoaLineEdit : NSTextField
+
+-(id) initWith:(phoenix::LineEdit&)lineEditReference {
+  if(self = [super initWithFrame:NSMakeRect(0, 0, 0, 0)]) {
+    lineEdit = &lineEditReference;
+
+    [self setDelegate:self];
+    [self setTarget:self];
+    [self setAction:@selector(activate:)];
+
+    //prevent focus changes from generating activate event
+    [[self cell] setSendsActionOnEndEditing:NO];
+  }
+  return self;
+}
+
+-(void) textDidChange:(NSNotification*)n {
+  if(lineEdit->onChange) lineEdit->onChange();
+}
+
+-(IBAction) activate:(id)sender {
+  if(lineEdit->onActivate) lineEdit->onActivate();
+}
+
+@end
+
+namespace phoenix {
+
+Size pLineEdit::minimumSize() {
+  Size size = Font::size(lineEdit.font(), lineEdit.state.text);
+  return {size.width + 10, size.height + 8};
+}
+
+void pLineEdit::setBackgroundColor(Color color) {
+}
+
+void pLineEdit::setEditable(bool editable) {
+  @autoreleasepool {
+    [cocoaView setEditable:editable];
+  }
+}
+
+void pLineEdit::setForegroundColor(Color color) {
+}
+
+void pLineEdit::setText(string text) {
+  @autoreleasepool {
+    [cocoaView setStringValue:[NSString stringWithUTF8String:text]];
+  }
+}
+
+string pLineEdit::text() {
+  @autoreleasepool {
+    return [[cocoaView stringValue] UTF8String];
+  }
+}
+
+void pLineEdit::constructor() {
+  @autoreleasepool {
+    cocoaView = cocoaLineEdit = [[CocoaLineEdit alloc] initWith:lineEdit];
+    setEditable(lineEdit.state.editable);
+  }
+}
+
+void pLineEdit::destructor() {
+  @autoreleasepool {
+    [cocoaView release];
+  }
+}
+
+}
diff -Nru higan/phoenix/cocoa/widget/line-edit.hpp nSide/phoenix/cocoa/widget/line-edit.hpp
--- higan/phoenix/cocoa/widget/line-edit.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/widget/line-edit.hpp	2015-09-16 13:08:13.605563373 +0900
@@ -0,0 +1,28 @@
+@interface CocoaLineEdit : NSTextField <NSTextFieldDelegate> {
+@public
+  phoenix::LineEdit* lineEdit;
+}
+-(id) initWith:(phoenix::LineEdit&)lineEdit;
+-(void) textDidChange:(NSNotification*)n;
+-(IBAction) activate:(id)sender;
+@end
+
+namespace phoenix {
+
+struct pLineEdit : public pWidget {
+  LineEdit& lineEdit;
+  CocoaLineEdit* cocoaLineEdit = nullptr;
+
+  Size minimumSize();
+  void setBackgroundColor(Color color);
+  void setEditable(bool editable);
+  void setForegroundColor(Color color);
+  void setText(string text);
+  string text();
+
+  pLineEdit(LineEdit& lineEdit) : pWidget(lineEdit), lineEdit(lineEdit) {}
+  void constructor();
+  void destructor();
+};
+
+}
diff -Nru higan/phoenix/cocoa/widget/list-view.cpp nSide/phoenix/cocoa/widget/list-view.cpp
--- higan/phoenix/cocoa/widget/list-view.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/widget/list-view.cpp	2015-09-16 13:08:13.602563373 +0900
@@ -0,0 +1,333 @@
+@implementation CocoaListView : NSScrollView
+
+-(id) initWith:(phoenix::ListView&)listViewReference {
+  if(self = [super initWithFrame:NSMakeRect(0, 0, 0, 0)]) {
+    listView = &listViewReference;
+    content = [[CocoaListViewContent alloc] initWithFrame:NSMakeRect(0, 0, 0, 0)];
+
+    [self setDocumentView:content];
+    [self setBorderType:NSBezelBorder];
+    [self setHasVerticalScroller:YES];
+
+    [content setDataSource:self];
+    [content setDelegate:self];
+    [content setTarget:self];
+    [content setDoubleAction:@selector(doubleAction:)];
+
+    [content setAllowsColumnReordering:NO];
+    [content setAllowsColumnResizing:YES];
+    [content setAllowsColumnSelection:NO];
+    [content setAllowsEmptySelection:YES];
+    [content setAllowsMultipleSelection:NO];
+    [content setColumnAutoresizingStyle:NSTableViewLastColumnOnlyAutoresizingStyle];
+
+    font = nil;
+    [self setFont:nil];
+  }
+  return self;
+}
+
+-(void) dealloc {
+  [content release];
+  [font release];
+  [super dealloc];
+}
+
+-(CocoaListViewContent*) content {
+  return content;
+}
+
+-(NSFont*) font {
+  return font;
+}
+
+-(void) setFont:(NSFont*)fontPointer {
+  if(!fontPointer) fontPointer = [NSFont systemFontOfSize:12];
+  [fontPointer retain];
+  if(font) [font release];
+  font = fontPointer;
+
+  unsigned fontHeight = phoenix::pFont::size(font, " ").height;
+  [content setFont:font];
+  [content setRowHeight:fontHeight];
+  [self reloadColumns];
+}
+
+-(void) reloadColumns {
+  while([[content tableColumns] count]) {
+    [content removeTableColumn:[[content tableColumns] lastObject]];
+  }
+
+  if(listView->state.checkable) {
+    NSTableColumn *tableColumn = [[NSTableColumn alloc] initWithIdentifier:@"check"];
+    NSTableHeaderCell *headerCell = [[NSTableHeaderCell alloc] initTextCell:@""];
+    NSButtonCell *dataCell = [[NSButtonCell alloc] initTextCell:@""];
+
+    [dataCell setButtonType:NSSwitchButton];
+    [dataCell setControlSize:NSSmallControlSize];
+    [dataCell setRefusesFirstResponder:YES];
+
+    [tableColumn setResizingMask:NSTableColumnNoResizing];
+    [tableColumn setHeaderCell:headerCell];
+    [tableColumn setDataCell:dataCell];
+    [tableColumn setWidth:20.0];
+
+    [content addTableColumn:tableColumn];
+  }
+
+  lstring headers = listView->state.headerText;
+  if(headers.size() == 0) headers.append("");
+  [content setUsesAlternatingRowBackgroundColors:headers.size() >= 2];
+
+  for(unsigned column = 0; column < headers.size(); column++) {
+    NSTableColumn* tableColumn = [[NSTableColumn alloc] initWithIdentifier:[[NSNumber numberWithInteger:column] stringValue]];
+    NSTableHeaderCell* headerCell = [[NSTableHeaderCell alloc] initTextCell:[NSString stringWithUTF8String:headers(column)]];
+    CocoaListViewCell* dataCell = [[CocoaListViewCell alloc] initTextCell:@""];
+
+    [dataCell setEditable:NO];
+
+    [tableColumn setResizingMask:NSTableColumnAutoresizingMask | NSTableColumnUserResizingMask];
+    [tableColumn setHeaderCell:headerCell];
+    [tableColumn setDataCell:dataCell];
+
+    [content addTableColumn:tableColumn];
+  }
+}
+
+-(NSInteger) numberOfRowsInTableView:(NSTableView*)table {
+  return listView->state.text.size();
+}
+
+-(id) tableView:(NSTableView*)table objectValueForTableColumn:(NSTableColumn*)tableColumn row:(NSInteger)row {
+  if([[tableColumn identifier] isEqualToString:@"check"]) {
+    auto checked = listView->state.checked(row) ? NSOnState : NSOffState;
+    return [NSNumber numberWithInteger:checked];
+  }
+
+  NSInteger column = [[tableColumn identifier] integerValue];
+  unsigned height = [table rowHeight];
+
+  NSString* text = [NSString stringWithUTF8String:listView->state.text(row)(column)];
+  NSImage* image = NSMakeImage(listView->state.image(row)(column), height, height);
+
+  if(image) return @{ @"text":text, @"image":image };
+  return @{ @"text":text };
+}
+
+-(BOOL) tableView:(NSTableView*)table shouldShowCellExpansionForTableColumn:(NSTableColumn*)tableColumn row:(NSInteger)row {
+  return NO;
+}
+
+-(NSString*) tableView:(NSTableView*)table toolTipForCell:(NSCell*)cell rect:(NSRectPointer)rect tableColumn:(NSTableColumn*)tableColumn row:(NSInteger)row mouseLocation:(NSPoint)mouseLocation {
+  return nil;
+}
+
+-(void) tableView:(NSTableView*)table setObjectValue:(id)object forTableColumn:(NSTableColumn*)tableColumn row:(NSInteger)row {
+  if([[tableColumn identifier] isEqualToString:@"check"]) {
+    listView->state.checked(row) = [object integerValue] != NSOffState;
+    if(listView->onToggle) listView->onToggle(row);
+  }
+}
+
+-(void) tableView:(NSTableView*)tableView willDisplayCell:(id)cell forTableColumn:(NSTableColumn*)tableColumn row:(NSInteger)row {
+  [cell setFont:[self font]];
+}
+
+-(void) tableViewSelectionDidChange:(NSNotification*)notification {
+  listView->state.selected = true;
+  listView->state.selection = [content selectedRow];
+  if(listView->onChange) listView->onChange();
+}
+
+-(IBAction) activate:(id)sender {
+  if(listView->onActivate) listView->onActivate();
+}
+
+-(IBAction) doubleAction:(id)sender {
+  if([content clickedRow] >= 0) {
+    [self activate:self];
+  }
+}
+
+@end
+
+@implementation CocoaListViewContent : NSTableView
+
+-(void) keyDown:(NSEvent*)event {
+  auto character = [[event characters] characterAtIndex:0];
+  if(character == NSEnterCharacter || character == NSCarriageReturnCharacter) {
+    if([self selectedRow] >= 0) {
+      [[self delegate] activate:self];
+      return;
+    }
+  }
+
+  [super keyDown:event];
+}
+
+@end
+
+@implementation CocoaListViewCell : NSTextFieldCell
+
+//used by type-ahead
+-(NSString*) stringValue {
+  return [[self objectValue] objectForKey:@"text"];
+}
+
+-(void) drawWithFrame:(NSRect)frame inView:(NSView*)view {
+  NSString* text = [[self objectValue] objectForKey:@"text"];
+  NSImage* image = [[self objectValue] objectForKey:@"image"];
+  unsigned textDisplacement = 0;
+
+  if(image) {
+    [[NSGraphicsContext currentContext] saveGraphicsState];
+
+    NSRect targetRect = NSMakeRect(frame.origin.x, frame.origin.y, frame.size.height, frame.size.height);
+    NSRect sourceRect = NSMakeRect(0, 0, [image size].width, [image size].height);
+    [image drawInRect:targetRect fromRect:sourceRect operation:NSCompositeSourceOver fraction:1.0 respectFlipped:YES hints:nil];
+
+    [[NSGraphicsContext currentContext] restoreGraphicsState];
+    textDisplacement = frame.size.height + 2;
+  }
+
+  NSRect textRect = NSMakeRect(
+    frame.origin.x + textDisplacement, frame.origin.y,
+    frame.size.width - textDisplacement, frame.size.height
+  );
+
+  NSColor* textColor = [self isHighlighted]
+  ? [NSColor alternateSelectedControlTextColor]
+  : [NSColor textColor];
+
+  [text drawInRect:textRect withAttributes:@{
+    NSForegroundColorAttributeName:textColor,
+    NSFontAttributeName:[self font]
+  }];
+}
+
+@end
+
+namespace phoenix {
+
+void pListView::append(const lstring& text) {
+  @autoreleasepool {
+    [[cocoaView content] reloadData];
+  }
+}
+
+void pListView::autoSizeColumns() {
+  @autoreleasepool {
+    if(listView.state.checkable) {
+      NSTableColumn* tableColumn = [[cocoaView content] tableColumnWithIdentifier:@"check"];
+      [tableColumn setWidth:20.0];
+    }
+
+    unsigned height = [[cocoaView content] rowHeight];
+    for(unsigned column = 0; column < max(1u, listView.state.headerText.size()); column++) {
+      NSTableColumn* tableColumn = [[cocoaView content] tableColumnWithIdentifier:[[NSNumber numberWithInteger:column] stringValue]];
+      unsigned minimumWidth = pFont::size([[tableColumn headerCell] font], listView.state.headerText(column)).width + 4;
+      for(unsigned row = 0; row < listView.state.text.size(); row++) {
+        unsigned width = pFont::size([cocoaView font], listView.state.text(row)(column)).width + 2;
+        if(listView.state.image(row)(height).empty() == false) width += height + 2;
+        if(width > minimumWidth) minimumWidth = width;
+      }
+      [tableColumn setWidth:minimumWidth];
+    }
+
+    [[cocoaView content] sizeLastColumnToFit];
+  }
+}
+
+void pListView::remove(unsigned selection) {
+  @autoreleasepool {
+    [[cocoaView content] reloadData];
+  }
+}
+
+void pListView::reset() {
+  @autoreleasepool {
+    [[cocoaView content] reloadData];
+  }
+}
+
+void pListView::setBackgroundColor(Color color) {
+}
+
+void pListView::setCheckable(bool checkable) {
+  @autoreleasepool {
+    [cocoaView reloadColumns];
+  }
+}
+
+void pListView::setChecked(unsigned selection, bool checked) {
+  @autoreleasepool {
+    [[cocoaView content] reloadData];
+  }
+}
+
+void pListView::setFont(string font) {
+  @autoreleasepool {
+    [cocoaView setFont:pFont::cocoaFont(font)];
+  }
+}
+
+void pListView::setForegroundColor(Color color) {
+}
+
+void pListView::setHeaderText(const lstring& text) {
+  @autoreleasepool {
+    [cocoaView reloadColumns];
+  }
+}
+
+void pListView::setHeaderVisible(bool visible) {
+  @autoreleasepool {
+    if(visible) {
+      [[cocoaView content] setHeaderView:[[[NSTableHeaderView alloc] init] autorelease]];
+    } else {
+      [[cocoaView content] setHeaderView:nil];
+    }
+  }
+}
+
+void pListView::setImage(unsigned selection, unsigned position, const image& image) {
+  @autoreleasepool {
+    [[cocoaView content] reloadData];
+  }
+}
+
+void pListView::setSelected(bool selected) {
+  @autoreleasepool {
+    if(selected == false) {
+      [[cocoaView content] deselectAll:nil];
+    }
+  }
+}
+
+void pListView::setSelection(unsigned selection) {
+  @autoreleasepool {
+    [[cocoaView content] selectRowIndexes:[NSIndexSet indexSetWithIndexesInRange:NSMakeRange(selection, 1)] byExtendingSelection:NO];
+  }
+}
+
+void pListView::setText(unsigned selection, unsigned position, const string text) {
+  @autoreleasepool {
+    [[cocoaView content] reloadData];
+  }
+}
+
+void pListView::constructor() {
+  @autoreleasepool {
+    cocoaView = cocoaListView = [[CocoaListView alloc] initWith:listView];
+    setHeaderVisible(listView.state.headerVisible);
+    setHeaderText(listView.state.headerText);
+  }
+}
+
+void pListView::destructor() {
+  @autoreleasepool {
+    [cocoaView release];
+  }
+}
+
+}
diff -Nru higan/phoenix/cocoa/widget/list-view.hpp nSide/phoenix/cocoa/widget/list-view.hpp
--- higan/phoenix/cocoa/widget/list-view.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/widget/list-view.hpp	2015-09-16 13:08:13.605563373 +0900
@@ -0,0 +1,64 @@
+@class CocoaListViewContent;
+
+@interface CocoaListView : NSScrollView <NSTableViewDelegate, NSTableViewDataSource> {
+@public
+  phoenix::ListView* listView;
+  CocoaListViewContent* content;
+  NSFont* font;
+}
+-(id) initWith:(phoenix::ListView&)listView;
+-(void) dealloc;
+-(CocoaListViewContent*) content;
+-(NSFont*) font;
+-(void) setFont:(NSFont*)font;
+-(void) reloadColumns;
+-(NSInteger) numberOfRowsInTableView:(NSTableView*)table;
+-(id) tableView:(NSTableView*)table objectValueForTableColumn:(NSTableColumn*)tableColumn row:(NSInteger)row;
+-(BOOL) tableView:(NSTableView*)table shouldShowCellExpansionForTableColumn:(NSTableColumn*)tableColumn row:(NSInteger)row;
+-(NSString*) tableView:(NSTableView*)table toolTipForCell:(NSCell*)cell rect:(NSRectPointer)rect tableColumn:(NSTableColumn*)tableColumn row:(NSInteger)row mouseLocation:(NSPoint)mouseLocation;
+-(void) tableView:(NSTableView*)table setObjectValue:(id)object forTableColumn:(NSTableColumn*)tableColumn row:(NSInteger)row;
+-(void) tableView:(NSTableView*)tableView willDisplayCell:(id)cell forTableColumn:(NSTableColumn*)tableColumn row:(NSInteger)row;
+-(void) tableViewSelectionDidChange:(NSNotification*)notification;
+-(IBAction) activate:(id)sender;
+-(IBAction) doubleAction:(id)sender;
+@end
+
+@interface CocoaListViewContent : NSTableView {
+}
+-(void) keyDown:(NSEvent*)event;
+@end
+
+@interface CocoaListViewCell : NSTextFieldCell {
+}
+-(NSString*) stringValue;
+-(void) drawWithFrame:(NSRect)frame inView:(NSView*)view;
+@end
+
+namespace phoenix {
+
+struct pListView : public pWidget {
+  ListView& listView;
+  CocoaListView* cocoaListView = nullptr;
+
+  void append(const lstring& text);
+  void autoSizeColumns();
+  void remove(unsigned selection);
+  void reset();
+  void setBackgroundColor(Color color);
+  void setCheckable(bool checkable);
+  void setChecked(unsigned selection, bool checked);
+  void setFont(string font);
+  void setForegroundColor(Color color);
+  void setHeaderText(const lstring& text);
+  void setHeaderVisible(bool visible);
+  void setImage(unsigned selection, unsigned position, const image& image);
+  void setSelected(bool selected);
+  void setSelection(unsigned selection);
+  void setText(unsigned selection, unsigned position, string text);
+
+  pListView(ListView& listView) : pWidget(listView), listView(listView) {}
+  void constructor();
+  void destructor();
+};
+
+}
diff -Nru higan/phoenix/cocoa/widget/progress-bar.cpp nSide/phoenix/cocoa/widget/progress-bar.cpp
--- higan/phoenix/cocoa/widget/progress-bar.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/widget/progress-bar.cpp	2015-09-16 13:08:13.604563373 +0900
@@ -0,0 +1,37 @@
+@implementation CocoaProgressBar : NSProgressIndicator
+
+-(id) initWith:(phoenix::ProgressBar&)progressBarReference {
+  if(self = [super initWithFrame:NSMakeRect(0, 0, 0, 0)]) {
+    progressBar = &progressBarReference;
+
+    [self setIndeterminate:NO];
+    [self setMinValue:0.0];
+    [self setMaxValue:100.0];
+  }
+  return self;
+}
+
+@end
+
+namespace phoenix {
+
+void pProgressBar::setPosition(unsigned position) {
+  @autoreleasepool {
+    [cocoaView setDoubleValue:position];
+  }
+}
+
+void pProgressBar::constructor() {
+  @autoreleasepool {
+    cocoaView = cocoaProgressBar = [[CocoaProgressBar alloc] initWith:progressBar];
+    setPosition(progressBar.state.position);
+  }
+}
+
+void pProgressBar::destructor() {
+  @autoreleasepool {
+    [cocoaView release];
+  }
+}
+
+}
diff -Nru higan/phoenix/cocoa/widget/progress-bar.hpp nSide/phoenix/cocoa/widget/progress-bar.hpp
--- higan/phoenix/cocoa/widget/progress-bar.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/widget/progress-bar.hpp	2015-09-16 13:08:13.598563372 +0900
@@ -0,0 +1,21 @@
+@interface CocoaProgressBar : NSProgressIndicator {
+@public
+  phoenix::ProgressBar* progressBar;
+}
+-(id) initWith:(phoenix::ProgressBar&)progressBar;
+@end
+
+namespace phoenix {
+
+struct pProgressBar : public pWidget {
+  ProgressBar& progressBar;
+  CocoaProgressBar* cocoaProgressBar = nullptr;
+
+  void setPosition(unsigned position);
+
+  pProgressBar(ProgressBar& progressBar) : pWidget(progressBar), progressBar(progressBar) {}
+  void constructor();
+  void destructor();
+};
+
+}
diff -Nru higan/phoenix/cocoa/widget/radio-button.cpp nSide/phoenix/cocoa/widget/radio-button.cpp
--- higan/phoenix/cocoa/widget/radio-button.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/widget/radio-button.cpp	2015-09-16 13:08:13.602563373 +0900
@@ -0,0 +1,94 @@
+@implementation CocoaRadioButton : NSButton
+
+-(id) initWith:(phoenix::RadioButton&)radioButtonReference {
+  if(self = [super initWithFrame:NSMakeRect(0, 0, 0, 0)]) {
+    radioButton = &radioButtonReference;
+
+    [self setTarget:self];
+    [self setAction:@selector(activate:)];
+    [self setBezelStyle:NSRegularSquareBezelStyle];
+    [self setButtonType:NSOnOffButton];
+  }
+  return self;
+}
+
+-(IBAction) activate:(id)sender {
+  bool wasChecked = radioButton->state.checked;
+  radioButton->setChecked();
+  if(wasChecked == false) {
+    if(radioButton->onActivate) radioButton->onActivate();
+  }
+}
+
+@end
+
+namespace phoenix {
+
+Size pRadioButton::minimumSize() {
+  Size size = Font::size(radioButton.font(), radioButton.state.text);
+
+  if(radioButton.state.orientation == Orientation::Horizontal) {
+    size.width += radioButton.state.image.width();
+    size.height = max(radioButton.state.image.height(), size.height);
+  }
+
+  if(radioButton.state.orientation == Orientation::Vertical) {
+    size.width = max(radioButton.state.image.width(), size.width);
+    size.height += radioButton.state.image.height();
+  }
+
+  return {size.width + 20, size.height + 4};
+}
+
+void pRadioButton::setChecked() {
+  @autoreleasepool {
+    for(auto& button : radioButton.state.group) {
+      auto state = (&button == &radioButton) ? NSOnState : NSOffState;
+      [button.p.cocoaView setState:state];
+    }
+  }
+}
+
+void pRadioButton::setGeometry(Geometry geometry) {
+  pWidget::setGeometry({
+    geometry.x - 2, geometry.y - 2,
+    geometry.width + 4, geometry.height + 4
+  });
+}
+
+void pRadioButton::setGroup(const group<RadioButton>& group) {
+}
+
+void pRadioButton::setImage(const image& image, Orientation orientation) {
+  @autoreleasepool {
+    if(image.empty()) {
+      [cocoaView setImage:nil];
+      return;
+    }
+
+    [cocoaView setImage:NSMakeImage(image)];
+
+    if(orientation == Orientation::Horizontal) [cocoaView setImagePosition:NSImageLeft];
+    if(orientation == Orientation::Vertical  ) [cocoaView setImagePosition:NSImageAbove];
+  }
+}
+
+void pRadioButton::setText(string text) {
+  @autoreleasepool {
+    [cocoaView setTitle:[NSString stringWithUTF8String:text]];
+  }
+}
+
+void pRadioButton::constructor() {
+  @autoreleasepool {
+    cocoaView = cocoaRadioButton = [[CocoaRadioButton alloc] initWith:radioButton];
+  }
+}
+
+void pRadioButton::destructor() {
+  @autoreleasepool {
+    [cocoaView release];
+  }
+}
+
+}
diff -Nru higan/phoenix/cocoa/widget/radio-button.hpp nSide/phoenix/cocoa/widget/radio-button.hpp
--- higan/phoenix/cocoa/widget/radio-button.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/widget/radio-button.hpp	2015-09-16 13:08:13.605563373 +0900
@@ -0,0 +1,27 @@
+@interface CocoaRadioButton : NSButton {
+@public
+  phoenix::RadioButton* radioButton;
+}
+-(id) initWith:(phoenix::RadioButton&)radioButton;
+-(IBAction) activate:(id)sender;
+@end
+
+namespace phoenix {
+
+struct pRadioButton : public pWidget {
+  RadioButton& radioButton;
+  CocoaRadioButton* cocoaRadioButton = nullptr;
+
+  Size minimumSize();
+  void setChecked();
+  void setGeometry(Geometry geometry);
+  void setGroup(const group<RadioButton>& group);
+  void setImage(const image& image, Orientation orientation);
+  void setText(string text);
+
+  pRadioButton(RadioButton& radioButton) : pWidget(radioButton), radioButton(radioButton) {}
+  void constructor();
+  void destructor();
+};
+
+}
diff -Nru higan/phoenix/cocoa/widget/radio-label.cpp nSide/phoenix/cocoa/widget/radio-label.cpp
--- higan/phoenix/cocoa/widget/radio-label.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/widget/radio-label.cpp	2015-09-16 13:08:13.604563373 +0900
@@ -0,0 +1,65 @@
+@implementation CocoaRadioLabel : NSButton
+
+-(id) initWith:(phoenix::RadioLabel&)radioLabelReference {
+  if(self = [super initWithFrame:NSMakeRect(0, 0, 0, 0)]) {
+    radioLabel = &radioLabelReference;
+
+    [self setTarget:self];
+    [self setAction:@selector(activate:)];
+    [self setButtonType:NSRadioButton];
+  }
+  return self;
+}
+
+-(IBAction) activate:(id)sender {
+  radioLabel->setChecked();
+  if(radioLabel->onActivate) radioLabel->onActivate();
+}
+
+@end
+
+namespace phoenix {
+
+Size pRadioLabel::minimumSize() {
+  Size size = Font::size(radioLabel.font(), radioLabel.state.text);
+  return {size.width + 22, size.height};
+}
+
+void pRadioLabel::setChecked() {
+  @autoreleasepool {
+    for(auto& item : radioLabel.state.group) {
+      auto state = (&item == &radioLabel) ? NSOnState : NSOffState;
+      [item.p.cocoaView setState:state];
+    }
+  }
+}
+
+void pRadioLabel::setGeometry(Geometry geometry) {
+  pWidget::setGeometry({
+    geometry.x - 1, geometry.y,
+    geometry.width + 2, geometry.height
+  });
+}
+
+void pRadioLabel::setGroup(const group<RadioLabel>& group) {
+}
+
+void pRadioLabel::setText(string text) {
+  @autoreleasepool {
+    [cocoaView setTitle:[NSString stringWithUTF8String:text]];
+  }
+}
+
+void pRadioLabel::constructor() {
+  @autoreleasepool {
+    cocoaView = cocoaRadioLabel = [[CocoaRadioLabel alloc] initWith:radioLabel];
+  }
+}
+
+void pRadioLabel::destructor() {
+  @autoreleasepool {
+    [cocoaView release];
+  }
+}
+
+}
diff -Nru higan/phoenix/cocoa/widget/radio-label.hpp nSide/phoenix/cocoa/widget/radio-label.hpp
--- higan/phoenix/cocoa/widget/radio-label.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/widget/radio-label.hpp	2015-09-16 13:08:13.598563372 +0900
@@ -0,0 +1,26 @@
+@interface CocoaRadioLabel : NSButton {
+@public
+  phoenix::RadioLabel* radioLabel;
+}
+-(id) initWith:(phoenix::RadioLabel&)radioLabel;
+-(IBAction) activate:(id)sender;
+@end
+
+namespace phoenix {
+
+struct pRadioLabel : public pWidget {
+  RadioLabel& radioLabel;
+  CocoaRadioLabel* cocoaRadioLabel = nullptr;
+
+  Size minimumSize();
+  void setChecked();
+  void setGeometry(Geometry geometry);
+  void setGroup(const group<RadioLabel>& group);
+  void setText(string text);
+
+  pRadioLabel(RadioLabel& radioLabel) : pWidget(radioLabel), radioLabel(radioLabel) {}
+  void constructor();
+  void destructor();
+};
+
+}
diff -Nru higan/phoenix/cocoa/widget/sizable.hpp nSide/phoenix/cocoa/widget/sizable.hpp
--- higan/phoenix/cocoa/widget/sizable.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/widget/sizable.hpp	2015-09-16 13:08:13.602563373 +0900
@@ -0,0 +1,9 @@
+namespace phoenix {
+
+struct pSizable : public pObject {
+  Sizable& sizable;
+
+  pSizable(Sizable& sizable) : pObject(sizable), sizable(sizable) {}
+};
+
+}
diff -Nru higan/phoenix/cocoa/widget/tab-frame.cpp nSide/phoenix/cocoa/widget/tab-frame.cpp
--- higan/phoenix/cocoa/widget/tab-frame.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/widget/tab-frame.cpp	2015-09-16 13:08:13.603563373 +0900
@@ -0,0 +1,145 @@
+@implementation CocoaTabFrame : NSTabView
+
+-(id) initWith:(phoenix::TabFrame&)tabFrameReference {
+  if(self = [super initWithFrame:NSMakeRect(0, 0, 0, 0)]) {
+    tabFrame = &tabFrameReference;
+
+    [self setDelegate:self];
+  }
+  return self;
+}
+
+-(void) tabView:(NSTabView*)tabView didSelectTabViewItem:(NSTabViewItem*)tabViewItem {
+  tabFrame->state.selection = [tabView indexOfTabViewItem:tabViewItem];
+  tabFrame->p.synchronizeLayout();
+  if(tabFrame->onChange) tabFrame->onChange();
+}
+
+@end
+
+@implementation CocoaTabFrameItem : NSTabViewItem
+
+-(id) initWith:(phoenix::TabFrame&)tabFrameReference {
+  if(self = [super initWithIdentifier:nil]) {
+    tabFrame = &tabFrameReference;
+    cocoaTabFrame = tabFrame->p.cocoaTabFrame;
+  }
+  return self;
+}
+
+-(NSSize) sizeOfLabel:(BOOL)shouldTruncateLabel {
+  NSSize sizeOfLabel = [super sizeOfLabel:shouldTruncateLabel];
+  signed selection = [cocoaTabFrame indexOfTabViewItem:self];
+  if(selection < 0) return sizeOfLabel;  //should never happen
+  if(tabFrame->state.image[selection].empty() == false) {
+    unsigned iconSize = phoenix::Font::size(tabFrame->font(), " ").height;
+    sizeOfLabel.width += iconSize + 2;
+  }
+  return sizeOfLabel;
+}
+
+-(void) drawLabel:(BOOL)shouldTruncateLabel inRect:(NSRect)tabRect {
+  signed selection = [cocoaTabFrame indexOfTabViewItem:self];
+  if(selection >= 0 && tabFrame->state.image[selection].empty() == false) {
+    unsigned iconSize = phoenix::Font::size(tabFrame->font(), " ").height;
+    NSImage* image = NSMakeImage(tabFrame->state.image[selection]);
+
+    [[NSGraphicsContext currentContext] saveGraphicsState];
+    NSRect targetRect = NSMakeRect(tabRect.origin.x, tabRect.origin.y + 2, iconSize, iconSize);
+    [image drawInRect:targetRect fromRect:NSZeroRect operation:NSCompositeSourceOver fraction:1.0 respectFlipped:YES hints:nil];
+    [[NSGraphicsContext currentContext] restoreGraphicsState];
+
+    tabRect.origin.x += iconSize + 2;
+    tabRect.size.width -= iconSize + 2;
+  }
+  [super drawLabel:shouldTruncateLabel inRect:tabRect];
+}
+
+@end
+
+namespace phoenix {
+
+void pTabFrame::append(string text, const image& image) {
+  @autoreleasepool {
+    CocoaTabFrameItem* item = [[CocoaTabFrameItem alloc] initWith:tabFrame];
+    [item setLabel:[NSString stringWithUTF8String:text]];
+    [cocoaView addTabViewItem:item];
+    tabs.append(item);
+  }
+}
+
+void pTabFrame::remove(unsigned selection) {
+  @autoreleasepool {
+    CocoaTabFrameItem* item = tabs[selection];
+    [cocoaView removeTabViewItem:item];
+    tabs.remove(selection);
+  }
+}
+
+void pTabFrame::setEnabled(bool enabled) {
+  for(auto& layout : tabFrame.state.layout) {
+    if(layout) layout->setEnabled(layout->enabled());
+  }
+  pWidget::setEnabled(enabled);
+}
+
+void pTabFrame::setGeometry(Geometry geometry) {
+  pWidget::setGeometry({
+    geometry.x - 7, geometry.y - 5,
+    geometry.width + 14, geometry.height + 6
+  });
+  geometry.x += 1, geometry.width -= 2;
+  geometry.y += 22, geometry.height -= 32;
+  for(auto& layout : tabFrame.state.layout) {
+    if(layout == nullptr) continue;
+    layout->setGeometry(geometry);
+  }
+  synchronizeLayout();
+}
+
+void pTabFrame::setImage(unsigned selection, const image& image) {
+}
+
+void pTabFrame::setSelection(unsigned selection) {
+  @autoreleasepool {
+    CocoaTabFrameItem* item = tabs[selection];
+    [cocoaView selectTabViewItem:item];
+  }
+  synchronizeLayout();
+}
+
+void pTabFrame::setText(unsigned selection, string text) {
+  @autoreleasepool {
+    CocoaTabFrameItem* item = tabs[selection];
+    [item setLabel:[NSString stringWithUTF8String:text]];
+  }
+}
+
+void pTabFrame::setVisible(bool visible) {
+  for(auto& layout : tabFrame.state.layout) {
+    if(layout) layout->setVisible(layout->visible());
+  }
+  pWidget::setVisible(visible);
+}
+
+void pTabFrame::constructor() {
+  @autoreleasepool {
+    cocoaView = cocoaTabFrame = [[CocoaTabFrame alloc] initWith:tabFrame];
+  }
+}
+
+void pTabFrame::destructor() {
+  @autoreleasepool {
+    [cocoaView release];
+  }
+}
+
+void pTabFrame::synchronizeLayout() {
+  unsigned selection = 0;
+  for(auto& layout : tabFrame.state.layout) {
+    if(layout) layout->setVisible(selection == tabFrame.state.selection);
+    selection++;
+  }
+}
+
+}
diff -Nru higan/phoenix/cocoa/widget/tab-frame.hpp nSide/phoenix/cocoa/widget/tab-frame.hpp
--- higan/phoenix/cocoa/widget/tab-frame.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/widget/tab-frame.hpp	2015-09-16 13:08:13.601563373 +0900
@@ -0,0 +1,41 @@
+@interface CocoaTabFrame : NSTabView <NSTabViewDelegate> {
+@public
+  phoenix::TabFrame* tabFrame;
+}
+-(id) initWith:(phoenix::TabFrame&)tabFrame;
+-(void) tabView:(NSTabView*)tabView didSelectTabViewItem:(NSTabViewItem*)tabViewItem;
+@end
+
+@interface CocoaTabFrameItem : NSTabViewItem {
+@public
+  phoenix::TabFrame* tabFrame;
+  CocoaTabFrame* cocoaTabFrame;
+}
+-(id) initWith:(phoenix::TabFrame&)tabFrame;
+-(NSSize) sizeOfLabel:(BOOL)shouldTruncateLabel;
+-(void) drawLabel:(BOOL)shouldTruncateLabel inRect:(NSRect)tabRect;
+@end
+
+namespace phoenix {
+
+struct pTabFrame : public pWidget {
+  TabFrame& tabFrame;
+  CocoaTabFrame* cocoaTabFrame = nullptr;
+  vector<CocoaTabFrameItem*> tabs;
+
+  void append(string text, const image& image);
+  void remove(unsigned selection);
+  void setEnabled(bool enabled);
+  void setGeometry(Geometry geometry);
+  void setImage(unsigned selection, const image& image);
+  void setSelection(unsigned selection);
+  void setText(unsigned selection, string text);
+  void setVisible(bool visible);
+
+  pTabFrame(TabFrame& tabFrame) : pWidget(tabFrame), tabFrame(tabFrame) {}
+  void constructor();
+  void destructor();
+  void synchronizeLayout();
+};
+
+}
diff -Nru higan/phoenix/cocoa/widget/text-edit.cpp nSide/phoenix/cocoa/widget/text-edit.cpp
--- higan/phoenix/cocoa/widget/text-edit.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/widget/text-edit.cpp	2015-09-16 13:08:13.603563373 +0900
@@ -0,0 +1,107 @@
+@implementation CocoaTextEdit : NSScrollView
+
+-(id) initWith:(phoenix::TextEdit&)textEditReference {
+  if(self = [super initWithFrame:NSMakeRect(0, 0, 0, 0)]) {
+    textEdit = &textEditReference;
+
+    content = [[[NSTextView alloc] initWithFrame:NSMakeRect(0, 0, 0, 0)] autorelease];
+    [content setDelegate:self];
+    [content setRichText:NO];
+
+    [self setBorderType:NSBezelBorder];
+    [self setDocumentView:content];
+    [self configure];
+  }
+  return self;
+}
+
+-(NSTextView*) content {
+  return content;
+}
+
+-(void) configure {
+  [content setMinSize:NSMakeSize(0, 0)];
+  [content setMaxSize:NSMakeSize(FLT_MAX, FLT_MAX)];
+
+  [[content textContainer] setContainerSize:NSMakeSize(FLT_MAX, FLT_MAX)];
+  [[content textContainer] setWidthTracksTextView:textEdit->wordWrap()];
+
+  [content setHorizontallyResizable:YES];
+  [content setVerticallyResizable:YES];
+  [content setAutoresizingMask:NSViewNotSizable];
+
+  [self setHasHorizontalScroller:!textEdit->wordWrap()];
+  [self setHasVerticalScroller:YES];
+}
+
+-(void) textDidChange:(NSNotification*)notification {
+  textEdit->state.text = [[content string] UTF8String];
+  if(textEdit->onChange) textEdit->onChange();
+}
+
+@end
+
+namespace phoenix {
+
+void pTextEdit::setBackgroundColor(Color color) {
+}
+
+void pTextEdit::setCursorPosition(unsigned position) {
+  @autoreleasepool {
+    string text = [[[cocoaView content] string] UTF8String];
+    position = min(position, text.length());
+    [[cocoaView content] setSelectedRange:NSMakeRange(position, 0)];
+  }
+}
+
+void pTextEdit::setEditable(bool editable) {
+  @autoreleasepool {
+    [[cocoaView content] setEditable:editable];
+  }
+}
+
+void pTextEdit::setFont(string font) {
+  @autoreleasepool {
+    [[cocoaView content] setFont:pFont::cocoaFont(font)];
+  }
+}
+
+void pTextEdit::setForegroundColor(Color color) {
+}
+
+void pTextEdit::setText(string text) {
+  @autoreleasepool {
+    [[cocoaView content] setString:[NSString stringWithUTF8String:text]];
+  }
+}
+
+void pTextEdit::setWordWrap(bool wordWrap) {
+  @autoreleasepool {
+    [cocoaView configure];
+  }
+}
+
+string pTextEdit::text() {
+  @autoreleasepool {
+    return [[[cocoaView content] string] UTF8String];
+  }
+}
+
+void pTextEdit::constructor() {
+  @autoreleasepool {
+    cocoaView = cocoaTextEdit = [[CocoaTextEdit alloc] initWith:textEdit];
+    setEditable(textEdit.state.editable);
+    setWordWrap(textEdit.state.wordWrap);
+    setFont(textEdit.font());
+    setText(textEdit.state.text);
+    setCursorPosition(textEdit.state.cursorPosition);
+  }
+}
+
+void pTextEdit::destructor() {
+  @autoreleasepool {
+    [cocoaView release];
+  }
+}
+
+}
diff -Nru higan/phoenix/cocoa/widget/text-edit.hpp nSide/phoenix/cocoa/widget/text-edit.hpp
--- higan/phoenix/cocoa/widget/text-edit.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/widget/text-edit.hpp	2015-09-16 13:08:13.601563373 +0900
@@ -0,0 +1,32 @@
+@interface CocoaTextEdit : NSScrollView <NSTextViewDelegate> {
+@public
+  phoenix::TextEdit* textEdit;
+  NSTextView* content;
+}
+-(id) initWith:(phoenix::TextEdit&)textEdit;
+-(NSTextView*) content;
+-(void) configure;
+-(void) textDidChange:(NSNotification*)notification;
+@end
+
+namespace phoenix {
+
+struct pTextEdit : public pWidget {
+  TextEdit& textEdit;
+  CocoaTextEdit* cocoaTextEdit = nullptr;
+
+  void setBackgroundColor(Color color);
+  void setCursorPosition(unsigned position);
+  void setEditable(bool editable);
+  void setFont(string font);
+  void setForegroundColor(Color color);
+  void setText(string text);
+  void setWordWrap(bool wordWrap);
+  string text();
+
+  pTextEdit(TextEdit& textEdit) : pWidget(textEdit), textEdit(textEdit) {}
+  void constructor();
+  void destructor();
+};
+
+}
diff -Nru higan/phoenix/cocoa/widget/vertical-scroller.cpp nSide/phoenix/cocoa/widget/vertical-scroller.cpp
--- higan/phoenix/cocoa/widget/vertical-scroller.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/widget/vertical-scroller.cpp	2015-09-16 13:08:13.604563373 +0900
@@ -0,0 +1,85 @@
+@implementation CocoaVerticalScroller : NSScroller
+
+-(id) initWith:(phoenix::VerticalScroller&)verticalScrollerReference {
+  if(self = [super initWithFrame:NSMakeRect(0, 0, 0, 1)]) {
+    verticalScroller = &verticalScrollerReference;
+
+    [self setTarget:self];
+    [self setAction:@selector(scroll:)];
+
+    [self setControlSize:NSRegularControlSize];
+    [self setScrollerStyle:NSScrollerStyleLegacy];
+    [self setEnabled:YES];
+
+    [self update];
+  }
+  return self;
+}
+
+-(void) update {
+  double d = 1.0 / verticalScroller->state.length;
+  double f = d * verticalScroller->state.position;
+
+  [self setDoubleValue:f];
+  [self setKnobProportion:d];
+}
+
+-(IBAction) scroll:(id)sender {
+  auto& state = verticalScroller->state;
+
+  switch([self hitPart]) {
+  case NSScrollerIncrementLine:
+  case NSScrollerIncrementPage:
+    if(state.position < state.length - 1) state.position++;
+    [self update];
+    break;
+
+  case NSScrollerDecrementLine:
+  case NSScrollerDecrementPage:
+    if(state.position) state.position--;
+    [self update];
+    break;
+
+  case NSScrollerKnob:
+    state.position = [self doubleValue] * state.length;
+    break;
+  }
+
+  if(verticalScroller->onChange) verticalScroller->onChange();
+}
+
+@end
+
+namespace phoenix {
+
+Size pVerticalScroller::minimumSize() {
+  @autoreleasepool {
+    return {[NSScroller scrollerWidthForControlSize:NSRegularControlSize scrollerStyle:NSScrollerStyleLegacy], 32};
+  }
+}
+
+void pVerticalScroller::setLength(unsigned length) {
+  @autoreleasepool {
+    [cocoaView update];
+  }
+}
+
+void pVerticalScroller::setPosition(unsigned position) {
+  @autoreleasepool {
+    [cocoaView update];
+  }
+}
+
+void pVerticalScroller::constructor() {
+  @autoreleasepool {
+    cocoaView = cocoaVerticalScroller = [[CocoaVerticalScroller alloc] initWith:verticalScroller];
+  }
+}
+
+void pVerticalScroller::destructor() {
+  @autoreleasepool {
+    [cocoaView release];
+  }
+}
+
+}
diff -Nru higan/phoenix/cocoa/widget/vertical-scroller.hpp nSide/phoenix/cocoa/widget/vertical-scroller.hpp
--- higan/phoenix/cocoa/widget/vertical-scroller.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/widget/vertical-scroller.hpp	2015-09-16 13:08:13.598563372 +0900
@@ -0,0 +1,25 @@
+@interface CocoaVerticalScroller : NSScroller {
+@public
+  phoenix::VerticalScroller* verticalScroller;
+}
+-(id) initWith:(phoenix::VerticalScroller&)verticalScroller;
+-(void) update;
+-(IBAction) scroll:(id)sender;
+@end
+
+namespace phoenix {
+
+struct pVerticalScroller : public pWidget {
+  VerticalScroller& verticalScroller;
+  CocoaVerticalScroller* cocoaVerticalScroller = nullptr;
+
+  Size minimumSize();
+  void setLength(unsigned length);
+  void setPosition(unsigned position);
+
+  pVerticalScroller(VerticalScroller& verticalScroller) : pWidget(verticalScroller), verticalScroller(verticalScroller) {}
+  void constructor();
+  void destructor();
+};
+
+}
diff -Nru higan/phoenix/cocoa/widget/vertical-slider.cpp nSide/phoenix/cocoa/widget/vertical-slider.cpp
--- higan/phoenix/cocoa/widget/vertical-slider.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/widget/vertical-slider.cpp	2015-09-16 13:08:13.605563373 +0900
@@ -0,0 +1,61 @@
+@implementation CocoaVerticalSlider : NSSlider
+
+-(id) initWith:(phoenix::VerticalSlider&)verticalSliderReference {
+  if(self = [super initWithFrame:NSMakeRect(0, 0, 0, 1)]) {
+    verticalSlider = &verticalSliderReference;
+
+    [self setTarget:self];
+    [self setAction:@selector(activate:)];
+    [self setMinValue:0];
+  }
+  return self;
+}
+
+-(IBAction) activate:(id)sender {
+  verticalSlider->state.position = [self doubleValue];
+  if(verticalSlider->onChange) verticalSlider->onChange();
+}
+
+@end
+
+namespace phoenix {
+
+Size pVerticalSlider::minimumSize() {
+  return {20, 48};
+}
+
+void pVerticalSlider::setGeometry(Geometry geometry) {
+  pWidget::setGeometry({
+    geometry.x, geometry.y - 2,
+    geometry.width, geometry.height + 4
+  });
+}
+
+void pVerticalSlider::setLength(unsigned length) {
+  @autoreleasepool {
+    [cocoaView setMaxValue:length];
+  }
+}
+
+void pVerticalSlider::setPosition(unsigned position) {
+  @autoreleasepool {
+    [cocoaView setDoubleValue:position];
+  }
+}
+
+void pVerticalSlider::constructor() {
+  @autoreleasepool {
+    cocoaView = cocoaVerticalSlider = [[CocoaVerticalSlider alloc] initWith:verticalSlider];
+
+    setLength(verticalSlider.state.length);
+    setPosition(verticalSlider.state.position);
+  }
+}
+
+void pVerticalSlider::destructor() {
+  @autoreleasepool {
+    [cocoaView release];
+  }
+}
+
+}
diff -Nru higan/phoenix/cocoa/widget/vertical-slider.hpp nSide/phoenix/cocoa/widget/vertical-slider.hpp
--- higan/phoenix/cocoa/widget/vertical-slider.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/widget/vertical-slider.hpp	2015-09-16 13:08:13.598563372 +0900
@@ -0,0 +1,25 @@
+@interface CocoaVerticalSlider : NSSlider {
+@public
+  phoenix::VerticalSlider* verticalSlider;
+}
+-(id) initWith:(phoenix::VerticalSlider&)verticalSlider;
+-(IBAction) activate:(id)sender;
+@end
+
+namespace phoenix {
+
+struct pVerticalSlider : public pWidget {
+  VerticalSlider& verticalSlider;
+  CocoaVerticalSlider* cocoaVerticalSlider = nullptr;
+
+  Size minimumSize();
+  void setGeometry(Geometry geometry);
+  void setLength(unsigned length);
+  void setPosition(unsigned position);
+
+  pVerticalSlider(VerticalSlider& verticalSlider) : pWidget(verticalSlider), verticalSlider(verticalSlider) {}
+  void constructor();
+  void destructor();
+};
+
+}
diff -Nru higan/phoenix/cocoa/widget/viewport.cpp nSide/phoenix/cocoa/widget/viewport.cpp
--- higan/phoenix/cocoa/widget/viewport.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/widget/viewport.cpp	2015-09-16 13:08:13.604563373 +0900
@@ -0,0 +1,66 @@
+@implementation CocoaViewport : NSView
+
+-(id) initWith:(phoenix::Viewport&)viewportReference {
+  if(self = [super initWithFrame:NSMakeRect(0, 0, 0, 0)]) {
+    viewport = &viewportReference;
+  }
+  return self;
+}
+
+-(void) drawRect:(NSRect)rect {
+  [[NSColor blackColor] setFill];
+  NSRectFillUsingOperation(rect, NSCompositeSourceOver);
+}
+
+-(BOOL) acceptsFirstResponder {
+  return YES;
+}
+
+-(NSDragOperation) draggingEntered:(id<NSDraggingInfo>)sender {
+  return DropPathsOperation(sender);
+}
+
+-(BOOL) performDragOperation:(id<NSDraggingInfo>)sender {
+  lstring paths = DropPaths(sender);
+  if(paths.empty()) return NO;
+  if(viewport->onDrop) viewport->onDrop(paths);
+  return YES;
+}
+
+-(void) keyDown:(NSEvent*)event {
+}
+
+-(void) keyUp:(NSEvent*)event {
+}
+
+@end
+
+namespace phoenix {
+
+uintptr_t pViewport::handle() {
+  return (uintptr_t)cocoaViewport;
+}
+
+void pViewport::setDroppable(bool droppable) {
+  @autoreleasepool {
+    if(droppable) {
+      [cocoaViewport registerForDraggedTypes:[NSArray arrayWithObject:NSFilenamesPboardType]];
+    } else {
+      [cocoaViewport unregisterDraggedTypes];
+    }
+  }
+}
+
+void pViewport::constructor() {
+  @autoreleasepool {
+    cocoaView = cocoaViewport = [[CocoaViewport alloc] initWith:viewport];
+  }
+}
+
+void pViewport::destructor() {
+  @autoreleasepool {
+    [cocoaView release];
+  }
+}
+
+}
diff -Nru higan/phoenix/cocoa/widget/viewport.hpp nSide/phoenix/cocoa/widget/viewport.hpp
--- higan/phoenix/cocoa/widget/viewport.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/widget/viewport.hpp	2015-09-16 13:08:13.601563373 +0900
@@ -0,0 +1,28 @@
+@interface CocoaViewport : NSView {
+@public
+  phoenix::Viewport* viewport;
+}
+-(id) initWith:(phoenix::Viewport&)viewport;
+-(void) drawRect:(NSRect)rect;
+-(BOOL) acceptsFirstResponder;
+-(NSDragOperation) draggingEntered:(id<NSDraggingInfo>)sender;
+-(BOOL) performDragOperation:(id<NSDraggingInfo>)sender;
+-(void) keyDown:(NSEvent*)event;
+-(void) keyUp:(NSEvent*)event;
+@end
+
+namespace phoenix {
+
+struct pViewport : public pWidget {
+  Viewport& viewport;
+  CocoaViewport* cocoaViewport = nullptr;
+
+  uintptr_t handle();
+  void setDroppable(bool droppable);
+
+  pViewport(Viewport& viewport) : pWidget(viewport), viewport(viewport) {}
+  void constructor();
+  void destructor();
+};
+
+}
diff -Nru higan/phoenix/cocoa/widget/widget.cpp nSide/phoenix/cocoa/widget/widget.cpp
--- higan/phoenix/cocoa/widget/widget.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/widget/widget.cpp	2015-09-16 13:08:13.599563372 +0900
@@ -0,0 +1,79 @@
+namespace phoenix {
+
+bool pWidget::enabled() {
+  @autoreleasepool {
+    return [cocoaView respondsToSelector:@selector(enabled)] && [cocoaView enabled];
+  }
+}
+
+bool pWidget::focused() {
+  @autoreleasepool {
+    return cocoaView == [[cocoaView window] firstResponder];
+  }
+}
+
+Size pWidget::minimumSize() {
+  return {0, 0};
+}
+
+void pWidget::setEnabled(bool enabled) {
+  if(!widget.parent()) enabled = false;
+  if(widget.state.abstract) enabled = false;
+  if(!widget.enabledToAll()) enabled = false;
+
+  @autoreleasepool {
+    if([cocoaView respondsToSelector:@selector(setEnabled:)]) {
+      [cocoaView setEnabled:enabled];
+    }
+  }
+}
+
+void pWidget::setFocused() {
+  @autoreleasepool {
+    [[cocoaView window] makeFirstResponder:cocoaView];
+  }
+}
+
+void pWidget::setFont(string font) {
+  @autoreleasepool {
+    if([cocoaView respondsToSelector:@selector(setFont:)]) {
+      [cocoaView setFont:pFont::cocoaFont(font)];
+    }
+  }
+}
+
+void pWidget::setGeometry(Geometry geometry) {
+  @autoreleasepool {
+    CGFloat windowHeight = [[cocoaView superview] frame].size.height;
+    [cocoaView setFrame:NSMakeRect(geometry.x, windowHeight - geometry.y - geometry.height, geometry.width, geometry.height)];
+    [[cocoaView superview] setNeedsDisplay:YES];
+  }
+  if(widget.onSize) widget.onSize();
+}
+
+void pWidget::setVisible(bool visible) {
+  if(!widget.parent()) visible = false;
+  if(widget.state.abstract) visible = false;
+  if(!widget.visibleToAll()) visible = false;
+
+  @autoreleasepool {
+    [cocoaView setHidden:!visible];
+  }
+}
+
+void pWidget::constructor() {
+  if(!widget.state.abstract) return;
+
+  @autoreleasepool {
+    cocoaView = [[NSView alloc] initWithFrame:NSMakeRect(0, 0, 0, 0)];
+    [cocoaView setHidden:true];
+  }
+}
+
+void pWidget::destructor() {
+  @autoreleasepool {
+    [cocoaView release];
+  }
+}
+
+}
diff -Nru higan/phoenix/cocoa/widget/widget.hpp nSide/phoenix/cocoa/widget/widget.hpp
--- higan/phoenix/cocoa/widget/widget.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/widget/widget.hpp	2015-09-16 13:08:13.601563373 +0900
@@ -0,0 +1,21 @@
+namespace phoenix {
+
+struct pWidget : public pSizable {
+  Widget& widget;
+  NSView* cocoaView = nullptr;
+
+  bool enabled();
+  bool focused();
+  virtual Size minimumSize();
+  virtual void setEnabled(bool enabled);
+  void setFocused();
+  virtual void setFont(string font);
+  virtual void setGeometry(Geometry geometry);
+  virtual void setVisible(bool visible);
+
+  pWidget(Widget& widget) : pSizable(widget), widget(widget) {}
+  void constructor();
+  void destructor();
+};
+
+}
diff -Nru higan/phoenix/cocoa/window.cpp nSide/phoenix/cocoa/window.cpp
--- higan/phoenix/cocoa/window.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/window.cpp	2015-09-16 13:08:13.617563374 +0900
@@ -0,0 +1,415 @@
+@implementation CocoaWindow : NSWindow
+
+-(id) initWith:(phoenix::Window&)windowReference {
+  window = &windowReference;
+
+  NSUInteger style = NSTitledWindowMask | NSClosableWindowMask | NSMiniaturizableWindowMask;
+  if(window->state.resizable) style |= NSResizableWindowMask;
+
+  if(self = [super initWithContentRect:NSMakeRect(0, 0, 640, 480) styleMask:style backing:NSBackingStoreBuffered defer:YES]) {
+    [self setDelegate:self];
+    [self setReleasedWhenClosed:NO];
+    [self setAcceptsMouseMovedEvents:YES];
+    [self setTitle:@""];
+
+    NSBundle* bundle = [NSBundle mainBundle];
+    NSDictionary* dictionary = [bundle infoDictionary];
+    NSString* applicationName = [dictionary objectForKey:@"CFBundleDisplayName"];
+    if(applicationName == nil) applicationName = [NSString stringWithUTF8String:phoenix::applicationState.name];
+
+    menuBar = [[NSMenu alloc] init];
+
+    NSMenuItem* item;
+    string text;
+
+    rootMenu = [[NSMenu alloc] init];
+    item = [[[NSMenuItem alloc] initWithTitle:@"" action:nil keyEquivalent:@""] autorelease];
+    [item setSubmenu:rootMenu];
+    [menuBar addItem:item];
+
+    item = [[[NSMenuItem alloc] initWithTitle:[NSString stringWithFormat:@"About %@ ...", applicationName] action:@selector(menuAbout) keyEquivalent:@""] autorelease];
+    [item setTarget:self];
+    [rootMenu addItem:item];
+    [rootMenu addItem:[NSMenuItem separatorItem]];
+
+    item = [[[NSMenuItem alloc] initWithTitle:@"Preferences" action:@selector(menuPreferences) keyEquivalent:@""] autorelease];
+    [item setTarget:self];
+    [rootMenu addItem:item];
+    [rootMenu addItem:[NSMenuItem separatorItem]];
+
+    NSMenu* servicesMenu = [[[NSMenu alloc] initWithTitle:@"Services"] autorelease];
+    item = [[[NSMenuItem alloc] initWithTitle:@"Services" action:nil keyEquivalent:@""] autorelease];
+    [item setTarget:self];
+    [item setSubmenu:servicesMenu];
+    [rootMenu addItem:item];
+    [rootMenu addItem:[NSMenuItem separatorItem]];
+    [NSApp setServicesMenu:servicesMenu];
+
+    item = [[[NSMenuItem alloc] initWithTitle:[NSString stringWithFormat:@"Hide %@", applicationName] action:@selector(hide:) keyEquivalent:@""] autorelease];
+    [item setTarget:NSApp];
+    [rootMenu addItem:item];
+
+    item = [[[NSMenuItem alloc] initWithTitle:@"Hide Others" action:@selector(hideOtherApplications:) keyEquivalent:@""] autorelease];
+    [item setTarget:NSApp];
+    [rootMenu addItem:item];
+
+    item = [[[NSMenuItem alloc] initWithTitle:@"Show All" action:@selector(unhideAllApplications:) keyEquivalent:@""] autorelease];
+    [item setTarget:NSApp];
+    [rootMenu addItem:item];
+    [rootMenu addItem:[NSMenuItem separatorItem]];
+
+    item = [[[NSMenuItem alloc] initWithTitle:[NSString stringWithFormat:@"Quit %@", applicationName] action:@selector(menuQuit) keyEquivalent:@""] autorelease];
+    [item setTarget:self];
+    [rootMenu addItem:item];
+
+    statusBar = [[NSTextField alloc] initWithFrame:NSMakeRect(0, 0, 0, 0)];
+    [statusBar setAlignment:NSLeftTextAlignment];
+    [statusBar setBordered:YES];
+    [statusBar setBezeled:YES];
+    [statusBar setBezelStyle:NSTextFieldSquareBezel];
+    [statusBar setEditable:NO];
+    [statusBar setHidden:YES];
+
+    [[self contentView] addSubview:statusBar positioned:NSWindowBelow relativeTo:nil];
+  }
+
+  return self;
+}
+
+-(BOOL) canBecomeKeyWindow {
+  return YES;
+}
+
+-(BOOL) canBecomeMainWindow {
+  return YES;
+}
+
+-(void) windowDidBecomeMain:(NSNotification*)notification {
+  if(window->state.menu.size() > 0) {
+    [NSApp setMainMenu:menuBar];
+  }
+}
+
+-(void) windowDidMove:(NSNotification*)notification {
+  window->p.moveEvent();
+}
+
+-(void) windowDidResize:(NSNotification*)notification {
+  window->p.sizeEvent();
+}
+
+-(BOOL) windowShouldClose:(id)sender {
+  if(window->onClose) window->onClose();
+  else window->setVisible(false);
+  if(window->state.modal && !window->visible()) window->setModal(false);
+  return NO;
+}
+
+-(NSDragOperation) draggingEntered:(id<NSDraggingInfo>)sender {
+  return DropPathsOperation(sender);
+}
+
+-(BOOL) performDragOperation:(id<NSDraggingInfo>)sender {
+  lstring paths = DropPaths(sender);
+  if(paths.empty()) return NO;
+  if(window->onDrop) window->onDrop(paths);
+  return YES;
+}
+
+-(NSMenu*) menuBar {
+  return menuBar;
+}
+
+-(void) menuAbout {
+  using phoenix::Application;
+  if(Application::Cocoa::onAbout) Application::Cocoa::onAbout();
+}
+
+-(void) menuPreferences {
+  using phoenix::Application;
+  if(Application::Cocoa::onPreferences) Application::Cocoa::onPreferences();
+}
+
+-(void) menuQuit {
+  using phoenix::Application;
+  if(Application::Cocoa::onQuit) Application::Cocoa::onQuit();
+}
+
+-(NSTextField*) statusBar {
+  return statusBar;
+}
+
+@end
+
+namespace phoenix {
+
+Window& pWindow::none() {
+  static Window* window = nullptr;
+  if(window == nullptr) window = new Window;
+  return *window;
+}
+
+void pWindow::append(Layout& layout) {
+  Geometry geometry = window.state.geometry;
+  geometry.x = geometry.y = 0;
+  layout.setGeometry(geometry);
+
+  statusBarReposition();
+}
+
+void pWindow::append(Menu& menu) {
+  @autoreleasepool {
+    [[cocoaWindow menuBar] addItem:menu.p.cocoaAction];
+  }
+}
+
+void pWindow::append(Widget& widget) {
+  if(widget.font().empty() && !window.state.widgetFont.empty()) {
+    widget.setFont(window.state.widgetFont);
+  }
+
+  @autoreleasepool {
+    [widget.p.cocoaView removeFromSuperview];
+    [[cocoaWindow contentView] addSubview:widget.p.cocoaView positioned:NSWindowAbove relativeTo:nil];
+    widget.p.setGeometry(widget.geometry());
+    [[cocoaWindow contentView] setNeedsDisplay:YES];
+  }
+}
+
+bool pWindow::focused() {
+  @autoreleasepool {
+    return [cocoaWindow isMainWindow] == YES;
+  }
+}
+
+Geometry pWindow::frameMargin() {
+  @autoreleasepool {
+    NSRect frame = [cocoaWindow frameRectForContentRect:NSMakeRect(0, 0, 640, 480)];
+    return {abs(frame.origin.x), frame.size.height - 480, frame.size.width - 640, abs(frame.origin.y)};
+  }
+}
+
+Geometry pWindow::geometry() {
+  @autoreleasepool {
+    NSRect area = [cocoaWindow contentRectForFrameRect:[cocoaWindow frame]];
+    area.size.height -= statusBarHeight();
+    return {area.origin.x, Desktop::size().height - area.origin.y - area.size.height, area.size.width, area.size.height};
+  }
+}
+
+void pWindow::remove(Layout& layout) {
+  @autoreleasepool {
+    [[cocoaWindow contentView] setNeedsDisplay:YES];
+  }
+}
+
+void pWindow::remove(Menu& menu) {
+  @autoreleasepool {
+    [[cocoaWindow menuBar] removeItem:menu.p.cocoaAction];
+  }
+}
+
+void pWindow::remove(Widget& widget) {
+  @autoreleasepool {
+    [widget.p.cocoaView removeFromSuperview];
+    [[cocoaWindow contentView] setNeedsDisplay:YES];
+  }
+}
+
+void pWindow::setBackgroundColor(Color color) {
+  @autoreleasepool {
+    [cocoaWindow
+      setBackgroundColor:[NSColor
+        colorWithCalibratedRed:color.red / 255.0
+        green:color.green / 255.0
+        blue:color.blue / 255.0
+        alpha:color.alpha / 255.0
+      ]
+    ];
+  }
+}
+
+void pWindow::setDroppable(bool droppable) {
+  @autoreleasepool {
+    if(droppable) {
+      [cocoaWindow registerForDraggedTypes:[NSArray arrayWithObject:NSFilenamesPboardType]];
+    } else {
+      [cocoaWindow unregisterDraggedTypes];
+    }
+  }
+}
+
+void pWindow::setFocused() {
+  @autoreleasepool {
+    [cocoaWindow makeKeyAndOrderFront:nil];
+  }
+}
+
+void pWindow::setFullScreen(bool fullScreen) {
+  @autoreleasepool {
+    if(fullScreen == true) {
+      [NSApp setPresentationOptions:NSApplicationPresentationFullScreen];
+      [cocoaWindow setCollectionBehavior:NSWindowCollectionBehaviorFullScreenPrimary];
+      [cocoaWindow toggleFullScreen:nil];
+    } else {
+      [cocoaWindow toggleFullScreen:nil];
+      [cocoaWindow setCollectionBehavior:NSWindowCollectionBehaviorDefault];
+      [NSApp setPresentationOptions:NSApplicationPresentationDefault];
+    }
+  }
+}
+
+void pWindow::setGeometry(Geometry geometry) {
+  locked = true;
+
+  @autoreleasepool {
+    [cocoaWindow
+      setFrame:[cocoaWindow
+        frameRectForContentRect:NSMakeRect(
+          geometry.x, Desktop::size().height - geometry.y - geometry.height,
+          geometry.width, geometry.height + statusBarHeight()
+        )
+      ]
+      display:YES
+    ];
+
+    for(auto& layout : window.state.layout) {
+      Geometry geometry = this->geometry();
+      geometry.x = geometry.y = 0;
+      layout.setGeometry(geometry);
+    }
+
+    statusBarReposition();
+  }
+
+  locked = false;
+}
+
+void pWindow::setMenuFont(string font) {
+}
+
+void pWindow::setMenuVisible(bool visible) {
+}
+
+void pWindow::setModal(bool modal) {
+  @autoreleasepool {
+    if(modal == true) {
+      [NSApp runModalForWindow:cocoaWindow];
+    } else {
+      [NSApp stopModal];
+      NSEvent* event = [NSEvent otherEventWithType:NSApplicationDefined location:NSMakePoint(0, 0) modifierFlags:0 timestamp:0.0 windowNumber:0 context:nil subtype:0 data1:0 data2:0];
+      [NSApp postEvent:event atStart:true];
+    }
+  }
+}
+
+void pWindow::setResizable(bool resizable) {
+  @autoreleasepool {
+    NSUInteger style = NSTitledWindowMask | NSClosableWindowMask | NSMiniaturizableWindowMask;
+    if(resizable) style |= NSResizableWindowMask;
+    [cocoaWindow setStyleMask:style];
+  }
+}
+
+void pWindow::setStatusFont(string font) {
+  @autoreleasepool {
+    [[cocoaWindow statusBar] setFont:pFont::cocoaFont(font)];
+  }
+  statusBarReposition();
+}
+
+void pWindow::setStatusText(string text) {
+  @autoreleasepool {
+    [[cocoaWindow statusBar] setStringValue:[NSString stringWithUTF8String:text]];
+  }
+}
+
+void pWindow::setStatusVisible(bool visible) {
+  @autoreleasepool {
+    [[cocoaWindow statusBar] setHidden:!visible];
+    setGeometry(geometry());
+  }
+}
+
+void pWindow::setTitle(string text) {
+  @autoreleasepool {
+    [cocoaWindow setTitle:[NSString stringWithUTF8String:text]];
+  }
+}
+
+void pWindow::setVisible(bool visible) {
+  @autoreleasepool {
+    if(visible) [cocoaWindow makeKeyAndOrderFront:nil];
+    else [cocoaWindow orderOut:nil];
+  }
+}
+
+void pWindow::setWidgetFont(string font) {
+}
+
+void pWindow::constructor() {
+  @autoreleasepool {
+    cocoaWindow = [[CocoaWindow alloc] initWith:window];
+
+    NSColor* color = [[cocoaWindow backgroundColor] colorUsingColorSpaceName:NSCalibratedRGBColorSpace];
+    window.state.backgroundColor = Color(
+      (uint8_t)(255 * [color redComponent]),
+      (uint8_t)(255 * [color greenComponent]),
+      (uint8_t)(255 * [color blueComponent]),
+      (uint8_t)(255 * [color alphaComponent])
+    );
+  }
+}
+
+void pWindow::destructor() {
+  @autoreleasepool {
+    [cocoaWindow release];
+  }
+}
+
+void pWindow::moveEvent() {
+  if(locked == false && window.fullScreen() == false && window.visible() == true) {
+    Geometry geometry = this->geometry();
+    window.state.geometry.x = geometry.x;
+    window.state.geometry.y = geometry.y;
+  }
+
+  if(locked == false) {
+    if(window.onMove) window.onMove();
+  }
+}
+
+void pWindow::sizeEvent() {
+  if(locked == false && window.fullScreen() == false && window.visible() == true) {
+    Geometry geometry = this->geometry();
+    window.state.geometry.width = geometry.width;
+    window.state.geometry.height = geometry.height;
+  }
+
+  for(auto& layout : window.state.layout) {
+    Geometry geometry = this->geometry();
+    geometry.x = geometry.y = 0;
+    layout.setGeometry(geometry);
+  }
+
+  statusBarReposition();
+
+  if(locked == false) {
+    if(window.onSize) window.onSize();
+  }
+}
+
+unsigned pWindow::statusBarHeight() {
+  if(!window.state.statusVisible) return 0;
+  return Font::size(window.state.statusFont, " ").height + 6;
+}
+
+void pWindow::statusBarReposition() {
+  @autoreleasepool {
+    NSRect area = [cocoaWindow contentRectForFrameRect:[cocoaWindow frame]];
+    [[cocoaWindow statusBar] setFrame:NSMakeRect(0, 0, area.size.width, statusBarHeight())];
+    [[cocoaWindow contentView] setNeedsDisplay:YES];
+  }
+}
+
+}
diff -Nru higan/phoenix/cocoa/window.hpp nSide/phoenix/cocoa/window.hpp
--- higan/phoenix/cocoa/window.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/cocoa/window.hpp	2015-09-16 13:08:13.618563374 +0900
@@ -0,0 +1,66 @@
+@interface CocoaWindow : NSWindow <NSWindowDelegate> {
+@public
+  phoenix::Window* window;
+  NSMenu* menuBar;
+  NSMenu* rootMenu;
+  NSTextField* statusBar;
+}
+-(id) initWith:(phoenix::Window&)window;
+-(BOOL) canBecomeKeyWindow;
+-(BOOL) canBecomeMainWindow;
+-(void) windowDidBecomeMain:(NSNotification*)notification;
+-(void) windowDidMove:(NSNotification*)notification;
+-(void) windowDidResize:(NSNotification*)notification;
+-(BOOL) windowShouldClose:(id)sender;
+-(NSDragOperation) draggingEntered:(id<NSDraggingInfo>)sender;
+-(BOOL) performDragOperation:(id<NSDraggingInfo>)sender;
+-(NSMenu*) menuBar;
+-(void) menuAbout;
+-(void) menuPreferences;
+-(void) menuQuit;
+-(NSTextField*) statusBar;
+@end
+
+namespace phoenix {
+
+struct pWindow : public pObject {
+  Window& window;
+  CocoaWindow* cocoaWindow = nullptr;
+
+  static Window& none();
+
+  void append(Layout& layout);
+  void append(Menu& menu);
+  void append(Widget& widget);
+  bool focused();
+  Geometry frameMargin();
+  Geometry geometry();
+  void remove(Layout& layout);
+  void remove(Menu& menu);
+  void remove(Widget& widget);
+  void setBackgroundColor(Color color);
+  void setDroppable(bool droppable);
+  void setFocused();
+  void setFullScreen(bool fullScreen);
+  void setGeometry(Geometry geometry);
+  void setMenuFont(string font);
+  void setMenuVisible(bool visible);
+  void setModal(bool modal);
+  void setResizable(bool resizable);
+  void setStatusFont(string font);
+  void setStatusText(string text);
+  void setStatusVisible(bool visible);
+  void setTitle(string text);
+  void setVisible(bool visible);
+  void setWidgetFont(string font);
+
+  pWindow(Window& window) : pObject(window), window(window) {}
+  void constructor();
+  void destructor();
+  void moveEvent();
+  void sizeEvent();
+  unsigned statusBarHeight();
+  void statusBarReposition();
+};
+
+}
diff -Nru higan/phoenix/core/core.cpp nSide/phoenix/core/core.cpp
--- higan/phoenix/core/core.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/core/core.cpp	2015-09-16 13:08:13.586563371 +0900
@@ -0,0 +1,2053 @@
+#include <nall/intrinsics.hpp>
+
+#if defined(PHOENIX_WINDOWS)
+  #include "../windows/header.hpp"
+#elif defined(PHOENIX_QT)
+  #include "../qt/header.hpp"
+#elif defined(PHOENIX_GTK)
+  #include "../gtk/header.hpp"
+#elif defined(PHOENIX_COCOA)
+  #include "../cocoa/header.hpp"
+#elif defined(PHOENIX_REFERENCE)
+  #include "../reference/header.hpp"
+#endif
+
+#include "core.hpp"
+using namespace nall;
+
+namespace phoenix {
+  #include "state.hpp"
+  #include "layout/fixed-layout.cpp"
+  #include "layout/horizontal-layout.cpp"
+  #include "layout/vertical-layout.cpp"
+}
+
+#if defined(PHOENIX_WINDOWS)
+  #include "../windows/platform.cpp"
+#elif defined(PHOENIX_QT)
+  #include "../qt/platform.cpp"
+#elif defined(PHOENIX_GTK)
+  #include "../gtk/platform.cpp"
+#elif defined(PHOENIX_COCOA)
+  #include "../cocoa/platform.cpp"
+#elif defined(PHOENIX_REFERENCE)
+  #include "../reference/platform.cpp"
+#endif
+
+namespace phoenix {
+
+//Application
+//===========
+
+function<void ()> Application::main;
+
+function<void ()> Application::Windows::onModalBegin;
+function<void ()> Application::Windows::onModalEnd;
+
+function<void ()> Application::Cocoa::onAbout;
+function<void ()> Application::Cocoa::onActivate;
+function<void ()> Application::Cocoa::onPreferences;
+function<void ()> Application::Cocoa::onQuit;
+
+void Application::run() {
+  return pApplication::run();
+}
+
+bool Application::pendingEvents() {
+  return pApplication::pendingEvents();
+}
+
+void Application::processEvents() {
+  return pApplication::processEvents();
+}
+
+void Application::quit() {
+  applicationState.quit = true;
+  return pApplication::quit();
+}
+
+void Application::setName(const string& name) {
+  applicationState.name = name;
+}
+
+void Application::initialize() {
+  static bool initialized = false;
+  if(initialized == false) {
+    initialized = true;
+    return pApplication::initialize();
+  }
+}
+
+//Color
+//=====
+
+uint32_t Color::rgb() const {
+  return (255 << 24) + (red << 16) + (green << 8) + (blue << 0);
+}
+
+uint32_t Color::argb() const {
+  return (alpha << 24) + (red << 16) + (green << 8) + (blue << 0);
+}
+
+//Geometry
+//========
+
+Position Geometry::position() const {
+  return {x, y};
+}
+
+Size Geometry::size() const {
+  return {width, height};
+}
+
+string Geometry::text() const {
+  return {x, ",", y, ",", width, ",", height};
+}
+
+Geometry::Geometry(const string& text) {
+  lstring part = text.split(",");
+  x = integer(part(0, "256"));
+  y = integer(part(1, "256"));
+  width = decimal(part(2, "256"));
+  height = decimal(part(3, "256"));
+}
+
+//Font
+//====
+
+string Font::serif(unsigned size, const string& style) {
+  return pFont::serif(size, style);
+}
+
+string Font::sans(unsigned size, const string& style) {
+  return pFont::sans(size, style);
+}
+
+string Font::monospace(unsigned size, const string& style) {
+  return pFont::monospace(size, style);
+}
+
+Size Font::size(const string& font, const string& text) {
+  return pFont::size(font, text);
+}
+
+//Desktop
+//=======
+
+Size Desktop::size() {
+  return pDesktop::size();
+}
+
+Geometry Desktop::workspace() {
+  return pDesktop::workspace();
+}
+
+//Monitor
+//=======
+
+unsigned Monitor::count() {
+  return pMonitor::count();
+}
+
+Geometry Monitor::geometry(unsigned monitor) {
+  return pMonitor::geometry(monitor);
+}
+
+unsigned Monitor::primary() {
+  return pMonitor::primary();
+}
+
+//Keyboard
+//========
+
+bool Keyboard::pressed(Keyboard::Scancode scancode) {
+  return pKeyboard::pressed(scancode);
+}
+
+bool Keyboard::released(Keyboard::Scancode scancode) {
+  return !pressed(scancode);
+}
+
+vector<bool> Keyboard::state() {
+  return pKeyboard::state();
+}
+
+//Mouse
+//=====
+
+Position Mouse::position() {
+  return pMouse::position();
+}
+
+bool Mouse::pressed(Mouse::Button button) {
+  return pMouse::pressed(button);
+}
+
+bool Mouse::released(Mouse::Button button) {
+  return !pressed(button);
+}
+
+//BrowserWindow
+//=============
+
+string BrowserWindow::directory() {
+  return pBrowserWindow::directory(state);
+}
+
+string BrowserWindow::open() {
+  return pBrowserWindow::open(state);
+}
+
+string BrowserWindow::save() {
+  return pBrowserWindow::save(state);
+}
+
+BrowserWindow& BrowserWindow::setFilters(const lstring& filters) {
+  state.filters = filters;
+  return *this;
+}
+
+BrowserWindow& BrowserWindow::setParent(Window& parent) {
+  state.parent = &parent;
+  return *this;
+}
+
+BrowserWindow& BrowserWindow::setPath(const string& path) {
+  state.path = path;
+  return *this;
+}
+
+BrowserWindow& BrowserWindow::setTitle(const string& title) {
+  state.title = title;
+  return *this;
+}
+
+BrowserWindow::BrowserWindow():
+state(*new State) {
+}
+
+BrowserWindow::~BrowserWindow() {
+  delete &state;
+}
+
+//MessageWindow
+//=============
+
+MessageWindow::Response MessageWindow::error(MessageWindow::Buttons buttons) {
+  state.buttons = buttons;
+  return pMessageWindow::error(state);
+}
+
+MessageWindow::Response MessageWindow::information(MessageWindow::Buttons buttons) {
+  state.buttons = buttons;
+  return pMessageWindow::information(state);
+}
+
+MessageWindow::Response MessageWindow::question(MessageWindow::Buttons buttons) {
+  state.buttons = buttons;
+  return pMessageWindow::question(state);
+}
+
+MessageWindow& MessageWindow::setParent(Window& parent) {
+  state.parent = &parent;
+  return *this;
+}
+
+MessageWindow& MessageWindow::setText(const string& text) {
+  state.text = text;
+  return *this;
+}
+
+MessageWindow& MessageWindow::setTitle(const string& title) {
+  state.title = title;
+  return *this;
+}
+
+MessageWindow::Response MessageWindow::warning(MessageWindow::Buttons buttons) {
+  state.buttons = buttons;
+  return pMessageWindow::warning(state);
+}
+
+MessageWindow::MessageWindow(const string& text):
+state(*new State) {
+  state.text = text;
+}
+
+MessageWindow::~MessageWindow() {
+  delete &state;
+}
+
+//Object
+//======
+
+Object::Object(pObject& p):
+p(p) {
+  Application::initialize();
+  p.constructor();
+}
+
+Object::~Object() {
+  p.destructor();
+  delete &p;
+}
+
+//Timer
+//=====
+
+bool Timer::enabled() const {
+  return state.enabled;
+}
+
+unsigned Timer::interval() const {
+  return state.interval;
+}
+
+void Timer::setEnabled(bool enabled) {
+  state.enabled = enabled;
+  return p.setEnabled(enabled);
+}
+
+void Timer::setInterval(unsigned interval) {
+  state.interval = interval;
+  return p.setInterval(interval);
+}
+
+Timer::Timer():
+state(*new State),
+base_from_member<pTimer&>(*new pTimer(*this)),
+Object(base_from_member<pTimer&>::value),
+p(base_from_member<pTimer&>::value) {
+  p.constructor();
+}
+
+Timer::~Timer() {
+  p.destructor();
+  delete &state;
+}
+
+//Window
+//======
+
+void Window::append(Layout& layout) {
+  if(state.layout.append(layout)) {
+    layout.Sizable::state.parent = nullptr;
+    layout.Sizable::state.window = this;
+    p.append(layout);
+    layout.synchronizeLayout();
+  }
+}
+
+void Window::append(Menu& menu) {
+  if(state.menu.append(menu)) {
+    menu.Action::state.window = this;
+    p.append(menu);
+  }
+}
+
+void Window::append(Widget& widget) {
+  if(state.widget.append(widget)) {
+    widget.Sizable::state.window = this;
+    p.append(widget);
+    widget.synchronizeLayout();
+  }
+}
+
+Color Window::backgroundColor() const {
+  return state.backgroundColor;
+}
+
+bool Window::droppable() const {
+  return state.droppable;
+}
+
+Geometry Window::frameGeometry() {
+  Geometry geometry = p.geometry();
+  Geometry margin = p.frameMargin();
+  return {
+    geometry.x - margin.x, geometry.y - margin.y,
+    geometry.width + margin.width, geometry.height + margin.height
+  };
+}
+
+Geometry Window::frameMargin() {
+  return p.frameMargin();
+}
+
+bool Window::focused() {
+  return p.focused();
+}
+
+bool Window::fullScreen() const {
+  return state.fullScreen;
+}
+
+Geometry Window::geometry() {
+  return p.geometry();
+}
+
+string Window::menuFont() const {
+  return state.menuFont;
+}
+
+bool Window::menuVisible() const {
+  return state.menuVisible;
+}
+
+bool Window::modal() const {
+  return state.modal;
+}
+
+void Window::remove(Layout& layout) {
+  if(state.layout.remove(layout)) {
+    p.remove(layout);
+    layout.Sizable::state.window = nullptr;
+  }
+}
+
+void Window::remove(Menu& menu) {
+  if(state.menu.remove(menu)) {
+    p.remove(menu);
+    menu.Action::state.window = nullptr;
+  }
+}
+
+void Window::remove(Widget& widget) {
+  if(state.widget.remove(widget)) {
+    p.remove(widget);
+    widget.Sizable::state.window = nullptr;
+  }
+}
+
+bool Window::resizable() const {
+  return state.resizable;
+}
+
+void Window::setBackgroundColor(Color color) {
+  state.backgroundColorOverride = true;
+  state.backgroundColor = color;
+  return p.setBackgroundColor(color);
+}
+
+void Window::setDroppable(bool droppable) {
+  state.droppable = droppable;
+  return p.setDroppable(droppable);
+}
+
+void Window::setFrameGeometry(Geometry geometry) {
+  Geometry margin = p.frameMargin();
+  return setGeometry({
+    geometry.x + margin.x, geometry.y + margin.y,
+    geometry.width - margin.width, geometry.height - margin.height
+  });
+}
+
+void Window::setFocused() {
+  return p.setFocused();
+}
+
+void Window::setFullScreen(bool fullScreen) {
+  state.fullScreen = fullScreen;
+  return p.setFullScreen(fullScreen);
+}
+
+void Window::setGeometry(Geometry geometry) {
+  state.geometry = geometry;
+  return p.setGeometry(geometry);
+}
+
+void Window::setMenuFont(const string& font) {
+  state.menuFont = font;
+  return p.setMenuFont(font);
+}
+
+void Window::setMenuVisible(bool visible) {
+  state.menuVisible = visible;
+  return p.setMenuVisible(visible);
+}
+
+void Window::setModal(bool modal) {
+  state.modal = modal;
+  return p.setModal(modal);
+}
+
+void Window::setResizable(bool resizable) {
+  state.resizable = resizable;
+  return p.setResizable(resizable);
+}
+
+void Window::setStatusFont(const string& font) {
+  state.statusFont = font;
+  return p.setStatusFont(font);
+}
+
+void Window::setStatusText(const string& text) {
+  state.statusText = text;
+  return p.setStatusText(text);
+}
+
+void Window::setStatusVisible(bool visible) {
+  state.statusVisible = visible;
+  return p.setStatusVisible(visible);
+}
+
+void Window::setTitle(const string& text) {
+  state.title = text;
+  return p.setTitle(text);
+}
+
+void Window::setVisible(bool visible) {
+  state.visible = visible;
+  synchronizeLayout();
+  return p.setVisible(visible);
+}
+
+void Window::setWidgetFont(const string& font) {
+  state.widgetFont = font;
+  return p.setWidgetFont(font);
+}
+
+void Window::setWindowGeometry(Geometry geometry) {
+  Geometry margin = p.frameMargin();
+  return setGeometry({
+    geometry.x + margin.x, geometry.y + margin.y,
+    geometry.width, geometry.height
+  });
+}
+
+string Window::statusFont() const {
+  return state.statusFont;
+}
+
+string Window::statusText() const {
+  return state.statusText;
+}
+
+bool Window::statusVisible() const {
+  return state.statusVisible;
+}
+
+void Window::synchronizeLayout() {
+  if(visible() && applicationState.quit == false) setGeometry(geometry());
+}
+
+string Window::title() const {
+  return state.title;
+}
+
+bool Window::visible() const {
+  return state.visible;
+}
+
+string Window::widgetFont() const {
+  return state.widgetFont;
+}
+
+Window::Window():
+state(*new State),
+base_from_member<pWindow&>(*new pWindow(*this)),
+Object(base_from_member<pWindow&>::value),
+p(base_from_member<pWindow&>::value) {
+  p.constructor();
+}
+
+Window::~Window() {
+  p.destructor();
+  delete &state;
+}
+
+//Action
+//======
+
+bool Action::enabled() const {
+  return state.enabled;
+}
+
+void Action::setEnabled(bool enabled) {
+  state.enabled = enabled;
+  return p.setEnabled(enabled);
+}
+
+void Action::setVisible(bool visible) {
+  state.visible = visible;
+  return p.setVisible(visible);
+}
+
+bool Action::visible() const {
+  return state.visible;
+}
+
+Action::Action(pAction& p):
+state(*new State),
+Object(p),
+p(p) {
+  p.constructor();
+}
+
+Action::~Action() {
+  p.destructor();
+  delete &state;
+}
+
+//Menu
+//====
+
+void Menu::append(const group<Action>& list) {
+  for(auto& action : list) {
+    if(state.action.append(action)) {
+      action.state.menu = this;
+      p.append(action);
+    }
+  }
+}
+
+image Menu::image() const {
+  return state.image;
+}
+
+void Menu::remove(const group<Action>& list) {
+  for(auto& action : list) {
+    if(state.action.remove(action)) {
+      action.state.menu = nullptr;
+      return p.remove(action);
+    }
+  }
+}
+
+void Menu::setImage(const nall::image& image) {
+  state.image = image;
+  return p.setImage(image);
+}
+
+void Menu::setText(const string& text) {
+  state.text = text;
+  return p.setText(text);
+}
+
+string Menu::text() const {
+  return state.text;
+}
+
+Menu::Menu():
+state(*new State),
+base_from_member<pMenu&>(*new pMenu(*this)),
+Action(base_from_member<pMenu&>::value),
+p(base_from_member<pMenu&>::value) {
+  p.constructor();
+}
+
+Menu::~Menu() {
+  p.destructor();
+  delete &state;
+}
+
+//Separator
+//=========
+
+Separator::Separator():
+base_from_member<pSeparator&>(*new pSeparator(*this)),
+Action(base_from_member<pSeparator&>::value),
+p(base_from_member<pSeparator&>::value) {
+  p.constructor();
+}
+
+Separator::~Separator() {
+  p.destructor();
+}
+
+//Item
+//====
+
+image Item::image() const {
+  return state.image;
+}
+
+void Item::setImage(const nall::image& image) {
+  state.image = image;
+  return p.setImage(image);
+}
+
+void Item::setText(const string& text) {
+  state.text = text;
+  return p.setText(text);
+}
+
+string Item::text() const {
+  return state.text;
+}
+
+Item::Item():
+state(*new State),
+base_from_member<pItem&>(*new pItem(*this)),
+Action(base_from_member<pItem&>::value),
+p(base_from_member<pItem&>::value) {
+  p.constructor();
+}
+
+Item::~Item() {
+  p.destructor();
+  delete &state;
+}
+
+//CheckItem
+//=========
+
+bool CheckItem::checked() const {
+  return state.checked;
+}
+
+void CheckItem::setChecked(bool checked) {
+  state.checked = checked;
+  return p.setChecked(checked);
+}
+
+void CheckItem::setText(const string& text) {
+  state.text = text;
+  return p.setText(text);
+}
+
+string CheckItem::text() const {
+  return state.text;
+}
+
+CheckItem::CheckItem():
+state(*new State),
+base_from_member<pCheckItem&>(*new pCheckItem(*this)),
+Action(base_from_member<pCheckItem&>::value),
+p(base_from_member<pCheckItem&>::value) {
+  p.constructor();
+}
+
+CheckItem::~CheckItem() {
+  p.destructor();
+  delete &state;
+}
+
+//RadioItem
+//=========
+
+void RadioItem::group(const nall::group<RadioItem>& list) {
+  for(auto& item : list) item.p.setGroup(item.state.group = list);
+  if(list.size()) list.first().setChecked();
+}
+
+bool RadioItem::checked() const {
+  return state.checked;
+}
+
+void RadioItem::setChecked() {
+  for(auto& item : state.group) item.state.checked = false;
+  state.checked = true;
+  return p.setChecked();
+}
+
+void RadioItem::setText(const string& text) {
+  state.text = text;
+  return p.setText(text);
+}
+
+string RadioItem::text() const {
+  return state.text;
+}
+
+RadioItem::RadioItem():
+state(*new State),
+base_from_member<pRadioItem&>(*new pRadioItem(*this)),
+Action(base_from_member<pRadioItem&>::value),
+p(base_from_member<pRadioItem&>::value) {
+  p.constructor();
+}
+
+RadioItem::~RadioItem() {
+  for(auto& item : state.group) {
+    if(&item != this) item.state.group.remove(*this);
+  }
+  p.destructor();
+  delete &state;
+}
+
+//Sizable
+//=======
+
+bool Sizable::enabled() const {
+  return state.enabled;
+}
+
+bool Sizable::enabledToAll() const {
+  if(state.enabled == false) return false;
+  if(state.parent) return state.parent->enabledToAll();
+  return true;
+}
+
+Layout* Sizable::layout() const {
+  if(state.parent && dynamic_cast<Layout*>(state.parent)) return (Layout*)state.parent;
+  return nullptr;
+}
+
+Sizable* Sizable::parent() const {
+  return state.parent;
+}
+
+bool Sizable::visible() const {
+  return state.visible;
+}
+
+bool Sizable::visibleToAll() const {
+  if(state.visible == false) return false;
+  if(state.parent) return state.parent->visibleToAll();
+  return true;
+}
+
+Window* Sizable::window() const {
+  return state.window;
+}
+
+Sizable::Sizable(pSizable& p):
+state(*new State),
+Object(p),
+p(p) {
+  p.constructor();
+}
+
+Sizable::~Sizable() {
+  if(layout()) layout()->remove(*this);
+  p.destructor();
+  delete &state;
+}
+
+//Layout
+//======
+
+void Layout::append(Sizable& sizable) {
+  sizable.state.parent = this;
+  sizable.state.window = Sizable::state.window;
+
+  if(dynamic_cast<Layout*>(&sizable)) {
+    Layout& layout = (Layout&)sizable;
+    layout.synchronizeLayout();
+  }
+
+  if(dynamic_cast<Widget*>(&sizable)) {
+    Widget& widget = (Widget&)sizable;
+    if(sizable.window()) sizable.window()->append(widget);
+  }
+}
+
+void Layout::remove(Sizable& sizable) {
+  if(dynamic_cast<Widget*>(&sizable)) {
+    Widget& widget = (Widget&)sizable;
+    if(sizable.window()) sizable.window()->remove(widget);
+  }
+
+  sizable.state.parent = nullptr;
+  sizable.state.window = nullptr;
+}
+
+void Layout::reset() {
+}
+
+Layout::Layout():
+state(*new State),
+base_from_member<pLayout&>(*new pLayout(*this)),
+Sizable(base_from_member<pLayout&>::value),
+p(base_from_member<pLayout&>::value) {
+}
+
+Layout::Layout(pLayout& p):
+state(*new State),
+base_from_member<pLayout&>(p),
+Sizable(p),
+p(p) {
+}
+
+Layout::~Layout() {
+  if(layout()) layout()->remove(*this);
+  if(window()) window()->remove(*this);
+  p.destructor();
+  delete &state;
+}
+
+//Widget
+//======
+
+bool Widget::focused() {
+  return p.focused();
+}
+
+string Widget::font() const {
+  return state.font;
+}
+
+Geometry Widget::geometry() const {
+  return state.geometry;
+}
+
+Size Widget::minimumSize() {
+  return p.minimumSize();
+}
+
+void Widget::setEnabled(bool enabled) {
+  Sizable::state.enabled = enabled;
+  return p.setEnabled(enabled);
+}
+
+void Widget::setFocused() {
+  return p.setFocused();
+}
+
+void Widget::setFont(const string& font) {
+  state.font = font;
+  return p.setFont(font);
+}
+
+void Widget::setGeometry(Geometry geometry) {
+  state.geometry = geometry;
+  return p.setGeometry(geometry);
+}
+
+void Widget::setVisible(bool visible) {
+  Sizable::state.visible = visible;
+  return p.setVisible(visible);
+}
+
+void Widget::synchronizeLayout() {
+}
+
+Widget::Widget():
+state(*new State),
+base_from_member<pWidget&>(*new pWidget(*this)),
+Sizable(base_from_member<pWidget&>::value),
+p(base_from_member<pWidget&>::value) {
+  state.abstract = true;
+  p.constructor();
+}
+
+Widget::Widget(pWidget& p):
+state(*new State),
+base_from_member<pWidget&>(p),
+Sizable(base_from_member<pWidget&>::value),
+p(base_from_member<pWidget&>::value) {
+  p.constructor();
+}
+
+Widget::~Widget() {
+  p.destructor();
+  delete &state;
+}
+
+//Button
+//======
+
+image Button::image() const {
+  return state.image;
+}
+
+Orientation Button::orientation() const {
+  return state.orientation;
+}
+
+void Button::setBordered(bool bordered) {
+  state.bordered = bordered;
+  return p.setBordered(bordered);
+}
+
+void Button::setImage(const nall::image& image, Orientation orientation) {
+  state.image = image;
+  state.orientation = orientation;
+  return p.setImage(image, orientation);
+}
+
+void Button::setText(const string& text) {
+  state.text = text;
+  return p.setText(text);
+}
+
+nall::string Button::text() const {
+  return state.text;
+}
+
+Button::Button():
+state(*new State),
+base_from_member<pButton&>(*new pButton(*this)),
+Widget(base_from_member<pButton&>::value),
+p(base_from_member<pButton&>::value) {
+  p.constructor();
+}
+
+Button::~Button() {
+  p.destructor();
+  delete &state;
+}
+
+//Canvas
+//======
+
+Color Canvas::color() const {
+  return state.color;
+}
+
+uint32_t* Canvas::data() const {
+  return state.data;
+}
+
+bool Canvas::droppable() const {
+  return state.droppable;
+}
+
+vector<Color> Canvas::gradient() const {
+  return state.gradient;
+}
+
+image Canvas::image() const {
+  return state.image;
+}
+
+Canvas::Mode Canvas::mode() const {
+  return state.mode;
+}
+
+void Canvas::setColor(Color color) {
+  state.color = color;
+  return setMode(Canvas::Mode::Color);
+}
+
+void Canvas::setData() {
+  if(state.width == 0 || state.height == 0) return;  //dynamic sizing not supported in Mode::Data
+  return setMode(Canvas::Mode::Data);
+}
+
+void Canvas::setDroppable(bool droppable) {
+  state.droppable = droppable;
+  return p.setDroppable(droppable);
+}
+
+void Canvas::setGradient(Color topLeft, Color topRight, Color bottomLeft, Color bottomRight) {
+  state.gradient[0] = topLeft;
+  state.gradient[1] = topRight;
+  state.gradient[2] = bottomLeft;
+  state.gradient[3] = bottomRight;
+  return setMode(Canvas::Mode::Gradient);
+}
+
+void Canvas::setHorizontalGradient(Color left, Color right) {
+  state.gradient[0] = state.gradient[2] = left;
+  state.gradient[1] = state.gradient[3] = right;
+  return setMode(Canvas::Mode::Gradient);
+}
+
+void Canvas::setImage(const nall::image& image) {
+  state.image = image;
+  return setMode(Canvas::Mode::Image);
+}
+
+void Canvas::setMode(Mode mode) {
+  state.mode = mode;
+  return p.setMode(mode);
+}
+
+void Canvas::setSize(Size size) {
+  if(size.width == Size::Maximum) size.width = 0;
+  if(size.height == Size::Maximum) size.height = 0;
+  state.width = size.width;
+  state.height = size.height;
+  delete[] state.data;
+  state.data = new uint32_t[state.width * state.height]();
+  return setMode(state.mode);
+}
+
+void Canvas::setVerticalGradient(Color top, Color bottom) {
+  state.gradient[0] = state.gradient[1] = top;
+  state.gradient[2] = state.gradient[3] = bottom;
+  return setMode(Canvas::Mode::Gradient);
+}
+
+Size Canvas::size() const {
+  return {state.width, state.height};
+}
+
+Canvas::Canvas():
+state(*new State),
+base_from_member<pCanvas&>(*new pCanvas(*this)),
+Widget(base_from_member<pCanvas&>::value),
+p(base_from_member<pCanvas&>::value) {
+  state.data = new uint32_t[state.width * state.height]();
+  p.constructor();
+}
+
+Canvas::~Canvas() {
+  p.destructor();
+  delete[] state.data;
+  delete &state;
+}
+
+//CheckButton
+//===========
+
+bool CheckButton::checked() const {
+  return state.checked;
+}
+
+image CheckButton::image() const {
+  return state.image;
+}
+
+void CheckButton::setChecked(bool checked) {
+  state.checked = checked;
+  return p.setChecked(checked);
+}
+
+void CheckButton::setImage(const nall::image& image, Orientation orientation) {
+  state.image = image;
+  state.orientation = orientation;
+  return p.setImage(image, orientation);
+}
+
+void CheckButton::setText(const string& text) {
+  state.text = text;
+  return p.setText(text);
+}
+
+string CheckButton::text() const {
+  return state.text;
+}
+
+CheckButton::CheckButton():
+state(*new State),
+base_from_member<pCheckButton&>(*new pCheckButton(*this)),
+Widget(base_from_member<pCheckButton&>::value),
+p(base_from_member<pCheckButton&>::value) {
+  p.constructor();
+}
+
+CheckButton::~CheckButton() {
+  p.destructor();
+  delete &state;
+}
+
+//CheckLabel
+//==========
+
+bool CheckLabel::checked() const {
+  return state.checked;
+}
+
+void CheckLabel::setChecked(bool checked) {
+  state.checked = checked;
+  return p.setChecked(checked);
+}
+
+void CheckLabel::setText(const string& text) {
+  state.text = text;
+  return p.setText(text);
+}
+
+string CheckLabel::text() const {
+  return state.text;
+}
+
+CheckLabel::CheckLabel():
+state(*new State),
+base_from_member<pCheckLabel&>(*new pCheckLabel(*this)),
+Widget(base_from_member<pCheckLabel&>::value),
+p(base_from_member<pCheckLabel&>::value) {
+  p.constructor();
+}
+
+CheckLabel::~CheckLabel() {
+  p.destructor();
+  delete &state;
+}
+
+
+//ComboButton
+//===========
+
+void ComboButton::append(const string& text) {
+  state.text.append(text);
+  return p.append(text);
+}
+
+void ComboButton::remove(unsigned selection) {
+  if(selection >= state.text.size()) return;
+  state.text.remove(selection);
+  p.remove(selection);
+}
+
+void ComboButton::reset() {
+  state.selection = 0;
+  state.text.reset();
+  return p.reset();
+}
+
+unsigned ComboButton::rows() const {
+  return state.text.size();
+}
+
+unsigned ComboButton::selection() const {
+  return state.selection;
+}
+
+void ComboButton::setSelection(unsigned selection) {
+  if(selection >= state.text.size()) return;
+  state.selection = selection;
+  return p.setSelection(selection);
+}
+
+void ComboButton::setText(unsigned selection, const string& text) {
+  if(selection >= state.text.size()) return;
+  state.text[selection] = text;
+  p.setText(selection, text);
+}
+
+string ComboButton::text() const {
+  if(state.text.empty()) return "";
+  return state.text[state.selection];
+}
+
+string ComboButton::text(unsigned selection) const {
+  if(selection >= state.text.size()) return "";
+  return state.text[selection];
+}
+
+ComboButton::ComboButton():
+state(*new State),
+base_from_member<pComboButton&>(*new pComboButton(*this)),
+Widget(base_from_member<pComboButton&>::value),
+p(base_from_member<pComboButton&>::value) {
+  p.constructor();
+}
+
+ComboButton::~ComboButton() {
+  p.destructor();
+  delete &state;
+}
+
+//Console
+//=======
+
+Color Console::backgroundColor() const {
+  return state.backgroundColor;
+}
+
+Color Console::foregroundColor() const {
+  return state.foregroundColor;
+}
+
+void Console::print(const string& text) {
+  return p.print(text);
+}
+
+string Console::prompt() const {
+  return state.prompt;
+}
+
+void Console::reset() {
+  return p.reset();
+}
+
+void Console::setBackgroundColor(Color color) {
+  state.backgroundColor = color;
+  return p.setBackgroundColor(color);
+}
+
+void Console::setForegroundColor(Color color) {
+  state.foregroundColor = color;
+  return p.setForegroundColor(color);
+}
+
+void Console::setPrompt(const string& prompt) {
+  state.prompt = prompt;
+  return p.setPrompt(prompt);
+}
+
+Console::Console():
+state(*new State),
+base_from_member<pConsole&>(*new pConsole(*this)),
+Widget(base_from_member<pConsole&>::value),
+p(base_from_member<pConsole&>::value) {
+  p.constructor();
+}
+
+Console::~Console() {
+  p.destructor();
+  delete &state;
+}
+
+//Frame
+//=====
+
+void Frame::setLayout(Layout& layout) {
+  state.layout = &layout;
+  synchronizeLayout();
+}
+
+void Frame::setText(const string& text) {
+  state.text = text;
+  return p.setText(text);
+}
+
+void Frame::synchronizeLayout() {
+  if(state.layout == nullptr) return;
+  state.layout->Sizable::state.window = Sizable::state.window;
+  state.layout->Sizable::state.parent = this;
+  state.layout->state.widget = this;
+  state.layout->synchronizeLayout();
+}
+
+string Frame::text() const {
+  return state.text;
+}
+
+Frame::Frame():
+state(*new State),
+base_from_member<pFrame&>(*new pFrame(*this)),
+Widget(base_from_member<pFrame&>::value),
+p(base_from_member<pFrame&>::value) {
+  p.constructor();
+}
+
+Frame::~Frame() {
+  p.destructor();
+  delete &state;
+}
+
+//HexEdit
+//=======
+
+Color HexEdit::backgroundColor() const {
+  return state.backgroundColor;
+}
+
+unsigned HexEdit::columns() const {
+  return state.columns;
+}
+
+Color HexEdit::foregroundColor() const {
+  return state.foregroundColor;
+}
+
+unsigned HexEdit::length() const {
+  return state.length;
+}
+
+unsigned HexEdit::offset() const {
+  return state.offset;
+}
+
+unsigned HexEdit::rows() const {
+  return state.rows;
+}
+
+void HexEdit::setBackgroundColor(Color color) {
+  state.backgroundColor = color;
+  return p.setBackgroundColor(color);
+}
+
+void HexEdit::setColumns(unsigned columns) {
+  state.columns = columns;
+  return p.setColumns(columns);
+}
+
+void HexEdit::setForegroundColor(Color color) {
+  state.foregroundColor = color;
+  return p.setForegroundColor(color);
+}
+
+void HexEdit::setLength(unsigned length) {
+  state.length = length;
+  return p.setLength(length);
+}
+
+void HexEdit::setOffset(unsigned offset) {
+  state.offset = offset;
+  return p.setOffset(offset);
+}
+
+void HexEdit::setRows(unsigned rows) {
+  state.rows = rows;
+  return p.setRows(rows);
+}
+
+void HexEdit::update() {
+  return p.update();
+}
+
+HexEdit::HexEdit():
+state(*new State),
+base_from_member<pHexEdit&>(*new pHexEdit(*this)),
+Widget(base_from_member<pHexEdit&>::value),
+p(base_from_member<pHexEdit&>::value) {
+  p.constructor();
+}
+
+HexEdit::~HexEdit() {
+  p.destructor();
+  delete &state;
+}
+
+//HorizontalScroller
+//==================
+
+unsigned HorizontalScroller::length() const {
+  return state.length;
+}
+
+unsigned HorizontalScroller::position() const {
+  return state.position;
+}
+
+void HorizontalScroller::setLength(unsigned length) {
+  state.length = length;
+  return p.setLength(length);
+}
+
+void HorizontalScroller::setPosition(unsigned position) {
+  state.position = position;
+  return p.setPosition(position);
+}
+
+HorizontalScroller::HorizontalScroller():
+state(*new State),
+base_from_member<pHorizontalScroller&>(*new pHorizontalScroller(*this)),
+Widget(base_from_member<pHorizontalScroller&>::value),
+p(base_from_member<pHorizontalScroller&>::value) {
+  p.constructor();
+}
+
+HorizontalScroller::~HorizontalScroller() {
+  p.destructor();
+  delete &state;
+}
+
+//HorizontalSlider
+//================
+
+unsigned HorizontalSlider::length() const {
+  return state.length;
+}
+
+unsigned HorizontalSlider::position() const {
+  return state.position;
+}
+
+void HorizontalSlider::setLength(unsigned length) {
+  state.length = length;
+  return p.setLength(length);
+}
+
+void HorizontalSlider::setPosition(unsigned position) {
+  state.position = position;
+  return p.setPosition(position);
+}
+
+HorizontalSlider::HorizontalSlider():
+state(*new State),
+base_from_member<pHorizontalSlider&>(*new pHorizontalSlider(*this)),
+Widget(base_from_member<pHorizontalSlider&>::value),
+p(base_from_member<pHorizontalSlider&>::value) {
+  p.constructor();
+}
+
+HorizontalSlider::~HorizontalSlider() {
+  p.destructor();
+  delete &state;
+}
+
+//Label
+//=====
+
+void Label::setText(const string& text) {
+  state.text = text;
+  return p.setText(text);
+}
+
+string Label::text() const {
+  return state.text;
+}
+
+Label::Label():
+state(*new State),
+base_from_member<pLabel&>(*new pLabel(*this)),
+Widget(base_from_member<pLabel&>::value),
+p(base_from_member<pLabel&>::value) {
+  p.constructor();
+}
+
+Label::~Label() {
+  p.destructor();
+  delete &state;
+}
+
+//LineEdit
+//========
+
+Color LineEdit::backgroundColor() const {
+  return state.backgroundColor;
+}
+
+bool LineEdit::editable() const {
+  return state.editable;
+}
+
+Color LineEdit::foregroundColor() const {
+  return state.foregroundColor;
+}
+
+void LineEdit::setBackgroundColor(Color color) {
+  state.backgroundColor = color;
+  return p.setBackgroundColor(color);
+}
+
+void LineEdit::setEditable(bool editable) {
+  state.editable = editable;
+  return p.setEditable(editable);
+}
+
+void LineEdit::setForegroundColor(Color color) {
+  state.foregroundColor = color;
+  return p.setForegroundColor(color);
+}
+
+void LineEdit::setText(const string& text) {
+  state.text = text;
+  return p.setText(text);
+}
+
+string LineEdit::text() {
+  return p.text();
+}
+
+LineEdit::LineEdit():
+state(*new State),
+base_from_member<pLineEdit&>(*new pLineEdit(*this)),
+Widget(base_from_member<pLineEdit&>::value),
+p(base_from_member<pLineEdit&>::value) {
+  p.constructor();
+}
+
+LineEdit::~LineEdit() {
+  p.destructor();
+  delete &state;
+}
+
+//ListView
+//========
+
+void ListView::append(const lstring& text) {
+  state.checked.append(false);
+  state.image.append({});
+  state.text.append(text);
+  return p.append(text);
+}
+
+void ListView::autoSizeColumns() {
+  return p.autoSizeColumns();
+}
+
+Color ListView::backgroundColor() const {
+  return state.backgroundColor;
+}
+
+bool ListView::checkable() const {
+  return state.checkable;
+}
+
+bool ListView::checked(unsigned selection) const {
+  if(selection >= state.text.size()) return false;
+  return state.checked[selection];
+}
+
+unsigned ListView::columns() const {
+  return max(1u, state.headerText.size());
+}
+
+Color ListView::foregroundColor() const {
+  return state.foregroundColor;
+}
+
+bool ListView::headerVisible() const {
+  return state.headerVisible;
+}
+
+image ListView::image(unsigned selection, unsigned position) const {
+  if(selection >= state.text.size()) return {};
+  return state.image[selection](position);
+}
+
+void ListView::remove(unsigned selection) {
+  if(selection >= state.text.size()) return;
+  state.checked.remove(selection);
+  state.image.remove(selection);
+  state.text.remove(selection);
+  return p.remove(selection);
+}
+
+void ListView::reset() {
+  state.checked.reset();
+  state.image.reset();
+  state.selected = false;
+  state.selection = 0;
+  state.text.reset();
+  return p.reset();
+}
+
+unsigned ListView::rows() const {
+  return state.text.size();
+}
+
+bool ListView::selected() const {
+  return state.selected;
+}
+
+unsigned ListView::selection() const {
+  return state.selection;
+}
+
+void ListView::setBackgroundColor(Color color) {
+  state.backgroundColor = color;
+  return p.setBackgroundColor(color);
+}
+
+void ListView::setCheckable(bool checkable) {
+  state.checkable = checkable;
+  return p.setCheckable(checkable);
+}
+
+void ListView::setChecked(unsigned selection, bool checked) {
+  if(selection >= state.text.size()) return;
+  state.checked[selection] = checked;
+  return p.setChecked(selection, checked);
+}
+
+void ListView::setForegroundColor(Color color) {
+  state.foregroundColor = color;
+  return p.setForegroundColor(color);
+}
+
+void ListView::setHeaderText(const lstring& text) {
+  state.headerText = text;
+  return p.setHeaderText(text);
+}
+
+void ListView::setHeaderVisible(bool visible) {
+  state.headerVisible = visible;
+  return p.setHeaderVisible(visible);
+}
+
+void ListView::setImage(unsigned selection, unsigned position, const nall::image& image) {
+  if(selection >= state.text.size()) return;
+  state.image[selection](position) = image;
+  return p.setImage(selection, position, image);
+}
+
+void ListView::setSelected(bool selected) {
+  state.selected = selected;
+  return p.setSelected(selected);
+}
+
+void ListView::setSelection(unsigned selection) {
+  if(selection >= state.text.size()) return;
+  state.selected = true;
+  state.selection = selection;
+  return p.setSelection(selection);
+}
+
+void ListView::setText(unsigned selection, const lstring& text) {
+  if(selection >= state.text.size()) return;
+  for(unsigned position = 0; position < text.size(); position++) {
+    setText(selection, position, text[position]);
+  }
+}
+
+void ListView::setText(unsigned selection, unsigned position, const string& text) {
+  if(selection >= state.text.size()) return;
+  state.text[selection](position) = text;
+  return p.setText(selection, position, text);
+}
+
+string ListView::text(unsigned selection, unsigned position) const {
+  if(selection >= state.text.size()) return "";
+  return state.text[selection](position);
+}
+
+ListView::ListView():
+state(*new State),
+base_from_member<pListView&>(*new pListView(*this)),
+Widget(base_from_member<pListView&>::value),
+p(base_from_member<pListView&>::value) {
+  p.constructor();
+}
+
+ListView::~ListView() {
+  p.destructor();
+  delete &state;
+}
+
+//ProgressBar
+//===========
+
+unsigned ProgressBar::position() const {
+  return state.position;
+}
+
+void ProgressBar::setPosition(unsigned position) {
+  state.position = position;
+  return p.setPosition(position);
+}
+
+ProgressBar::ProgressBar():
+state(*new State),
+base_from_member<pProgressBar&>(*new pProgressBar(*this)),
+Widget(base_from_member<pProgressBar&>::value),
+p(base_from_member<pProgressBar&>::value) {
+  p.constructor();
+}
+
+ProgressBar::~ProgressBar() {
+  p.destructor();
+  delete &state;
+}
+
+//RadioButton
+//===========
+
+void RadioButton::group(const nall::group<RadioButton>& list) {
+  for(auto& item : list) item.p.setGroup(item.state.group = list);
+  if(list.size()) list.first().setChecked();
+}
+
+bool RadioButton::checked() const {
+  return state.checked;
+}
+
+image RadioButton::image() const {
+  return state.image;
+}
+
+void RadioButton::setChecked() {
+  for(auto& item : state.group) item.state.checked = false;
+  state.checked = true;
+  return p.setChecked();
+}
+
+void RadioButton::setImage(const nall::image& image, Orientation orientation) {
+  state.image = image;
+  state.orientation = orientation;
+  return p.setImage(image, orientation);
+}
+
+void RadioButton::setText(const string& text) {
+  state.text = text;
+  return p.setText(text);
+}
+
+string RadioButton::text() const {
+  return state.text;
+}
+
+RadioButton::RadioButton():
+state(*new State),
+base_from_member<pRadioButton&>(*new pRadioButton(*this)),
+Widget(base_from_member<pRadioButton&>::value),
+p(base_from_member<pRadioButton&>::value) {
+  p.constructor();
+}
+
+RadioButton::~RadioButton() {
+  for(auto& item : state.group) {
+    if(&item != this) item.state.group.remove(*this);
+  }
+  p.destructor();
+  delete &state;
+}
+
+//RadioLabel
+//==========
+
+void RadioLabel::group(const nall::group<RadioLabel>& list) {
+  for(auto& item : list) item.p.setGroup(item.state.group = list);
+  if(list.size()) list.first().setChecked();
+}
+
+bool RadioLabel::checked() const {
+  return state.checked;
+}
+
+void RadioLabel::setChecked() {
+  for(auto &item : state.group) item.state.checked = false;
+  state.checked = true;
+  return p.setChecked();
+}
+
+void RadioLabel::setText(const string& text) {
+  state.text = text;
+  return p.setText(text);
+}
+
+string RadioLabel::text() const {
+  return state.text;
+}
+
+RadioLabel::RadioLabel():
+state(*new State),
+base_from_member<pRadioLabel&>(*new pRadioLabel(*this)),
+Widget(base_from_member<pRadioLabel&>::value),
+p(base_from_member<pRadioLabel&>::value) {
+  p.constructor();
+}
+
+RadioLabel::~RadioLabel() {
+  for(auto& item : state.group) {
+    if(&item != this) item.state.group.remove(*this);
+  }
+  p.destructor();
+  delete &state;
+}
+
+//TabFrame
+//========
+
+void TabFrame::append(const string& text, const nall::image& image) {
+  state.image.append(image);
+  state.layout.append(nullptr);
+  state.text.append(text);
+  return p.append(text, image);
+}
+
+image TabFrame::image(unsigned selection) const {
+  if(selection >= state.text.size()) return {};
+  return state.image[selection];
+}
+
+void TabFrame::remove(unsigned selection) {
+  if(selection >= state.text.size()) return;
+  state.image.remove(selection);
+  state.layout.remove(selection);
+  state.text.remove(selection);
+  return p.remove(selection);
+}
+
+unsigned TabFrame::selection() const {
+  return state.selection;
+}
+
+void TabFrame::setImage(unsigned selection, const nall::image& image) {
+  if(selection >= state.text.size()) return;
+  state.image[selection] = image;
+  return p.setImage(selection, image);
+}
+
+void TabFrame::setLayout(unsigned selection, Layout& layout) {
+  if(selection >= state.text.size()) return;
+  state.layout[selection] = &layout;
+  synchronizeLayout();
+}
+
+void TabFrame::setSelection(unsigned selection) {
+  state.selection = selection;
+  return p.setSelection(selection);
+}
+
+void TabFrame::setText(unsigned selection, const string& text) {
+  if(selection >= state.text.size()) return;
+  state.text[selection] = text;
+  return p.setText(selection, text);
+}
+
+void TabFrame::synchronizeLayout() {
+  for(unsigned n = 0; n < state.layout.size(); n++) {
+    Layout* layout = state.layout[n];
+    if(layout == nullptr) continue;
+    layout->Sizable::state.parent = this;
+    layout->Sizable::state.window = Sizable::state.window;
+    layout->state.widget = this;
+    layout->state.widgetSelection = n;
+    layout->synchronizeLayout();
+  }
+}
+
+unsigned TabFrame::tabs() const {
+  return state.text.size();
+}
+
+string TabFrame::text(unsigned selection) const {
+  if(selection >= state.text.size()) return "";
+  return state.text[selection];
+}
+
+TabFrame::TabFrame():
+state(*new State),
+base_from_member<pTabFrame&>(*new pTabFrame(*this)),
+Widget(base_from_member<pTabFrame&>::value),
+p(base_from_member<pTabFrame&>::value) {
+  p.constructor();
+}
+
+TabFrame::~TabFrame() {
+  p.destructor();
+  delete &state;
+}
+
+//TextEdit
+//========
+
+Color TextEdit::backgroundColor() const {
+  return state.backgroundColor;
+}
+
+bool TextEdit::editable() const {
+  return state.editable;
+}
+
+Color TextEdit::foregroundColor() const {
+  return state.foregroundColor;
+}
+
+void TextEdit::setBackgroundColor(Color color) {
+  state.backgroundColor = color;
+  return p.setBackgroundColor(color);
+}
+
+void TextEdit::setCursorPosition(unsigned position) {
+  state.cursorPosition = position;
+  return p.setCursorPosition(position);
+}
+
+void TextEdit::setEditable(bool editable) {
+  state.editable = editable;
+  return p.setEditable(editable);
+}
+
+void TextEdit::setForegroundColor(Color color) {
+  state.foregroundColor = color;
+  return p.setForegroundColor(color);
+}
+
+void TextEdit::setText(const string& text) {
+  state.text = text;
+  return p.setText(text);
+}
+
+void TextEdit::setWordWrap(bool wordWrap) {
+  state.wordWrap = wordWrap;
+  return p.setWordWrap(wordWrap);
+}
+
+string TextEdit::text() {
+  return p.text();
+}
+
+bool TextEdit::wordWrap() const {
+  return state.wordWrap;
+}
+
+TextEdit::TextEdit():
+state(*new State),
+base_from_member<pTextEdit&>(*new pTextEdit(*this)),
+Widget(base_from_member<pTextEdit&>::value),
+p(base_from_member<pTextEdit&>::value) {
+  p.constructor();
+}
+
+TextEdit::~TextEdit() {
+  p.destructor();
+  delete &state;
+}
+
+//VerticalScroller
+//================
+
+unsigned VerticalScroller::length() const {
+  return state.length;
+}
+
+unsigned VerticalScroller::position() const {
+  return state.position;
+}
+
+void VerticalScroller::setLength(unsigned length) {
+  state.length = length;
+  return p.setLength(length);
+}
+
+void VerticalScroller::setPosition(unsigned position) {
+  state.position = position;
+  return p.setPosition(position);
+}
+
+VerticalScroller::VerticalScroller():
+state(*new State),
+base_from_member<pVerticalScroller&>(*new pVerticalScroller(*this)),
+Widget(base_from_member<pVerticalScroller&>::value),
+p(base_from_member<pVerticalScroller&>::value) {
+  p.constructor();
+}
+
+VerticalScroller::~VerticalScroller() {
+  p.destructor();
+  delete &state;
+}
+
+//VerticalSlider
+//==============
+
+unsigned VerticalSlider::length() const {
+  return state.length;
+}
+
+unsigned VerticalSlider::position() const {
+  return state.position;
+}
+
+void VerticalSlider::setLength(unsigned length) {
+  state.length = length;
+  return p.setLength(length);
+}
+
+void VerticalSlider::setPosition(unsigned position) {
+  state.position = position;
+  return p.setPosition(position);
+}
+
+VerticalSlider::VerticalSlider():
+state(*new State),
+base_from_member<pVerticalSlider&>(*new pVerticalSlider(*this)),
+Widget(base_from_member<pVerticalSlider&>::value),
+p(base_from_member<pVerticalSlider&>::value) {
+  p.constructor();
+}
+
+VerticalSlider::~VerticalSlider() {
+  p.destructor();
+  delete &state;
+}
+
+//Viewport
+//========
+
+bool Viewport::droppable() const {
+  return state.droppable;
+}
+
+uintptr_t Viewport::handle() {
+  return p.handle();
+}
+
+void Viewport::setDroppable(bool droppable) {
+  state.droppable = droppable;
+  return p.setDroppable(droppable);
+}
+
+Viewport::Viewport():
+state(*new State),
+base_from_member<pViewport&>(*new pViewport(*this)),
+Widget(base_from_member<pViewport&>::value),
+p(base_from_member<pViewport&>::value) {
+  p.constructor();
+}
+
+Viewport::~Viewport() {
+  p.destructor();
+  delete &state;
+}
+
+}
diff -Nru higan/phoenix/core/core.hpp nSide/phoenix/core/core.hpp
--- higan/phoenix/core/core.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/core/core.hpp	2015-09-16 13:08:13.582563371 +0900
@@ -0,0 +1,895 @@
+#include <nall/platform.hpp>
+#include <nall/config.hpp>
+#include <nall/directory.hpp>
+#include <nall/function.hpp>
+//#include <nall/group.hpp>
+
+#ifndef NALL_GROUP_HPP
+#define NALL_GROUP_HPP
+
+//group
+//vector of unique references
+
+#include <nall/vector.hpp>
+
+namespace nall {
+
+template<typename T> struct group : protected vector<T*> {
+  group& operator=(const group& source) { vector<T*>::operator=(source); return *this; }
+  group& operator=(group&& source) { vector<T*>::operator=(std::move(source)); return *this; }
+  template<typename... Args> group(Args&&... args) { construct(std::forward<Args>(args)...); }
+
+  bool empty() const { return vector<T*>::empty(); }
+  unsigned size() const { return vector<T*>::size(); }
+  void reset() { vector<T*>::reset(); }
+
+  T& first() const { return *vector<T*>::operator[](0); }
+
+  //return true if at least one item was appended
+  template<typename... Args> bool append(T& value, Args&&... args) {
+    bool result = append(value);
+    return append(std::forward<Args>(args)...) | result;
+  }
+
+  bool append(T& value) {
+    if(vector<T*>::find(&value)) return false;
+    return vector<T*>::append(&value), true;
+  }
+
+  //return true if at least one item was removed
+  template<typename... Args> bool remove(T& value, Args&&... args) {
+    bool result = remove(value);
+    return remove(std::forward<Args>(args)...) | result;
+  }
+
+  bool remove(T& value) {
+    if(auto position = vector<T*>::find(&value)) return vector<T*>::remove(position()), true;
+    return false;
+  }
+
+  struct iterator : protected vector<T*>::constIterator {
+    T& operator*() const { return *vector<T*>::constIterator::operator*(); }
+    bool operator!=(const iterator& source) const { return vector<T*>::constIterator::operator!=(source); }
+    iterator& operator++() { vector<T*>::constIterator::operator++(); return *this; }
+    iterator(const group& source, unsigned position) : vector<T*>::constIterator(source, position) {}
+  };
+
+  const iterator begin() const { return iterator(*this, 0); }
+  const iterator end() const { return iterator(*this, size()); }
+
+private:
+  void construct() {}
+  void construct(const group& source) { vector<T*>::operator=(source); }
+  void construct(group&& source) { vector<T*>::operator=(std::move(source)); }
+  template<typename... Args> void construct(T& value, Args&&... args) {
+    append(value);
+    construct(std::forward<Args>(args)...);
+  }
+};
+
+}
+
+#endif
+
+#include <nall/image.hpp>
+#include <nall/map.hpp>
+#include <nall/stdint.hpp>
+#include <nall/string.hpp>
+#include <nall/utility.hpp>
+#include <nall/vector.hpp>
+
+namespace phoenix {
+
+struct Application;
+struct Font;
+struct Window;
+struct Menu;
+struct Sizable;
+struct Layout;
+struct Widget;
+
+struct pApplication;
+struct pFont;
+struct pObject;
+struct pTimer;
+struct pWindow;
+struct pAction;
+struct pMenu;
+struct pSeparator;
+struct pItem;
+struct pCheckItem;
+struct pRadioItem;
+struct pSizable;
+struct pLayout;
+struct pWidget;
+struct pButton;
+struct pCanvas;
+struct pCheckButton;
+struct pCheckLabel;
+struct pComboButton;
+struct pConsole;
+struct pFrame;
+struct pHexEdit;
+struct pHorizontalScroller;
+struct pHorizontalSlider;
+struct pLabel;
+struct pLineEdit;
+struct pListView;
+struct pProgressBar;
+struct pRadioButton;
+struct pRadioLabel;
+struct pTabFrame;
+struct pTextEdit;
+struct pVerticalScroller;
+struct pVerticalSlider;
+struct pViewport;
+
+struct Application {
+  static nall::function<void ()> main;
+
+  static void run();
+  static bool pendingEvents();
+  static void processEvents();
+  static void quit();
+  static void setName(const nall::string& name);
+
+  Application() = delete;
+  struct State;
+  static void initialize();
+
+  struct Windows {
+    static nall::function<void ()> onModalBegin;
+    static nall::function<void ()> onModalEnd;
+  };
+
+  struct Cocoa {
+    static nall::function<void ()> onAbout;
+    static nall::function<void ()> onActivate;
+    static nall::function<void ()> onPreferences;
+    static nall::function<void ()> onQuit;
+  };
+};
+
+struct Color {
+  uint8_t red, green, blue, alpha;
+  uint32_t rgb() const;
+  uint32_t argb() const;
+  inline Color() : alpha(255), red(0), green(0), blue(0) {}
+  inline Color(uint8_t red, uint8_t green, uint8_t blue) : alpha(255), red(red), green(green), blue(blue) {}
+  inline Color(uint8_t alpha, uint8_t red, uint8_t green, uint8_t blue) : alpha(alpha), red(red), green(green), blue(blue) {}
+};
+
+struct Position {
+  signed x, y;
+  inline Position() : x(0), y(0) {}
+  template<typename X, typename Y> inline Position(X x, Y y) : x(x), y(y) {}
+};
+
+struct Size {
+  static const unsigned Maximum = ~0u;
+  static const unsigned Minimum =  0u;
+
+  unsigned width, height;
+  inline Size() : width(0), height(0) {}
+  template<typename W, typename H> inline Size(W width, H height) : width(width), height(height) {}
+};
+
+struct Geometry {
+  signed x, y;
+  unsigned width, height;
+  Position position() const;
+  Size size() const;
+  nall::string text() const;
+  inline Geometry() : x(0), y(0), width(0), height(0) {}
+  inline Geometry(Position position, Size size) : x(position.x), y(position.y), width(size.width), height(size.height) {}
+  template<typename X, typename Y, typename W, typename H> inline Geometry(X x, Y y, W width, H height) : x(x), y(y), width(width), height(height) {}
+  Geometry(const nall::string& text);
+};
+
+enum class Orientation : unsigned { Horizontal, Vertical };
+
+struct Font {
+  static nall::string serif(unsigned size = 0, const nall::string& style = "");
+  static nall::string sans(unsigned size = 0, const nall::string& style = "");
+  static nall::string monospace(unsigned size = 0, const nall::string& style = "");
+  static Size size(const nall::string& font, const nall::string& text);
+  Font() = delete;
+};
+
+struct Desktop {
+  static Size size();
+  static Geometry workspace();
+  Desktop() = delete;
+};
+
+struct Monitor {
+  static unsigned count();
+  static Geometry geometry(unsigned monitor);
+  static unsigned primary();
+};
+
+struct Keyboard {
+  #include "keyboard.hpp"
+  static bool pressed(Scancode scancode);
+  static bool released(Scancode scancode);
+  static nall::vector<bool> state();
+  Keyboard() = delete;
+};
+
+struct Mouse {
+  enum class Button : unsigned { Left, Middle, Right };
+  static Position position();
+  static bool pressed(Button);
+  static bool released(Button);
+  Mouse() = delete;
+};
+
+struct BrowserWindow {
+  nall::string directory();
+  nall::string open();
+  nall::string save();
+  BrowserWindow& setFilters(const nall::lstring& filters);
+  BrowserWindow& setParent(Window& parent);
+  BrowserWindow& setPath(const nall::string& path);
+  BrowserWindow& setTitle(const nall::string& title);
+
+  BrowserWindow();
+  ~BrowserWindow();
+  struct State;
+  State& state;
+};
+
+struct MessageWindow {
+  enum class Buttons : unsigned {
+    Ok,
+    OkCancel,
+    YesNo,
+    YesNoCancel,
+  };
+
+  enum class Response : unsigned {
+    Ok,
+    Cancel,
+    Yes,
+    No,
+  };
+
+  Response error(Buttons = Buttons::Ok);
+  Response information(Buttons = Buttons::Ok);
+  Response question(Buttons = Buttons::YesNo);
+  MessageWindow& setParent(Window& parent);
+  MessageWindow& setText(const nall::string& text);
+  MessageWindow& setTitle(const nall::string& title);
+  Response warning(Buttons = Buttons::Ok);
+
+  MessageWindow(const nall::string& text = "");
+  ~MessageWindow();
+  struct State;
+  State& state;
+};
+
+struct Object {
+  Object(pObject& p);
+  Object& operator=(const Object&) = delete;
+  Object(const Object&) = delete;
+  virtual ~Object();
+  pObject& p;
+};
+
+struct Timer : private nall::base_from_member<pTimer&>, Object {
+  nall::function<void ()> onActivate;
+
+  bool enabled() const;
+  unsigned interval() const;
+  void setEnabled(bool enabled = true);
+  void setInterval(unsigned interval);  //in milliseconds
+
+  Timer();
+  ~Timer();
+  struct State;
+  State& state;
+  pTimer& p;
+};
+
+struct Window : private nall::base_from_member<pWindow&>, Object {
+  nall::function<void ()> onClose;
+  nall::function<void (nall::lstring)> onDrop;
+  nall::function<void (Keyboard::Keycode)> onKeyPress;
+  nall::function<void (Keyboard::Keycode)> onKeyRelease;
+  nall::function<void ()> onMove;
+  nall::function<void ()> onSize;
+
+  void append(Layout& layout);
+  void append(Menu& menu);
+  void append(Widget& widget);
+  Color backgroundColor() const;
+  bool droppable() const;
+  Geometry frameGeometry();
+  Geometry frameMargin();
+  bool focused();
+  bool fullScreen() const;
+  Geometry geometry();
+  nall::string menuFont() const;
+  bool menuVisible() const;
+  bool modal() const;
+  void remove(Layout& layout);
+  void remove(Menu& menu);
+  void remove(Widget& widget);
+  bool resizable() const;
+  void setBackgroundColor(Color color);
+  void setDroppable(bool droppable = true);
+  void setFrameGeometry(Geometry geometry);
+  void setFocused();
+  void setFullScreen(bool fullScreen = true);
+  void setGeometry(Geometry geometry);
+  void setMenuFont(const nall::string& font);
+  void setMenuVisible(bool visible = true);
+  void setModal(bool modal = true);
+  void setResizable(bool resizable = true);
+  void setStatusFont(const nall::string& font);
+  void setStatusText(const nall::string& text);
+  void setStatusVisible(bool visible = true);
+  void setTitle(const nall::string& text);
+  void setVisible(bool visible = true);
+  void setWidgetFont(const nall::string& font);
+  void setWindowGeometry(Geometry geometry);
+  nall::string statusFont() const;
+  nall::string statusText() const;
+  bool statusVisible() const;
+  void synchronizeLayout();
+  nall::string title() const;
+  bool visible() const;
+  nall::string widgetFont() const;
+
+  Window();
+  ~Window();
+  struct State;
+  State& state;
+  pWindow& p;
+};
+
+struct Action : Object {
+  bool enabled() const;
+  void setEnabled(bool enabled = true);
+  void setVisible(bool visible = true);
+  bool visible() const;
+
+  Action(pAction& p);
+  ~Action();
+  struct State;
+  State& state;
+  pAction& p;
+};
+
+struct Menu : private nall::base_from_member<pMenu&>, Action {
+  void append(const nall::group<Action>& list);
+  nall::image image() const;
+  void remove(const nall::group<Action>& list);
+  void setImage(const nall::image& image = nall::image{});
+  void setText(const nall::string& text);
+  nall::string text() const;
+
+  Menu();
+  ~Menu();
+  struct State;
+  State& state;
+  pMenu& p;
+};
+
+struct Separator : private nall::base_from_member<pSeparator&>, Action {
+  Separator();
+  ~Separator();
+  pSeparator& p;
+};
+
+struct Item : private nall::base_from_member<pItem&>, Action {
+  nall::function<void ()> onActivate;
+
+  nall::image image() const;
+  void setImage(const nall::image& image = nall::image{});
+  void setText(const nall::string& text);
+  nall::string text() const;
+
+  Item();
+  ~Item();
+  struct State;
+  State& state;
+  pItem& p;
+};
+
+struct CheckItem : private nall::base_from_member<pCheckItem&>, Action {
+  nall::function<void ()> onToggle;
+
+  bool checked() const;
+  void setChecked(bool checked = true);
+  void setText(const nall::string& text);
+  nall::string text() const;
+
+  CheckItem();
+  ~CheckItem();
+  struct State;
+  State& state;
+  pCheckItem& p;
+};
+
+struct RadioItem : private nall::base_from_member<pRadioItem&>, Action {
+  template<typename... Args> static void group(Args&&... args) { group({std::forward<Args>(args)...}); }
+  static void group(const nall::group<RadioItem>& list);
+
+  nall::function<void ()> onActivate;
+
+  bool checked() const;
+  void setChecked();
+  void setText(const nall::string& text);
+  nall::string text() const;
+
+  RadioItem();
+  ~RadioItem();
+  struct State;
+  State& state;
+  pRadioItem& p;
+};
+
+struct Sizable : Object {
+  bool enabled() const;
+  bool enabledToAll() const;
+  Layout* layout() const;
+  virtual Size minimumSize() = 0;
+  Sizable* parent() const;
+  virtual void setEnabled(bool enabled = true) = 0;
+  virtual void setGeometry(Geometry geometry) = 0;
+  virtual void setVisible(bool visible = true) = 0;
+  virtual void synchronizeLayout() = 0;
+  bool visible() const;
+  bool visibleToAll() const;
+  Window* window() const;
+
+  Sizable(pSizable& p);
+  ~Sizable();
+  struct State;
+  State& state;
+  pSizable& p;
+};
+
+struct Layout : private nall::base_from_member<pLayout&>, Sizable {
+  virtual void append(Sizable& sizable);
+  virtual void remove(Sizable& sizable);
+  virtual void reset();
+
+  Layout();
+  Layout(pLayout& p);
+  ~Layout();
+  struct State;
+  State& state;
+  pLayout& p;
+};
+
+struct Widget : private nall::base_from_member<pWidget&>, Sizable {
+  nall::function<void ()> onSize;
+
+  bool focused();
+  nall::string font() const;
+  Geometry geometry() const;
+  Size minimumSize();
+  void setEnabled(bool enabled = true);
+  void setFocused();
+  void setFont(const nall::string& font);
+  void setGeometry(Geometry geometry);
+  void setVisible(bool visible = true);
+  void synchronizeLayout();
+
+  Widget();
+  Widget(pWidget& p);
+  ~Widget();
+  struct State;
+  State& state;
+  pWidget& p;
+};
+
+struct Button : private nall::base_from_member<pButton&>, Widget {
+  nall::function<void ()> onActivate;
+
+  nall::image image() const;
+  Orientation orientation() const;
+  void setBordered(bool bordered);
+  void setImage(const nall::image& image = nall::image{}, Orientation orientation = Orientation::Horizontal);
+  void setText(const nall::string& text);
+  nall::string text() const;
+
+  Button();
+  ~Button();
+  struct State;
+  State& state;
+  pButton& p;
+};
+
+struct Canvas : private nall::base_from_member<pCanvas&>, Widget {
+  enum class Mode : unsigned { Color, Gradient, Image, Data };
+
+  nall::function<void (nall::lstring)> onDrop;
+  nall::function<void ()> onMouseLeave;
+  nall::function<void (Position)> onMouseMove;
+  nall::function<void (Mouse::Button)> onMousePress;
+  nall::function<void (Mouse::Button)> onMouseRelease;
+
+  Color color() const;
+  uint32_t* data() const;
+  bool droppable() const;
+  nall::vector<Color> gradient() const;
+  nall::image image() const;
+  Mode mode() const;
+  void setColor(Color color);
+  void setData();
+  void setDroppable(bool droppable = true);
+  void setHorizontalGradient(Color left, Color right);
+  void setGradient(Color topLeft, Color topRight, Color bottomLeft, Color bottomRight);
+  void setImage(const nall::image& image);
+  void setMode(Mode mode);
+  void setSize(Size size);
+  void setVerticalGradient(Color top, Color bottom);
+  Size size() const;
+
+  Canvas();
+  ~Canvas();
+  struct State;
+  State& state;
+  pCanvas& p;
+};
+
+struct CheckButton : private nall::base_from_member<pCheckButton&>, Widget {
+  nall::function<void ()> onToggle;
+
+  bool checked() const;
+  nall::image image() const;
+  void setChecked(bool checked = true);
+  void setImage(const nall::image& image = nall::image{}, Orientation orientation = Orientation::Horizontal);
+  void setText(const nall::string& text);
+  nall::string text() const;
+
+  CheckButton();
+  ~CheckButton();
+  struct State;
+  State& state;
+  pCheckButton& p;
+};
+
+struct CheckLabel : private nall::base_from_member<pCheckLabel&>, Widget {
+  nall::function<void ()> onToggle;
+
+  bool checked() const;
+  void setChecked(bool checked = true);
+  void setText(const nall::string& text);
+  nall::string text() const;
+
+  CheckLabel();
+  ~CheckLabel();
+  struct State;
+  State& state;
+  pCheckLabel& p;
+};
+
+struct ComboButton : private nall::base_from_member<pComboButton&>, Widget {
+  nall::function<void ()> onChange;
+
+  void append(const nall::string& text = "");
+  void remove(unsigned selection);
+  void reset();
+  unsigned rows() const;
+  unsigned selection() const;
+  void setSelection(unsigned selection);
+  void setText(unsigned selection, const nall::string& text);
+  nall::string text() const;
+  nall::string text(unsigned selection) const;
+
+  ComboButton();
+  ~ComboButton();
+  struct State;
+  State& state;
+  pComboButton& p;
+};
+
+struct Console : private nall::base_from_member<pConsole&>, Widget {
+  nall::function<void (nall::string)> onActivate;
+
+  template<typename... Args> void print(Args&&... args) { print({args...}); }
+
+  Color backgroundColor() const;
+  Color foregroundColor() const;
+  void print(const nall::string& text);
+  nall::string prompt() const;
+  void reset();
+  void setBackgroundColor(Color color);
+  void setForegroundColor(Color color);
+  void setPrompt(const nall::string& prompt);
+
+  Console();
+  ~Console();
+  struct State;
+  State& state;
+  pConsole& p;
+};
+
+struct Frame : private nall::base_from_member<pFrame&>, Widget {
+  void setLayout(Layout& layout);
+  void setText(const nall::string& text);
+  void synchronizeLayout();
+  nall::string text() const;
+
+  Frame();
+  ~Frame();
+  struct State;
+  State& state;
+  pFrame& p;
+};
+
+struct HexEdit : private nall::base_from_member<pHexEdit&>, Widget {
+  nall::function<uint8_t (unsigned)> onRead;
+  nall::function<void (unsigned, uint8_t)> onWrite;
+
+  Color backgroundColor() const;
+  unsigned columns() const;
+  Color foregroundColor() const;
+  unsigned length() const;
+  unsigned offset() const;
+  unsigned rows() const;
+  void setBackgroundColor(Color color);
+  void setColumns(unsigned columns);
+  void setForegroundColor(Color color);
+  void setLength(unsigned length);
+  void setOffset(unsigned offset);
+  void setRows(unsigned rows);
+  void update();
+
+  HexEdit();
+  ~HexEdit();
+  struct State;
+  State& state;
+  pHexEdit& p;
+};
+
+struct HorizontalScroller : private nall::base_from_member<pHorizontalScroller&>, Widget {
+  nall::function<void ()> onChange;
+
+  unsigned length() const;
+  unsigned position() const;
+  void setLength(unsigned length);
+  void setPosition(unsigned position);
+
+  HorizontalScroller();
+  ~HorizontalScroller();
+  struct State;
+  State& state;
+  pHorizontalScroller& p;
+};
+
+struct HorizontalSlider : private nall::base_from_member<pHorizontalSlider&>, Widget {
+  nall::function<void ()> onChange;
+
+  unsigned length() const;
+  unsigned position() const;
+  void setLength(unsigned length);
+  void setPosition(unsigned position);
+
+  HorizontalSlider();
+  ~HorizontalSlider();
+  struct State;
+  State& state;
+  pHorizontalSlider& p;
+};
+
+struct Label : private nall::base_from_member<pLabel&>, Widget {
+  void setText(const nall::string& text);
+  nall::string text() const;
+
+  Label();
+  ~Label();
+  struct State;
+  State& state;
+  pLabel& p;
+};
+
+struct LineEdit : private nall::base_from_member<pLineEdit&>, Widget {
+  nall::function<void ()> onActivate;
+  nall::function<void ()> onChange;
+
+  Color backgroundColor() const;
+  bool editable() const;
+  Color foregroundColor() const;
+  void setBackgroundColor(Color color);
+  void setEditable(bool editable = true);
+  void setForegroundColor(Color color);
+  void setText(const nall::string& text);
+  nall::string text();
+
+  LineEdit();
+  ~LineEdit();
+  struct State;
+  State& state;
+  pLineEdit& p;
+};
+
+struct ListView : private nall::base_from_member<pListView&>, Widget {
+  nall::function<void ()> onActivate;
+  nall::function<void ()> onChange;
+  nall::function<void (unsigned)> onToggle;
+
+  void append(const nall::lstring& text);
+  void autoSizeColumns();
+  Color backgroundColor() const;
+  bool checkable() const;
+  bool checked(unsigned selection) const;
+  unsigned columns() const;
+  Color foregroundColor() const;
+  bool headerVisible() const;
+  nall::image image(unsigned selection, unsigned position) const;
+  void remove(unsigned selection);
+  void reset();
+  unsigned rows() const;
+  bool selected() const;
+  unsigned selection() const;
+  void setBackgroundColor(Color color);
+  void setCheckable(bool checkable = true);
+  void setChecked(unsigned selection, bool checked = true);
+  void setForegroundColor(Color color);
+  void setHeaderText(const nall::lstring& text);
+  void setHeaderVisible(bool visible = true);
+  void setImage(unsigned selection, unsigned position, const nall::image& image = nall::image{});
+  void setSelected(bool selected = true);
+  void setSelection(unsigned selection);
+  void setText(unsigned selection, const nall::lstring& text);
+  void setText(unsigned selection, unsigned position, const nall::string& text);
+  nall::string text(unsigned selection, unsigned position) const;
+
+  ListView();
+  ~ListView();
+  struct State;
+  State& state;
+  pListView& p;
+};
+
+struct ProgressBar : private nall::base_from_member<pProgressBar&>, Widget {
+  unsigned position() const;
+  void setPosition(unsigned position);
+
+  ProgressBar();
+  ~ProgressBar();
+  struct State;
+  State& state;
+  pProgressBar& p;
+};
+
+struct RadioButton : private nall::base_from_member<pRadioButton&>, Widget {
+  template<typename... Args> static void group(Args&&... args) { group({std::forward<Args>(args)...}); }
+  static void group(const nall::group<RadioButton>& list);
+
+  nall::function<void ()> onActivate;
+
+  bool checked() const;
+  nall::image image() const;
+  void setChecked();
+  void setImage(const nall::image& image = nall::image{}, Orientation orientation = Orientation::Horizontal);
+  void setText(const nall::string& text);
+  nall::string text() const;
+
+  RadioButton();
+  ~RadioButton();
+  struct State;
+  State& state;
+  pRadioButton& p;
+};
+
+struct RadioLabel : private nall::base_from_member<pRadioLabel&>, Widget {
+  template<typename... Args> static void group(Args&&... args) { group({std::forward<Args>(args)...}); }
+  static void group(const nall::group<RadioLabel>& list);
+
+  nall::function<void ()> onActivate;
+
+  bool checked() const;
+  void setChecked();
+  void setText(const nall::string& text);
+  nall::string text() const;
+
+  RadioLabel();
+  ~RadioLabel();
+  struct State;
+  State& state;
+  pRadioLabel& p;
+};
+
+struct TabFrame : private nall::base_from_member<pTabFrame&>, Widget {
+  nall::function<void ()> onChange;
+
+  void append(const nall::string& text = "", const nall::image& image = nall::image{});
+  nall::image image(unsigned selection) const;
+  void remove(unsigned selection);
+  unsigned selection() const;
+  void setImage(unsigned selection, const nall::image& image = nall::image{});
+  void setLayout(unsigned selection, Layout& layout);
+  void setSelection(unsigned selection);
+  void setText(unsigned selection, const nall::string& text);
+  void synchronizeLayout();
+  unsigned tabs() const;
+  nall::string text(unsigned selection) const;
+
+  TabFrame();
+  ~TabFrame();
+  struct State;
+  State& state;
+  pTabFrame& p;
+};
+
+struct TextEdit : private nall::base_from_member<pTextEdit&>, Widget {
+  nall::function<void ()> onChange;
+
+  Color backgroundColor() const;
+  bool editable() const;
+  Color foregroundColor() const;
+  void setBackgroundColor(Color color);
+  void setCursorPosition(unsigned position);
+  void setEditable(bool editable = true);
+  void setForegroundColor(Color color);
+  void setText(const nall::string& text);
+  void setWordWrap(bool wordWrap = true);
+  nall::string text();
+  bool wordWrap() const;
+
+  TextEdit();
+  ~TextEdit();
+  struct State;
+  State& state;
+  pTextEdit& p;
+};
+
+struct VerticalScroller : private nall::base_from_member<pVerticalScroller&>, Widget {
+  nall::function<void ()> onChange;
+
+  unsigned length() const;
+  unsigned position() const;
+  void setLength(unsigned length);
+  void setPosition(unsigned position);
+
+  VerticalScroller();
+  ~VerticalScroller();
+  struct State;
+  State& state;
+  pVerticalScroller& p;
+};
+
+struct VerticalSlider : private nall::base_from_member<pVerticalSlider&>, Widget {
+  nall::function<void ()> onChange;
+
+  unsigned length() const;
+  unsigned position() const;
+  void setLength(unsigned length);
+  void setPosition(unsigned position);
+
+  VerticalSlider();
+  ~VerticalSlider();
+  struct State;
+  State& state;
+  pVerticalSlider& p;
+};
+
+struct Viewport : private nall::base_from_member<pViewport&>, Widget {
+  nall::function<void (nall::lstring)> onDrop;
+  nall::function<void ()> onMouseLeave;
+  nall::function<void (Position)> onMouseMove;
+  nall::function<void (Mouse::Button)> onMousePress;
+  nall::function<void (Mouse::Button)> onMouseRelease;
+
+  bool droppable() const;
+  uintptr_t handle();
+  void setDroppable(bool droppable = true);
+
+  Viewport();
+  ~Viewport();
+  struct State;
+  State& state;
+  pViewport& p;
+};
+
+#include "layout/fixed-layout.hpp"
+#include "layout/horizontal-layout.hpp"
+#include "layout/vertical-layout.hpp"
+
+}
diff -Nru higan/phoenix/core/keyboard.hpp nSide/phoenix/core/keyboard.hpp
--- higan/phoenix/core/keyboard.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/core/keyboard.hpp	2015-09-16 13:08:13.586563371 +0900
@@ -0,0 +1,45 @@
+//each code refers to a physical key
+//names are taken assuming: NumLock on, CapsLock off, Shift off
+//layout uses US-104 keyboard
+enum class Scancode : unsigned {
+  None,
+
+  Escape, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12,
+  PrintScreen, ScrollLock, Pause,
+  Insert, Delete, Home, End, PageUp, PageDown,
+  Up, Down, Left, Right,
+
+  Grave, Number1, Number2, Number3, Number4, Number5, Number6, Number7, Number8, Number9, Number0, Minus, Equal, Backspace,
+  BracketLeft, BracketRight, Backslash, Semicolon, Apostrophe, Comma, Period, Slash,
+  Tab, CapsLock, Return, ShiftLeft, ShiftRight, ControlLeft, ControlRight, SuperLeft, SuperRight, AltLeft, AltRight, Space, Menu,
+  A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z,
+
+  NumLock, Divide, Multiply, Subtract, Add, Enter, Point,
+  Keypad1, Keypad2, Keypad3, Keypad4, Keypad5, Keypad6, Keypad7, Keypad8, Keypad9, Keypad0,
+
+  Limit,
+};
+
+//each enum refers to a translated scancode (eg Shift+1 = !)
+enum class Keycode : unsigned {
+  None,
+
+  Escape, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12,
+  PrintScreen, SysRq, ScrollLock, Pause, Break,
+  Insert, Delete, Home, End, PageUp, PageDown,
+  Up, Down, Left, Right,
+
+  Grave, Number1, Number2, Number3, Number4, Number5, Number6, Number7, Number8, Number9, Number0, Minus, Equal, Backspace,
+  Tilde, Exclamation, At, Pound, Dollar, Percent, Power, Ampersand, Asterisk, ParenthesisLeft, ParenthesisRight, Underscore, Plus,
+  BracketLeft, BracketRight, Backslash, Semicolon, Apostrophe, Comma, Period, Slash,
+  BraceLeft, BraceRight, Pipe, Colon, Quote, CaretLeft, CaretRight, Question,
+  Tab, CapsLock, Return, ShiftLeft, ShiftRight, ControlLeft, ControlRight, SuperLeft, SuperRight, AltLeft, AltRight, Space, Menu,
+  A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z,
+  a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z,
+
+  NumLock, Divide, Multiply, Subtract, Add, Enter, Point,
+  Keypad1, Keypad2, Keypad3, Keypad4, Keypad5, Keypad6, Keypad7, Keypad8, Keypad9, Keypad0,
+  KeypadInsert, KeypadDelete, KeypadHome, KeypadEnd, KeypadPageUp, KeypadPageDown, KeypadUp, KeypadDown, KeypadLeft, KeypadRight, KeypadCenter,
+
+  Limit,
+};
diff -Nru higan/phoenix/core/layout/fixed-layout.cpp nSide/phoenix/core/layout/fixed-layout.cpp
--- higan/phoenix/core/layout/fixed-layout.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/core/layout/fixed-layout.cpp	2015-09-16 13:08:13.587563371 +0900
@@ -0,0 +1,68 @@
+void FixedLayout::append(Sizable& sizable, Geometry geometry) {
+  children.append({&sizable, geometry});
+  synchronizeLayout();
+  if(window()) window()->synchronizeLayout();
+}
+
+void FixedLayout::append(Sizable& sizable) {
+  for(auto& child : children) if(child.sizable == &sizable) return;
+  Layout::append(sizable);
+  if(window()) window()->synchronizeLayout();
+}
+
+Size FixedLayout::minimumSize() {
+  unsigned width = Size::Minimum, height = Size::Minimum;
+  for(auto& child : children) {
+    width  = max(width,  child.sizable->minimumSize().width);
+    height = max(height, child.sizable->minimumSize().height);
+  }
+  return {width, height};
+}
+
+void FixedLayout::remove(Sizable& sizable) {
+  for(unsigned n = 0; n < children.size(); n++) {
+    if(children[n].sizable == &sizable) {
+      children.remove(n);
+      Layout::remove(sizable);
+      if(window()) window()->synchronizeLayout();
+      break;
+    }
+  }
+}
+
+void FixedLayout::reset() {
+  for(auto& child : children) {
+    if(window() && dynamic_cast<Widget*>(child.sizable)) window()->remove((Widget&)*child.sizable);
+  }
+}
+
+void FixedLayout::setEnabled(bool enabled) {
+  Sizable::state.enabled = enabled;
+  for(auto& child : children) {
+    child.sizable->setEnabled(child.sizable->enabled());
+  }
+}
+
+void FixedLayout::setGeometry(Geometry geometry) {
+}
+
+void FixedLayout::setVisible(bool visible) {
+  Sizable::state.visible = visible;
+  for(auto& child : children) {
+    child.sizable->setVisible(child.sizable->visible());
+  }
+}
+
+void FixedLayout::synchronizeLayout() {
+  for(auto& child : children) {
+    Layout::append(*child.sizable);
+    Geometry childGeometry = child.geometry;
+    if((signed)childGeometry.width < 1) childGeometry.width = 1;
+    if((signed)childGeometry.height < 1) childGeometry.height = 1;
+    child.sizable->setGeometry(childGeometry);
+  }
+}
+
+FixedLayout::~FixedLayout() {
+  while(children.size()) remove(*children[0].sizable);
+}
diff -Nru higan/phoenix/core/layout/fixed-layout.hpp nSide/phoenix/core/layout/fixed-layout.hpp
--- higan/phoenix/core/layout/fixed-layout.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/core/layout/fixed-layout.hpp	2015-09-16 13:08:13.587563371 +0900
@@ -0,0 +1,19 @@
+struct FixedLayout : Layout {
+  void append(Sizable& sizable, Geometry geometry);
+  void append(Sizable& sizable);
+  Size minimumSize();
+  void remove(Sizable& sizable);
+  void reset();
+  void setEnabled(bool enabled = true);
+  void setGeometry(Geometry geometry);
+  void setVisible(bool visible = true);
+  void synchronizeLayout();
+  ~FixedLayout();
+
+//private:
+  struct Children {
+    Sizable* sizable;
+    Geometry geometry;
+  };
+  nall::vector<Children> children;
+};
diff -Nru higan/phoenix/core/layout/horizontal-layout.cpp nSide/phoenix/core/layout/horizontal-layout.cpp
--- higan/phoenix/core/layout/horizontal-layout.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/core/layout/horizontal-layout.cpp	2015-09-16 13:08:13.587563371 +0900
@@ -0,0 +1,127 @@
+void HorizontalLayout::append(Sizable& sizable, Size size, unsigned spacing) {
+  for(auto& child : children) if(child.sizable == &sizable) return;
+  children.append({&sizable, size.width, size.height, spacing});
+  synchronizeLayout();
+  if(window()) window()->synchronizeLayout();
+}
+
+void HorizontalLayout::append(Sizable& sizable) {
+  for(auto& child : children) if(child.sizable == &sizable) return;
+  Layout::append(sizable);
+  if(window()) window()->synchronizeLayout();
+}
+
+Size HorizontalLayout::minimumSize() {
+  unsigned width = 0, height = 0;
+
+  for(auto& child : children) {
+    width += child.spacing;
+    if(child.width == Size::Minimum || child.width == Size::Maximum) {
+      width += child.sizable->minimumSize().width;
+      continue;
+    }
+    width += child.width;
+  }
+
+  for(auto& child : children) {
+    if(child.height == Size::Minimum || child.height == Size::Maximum) {
+      height = max(height, child.sizable->minimumSize().height);
+      continue;
+    }
+    height = max(height, child.height);
+  }
+
+  return {state.margin * 2 + width, state.margin * 2 + height};
+}
+
+void HorizontalLayout::remove(Sizable& sizable) {
+  for(unsigned n = 0; n < children.size(); n++) {
+    if(children[n].sizable == &sizable) {
+      if(dynamic_cast<Layout*>(children[n].sizable)) {
+        Layout* layout = (Layout*)children[n].sizable;
+        layout->reset();
+      }
+      children.remove(n);
+      Layout::remove(sizable);
+      if(window()) window()->synchronizeLayout();
+      break;
+    }
+  }
+}
+
+void HorizontalLayout::reset() {
+  for(auto& child : children) {
+    if(window() && dynamic_cast<Layout*>(child.sizable)) ((Layout*)child.sizable)->reset();
+    if(window() && dynamic_cast<Widget*>(child.sizable)) window()->remove((Widget&)*child.sizable);
+  }
+}
+
+void HorizontalLayout::setAlignment(double alignment) {
+  state.alignment = max(0.0, min(1.0, alignment));
+}
+
+void HorizontalLayout::setEnabled(bool enabled) {
+  Sizable::state.enabled = enabled;
+  for(auto& child : children) {
+    child.sizable->setEnabled(child.sizable->enabled());
+  }
+}
+
+void HorizontalLayout::setGeometry(Geometry containerGeometry) {
+  auto children = this->children;
+  for(auto& child : children) {
+    if(child.width  == Size::Minimum) child.width  = child.sizable->minimumSize().width;
+    if(child.height == Size::Minimum) child.height = child.sizable->minimumSize().height;
+  }
+
+  Geometry geometry = containerGeometry;
+  geometry.x      += state.margin;
+  geometry.y      += state.margin;
+  geometry.width  -= state.margin * 2;
+  geometry.height -= state.margin * 2;
+
+  unsigned minimumWidth = 0, maximumWidthCounter = 0;
+  for(auto& child : children) {
+    if(child.width == Size::Maximum) maximumWidthCounter++;
+    if(child.width != Size::Maximum) minimumWidth += child.width;
+    minimumWidth += child.spacing;
+  }
+
+  for(auto& child : children) {
+    if(child.width  == Size::Maximum) child.width  = (geometry.width - minimumWidth) / maximumWidthCounter;
+    if(child.height == Size::Maximum) child.height = geometry.height;
+  }
+
+  unsigned maximumHeight = 0;
+  for(auto& child : children) maximumHeight = max(maximumHeight, child.height);
+
+  for(auto& child : children) {
+    unsigned pivot = (maximumHeight - child.height) * state.alignment;
+    Geometry childGeometry = {geometry.x, geometry.y + pivot, child.width, child.height};
+    if((signed)childGeometry.width < 1) childGeometry.width = 1;
+    if((signed)childGeometry.height < 1) childGeometry.height = 1;
+    child.sizable->setGeometry(childGeometry);
+
+    geometry.x += child.width + child.spacing;
+    geometry.width -= child.width + child.spacing;
+  }
+}
+
+void HorizontalLayout::setMargin(unsigned margin) {
+  state.margin = margin;
+}
+
+void HorizontalLayout::setVisible(bool visible) {
+  Sizable::state.visible = visible;
+  for(auto& child : children) {
+    child.sizable->setVisible(child.sizable->visible());
+  }
+}
+
+void HorizontalLayout::synchronizeLayout() {
+  for(auto& child : children) Layout::append(*child.sizable);
+}
+
+HorizontalLayout::~HorizontalLayout() {
+  while(children.size()) remove(*children[0].sizable);
+}
diff -Nru higan/phoenix/core/layout/horizontal-layout.hpp nSide/phoenix/core/layout/horizontal-layout.hpp
--- higan/phoenix/core/layout/horizontal-layout.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/core/layout/horizontal-layout.hpp	2015-09-16 13:08:13.586563371 +0900
@@ -0,0 +1,26 @@
+struct HorizontalLayout : public Layout {
+  void append(Sizable& sizable, Size size, unsigned spacing = 0);
+  void append(Sizable& sizable);
+  Size minimumSize();
+  void remove(Sizable& sizable);
+  void reset();
+  void setAlignment(double alignment);
+  void setEnabled(bool enabled = true);
+  void setGeometry(Geometry geometry);
+  void setMargin(unsigned margin);
+  void setVisible(bool visible = true);
+  void synchronizeLayout();
+  ~HorizontalLayout();
+
+//private:
+  struct State {
+    double alignment = 0.5;
+    unsigned margin = 0;
+  } state;
+
+  struct Children {
+    Sizable* sizable;
+    unsigned width, height, spacing;
+  };
+  nall::vector<Children> children;
+};
diff -Nru higan/phoenix/core/layout/vertical-layout.cpp nSide/phoenix/core/layout/vertical-layout.cpp
--- higan/phoenix/core/layout/vertical-layout.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/core/layout/vertical-layout.cpp	2015-09-16 13:08:13.587563371 +0900
@@ -0,0 +1,127 @@
+void VerticalLayout::append(Sizable& sizable, Size size, unsigned spacing) {
+  for(auto& child : children) if(child.sizable == &sizable) return;
+  children.append({&sizable, size.width, size.height, spacing});
+  synchronizeLayout();
+  if(window()) window()->synchronizeLayout();
+}
+
+void VerticalLayout::append(Sizable& sizable) {
+  for(auto& child : children) if(child.sizable == &sizable) return;
+  Layout::append(sizable);
+  if(window()) window()->synchronizeLayout();
+}
+
+Size VerticalLayout::minimumSize() {
+  unsigned width = 0, height = 0;
+
+  for(auto& child : children) {
+    if(child.width == Size::Minimum || child.width == Size::Maximum) {
+      width = max(width, child.sizable->minimumSize().width);
+      continue;
+    }
+    width = max(width, child.width);
+  }
+
+  for(auto& child : children) {
+    height += child.spacing;
+    if(child.height == Size::Minimum || child.height == Size::Maximum) {
+      height += child.sizable->minimumSize().height;
+      continue;
+    }
+    height += child.height;
+  }
+
+  return {state.margin * 2 + width, state.margin * 2 + height};
+}
+
+void VerticalLayout::remove(Sizable& sizable) {
+  for(unsigned n = 0; n < children.size(); n++) {
+    if(children[n].sizable == &sizable) {
+      if(dynamic_cast<Layout*>(children[n].sizable)) {
+        Layout* layout = (Layout*)children[n].sizable;
+        layout->reset();
+      }
+      children.remove(n);
+      Layout::remove(sizable);
+      if(window()) window()->synchronizeLayout();
+      break;
+    }
+  }
+}
+
+void VerticalLayout::reset() {
+  for(auto& child : children) {
+    if(window() && dynamic_cast<Layout*>(child.sizable)) ((Layout*)child.sizable)->reset();
+    if(window() && dynamic_cast<Widget*>(child.sizable)) window()->remove((Widget&)*child.sizable);
+  }
+}
+
+void VerticalLayout::setAlignment(double alignment) {
+  state.alignment = max(0.0, min(1.0, alignment));
+}
+
+void VerticalLayout::setEnabled(bool enabled) {
+  Sizable::state.enabled = enabled;
+  for(auto& child : children) {
+    child.sizable->setEnabled(child.sizable->enabled());
+  }
+}
+
+void VerticalLayout::setGeometry(Geometry containerGeometry) {
+  auto children = this->children;
+  for(auto& child : children) {
+    if(child.width  == Size::Minimum) child.width  = child.sizable->minimumSize().width;
+    if(child.height == Size::Minimum) child.height = child.sizable->minimumSize().height;
+  }
+
+  Geometry geometry = containerGeometry;
+  geometry.x      += state.margin;
+  geometry.y      += state.margin;
+  geometry.width  -= state.margin * 2;
+  geometry.height -= state.margin * 2;
+
+  unsigned minimumHeight = 0, maximumHeightCounter = 0;
+  for(auto& child : children) {
+    if(child.height == Size::Maximum) maximumHeightCounter++;
+    if(child.height != Size::Maximum) minimumHeight += child.height;
+    minimumHeight += child.spacing;
+  }
+
+  for(auto& child : children) {
+    if(child.width  == Size::Maximum) child.width  = geometry.width;
+    if(child.height == Size::Maximum) child.height = (geometry.height - minimumHeight) / maximumHeightCounter;
+  }
+
+  unsigned maximumWidth = 0;
+  for(auto& child : children) maximumWidth = max(maximumWidth, child.width);
+
+  for(auto& child : children) {
+    unsigned pivot = (maximumWidth - child.width) * state.alignment;
+    Geometry childGeometry = {geometry.x + pivot, geometry.y, child.width, child.height};
+    if((signed)childGeometry.width < 1) childGeometry.width = 1;
+    if((signed)childGeometry.height < 1) childGeometry.height = 1;
+    child.sizable->setGeometry(childGeometry);
+
+    geometry.y += child.height + child.spacing;
+    geometry.height -= child.height + child.spacing;
+  }
+}
+
+void VerticalLayout::setMargin(unsigned margin) {
+  state.margin = margin;
+}
+
+void VerticalLayout::setVisible(bool visible) {
+  Sizable::state.visible = visible;
+  for(auto& child : children) {
+    child.sizable->setVisible(child.sizable->visible());
+  }
+}
+
+void VerticalLayout::synchronizeLayout() {
+  for(auto& child : children) Layout::append(*child.sizable);
+}
+
+VerticalLayout::~VerticalLayout() {
+  while(children.size()) remove(*children[0].sizable);
+}
diff -Nru higan/phoenix/core/layout/vertical-layout.hpp nSide/phoenix/core/layout/vertical-layout.hpp
--- higan/phoenix/core/layout/vertical-layout.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/core/layout/vertical-layout.hpp	2015-09-16 13:08:13.587563371 +0900
@@ -0,0 +1,26 @@
+struct VerticalLayout : public Layout {
+  void append(Sizable& sizable, Size size, unsigned spacing = 0);
+  void append(Sizable& sizable);
+  Size minimumSize();
+  void remove(Sizable& sizable);
+  void reset();
+  void setAlignment(double alignment);
+  void setEnabled(bool enabled = true);
+  void setGeometry(Geometry geometry);
+  void setMargin(unsigned margin);
+  void setVisible(bool visible = true);
+  void synchronizeLayout();
+  ~VerticalLayout();
+
+//private:
+  struct State {
+    double alignment = 0.0;
+    unsigned margin = 0;
+  } state;
+
+  struct Children {
+    Sizable* sizable;
+    unsigned width, height, spacing;
+  };
+  nall::vector<Children> children;
+};
diff -Nru higan/phoenix/core/state.hpp nSide/phoenix/core/state.hpp
--- higan/phoenix/core/state.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/core/state.hpp	2015-09-16 13:08:13.581563370 +0900
@@ -0,0 +1,228 @@
+struct Application::State {
+  string name;
+  bool quit = false;
+} applicationState;
+
+struct Timer::State {
+  bool enabled = false;
+  unsigned interval = 0;
+};
+
+struct BrowserWindow::State {
+  lstring filters;
+  Window* parent = nullptr;
+  string path;
+  string title;
+};
+
+struct MessageWindow::State {
+  MessageWindow::Buttons buttons = MessageWindow::Buttons::Ok;
+  Window* parent = nullptr;
+  string text;
+  string title;
+};
+
+struct Window::State {
+  bool backgroundColorOverride = false;
+  Color backgroundColor = {0, 0, 0};
+  bool droppable = false;
+  bool fullScreen = false;
+  Geometry geometry = {128, 128, 256, 256};
+  group<Layout> layout;
+  group<Menu> menu;
+  string menuFont;
+  bool menuVisible = false;
+  bool modal = false;
+  bool resizable = true;
+  string statusFont;
+  string statusText;
+  bool statusVisible = false;
+  string title;
+  bool visible = false;
+  group<Widget> widget;
+  string widgetFont;
+};
+
+struct Action::State {
+  bool enabled = true;
+  Menu* menu = nullptr;
+  bool visible = true;
+  Window* window = nullptr;
+};
+
+struct Menu::State {
+  group<Action> action;
+  nall::image image;
+  string text;
+};
+
+struct Item::State {
+  nall::image image;
+  string text;
+};
+
+struct CheckItem::State {
+  bool checked = false;
+  string text;
+};
+
+struct RadioItem::State {
+  bool checked = true;
+  nall::group<RadioItem> group;
+  string text;
+};
+
+struct Sizable::State {
+  bool enabled = true;
+  Sizable* parent = nullptr;
+  bool visible = true;
+  Window* window = nullptr;
+};
+
+struct Layout::State {
+  Widget* widget = nullptr;
+  unsigned widgetSelection = 0;
+};
+
+struct Widget::State {
+  bool abstract = false;
+  string font;
+  Geometry geometry = {0, 0, 0, 0};
+};
+
+struct Button::State {
+  bool bordered;
+  nall::image image;
+  Orientation orientation = Orientation::Horizontal;
+  string text;
+};
+
+struct Canvas::State {
+  Color color;
+  uint32_t* data = nullptr;
+  bool droppable = false;
+  vector<Color> gradient = {{}, {}, {}, {}};
+  nall::image image;
+  Canvas::Mode mode = Canvas::Mode::Color;
+  unsigned width = 0;
+  unsigned height = 0;
+};
+
+struct CheckButton::State {
+  bool checked = false;
+  nall::image image;
+  Orientation orientation = Orientation::Horizontal;
+  string text;
+};
+
+struct CheckLabel::State {
+  bool checked = false;
+  string text;
+};
+
+struct ComboButton::State {
+  unsigned selection = 0;
+  vector<string> text;
+};
+
+struct Console::State {
+  Color backgroundColor = {255, 255, 255};
+  Color foregroundColor = {0, 0, 0};
+  string prompt;
+};
+
+struct Frame::State {
+  Layout* layout = nullptr;
+  string text;
+};
+
+struct HexEdit::State {
+  Color backgroundColor = {255, 255, 255};
+  unsigned columns = 16;
+  Color foregroundColor = {0, 0, 0};
+  unsigned length = 0;
+  unsigned offset = 0;
+  unsigned rows = 16;
+};
+
+struct HorizontalScroller::State {
+  unsigned length = 101;
+  unsigned position = 0;
+};
+
+struct HorizontalSlider::State {
+  unsigned length = 101;
+  unsigned position = 0;
+};
+
+struct Label::State {
+  string text;
+};
+
+struct LineEdit::State {
+  Color backgroundColor = {255, 255, 255};
+  bool editable = true;
+  Color foregroundColor = {0, 0, 0};
+  string text;
+};
+
+struct ListView::State {
+  Color backgroundColor = {255, 255, 255};
+  bool checkable = false;
+  vector<bool> checked;
+  Color foregroundColor = {0, 0, 0};
+  lstring headerText;
+  bool headerVisible = false;
+  vector<vector<nall::image>> image;
+  bool selected = false;
+  unsigned selection = 0;
+  vector<lstring> text;
+};
+
+struct ProgressBar::State {
+  unsigned position = 0;
+};
+
+struct RadioButton::State {
+  bool checked = true;
+  nall::group<RadioButton> group;
+  nall::image image;
+  Orientation orientation = Orientation::Horizontal;
+  string text;
+};
+
+struct RadioLabel::State {
+  bool checked = true;
+  nall::group<RadioLabel> group;
+  string text;
+};
+
+struct TabFrame::State {
+  vector<nall::image> image;
+  vector<Layout*> layout;
+  unsigned selection = 0;
+  lstring text;
+};
+
+struct TextEdit::State {
+  Color backgroundColor = {255, 255, 255};
+  unsigned cursorPosition = 0;
+  bool editable = true;
+  Color foregroundColor = {0, 0, 0};
+  string text;
+  bool wordWrap = true;
+};
+
+struct VerticalScroller::State {
+  unsigned length = 101;
+  unsigned position = 0;
+};
+
+struct VerticalSlider::State {
+  unsigned length = 101;
+  unsigned position = 0;
+};
+
+struct Viewport::State {
+  bool droppable = false;
+};
diff -Nru higan/phoenix/GNUmakefile nSide/phoenix/GNUmakefile
--- higan/phoenix/GNUmakefile	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/GNUmakefile	2015-09-16 13:08:13.619563374 +0900
@@ -0,0 +1,27 @@
+ifeq ($(platform),)
+  phoenixflags = $(cppflags) $(flags) -DPHOENIX_REFERENCE
+  phoenixlink =
+else ifeq ($(platform),windows)
+  phoenixflags = $(cppflags) $(flags) -DPHOENIX_WINDOWS
+  phoenixlink = -lkernel32 -luser32 -lgdi32 -ladvapi32 -lole32 -lcomctl32 -lcomdlg32 -luxtheme -lmsimg32 -lshlwapi
+  ifeq ($(arch),x86)
+    phoenixlink += -m32
+  endif
+else ifeq ($(platform),macosx)
+  phoenixflags = $(objcppflags) $(flags) -DPHOENIX_COCOA
+  phoenixlink = -framework Cocoa -framework Carbon
+else
+  ifeq ($(phoenix),)
+    phoenix := gtk
+  endif
+
+  ifeq ($(phoenix),gtk)
+    phoenixflags = $(cppflags) $(flags) -DPHOENIX_GTK `pkg-config --cflags gtk+-2.0`
+    phoenixlink = `pkg-config --libs gtk+-2.0`
+  endif
+
+  ifeq ($(phoenix),qt)
+    phoenixflags = $(cppflags) $(flags) -DPHOENIX_QT `pkg-config --cflags QtCore QtGui`
+    phoenixlink = `pkg-config --libs QtCore QtGui`
+  endif
+endif
diff -Nru higan/phoenix/gtk/action/action.cpp nSide/phoenix/gtk/action/action.cpp
--- higan/phoenix/gtk/action/action.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/gtk/action/action.cpp	2015-09-16 13:08:13.559563368 +0900
@@ -0,0 +1,31 @@
+namespace phoenix {
+
+void pAction::setEnabled(bool enabled) {
+  gtk_widget_set_sensitive(widget, enabled);
+}
+
+void pAction::setVisible(bool visible) {
+  gtk_widget_set_visible(widget, visible);
+}
+
+void pAction::constructor() {
+}
+
+void pAction::orphan() {
+}
+
+//GTK+ uses _ for mnemonics, __ for _
+//transform so that & is used for mnemonics, && for &
+string pAction::mnemonic(string text) {
+  text.transform("&_", "\x01\x02");
+  text.replace("\x01\x01", "&");
+  text.transform("\x01", "_");
+  text.replace("\x02", "__");
+  return text;
+}
+
+void pAction::setFont(string font) {
+  pFont::setFont(widget, font);
+}
+
+}
diff -Nru higan/phoenix/gtk/action/check-item.cpp nSide/phoenix/gtk/action/check-item.cpp
--- higan/phoenix/gtk/action/check-item.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/gtk/action/check-item.cpp	2015-09-16 13:08:13.559563368 +0900
@@ -0,0 +1,34 @@
+namespace phoenix {
+
+static void CheckItem_toggle(GtkCheckMenuItem* gtkCheckMenuItem, CheckItem* self) {
+  self->state.checked = gtk_check_menu_item_get_active(gtkCheckMenuItem);
+  if(!self->p.locked && self->onToggle) self->onToggle();
+}
+
+void pCheckItem::setChecked(bool checked) {
+  locked = true;
+  gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(widget), checked);
+  locked = false;
+}
+
+void pCheckItem::setText(string text) {
+  gtk_menu_item_set_label(GTK_MENU_ITEM(widget), mnemonic(text));
+}
+
+void pCheckItem::constructor() {
+  widget = gtk_check_menu_item_new_with_mnemonic("");
+  setChecked(checkItem.state.checked);
+  setText(checkItem.state.text);
+  g_signal_connect(G_OBJECT(widget), "toggled", G_CALLBACK(CheckItem_toggle), (gpointer)&checkItem);
+}
+
+void pCheckItem::destructor() {
+  gtk_widget_destroy(widget);
+}
+
+void pCheckItem::orphan() {
+  destructor();
+  constructor();
+}
+
+}
diff -Nru higan/phoenix/gtk/action/item.cpp nSide/phoenix/gtk/action/item.cpp
--- higan/phoenix/gtk/action/item.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/gtk/action/item.cpp	2015-09-16 13:08:13.559563368 +0900
@@ -0,0 +1,35 @@
+namespace phoenix {
+
+static void Item_activate(Item* self) {
+  if(self->onActivate) self->onActivate();
+}
+
+void pItem::setImage(const image& image) {
+  if(image.empty() == false) {
+    GtkImage* gtkImage = CreateImage(image, true);
+    gtk_image_menu_item_set_image(GTK_IMAGE_MENU_ITEM(widget), (GtkWidget*)gtkImage);
+  } else {
+    gtk_image_menu_item_set_image(GTK_IMAGE_MENU_ITEM(widget), nullptr);
+  }
+}
+
+void pItem::setText(string text) {
+  gtk_menu_item_set_label(GTK_MENU_ITEM(widget), mnemonic(text));
+}
+
+void pItem::constructor() {
+  widget = gtk_image_menu_item_new_with_mnemonic("");
+  g_signal_connect_swapped(G_OBJECT(widget), "activate", G_CALLBACK(Item_activate), (gpointer)&item);
+  setText(item.state.text);
+}
+
+void pItem::destructor() {
+  gtk_widget_destroy(widget);
+}
+
+void pItem::orphan() {
+  destructor();
+  constructor();
+}
+
+}
diff -Nru higan/phoenix/gtk/action/menu.cpp nSide/phoenix/gtk/action/menu.cpp
--- higan/phoenix/gtk/action/menu.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/gtk/action/menu.cpp	2015-09-16 13:08:13.559563368 +0900
@@ -0,0 +1,55 @@
+namespace phoenix {
+
+void pMenu::append(Action& action) {
+  action.state.window = this->action.state.window;
+
+  gtk_menu_shell_append(GTK_MENU_SHELL(gtkMenu), action.p.widget);
+  if(action.state.window && action.state.window->state.menuFont != "") {
+    action.p.setFont(action.state.window->state.menuFont);
+  }
+  gtk_widget_show(action.p.widget);
+}
+
+void pMenu::remove(Action& action) {
+  action.p.orphan();
+  action.state.window = nullptr;
+}
+
+void pMenu::setImage(const image& image) {
+  if(image.empty() == false) {
+    GtkImage* gtkImage = CreateImage(image, true);
+    gtk_image_menu_item_set_image(GTK_IMAGE_MENU_ITEM(widget), (GtkWidget*)gtkImage);
+  } else {
+    gtk_image_menu_item_set_image(GTK_IMAGE_MENU_ITEM(widget), nullptr);
+  }
+}
+
+void pMenu::setText(string text) {
+  gtk_menu_item_set_label(GTK_MENU_ITEM(widget), mnemonic(text));
+}
+
+void pMenu::constructor() {
+  gtkMenu = gtk_menu_new();
+  widget = gtk_image_menu_item_new_with_mnemonic("");
+  gtk_menu_item_set_submenu(GTK_MENU_ITEM(widget), gtkMenu);
+  setText(menu.state.text);
+}
+
+void pMenu::destructor() {
+  gtk_widget_destroy(gtkMenu);
+  gtk_widget_destroy(widget);
+}
+
+void pMenu::orphan() {
+  for(auto& action : menu.state.action) action.p.orphan();
+  destructor();
+  constructor();
+  for(auto& action : menu.state.action) append(action);
+}
+
+void pMenu::setFont(string font) {
+  pAction::setFont(font);
+  for(auto& item : menu.state.action) item.p.setFont(font);
+}
+
+}
diff -Nru higan/phoenix/gtk/action/radio-item.cpp nSide/phoenix/gtk/action/radio-item.cpp
--- higan/phoenix/gtk/action/radio-item.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/gtk/action/radio-item.cpp	2015-09-16 13:08:13.559563368 +0900
@@ -0,0 +1,62 @@
+namespace phoenix {
+
+static void RadioItem_activate(GtkCheckMenuItem* gtkCheckMenuItem, RadioItem* self) {
+  self->p.onActivate();
+}
+
+void pRadioItem::setChecked() {
+  parent().locked = true;
+  for(auto& item : radioItem.state.group) gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(item.p.widget), false);
+  gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(widget), true);
+  parent().locked = false;
+}
+
+void pRadioItem::setGroup(const group<RadioItem>& group) {
+  parent().locked = true;
+  for(auto& item : group) {
+    if(&item == &group.first()) continue;
+    GSList* currentGroup = gtk_radio_menu_item_get_group(GTK_RADIO_MENU_ITEM(group.first().p.widget));
+    if(currentGroup != gtk_radio_menu_item_get_group(GTK_RADIO_MENU_ITEM(item.p.widget))) {
+      gtk_radio_menu_item_set_group(GTK_RADIO_MENU_ITEM(item.p.widget), currentGroup);
+    }
+  }
+  parent().locked = false;
+}
+
+void pRadioItem::setText(string text) {
+  gtk_menu_item_set_label(GTK_MENU_ITEM(widget), mnemonic(text));
+}
+
+void pRadioItem::constructor() {
+  widget = gtk_radio_menu_item_new_with_mnemonic(0, "");
+  setGroup(radioItem.state.group);
+  setText(radioItem.state.text);
+  for(auto& item : radioItem.state.group) {
+    gtk_check_menu_item_set_active(GTK_CHECK_MENU_ITEM(item.p.widget), item.state.checked);
+  }
+  g_signal_connect(G_OBJECT(widget), "toggled", G_CALLBACK(RadioItem_activate), (gpointer)&radioItem);
+}
+
+void pRadioItem::destructor() {
+  gtk_widget_destroy(widget);
+}
+
+void pRadioItem::orphan() {
+  destructor();
+  constructor();
+}
+
+void pRadioItem::onActivate() {
+  if(parent().locked) return;
+  bool wasChecked = radioItem.state.checked;
+  radioItem.setChecked();
+  if(wasChecked) return;
+  if(radioItem.onActivate) radioItem.onActivate();
+}
+
+pRadioItem& pRadioItem::parent() {
+  if(radioItem.state.group.size()) return radioItem.state.group.first().p;
+  return *this;
+}
+
+}
diff -Nru higan/phoenix/gtk/action/separator.cpp nSide/phoenix/gtk/action/separator.cpp
--- higan/phoenix/gtk/action/separator.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/gtk/action/separator.cpp	2015-09-16 13:08:13.558563368 +0900
@@ -0,0 +1,16 @@
+namespace phoenix {
+
+void pSeparator::constructor() {
+  widget = gtk_separator_menu_item_new();
+}
+
+void pSeparator::destructor() {
+  gtk_widget_destroy(widget);
+}
+
+void pSeparator::orphan() {
+  destructor();
+  constructor();
+}
+
+}
diff -Nru higan/phoenix/gtk/application.cpp nSide/phoenix/gtk/application.cpp
--- higan/phoenix/gtk/application.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/gtk/application.cpp	2015-09-16 13:08:13.566563369 +0900
@@ -0,0 +1,60 @@
+namespace phoenix {
+
+XlibDisplay* pApplication::display = nullptr;
+
+void pApplication::run() {
+  if(Application::main) {
+    while(applicationState.quit == false) {
+      processEvents();
+      Application::main();
+    }
+  } else {
+    gtk_main();
+  }
+}
+
+bool pApplication::pendingEvents() {
+  return gtk_events_pending();
+}
+
+void pApplication::processEvents() {
+  while(pendingEvents()) gtk_main_iteration_do(false);
+}
+
+void pApplication::quit() {
+  //if gtk_main() was invoked, call gtk_main_quit()
+  if(gtk_main_level()) gtk_main_quit();
+}
+
+void pApplication::initialize() {
+  display = XOpenDisplay(nullptr);
+
+  settings = new Settings;
+  settings->load();
+
+  int argc = 1;
+  char* argv[] = {new char[8], nullptr};
+  strcpy(argv[0], "phoenix");
+  char** argvp = argv;
+  gtk_init(&argc, &argvp);
+
+  GtkSettings* gtkSettings = gtk_settings_get_default();
+//g_object_set(gtkSettings, "gtk-button-images", true, nullptr);
+
+  gtk_rc_parse_string(R"(
+    style "phoenix-gtk"
+    {
+      GtkWindow::resize-grip-width = 0
+      GtkWindow::resize-grip-height = 0
+      GtkTreeView::vertical-separator = 0
+      GtkComboBox::appears-as-list = 1
+    }
+    class "GtkWindow" style "phoenix-gtk"
+    class "GtkTreeView" style "phoenix-gtk"
+  # class "GtkComboBox" style "phoenix-gtk"
+  )");
+
+  pKeyboard::initialize();
+}
+
+}
diff -Nru higan/phoenix/gtk/browser-window.cpp nSide/phoenix/gtk/browser-window.cpp
--- higan/phoenix/gtk/browser-window.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/gtk/browser-window.cpp	2015-09-16 13:08:13.568563369 +0900
@@ -0,0 +1,88 @@
+namespace phoenix {
+
+static void BrowserWindow_addFilters(GtkWidget* dialog, lstring filters) {
+  for(auto& filter : filters) {
+    GtkFileFilter* gtkFilter = gtk_file_filter_new();
+    gtk_file_filter_set_name(gtkFilter, filter);
+    lstring patterns = filter.split("(", 1L)(1).rtrim<1>(")").split(",");
+    for(auto& pattern : patterns) gtk_file_filter_add_pattern(gtkFilter, pattern.strip());
+    gtk_file_chooser_add_filter(GTK_FILE_CHOOSER(dialog), gtkFilter);
+  }
+}
+
+string pBrowserWindow::directory(BrowserWindow::State& state) {
+  string name;
+
+  GtkWidget* dialog = gtk_file_chooser_dialog_new(
+    state.title ? state.title : "Select Directory",
+    state.parent ? GTK_WINDOW(state.parent->p.widget) : (GtkWindow*)nullptr,
+    GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER,
+    GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
+    GTK_STOCK_OPEN, GTK_RESPONSE_ACCEPT,
+    (const gchar*)nullptr
+  );
+
+  if(state.path) gtk_file_chooser_set_current_folder(GTK_FILE_CHOOSER(dialog), state.path);
+
+  if(gtk_dialog_run(GTK_DIALOG(dialog)) == GTK_RESPONSE_ACCEPT) {
+    char* temp = gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(dialog));
+    name = temp;
+    g_free(temp);
+  }
+
+  gtk_widget_destroy(dialog);
+  if(name && !name.endsWith("/")) name.append("/");
+  return name;
+}
+
+string pBrowserWindow::open(BrowserWindow::State& state) {
+  string name;
+
+  GtkWidget* dialog = gtk_file_chooser_dialog_new(
+    state.title ? state.title : "Open File",
+    state.parent ? GTK_WINDOW(state.parent->p.widget) : (GtkWindow*)nullptr,
+    GTK_FILE_CHOOSER_ACTION_OPEN,
+    GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
+    GTK_STOCK_OPEN, GTK_RESPONSE_ACCEPT,
+    (const gchar*)nullptr
+  );
+
+  if(state.path) gtk_file_chooser_set_current_folder(GTK_FILE_CHOOSER(dialog), state.path);
+  BrowserWindow_addFilters(dialog, state.filters);
+
+  if(gtk_dialog_run(GTK_DIALOG(dialog)) == GTK_RESPONSE_ACCEPT) {
+    char* temp = gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(dialog));
+    name = temp;
+    g_free(temp);
+  }
+
+  gtk_widget_destroy(dialog);
+  return name;
+}
+
+string pBrowserWindow::save(BrowserWindow::State& state) {
+  string name;
+
+  GtkWidget* dialog = gtk_file_chooser_dialog_new(
+    state.title ? state.title : "Save File",
+    state.parent ? GTK_WINDOW(state.parent->p.widget) : (GtkWindow*)nullptr,
+    GTK_FILE_CHOOSER_ACTION_SAVE,
+    GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
+    GTK_STOCK_OPEN, GTK_RESPONSE_ACCEPT,
+    (const gchar*)nullptr
+  );
+
+  if(state.path) gtk_file_chooser_set_current_folder(GTK_FILE_CHOOSER(dialog), state.path);
+  BrowserWindow_addFilters(dialog, state.filters);
+
+  if(gtk_dialog_run(GTK_DIALOG(dialog)) == GTK_RESPONSE_ACCEPT) {
+    char* temp = gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(dialog));
+    name = temp;
+    g_free(temp);
+  }
+
+  gtk_widget_destroy(dialog);
+  return name;
+}
+
+}
diff -Nru higan/phoenix/gtk/desktop.cpp nSide/phoenix/gtk/desktop.cpp
--- higan/phoenix/gtk/desktop.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/gtk/desktop.cpp	2015-09-16 13:08:13.558563368 +0900
@@ -0,0 +1,40 @@
+namespace phoenix {
+
+Size pDesktop::size() {
+  return {
+    gdk_screen_get_width(gdk_screen_get_default()),
+    gdk_screen_get_height(gdk_screen_get_default())
+  };
+}
+
+Geometry pDesktop::workspace() {
+  XlibDisplay* display = XOpenDisplay(nullptr);
+  int screen = DefaultScreen(display);
+
+  static Atom atom = XlibNone;
+  if(atom == XlibNone) atom = XInternAtom(display, "_NET_WORKAREA", True);
+
+  int format;
+  unsigned char* data = nullptr;
+  unsigned long items, after;
+  Atom returnAtom;
+
+  int result = XGetWindowProperty(
+    display, RootWindow(display, screen), atom, 0, 4, False, XA_CARDINAL, &returnAtom, &format, &items, &after, &data
+  );
+
+  XCloseDisplay(display);
+
+  if(result == Success && returnAtom == XA_CARDINAL && format == 32 && items == 4) {
+    unsigned long *workarea = (unsigned long*)data;
+    return {(signed)workarea[0], (signed)workarea[1], (unsigned)workarea[2], (unsigned)workarea[3]};
+  }
+
+  return {
+    0, 0,
+    gdk_screen_get_width(gdk_screen_get_default()),
+    gdk_screen_get_height(gdk_screen_get_default())
+  };
+}
+
+}
diff -Nru higan/phoenix/gtk/font.cpp nSide/phoenix/gtk/font.cpp
--- higan/phoenix/gtk/font.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/gtk/font.cpp	2015-09-16 13:08:13.566563369 +0900
@@ -0,0 +1,77 @@
+namespace phoenix {
+
+string pFont::serif(unsigned size, string style) {
+  if(size == 0) size = 8;
+  if(style == "") style = "Normal";
+  return {"Serif, ", size, ", ", style};
+}
+
+string pFont::sans(unsigned size, string style) {
+  if(size == 0) size = 8;
+  if(style == "") style = "Normal";
+  return {"Sans, ", size, ", ", style};
+}
+
+string pFont::monospace(unsigned size, string style) {
+  if(size == 0) size = 8;
+  return {"Liberation Mono, ", size, ", ", style};
+}
+
+Size pFont::size(string font, string text) {
+  PangoFontDescription* description = create(font);
+  Size size = pFont::size(description, text);
+  free(description);
+  return size;
+}
+
+PangoFontDescription* pFont::create(string description) {
+  lstring part = description.split(",", 2L).strip();
+
+  string family = "Sans";
+  unsigned size = 8u;
+  bool bold = false;
+  bool italic = false;
+
+  if(part[0] != "") family = part[0];
+  if(part.size() >= 2) size = decimal(part[1]);
+  if(part.size() >= 3) bold = (bool)part[2].find("Bold");
+  if(part.size() >= 3) italic = (bool)part[2].find("Italic");
+
+  PangoFontDescription* font = pango_font_description_new();
+  pango_font_description_set_family(font, family);
+  pango_font_description_set_size(font, size * PANGO_SCALE);
+  pango_font_description_set_weight(font, !bold ? PANGO_WEIGHT_NORMAL : PANGO_WEIGHT_BOLD);
+  pango_font_description_set_style(font, !italic ? PANGO_STYLE_NORMAL : PANGO_STYLE_OBLIQUE);
+  return font;
+}
+
+void pFont::free(PangoFontDescription* font) {
+  pango_font_description_free(font);
+}
+
+Size pFont::size(PangoFontDescription* font, string text) {
+  PangoContext* context = gdk_pango_context_get_for_screen(gdk_screen_get_default());
+  PangoLayout* layout = pango_layout_new(context);
+  pango_layout_set_font_description(layout, font);
+  pango_layout_set_text(layout, text, -1);
+  int width = 0, height = 0;
+  pango_layout_get_pixel_size(layout, &width, &height);
+  g_object_unref((gpointer)layout);
+  return {width, height};
+}
+
+void pFont::setFont(GtkWidget* widget, string font) {
+  auto gtkFont = pFont::create(font);
+  pFont::setFont(widget, (gpointer)gtkFont);
+  pFont::free(gtkFont);
+}
+
+void pFont::setFont(GtkWidget* widget, gpointer font) {
+  if(font == nullptr) return;
+  gtk_widget_modify_font(widget, (PangoFontDescription*)font);
+  if(GTK_IS_CONTAINER(widget)) {
+    gtk_container_foreach(GTK_CONTAINER(widget), (GtkCallback)pFont::setFont, font);
+  }
+}
+
+}
diff -Nru higan/phoenix/gtk/header.hpp nSide/phoenix/gtk/header.hpp
--- higan/phoenix/gtk/header.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/gtk/header.hpp	2015-09-16 13:08:13.566563369 +0900
@@ -0,0 +1,8 @@
+#include <nall/xorg/guard.hpp>
+#include <gtk/gtk.h>
+#include <gdk/gdk.h>
+#include <gdk/gdkx.h>
+#include <gdk/gdkkeysyms.h>
+#include <cairo.h>
+#include <X11/Xatom.h>
+#include <nall/xorg/guard.hpp>
diff -Nru higan/phoenix/gtk/keyboard.cpp nSide/phoenix/gtk/keyboard.cpp
--- higan/phoenix/gtk/keyboard.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/gtk/keyboard.cpp	2015-09-16 13:08:13.567563369 +0900
@@ -0,0 +1,149 @@
+namespace phoenix {
+
+void pKeyboard::initialize() {
+  auto append = [](Keyboard::Scancode scancode, unsigned keysym) {
+    settings->keymap.insert(scancode, XKeysymToKeycode(pApplication::display, keysym));
+  };
+
+  append(Keyboard::Scancode::Escape, XK_Escape);
+  append(Keyboard::Scancode::F1, XK_F1);
+  append(Keyboard::Scancode::F2, XK_F2);
+  append(Keyboard::Scancode::F3, XK_F3);
+  append(Keyboard::Scancode::F4, XK_F4);
+  append(Keyboard::Scancode::F5, XK_F5);
+  append(Keyboard::Scancode::F6, XK_F6);
+  append(Keyboard::Scancode::F7, XK_F7);
+  append(Keyboard::Scancode::F8, XK_F8);
+  append(Keyboard::Scancode::F9, XK_F9);
+  append(Keyboard::Scancode::F10, XK_F10);
+  append(Keyboard::Scancode::F11, XK_F11);
+  append(Keyboard::Scancode::F12, XK_F12);
+
+  append(Keyboard::Scancode::PrintScreen, XK_Print);
+  append(Keyboard::Scancode::ScrollLock, XK_Scroll_Lock);
+  append(Keyboard::Scancode::Pause, XK_Pause);
+
+  append(Keyboard::Scancode::Insert, XK_Insert);
+  append(Keyboard::Scancode::Delete, XK_Delete);
+  append(Keyboard::Scancode::Home, XK_Home);
+  append(Keyboard::Scancode::End, XK_End);
+  append(Keyboard::Scancode::PageUp, XK_Prior);
+  append(Keyboard::Scancode::PageDown, XK_Next);
+
+  append(Keyboard::Scancode::Up, XK_Up);
+  append(Keyboard::Scancode::Down, XK_Down);
+  append(Keyboard::Scancode::Left, XK_Left);
+  append(Keyboard::Scancode::Right, XK_Right);
+
+  append(Keyboard::Scancode::Grave, XK_asciitilde);
+  append(Keyboard::Scancode::Number1, XK_1);
+  append(Keyboard::Scancode::Number2, XK_2);
+  append(Keyboard::Scancode::Number3, XK_3);
+  append(Keyboard::Scancode::Number4, XK_4);
+  append(Keyboard::Scancode::Number5, XK_5);
+  append(Keyboard::Scancode::Number6, XK_6);
+  append(Keyboard::Scancode::Number7, XK_7);
+  append(Keyboard::Scancode::Number8, XK_8);
+  append(Keyboard::Scancode::Number9, XK_9);
+  append(Keyboard::Scancode::Number0, XK_0);
+  append(Keyboard::Scancode::Minus, XK_minus);
+  append(Keyboard::Scancode::Equal, XK_equal);
+  append(Keyboard::Scancode::Backspace, XK_BackSpace);
+
+  append(Keyboard::Scancode::BracketLeft, XK_bracketleft);
+  append(Keyboard::Scancode::BracketRight, XK_bracketright);
+  append(Keyboard::Scancode::Backslash, XK_backslash);
+  append(Keyboard::Scancode::Semicolon, XK_semicolon);
+  append(Keyboard::Scancode::Apostrophe, XK_apostrophe);
+  append(Keyboard::Scancode::Comma, XK_comma);
+  append(Keyboard::Scancode::Period, XK_period);
+  append(Keyboard::Scancode::Slash, XK_slash);
+
+  append(Keyboard::Scancode::Tab, XK_Tab);
+  append(Keyboard::Scancode::CapsLock, XK_Caps_Lock);
+  append(Keyboard::Scancode::Return, XK_Return);
+  append(Keyboard::Scancode::ShiftLeft, XK_Shift_L);
+  append(Keyboard::Scancode::ShiftRight, XK_Shift_R);
+  append(Keyboard::Scancode::ControlLeft, XK_Control_L);
+  append(Keyboard::Scancode::ControlRight, XK_Control_R);
+  append(Keyboard::Scancode::SuperLeft, XK_Super_L);
+  append(Keyboard::Scancode::SuperRight, XK_Super_R);
+  append(Keyboard::Scancode::AltLeft, XK_Alt_L);
+  append(Keyboard::Scancode::AltRight, XK_Alt_R);
+  append(Keyboard::Scancode::Space, XK_space);
+  append(Keyboard::Scancode::Menu, XK_Menu);
+
+  append(Keyboard::Scancode::A, XK_A);
+  append(Keyboard::Scancode::B, XK_B);
+  append(Keyboard::Scancode::C, XK_C);
+  append(Keyboard::Scancode::D, XK_D);
+  append(Keyboard::Scancode::E, XK_E);
+  append(Keyboard::Scancode::F, XK_F);
+  append(Keyboard::Scancode::G, XK_G);
+  append(Keyboard::Scancode::H, XK_H);
+  append(Keyboard::Scancode::I, XK_I);
+  append(Keyboard::Scancode::J, XK_J);
+  append(Keyboard::Scancode::K, XK_K);
+  append(Keyboard::Scancode::L, XK_L);
+  append(Keyboard::Scancode::M, XK_M);
+  append(Keyboard::Scancode::N, XK_N);
+  append(Keyboard::Scancode::O, XK_O);
+  append(Keyboard::Scancode::P, XK_P);
+  append(Keyboard::Scancode::Q, XK_Q);
+  append(Keyboard::Scancode::R, XK_R);
+  append(Keyboard::Scancode::S, XK_S);
+  append(Keyboard::Scancode::T, XK_T);
+  append(Keyboard::Scancode::U, XK_U);
+  append(Keyboard::Scancode::V, XK_V);
+  append(Keyboard::Scancode::W, XK_W);
+  append(Keyboard::Scancode::X, XK_X);
+  append(Keyboard::Scancode::Y, XK_Y);
+  append(Keyboard::Scancode::Z, XK_Z);
+
+  append(Keyboard::Scancode::NumLock, XK_Num_Lock);
+  append(Keyboard::Scancode::Divide, XK_KP_Divide);
+  append(Keyboard::Scancode::Multiply, XK_KP_Multiply);
+  append(Keyboard::Scancode::Subtract, XK_KP_Subtract);
+  append(Keyboard::Scancode::Add, XK_KP_Add);
+  append(Keyboard::Scancode::Enter, XK_KP_Enter);
+  append(Keyboard::Scancode::Point, XK_KP_Decimal);
+
+  append(Keyboard::Scancode::Keypad1, XK_KP_1);
+  append(Keyboard::Scancode::Keypad2, XK_KP_2);
+  append(Keyboard::Scancode::Keypad3, XK_KP_3);
+  append(Keyboard::Scancode::Keypad4, XK_KP_4);
+  append(Keyboard::Scancode::Keypad5, XK_KP_5);
+  append(Keyboard::Scancode::Keypad6, XK_KP_6);
+  append(Keyboard::Scancode::Keypad7, XK_KP_7);
+  append(Keyboard::Scancode::Keypad8, XK_KP_8);
+  append(Keyboard::Scancode::Keypad9, XK_KP_9);
+  append(Keyboard::Scancode::Keypad0, XK_KP_0);
+}
+
+bool pKeyboard::pressed(Keyboard::Scancode scancode) {
+  char state[256];
+  XQueryKeymap(pApplication::display, state);
+  if(auto result = settings->keymap.find(scancode)) {
+    unsigned id = result();
+    return state[id >> 3] & (1 << (id & 7));
+  }
+  return false;
+}
+
+vector<bool> pKeyboard::state() {
+  vector<bool> output;
+  output.resize((unsigned)Keyboard::Scancode::Limit);
+  for(auto& n : output) n = false;
+
+  char state[256];
+  XQueryKeymap(pApplication::display, state);
+  for(auto node : settings->keymap) {
+    if(state[node.value >> 3] & (1 << (node.value & 7))) {
+      output[(unsigned)node.key] = true;
+    }
+  }
+
+  return output;
+}
+
+}
diff -Nru higan/phoenix/gtk/message-window.cpp nSide/phoenix/gtk/message-window.cpp
--- higan/phoenix/gtk/message-window.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/gtk/message-window.cpp	2015-09-16 13:08:13.566563369 +0900
@@ -0,0 +1,60 @@
+namespace phoenix {
+
+static MessageWindow::Response Message(MessageWindow::State& state, GtkMessageType messageStyle) {
+  GtkWidget* dialog = gtk_message_dialog_new(
+    state.parent ? GTK_WINDOW(state.parent->p.widget) : (GtkWindow*)nullptr,
+    GTK_DIALOG_MODAL, messageStyle, GTK_BUTTONS_NONE, "%s", (const char*)state.text
+  );
+
+  if(state.title) gtk_window_set_title(GTK_WINDOW(dialog), state.title);
+  else if(applicationState.name) gtk_window_set_title(GTK_WINDOW(dialog), applicationState.name);
+
+  switch(state.buttons) {
+  case MessageWindow::Buttons::Ok:
+    gtk_dialog_add_buttons(GTK_DIALOG(dialog), "Ok", GTK_RESPONSE_OK, nullptr);
+    break;
+  case MessageWindow::Buttons::OkCancel:
+    gtk_dialog_add_buttons(GTK_DIALOG(dialog), "Ok", GTK_RESPONSE_OK, "Cancel", GTK_RESPONSE_CANCEL, nullptr);
+    break;
+  case MessageWindow::Buttons::YesNo:
+    gtk_dialog_add_buttons(GTK_DIALOG(dialog), "Yes", GTK_RESPONSE_YES, "No", GTK_RESPONSE_NO, nullptr);
+    break;
+  case MessageWindow::Buttons::YesNoCancel:
+    gtk_dialog_add_buttons(GTK_DIALOG(dialog), "Yes", GTK_RESPONSE_YES, "No", GTK_RESPONSE_NO, "Cancel", GTK_RESPONSE_CANCEL, nullptr);
+    break;
+  }
+
+  auto response = gtk_dialog_run(GTK_DIALOG(dialog));
+  gtk_widget_destroy(dialog);
+
+  if(response == GTK_RESPONSE_OK) return MessageWindow::Response::Ok;
+  if(response == GTK_RESPONSE_CANCEL) return MessageWindow::Response::Cancel;
+  if(response == GTK_RESPONSE_YES) return MessageWindow::Response::Yes;
+  if(response == GTK_RESPONSE_NO) return MessageWindow::Response::No;
+
+  //if dialog was closed without choosing a button, choose the most appropriate response
+  if(state.buttons == MessageWindow::Buttons::Ok) return MessageWindow::Response::Ok;
+  if(state.buttons == MessageWindow::Buttons::OkCancel) return MessageWindow::Response::Cancel;
+  if(state.buttons == MessageWindow::Buttons::YesNo) return MessageWindow::Response::No;
+  if(state.buttons == MessageWindow::Buttons::YesNoCancel) return MessageWindow::Response::Cancel;
+
+  throw;
+}
+
+MessageWindow::Response pMessageWindow::error(MessageWindow::State& state) {
+  return Message(state, GTK_MESSAGE_ERROR);
+}
+
+MessageWindow::Response pMessageWindow::information(MessageWindow::State& state) {
+  return Message(state, GTK_MESSAGE_INFO);
+}
+
+MessageWindow::Response pMessageWindow::question(MessageWindow::State& state) {
+  return Message(state, GTK_MESSAGE_QUESTION);
+}
+
+MessageWindow::Response pMessageWindow::warning(MessageWindow::State& state) {
+  return Message(state, GTK_MESSAGE_WARNING);
+}
+
+}
diff -Nru higan/phoenix/gtk/monitor.cpp nSide/phoenix/gtk/monitor.cpp
--- higan/phoenix/gtk/monitor.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/gtk/monitor.cpp	2015-09-16 13:08:13.568563369 +0900
@@ -0,0 +1,17 @@
+namespace phoenix {
+
+unsigned pMonitor::count() {
+  return gdk_screen_get_n_monitors(gdk_screen_get_default());
+}
+
+Geometry pMonitor::geometry(unsigned monitor) {
+  GdkRectangle rectangle = {0};
+  gdk_screen_get_monitor_geometry(gdk_screen_get_default(), monitor, &rectangle);
+  return {rectangle.x, rectangle.y, rectangle.width, rectangle.height};
+}
+
+unsigned pMonitor::primary() {
+  return gdk_screen_get_primary_monitor(gdk_screen_get_default());
+}
+
+}
diff -Nru higan/phoenix/gtk/mouse.cpp nSide/phoenix/gtk/mouse.cpp
--- higan/phoenix/gtk/mouse.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/gtk/mouse.cpp	2015-09-16 13:08:13.566563369 +0900
@@ -0,0 +1,24 @@
+namespace phoenix {
+
+Position pMouse::position() {
+  XlibWindow root, child;
+  int rootx, rooty, winx, winy;
+  unsigned int mask;
+  XQueryPointer(pApplication::display, DefaultRootWindow(pApplication::display), &root, &child, &rootx, &rooty, &winx, &winy, &mask);
+  return {rootx, rooty};
+}
+
+bool pMouse::pressed(Mouse::Button button) {
+  XlibWindow root, child;
+  int rootx, rooty, winx, winy;
+  unsigned int mask;
+  XQueryPointer(pApplication::display, DefaultRootWindow(pApplication::display), &root, &child, &rootx, &rooty, &winx, &winy, &mask);
+  switch(button) {
+  case Mouse::Button::Left: return mask & Button1Mask;
+  case Mouse::Button::Middle: return mask & Button2Mask;
+  case Mouse::Button::Right: return mask & Button3Mask;
+  }
+  return false;
+}
+
+}
diff -Nru higan/phoenix/gtk/platform.cpp nSide/phoenix/gtk/platform.cpp
--- higan/phoenix/gtk/platform.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/gtk/platform.cpp	2015-09-16 13:08:13.568563369 +0900
@@ -0,0 +1,46 @@
+#include "platform.hpp"
+
+#include "utility.cpp"
+#include "settings.cpp"
+
+#include "desktop.cpp"
+#include "monitor.cpp"
+#include "keyboard.cpp"
+#include "mouse.cpp"
+#include "browser-window.cpp"
+#include "message-window.cpp"
+#include "font.cpp"
+#include "timer.cpp"
+#include "window.cpp"
+
+#include "action/action.cpp"
+#include "action/menu.cpp"
+#include "action/separator.cpp"
+#include "action/item.cpp"
+#include "action/check-item.cpp"
+#include "action/radio-item.cpp"
+
+#include "widget/widget.cpp"
+#include "widget/button.cpp"
+#include "widget/canvas.cpp"
+#include "widget/check-button.cpp"
+#include "widget/check-label.cpp"
+#include "widget/combo-button.cpp"
+#include "widget/console.cpp"
+#include "widget/frame.cpp"
+#include "widget/hex-edit.cpp"
+#include "widget/horizontal-scroller.cpp"
+#include "widget/horizontal-slider.cpp"
+#include "widget/label.cpp"
+#include "widget/line-edit.cpp"
+#include "widget/list-view.cpp"
+#include "widget/progress-bar.cpp"
+#include "widget/radio-button.cpp"
+#include "widget/radio-label.cpp"
+#include "widget/tab-frame.cpp"
+#include "widget/text-edit.cpp"
+#include "widget/vertical-scroller.cpp"
+#include "widget/vertical-slider.cpp"
+#include "widget/viewport.cpp"
+
+#include "application.cpp"
diff -Nru higan/phoenix/gtk/platform.hpp nSide/phoenix/gtk/platform.hpp
--- higan/phoenix/gtk/platform.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/gtk/platform.hpp	2015-09-16 13:08:13.560563368 +0900
@@ -0,0 +1,640 @@
+namespace phoenix {
+
+struct pApplication {
+  static XlibDisplay* display;
+
+  static void run();
+  static bool pendingEvents();
+  static void processEvents();
+  static void quit();
+
+  static void initialize();
+};
+
+struct Settings : Configuration::Document {
+  bimap<Keyboard::Scancode, unsigned> keymap;
+
+  struct Geometry : Configuration::Node {
+    unsigned frameX;
+    unsigned frameY;
+    unsigned frameWidth;
+    unsigned frameHeight;
+    unsigned menuHeight;
+    unsigned statusHeight;
+  } geometry;
+
+  struct Window : Configuration::Node {
+    unsigned backgroundColor;
+  } window;
+
+  void load();
+  void save();
+  Settings();
+};
+
+struct pWindow;
+struct pMenu;
+struct pLayout;
+struct pWidget;
+
+struct pFont {
+  static string serif(unsigned size, string style);
+  static string sans(unsigned size, string style);
+  static string monospace(unsigned size, string style);
+  static Size size(string font, string text);
+
+  static PangoFontDescription* create(string description);
+  static void free(PangoFontDescription* font);
+  static Size size(PangoFontDescription* font, string text);
+  static void setFont(GtkWidget* widget, string font);
+  static void setFont(GtkWidget* widget, gpointer font);
+};
+
+struct pDesktop {
+  static Size size();
+  static Geometry workspace();
+};
+
+struct pMonitor {
+  static unsigned count();
+  static Geometry geometry(unsigned monitor);
+  static unsigned primary();
+};
+
+struct pKeyboard {
+  static bool pressed(Keyboard::Scancode scancode);
+  static vector<bool> state();
+
+  static void initialize();
+};
+
+struct pMouse {
+  static Position position();
+  static bool pressed(Mouse::Button button);
+};
+
+struct pBrowserWindow {
+  static string directory(BrowserWindow::State& state);
+  static string open(BrowserWindow::State& state);
+  static string save(BrowserWindow::State& state);
+};
+
+struct pMessageWindow {
+  static MessageWindow::Response error(MessageWindow::State& state);
+  static MessageWindow::Response information(MessageWindow::State& state);
+  static MessageWindow::Response question(MessageWindow::State& state);
+  static MessageWindow::Response warning(MessageWindow::State& state);
+};
+
+struct pObject {
+  Object& object;
+  bool locked;
+
+  pObject(Object& object) : object(object), locked(false) {}
+  virtual ~pObject() {}
+
+  void constructor() {}
+  void destructor() {}
+};
+
+struct pTimer : public pObject {
+  Timer& timer;
+
+  void setEnabled(bool enabled);
+  void setInterval(unsigned interval);
+
+  pTimer(Timer& timer) : pObject(timer), timer(timer) {}
+  void constructor();
+};
+
+struct pWindow : public pObject {
+  Window& window;
+  GtkWidget* widget;
+  GtkWidget* menuContainer;
+  GtkWidget* formContainer;
+  GtkWidget* statusContainer;
+  GtkWidget* menu;
+  GtkWidget* status;
+  GtkAllocation lastAllocation;
+  bool onSizePending;
+
+  static Window& none();
+
+  void append(Layout& layout);
+  void append(Menu& menu);
+  void append(Widget& widget);
+  bool focused();
+  Geometry frameMargin();
+  Geometry geometry();
+  void remove(Layout& layout);
+  void remove(Menu& menu);
+  void remove(Widget& widget);
+  void setBackgroundColor(Color color);
+  void setDroppable(bool droppable);
+  void setFocused();
+  void setFullScreen(bool fullScreen);
+  void setGeometry(Geometry geometry);
+  void setMenuFont(string font);
+  void setMenuVisible(bool visible);
+  void setModal(bool modal);
+  void setResizable(bool resizable);
+  void setStatusFont(string font);
+  void setStatusText(string text);
+  void setStatusVisible(bool visible);
+  void setTitle(string text);
+  void setVisible(bool visible);
+  void setWidgetFont(string font);
+
+  pWindow(Window& window) : pObject(window), window(window) {}
+  void constructor();
+  unsigned menuHeight();
+  unsigned statusHeight();
+};
+
+struct pAction : public pObject {
+  Action& action;
+  GtkWidget* widget;
+
+  void setEnabled(bool enabled);
+  void setVisible(bool visible);
+
+  pAction(Action& action) : pObject(action), action(action) {}
+  void constructor();
+  virtual void orphan();
+  string mnemonic(string text);
+  virtual void setFont(string font);
+};
+
+struct pMenu : public pAction {
+  Menu& menu;
+  GtkWidget* gtkMenu;
+
+  void append(Action& action);
+  void remove(Action& action);
+  void setImage(const image& image);
+  void setText(string text);
+
+  pMenu(Menu &menu) : pAction(menu), menu(menu) {}
+  void constructor();
+  void destructor();
+  void orphan();
+  void setFont(string font);
+};
+
+struct pSeparator : public pAction {
+  Separator& separator;
+
+  pSeparator(Separator& separator) : pAction(separator), separator(separator) {}
+  void constructor();
+  void destructor();
+  void orphan();
+};
+
+struct pItem : public pAction {
+  Item& item;
+
+  void setImage(const image& image);
+  void setText(string text);
+
+  pItem(Item& item) : pAction(item), item(item) {}
+  void constructor();
+  void destructor();
+  void orphan();
+};
+
+struct pCheckItem : public pAction {
+  CheckItem& checkItem;
+
+  void setChecked(bool checked);
+  void setText(string text);
+
+  pCheckItem(CheckItem& checkItem) : pAction(checkItem), checkItem(checkItem) {}
+  void constructor();
+  void destructor();
+  void orphan();
+};
+
+struct pRadioItem : public pAction {
+  RadioItem& radioItem;
+
+  void setChecked();
+  void setGroup(const group<RadioItem>& group);
+  void setText(string text);
+
+  pRadioItem(RadioItem& radioItem) : pAction(radioItem), radioItem(radioItem) {}
+  void constructor();
+  void destructor();
+  void orphan();
+  void onActivate();
+  pRadioItem& parent();
+};
+
+struct pSizable : public pObject {
+  Sizable& sizable;
+
+  virtual Position displacement() { return {0, 0}; }
+
+  pSizable(Sizable &sizable) : pObject(sizable), sizable(sizable) {}
+};
+
+struct pLayout : public pSizable {
+  Layout& layout;
+
+  pLayout(Layout& layout) : pSizable(layout), layout(layout) {}
+};
+
+struct pWidget : public pSizable {
+  Widget& widget;
+  GtkWidget* gtkWidget = nullptr;
+  GtkWidget* gtkParent = nullptr;
+
+  virtual GtkWidget* container(Widget& widget);
+  virtual bool focused();
+  virtual Size minimumSize();
+  virtual void setEnabled(bool enabled);
+  virtual void setFocused();
+  virtual void setFont(string font);
+  virtual void setGeometry(Geometry geometry);
+  virtual void setVisible(bool visible);
+
+  pWidget(Widget& widget) : pSizable(widget), widget(widget) {}
+  void constructor();
+  void destructor();
+  virtual void orphan();
+};
+
+struct pButton : public pWidget {
+  Button& button;
+
+  Size minimumSize();
+  void setImage(const image& image, Orientation orientation);
+  void setText(string text);
+
+  pButton(Button& button) : pWidget(button), button(button) {}
+  void constructor();
+  void destructor();
+  void orphan();
+};
+
+struct pCanvas : public pWidget {
+  Canvas& canvas;
+  GdkPixbuf* surface = nullptr;
+  unsigned surfaceWidth = 0;
+  unsigned surfaceHeight = 0;
+
+  Size minimumSize();
+  void setDroppable(bool droppable);
+  void setGeometry(Geometry geometry);
+  void setMode(Canvas::Mode mode);
+  void setSize(Size size);
+
+  pCanvas(Canvas& canvas) : pWidget(canvas), canvas(canvas) {}
+  void constructor();
+  void destructor();
+  void orphan();
+  void onExpose(GdkEventExpose* event);
+  void rasterize();
+  void redraw();
+  void release();
+};
+
+struct pCheckButton : public pWidget {
+  CheckButton& checkButton;
+
+  Size minimumSize();
+  void setChecked(bool checked);
+  void setImage(const image& image, Orientation orientation);
+  void setText(string text);
+
+  pCheckButton(CheckButton& checkButton) : pWidget(checkButton), checkButton(checkButton) {}
+  void constructor();
+  void destructor();
+  void orphan();
+  void onToggle();
+};
+
+struct pCheckLabel : public pWidget {
+  CheckLabel& checkLabel;
+
+  Size minimumSize();
+  void setChecked(bool checked);
+  void setText(string text);
+
+  pCheckLabel(CheckLabel& checkLabel) : pWidget(checkLabel), checkLabel(checkLabel) {}
+  void constructor();
+  void destructor();
+  void orphan();
+};
+
+struct pComboButton : public pWidget {
+  ComboButton& comboButton;
+  unsigned itemCounter;
+
+  void append(string text);
+  Size minimumSize();
+  void remove(unsigned selection);
+  void reset();
+  void setSelection(unsigned selection);
+  void setText(unsigned selection, string text);
+
+  pComboButton(ComboButton& comboButton) : pWidget(comboButton), comboButton(comboButton) {}
+  void constructor();
+  void destructor();
+  void orphan();
+};
+
+struct pConsole : public pWidget {
+  Console& console;
+  GtkWidget* subWidget;
+  GtkTextBuffer* textBuffer;
+  string previousPrompt;
+  lstring history;
+  unsigned historyOffset = 0;
+
+  void print(string text);
+  void reset();
+  void setBackgroundColor(Color color);
+  void setForegroundColor(Color color);
+  void setPrompt(string prompt);
+
+  pConsole(Console& console) : pWidget(console), console(console) {}
+  void constructor();
+  void destructor();
+  void orphan();
+  bool keyPress(unsigned scancode, unsigned mask);
+  void seekToEnd();
+  void seekToMark();
+};
+
+struct pFrame : public pWidget {
+  Frame& frame;
+
+  GtkWidget* container(Widget& widget);
+  Position containerOffset();
+  void setEnabled(bool enabled);
+  void setGeometry(Geometry geometry);
+  void setText(string text);
+  void setVisible(bool visible);
+
+  pFrame(Frame& frame) : pWidget(frame), frame(frame) {}
+  void constructor();
+  void destructor();
+  void orphan();
+};
+
+struct pHexEdit : public pWidget {
+  HexEdit& hexEdit;
+  GtkWidget* container;
+  GtkWidget* subWidget;
+  GtkWidget* scrollBar;
+  GtkTextBuffer* textBuffer;
+  GtkTextMark* textCursor;
+
+  bool focused();
+  void setBackgroundColor(Color color);
+  void setColumns(unsigned columns);
+  void setForegroundColor(Color color);
+  void setLength(unsigned length);
+  void setOffset(unsigned offset);
+  void setRows(unsigned rows);
+  void update();
+
+  pHexEdit(HexEdit& hexEdit) : pWidget(hexEdit), hexEdit(hexEdit) {}
+  void constructor();
+  void destructor();
+  void orphan();
+  unsigned cursorPosition();
+  bool keyPress(unsigned scancode, unsigned mask);
+  signed rows();
+  signed rowsScrollable();
+  void scroll(signed position);
+  void setCursorPosition(unsigned position);
+  void setScroll();
+  void updateScroll();
+};
+
+struct pHorizontalScroller : public pWidget {
+  HorizontalScroller& horizontalScroller;
+
+  Size minimumSize();
+  void setLength(unsigned length);
+  void setPosition(unsigned position);
+
+  pHorizontalScroller(HorizontalScroller& horizontalScroller) : pWidget(horizontalScroller), horizontalScroller(horizontalScroller) {}
+  void constructor();
+  void destructor();
+  void orphan();
+};
+
+struct pHorizontalSlider : public pWidget {
+  HorizontalSlider& horizontalSlider;
+
+  Size minimumSize();
+  void setLength(unsigned length);
+  void setPosition(unsigned position);
+
+  pHorizontalSlider(HorizontalSlider& horizontalSlider) : pWidget(horizontalSlider), horizontalSlider(horizontalSlider) {}
+  void constructor();
+  void destructor();
+  void orphan();
+};
+
+struct pLabel : public pWidget {
+  Label& label;
+
+  Size minimumSize();
+  void setText(string text);
+
+  pLabel(Label& label) : pWidget(label), label(label) {}
+  void constructor();
+  void destructor();
+  void orphan();
+};
+
+struct pLineEdit : public pWidget {
+  LineEdit& lineEdit;
+
+  Size minimumSize();
+  void setBackgroundColor(Color color);
+  void setEditable(bool editable);
+  void setForegroundColor(Color color);
+  void setText(string text);
+  string text();
+
+  pLineEdit(LineEdit& lineEdit) : pWidget(lineEdit), lineEdit(lineEdit) {}
+  void constructor();
+  void destructor();
+  void orphan();
+};
+
+struct pListView : public pWidget {
+  ListView& listView;
+  GtkWidget* subWidget;
+  GtkListStore* store;
+  struct GtkColumn {
+    GtkTreeViewColumn* column;
+    GtkCellRenderer* checkbutton;
+    GtkCellRenderer* icon;
+    GtkCellRenderer* text;
+    GtkWidget *label;
+  };
+  vector<GtkColumn> column;
+
+  void append(const lstring& text);
+  void autoSizeColumns();
+  bool focused();
+  void remove(unsigned selection);
+  void reset();
+  void setBackgroundColor(Color color);
+  void setCheckable(bool checkable);
+  void setChecked(unsigned selection, bool checked);
+  void setForegroundColor(Color color);
+  void setHeaderText(const lstring& text);
+  void setHeaderVisible(bool visible);
+  void setImage(unsigned selection, unsigned position, const image& image);
+  void setSelected(bool selected);
+  void setSelection(unsigned row);
+  void setText(unsigned selection, unsigned position, string text);
+
+  pListView(ListView& listView) : pWidget(listView), listView(listView) {}
+  void constructor();
+  void destructor();
+  void orphan();
+  void setFocused();
+  void setFont(string font);
+};
+
+struct pProgressBar : public pWidget {
+  ProgressBar& progressBar;
+
+  Size minimumSize();
+  void setPosition(unsigned position);
+
+  pProgressBar(ProgressBar& progressBar) : pWidget(progressBar), progressBar(progressBar) {}
+  void constructor();
+  void destructor();
+  void orphan();
+};
+
+struct pRadioButton : public pWidget {
+  RadioButton& radioButton;
+
+  Size minimumSize();
+  void setChecked();
+  void setGroup(const group<RadioButton>& group);
+  void setImage(const image& image, Orientation orientation);
+  void setText(string text);
+
+  pRadioButton(RadioButton& radioButton) : pWidget(radioButton), radioButton(radioButton) {}
+  void constructor();
+  void destructor();
+  void orphan();
+  void onActivate();
+  pRadioButton& parent();
+};
+
+struct pRadioLabel : public pWidget {
+  RadioLabel& radioLabel;
+
+  Size minimumSize();
+  void setChecked();
+  void setGroup(const group<RadioLabel>& group);
+  void setText(string text);
+
+  pRadioLabel(RadioLabel& radioLabel) : pWidget(radioLabel), radioLabel(radioLabel) {}
+  void onActivate();
+  pRadioLabel& parent();
+  void constructor();
+  void destructor();
+  void orphan();
+};
+
+struct pTabFrame : public pWidget {
+  TabFrame& tabFrame;
+  struct Tab {
+    GtkWidget* child;
+    GtkWidget* container;
+    GtkWidget* layout;
+    GtkWidget* image;
+    GtkWidget* title;
+  };
+  vector<Tab> tabs;
+
+  void append(string text, const image& image);
+  GtkWidget* container(Widget& widget);
+  Position displacement();
+  void remove(unsigned selection);
+  void setEnabled(bool enabled);
+  void setGeometry(Geometry geometry);
+  void setImage(unsigned selection, const image& image);
+  void setSelection(unsigned selection);
+  void setText(unsigned selection, string text);
+  void setVisible(bool visible);
+
+  pTabFrame(TabFrame& tabFrame) : pWidget(tabFrame), tabFrame(tabFrame) {}
+  void constructor();
+  void destructor();
+  void orphan();
+  void setFont(string font);
+  void synchronizeLayout();
+};
+
+struct pTextEdit : public pWidget {
+  TextEdit& textEdit;
+  GtkWidget* subWidget;
+  GtkTextBuffer* textBuffer;
+
+  bool focused();
+  void setBackgroundColor(Color color);
+  void setCursorPosition(unsigned position);
+  void setEditable(bool editable);
+  void setForegroundColor(Color color);
+  void setText(string text);
+  void setWordWrap(bool wordWrap);
+  string text();
+
+  pTextEdit(TextEdit& textEdit) : pWidget(textEdit), textEdit(textEdit) {}
+  void constructor();
+  void destructor();
+  void orphan();
+};
+
+struct pVerticalScroller : public pWidget {
+  VerticalScroller& verticalScroller;
+
+  Size minimumSize();
+  void setLength(unsigned length);
+  void setPosition(unsigned position);
+
+  pVerticalScroller(VerticalScroller& verticalScroller) : pWidget(verticalScroller), verticalScroller(verticalScroller) {}
+  void constructor();
+  void destructor();
+  void orphan();
+};
+
+struct pVerticalSlider : public pWidget {
+  VerticalSlider& verticalSlider;
+
+  Size minimumSize();
+  void setLength(unsigned length);
+  void setPosition(unsigned position);
+
+  pVerticalSlider(VerticalSlider& verticalSlider) : pWidget(verticalSlider), verticalSlider(verticalSlider) {}
+  void constructor();
+  void destructor();
+  void orphan();
+};
+
+struct pViewport : public pWidget {
+  Viewport& viewport;
+
+  uintptr_t handle();
+  void setDroppable(bool droppable);
+
+  pViewport(Viewport& viewport) : pWidget(viewport), viewport(viewport) {}
+  void constructor();
+  void destructor();
+  void orphan();
+};
+
+}
diff -Nru higan/phoenix/gtk/settings.cpp nSide/phoenix/gtk/settings.cpp
--- higan/phoenix/gtk/settings.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/gtk/settings.cpp	2015-09-16 13:08:13.558563368 +0900
@@ -0,0 +1,28 @@
+namespace phoenix {
+
+static Settings* settings = nullptr;
+
+void Settings::load() {
+  string path = {userpath(), ".config/phoenix/"};
+  Configuration::Document::load({path, "gtk.bml"});
+}
+
+void Settings::save() {
+  string path = {userpath(), ".config/phoenix/"};
+  directory::create(path, 0755);
+  Configuration::Document::save({path, "gtk.bml"});
+}
+
+Settings::Settings() {
+  geometry.append(geometry.frameX = 4, "FrameX");
+  geometry.append(geometry.frameY = 24, "FrameY");
+  geometry.append(geometry.frameWidth = 8, "FrameWidth");
+  geometry.append(geometry.frameHeight = 28, "FrameHeight");
+  geometry.append(geometry.menuHeight = 20, "MenuHeight");
+  geometry.append(geometry.statusHeight = 20, "StatusHeight");
+  append(geometry, "Geometry");
+  window.append(window.backgroundColor = 0xedeceb, "BackgroundColor");
+  append(window, "Window");
+}
+
+}
diff -Nru higan/phoenix/gtk/timer.cpp nSide/phoenix/gtk/timer.cpp
--- higan/phoenix/gtk/timer.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/gtk/timer.cpp	2015-09-16 13:08:13.566563369 +0900
@@ -0,0 +1,28 @@
+namespace phoenix {
+
+static guint Timer_trigger(pTimer* self) {
+  //timer may have been disabled prior to triggering, so check state
+  if(self->timer.state.enabled) {
+    if(self->timer.onActivate) self->timer.onActivate();
+  }
+  //callback may have disabled timer, so check state again
+  if(self->timer.state.enabled) {
+    g_timeout_add(self->timer.state.interval, (GSourceFunc)Timer_trigger, (gpointer)self);
+  }
+  //kill this timer instance (it is spawned above if needed again)
+  return false;
+}
+
+void pTimer::setEnabled(bool enabled) {
+  if(enabled) {
+    g_timeout_add(timer.state.interval, (GSourceFunc)Timer_trigger, (gpointer)this);
+  }
+}
+
+void pTimer::setInterval(unsigned interval) {
+}
+
+void pTimer::constructor() {
+}
+
+}
diff -Nru higan/phoenix/gtk/utility.cpp nSide/phoenix/gtk/utility.cpp
--- higan/phoenix/gtk/utility.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/gtk/utility.cpp	2015-09-16 13:08:13.568563369 +0900
@@ -0,0 +1,259 @@
+namespace phoenix {
+
+static GdkColor CreateColor(uint8_t r, uint8_t g, uint8_t b) {
+  GdkColor color;
+  color.pixel = (r << 16) | (g << 8) | (b << 0);
+  color.red = (r << 8) | (r << 0);
+  color.green = (g << 8) | (g << 0);
+  color.blue = (b << 8) | (b << 0);
+  return color;
+}
+
+static GdkPixbuf* CreatePixbuf(const nall::image& image, bool scale = false) {
+  nall::image gdkImage = image;
+  gdkImage.transform(0, 32, 255u << 24, 255u << 0, 255u << 8, 255u << 16);
+  if(scale) gdkImage.scale(15, 15);
+
+  GdkPixbuf* pixbuf = gdk_pixbuf_new(GDK_COLORSPACE_RGB, true, 8, gdkImage.width, gdkImage.height);
+  memcpy(gdk_pixbuf_get_pixels(pixbuf), gdkImage.data(), gdkImage.width * gdkImage.height * 4);
+
+  return pixbuf;
+}
+
+static GtkImage* CreateImage(const nall::image& image, bool scale = false) {
+  GdkPixbuf* pixbuf = CreatePixbuf(image, scale);
+  GtkImage* gtkImage = (GtkImage*)gtk_image_new_from_pixbuf(pixbuf);
+  g_object_unref(pixbuf);
+  return gtkImage;
+}
+
+static lstring DropPaths(GtkSelectionData* data) {
+  gchar** uris = gtk_selection_data_get_uris(data);
+  if(uris == nullptr) return {};
+
+  lstring paths;
+  for(unsigned n = 0; uris[n] != nullptr; n++) {
+    gchar* pathname = g_filename_from_uri(uris[n], nullptr, nullptr);
+    if(pathname == nullptr) continue;
+
+    string path = pathname;
+    g_free(pathname);
+    if(directory::exists(path) && !path.endsWith("/")) path.append("/");
+    paths.append(path);
+  }
+
+  g_strfreev(uris);
+  return paths;
+}
+
+static Position GetDisplacement(Sizable* sizable) {
+  Position position;
+  while(sizable->state.parent) {
+    Position displacement = sizable->state.parent->p.displacement();
+    position.x += displacement.x;
+    position.y += displacement.y;
+    sizable = sizable->state.parent;
+  }
+  return position;
+}
+
+static Layout* GetParentWidgetLayout(Sizable* sizable) {
+  while(sizable) {
+    if(sizable->state.parent && dynamic_cast<TabFrame*>(sizable->state.parent)) return (Layout*)sizable;
+    sizable = sizable->state.parent;
+  }
+  return nullptr;
+}
+
+static Widget* GetParentWidget(Sizable* sizable) {
+  while(sizable) {
+    if(sizable->state.parent && dynamic_cast<TabFrame*>(sizable->state.parent)) return (Widget*)sizable->state.parent;
+    sizable = sizable->state.parent;
+  }
+  return nullptr;
+}
+
+static Keyboard::Keycode Keysym(unsigned keysym) {
+  switch(keysym) {
+  case GDK_Escape: return Keyboard::Keycode::Escape;
+  case GDK_F1: return Keyboard::Keycode::F1;
+  case GDK_F2: return Keyboard::Keycode::F2;
+  case GDK_F3: return Keyboard::Keycode::F3;
+  case GDK_F4: return Keyboard::Keycode::F4;
+  case GDK_F5: return Keyboard::Keycode::F5;
+  case GDK_F6: return Keyboard::Keycode::F6;
+  case GDK_F7: return Keyboard::Keycode::F7;
+  case GDK_F8: return Keyboard::Keycode::F8;
+  case GDK_F9: return Keyboard::Keycode::F9;
+  case GDK_F10: return Keyboard::Keycode::F10;
+  case GDK_F11: return Keyboard::Keycode::F11;
+  case GDK_F12: return Keyboard::Keycode::F12;
+
+  case GDK_Print: return Keyboard::Keycode::PrintScreen;
+  //Keyboard::Keycode::SysRq
+  case GDK_Scroll_Lock: return Keyboard::Keycode::ScrollLock;
+  case GDK_Pause: return Keyboard::Keycode::Pause;
+  //Keyboard::Keycode::Break
+
+  case GDK_Insert: return Keyboard::Keycode::Insert;
+  case GDK_Delete: return Keyboard::Keycode::Delete;
+  case GDK_Home: return Keyboard::Keycode::Home;
+  case GDK_End: return Keyboard::Keycode::End;
+  case GDK_Prior: return Keyboard::Keycode::PageUp;
+  case GDK_Next: return Keyboard::Keycode::PageDown;
+
+  case GDK_Up: return Keyboard::Keycode::Up;
+  case GDK_Down: return Keyboard::Keycode::Down;
+  case GDK_Left: return Keyboard::Keycode::Left;
+  case GDK_Right: return Keyboard::Keycode::Right;
+
+  case GDK_grave: return Keyboard::Keycode::Grave;
+  case GDK_1: return Keyboard::Keycode::Number1;
+  case GDK_2: return Keyboard::Keycode::Number2;
+  case GDK_3: return Keyboard::Keycode::Number3;
+  case GDK_4: return Keyboard::Keycode::Number4;
+  case GDK_5: return Keyboard::Keycode::Number5;
+  case GDK_6: return Keyboard::Keycode::Number6;
+  case GDK_7: return Keyboard::Keycode::Number7;
+  case GDK_8: return Keyboard::Keycode::Number8;
+  case GDK_9: return Keyboard::Keycode::Number9;
+  case GDK_0: return Keyboard::Keycode::Number0;
+  case GDK_minus: return Keyboard::Keycode::Minus;
+  case GDK_equal: return Keyboard::Keycode::Equal;
+  case GDK_BackSpace: return Keyboard::Keycode::Backspace;
+
+  case GDK_asciitilde: return Keyboard::Keycode::Tilde;
+  case GDK_exclam: return Keyboard::Keycode::Exclamation;
+  case GDK_at: return Keyboard::Keycode::At;
+  case GDK_numbersign: return Keyboard::Keycode::Pound;
+  case GDK_dollar: return Keyboard::Keycode::Dollar;
+  case GDK_percent: return Keyboard::Keycode::Percent;
+  case GDK_asciicircum: return Keyboard::Keycode::Power;
+  case GDK_ampersand: return Keyboard::Keycode::Ampersand;
+  case GDK_asterisk: return Keyboard::Keycode::Asterisk;
+  case GDK_parenleft: return Keyboard::Keycode::ParenthesisLeft;
+  case GDK_parenright: return Keyboard::Keycode::ParenthesisRight;
+  case GDK_underscore: return Keyboard::Keycode::Underscore;
+  case GDK_plus: return Keyboard::Keycode::Plus;
+
+  case GDK_bracketleft: return Keyboard::Keycode::BracketLeft;
+  case GDK_bracketright: return Keyboard::Keycode::BracketRight;
+  case GDK_backslash: return Keyboard::Keycode::Backslash;
+  case GDK_semicolon: return Keyboard::Keycode::Semicolon;
+  case GDK_apostrophe: return Keyboard::Keycode::Apostrophe;
+  case GDK_comma: return Keyboard::Keycode::Comma;
+  case GDK_period: return Keyboard::Keycode::Period;
+  case GDK_slash: return Keyboard::Keycode::Slash;
+
+  case GDK_braceleft: return Keyboard::Keycode::BraceLeft;
+  case GDK_braceright: return Keyboard::Keycode::BraceRight;
+  case GDK_bar: return Keyboard::Keycode::Pipe;
+  case GDK_colon: return Keyboard::Keycode::Colon;
+  case GDK_quotedbl: return Keyboard::Keycode::Quote;
+  case GDK_less: return Keyboard::Keycode::CaretLeft;
+  case GDK_greater: return Keyboard::Keycode::CaretRight;
+  case GDK_question: return Keyboard::Keycode::Question;
+
+  case GDK_Tab: return Keyboard::Keycode::Tab;
+  case GDK_Caps_Lock: return Keyboard::Keycode::CapsLock;
+  case GDK_Return: return Keyboard::Keycode::Return;
+  case GDK_Shift_L: return Keyboard::Keycode::ShiftLeft;
+  case GDK_Shift_R: return Keyboard::Keycode::ShiftRight;
+  case GDK_Control_L: return Keyboard::Keycode::ControlLeft;
+  case GDK_Control_R: return Keyboard::Keycode::ControlRight;
+  case GDK_Super_L: return Keyboard::Keycode::SuperLeft;
+  case GDK_Super_R: return Keyboard::Keycode::SuperRight;
+  case GDK_Alt_L: return Keyboard::Keycode::AltLeft;
+  case GDK_Alt_R: return Keyboard::Keycode::AltRight;
+  case GDK_space: return Keyboard::Keycode::Space;
+  case GDK_Menu: return Keyboard::Keycode::Menu;
+
+  case GDK_A: return Keyboard::Keycode::A;
+  case GDK_B: return Keyboard::Keycode::B;
+  case GDK_C: return Keyboard::Keycode::C;
+  case GDK_D: return Keyboard::Keycode::D;
+  case GDK_E: return Keyboard::Keycode::E;
+  case GDK_F: return Keyboard::Keycode::F;
+  case GDK_G: return Keyboard::Keycode::G;
+  case GDK_H: return Keyboard::Keycode::H;
+  case GDK_I: return Keyboard::Keycode::I;
+  case GDK_J: return Keyboard::Keycode::J;
+  case GDK_K: return Keyboard::Keycode::K;
+  case GDK_L: return Keyboard::Keycode::L;
+  case GDK_M: return Keyboard::Keycode::M;
+  case GDK_N: return Keyboard::Keycode::N;
+  case GDK_O: return Keyboard::Keycode::O;
+  case GDK_P: return Keyboard::Keycode::P;
+  case GDK_Q: return Keyboard::Keycode::Q;
+  case GDK_R: return Keyboard::Keycode::R;
+  case GDK_S: return Keyboard::Keycode::S;
+  case GDK_T: return Keyboard::Keycode::T;
+  case GDK_U: return Keyboard::Keycode::U;
+  case GDK_V: return Keyboard::Keycode::V;
+  case GDK_W: return Keyboard::Keycode::W;
+  case GDK_X: return Keyboard::Keycode::X;
+  case GDK_Y: return Keyboard::Keycode::Y;
+  case GDK_Z: return Keyboard::Keycode::Z;
+
+  case GDK_a: return Keyboard::Keycode::a;
+  case GDK_b: return Keyboard::Keycode::b;
+  case GDK_c: return Keyboard::Keycode::c;
+  case GDK_d: return Keyboard::Keycode::d;
+  case GDK_e: return Keyboard::Keycode::e;
+  case GDK_f: return Keyboard::Keycode::f;
+  case GDK_g: return Keyboard::Keycode::g;
+  case GDK_h: return Keyboard::Keycode::h;
+  case GDK_i: return Keyboard::Keycode::i;
+  case GDK_j: return Keyboard::Keycode::j;
+  case GDK_k: return Keyboard::Keycode::k;
+  case GDK_l: return Keyboard::Keycode::l;
+  case GDK_m: return Keyboard::Keycode::m;
+  case GDK_n: return Keyboard::Keycode::n;
+  case GDK_o: return Keyboard::Keycode::o;
+  case GDK_p: return Keyboard::Keycode::p;
+  case GDK_q: return Keyboard::Keycode::q;
+  case GDK_r: return Keyboard::Keycode::r;
+  case GDK_s: return Keyboard::Keycode::s;
+  case GDK_t: return Keyboard::Keycode::t;
+  case GDK_u: return Keyboard::Keycode::u;
+  case GDK_v: return Keyboard::Keycode::v;
+  case GDK_w: return Keyboard::Keycode::w;
+  case GDK_x: return Keyboard::Keycode::x;
+  case GDK_y: return Keyboard::Keycode::y;
+  case GDK_z: return Keyboard::Keycode::z;
+
+  case GDK_Num_Lock: return Keyboard::Keycode::NumLock;
+  case GDK_KP_Divide: return Keyboard::Keycode::Divide;
+  case GDK_KP_Multiply: return Keyboard::Keycode::Multiply;
+  case GDK_KP_Subtract: return Keyboard::Keycode::Subtract;
+  case GDK_KP_Add: return Keyboard::Keycode::Add;
+  case GDK_KP_Enter: return Keyboard::Keycode::Enter;
+  case GDK_KP_Decimal: return Keyboard::Keycode::Point;
+
+  case GDK_KP_1: return Keyboard::Keycode::Keypad1;
+  case GDK_KP_2: return Keyboard::Keycode::Keypad2;
+  case GDK_KP_3: return Keyboard::Keycode::Keypad3;
+  case GDK_KP_4: return Keyboard::Keycode::Keypad4;
+  case GDK_KP_5: return Keyboard::Keycode::Keypad5;
+  case GDK_KP_6: return Keyboard::Keycode::Keypad6;
+  case GDK_KP_7: return Keyboard::Keycode::Keypad7;
+  case GDK_KP_8: return Keyboard::Keycode::Keypad8;
+  case GDK_KP_9: return Keyboard::Keycode::Keypad9;
+  case GDK_KP_0: return Keyboard::Keycode::Keypad0;
+
+  case GDK_KP_Home: return Keyboard::Keycode::KeypadHome;
+  case GDK_KP_End: return Keyboard::Keycode::KeypadEnd;
+  case GDK_KP_Page_Up: return Keyboard::Keycode::KeypadPageUp;
+  case GDK_KP_Page_Down: return Keyboard::Keycode::KeypadPageDown;
+  case GDK_KP_Up: return Keyboard::Keycode::KeypadUp;
+  case GDK_KP_Down: return Keyboard::Keycode::KeypadDown;
+  case GDK_KP_Left: return Keyboard::Keycode::KeypadLeft;
+  case GDK_KP_Right: return Keyboard::Keycode::KeypadRight;
+  case GDK_KP_Begin: return Keyboard::Keycode::KeypadCenter;
+  case GDK_KP_Insert: return Keyboard::Keycode::KeypadInsert;
+  case GDK_KP_Delete: return Keyboard::Keycode::KeypadDelete;
+  }
+  return Keyboard::Keycode::None;
+}
+
+}
diff -Nru higan/phoenix/gtk/widget/button.cpp nSide/phoenix/gtk/widget/button.cpp
--- higan/phoenix/gtk/widget/button.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/gtk/widget/button.cpp	2015-09-16 13:08:13.561563368 +0900
@@ -0,0 +1,61 @@
+namespace phoenix {
+
+static void Button_activate(Button* self) {
+  if(self->onActivate) self->onActivate();
+}
+
+Size pButton::minimumSize() {
+  Size size = pFont::size(widget.state.font, button.state.text);
+
+  if(button.state.orientation == Orientation::Horizontal) {
+    size.width += button.state.image.width();
+    size.height = max(button.state.image.height(), size.height);
+  }
+
+  if(button.state.orientation == Orientation::Vertical) {
+    size.width = max(button.state.image.width(), size.width);
+    size.height += button.state.image.height();
+  }
+
+  return {size.width + 24, size.height + 12};
+}
+
+void pButton::setBordered(bool bordered) {
+  gtk_button_set_relief(gtkButton, bordered ? GTK_RELIEF_NORMAL : GTK_RELIEF_NONE);
+}
+
+void pButton::setImage(const image& image, Orientation orientation) {
+  if(image.empty() == false) {
+    GtkImage* gtkImage = CreateImage(image);
+    gtk_button_set_image(GTK_BUTTON(gtkWidget), (GtkWidget*)gtkImage);
+  } else {
+    gtk_button_set_image(GTK_BUTTON(gtkWidget), nullptr);
+  }
+  switch(orientation) {
+  case Orientation::Horizontal: gtk_button_set_image_position(GTK_BUTTON(gtkWidget), GTK_POS_LEFT); break;
+  case Orientation::Vertical:   gtk_button_set_image_position(GTK_BUTTON(gtkWidget), GTK_POS_TOP);  break;
+  }
+}
+
+void pButton::setText(string text) {
+  gtk_button_set_label(GTK_BUTTON(gtkWidget), text);
+  setFont(widget.state.font);
+}
+
+void pButton::constructor() {
+  gtkWidget = gtk_button_new();
+  g_signal_connect_swapped(G_OBJECT(gtkWidget), "clicked", G_CALLBACK(Button_activate), (gpointer)&button);
+
+  setText(button.state.text);
+}
+
+void pButton::destructor() {
+  gtk_widget_destroy(gtkWidget);
+}
+
+void pButton::orphan() {
+  destructor();
+  constructor();
+}
+
+}
diff -Nru higan/phoenix/gtk/widget/canvas.cpp nSide/phoenix/gtk/widget/canvas.cpp
--- higan/phoenix/gtk/widget/canvas.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/gtk/widget/canvas.cpp	2015-09-16 13:08:13.561563368 +0900
@@ -0,0 +1,177 @@
+namespace phoenix {
+
+static void Canvas_drop(GtkWidget* widget, GdkDragContext* context, signed x, signed y,
+GtkSelectionData* data, unsigned type, unsigned timestamp, Canvas* canvas) {
+  if(!canvas->state.droppable) return;
+  lstring paths = DropPaths(data);
+  if(paths.empty()) return;
+  if(canvas->onDrop) canvas->onDrop(paths);
+}
+
+static signed Canvas_expose(GtkWidget* widget, GdkEventExpose* event, Canvas* self) {
+  self->p.onExpose(event);
+  return true;
+}
+
+static signed Canvas_mouseLeave(GtkWidget* widget, GdkEventButton* event, Canvas* self) {
+  if(self->onMouseLeave) self->onMouseLeave();
+  return true;
+}
+
+static signed Canvas_mouseMove(GtkWidget* widget, GdkEventButton* event, Canvas* self) {
+  if(self->onMouseMove) self->onMouseMove({(signed)event->x, (signed)event->y});
+  return true;
+}
+
+static signed Canvas_mousePress(GtkWidget* widget, GdkEventButton* event, Canvas* self) {
+  if(self->onMousePress) switch(event->button) {
+  case 1: self->onMousePress(Mouse::Button::Left); break;
+  case 2: self->onMousePress(Mouse::Button::Middle); break;
+  case 3: self->onMousePress(Mouse::Button::Right); break;
+  }
+  return true;
+}
+
+static signed Canvas_mouseRelease(GtkWidget* widget, GdkEventButton* event, Canvas* self) {
+  if(self->onMouseRelease) switch(event->button) {
+  case 1: self->onMouseRelease(Mouse::Button::Left); break;
+  case 2: self->onMouseRelease(Mouse::Button::Middle); break;
+  case 3: self->onMouseRelease(Mouse::Button::Right); break;
+  }
+  return true;
+}
+
+Size pCanvas::minimumSize() {
+  return {canvas.state.width, canvas.state.height};
+}
+
+void pCanvas::setDroppable(bool droppable) {
+  gtk_drag_dest_set(gtkWidget, GTK_DEST_DEFAULT_ALL, nullptr, 0, GDK_ACTION_COPY);
+  if(droppable) gtk_drag_dest_add_uri_targets(gtkWidget);
+}
+
+void pCanvas::setGeometry(Geometry geometry) {
+  if(canvas.state.width == 0 || canvas.state.height == 0) rasterize();
+  unsigned width = canvas.state.width;
+  unsigned height = canvas.state.height;
+  if(width == 0) width = widget.state.geometry.width;
+  if(height == 0) height = widget.state.geometry.height;
+
+  if(width < geometry.width) {
+    geometry.x += (geometry.width - width) / 2;
+    geometry.width = width;
+  }
+
+  if(height < geometry.height) {
+    geometry.y += (geometry.height - height) / 2;
+    geometry.height = height;
+  }
+
+  pWidget::setGeometry(geometry);
+}
+
+void pCanvas::setMode(Canvas::Mode mode) {
+  rasterize(), redraw();
+}
+
+void pCanvas::setSize(Size size) {
+  rasterize(), redraw();
+}
+
+void pCanvas::constructor() {
+  gtkWidget = gtk_drawing_area_new();
+//gtk_widget_set_double_buffered(gtkWidget, false);
+  gtk_widget_add_events(gtkWidget,
+    GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK | GDK_EXPOSURE_MASK | GDK_LEAVE_NOTIFY_MASK | GDK_POINTER_MOTION_MASK);
+  g_signal_connect(G_OBJECT(gtkWidget), "button-press-event", G_CALLBACK(Canvas_mousePress), (gpointer)&canvas);
+  g_signal_connect(G_OBJECT(gtkWidget), "button-release-event", G_CALLBACK(Canvas_mouseRelease), (gpointer)&canvas);
+  g_signal_connect(G_OBJECT(gtkWidget), "drag-data-received", G_CALLBACK(Canvas_drop), (gpointer)&canvas);
+  g_signal_connect(G_OBJECT(gtkWidget), "expose-event", G_CALLBACK(Canvas_expose), (gpointer)&canvas);
+  g_signal_connect(G_OBJECT(gtkWidget), "leave-notify-event", G_CALLBACK(Canvas_mouseLeave), (gpointer)&canvas);
+  g_signal_connect(G_OBJECT(gtkWidget), "motion-notify-event", G_CALLBACK(Canvas_mouseMove), (gpointer)&canvas);
+
+  setDroppable(canvas.state.droppable);
+  rasterize(), redraw();
+}
+
+void pCanvas::destructor() {
+  release();
+  gtk_widget_destroy(gtkWidget);
+}
+
+void pCanvas::orphan() {
+  destructor();
+  constructor();
+}
+
+void pCanvas::onExpose(GdkEventExpose* expose) {
+  if(surface) gdk_draw_pixbuf(gtk_widget_get_window(gtkWidget), nullptr, surface, 0, 0, 0, 0, -1, -1, GDK_RGB_DITHER_NONE, 0, 0);
+}
+
+void pCanvas::rasterize() {
+  unsigned width = canvas.state.width;
+  unsigned height = canvas.state.height;
+  if(width == 0) width = widget.state.geometry.width;
+  if(height == 0) height = widget.state.geometry.height;
+
+  if(width != surfaceWidth || height != surfaceHeight) release();
+  surfaceWidth = width;
+  surfaceHeight = height;
+
+  if(width == 0 || height == 0) return;
+
+  if(!surface) surface = gdk_pixbuf_new(GDK_COLORSPACE_RGB, true, 8, width, height);
+  uint32_t* buffer = (uint32_t*)gdk_pixbuf_get_pixels(surface);
+
+  if(canvas.state.mode == Canvas::Mode::Color) {
+    uint32_t color = canvas.state.color.argb();
+    for(unsigned n = 0; n < width * height; n++) buffer[n] = color;
+  }
+
+  if(canvas.state.mode == Canvas::Mode::Gradient) {
+    nall::image image;
+    image.allocate(width, height);
+    image.gradient(
+      canvas.state.gradient[0].argb(), canvas.state.gradient[1].argb(), canvas.state.gradient[2].argb(), canvas.state.gradient[3].argb()
+    );
+    memcpy(buffer, image.data(), image.size());
+  }
+
+  if(canvas.state.mode == Canvas::Mode::Image) {
+    nall::image image = canvas.state.image;
+    image.scale(width, height);
+    image.transform(0, 32, 255u << 24, 255u << 16, 255u << 8, 255u << 0);
+    memcpy(buffer, image.data(), image.size());
+  }
+
+  if(canvas.state.mode == Canvas::Mode::Data) {
+    if(width == canvas.state.width && height == canvas.state.height) {
+      memcpy(buffer, canvas.state.data, width * height * sizeof(uint32_t));
+    } else {
+      memset(buffer, 0x00, width * height * sizeof(uint32_t));
+    }
+  }
+
+  //ARGB -> ABGR conversion
+  for(unsigned n = 0; n < width * height; n++) {
+    uint32_t color = *buffer;
+    color = (color & 0xff00ff00) | ((color & 0xff0000) >> 16) | ((color & 0x0000ff) << 16);
+    *buffer++ = color;
+  }
+}
+
+void pCanvas::redraw() {
+  if(gtk_widget_get_realized(gtkWidget)) {
+    gdk_window_invalidate_rect(gtk_widget_get_window(gtkWidget), nullptr, true);
+  }
+}
+
+void pCanvas::release() {
+  if(surface == nullptr) return;
+  g_object_unref(surface);
+  surface = nullptr;
+  surfaceWidth = 0;
+  surfaceHeight = 0;
+}
+
+}
diff -Nru higan/phoenix/gtk/widget/check-button.cpp nSide/phoenix/gtk/widget/check-button.cpp
--- higan/phoenix/gtk/widget/check-button.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/gtk/widget/check-button.cpp	2015-09-16 13:08:13.562563369 +0900
@@ -0,0 +1,70 @@
+namespace phoenix {
+
+static void CheckButton_toggle(GtkToggleButton* toggleButton, CheckButton* self) {
+  self->p.onToggle();
+}
+
+Size pCheckButton::minimumSize() {
+  Size size = pFont::size(widget.state.font, checkButton.state.text);
+
+  if(checkButton.state.orientation == Orientation::Horizontal) {
+    size.width += checkButton.state.image.width();
+    size.height = max(checkButton.state.image.height(), size.height);
+  }
+
+  if(checkButton.state.orientation == Orientation::Vertical) {
+    size.width = max(checkButton.state.image.width(), size.width);
+    size.height += checkButton.state.image.height();
+  }
+
+  return {size.width + 24, size.height + 12};
+}
+
+void pCheckButton::setChecked(bool checked) {
+  locked = true;
+  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(gtkWidget), checked);
+  locked = false;
+}
+
+void pCheckButton::setImage(const image& image, Orientation orientation) {
+  if(image.empty() == false) {
+    GtkImage* gtkImage = CreateImage(image);
+    gtk_button_set_image(GTK_BUTTON(gtkWidget), (GtkWidget*)gtkImage);
+  } else {
+    gtk_button_set_image(GTK_BUTTON(gtkWidget), nullptr);
+  }
+  switch(orientation) {
+  case Orientation::Horizontal: gtk_button_set_image_position(GTK_BUTTON(gtkWidget), GTK_POS_LEFT); break;
+  case Orientation::Vertical:   gtk_button_set_image_position(GTK_BUTTON(gtkWidget), GTK_POS_TOP);  break;
+  }
+}
+
+void pCheckButton::setText(string text) {
+  gtk_button_set_label(GTK_BUTTON(gtkWidget), text);
+  setFont(widget.state.font);
+}
+
+void pCheckButton::constructor() {
+  gtkWidget = gtk_toggle_button_new();
+  g_signal_connect(G_OBJECT(gtkWidget), "toggled", G_CALLBACK(CheckButton_toggle), (gpointer)&checkButton);
+
+  setChecked(checkButton.state.checked);
+  setText(checkButton.state.text);
+}
+
+void pCheckButton::destructor() {
+  gtk_widget_destroy(gtkWidget);
+}
+
+void pCheckButton::orphan() {
+  destructor();
+  constructor();
+}
+
+void pCheckButton::onToggle() {
+  if(locked) return;
+  checkButton.state.checked = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(gtkWidget));
+  if(checkButton.onToggle) checkButton.onToggle();
+}
+
+}
diff -Nru higan/phoenix/gtk/widget/check-label.cpp nSide/phoenix/gtk/widget/check-label.cpp
--- higan/phoenix/gtk/widget/check-label.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/gtk/widget/check-label.cpp	2015-09-16 13:08:13.561563368 +0900
@@ -0,0 +1,40 @@
+namespace phoenix {
+
+static void CheckLabel_toggle(GtkToggleButton* toggleButton, CheckLabel* self) {
+  self->state.checked = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(self->p.gtkWidget));
+  if(!self->p.locked && self->onToggle) self->onToggle();
+}
+
+Size pCheckLabel::minimumSize() {
+  Size size = pFont::size(widget.state.font, checkLabel.state.text);
+  return {size.width + 28, size.height + 4};
+}
+
+void pCheckLabel::setChecked(bool checked) {
+  locked = true;
+  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(gtkWidget), checked);
+  locked = false;
+}
+
+void pCheckLabel::setText(string text) {
+  gtk_button_set_label(GTK_BUTTON(gtkWidget), text);
+}
+
+void pCheckLabel::constructor() {
+  gtkWidget = gtk_check_button_new_with_label("");
+  g_signal_connect(G_OBJECT(gtkWidget), "toggled", G_CALLBACK(CheckLabel_toggle), (gpointer)&checkLabel);
+
+  setChecked(checkLabel.state.checked);
+  setText(checkLabel.state.text);
+}
+
+void pCheckLabel::destructor() {
+  gtk_widget_destroy(gtkWidget);
+}
+
+void pCheckLabel::orphan() {
+  destructor();
+  constructor();
+}
+
+}
diff -Nru higan/phoenix/gtk/widget/combo-button.cpp nSide/phoenix/gtk/widget/combo-button.cpp
--- higan/phoenix/gtk/widget/combo-button.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/gtk/widget/combo-button.cpp	2015-09-16 13:08:13.562563369 +0900
@@ -0,0 +1,74 @@
+namespace phoenix {
+
+static void ComboButton_change(ComboButton* self) {
+  if(!self->p.locked) {
+    self->state.selection = gtk_combo_box_get_active(GTK_COMBO_BOX(self->p.gtkWidget));
+    if(self->onChange) self->onChange();
+  }
+}
+
+void pComboButton::append(string text) {
+  gtk_combo_box_append_text(GTK_COMBO_BOX(gtkWidget), text);
+  if(itemCounter++ == 0) comboButton.setSelection(0);
+}
+
+Size pComboButton::minimumSize() {
+  unsigned maximumWidth = 0;
+  for(auto& item : comboButton.state.text) maximumWidth = max(maximumWidth, pFont::size(widget.state.font, item).width);
+
+  Size size = pFont::size(widget.state.font, " ");
+  return {maximumWidth + 44, size.height + 12};
+}
+
+void pComboButton::remove(unsigned selection) {
+  locked = true;
+  gtk_combo_box_remove_text(GTK_COMBO_BOX(gtkWidget), selection);
+  itemCounter--;
+  locked = false;
+
+  //when removing the actively selected item, reset the selection to the first entry
+  if(selection == comboButton.state.selection) comboButton.setSelection(0);
+}
+
+void pComboButton::reset() {
+  locked = true;
+  gtk_list_store_clear(GTK_LIST_STORE(gtk_combo_box_get_model(GTK_COMBO_BOX(gtkWidget))));
+  itemCounter = 0;
+  locked = false;
+}
+
+void pComboButton::setSelection(unsigned selection) {
+  locked = true;
+  gtk_combo_box_set_active(GTK_COMBO_BOX(gtkWidget), selection);
+  locked = false;
+}
+
+void pComboButton::setText(unsigned selection, string text) {
+  locked = true;
+  gtk_combo_box_remove_text(GTK_COMBO_BOX(gtkWidget), selection);
+  gtk_combo_box_insert_text(GTK_COMBO_BOX(gtkWidget), selection, text);
+  gtk_combo_box_set_active(GTK_COMBO_BOX(gtkWidget), comboButton.state.selection);
+  locked = false;
+}
+
+void pComboButton::constructor() {
+  itemCounter = 0;
+  gtkWidget = gtk_combo_box_new_text();
+  g_signal_connect_swapped(G_OBJECT(gtkWidget), "changed", G_CALLBACK(ComboButton_change), (gpointer)&comboButton);
+
+  locked = true;
+  for(auto& text : comboButton.state.text) append(text);
+  locked = false;
+  setSelection(comboButton.state.selection);
+}
+
+void pComboButton::destructor() {
+  gtk_widget_destroy(gtkWidget);
+}
+
+void pComboButton::orphan() {
+  destructor();
+  constructor();
+}
+
+}
diff -Nru higan/phoenix/gtk/widget/console.cpp nSide/phoenix/gtk/widget/console.cpp
--- higan/phoenix/gtk/widget/console.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/gtk/widget/console.cpp	2015-09-16 13:08:13.562563369 +0900
@@ -0,0 +1,186 @@
+namespace phoenix {
+
+static bool Console_keyPress(GtkWidget* widget, GdkEventKey* event, Console* self) {
+  return self->p.keyPress(event->keyval, event->state);
+}
+
+void pConsole::print(string text) {
+  //insert text before prompt and command
+  GtkTextIter iter;
+  gtk_text_buffer_get_iter_at_line_offset(textBuffer, &iter, gtk_text_buffer_get_line_count(textBuffer), 0);
+  gtk_text_buffer_insert(textBuffer, &iter, text, -1);
+  seekToEnd();
+}
+
+void pConsole::reset() {
+  //flush history and redraw prompt
+  gtk_text_buffer_set_text(textBuffer, console.prompt(), -1);
+  seekToEnd();
+}
+
+void pConsole::setBackgroundColor(Color color) {
+  GdkColor gdkColor = CreateColor(color.red, color.green, color.blue);
+  gtk_widget_modify_base(subWidget, GTK_STATE_NORMAL, &gdkColor);
+}
+
+void pConsole::setForegroundColor(Color color) {
+  GdkColor gdkColor = CreateColor(color.red, color.green, color.blue);
+  gtk_widget_modify_text(subWidget, GTK_STATE_NORMAL, &gdkColor);
+}
+
+void pConsole::setPrompt(string prompt) {
+  //erase previous prompt and replace it with new prompt
+  GtkTextIter lhs, rhs;
+  gtk_text_buffer_get_iter_at_line_offset(textBuffer, &lhs, gtk_text_buffer_get_line_count(textBuffer), 0);
+  gtk_text_buffer_get_iter_at_line_offset(textBuffer, &rhs, gtk_text_buffer_get_line_count(textBuffer), previousPrompt.size());
+  gtk_text_buffer_delete(textBuffer, &lhs, &rhs);
+  gtk_text_buffer_get_iter_at_line_offset(textBuffer, &lhs, gtk_text_buffer_get_line_count(textBuffer), 0);
+  gtk_text_buffer_insert(textBuffer, &lhs, previousPrompt = prompt, -1);
+  seekToEnd();
+}
+
+void pConsole::constructor() {
+  gtkWidget = gtk_scrolled_window_new(0, 0);
+  gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(gtkWidget), GTK_POLICY_AUTOMATIC, GTK_POLICY_ALWAYS);
+  gtk_scrolled_window_set_shadow_type(GTK_SCROLLED_WINDOW(gtkWidget), GTK_SHADOW_ETCHED_IN);
+
+  subWidget = gtk_text_view_new();
+  gtk_text_view_set_editable(GTK_TEXT_VIEW(subWidget), false);
+  gtk_text_view_set_wrap_mode(GTK_TEXT_VIEW(subWidget), GTK_WRAP_NONE);
+  gtk_container_add(GTK_CONTAINER(gtkWidget), subWidget);
+
+  textBuffer = gtk_text_view_get_buffer(GTK_TEXT_VIEW(subWidget));
+
+  g_signal_connect(G_OBJECT(subWidget), "key-press-event", G_CALLBACK(Console_keyPress), (gpointer)&console);
+
+  gtk_widget_show(subWidget);
+}
+
+void pConsole::destructor() {
+  gtk_widget_destroy(subWidget);
+  gtk_widget_destroy(gtkWidget);
+}
+
+void pConsole::orphan() {
+  destructor();
+  constructor();
+}
+
+bool pConsole::keyPress(unsigned scancode, unsigned mask) {
+  if(mask & (GDK_CONTROL_MASK | GDK_MOD1_MASK | GDK_SUPER_MASK)) return false;  //allow actions such as Ctrl+C (copy)
+
+  GtkTextMark* mark = gtk_text_buffer_get_mark(textBuffer, "insert");
+  GtkTextIter start, cursor, end;
+  gtk_text_buffer_get_iter_at_line_offset(textBuffer, &start, gtk_text_buffer_get_line_count(textBuffer), console.prompt().size());
+  gtk_text_buffer_get_iter_at_mark(textBuffer, &cursor, mark);
+  gtk_text_buffer_get_end_iter(textBuffer, &end);
+
+  if(scancode == GDK_KEY_Return || scancode == GDK_KEY_KP_Enter) {
+    char* temp = gtk_text_buffer_get_text(textBuffer, &start, &end, true);
+    string s = temp;
+    g_free(temp);
+    gtk_text_buffer_insert(textBuffer, &end, string{"\n", console.prompt()}, -1);
+    if(console.onActivate) console.onActivate(s);
+    if(s) history.prepend(s);
+    if(history.size() > 128) history.removeLast();
+    historyOffset = 0;
+    seekToEnd();
+    return true;
+  }
+
+  if(scancode == GDK_KEY_Up) {
+    gtk_text_buffer_delete(textBuffer, &start, &end);
+    gtk_text_buffer_get_end_iter(textBuffer, &end);
+    if(historyOffset < history.size()) {
+      gtk_text_buffer_insert(textBuffer, &end, history[historyOffset++], -1);
+    }
+    seekToEnd();
+    return true;
+  }
+
+  if(scancode == GDK_KEY_Down) {
+    gtk_text_buffer_delete(textBuffer, &start, &end);
+    gtk_text_buffer_get_end_iter(textBuffer, &end);
+    if(historyOffset > 0) {
+      gtk_text_buffer_insert(textBuffer, &end, history[--historyOffset], -1);
+    }
+    seekToEnd();
+    return true;
+  }
+
+  if(scancode == GDK_KEY_Left) {
+    if(gtk_text_iter_get_offset(&cursor) <= gtk_text_iter_get_offset(&start)) {
+      gtk_text_buffer_place_cursor(textBuffer, &start);
+    } else {
+      gtk_text_iter_set_offset(&cursor, gtk_text_iter_get_offset(&cursor) - 1);
+      gtk_text_buffer_place_cursor(textBuffer, &cursor);
+    }
+    seekToMark();
+    return true;
+  }
+
+  if(scancode == GDK_KEY_Right) {
+    if(gtk_text_iter_get_offset(&cursor) < gtk_text_iter_get_offset(&start)) {
+      gtk_text_buffer_place_cursor(textBuffer, &end);
+    } else if(gtk_text_iter_get_offset(&cursor) < gtk_text_iter_get_offset(&end)) {
+      gtk_text_iter_set_offset(&cursor, gtk_text_iter_get_offset(&cursor) + 1);
+      gtk_text_buffer_place_cursor(textBuffer, &cursor);
+    }
+    seekToMark();
+    return true;
+  }
+
+  if(scancode == GDK_KEY_Home) {
+    gtk_text_buffer_place_cursor(textBuffer, &start);
+    seekToMark();
+    return true;
+  }
+
+  if(scancode == GDK_KEY_End) {
+    gtk_text_buffer_place_cursor(textBuffer, &end);
+    seekToMark();
+    return true;
+  }
+
+  if(scancode == GDK_KEY_BackSpace) {
+    if(gtk_text_iter_get_offset(&cursor) <= gtk_text_iter_get_offset(&start)) return true;
+    GtkTextIter lhs = cursor;
+    gtk_text_iter_set_offset(&lhs, gtk_text_iter_get_offset(&cursor) - 1);
+    gtk_text_buffer_delete(textBuffer, &lhs, &cursor);
+    seekToMark();
+    return true;
+  }
+
+  if(scancode == GDK_KEY_Delete) {
+    if(gtk_text_iter_get_offset(&cursor) < gtk_text_iter_get_offset(&start)) return true;
+    if(gtk_text_iter_get_offset(&cursor) == gtk_text_iter_get_offset(&end)) return true;
+    GtkTextIter rhs = cursor;
+    gtk_text_iter_set_offset(&rhs, gtk_text_iter_get_offset(&cursor) + 1);
+    gtk_text_buffer_delete(textBuffer, &cursor, &rhs);
+    seekToMark();
+    return true;
+  }
+
+  if(scancode >= 0x20 && scancode <= 0x7e) {
+    if(gtk_text_iter_get_offset(&cursor) < gtk_text_iter_get_offset(&start)) return true;
+    gtk_text_buffer_insert(textBuffer, &cursor, string{(char)scancode}, -1);
+    seekToMark();
+    return true;
+  }
+
+  return false;
+}
+
+void pConsole::seekToEnd() {
+  GtkTextIter iter;
+  gtk_text_buffer_get_end_iter(textBuffer, &iter);
+  gtk_text_buffer_place_cursor(textBuffer, &iter);
+  seekToMark();
+}
+
+void pConsole::seekToMark() {
+  GtkTextMark* mark = gtk_text_buffer_get_mark(textBuffer, "insert");
+  gtk_text_view_scroll_mark_onscreen(GTK_TEXT_VIEW(subWidget), mark);
+}
+
+}
diff -Nru higan/phoenix/gtk/widget/frame.cpp nSide/phoenix/gtk/widget/frame.cpp
--- higan/phoenix/gtk/widget/frame.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/gtk/widget/frame.cpp	2015-09-16 13:08:13.562563369 +0900
@@ -0,0 +1,48 @@
+namespace phoenix {
+
+GtkWidget* pFrame::container(Widget& widget) {
+  return gtk_widget_get_parent(gtkWidget);
+}
+
+Position pFrame::containerOffset() {
+  return {0, 0};
+}
+
+void pFrame::setEnabled(bool enabled) {
+  if(frame.state.layout) frame.state.layout->setEnabled(frame.state.layout->enabled());
+  pWidget::setEnabled(enabled);
+}
+
+void pFrame::setGeometry(Geometry geometry) {
+  pWidget::setGeometry(geometry);
+  if(frame.state.layout == nullptr) return;
+  Size size = pFont::size(widget.state.font, frame.state.text);
+  if(frame.state.text.empty()) size.height = 8;
+  geometry.x += 2, geometry.width -= 5;
+  geometry.y += size.height - 1, geometry.height -= size.height + 2;
+  frame.state.layout->setGeometry(geometry);
+}
+
+void pFrame::setText(string text) {
+  gtk_frame_set_label(GTK_FRAME(gtkWidget), text);
+}
+
+void pFrame::setVisible(bool visible) {
+  if(frame.state.layout) frame.state.layout->setVisible(frame.state.layout->visible());
+  pWidget::setVisible(visible);
+}
+
+void pFrame::constructor() {
+  gtkWidget = gtk_frame_new("");
+}
+
+void pFrame::destructor() {
+  gtk_widget_destroy(gtkWidget);
+}
+
+void pFrame::orphan() {
+  destructor();
+  constructor();
+}
+
+}
diff -Nru higan/phoenix/gtk/widget/hex-edit.cpp nSide/phoenix/gtk/widget/hex-edit.cpp
--- higan/phoenix/gtk/widget/hex-edit.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/gtk/widget/hex-edit.cpp	2015-09-16 13:08:13.565563369 +0900
@@ -0,0 +1,308 @@
+namespace phoenix {
+
+static bool HexEdit_keyPress(GtkWidget* widget, GdkEventKey* event, HexEdit* self) {
+  return self->p.keyPress(event->keyval, event->state);
+}
+
+static bool HexEdit_mouseScroll(GtkWidget* widget, GdkEventScroll* event, HexEdit* self) {
+  double position = gtk_range_get_value(GTK_RANGE(self->p.scrollBar));
+
+  if(event->direction == GDK_SCROLL_UP) {
+    self->p.scroll(position - 1);
+  }
+
+  if(event->direction == GDK_SCROLL_DOWN) {
+    self->p.scroll(position + 1);
+  }
+
+  return true;  //do not propagate event further
+}
+
+static bool HexEdit_scroll(GtkRange* range, GtkScrollType scroll, double value, HexEdit* self) {
+  self->p.scroll((signed)value);
+  return true;  //do not propagate event further
+}
+
+bool pHexEdit::focused() {
+  return GTK_WIDGET_HAS_FOCUS(subWidget) || GTK_WIDGET_HAS_FOCUS(scrollBar);
+}
+
+void pHexEdit::setBackgroundColor(Color color) {
+  GdkColor gdkColor = CreateColor(color.red, color.green, color.blue);
+  gtk_widget_modify_base(subWidget, GTK_STATE_NORMAL, &gdkColor);
+}
+
+void pHexEdit::setColumns(unsigned columns) {
+  setScroll();
+  update();
+}
+
+void pHexEdit::setForegroundColor(Color color) {
+  GdkColor gdkColor = CreateColor(color.red, color.green, color.blue);
+  gtk_widget_modify_text(subWidget, GTK_STATE_NORMAL, &gdkColor);
+}
+
+void pHexEdit::setLength(unsigned length) {
+  setScroll();
+  update();
+}
+
+void pHexEdit::setOffset(unsigned offset) {
+  setScroll();
+  updateScroll();
+  update();
+}
+
+void pHexEdit::setRows(unsigned rows) {
+  setScroll();
+  update();
+}
+
+void pHexEdit::update() {
+  if(!hexEdit.onRead) {
+    gtk_text_buffer_set_text(textBuffer, "", -1);
+    return;
+  }
+
+  unsigned position = cursorPosition();
+
+  string output;
+  unsigned offset = hexEdit.state.offset;
+  for(unsigned row = 0; row < hexEdit.state.rows; row++) {
+    output.append(hex(offset, 8L));
+    output.append("  ");
+
+    string hexdata;
+    string ansidata = " ";
+    for(unsigned column = 0; column < hexEdit.state.columns; column++) {
+      if(offset < hexEdit.state.length) {
+        uint8_t data = hexEdit.onRead(offset++);
+        hexdata.append(hex(data, 2L));
+        hexdata.append(" ");
+        ansidata.append(data >= 0x20 && data <= 0x7e ? (char)data : '.');
+      } else {
+        hexdata.append("   ");
+        ansidata.append(" ");
+      }
+    }
+
+    output.append(hexdata);
+    output.append(ansidata);
+    if(offset >= hexEdit.state.length) break;
+    if(row != hexEdit.state.rows - 1) output.append("\n");
+  }
+
+  gtk_text_buffer_set_text(textBuffer, output, -1);
+  if(position == 0) position = 10;  //start at first position where hex values can be entered
+  setCursorPosition(position);
+}
+
+void pHexEdit::constructor() {
+  gtkWidget = gtk_hbox_new(false, 0);
+
+  container = gtk_scrolled_window_new(0, 0);
+  gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(container), GTK_POLICY_AUTOMATIC, GTK_POLICY_NEVER);
+  gtk_scrolled_window_set_shadow_type(GTK_SCROLLED_WINDOW(container), GTK_SHADOW_ETCHED_IN);
+
+  subWidget = gtk_text_view_new();
+  gtk_text_view_set_editable(GTK_TEXT_VIEW(subWidget), false);
+  gtk_text_view_set_wrap_mode(GTK_TEXT_VIEW(subWidget), GTK_WRAP_NONE);
+  gtk_container_add(GTK_CONTAINER(container), subWidget);
+  g_signal_connect(G_OBJECT(subWidget), "key-press-event", G_CALLBACK(HexEdit_keyPress), (gpointer)&hexEdit);
+  g_signal_connect(G_OBJECT(subWidget), "scroll-event", G_CALLBACK(HexEdit_mouseScroll), (gpointer)&hexEdit);
+
+  scrollBar = gtk_vscrollbar_new((GtkAdjustment*)nullptr);
+  gtk_range_set_range(GTK_RANGE(scrollBar), 0, 255);
+  gtk_range_set_increments(GTK_RANGE(scrollBar), 1, 16);
+  gtk_widget_set_sensitive(scrollBar, false);
+  g_signal_connect(G_OBJECT(scrollBar), "change-value", G_CALLBACK(HexEdit_scroll), (gpointer)&hexEdit);
+  g_signal_connect(G_OBJECT(scrollBar), "scroll-event", G_CALLBACK(HexEdit_mouseScroll), (gpointer)&hexEdit);
+
+  gtk_box_pack_start(GTK_BOX(gtkWidget), container, true, true, 0);
+  gtk_box_pack_start(GTK_BOX(gtkWidget), scrollBar, false, false, 1);
+
+  textBuffer = gtk_text_view_get_buffer(GTK_TEXT_VIEW(subWidget));
+  textCursor = gtk_text_buffer_get_mark(textBuffer, "insert");
+
+  gtk_widget_show(scrollBar);
+  gtk_widget_show(subWidget);
+  gtk_widget_show(container);
+
+  setColumns(hexEdit.state.columns);
+  setRows(hexEdit.state.rows);
+  setLength(hexEdit.state.length);
+  setOffset(hexEdit.state.offset);
+  update();
+}
+
+void pHexEdit::destructor() {
+  gtk_widget_destroy(scrollBar);
+  gtk_widget_destroy(subWidget);
+  gtk_widget_destroy(container);
+  gtk_widget_destroy(gtkWidget);
+}
+
+void pHexEdit::orphan() {
+  destructor();
+  constructor();
+}
+
+unsigned pHexEdit::cursorPosition() {
+  GtkTextIter iter;
+  gtk_text_buffer_get_iter_at_mark(textBuffer, &iter, textCursor);
+  return gtk_text_iter_get_offset(&iter);
+}
+
+bool pHexEdit::keyPress(unsigned scancode, unsigned mask) {
+  if(!hexEdit.onRead) return false;
+
+  if(mask & (GDK_CONTROL_MASK | GDK_MOD1_MASK | GDK_SUPER_MASK)) return false;  //allow actions such as Ctrl+C (copy)
+
+  signed position = cursorPosition();
+  signed lineWidth = 10 + (hexEdit.state.columns * 3) + 1 + hexEdit.state.columns + 1;
+  signed cursorY = position / lineWidth;
+  signed cursorX = position % lineWidth;
+
+  if(scancode == GDK_Home) {
+    setCursorPosition(cursorY * lineWidth + 10);
+    return true;
+  }
+
+  if(scancode == GDK_End) {
+    setCursorPosition(cursorY * lineWidth + 10 + (hexEdit.state.columns * 3 - 1));
+    return true;
+  }
+
+  if(scancode == GDK_Up) {
+    if(cursorY != 0) return false;
+
+    signed newOffset = hexEdit.state.offset - hexEdit.state.columns;
+    if(newOffset >= 0) {
+      hexEdit.setOffset(newOffset);
+      update();
+    }
+    return true;
+  }
+
+  if(scancode == GDK_Down) {
+    if(cursorY >= rows() - 1) return true;
+    if(cursorY != hexEdit.state.rows - 1) return false;
+
+    signed newOffset = hexEdit.state.offset + hexEdit.state.columns;
+    if(newOffset + hexEdit.state.columns * hexEdit.state.rows - (hexEdit.state.columns - 1) <= hexEdit.state.length) {
+      hexEdit.setOffset(newOffset);
+      update();
+    }
+    return true;
+  }
+
+  if(scancode == GDK_Page_Up) {
+    signed newOffset = hexEdit.state.offset - hexEdit.state.columns * hexEdit.state.rows;
+    if(newOffset >= 0) {
+      hexEdit.setOffset(newOffset);
+    } else {
+      hexEdit.setOffset(0);
+    }
+    update();
+    return true;
+  }
+
+  if(scancode == GDK_Page_Down) {
+    signed newOffset = hexEdit.state.offset + hexEdit.state.columns * hexEdit.state.rows;
+    for(unsigned n = 0; n < hexEdit.state.rows; n++) {
+      if(newOffset + hexEdit.state.columns * hexEdit.state.rows - (hexEdit.state.columns - 1) <= hexEdit.state.length) {
+        hexEdit.setOffset(newOffset);
+        update();
+        break;
+      }
+      newOffset -= hexEdit.state.columns;
+    }
+    return true;
+  }
+
+  //convert scancode to hex nibble
+       if(scancode >= '0' && scancode <= '9') scancode = scancode - '0';
+  else if(scancode >= 'A' && scancode <= 'F') scancode = scancode - 'A' + 10;
+  else if(scancode >= 'a' && scancode <= 'f') scancode = scancode - 'a' + 10;
+  else return false;  //not a valid hex value
+
+  if(cursorX >= 10) {
+    //not on an offset
+    cursorX -= 10;
+    if((cursorX % 3) != 2) {
+      //not on a space
+      bool cursorNibble = (cursorX % 3) == 1;  //0 = high, 1 = low
+      cursorX /= 3;
+      if(cursorX < hexEdit.state.columns) {
+        //not in ANSI region
+        unsigned offset = hexEdit.state.offset + (cursorY * hexEdit.state.columns + cursorX);
+
+        if(offset >= hexEdit.state.length) return false;  //do not edit past end of data
+        uint8_t data = hexEdit.onRead(offset);
+
+        //write modified value
+        if(cursorNibble == 1) {
+          data = (data & 0xf0) | (scancode << 0);
+        } else {
+          data = (data & 0x0f) | (scancode << 4);
+        }
+        if(hexEdit.onWrite) hexEdit.onWrite(offset, data);
+
+        //auto-advance cursor to next nibble/byte
+        position++;
+        if(cursorNibble && cursorX != hexEdit.state.columns - 1) position++;
+        setCursorPosition(position);
+
+        //refresh output to reflect modified data
+        update();
+      }
+    }
+  }
+
+  return true;
+}
+
+//number of actual rows
+signed pHexEdit::rows() {
+  return (max(1u, hexEdit.state.length) + hexEdit.state.columns - 1) / hexEdit.state.columns;
+}
+
+//number of scrollable row positions
+signed pHexEdit::rowsScrollable() {
+  return max(0u, rows() - hexEdit.state.rows);
+}
+
+void pHexEdit::scroll(signed position) {
+  if(position > rowsScrollable()) position = rowsScrollable();
+  if(position < 0) position = 0;
+  hexEdit.setOffset(position * hexEdit.state.columns);
+}
+
+void pHexEdit::setCursorPosition(unsigned position) {
+  GtkTextIter iter;
+  gtk_text_buffer_get_iter_at_mark(textBuffer, &iter, textCursor);
+
+  //GTK+ will throw many errors to the terminal if you set iterator past end of buffer
+  GtkTextIter endIter;
+  gtk_text_buffer_get_end_iter(textBuffer, &iter);
+  unsigned endPosition = gtk_text_iter_get_offset(&iter);
+
+  gtk_text_iter_set_offset(&iter, min(position, endPosition));
+  gtk_text_buffer_place_cursor(textBuffer, &iter);
+}
+
+void pHexEdit::setScroll() {
+  if(rowsScrollable() > 0) {
+    gtk_range_set_range(GTK_RANGE(scrollBar), 0, rowsScrollable());
+    gtk_widget_set_sensitive(scrollBar, true);
+  } else {
+    gtk_widget_set_sensitive(scrollBar, false);
+  }
+}
+
+void pHexEdit::updateScroll() {
+  unsigned row = hexEdit.state.offset / hexEdit.state.columns;
+  gtk_range_set_value(GTK_RANGE(scrollBar), row);
+}
+
+}
diff -Nru higan/phoenix/gtk/widget/horizontal-scroller.cpp nSide/phoenix/gtk/widget/horizontal-scroller.cpp
--- higan/phoenix/gtk/widget/horizontal-scroller.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/gtk/widget/horizontal-scroller.cpp	2015-09-16 13:08:13.564563369 +0900
@@ -0,0 +1,43 @@
+namespace phoenix {
+
+static void HorizontalScroller_change(GtkRange* gtkRange, HorizontalScroller* self) {
+  unsigned position = (unsigned)gtk_range_get_value(gtkRange);
+  if(self->state.position == position) return;
+  self->state.position = position;
+  if(!self->p.locked && self->onChange) self->onChange();
+}
+
+Size pHorizontalScroller::minimumSize() {
+  return {0, 20};
+}
+
+void pHorizontalScroller::setLength(unsigned length) {
+  locked = true;
+  length += length == 0;
+  gtk_range_set_range(GTK_RANGE(gtkWidget), 0, max(1u, length - 1));
+  gtk_range_set_increments(GTK_RANGE(gtkWidget), 1, length >> 3);
+  locked = false;
+}
+
+void pHorizontalScroller::setPosition(unsigned position) {
+  gtk_range_set_value(GTK_RANGE(gtkWidget), position);
+}
+
+void pHorizontalScroller::constructor() {
+  gtkWidget = gtk_hscrollbar_new(0);
+  g_signal_connect(G_OBJECT(gtkWidget), "value-changed", G_CALLBACK(HorizontalScroller_change), (gpointer)&horizontalScroller);
+
+  setLength(horizontalScroller.state.length);
+  setPosition(horizontalScroller.state.position);
+}
+
+void pHorizontalScroller::destructor() {
+  gtk_widget_destroy(gtkWidget);
+}
+
+void pHorizontalScroller::orphan() {
+  destructor();
+  constructor();
+}
+
+}
diff -Nru higan/phoenix/gtk/widget/horizontal-slider.cpp nSide/phoenix/gtk/widget/horizontal-slider.cpp
--- higan/phoenix/gtk/widget/horizontal-slider.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/gtk/widget/horizontal-slider.cpp	2015-09-16 13:08:13.561563368 +0900
@@ -0,0 +1,42 @@
+namespace phoenix {
+
+static void HorizontalSlider_change(GtkRange* gtkRange, HorizontalSlider* self) {
+  unsigned position = (unsigned)gtk_range_get_value(gtkRange);
+  if(self->state.position == position) return;
+  self->state.position = position;
+  if(self->onChange) self->onChange();
+}
+
+Size pHorizontalSlider::minimumSize() {
+  return {0, 20};
+}
+
+void pHorizontalSlider::setLength(unsigned length) {
+  length += length == 0;
+  gtk_range_set_range(GTK_RANGE(gtkWidget), 0, max(1u, length - 1));
+  gtk_range_set_increments(GTK_RANGE(gtkWidget), 1, length >> 3);
+}
+
+void pHorizontalSlider::setPosition(unsigned position) {
+  gtk_range_set_value(GTK_RANGE(gtkWidget), position);
+}
+
+void pHorizontalSlider::constructor() {
+  gtkWidget = gtk_hscale_new_with_range(0, 100, 1);
+  gtk_scale_set_draw_value(GTK_SCALE(gtkWidget), false);
+  g_signal_connect(G_OBJECT(gtkWidget), "value-changed", G_CALLBACK(HorizontalSlider_change), (gpointer)&horizontalSlider);
+
+  setLength(horizontalSlider.state.length);
+  setPosition(horizontalSlider.state.position);
+}
+
+void pHorizontalSlider::destructor() {
+  gtk_widget_destroy(gtkWidget);
+}
+
+void pHorizontalSlider::orphan() {
+  destructor();
+  constructor();
+}
+
+}
diff -Nru higan/phoenix/gtk/widget/label.cpp nSide/phoenix/gtk/widget/label.cpp
--- higan/phoenix/gtk/widget/label.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/gtk/widget/label.cpp	2015-09-16 13:08:13.563563369 +0900
@@ -0,0 +1,28 @@
+namespace phoenix {
+
+Size pLabel::minimumSize() {
+  Size size = pFont::size(widget.state.font, label.state.text);
+  return {size.width, size.height};
+}
+
+void pLabel::setText(string text) {
+  gtk_label_set_text(GTK_LABEL(gtkWidget), text);
+}
+
+void pLabel::constructor() {
+  gtkWidget = gtk_label_new("");
+  gtk_misc_set_alignment(GTK_MISC(gtkWidget), 0.0, 0.5);
+
+  setText(label.state.text);
+}
+
+void pLabel::destructor() {
+  gtk_widget_destroy(gtkWidget);
+}
+
+void pLabel::orphan() {
+  destructor();
+  constructor();
+}
+
+}
diff -Nru higan/phoenix/gtk/widget/line-edit.cpp nSide/phoenix/gtk/widget/line-edit.cpp
--- higan/phoenix/gtk/widget/line-edit.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/gtk/widget/line-edit.cpp	2015-09-16 13:08:13.564563369 +0900
@@ -0,0 +1,59 @@
+namespace phoenix {
+
+static void LineEdit_activate(LineEdit* self) {
+  if(self->onActivate) self->onActivate();
+}
+
+static void LineEdit_change(LineEdit* self) {
+  self->state.text = self->text();
+  if(self->p.locked == false && self->onChange) self->onChange();
+}
+
+Size pLineEdit::minimumSize() {
+  Size size = pFont::size(widget.state.font, lineEdit.state.text);
+  return {size.width + 10, size.height + 10};
+}
+
+void pLineEdit::setBackgroundColor(Color color) {
+  GdkColor gdkColor = CreateColor(color.red, color.green, color.blue);
+  gtk_widget_modify_base(gtkWidget, GTK_STATE_NORMAL, &gdkColor);
+}
+
+void pLineEdit::setEditable(bool editable) {
+  gtk_editable_set_editable(GTK_EDITABLE(gtkWidget), editable);
+}
+
+void pLineEdit::setForegroundColor(Color color) {
+  GdkColor gdkColor = CreateColor(color.red, color.green, color.blue);
+  gtk_widget_modify_text(gtkWidget, GTK_STATE_NORMAL, &gdkColor);
+}
+
+void pLineEdit::setText(string text) {
+  locked = true;
+  gtk_entry_set_text(GTK_ENTRY(gtkWidget), text);
+  locked = false;
+}
+
+string pLineEdit::text() {
+  return gtk_entry_get_text(GTK_ENTRY(gtkWidget));
+}
+
+void pLineEdit::constructor() {
+  gtkWidget = gtk_entry_new();
+  g_signal_connect_swapped(G_OBJECT(gtkWidget), "activate", G_CALLBACK(LineEdit_activate), (gpointer)&lineEdit);
+  g_signal_connect_swapped(G_OBJECT(gtkWidget), "changed", G_CALLBACK(LineEdit_change), (gpointer)&lineEdit);
+
+  setEditable(lineEdit.state.editable);
+  setText(lineEdit.state.text);
+}
+
+void pLineEdit::destructor() {
+  gtk_widget_destroy(gtkWidget);
+}
+
+void pLineEdit::orphan() {
+  destructor();
+  constructor();
+}
+
+}
diff -Nru higan/phoenix/gtk/widget/list-view.cpp nSide/phoenix/gtk/widget/list-view.cpp
--- higan/phoenix/gtk/widget/list-view.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/gtk/widget/list-view.cpp	2015-09-16 13:08:13.563563369 +0900
@@ -0,0 +1,216 @@
+namespace phoenix {
+
+static void ListView_activate(GtkTreeView* treeView, GtkTreePath* path, GtkTreeViewColumn* column, ListView* self) {
+  char* pathname = gtk_tree_path_to_string(path);
+  unsigned selection = decimal(pathname);
+  g_free(pathname);
+  self->state.selection = selection;
+  if(self->onActivate) self->onActivate();
+}
+
+static void ListView_change(GtkTreeView* treeView, ListView* self) {
+  GtkTreeIter iter;
+  if(!gtk_tree_selection_get_selected(gtk_tree_view_get_selection(treeView), 0, &iter)) return;  //should not be possible
+  char* path = gtk_tree_model_get_string_from_iter(gtk_tree_view_get_model(treeView), &iter);
+  unsigned selection = decimal(path);
+  g_free(path);
+
+  if(!self->state.selected || self->state.selection != selection) {
+    self->state.selected = true;
+    self->state.selection = selection;
+    if(self->onChange) self->onChange();
+  }
+}
+
+static void ListView_toggle(GtkCellRendererToggle* cell, gchar* path, ListView* self) {
+  unsigned selection = decimal(path);
+  self->setChecked(selection, !self->checked(selection));
+  if(self->onToggle) self->onToggle(selection);
+}
+
+void pListView::append(const lstring& text) {
+  GtkTreeIter iter;
+  gtk_list_store_append(store, &iter);
+  for(unsigned n = 0; n < text.size(); n++) {
+    gtk_list_store_set(store, &iter, 1 + n * 2 + 1, (const char*)text[n], -1);
+  }
+}
+
+void pListView::autoSizeColumns() {
+  gtk_tree_view_columns_autosize(GTK_TREE_VIEW(subWidget));
+}
+
+bool pListView::focused() {
+  return GTK_WIDGET_HAS_FOCUS(subWidget);
+}
+
+void pListView::remove(unsigned selection) {
+  GtkTreeModel* model = gtk_tree_view_get_model(GTK_TREE_VIEW(subWidget));
+  GtkTreeIter iter;
+  gtk_tree_model_get_iter_from_string(model, &iter, string(selection));
+  gtk_list_store_remove(store, &iter);
+}
+
+void pListView::reset() {
+  listView.state.selected = false;
+  listView.state.selection = 0;
+  gtk_list_store_clear(GTK_LIST_STORE(store));
+  gtk_tree_view_set_model(GTK_TREE_VIEW(subWidget), GTK_TREE_MODEL(store));
+  //reset gtk_scrolled_window scrollbar position to 0,0 (top-left), as ListView is now empty
+  gtk_scrolled_window_set_hadjustment(GTK_SCROLLED_WINDOW(gtkWidget), 0);
+  gtk_scrolled_window_set_vadjustment(GTK_SCROLLED_WINDOW(gtkWidget), 0);
+}
+
+void pListView::setBackgroundColor(Color color) {
+  GdkColor gdkColor = CreateColor(color.red, color.green, color.blue);
+  gtk_widget_modify_base(subWidget, GTK_STATE_NORMAL, &gdkColor);
+}
+
+void pListView::setCheckable(bool checkable) {
+  gtk_cell_renderer_set_visible(column(0).checkbutton, checkable);
+}
+
+void pListView::setChecked(unsigned selection, bool checked) {
+  GtkTreeModel* model = gtk_tree_view_get_model(GTK_TREE_VIEW(subWidget));
+  GtkTreeIter iter;
+  gtk_tree_model_get_iter_from_string(model, &iter, string(selection));
+  gtk_list_store_set(GTK_LIST_STORE(model), &iter, 0, checked, -1);
+}
+
+void pListView::setForegroundColor(Color color) {
+  GdkColor gdkColor = CreateColor(color.red, color.green, color.blue);
+  gtk_widget_modify_text(subWidget, GTK_STATE_NORMAL, &gdkColor);
+}
+
+void pListView::setHeaderText(const lstring& text) {
+  destructor();
+  constructor();
+}
+
+void pListView::setHeaderVisible(bool visible) {
+  gtk_tree_view_set_headers_visible(GTK_TREE_VIEW(subWidget), visible);
+}
+
+void pListView::setImage(unsigned selection, unsigned position, const image& image) {
+  GtkTreeModel* model = gtk_tree_view_get_model(GTK_TREE_VIEW(subWidget));
+  GtkTreeIter iter;
+  gtk_tree_model_get_iter_from_string(model, &iter, string(selection));
+  if(image.empty() == false) {
+    GdkPixbuf* pixbuf = CreatePixbuf(image, true);
+    gtk_list_store_set(store, &iter, 1 + position * 2, pixbuf, -1);
+  } else {
+    gtk_list_store_set(store, &iter, 1 + position * 2, nullptr, -1);
+  }
+}
+
+void pListView::setSelected(bool selected) {
+  if(selected == false) {
+    GtkTreeSelection* selection = gtk_tree_view_get_selection(GTK_TREE_VIEW(subWidget));
+    gtk_tree_selection_unselect_all(selection);
+  } else {
+    setSelection(listView.state.selection);
+  }
+}
+
+void pListView::setSelection(unsigned selection) {
+  GtkTreeSelection* treeSelection = gtk_tree_view_get_selection(GTK_TREE_VIEW(subWidget));
+  gtk_tree_selection_unselect_all(treeSelection);
+  GtkTreePath* path = gtk_tree_path_new_from_string(string{selection});
+  gtk_tree_selection_select_path(treeSelection, path);
+  gtk_tree_view_set_cursor(GTK_TREE_VIEW(subWidget), path, nullptr, false);
+  gtk_tree_view_scroll_to_cell(GTK_TREE_VIEW(subWidget), path, nullptr, true, 0.5, 0.0);
+  gtk_tree_path_free(path);
+}
+
+void pListView::setText(unsigned selection, unsigned position, string text) {
+  GtkTreeModel* model = gtk_tree_view_get_model(GTK_TREE_VIEW(subWidget));
+  GtkTreeIter iter;
+  gtk_tree_model_get_iter_from_string(model, &iter, string(selection));
+  gtk_list_store_set(store, &iter, 1 + position * 2 + 1, (const char*)text, -1);
+}
+
+void pListView::constructor() {
+  gtkWidget = gtk_scrolled_window_new(0, 0);
+  gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(gtkWidget), GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
+  gtk_scrolled_window_set_shadow_type(GTK_SCROLLED_WINDOW(gtkWidget), GTK_SHADOW_ETCHED_IN);
+
+  lstring headerText = listView.state.headerText;
+  if(headerText.size() == 0) headerText.append("");  //ListView must have at least one column
+
+  column.reset();
+  vector<GType> gtype;
+  for(auto& text : headerText) {
+    GtkColumn cell;
+    cell.label = gtk_label_new(text);
+    cell.column = gtk_tree_view_column_new();
+    gtk_tree_view_column_set_resizable(cell.column, true);
+    gtk_tree_view_column_set_title(cell.column, "");
+
+    if(column.size() == 0) {  //first column checkbutton
+      cell.checkbutton = gtk_cell_renderer_toggle_new();
+      gtk_tree_view_column_pack_start(cell.column, cell.checkbutton, false);
+      gtk_tree_view_column_set_attributes(cell.column, cell.checkbutton, "active", gtype.size(), nullptr);
+      gtype.append(G_TYPE_BOOLEAN);
+      g_signal_connect(cell.checkbutton, "toggled", G_CALLBACK(ListView_toggle), (gpointer)&listView);
+    }
+
+    cell.icon = gtk_cell_renderer_pixbuf_new();
+    gtk_tree_view_column_pack_start(cell.column, cell.icon, false);
+    gtk_tree_view_column_set_attributes(cell.column, cell.icon, "pixbuf", gtype.size(), nullptr);
+    gtype.append(GDK_TYPE_PIXBUF);
+
+    cell.text = gtk_cell_renderer_text_new();
+    gtk_tree_view_column_pack_start(cell.column, cell.text, false);
+    gtk_tree_view_column_set_attributes(cell.column, cell.text, "text", gtype.size(), nullptr);
+    gtype.append(G_TYPE_STRING);
+
+    column.append(cell);
+  }
+
+  store = gtk_list_store_newv(gtype.size(), gtype.data());
+  subWidget = gtk_tree_view_new_with_model(GTK_TREE_MODEL(store));
+  gtk_container_add(GTK_CONTAINER(gtkWidget), subWidget);
+  g_object_unref(G_OBJECT(store));
+
+  for(auto& cell : column) {
+    gtk_tree_view_column_set_widget(GTK_TREE_VIEW_COLUMN(cell.column), cell.label);
+    gtk_tree_view_append_column(GTK_TREE_VIEW(subWidget), cell.column);
+    gtk_widget_show(cell.label);
+  }
+
+  gtk_tree_view_set_rules_hint(GTK_TREE_VIEW(subWidget), headerText.size() >= 2);  //two or more columns + checkbutton column
+  gtk_tree_view_set_search_column(GTK_TREE_VIEW(subWidget), 2);
+
+  g_signal_connect(G_OBJECT(subWidget), "cursor-changed", G_CALLBACK(ListView_change), (gpointer)&listView);
+  g_signal_connect(G_OBJECT(subWidget), "row-activated", G_CALLBACK(ListView_activate), (gpointer)&listView);
+
+  gtk_widget_show(subWidget);
+
+  setHeaderVisible(listView.state.headerVisible);
+  setCheckable(listView.state.checkable);
+  for(auto& text : listView.state.text) append(text);
+  for(unsigned n = 0; n < listView.state.checked.size(); n++) setChecked(n, listView.state.checked[n]);
+  if(listView.state.selected) setSelection(listView.state.selection);
+  autoSizeColumns();
+}
+
+void pListView::destructor() {
+  gtk_widget_destroy(subWidget);
+  gtk_widget_destroy(gtkWidget);
+}
+
+void pListView::orphan() {
+  destructor();
+  constructor();
+}
+
+void pListView::setFocused() {
+  gtk_widget_grab_focus(subWidget);
+}
+
+void pListView::setFont(string font) {
+  pFont::setFont(gtkWidget, font);
+  for(auto& cell : column) pFont::setFont(cell.label, font);
+}
+
+}
diff -Nru higan/phoenix/gtk/widget/progress-bar.cpp nSide/phoenix/gtk/widget/progress-bar.cpp
--- higan/phoenix/gtk/widget/progress-bar.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/gtk/widget/progress-bar.cpp	2015-09-16 13:08:13.565563369 +0900
@@ -0,0 +1,27 @@
+namespace phoenix {
+
+Size pProgressBar::minimumSize() {
+  return {0, 25};
+}
+
+void pProgressBar::setPosition(unsigned position) {
+  position = position <= 100 ? position : 0;
+  gtk_progress_bar_set_fraction(GTK_PROGRESS_BAR(gtkWidget), (double)position / 100.0);
+}
+
+void pProgressBar::constructor() {
+  gtkWidget = gtk_progress_bar_new();
+
+  setPosition(progressBar.state.position);
+}
+
+void pProgressBar::destructor() {
+  gtk_widget_destroy(gtkWidget);
+}
+
+void pProgressBar::orphan() {
+  destructor();
+  constructor();
+}
+
+}
diff -Nru higan/phoenix/gtk/widget/radio-button.cpp nSide/phoenix/gtk/widget/radio-button.cpp
--- higan/phoenix/gtk/widget/radio-button.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/gtk/widget/radio-button.cpp	2015-09-16 13:08:13.563563369 +0900
@@ -0,0 +1,89 @@
+namespace phoenix {
+
+static void RadioButton_activate(GtkToggleButton* toggleButton, RadioButton* self) {
+  self->p.onActivate();
+}
+
+Size pRadioButton::minimumSize() {
+  Size size = pFont::size(widget.state.font, radioButton.state.text);
+
+  if(radioButton.state.orientation == Orientation::Horizontal) {
+    size.width += radioButton.state.image.width();
+    size.height = max(radioButton.state.image.height(), size.height);
+  }
+
+  if(radioButton.state.orientation == Orientation::Vertical) {
+    size.width = max(radioButton.state.image.width(), size.width);
+    size.height += radioButton.state.image.height();
+  }
+
+  return {size.width + 24, size.height + 12};
+}
+
+void pRadioButton::setChecked() {
+  parent().locked = true;
+  for(auto& item : radioButton.state.group) {
+    bool checked = &item == &radioButton;
+    gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(item.p.gtkWidget), item.state.checked = checked);
+  }
+  parent().locked = false;
+}
+
+void pRadioButton::setGroup(const group<RadioButton>& group) {
+  parent().locked = true;
+  for(auto& item : radioButton.state.group) {
+    gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(item.p.gtkWidget), item.state.checked);
+  }
+  parent().locked = false;
+}
+
+void pRadioButton::setImage(const image& image, Orientation orientation) {
+  if(image.empty() == false) {
+    GtkImage* gtkImage = CreateImage(image);
+    gtk_button_set_image(GTK_BUTTON(gtkWidget), (GtkWidget*)gtkImage);
+  } else {
+    gtk_button_set_image(GTK_BUTTON(gtkWidget), nullptr);
+  }
+  switch(orientation) {
+  case Orientation::Horizontal: gtk_button_set_image_position(GTK_BUTTON(gtkWidget), GTK_POS_LEFT); break;
+  case Orientation::Vertical:   gtk_button_set_image_position(GTK_BUTTON(gtkWidget), GTK_POS_TOP);  break;
+  }
+}
+
+void pRadioButton::setText(string text) {
+  gtk_button_set_label(GTK_BUTTON(gtkWidget), text);
+  setFont(widget.state.font);
+}
+
+void pRadioButton::constructor() {
+  gtkWidget = gtk_toggle_button_new();
+  g_signal_connect(G_OBJECT(gtkWidget), "toggled", G_CALLBACK(RadioButton_activate), (gpointer)&radioButton);
+
+  setGroup(radioButton.state.group);
+  setText(radioButton.state.text);
+}
+
+void pRadioButton::destructor() {
+  gtk_widget_destroy(gtkWidget);
+}
+
+void pRadioButton::orphan() {
+  destructor();
+  constructor();
+}
+
+void pRadioButton::onActivate() {
+  if(parent().locked) return;
+  bool wasChecked = radioButton.state.checked;
+  setChecked();
+  if(!wasChecked) {
+    if(radioButton.onActivate) radioButton.onActivate();
+  }
+}
+
+pRadioButton& pRadioButton::parent() {
+  if(radioButton.state.group.size()) return radioButton.state.group.first().p;
+  return *this;
+}
+
+}
diff -Nru higan/phoenix/gtk/widget/radio-label.cpp nSide/phoenix/gtk/widget/radio-label.cpp
--- higan/phoenix/gtk/widget/radio-label.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/gtk/widget/radio-label.cpp	2015-09-16 13:08:13.565563369 +0900
@@ -0,0 +1,69 @@
+namespace phoenix {
+
+static void RadioLabel_activate(GtkToggleButton* toggleButton, RadioLabel* self) {
+  self->p.onActivate();
+}
+
+Size pRadioLabel::minimumSize() {
+  Size size = pFont::size(widget.state.font, radioLabel.state.text);
+  return {size.width + 28, size.height + 4};
+}
+
+void pRadioLabel::setChecked() {
+  parent().locked = true;
+  for(auto& item : radioLabel.state.group) item.state.checked = false;
+  gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(gtkWidget), radioLabel.state.checked = true);
+  parent().locked = false;
+}
+
+void pRadioLabel::setGroup(const group<RadioLabel>& group) {
+  if(&parent() == this) return;
+  parent().locked = true;
+  gtk_radio_button_set_group(
+    GTK_RADIO_BUTTON(gtkWidget),
+    gtk_radio_button_get_group(GTK_RADIO_BUTTON(parent().gtkWidget))
+  );
+  for(auto& item : radioLabel.state.group) {
+    if(item.state.checked) {
+      gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(item.p.gtkWidget), true);
+      break;
+    }
+  }
+  parent().locked = false;
+}
+
+void pRadioLabel::setText(string text) {
+  gtk_button_set_label(GTK_BUTTON(gtkWidget), text);
+}
+
+void pRadioLabel::constructor() {
+  gtkWidget = gtk_radio_button_new_with_label(nullptr, "");
+  g_signal_connect(G_OBJECT(gtkWidget), "toggled", G_CALLBACK(RadioLabel_activate), (gpointer)&radioLabel);
+
+  setGroup(radioLabel.state.group);
+  setText(radioLabel.state.text);
+}
+
+void pRadioLabel::destructor() {
+  gtk_widget_destroy(gtkWidget);
+}
+
+void pRadioLabel::orphan() {
+  destructor();
+  constructor();
+}
+
+void pRadioLabel::onActivate() {
+  if(parent().locked) return;
+  bool wasChecked = radioLabel.state.checked;
+  setChecked();
+  if(wasChecked) return;
+  if(radioLabel.onActivate) radioLabel.onActivate();
+}
+
+pRadioLabel& pRadioLabel::parent() {
+  if(radioLabel.state.group.size()) return radioLabel.state.group.first().p;
+  return *this;
+}
+
+}
diff -Nru higan/phoenix/gtk/widget/tab-frame.cpp nSide/phoenix/gtk/widget/tab-frame.cpp
--- higan/phoenix/gtk/widget/tab-frame.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/gtk/widget/tab-frame.cpp	2015-09-16 13:08:13.563563369 +0900
@@ -0,0 +1,126 @@
+namespace phoenix {
+
+static void TabFrame_change(GtkNotebook* notebook, GtkWidget* page, unsigned selection, TabFrame* self) {
+  self->state.selection = selection;
+  self->p.synchronizeLayout();
+  if(!self->p.locked && self->onChange) self->onChange();
+}
+
+void pTabFrame::append(string text, const image& image) {
+  unsigned selection = tabFrame.state.text.size() - 1;
+
+  Tab tab;
+  tab.child = gtk_fixed_new();
+  tab.container = gtk_hbox_new(false, 0);
+  tab.image = gtk_image_new();
+  tab.title = gtk_label_new(text);
+  tabs.append(tab);
+
+  gtk_widget_show(tab.child);
+  gtk_widget_show(tab.container);
+  gtk_widget_show(tab.image);
+  gtk_widget_show(tab.title);
+  gtk_box_pack_start(GTK_BOX(tab.container), tab.image, false, false, 0);
+  gtk_box_pack_start(GTK_BOX(tab.container), tab.title, false, false, 2);
+
+  gtk_notebook_append_page(GTK_NOTEBOOK(gtkWidget), tab.child, tab.container);
+  setFont(widget.state.font);
+  if(!image.empty()) setImage(selection, image);
+}
+
+GtkWidget* pTabFrame::container(Widget& widget) {
+  Layout* widgetLayout = GetParentWidgetLayout(&widget);
+  unsigned selection = 0;
+  for(auto& layout : tabFrame.state.layout) {
+    if(layout == widgetLayout) return tabs[selection].child;
+    selection++;
+  }
+  return nullptr;
+}
+
+Position pTabFrame::displacement() {
+  return {6, 31};
+}
+
+void pTabFrame::remove(unsigned selection) {
+  tabs.remove(selection);
+  gtk_notebook_remove_page(GTK_NOTEBOOK(gtkWidget), selection);
+}
+
+void pTabFrame::setEnabled(bool enabled) {
+  for(auto& layout : tabFrame.state.layout) {
+    if(layout) layout->setEnabled(layout->enabled());
+  }
+  pWidget::setEnabled(enabled);
+}
+
+void pTabFrame::setGeometry(Geometry geometry) {
+  pWidget::setGeometry(geometry);
+  geometry.x += 1, geometry.width -= 5;
+  geometry.y += 26, geometry.height -= 31;
+  for(auto& layout : tabFrame.state.layout) {
+    if(layout) layout->setGeometry(geometry);
+  }
+  synchronizeLayout();
+}
+
+void pTabFrame::setImage(unsigned selection, const image& image) {
+  if(image.empty() == false) {
+    nall::image copy = image;
+    unsigned size = pFont::size(widget.state.font, " ").height;
+    copy.scale(size, size);
+    GdkPixbuf* pixbuf = CreatePixbuf(copy);
+    gtk_image_set_from_pixbuf(GTK_IMAGE(tabs[selection].image), pixbuf);
+  } else {
+    gtk_image_clear(GTK_IMAGE(tabs[selection].image));
+  }
+}
+
+void pTabFrame::setSelection(unsigned selection) {
+  locked = true;
+  gtk_notebook_set_current_page(GTK_NOTEBOOK(gtkWidget), selection);
+  locked = false;
+}
+
+void pTabFrame::setText(unsigned selection, string text) {
+  gtk_label_set_text(GTK_LABEL(tabs[selection].title), text);
+}
+
+void pTabFrame::setVisible(bool visible) {
+  for(auto& layout : tabFrame.state.layout) {
+    if(layout) layout->setVisible(layout->visible());
+  }
+  pWidget::setVisible(visible);
+}
+
+void pTabFrame::constructor() {
+  gtkWidget = gtk_notebook_new();
+  gtk_notebook_set_show_border(GTK_NOTEBOOK(gtkWidget), false);
+  gtk_notebook_set_tab_pos(GTK_NOTEBOOK(gtkWidget), GTK_POS_TOP);
+  g_signal_connect(G_OBJECT(gtkWidget), "switch-page", G_CALLBACK(TabFrame_change), (gpointer)&tabFrame);
+
+  setSelection(tabFrame.state.selection);
+}
+
+void pTabFrame::destructor() {
+  gtk_widget_destroy(gtkWidget);
+}
+
+void pTabFrame::orphan() {
+  destructor();
+  constructor();
+}
+
+void pTabFrame::setFont(string font) {
+  for(auto& tab : tabs) pFont::setFont(tab.title, font);
+}
+
+void pTabFrame::synchronizeLayout() {
+  unsigned selection = 0;
+  for(auto& layout : tabFrame.state.layout) {
+    if(layout) layout->setVisible(selection == tabFrame.state.selection);
+    selection++;
+  }
+}
+
+}
diff -Nru higan/phoenix/gtk/widget/text-edit.cpp nSide/phoenix/gtk/widget/text-edit.cpp
--- higan/phoenix/gtk/widget/text-edit.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/gtk/widget/text-edit.cpp	2015-09-16 13:08:13.564563369 +0900
@@ -0,0 +1,88 @@
+namespace phoenix {
+
+static void TextEdit_change(TextEdit* self) {
+  self->state.text = self->text();
+  if(self->p.locked == false && self->onChange) self->onChange();
+}
+
+bool pTextEdit::focused() {
+  return GTK_WIDGET_HAS_FOCUS(subWidget);
+}
+
+void pTextEdit::setBackgroundColor(Color color) {
+  GdkColor gdkColor = CreateColor(color.red, color.green, color.blue);
+  gtk_widget_modify_base(subWidget, GTK_STATE_NORMAL, &gdkColor);
+}
+
+void pTextEdit::setCursorPosition(unsigned position) {
+  GtkTextMark* mark = gtk_text_buffer_get_mark(textBuffer, "insert");
+  GtkTextIter iter;
+  gtk_text_buffer_get_end_iter(textBuffer, &iter);
+  gtk_text_iter_set_offset(&iter, min(position, gtk_text_iter_get_offset(&iter)));
+  gtk_text_buffer_place_cursor(textBuffer, &iter);
+  gtk_text_view_scroll_mark_onscreen(GTK_TEXT_VIEW(subWidget), mark);
+}
+
+void pTextEdit::setEditable(bool editable) {
+  gtk_text_view_set_editable(GTK_TEXT_VIEW(subWidget), editable);
+}
+
+void pTextEdit::setForegroundColor(Color color) {
+  GdkColor gdkColor = CreateColor(color.red, color.green, color.blue);
+  gtk_widget_modify_text(subWidget, GTK_STATE_NORMAL, &gdkColor);
+}
+
+void pTextEdit::setText(string text) {
+  locked = true;
+  gtk_text_buffer_set_text(textBuffer, text, -1);
+  locked = false;
+}
+
+void pTextEdit::setWordWrap(bool wordWrap) {
+  gtk_text_view_set_wrap_mode(GTK_TEXT_VIEW(subWidget), wordWrap ? GTK_WRAP_WORD_CHAR : GTK_WRAP_NONE);
+  gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(gtkWidget),
+    wordWrap ? GTK_POLICY_NEVER : GTK_POLICY_ALWAYS,
+    GTK_POLICY_ALWAYS);
+}
+
+string pTextEdit::text() {
+  GtkTextIter start, end;
+  gtk_text_buffer_get_start_iter(textBuffer, &start);
+  gtk_text_buffer_get_end_iter(textBuffer, &end);
+  char* temp = gtk_text_buffer_get_text(textBuffer, &start, &end, true);
+  string text = temp;
+  g_free(temp);
+  return text;
+}
+
+void pTextEdit::constructor() {
+  gtkWidget = gtk_scrolled_window_new(0, 0);
+  gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(gtkWidget), GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
+  gtk_scrolled_window_set_shadow_type(GTK_SCROLLED_WINDOW(gtkWidget), GTK_SHADOW_ETCHED_IN);
+
+  subWidget = gtk_text_view_new();
+  gtk_text_view_set_wrap_mode(GTK_TEXT_VIEW(subWidget), GTK_WRAP_WORD_CHAR);
+  gtk_container_add(GTK_CONTAINER(gtkWidget), subWidget);
+
+  textBuffer = gtk_text_view_get_buffer(GTK_TEXT_VIEW(subWidget));
+
+  g_signal_connect_swapped(G_OBJECT(textBuffer), "changed", G_CALLBACK(TextEdit_change), (gpointer)&textEdit);
+
+  gtk_widget_show(subWidget);
+
+  setEditable(textEdit.state.editable);
+  setText(textEdit.state.text);
+  setWordWrap(textEdit.state.wordWrap);
+}
+
+void pTextEdit::destructor() {
+  gtk_widget_destroy(subWidget);
+  gtk_widget_destroy(gtkWidget);
+}
+
+void pTextEdit::orphan() {
+  destructor();
+  constructor();
+}
+
+}
diff -Nru higan/phoenix/gtk/widget/vertical-scroller.cpp nSide/phoenix/gtk/widget/vertical-scroller.cpp
--- higan/phoenix/gtk/widget/vertical-scroller.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/gtk/widget/vertical-scroller.cpp	2015-09-16 13:08:13.564563369 +0900
@@ -0,0 +1,43 @@
+namespace phoenix {
+
+static void VerticalScroller_change(GtkRange* gtkRange, VerticalScroller* self) {
+  unsigned position = (unsigned)gtk_range_get_value(gtkRange);
+  if(self->state.position == position) return;
+  self->state.position = position;
+  if(!self->p.locked && self->onChange) self->onChange();
+}
+
+Size pVerticalScroller::minimumSize() {
+  return {20, 0};
+}
+
+void pVerticalScroller::setLength(unsigned length) {
+  locked = true;
+  length += length == 0;
+  gtk_range_set_range(GTK_RANGE(gtkWidget), 0, max(1u, length - 1));
+  gtk_range_set_increments(GTK_RANGE(gtkWidget), 1, length >> 3);
+  locked = false;
+}
+
+void pVerticalScroller::setPosition(unsigned position) {
+  gtk_range_set_value(GTK_RANGE(gtkWidget), position);
+}
+
+void pVerticalScroller::constructor() {
+  gtkWidget = gtk_vscrollbar_new(0);
+  g_signal_connect(G_OBJECT(gtkWidget), "value-changed", G_CALLBACK(VerticalScroller_change), (gpointer)&verticalScroller);
+
+  setLength(verticalScroller.state.length);
+  setPosition(verticalScroller.state.position);
+}
+
+void pVerticalScroller::destructor() {
+  gtk_widget_destroy(gtkWidget);
+}
+
+void pVerticalScroller::orphan() {
+  destructor();
+  constructor();
+}
+
+}
diff -Nru higan/phoenix/gtk/widget/vertical-slider.cpp nSide/phoenix/gtk/widget/vertical-slider.cpp
--- higan/phoenix/gtk/widget/vertical-slider.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/gtk/widget/vertical-slider.cpp	2015-09-16 13:08:13.565563369 +0900
@@ -0,0 +1,42 @@
+namespace phoenix {
+
+static void VerticalSlider_change(GtkRange* gtkRange, VerticalSlider* self) {
+  unsigned position = (unsigned)gtk_range_get_value(gtkRange);
+  if(self->state.position == position) return;
+  self->state.position = position;
+  if(self->onChange) self->onChange();
+}
+
+Size pVerticalSlider::minimumSize() {
+  return {20, 0};
+}
+
+void pVerticalSlider::setLength(unsigned length) {
+  length += length == 0;
+  gtk_range_set_range(GTK_RANGE(gtkWidget), 0, max(1u, length - 1));
+  gtk_range_set_increments(GTK_RANGE(gtkWidget), 1, length >> 3);
+}
+
+void pVerticalSlider::setPosition(unsigned position) {
+  gtk_range_set_value(GTK_RANGE(gtkWidget), position);
+}
+
+void pVerticalSlider::constructor() {
+  gtkWidget = gtk_vscale_new_with_range(0, 100, 1);
+  gtk_scale_set_draw_value(GTK_SCALE(gtkWidget), false);
+  g_signal_connect(G_OBJECT(gtkWidget), "value-changed", G_CALLBACK(VerticalSlider_change), (gpointer)&verticalSlider);
+
+  setLength(verticalSlider.state.length);
+  setPosition(verticalSlider.state.position);
+}
+
+void pVerticalSlider::destructor() {
+  gtk_widget_destroy(gtkWidget);
+}
+
+void pVerticalSlider::orphan() {
+  destructor();
+  constructor();
+}
+
+}
diff -Nru higan/phoenix/gtk/widget/viewport.cpp nSide/phoenix/gtk/widget/viewport.cpp
--- higan/phoenix/gtk/widget/viewport.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/gtk/widget/viewport.cpp	2015-09-16 13:08:13.564563369 +0900
@@ -0,0 +1,76 @@
+namespace phoenix {
+
+static void Viewport_dropEvent(GtkWidget* widget, GdkDragContext* context, gint x, gint y,
+GtkSelectionData* data, guint type, guint timestamp, Viewport* viewport) {
+  if(viewport->state.droppable == false) return;
+  lstring paths = DropPaths(data);
+  if(paths.empty()) return;
+  if(viewport->onDrop) viewport->onDrop(paths);
+}
+
+static gboolean Viewport_mouseLeave(GtkWidget* widget, GdkEventButton* event, pViewport* self) {
+  if(self->viewport.onMouseLeave) self->viewport.onMouseLeave();
+  return true;
+}
+
+static gboolean Viewport_mouseMove(GtkWidget* widget, GdkEventButton* event, pViewport* self) {
+  if(self->viewport.onMouseMove) self->viewport.onMouseMove({(signed)event->x, (signed)event->y});
+  return true;
+}
+
+static gboolean Viewport_mousePress(GtkWidget* widget, GdkEventButton* event, pViewport* self) {
+  if(self->viewport.onMousePress) switch(event->button) {
+  case 1: self->viewport.onMousePress(Mouse::Button::Left); break;
+  case 2: self->viewport.onMousePress(Mouse::Button::Middle); break;
+  case 3: self->viewport.onMousePress(Mouse::Button::Right); break;
+  }
+  return true;
+}
+
+static gboolean Viewport_mouseRelease(GtkWidget* widget, GdkEventButton* event, pViewport* self) {
+  if(self->viewport.onMouseRelease) switch(event->button) {
+  case 1: self->viewport.onMouseRelease(Mouse::Button::Left); break;
+  case 2: self->viewport.onMouseRelease(Mouse::Button::Middle); break;
+  case 3: self->viewport.onMouseRelease(Mouse::Button::Right); break;
+  }
+  return true;
+}
+
+uintptr_t pViewport::handle() {
+  return GDK_WINDOW_XID(gtk_widget_get_window(gtkWidget));
+}
+
+void pViewport::setDroppable(bool droppable) {
+  gtk_drag_dest_set(gtkWidget, GTK_DEST_DEFAULT_ALL, nullptr, 0, GDK_ACTION_COPY);
+  if(droppable) gtk_drag_dest_add_uri_targets(gtkWidget);
+}
+
+void pViewport::constructor() {
+  gtkWidget = gtk_drawing_area_new();
+//gtk_widget_set_double_buffered(gtkWidget, false);
+  gtk_widget_add_events(gtkWidget,
+    GDK_BUTTON_PRESS_MASK | GDK_BUTTON_RELEASE_MASK | GDK_LEAVE_NOTIFY_MASK | GDK_POINTER_MOTION_MASK);
+  g_signal_connect(G_OBJECT(gtkWidget), "drag-data-received", G_CALLBACK(Viewport_dropEvent), (gpointer)&viewport);
+  g_signal_connect(G_OBJECT(gtkWidget), "button-press-event", G_CALLBACK(Viewport_mousePress), (gpointer)this);
+  g_signal_connect(G_OBJECT(gtkWidget), "button-release-event", G_CALLBACK(Viewport_mouseRelease), (gpointer)this);
+  g_signal_connect(G_OBJECT(gtkWidget), "leave-notify-event", G_CALLBACK(Viewport_mouseLeave), (gpointer)this);
+  g_signal_connect(G_OBJECT(gtkWidget), "motion-notify-event", G_CALLBACK(Viewport_mouseMove), (gpointer)this);
+
+  GdkColor color;
+  color.pixel = 0;
+  color.red = 0;
+  color.green = 0;
+  color.blue = 0;
+  gtk_widget_modify_bg(gtkWidget, GTK_STATE_NORMAL, &color);
+}
+
+void pViewport::destructor() {
+  gtk_widget_destroy(gtkWidget);
+}
+
+void pViewport::orphan() {
+  destructor();
+  constructor();
+}
+
+}
diff -Nru higan/phoenix/gtk/widget/widget.cpp nSide/phoenix/gtk/widget/widget.cpp
--- higan/phoenix/gtk/widget/widget.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/gtk/widget/widget.cpp	2015-09-16 13:08:13.561563368 +0900
@@ -0,0 +1,62 @@
+namespace phoenix {
+
+GtkWidget* pWidget::container(Widget& widget) {
+  return nullptr;
+}
+
+bool pWidget::focused() {
+  return GTK_WIDGET_HAS_FOCUS(gtkWidget);
+}
+
+Size pWidget::minimumSize() {
+  return {0, 0};
+}
+
+void pWidget::setEnabled(bool enabled) {
+  if(!widget.parent()) enabled = false;
+  if(widget.state.abstract) enabled = false;
+  if(!widget.enabledToAll()) enabled = false;
+  gtk_widget_set_sensitive(gtkWidget, enabled);
+}
+
+void pWidget::setFocused() {
+  gtk_widget_grab_focus(gtkWidget);
+}
+
+void pWidget::setFont(string font) {
+  pFont::setFont(gtkWidget, font);
+}
+
+void pWidget::setGeometry(Geometry geometry) {
+  Position displacement = GetDisplacement(&widget);
+  geometry.x -= displacement.x;
+  geometry.y -= displacement.y;
+
+  if(gtkParent) gtk_fixed_move(GTK_FIXED(gtkParent), gtkWidget, geometry.x, geometry.y);
+  unsigned width = (signed)geometry.width <= 0 ? 1u : geometry.width;
+  unsigned height = (signed)geometry.height <= 0 ? 1u : geometry.height;
+  gtk_widget_set_size_request(gtkWidget, width, height);
+  if(widget.onSize) widget.onSize();
+}
+
+void pWidget::setVisible(bool visible) {
+  if(!widget.parent()) visible = false;
+  if(widget.state.abstract) visible = false;
+  if(!widget.visibleToAll()) visible = false;
+  gtk_widget_set_visible(gtkWidget, visible);
+}
+
+void pWidget::constructor() {
+  if(widget.state.abstract) gtkWidget = gtk_fixed_new();
+}
+
+void pWidget::destructor() {
+  if(widget.state.abstract) gtk_widget_destroy(gtkWidget);
+}
+
+void pWidget::orphan() {
+  destructor();
+  constructor();
+}
+
+}
diff -Nru higan/phoenix/gtk/window.cpp nSide/phoenix/gtk/window.cpp
--- higan/phoenix/gtk/window.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/gtk/window.cpp	2015-09-16 13:08:13.567563369 +0900
@@ -0,0 +1,402 @@
+namespace phoenix {
+
+static gint Window_close(GtkWidget* widget, GdkEvent* event, Window* window) {
+  if(window->onClose) window->onClose();
+  else window->setVisible(false);
+  if(window->state.modal && !window->visible()) window->setModal(false);
+  return true;
+}
+
+static gboolean Window_expose(GtkWidget* widget, GdkEvent* event, Window* window) {
+  if(window->state.backgroundColorOverride == false) return false;
+  cairo_t* context = gdk_cairo_create(widget->window);
+
+  Color color = window->backgroundColor();
+  double red   = (double)color.red   / 255.0;
+  double green = (double)color.green / 255.0;
+  double blue  = (double)color.blue  / 255.0;
+  double alpha = (double)color.alpha / 255.0;
+
+  if(gdk_screen_is_composited(gdk_screen_get_default())
+  && gdk_screen_get_rgba_colormap(gdk_screen_get_default())
+  ) {
+    cairo_set_source_rgba(context, red, green, blue, alpha);
+  } else {
+    cairo_set_source_rgb(context, red, green, blue);
+  }
+
+  cairo_set_operator(context, CAIRO_OPERATOR_SOURCE);
+  cairo_paint(context);
+  cairo_destroy(context);
+
+  return false;
+}
+
+static gboolean Window_configure(GtkWidget* widget, GdkEvent* event, Window* window) {
+  if(gtk_widget_get_realized(window->p.widget) == false) return false;
+  if(window->visible() == false) return false;
+  GdkWindow *gdkWindow = gtk_widget_get_window(widget);
+
+  GdkRectangle border, client;
+  gdk_window_get_frame_extents(gdkWindow, &border);
+  gdk_window_get_geometry(gdkWindow, nullptr, nullptr, &client.width, &client.height, nullptr);
+  gdk_window_get_origin(gdkWindow, &client.x, &client.y);
+
+  if(window->state.fullScreen == false) {
+    //update geometry settings
+    settings->geometry.frameX = client.x - border.x;
+    settings->geometry.frameY = client.y - border.y;
+    settings->geometry.frameWidth = border.width - client.width;
+    settings->geometry.frameHeight = border.height - client.height;
+    if(window->state.backgroundColorOverride == false) {
+      GdkColor color = widget->style->bg[GTK_STATE_NORMAL];
+      settings->window.backgroundColor
+      = ((uint8_t)(color.red   >> 8) << 16)
+      + ((uint8_t)(color.green >> 8) <<  8)
+      + ((uint8_t)(color.blue  >> 8) <<  0);
+    }
+    settings->save();
+  }
+
+  Geometry geometry = {
+    client.x,
+    client.y + window->p.menuHeight(),
+    client.width,
+    client.height - window->p.menuHeight() - window->p.statusHeight()
+  };
+
+  //move
+  if(geometry.x != window->state.geometry.x || geometry.y != window->state.geometry.y) {
+    if(window->state.fullScreen == false) {
+      window->state.geometry.x = geometry.x;
+      window->state.geometry.y = geometry.y;
+    }
+    if(window->p.locked == false && window->onMove) window->onMove();
+  }
+
+  //size
+  if(geometry.width != window->state.geometry.width || geometry.height != window->state.geometry.height) {
+    window->p.onSizePending = true;
+  }
+
+  return false;
+}
+
+static void Window_drop(GtkWidget* widget, GdkDragContext* context, gint x, gint y,
+GtkSelectionData* data, guint type, guint timestamp, Window* window) {
+  if(window->state.droppable == false) return;
+  lstring paths = DropPaths(data);
+  if(paths.empty()) return;
+  if(window->onDrop) window->onDrop(paths);
+}
+
+static gboolean Window_keyPress(GtkWidget* widget, GdkEventKey* event, Window* window) {
+  Keyboard::Keycode key = Keysym(event->keyval);
+  if(key != Keyboard::Keycode::None && window->onKeyPress) window->onKeyPress(key);
+  return false;
+}
+
+static gboolean Window_keyRelease(GtkWidget* widget, GdkEventKey* event, Window* window) {
+  Keyboard::Keycode key = Keysym(event->keyval);
+  if(key != Keyboard::Keycode::None && window->onKeyRelease) window->onKeyRelease(key);
+  return false;
+}
+
+static void Window_sizeAllocate(GtkWidget* widget, GtkAllocation* allocation, Window* window) {
+  //size-allocate sent from gtk_fixed_move(); detect if layout unchanged and return
+  if(allocation->width  == window->p.lastAllocation.width
+  && allocation->height == window->p.lastAllocation.height) return;
+
+  window->state.geometry.width  = allocation->width;
+  window->state.geometry.height = allocation->height;
+
+  for(auto& layout : window->state.layout) {
+    Geometry geometry = window->geometry();
+    geometry.x = geometry.y = 0;
+    layout.setGeometry(geometry);
+  }
+
+  if(window->p.onSizePending && window->p.locked == false && window->onSize) {
+    window->p.onSizePending = false;
+    window->onSize();
+  }
+
+  window->p.lastAllocation = *allocation;
+}
+
+static void Window_sizeRequest(GtkWidget* widget, GtkRequisition* requisition, Window* window) {
+  requisition->width  = window->state.geometry.width;
+  requisition->height = window->state.geometry.height;
+}
+
+Window& pWindow::none() {
+  static Window* window = nullptr;
+  if(window == nullptr) window = new Window;
+  return *window;
+}
+
+void pWindow::append(Layout& layout) {
+  Geometry geometry = this->geometry();
+  geometry.x = geometry.y = 0;
+  layout.setGeometry(geometry);
+}
+
+void pWindow::append(Menu& menu) {
+  if(window.state.menuFont) menu.p.setFont(window.state.menuFont);
+  else menu.p.setFont(Font::sans(8));
+  gtk_menu_shell_append(GTK_MENU_SHELL(this->menu), menu.p.widget);
+  gtk_widget_show(menu.p.widget);
+}
+
+void pWindow::append(Widget& widget) {
+  if(widget.font().empty() && !window.state.widgetFont.empty()) {
+    widget.setFont(window.state.widgetFont);
+  }
+
+  if(GetParentWidget(&widget)) {
+    widget.p.gtkParent = GetParentWidget(&widget)->p.container(widget);
+  } else {
+    widget.p.gtkParent = formContainer;
+  }
+
+  gtk_fixed_put(GTK_FIXED(widget.p.gtkParent), widget.p.gtkWidget, 0, 0);
+  if(widget.state.font) widget.p.setFont(widget.state.font);
+  else if(window.state.widgetFont) widget.p.setFont(window.state.widgetFont);
+  else widget.p.setFont(Font::sans(8));
+  widget.setVisible(widget.visible());
+}
+
+Geometry pWindow::frameMargin() {
+  if(window.state.fullScreen) return {
+    0,
+    menuHeight(),
+    0,
+    menuHeight() + statusHeight()
+  };
+
+  return {
+    settings->geometry.frameX,
+    settings->geometry.frameY + menuHeight(),
+    settings->geometry.frameWidth,
+    settings->geometry.frameHeight + menuHeight() + statusHeight()
+  };
+}
+
+bool pWindow::focused() {
+  return gtk_window_is_active(GTK_WINDOW(widget));
+}
+
+Geometry pWindow::geometry() {
+  if(window.state.fullScreen) {
+    int x, y, width, height;
+    gtk_window_get_position(GTK_WINDOW(widget), &x, &y);
+    gtk_window_get_size(GTK_WINDOW(widget), &width, &height);
+    return {x, y + menuHeight(), width, height - menuHeight() - statusHeight()};
+  }
+  return window.state.geometry;
+}
+
+void pWindow::remove(Layout& layout) {
+}
+
+void pWindow::remove(Menu& menu) {
+  menu.p.orphan();
+}
+
+void pWindow::remove(Widget& widget) {
+  widget.p.orphan();
+}
+
+void pWindow::setBackgroundColor(Color color) {
+  GdkColor gdkColor = CreateColor(color.red, color.green, color.blue);
+  gtk_widget_modify_bg(widget, GTK_STATE_NORMAL, &gdkColor);
+}
+
+void pWindow::setDroppable(bool droppable) {
+  gtk_drag_dest_set(widget, GTK_DEST_DEFAULT_ALL, nullptr, 0, GDK_ACTION_COPY);
+  if(droppable) gtk_drag_dest_add_uri_targets(widget);
+}
+
+void pWindow::setFocused() {
+  gtk_window_present(GTK_WINDOW(widget));
+}
+
+void pWindow::setFullScreen(bool fullScreen) {
+  if(fullScreen == false) {
+    gtk_window_unfullscreen(GTK_WINDOW(widget));
+  } else {
+    gtk_window_fullscreen(GTK_WINDOW(widget));
+  /*unsigned monitor = gdk_screen_get_monitor_at_window(gdk_screen_get_default(), gtk_widget_get_window(widget));
+    GdkRectangle rectangle = {0};
+    gdk_screen_get_monitor_geometry(gdk_screen_get_default(), monitor, &rectangle);
+    gtk_window_set_decorated(GTK_WINDOW(widget), false);
+    gtk_window_move(GTK_WINDOW(widget), rectangle.x, rectangle.y);
+    gtk_window_resize(GTK_WINDOW(widget), rectangle.width, rectangle.height);
+    gtk_widget_set_size_request(formContainer, rectangle.width, rectangle.height);*/
+  }
+}
+
+void pWindow::setGeometry(Geometry geometry) {
+  Geometry margin = frameMargin();
+  gtk_window_move(GTK_WINDOW(widget), geometry.x - margin.x, geometry.y - margin.y);
+
+  GdkGeometry geom;
+  geom.min_width  = window.state.resizable ? 1 : window.state.geometry.width;
+  geom.min_height = window.state.resizable ? 1 : window.state.geometry.height;
+  gtk_window_set_geometry_hints(GTK_WINDOW(widget), GTK_WIDGET(widget), &geom, GDK_HINT_MIN_SIZE);
+
+//gtk_window_set_policy(GTK_WINDOW(widget), true, true, false);
+  gtk_widget_set_size_request(formContainer, geometry.width, geometry.height);
+  gtk_window_resize(GTK_WINDOW(widget), geometry.width, geometry.height + menuHeight() + statusHeight());
+
+  for(auto& layout : window.state.layout) {
+    Geometry layoutGeometry = geometry;
+    layoutGeometry.x = layoutGeometry.y = 0;
+    layout.setGeometry(layoutGeometry);
+  }
+}
+
+void pWindow::setMenuFont(string font) {
+  for(auto& item : window.state.menu) item.p.setFont(font);
+}
+
+void pWindow::setMenuVisible(bool visible) {
+  gtk_widget_set_visible(menu, visible);
+}
+
+void pWindow::setModal(bool modal) {
+  if(modal == true) {
+    gtk_window_set_modal(GTK_WINDOW(widget), true);
+    while(window.state.modal) {
+      Application::processEvents();
+      usleep(20 * 1000);
+    }
+    gtk_window_set_modal(GTK_WINDOW(widget), false);
+  }
+}
+
+void pWindow::setResizable(bool resizable) {
+  gtk_window_set_resizable(GTK_WINDOW(widget), resizable);
+  gtk_statusbar_set_has_resize_grip(GTK_STATUSBAR(status), resizable);
+}
+
+void pWindow::setStatusFont(string font) {
+  pFont::setFont(status, font);
+}
+
+void pWindow::setStatusText(string text) {
+  gtk_statusbar_pop(GTK_STATUSBAR(status), 1);
+  gtk_statusbar_push(GTK_STATUSBAR(status), 1, text);
+}
+
+void pWindow::setStatusVisible(bool visible) {
+  gtk_widget_set_visible(status, visible);
+}
+
+void pWindow::setTitle(string text) {
+  gtk_window_set_title(GTK_WINDOW(widget), text);
+}
+
+void pWindow::setVisible(bool visible) {
+  gtk_widget_set_visible(widget, visible);
+  if(visible) {
+    if(gtk_widget_get_visible(menu)) {
+      GtkAllocation allocation;
+      gtk_widget_get_allocation(menu, &allocation);
+      settings->geometry.menuHeight = allocation.height;
+    }
+
+    if(gtk_widget_get_visible(status)) {
+      GtkAllocation allocation;
+      gtk_widget_get_allocation(status, &allocation);
+      settings->geometry.statusHeight = allocation.height;
+    }
+  }
+}
+
+void pWindow::setWidgetFont(string font) {
+}
+
+void pWindow::constructor() {
+  lastAllocation.width  = 0;
+  lastAllocation.height = 0;
+  onSizePending = false;
+
+  widget = gtk_window_new(GTK_WINDOW_TOPLEVEL);
+
+  //if program was given a name, try and set the window taskbar icon from one of the pixmaps folders
+  if(applicationState.name.empty() == false) {
+    string filename = {"/usr/share/pixmaps/", applicationState.name, ".png"};
+    if(!file::exists(filename)) filename = {"/usr/local/share/pixmaps/", applicationState.name, ".png"};
+    if(file::exists(filename)) {
+      //maximum image size supported by GTK+ is 256x256; so we must scale larger images ourselves
+      nall::image icon(filename);
+      icon.scale(min(256u, icon.width), min(256u, icon.height), true);
+      GdkPixbuf* pixbuf = CreatePixbuf(icon);
+      gtk_window_set_icon(GTK_WINDOW(widget), pixbuf);
+      g_object_unref(G_OBJECT(pixbuf));
+    }
+  }
+
+  GdkColormap* colormap = gdk_screen_get_rgba_colormap(gdk_screen_get_default());
+  if(!colormap) colormap = gdk_screen_get_rgb_colormap(gdk_screen_get_default());
+  if(colormap) gtk_widget_set_colormap(widget, colormap);
+
+  gtk_window_set_resizable(GTK_WINDOW(widget), true);
+  #if GTK_MAJOR_VERSION >= 3
+  gtk_window_set_has_resize_grip(GTK_WINDOW(widget), false);
+  #endif
+
+  gtk_widget_set_app_paintable(widget, true);
+  gtk_widget_add_events(widget, GDK_CONFIGURE);
+
+  menuContainer = gtk_vbox_new(false, 0);
+  gtk_container_add(GTK_CONTAINER(widget), menuContainer);
+  gtk_widget_show(menuContainer);
+
+  menu = gtk_menu_bar_new();
+  gtk_box_pack_start(GTK_BOX(menuContainer), menu, false, false, 0);
+
+  formContainer = gtk_fixed_new();
+  gtk_box_pack_start(GTK_BOX(menuContainer), formContainer, true, true, 0);
+  gtk_widget_show(formContainer);
+
+  statusContainer = gtk_event_box_new();
+  status = gtk_statusbar_new();
+  gtk_statusbar_set_has_resize_grip(GTK_STATUSBAR(status), true);
+  gtk_container_add(GTK_CONTAINER(statusContainer), status);
+  gtk_box_pack_start(GTK_BOX(menuContainer), statusContainer, false, false, 0);
+  gtk_widget_show(statusContainer);
+
+  setTitle("");
+  setResizable(window.state.resizable);
+  setGeometry(window.state.geometry);
+  setMenuFont(Font::sans(8));
+  setStatusFont(Font::sans(8));
+
+  g_signal_connect(G_OBJECT(widget), "delete-event", G_CALLBACK(Window_close), (gpointer)&window);
+  g_signal_connect(G_OBJECT(widget), "expose-event", G_CALLBACK(Window_expose), (gpointer)&window);
+  g_signal_connect(G_OBJECT(widget), "configure-event", G_CALLBACK(Window_configure), (gpointer)&window);
+  g_signal_connect(G_OBJECT(widget), "drag-data-received", G_CALLBACK(Window_drop), (gpointer)&window);
+  g_signal_connect(G_OBJECT(widget), "key-press-event", G_CALLBACK(Window_keyPress), (gpointer)&window);
+  g_signal_connect(G_OBJECT(widget), "key-release-event", G_CALLBACK(Window_keyPress), (gpointer)&window);
+
+  g_signal_connect(G_OBJECT(formContainer), "size-allocate", G_CALLBACK(Window_sizeAllocate), (gpointer)&window);
+  g_signal_connect(G_OBJECT(formContainer), "size-request", G_CALLBACK(Window_sizeRequest), (gpointer)&window);
+
+  window.state.backgroundColor = Color(
+    (uint8_t)(settings->window.backgroundColor >> 16),
+    (uint8_t)(settings->window.backgroundColor >>  8),
+    (uint8_t)(settings->window.backgroundColor >>  0)
+  );
+}
+
+unsigned pWindow::menuHeight() {
+  return window.state.menuVisible ? settings->geometry.menuHeight : 0;
+}
+
+unsigned pWindow::statusHeight() {
+  return window.state.statusVisible ? settings->geometry.statusHeight : 0;
+}
+
+}
diff -Nru higan/phoenix/phoenix.cpp nSide/phoenix/phoenix.cpp
--- higan/phoenix/phoenix.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/phoenix.cpp	2015-09-16 13:08:13.544563367 +0900
@@ -0,0 +1,6 @@
+#ifndef PHOENIX_CPP
+#define PHOENIX_CPP
+
+#include "core/core.cpp"
+
+#endif
diff -Nru higan/phoenix/phoenix.hpp nSide/phoenix/phoenix.hpp
--- higan/phoenix/phoenix.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/phoenix.hpp	2015-09-16 13:08:13.558563368 +0900
@@ -0,0 +1,6 @@
+#ifndef PHOENIX_HPP
+#define PHOENIX_HPP
+
+#include "core/core.hpp"
+
+#endif
diff -Nru higan/phoenix/qt/action/action.cpp nSide/phoenix/qt/action/action.cpp
--- higan/phoenix/qt/action/action.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/qt/action/action.cpp	2015-09-16 13:08:13.545563367 +0900
@@ -0,0 +1,53 @@
+namespace phoenix {
+
+void pAction::setEnabled(bool enabled) {
+  if(dynamic_cast<Menu*>(&action)) {
+    ((Menu&)action).p.qtMenu->setEnabled(enabled);
+  } else if(dynamic_cast<Separator*>(&action)) {
+    ((Separator&)action).p.qtAction->setEnabled(enabled);
+  } else if(dynamic_cast<Item*>(&action)) {
+    ((Item&)action).p.qtAction->setEnabled(enabled);
+  } else if(dynamic_cast<CheckItem*>(&action)) {
+    ((CheckItem&)action).p.qtAction->setEnabled(enabled);
+  } else if(dynamic_cast<RadioItem*>(&action)) {
+    ((RadioItem&)action).p.qtAction->setEnabled(enabled);
+  }
+}
+
+void pAction::setFont(string font) {
+  QFont qtFont = pFont::create(font);
+
+  if(dynamic_cast<Menu*>(&action)) {
+    ((Menu&)action).p.setFont(font);
+  } else if(dynamic_cast<Separator*>(&action)) {
+    ((Separator&)action).p.qtAction->setFont(qtFont);
+  } else if(dynamic_cast<Item*>(&action)) {
+    ((Item&)action).p.qtAction->setFont(qtFont);
+  } else if(dynamic_cast<CheckItem*>(&action)) {
+    ((CheckItem&)action).p.qtAction->setFont(qtFont);
+  } else if(dynamic_cast<RadioItem*>(&action)) {
+    ((RadioItem&)action).p.qtAction->setFont(qtFont);
+  }
+}
+
+void pAction::setVisible(bool visible) {
+  if(dynamic_cast<Menu*>(&action)) {
+    ((Menu&)action).p.qtMenu->menuAction()->setVisible(visible);
+  } else if(dynamic_cast<Separator*>(&action)) {
+    ((Separator&)action).p.qtAction->setVisible(visible);
+  } else if(dynamic_cast<Item*>(&action)) {
+    ((Item&)action).p.qtAction->setVisible(visible);
+  } else if(dynamic_cast<CheckItem*>(&action)) {
+    ((CheckItem&)action).p.qtAction->setVisible(visible);
+  } else if(dynamic_cast<RadioItem*>(&action)) {
+    ((RadioItem&)action).p.qtAction->setVisible(visible);
+  }
+}
+
+void pAction::constructor() {
+}
+
+void pAction::destructor() {
+}
+
+}
diff -Nru higan/phoenix/qt/action/check-item.cpp nSide/phoenix/qt/action/check-item.cpp
--- higan/phoenix/qt/action/check-item.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/qt/action/check-item.cpp	2015-09-16 13:08:13.544563367 +0900
@@ -0,0 +1,28 @@
+namespace phoenix {
+
+void pCheckItem::setChecked(bool checked) {
+  qtAction->setChecked(checked);
+}
+
+void pCheckItem::setText(string text) {
+  qtAction->setText(QString::fromUtf8(text));
+}
+
+void pCheckItem::constructor() {
+  qtAction = new QAction(0);
+  qtAction->setCheckable(true);
+  connect(qtAction, SIGNAL(triggered()), SLOT(onToggle()));
+}
+
+void pCheckItem::destructor() {
+  if(action.state.menu) action.state.menu->remove(checkItem);
+  delete qtAction;
+  qtAction = nullptr;
+}
+
+void pCheckItem::onToggle() {
+  checkItem.state.checked = qtAction->isChecked();
+  if(checkItem.onToggle) checkItem.onToggle();
+}
+
+}
diff -Nru higan/phoenix/qt/action/item.cpp nSide/phoenix/qt/action/item.cpp
--- higan/phoenix/qt/action/item.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/qt/action/item.cpp	2015-09-16 13:08:13.545563367 +0900
@@ -0,0 +1,26 @@
+namespace phoenix {
+
+void pItem::setImage(const image& image) {
+  qtAction->setIcon(CreateIcon(image));
+}
+
+void pItem::setText(string text) {
+  qtAction->setText(QString::fromUtf8(text));
+}
+
+void pItem::constructor() {
+  qtAction = new QAction(0);
+  connect(qtAction, SIGNAL(triggered()), SLOT(onActivate()));
+}
+
+void pItem::destructor() {
+  if(action.state.menu) action.state.menu->remove(item);
+  delete qtAction;
+  qtAction = nullptr;
+}
+
+void pItem::onActivate() {
+  if(item.onActivate) item.onActivate();
+}
+
+}
diff -Nru higan/phoenix/qt/action/menu.cpp nSide/phoenix/qt/action/menu.cpp
--- higan/phoenix/qt/action/menu.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/qt/action/menu.cpp	2015-09-16 13:08:13.545563367 +0900
@@ -0,0 +1,56 @@
+namespace phoenix {
+
+void pMenu::append(Action& action) {
+  if(dynamic_cast<Menu*>(&action)) {
+    qtMenu->addMenu(((Menu&)action).p.qtMenu);
+  } else if(dynamic_cast<Separator*>(&action)) {
+    qtMenu->addAction(((Separator&)action).p.qtAction);
+  } else if(dynamic_cast<Item*>(&action)) {
+    qtMenu->addAction(((Item&)action).p.qtAction);
+  } else if(dynamic_cast<CheckItem*>(&action)) {
+    qtMenu->addAction(((CheckItem&)action).p.qtAction);
+  } else if(dynamic_cast<RadioItem*>(&action)) {
+    qtMenu->addAction(((RadioItem&)action).p.qtAction);
+  }
+}
+
+void pMenu::remove(Action& action) {
+  if(dynamic_cast<Menu*>(&action)) {
+    //QMenu::removeMenu() does not exist
+    qtMenu->clear();
+    for(auto& action : menu.state.action) append(action);
+  } else if(dynamic_cast<Separator*>(&action)) {
+    qtMenu->removeAction(((Separator&)action).p.qtAction);
+  } else if(dynamic_cast<Item*>(&action)) {
+    qtMenu->removeAction(((Item&)action).p.qtAction);
+  } else if(dynamic_cast<CheckItem*>(&action)) {
+    qtMenu->removeAction(((CheckItem&)action).p.qtAction);
+  } else if(dynamic_cast<RadioItem*>(&action)) {
+    qtMenu->removeAction(((CheckItem&)action).p.qtAction);
+  }
+}
+
+void pMenu::setFont(string font) {
+  qtMenu->setFont(pFont::create(font));
+  for(auto &item : menu.state.action) item.p.setFont(font);
+}
+
+void pMenu::setImage(const image& image) {
+  qtMenu->setIcon(CreateIcon(image));
+}
+
+void pMenu::setText(string text) {
+  qtMenu->setTitle(QString::fromUtf8(text));
+}
+
+void pMenu::constructor() {
+  qtMenu = new QMenu;
+}
+
+void pMenu::destructor() {
+  if(action.state.menu) action.state.menu->remove(menu);
+  delete qtMenu;
+  qtMenu = nullptr;
+}
+
+}
diff -Nru higan/phoenix/qt/action/radio-item.cpp nSide/phoenix/qt/action/radio-item.cpp
--- higan/phoenix/qt/action/radio-item.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/qt/action/radio-item.cpp	2015-09-16 13:08:13.544563367 +0900
@@ -0,0 +1,42 @@
+namespace phoenix {
+
+void pRadioItem::setChecked() {
+  lock();
+  for(auto& item : radioItem.state.group) {
+    bool checkState = item.p.qtAction == qtAction;
+    item.state.checked = checkState;
+    item.p.qtAction->setChecked(checkState);
+  }
+  unlock();
+}
+
+void pRadioItem::setGroup(const group<RadioItem>& group) {
+}
+
+void pRadioItem::setText(string text) {
+  qtAction->setText(QString::fromUtf8(text));
+}
+
+void pRadioItem::constructor() {
+  qtAction = new QAction(0);
+  qtGroup = new QActionGroup(0);
+  qtAction->setCheckable(true);
+  qtAction->setActionGroup(qtGroup);
+  qtAction->setChecked(true);
+  connect(qtAction, SIGNAL(triggered()), SLOT(onActivate()));
+}
+
+void pRadioItem::destructor() {
+  if(action.state.menu) action.state.menu->remove(radioItem);
+  delete qtAction;
+  qtAction = nullptr;
+}
+
+void pRadioItem::onActivate() {
+  if(!radioItem.state.checked) {
+    setChecked();
+    if(!locked() && radioItem.onActivate) radioItem.onActivate();
+  }
+}
+
+}
diff -Nru higan/phoenix/qt/action/separator.cpp nSide/phoenix/qt/action/separator.cpp
--- higan/phoenix/qt/action/separator.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/qt/action/separator.cpp	2015-09-16 13:08:13.544563367 +0900
@@ -0,0 +1,14 @@
+namespace phoenix {
+
+void pSeparator::constructor() {
+  qtAction = new QAction(0);
+  qtAction->setSeparator(true);
+}
+
+void pSeparator::destructor() {
+  if(action.state.menu) action.state.menu->remove(separator);
+  delete qtAction;
+  qtAction = nullptr;
+}
+
+}
diff -Nru higan/phoenix/qt/application.cpp nSide/phoenix/qt/application.cpp
--- higan/phoenix/qt/application.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/qt/application.cpp	2015-09-16 13:08:13.552563368 +0900
@@ -0,0 +1,54 @@
+namespace phoenix {
+
+XlibDisplay* pApplication::display = nullptr;
+
+void pApplication::run() {
+  if(Application::main) {
+    while(applicationState.quit == false) {
+      processEvents();
+      Application::main();
+    }
+  } else {
+    QApplication::exec();
+  }
+}
+
+bool pApplication::pendingEvents() {
+  return QApplication::hasPendingEvents();
+}
+
+void pApplication::processEvents() {
+  while(pendingEvents()) QApplication::processEvents();
+}
+
+void pApplication::quit() {
+  QApplication::quit();
+  //note: QApplication cannot be deleted; or libQtGui will crash
+  qtApplication = nullptr;
+}
+
+void pApplication::syncX() {
+  for(unsigned n = 0; n < 8; n++) {
+    QApplication::syncX();
+    Application::processEvents();
+    usleep(2000);
+  }
+}
+
+void pApplication::initialize() {
+  display = XOpenDisplay(0);
+
+  settings = new Settings;
+  settings->load();
+
+  static int argc = 1;
+  static char* argv[] = {new char[8], nullptr};
+  strcpy(argv[0], "phoenix");
+  char** argvp = argv;
+
+  qtApplication = new QApplication(argc, argvp);
+
+  pKeyboard::initialize();
+}
+
+}
diff -Nru higan/phoenix/qt/browser-window.cpp nSide/phoenix/qt/browser-window.cpp
--- higan/phoenix/qt/browser-window.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/qt/browser-window.cpp	2015-09-16 13:08:13.557563368 +0900
@@ -0,0 +1,54 @@
+namespace phoenix {
+
+string pBrowserWindow::directory(BrowserWindow::State& state) {
+  QString directory = QFileDialog::getExistingDirectory(
+    state.parent ? state.parent->p.qtWindow : nullptr,
+    state.title ? state.title : "Select Directory",
+    QString::fromUtf8(state.path), QFileDialog::ShowDirsOnly | QFileDialog::DontResolveSymlinks
+  );
+  string name = directory.toUtf8().constData();
+  if(name && name.endsWith("/") == false) name.append("/");
+  return name;
+}
+
+string pBrowserWindow::open(BrowserWindow::State& state) {
+  string filters = state.filters.merge(";;");
+
+  //convert filter list from phoenix to Qt format, example:
+  //"Text, XML files (*.txt,*.xml)" -> "Text, XML files (*.txt *.xml)"
+  signed parentheses = 0;
+  for(auto& n : filters) {
+    if(n == '(') parentheses++;
+    if(n == ')') parentheses--;
+    if(n == ',' && parentheses) n = ' ';
+  }
+
+  QString filename = QFileDialog::getOpenFileName(
+    state.parent ? state.parent->p.qtWindow : nullptr,
+    state.title ? state.title : "Open File",
+    QString::fromUtf8(state.path), QString::fromUtf8(filters)
+  );
+  return filename.toUtf8().constData();
+}
+
+string pBrowserWindow::save(BrowserWindow::State& state) {
+  string filters = state.filters.merge(";;");
+
+  //convert filter list from phoenix to Qt format, example:
+  //"Text, XML files (*.txt,*.xml)" -> "Text, XML files (*.txt *.xml)"
+  signed parentheses = 0;
+  for(auto& n : filters) {
+    if(n == '(') parentheses++;
+    if(n == ')') parentheses--;
+    if(n == ',' && parentheses) n = ' ';
+  }
+
+  QString filename = QFileDialog::getSaveFileName(
+    state.parent ? state.parent->p.qtWindow : nullptr,
+    state.title ? state.title : "Save File",
+    QString::fromUtf8(state.path), QString::fromUtf8(filters)
+  );
+  return filename.toUtf8().constData();
+}
+
+}
diff -Nru higan/phoenix/qt/desktop.cpp nSide/phoenix/qt/desktop.cpp
--- higan/phoenix/qt/desktop.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/qt/desktop.cpp	2015-09-16 13:08:13.544563367 +0900
@@ -0,0 +1,13 @@
+namespace phoenix {
+
+Size pDesktop::size() {
+  QRect rect = QApplication::desktop()->screenGeometry();
+  return {rect.width(), rect.height()};
+}
+
+Geometry pDesktop::workspace() {
+  QRect rect = QApplication::desktop()->availableGeometry();
+  return {rect.x(), rect.y(), rect.width(), rect.height()};
+}
+
+}
diff -Nru higan/phoenix/qt/font.cpp nSide/phoenix/qt/font.cpp
--- higan/phoenix/qt/font.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/qt/font.cpp	2015-09-16 13:08:13.550563367 +0900
@@ -0,0 +1,60 @@
+namespace phoenix {
+
+string pFont::serif(unsigned size, string style) {
+  if(size == 0) size = 8;
+  if(style == "") style = "Normal";
+  return {"Serif, ", size, ", ", style};
+}
+
+string pFont::sans(unsigned size, string style) {
+  if(size == 0) size = 8;
+  if(style == "") style = "Normal";
+  return {"Sans, ", size, ", ", style};
+}
+
+string pFont::monospace(unsigned size, string style) {
+  if(size == 0) size = 8;
+  if(style == "") style = "Normal";
+  return {"Liberation Mono, ", size, ", ", style};
+}
+
+Size pFont::size(string font, string text) {
+  return pFont::size(pFont::create(font), text);
+}
+
+QFont pFont::create(string description) {
+  lstring part = description.split(",", 2L).strip();
+
+  string family = "Sans";
+  unsigned size = 8u;
+  bool bold = false;
+  bool italic = false;
+
+  if(part[0] != "") family = part[0];
+  if(part.size() >= 2) size = decimal(part[1]);
+  if(part.size() >= 3) bold = (bool)part[2].find("Bold");
+  if(part.size() >= 3) italic = (bool)part[2].find("Italic");
+
+  QFont qtFont;
+  qtFont.setFamily(family);
+  qtFont.setPointSize(size);
+  if(bold) qtFont.setBold(true);
+  if(italic) qtFont.setItalic(true);
+  return qtFont;
+}
+
+Size pFont::size(const QFont& qtFont, string text) {
+  QFontMetrics metrics(qtFont);
+
+  lstring lines;
+  lines.split("\n", text);
+
+  unsigned maxWidth = 0;
+  for(auto& line : lines) {
+    maxWidth = max(maxWidth, metrics.width(line));
+  }
+
+  return {maxWidth, metrics.height() * lines.size()};
+}
+
+}
diff -Nru higan/phoenix/qt/header.hpp nSide/phoenix/qt/header.hpp
--- higan/phoenix/qt/header.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/qt/header.hpp	2015-09-16 13:08:13.552563368 +0900
@@ -0,0 +1,16 @@
+#include <QApplication>
+#include <QtGui>
+#include <nall/xorg/guard.hpp>
+#define XK_MISCELLANY
+#define XK_LATIN1
+#include <X11/Xlib.h>
+#include <X11/keysymdef.h>
+#undef XK_MISCELLANY
+#undef XK_LATIN1
+#include <nall/xorg/guard.hpp>
+
+//Qt 4.8.0 and earlier improperly define the QLOCATION macro
+//in C++11, it is detected as a malformed user-defined literal
+//below is a workaround to fix compilation errors caused by this
+#undef  QLOCATION
+#define QLOCATION "\0" __FILE__ ":" QTOSTRING(__LINE__)
diff -Nru higan/phoenix/qt/keyboard.cpp nSide/phoenix/qt/keyboard.cpp
--- higan/phoenix/qt/keyboard.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/qt/keyboard.cpp	2015-09-16 13:08:13.553563368 +0900
@@ -0,0 +1,149 @@
+namespace phoenix {
+
+void pKeyboard::initialize() {
+  auto append = [](Keyboard::Scancode scancode, unsigned keysym) {
+    settings->keymap.insert(scancode, XKeysymToKeycode(pApplication::display, keysym));
+  };
+
+  append(Keyboard::Scancode::Escape, XK_Escape);
+  append(Keyboard::Scancode::F1, XK_F1);
+  append(Keyboard::Scancode::F2, XK_F2);
+  append(Keyboard::Scancode::F3, XK_F3);
+  append(Keyboard::Scancode::F4, XK_F4);
+  append(Keyboard::Scancode::F5, XK_F5);
+  append(Keyboard::Scancode::F6, XK_F6);
+  append(Keyboard::Scancode::F7, XK_F7);
+  append(Keyboard::Scancode::F8, XK_F8);
+  append(Keyboard::Scancode::F9, XK_F9);
+  append(Keyboard::Scancode::F10, XK_F10);
+  append(Keyboard::Scancode::F11, XK_F11);
+  append(Keyboard::Scancode::F12, XK_F12);
+
+  append(Keyboard::Scancode::PrintScreen, XK_Print);
+  append(Keyboard::Scancode::ScrollLock, XK_Scroll_Lock);
+  append(Keyboard::Scancode::Pause, XK_Pause);
+
+  append(Keyboard::Scancode::Insert, XK_Insert);
+  append(Keyboard::Scancode::Delete, XK_Delete);
+  append(Keyboard::Scancode::Home, XK_Home);
+  append(Keyboard::Scancode::End, XK_End);
+  append(Keyboard::Scancode::PageUp, XK_Prior);
+  append(Keyboard::Scancode::PageDown, XK_Next);
+
+  append(Keyboard::Scancode::Up, XK_Up);
+  append(Keyboard::Scancode::Down, XK_Down);
+  append(Keyboard::Scancode::Left, XK_Left);
+  append(Keyboard::Scancode::Right, XK_Right);
+
+  append(Keyboard::Scancode::Grave, XK_asciitilde);
+  append(Keyboard::Scancode::Number1, XK_1);
+  append(Keyboard::Scancode::Number2, XK_2);
+  append(Keyboard::Scancode::Number3, XK_3);
+  append(Keyboard::Scancode::Number4, XK_4);
+  append(Keyboard::Scancode::Number5, XK_5);
+  append(Keyboard::Scancode::Number6, XK_6);
+  append(Keyboard::Scancode::Number7, XK_7);
+  append(Keyboard::Scancode::Number8, XK_8);
+  append(Keyboard::Scancode::Number9, XK_9);
+  append(Keyboard::Scancode::Number0, XK_0);
+  append(Keyboard::Scancode::Minus, XK_minus);
+  append(Keyboard::Scancode::Equal, XK_equal);
+  append(Keyboard::Scancode::Backspace, XK_BackSpace);
+
+  append(Keyboard::Scancode::BracketLeft, XK_bracketleft);
+  append(Keyboard::Scancode::BracketRight, XK_bracketright);
+  append(Keyboard::Scancode::Backslash, XK_backslash);
+  append(Keyboard::Scancode::Semicolon, XK_semicolon);
+  append(Keyboard::Scancode::Apostrophe, XK_apostrophe);
+  append(Keyboard::Scancode::Comma, XK_comma);
+  append(Keyboard::Scancode::Period, XK_period);
+  append(Keyboard::Scancode::Slash, XK_slash);
+
+  append(Keyboard::Scancode::Tab, XK_Tab);
+  append(Keyboard::Scancode::CapsLock, XK_Caps_Lock);
+  append(Keyboard::Scancode::Return, XK_Return);
+  append(Keyboard::Scancode::ShiftLeft, XK_Shift_L);
+  append(Keyboard::Scancode::ShiftRight, XK_Shift_R);
+  append(Keyboard::Scancode::ControlLeft, XK_Control_L);
+  append(Keyboard::Scancode::ControlRight, XK_Control_R);
+  append(Keyboard::Scancode::SuperLeft, XK_Super_L);
+  append(Keyboard::Scancode::SuperRight, XK_Super_R);
+  append(Keyboard::Scancode::AltLeft, XK_Alt_L);
+  append(Keyboard::Scancode::AltRight, XK_Alt_R);
+  append(Keyboard::Scancode::Space, XK_space);
+  append(Keyboard::Scancode::Menu, XK_Menu);
+
+  append(Keyboard::Scancode::A, XK_A);
+  append(Keyboard::Scancode::B, XK_B);
+  append(Keyboard::Scancode::C, XK_C);
+  append(Keyboard::Scancode::D, XK_D);
+  append(Keyboard::Scancode::E, XK_E);
+  append(Keyboard::Scancode::F, XK_F);
+  append(Keyboard::Scancode::G, XK_G);
+  append(Keyboard::Scancode::H, XK_H);
+  append(Keyboard::Scancode::I, XK_I);
+  append(Keyboard::Scancode::J, XK_J);
+  append(Keyboard::Scancode::K, XK_K);
+  append(Keyboard::Scancode::L, XK_L);
+  append(Keyboard::Scancode::M, XK_M);
+  append(Keyboard::Scancode::N, XK_N);
+  append(Keyboard::Scancode::O, XK_O);
+  append(Keyboard::Scancode::P, XK_P);
+  append(Keyboard::Scancode::Q, XK_Q);
+  append(Keyboard::Scancode::R, XK_R);
+  append(Keyboard::Scancode::S, XK_S);
+  append(Keyboard::Scancode::T, XK_T);
+  append(Keyboard::Scancode::U, XK_U);
+  append(Keyboard::Scancode::V, XK_V);
+  append(Keyboard::Scancode::W, XK_W);
+  append(Keyboard::Scancode::X, XK_X);
+  append(Keyboard::Scancode::Y, XK_Y);
+  append(Keyboard::Scancode::Z, XK_Z);
+
+  append(Keyboard::Scancode::NumLock, XK_Num_Lock);
+  append(Keyboard::Scancode::Divide, XK_KP_Divide);
+  append(Keyboard::Scancode::Multiply, XK_KP_Multiply);
+  append(Keyboard::Scancode::Subtract, XK_KP_Subtract);
+  append(Keyboard::Scancode::Add, XK_KP_Add);
+  append(Keyboard::Scancode::Enter, XK_KP_Enter);
+  append(Keyboard::Scancode::Point, XK_KP_Decimal);
+
+  append(Keyboard::Scancode::Keypad1, XK_KP_1);
+  append(Keyboard::Scancode::Keypad2, XK_KP_2);
+  append(Keyboard::Scancode::Keypad3, XK_KP_3);
+  append(Keyboard::Scancode::Keypad4, XK_KP_4);
+  append(Keyboard::Scancode::Keypad5, XK_KP_5);
+  append(Keyboard::Scancode::Keypad6, XK_KP_6);
+  append(Keyboard::Scancode::Keypad7, XK_KP_7);
+  append(Keyboard::Scancode::Keypad8, XK_KP_8);
+  append(Keyboard::Scancode::Keypad9, XK_KP_9);
+  append(Keyboard::Scancode::Keypad0, XK_KP_0);
+}
+
+bool pKeyboard::pressed(Keyboard::Scancode scancode) {
+  char state[256];
+  XQueryKeymap(pApplication::display, state);
+  if(auto result = settings->keymap.find(scancode)) {
+    unsigned id = result();
+    return state[id >> 3] & (1 << (id & 7));
+  }
+  return false;
+}
+
+vector<bool> pKeyboard::state() {
+  vector<bool> output;
+  output.resize((unsigned)Keyboard::Scancode::Limit);
+  for(auto& n : output) n = false;
+
+  char state[256];
+  XQueryKeymap(pApplication::display, state);
+  for(auto node : settings->keymap) {
+    if(state[node.value >> 3] & (1 << (node.value & 7))) {
+      output[(unsigned)node.key] = true;
+    }
+  }
+
+  return output;
+}
+
+}
diff -Nru higan/phoenix/qt/message-window.cpp nSide/phoenix/qt/message-window.cpp
--- higan/phoenix/qt/message-window.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/qt/message-window.cpp	2015-09-16 13:08:13.550563367 +0900
@@ -0,0 +1,55 @@
+namespace phoenix {
+
+static QMessageBox::StandardButtons MessageWindow_buttons(MessageWindow::Buttons buttons) {
+  QMessageBox::StandardButtons standardButtons = QMessageBox::NoButton;
+  if(buttons == MessageWindow::Buttons::Ok) standardButtons = QMessageBox::Ok;
+  if(buttons == MessageWindow::Buttons::OkCancel) standardButtons = QMessageBox::Ok | QMessageBox::Cancel;
+  if(buttons == MessageWindow::Buttons::YesNo) standardButtons = QMessageBox::Yes | QMessageBox::No;
+  if(buttons == MessageWindow::Buttons::YesNoCancel) standardButtons = QMessageBox::Yes | QMessageBox::No | QMessageBox::Cancel;
+  return standardButtons;
+}
+
+static MessageWindow::Response MessageWindow_response(MessageWindow::Buttons buttons, QMessageBox::StandardButton response) {
+  if(response == QMessageBox::Ok) return MessageWindow::Response::Ok;
+  if(response == QMessageBox::Cancel) return MessageWindow::Response::Cancel;
+  if(response == QMessageBox::Yes) return MessageWindow::Response::Yes;
+  if(response == QMessageBox::No) return MessageWindow::Response::No;
+
+  //MessageWindow was closed via window manager, rather than by a button; assume a cancel/no response
+  if(buttons == MessageWindow::Buttons::Ok) return MessageWindow::Response::Ok;
+  if(buttons == MessageWindow::Buttons::OkCancel) return MessageWindow::Response::Cancel;
+  if(buttons == MessageWindow::Buttons::YesNo) return MessageWindow::Response::No;
+  if(buttons == MessageWindow::Buttons::YesNoCancel) return MessageWindow::Response::Cancel;
+
+  throw;
+}
+
+MessageWindow::Response pMessageWindow::error(MessageWindow::State& state) {
+  return MessageWindow_response(
+    state.buttons, QMessageBox::critical(state.parent ? state.parent->p.qtWindow : nullptr, state.title ? state.title : " ",
+    QString::fromUtf8(state.text), MessageWindow_buttons(state.buttons))
+  );
+}
+
+MessageWindow::Response pMessageWindow::information(MessageWindow::State& state) {
+  return MessageWindow_response(
+    state.buttons, QMessageBox::information(state.parent ? state.parent->p.qtWindow : nullptr, state.title ? state.title : " ",
+    QString::fromUtf8(state.text), MessageWindow_buttons(state.buttons))
+  );
+}
+
+MessageWindow::Response pMessageWindow::question(MessageWindow::State& state) {
+  return MessageWindow_response(
+    state.buttons, QMessageBox::question(state.parent ? state.parent->p.qtWindow : nullptr, state.title ? state.title : " ",
+    QString::fromUtf8(state.text), MessageWindow_buttons(state.buttons))
+  );
+}
+
+MessageWindow::Response pMessageWindow::warning(MessageWindow::State& state) {
+  return MessageWindow_response(
+    state.buttons, QMessageBox::warning(state.parent ? state.parent->p.qtWindow : nullptr, state.title ? state.title : " ",
+    QString::fromUtf8(state.text), MessageWindow_buttons(state.buttons))
+  );
+}
+
+}
diff -Nru higan/phoenix/qt/monitor.cpp nSide/phoenix/qt/monitor.cpp
--- higan/phoenix/qt/monitor.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/qt/monitor.cpp	2015-09-16 13:08:13.558563368 +0900
@@ -0,0 +1,16 @@
+namespace phoenix {
+
+unsigned pMonitor::count() {
+  return QApplication::desktop()->screenCount();
+}
+
+Geometry pMonitor::geometry(unsigned monitor) {
+  QRect rectangle = QApplication::desktop()->screenGeometry(monitor);
+  return {rectangle.x(), rectangle.y(), rectangle.width(), rectangle.height()};
+}
+
+unsigned pMonitor::primary() {
+  return QApplication::desktop()->primaryScreen();
+}
+
+}
diff -Nru higan/phoenix/qt/mouse.cpp nSide/phoenix/qt/mouse.cpp
--- higan/phoenix/qt/mouse.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/qt/mouse.cpp	2015-09-16 13:08:13.552563368 +0900
@@ -0,0 +1,18 @@
+namespace phoenix {
+
+Position pMouse::position() {
+  QPoint point = QCursor::pos();
+  return {point.x(), point.y()};
+}
+
+bool pMouse::pressed(Mouse::Button button) {
+  Qt::MouseButtons buttons = QApplication::mouseButtons();
+  switch(button) {
+  case Mouse::Button::Left: return buttons & Qt::LeftButton;
+  case Mouse::Button::Middle: return buttons & Qt::MidButton;
+  case Mouse::Button::Right: return buttons & Qt::RightButton;
+  }
+  return false;
+}
+
+}
diff -Nru higan/phoenix/qt/platform.cpp nSide/phoenix/qt/platform.cpp
--- higan/phoenix/qt/platform.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/qt/platform.cpp	2015-09-16 13:08:13.557563368 +0900
@@ -0,0 +1,49 @@
+#include "platform.moc.hpp"
+#include "platform.moc"
+
+#include "utility.cpp"
+#include "settings.cpp"
+
+#include "desktop.cpp"
+#include "monitor.cpp"
+#include "keyboard.cpp"
+#include "mouse.cpp"
+#include "browser-window.cpp"
+#include "message-window.cpp"
+#include "font.cpp"
+#include "timer.cpp"
+#include "window.cpp"
+#include "popup-menu.cpp"
+
+#include "action/action.cpp"
+#include "action/menu.cpp"
+#include "action/separator.cpp"
+#include "action/item.cpp"
+#include "action/check-item.cpp"
+#include "action/radio-item.cpp"
+
+#include "widget/widget.cpp"
+#include "widget/button.cpp"
+#include "widget/canvas.cpp"
+#include "widget/check-button.cpp"
+#include "widget/check-label.cpp"
+#include "widget/combo-button.cpp"
+#include "widget/console.cpp"
+#include "widget/frame.cpp"
+#include "widget/hex-edit.cpp"
+#include "widget/horizontal-scroller.cpp"
+#include "widget/horizontal-slider.cpp"
+#include "widget/icon-view.cpp"
+#include "widget/label.cpp"
+#include "widget/line-edit.cpp"
+#include "widget/list-view.cpp"
+#include "widget/progress-bar.cpp"
+#include "widget/radio-button.cpp"
+#include "widget/radio-label.cpp"
+#include "widget/tab-frame.cpp"
+#include "widget/text-edit.cpp"
+#include "widget/vertical-scroller.cpp"
+#include "widget/vertical-slider.cpp"
+#include "widget/viewport.cpp"
+
+#include "application.cpp"
diff -Nru higan/phoenix/qt/platform.moc nSide/phoenix/qt/platform.moc
--- higan/phoenix/qt/platform.moc	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/qt/platform.moc	2015-09-16 13:08:13.557563368 +0900
@@ -0,0 +1,1816 @@
+/****************************************************************************
+** Meta object code from reading C++ file 'platform.moc.hpp'
+**
+** Created by: The Qt Meta Object Compiler version 63 (Qt 4.8.5)
+**
+** WARNING! All changes made in this file will be lost!
+*****************************************************************************/
+
+#if !defined(Q_MOC_OUTPUT_REVISION)
+#error "The header file 'platform.moc.hpp' doesn't include <QObject>."
+#elif Q_MOC_OUTPUT_REVISION != 63
+#error "This file was generated using the moc from 4.8.5. It"
+#error "cannot be used with the include files from this version of Qt."
+#error "(The moc has changed too much.)"
+#endif
+
+QT_BEGIN_MOC_NAMESPACE
+static const uint qt_meta_data_phoenix__pTimer[] = {
+
+ // content:
+       6,       // revision
+       0,       // classname
+       0,    0, // classinfo
+       1,   14, // methods
+       0,    0, // properties
+       0,    0, // enums/sets
+       0,    0, // constructors
+       0,       // flags
+       0,       // signalCount
+
+ // slots: signature, parameters, type, tag, flags
+      16,   29,   29,   29, 0x0a,
+
+       0        // eod
+};
+
+static const char qt_meta_stringdata_phoenix__pTimer[] = {
+    "phoenix::pTimer\0onActivate()\0\0"
+};
+
+void phoenix::pTimer::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
+{
+    if (_c == QMetaObject::InvokeMetaMethod) {
+        Q_ASSERT(staticMetaObject.cast(_o));
+        pTimer *_t = static_cast<pTimer *>(_o);
+        switch (_id) {
+        case 0: _t->onActivate(); break;
+        default: ;
+        }
+    }
+    Q_UNUSED(_a);
+}
+
+const QMetaObjectExtraData phoenix::pTimer::staticMetaObjectExtraData = {
+    0,  qt_static_metacall 
+};
+
+const QMetaObject phoenix::pTimer::staticMetaObject = {
+    { &QObject::staticMetaObject, qt_meta_stringdata_phoenix__pTimer,
+      qt_meta_data_phoenix__pTimer, &staticMetaObjectExtraData }
+};
+
+#ifdef Q_NO_DATA_RELOCATION
+const QMetaObject &phoenix::pTimer::getStaticMetaObject() { return staticMetaObject; }
+#endif //Q_NO_DATA_RELOCATION
+
+const QMetaObject *phoenix::pTimer::metaObject() const
+{
+    return QObject::d_ptr->metaObject ? QObject::d_ptr->metaObject : &staticMetaObject;
+}
+
+void *phoenix::pTimer::qt_metacast(const char *_clname)
+{
+    if (!_clname) return 0;
+    if (!strcmp(_clname, qt_meta_stringdata_phoenix__pTimer))
+        return static_cast<void*>(const_cast< pTimer*>(this));
+    if (!strcmp(_clname, "pObject"))
+        return static_cast< pObject*>(const_cast< pTimer*>(this));
+    return QObject::qt_metacast(_clname);
+}
+
+int phoenix::pTimer::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
+{
+    _id = QObject::qt_metacall(_c, _id, _a);
+    if (_id < 0)
+        return _id;
+    if (_c == QMetaObject::InvokeMetaMethod) {
+        if (_id < 1)
+            qt_static_metacall(this, _c, _id, _a);
+        _id -= 1;
+    }
+    return _id;
+}
+static const uint qt_meta_data_phoenix__pWindow[] = {
+
+ // content:
+       6,       // revision
+       0,       // classname
+       0,    0, // classinfo
+       0,    0, // methods
+       0,    0, // properties
+       0,    0, // enums/sets
+       0,    0, // constructors
+       0,       // flags
+       0,       // signalCount
+
+       0        // eod
+};
+
+static const char qt_meta_stringdata_phoenix__pWindow[] = {
+    "phoenix::pWindow\0"
+};
+
+void phoenix::pWindow::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
+{
+    Q_UNUSED(_o);
+    Q_UNUSED(_id);
+    Q_UNUSED(_c);
+    Q_UNUSED(_a);
+}
+
+const QMetaObjectExtraData phoenix::pWindow::staticMetaObjectExtraData = {
+    0,  qt_static_metacall 
+};
+
+const QMetaObject phoenix::pWindow::staticMetaObject = {
+    { &QObject::staticMetaObject, qt_meta_stringdata_phoenix__pWindow,
+      qt_meta_data_phoenix__pWindow, &staticMetaObjectExtraData }
+};
+
+#ifdef Q_NO_DATA_RELOCATION
+const QMetaObject &phoenix::pWindow::getStaticMetaObject() { return staticMetaObject; }
+#endif //Q_NO_DATA_RELOCATION
+
+const QMetaObject *phoenix::pWindow::metaObject() const
+{
+    return QObject::d_ptr->metaObject ? QObject::d_ptr->metaObject : &staticMetaObject;
+}
+
+void *phoenix::pWindow::qt_metacast(const char *_clname)
+{
+    if (!_clname) return 0;
+    if (!strcmp(_clname, qt_meta_stringdata_phoenix__pWindow))
+        return static_cast<void*>(const_cast< pWindow*>(this));
+    if (!strcmp(_clname, "pObject"))
+        return static_cast< pObject*>(const_cast< pWindow*>(this));
+    return QObject::qt_metacast(_clname);
+}
+
+int phoenix::pWindow::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
+{
+    _id = QObject::qt_metacall(_c, _id, _a);
+    if (_id < 0)
+        return _id;
+    return _id;
+}
+static const uint qt_meta_data_phoenix__pItem[] = {
+
+ // content:
+       6,       // revision
+       0,       // classname
+       0,    0, // classinfo
+       1,   14, // methods
+       0,    0, // properties
+       0,    0, // enums/sets
+       0,    0, // constructors
+       0,       // flags
+       0,       // signalCount
+
+ // slots: signature, parameters, type, tag, flags
+      15,   28,   28,   28, 0x0a,
+
+       0        // eod
+};
+
+static const char qt_meta_stringdata_phoenix__pItem[] = {
+    "phoenix::pItem\0onActivate()\0\0"
+};
+
+void phoenix::pItem::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
+{
+    if (_c == QMetaObject::InvokeMetaMethod) {
+        Q_ASSERT(staticMetaObject.cast(_o));
+        pItem *_t = static_cast<pItem *>(_o);
+        switch (_id) {
+        case 0: _t->onActivate(); break;
+        default: ;
+        }
+    }
+    Q_UNUSED(_a);
+}
+
+const QMetaObjectExtraData phoenix::pItem::staticMetaObjectExtraData = {
+    0,  qt_static_metacall 
+};
+
+const QMetaObject phoenix::pItem::staticMetaObject = {
+    { &QObject::staticMetaObject, qt_meta_stringdata_phoenix__pItem,
+      qt_meta_data_phoenix__pItem, &staticMetaObjectExtraData }
+};
+
+#ifdef Q_NO_DATA_RELOCATION
+const QMetaObject &phoenix::pItem::getStaticMetaObject() { return staticMetaObject; }
+#endif //Q_NO_DATA_RELOCATION
+
+const QMetaObject *phoenix::pItem::metaObject() const
+{
+    return QObject::d_ptr->metaObject ? QObject::d_ptr->metaObject : &staticMetaObject;
+}
+
+void *phoenix::pItem::qt_metacast(const char *_clname)
+{
+    if (!_clname) return 0;
+    if (!strcmp(_clname, qt_meta_stringdata_phoenix__pItem))
+        return static_cast<void*>(const_cast< pItem*>(this));
+    if (!strcmp(_clname, "pAction"))
+        return static_cast< pAction*>(const_cast< pItem*>(this));
+    return QObject::qt_metacast(_clname);
+}
+
+int phoenix::pItem::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
+{
+    _id = QObject::qt_metacall(_c, _id, _a);
+    if (_id < 0)
+        return _id;
+    if (_c == QMetaObject::InvokeMetaMethod) {
+        if (_id < 1)
+            qt_static_metacall(this, _c, _id, _a);
+        _id -= 1;
+    }
+    return _id;
+}
+static const uint qt_meta_data_phoenix__pCheckItem[] = {
+
+ // content:
+       6,       // revision
+       0,       // classname
+       0,    0, // classinfo
+       1,   14, // methods
+       0,    0, // properties
+       0,    0, // enums/sets
+       0,    0, // constructors
+       0,       // flags
+       0,       // signalCount
+
+ // slots: signature, parameters, type, tag, flags
+      20,   31,   31,   31, 0x0a,
+
+       0        // eod
+};
+
+static const char qt_meta_stringdata_phoenix__pCheckItem[] = {
+    "phoenix::pCheckItem\0onToggle()\0\0"
+};
+
+void phoenix::pCheckItem::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
+{
+    if (_c == QMetaObject::InvokeMetaMethod) {
+        Q_ASSERT(staticMetaObject.cast(_o));
+        pCheckItem *_t = static_cast<pCheckItem *>(_o);
+        switch (_id) {
+        case 0: _t->onToggle(); break;
+        default: ;
+        }
+    }
+    Q_UNUSED(_a);
+}
+
+const QMetaObjectExtraData phoenix::pCheckItem::staticMetaObjectExtraData = {
+    0,  qt_static_metacall 
+};
+
+const QMetaObject phoenix::pCheckItem::staticMetaObject = {
+    { &QObject::staticMetaObject, qt_meta_stringdata_phoenix__pCheckItem,
+      qt_meta_data_phoenix__pCheckItem, &staticMetaObjectExtraData }
+};
+
+#ifdef Q_NO_DATA_RELOCATION
+const QMetaObject &phoenix::pCheckItem::getStaticMetaObject() { return staticMetaObject; }
+#endif //Q_NO_DATA_RELOCATION
+
+const QMetaObject *phoenix::pCheckItem::metaObject() const
+{
+    return QObject::d_ptr->metaObject ? QObject::d_ptr->metaObject : &staticMetaObject;
+}
+
+void *phoenix::pCheckItem::qt_metacast(const char *_clname)
+{
+    if (!_clname) return 0;
+    if (!strcmp(_clname, qt_meta_stringdata_phoenix__pCheckItem))
+        return static_cast<void*>(const_cast< pCheckItem*>(this));
+    if (!strcmp(_clname, "pAction"))
+        return static_cast< pAction*>(const_cast< pCheckItem*>(this));
+    return QObject::qt_metacast(_clname);
+}
+
+int phoenix::pCheckItem::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
+{
+    _id = QObject::qt_metacall(_c, _id, _a);
+    if (_id < 0)
+        return _id;
+    if (_c == QMetaObject::InvokeMetaMethod) {
+        if (_id < 1)
+            qt_static_metacall(this, _c, _id, _a);
+        _id -= 1;
+    }
+    return _id;
+}
+static const uint qt_meta_data_phoenix__pRadioItem[] = {
+
+ // content:
+       6,       // revision
+       0,       // classname
+       0,    0, // classinfo
+       1,   14, // methods
+       0,    0, // properties
+       0,    0, // enums/sets
+       0,    0, // constructors
+       0,       // flags
+       0,       // signalCount
+
+ // slots: signature, parameters, type, tag, flags
+      20,   33,   33,   33, 0x0a,
+
+       0        // eod
+};
+
+static const char qt_meta_stringdata_phoenix__pRadioItem[] = {
+    "phoenix::pRadioItem\0onActivate()\0\0"
+};
+
+void phoenix::pRadioItem::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
+{
+    if (_c == QMetaObject::InvokeMetaMethod) {
+        Q_ASSERT(staticMetaObject.cast(_o));
+        pRadioItem *_t = static_cast<pRadioItem *>(_o);
+        switch (_id) {
+        case 0: _t->onActivate(); break;
+        default: ;
+        }
+    }
+    Q_UNUSED(_a);
+}
+
+const QMetaObjectExtraData phoenix::pRadioItem::staticMetaObjectExtraData = {
+    0,  qt_static_metacall 
+};
+
+const QMetaObject phoenix::pRadioItem::staticMetaObject = {
+    { &QObject::staticMetaObject, qt_meta_stringdata_phoenix__pRadioItem,
+      qt_meta_data_phoenix__pRadioItem, &staticMetaObjectExtraData }
+};
+
+#ifdef Q_NO_DATA_RELOCATION
+const QMetaObject &phoenix::pRadioItem::getStaticMetaObject() { return staticMetaObject; }
+#endif //Q_NO_DATA_RELOCATION
+
+const QMetaObject *phoenix::pRadioItem::metaObject() const
+{
+    return QObject::d_ptr->metaObject ? QObject::d_ptr->metaObject : &staticMetaObject;
+}
+
+void *phoenix::pRadioItem::qt_metacast(const char *_clname)
+{
+    if (!_clname) return 0;
+    if (!strcmp(_clname, qt_meta_stringdata_phoenix__pRadioItem))
+        return static_cast<void*>(const_cast< pRadioItem*>(this));
+    if (!strcmp(_clname, "pAction"))
+        return static_cast< pAction*>(const_cast< pRadioItem*>(this));
+    return QObject::qt_metacast(_clname);
+}
+
+int phoenix::pRadioItem::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
+{
+    _id = QObject::qt_metacall(_c, _id, _a);
+    if (_id < 0)
+        return _id;
+    if (_c == QMetaObject::InvokeMetaMethod) {
+        if (_id < 1)
+            qt_static_metacall(this, _c, _id, _a);
+        _id -= 1;
+    }
+    return _id;
+}
+static const uint qt_meta_data_phoenix__pButton[] = {
+
+ // content:
+       6,       // revision
+       0,       // classname
+       0,    0, // classinfo
+       1,   14, // methods
+       0,    0, // properties
+       0,    0, // enums/sets
+       0,    0, // constructors
+       0,       // flags
+       0,       // signalCount
+
+ // slots: signature, parameters, type, tag, flags
+      17,   30,   30,   30, 0x0a,
+
+       0        // eod
+};
+
+static const char qt_meta_stringdata_phoenix__pButton[] = {
+    "phoenix::pButton\0onActivate()\0\0"
+};
+
+void phoenix::pButton::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
+{
+    if (_c == QMetaObject::InvokeMetaMethod) {
+        Q_ASSERT(staticMetaObject.cast(_o));
+        pButton *_t = static_cast<pButton *>(_o);
+        switch (_id) {
+        case 0: _t->onActivate(); break;
+        default: ;
+        }
+    }
+    Q_UNUSED(_a);
+}
+
+const QMetaObjectExtraData phoenix::pButton::staticMetaObjectExtraData = {
+    0,  qt_static_metacall 
+};
+
+const QMetaObject phoenix::pButton::staticMetaObject = {
+    { &QObject::staticMetaObject, qt_meta_stringdata_phoenix__pButton,
+      qt_meta_data_phoenix__pButton, &staticMetaObjectExtraData }
+};
+
+#ifdef Q_NO_DATA_RELOCATION
+const QMetaObject &phoenix::pButton::getStaticMetaObject() { return staticMetaObject; }
+#endif //Q_NO_DATA_RELOCATION
+
+const QMetaObject *phoenix::pButton::metaObject() const
+{
+    return QObject::d_ptr->metaObject ? QObject::d_ptr->metaObject : &staticMetaObject;
+}
+
+void *phoenix::pButton::qt_metacast(const char *_clname)
+{
+    if (!_clname) return 0;
+    if (!strcmp(_clname, qt_meta_stringdata_phoenix__pButton))
+        return static_cast<void*>(const_cast< pButton*>(this));
+    if (!strcmp(_clname, "pWidget"))
+        return static_cast< pWidget*>(const_cast< pButton*>(this));
+    return QObject::qt_metacast(_clname);
+}
+
+int phoenix::pButton::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
+{
+    _id = QObject::qt_metacall(_c, _id, _a);
+    if (_id < 0)
+        return _id;
+    if (_c == QMetaObject::InvokeMetaMethod) {
+        if (_id < 1)
+            qt_static_metacall(this, _c, _id, _a);
+        _id -= 1;
+    }
+    return _id;
+}
+static const uint qt_meta_data_phoenix__pCanvas[] = {
+
+ // content:
+       6,       // revision
+       0,       // classname
+       0,    0, // classinfo
+       0,    0, // methods
+       0,    0, // properties
+       0,    0, // enums/sets
+       0,    0, // constructors
+       0,       // flags
+       0,       // signalCount
+
+       0        // eod
+};
+
+static const char qt_meta_stringdata_phoenix__pCanvas[] = {
+    "phoenix::pCanvas\0"
+};
+
+void phoenix::pCanvas::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
+{
+    Q_UNUSED(_o);
+    Q_UNUSED(_id);
+    Q_UNUSED(_c);
+    Q_UNUSED(_a);
+}
+
+const QMetaObjectExtraData phoenix::pCanvas::staticMetaObjectExtraData = {
+    0,  qt_static_metacall 
+};
+
+const QMetaObject phoenix::pCanvas::staticMetaObject = {
+    { &QObject::staticMetaObject, qt_meta_stringdata_phoenix__pCanvas,
+      qt_meta_data_phoenix__pCanvas, &staticMetaObjectExtraData }
+};
+
+#ifdef Q_NO_DATA_RELOCATION
+const QMetaObject &phoenix::pCanvas::getStaticMetaObject() { return staticMetaObject; }
+#endif //Q_NO_DATA_RELOCATION
+
+const QMetaObject *phoenix::pCanvas::metaObject() const
+{
+    return QObject::d_ptr->metaObject ? QObject::d_ptr->metaObject : &staticMetaObject;
+}
+
+void *phoenix::pCanvas::qt_metacast(const char *_clname)
+{
+    if (!_clname) return 0;
+    if (!strcmp(_clname, qt_meta_stringdata_phoenix__pCanvas))
+        return static_cast<void*>(const_cast< pCanvas*>(this));
+    if (!strcmp(_clname, "pWidget"))
+        return static_cast< pWidget*>(const_cast< pCanvas*>(this));
+    return QObject::qt_metacast(_clname);
+}
+
+int phoenix::pCanvas::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
+{
+    _id = QObject::qt_metacall(_c, _id, _a);
+    if (_id < 0)
+        return _id;
+    return _id;
+}
+static const uint qt_meta_data_phoenix__pCheckButton[] = {
+
+ // content:
+       6,       // revision
+       0,       // classname
+       0,    0, // classinfo
+       1,   14, // methods
+       0,    0, // properties
+       0,    0, // enums/sets
+       0,    0, // constructors
+       0,       // flags
+       0,       // signalCount
+
+ // slots: signature, parameters, type, tag, flags
+      22,   37,   45,   45, 0x0a,
+
+       0        // eod
+};
+
+static const char qt_meta_stringdata_phoenix__pCheckButton[] = {
+    "phoenix::pCheckButton\0onToggle(bool)\0"
+    "checked\0\0"
+};
+
+void phoenix::pCheckButton::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
+{
+    if (_c == QMetaObject::InvokeMetaMethod) {
+        Q_ASSERT(staticMetaObject.cast(_o));
+        pCheckButton *_t = static_cast<pCheckButton *>(_o);
+        switch (_id) {
+        case 0: _t->onToggle((*reinterpret_cast< bool(*)>(_a[1]))); break;
+        default: ;
+        }
+    }
+}
+
+const QMetaObjectExtraData phoenix::pCheckButton::staticMetaObjectExtraData = {
+    0,  qt_static_metacall 
+};
+
+const QMetaObject phoenix::pCheckButton::staticMetaObject = {
+    { &QObject::staticMetaObject, qt_meta_stringdata_phoenix__pCheckButton,
+      qt_meta_data_phoenix__pCheckButton, &staticMetaObjectExtraData }
+};
+
+#ifdef Q_NO_DATA_RELOCATION
+const QMetaObject &phoenix::pCheckButton::getStaticMetaObject() { return staticMetaObject; }
+#endif //Q_NO_DATA_RELOCATION
+
+const QMetaObject *phoenix::pCheckButton::metaObject() const
+{
+    return QObject::d_ptr->metaObject ? QObject::d_ptr->metaObject : &staticMetaObject;
+}
+
+void *phoenix::pCheckButton::qt_metacast(const char *_clname)
+{
+    if (!_clname) return 0;
+    if (!strcmp(_clname, qt_meta_stringdata_phoenix__pCheckButton))
+        return static_cast<void*>(const_cast< pCheckButton*>(this));
+    if (!strcmp(_clname, "pWidget"))
+        return static_cast< pWidget*>(const_cast< pCheckButton*>(this));
+    return QObject::qt_metacast(_clname);
+}
+
+int phoenix::pCheckButton::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
+{
+    _id = QObject::qt_metacall(_c, _id, _a);
+    if (_id < 0)
+        return _id;
+    if (_c == QMetaObject::InvokeMetaMethod) {
+        if (_id < 1)
+            qt_static_metacall(this, _c, _id, _a);
+        _id -= 1;
+    }
+    return _id;
+}
+static const uint qt_meta_data_phoenix__pCheckLabel[] = {
+
+ // content:
+       6,       // revision
+       0,       // classname
+       0,    0, // classinfo
+       1,   14, // methods
+       0,    0, // properties
+       0,    0, // enums/sets
+       0,    0, // constructors
+       0,       // flags
+       0,       // signalCount
+
+ // slots: signature, parameters, type, tag, flags
+      21,   32,   32,   32, 0x0a,
+
+       0        // eod
+};
+
+static const char qt_meta_stringdata_phoenix__pCheckLabel[] = {
+    "phoenix::pCheckLabel\0onToggle()\0\0"
+};
+
+void phoenix::pCheckLabel::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
+{
+    if (_c == QMetaObject::InvokeMetaMethod) {
+        Q_ASSERT(staticMetaObject.cast(_o));
+        pCheckLabel *_t = static_cast<pCheckLabel *>(_o);
+        switch (_id) {
+        case 0: _t->onToggle(); break;
+        default: ;
+        }
+    }
+    Q_UNUSED(_a);
+}
+
+const QMetaObjectExtraData phoenix::pCheckLabel::staticMetaObjectExtraData = {
+    0,  qt_static_metacall 
+};
+
+const QMetaObject phoenix::pCheckLabel::staticMetaObject = {
+    { &QObject::staticMetaObject, qt_meta_stringdata_phoenix__pCheckLabel,
+      qt_meta_data_phoenix__pCheckLabel, &staticMetaObjectExtraData }
+};
+
+#ifdef Q_NO_DATA_RELOCATION
+const QMetaObject &phoenix::pCheckLabel::getStaticMetaObject() { return staticMetaObject; }
+#endif //Q_NO_DATA_RELOCATION
+
+const QMetaObject *phoenix::pCheckLabel::metaObject() const
+{
+    return QObject::d_ptr->metaObject ? QObject::d_ptr->metaObject : &staticMetaObject;
+}
+
+void *phoenix::pCheckLabel::qt_metacast(const char *_clname)
+{
+    if (!_clname) return 0;
+    if (!strcmp(_clname, qt_meta_stringdata_phoenix__pCheckLabel))
+        return static_cast<void*>(const_cast< pCheckLabel*>(this));
+    if (!strcmp(_clname, "pWidget"))
+        return static_cast< pWidget*>(const_cast< pCheckLabel*>(this));
+    return QObject::qt_metacast(_clname);
+}
+
+int phoenix::pCheckLabel::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
+{
+    _id = QObject::qt_metacall(_c, _id, _a);
+    if (_id < 0)
+        return _id;
+    if (_c == QMetaObject::InvokeMetaMethod) {
+        if (_id < 1)
+            qt_static_metacall(this, _c, _id, _a);
+        _id -= 1;
+    }
+    return _id;
+}
+static const uint qt_meta_data_phoenix__pComboButton[] = {
+
+ // content:
+       6,       // revision
+       0,       // classname
+       0,    0, // classinfo
+       1,   14, // methods
+       0,    0, // properties
+       0,    0, // enums/sets
+       0,    0, // constructors
+       0,       // flags
+       0,       // signalCount
+
+ // slots: signature, parameters, type, tag, flags
+      22,   33,   33,   33, 0x0a,
+
+       0        // eod
+};
+
+static const char qt_meta_stringdata_phoenix__pComboButton[] = {
+    "phoenix::pComboButton\0onChange()\0\0"
+};
+
+void phoenix::pComboButton::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
+{
+    if (_c == QMetaObject::InvokeMetaMethod) {
+        Q_ASSERT(staticMetaObject.cast(_o));
+        pComboButton *_t = static_cast<pComboButton *>(_o);
+        switch (_id) {
+        case 0: _t->onChange(); break;
+        default: ;
+        }
+    }
+    Q_UNUSED(_a);
+}
+
+const QMetaObjectExtraData phoenix::pComboButton::staticMetaObjectExtraData = {
+    0,  qt_static_metacall 
+};
+
+const QMetaObject phoenix::pComboButton::staticMetaObject = {
+    { &QObject::staticMetaObject, qt_meta_stringdata_phoenix__pComboButton,
+      qt_meta_data_phoenix__pComboButton, &staticMetaObjectExtraData }
+};
+
+#ifdef Q_NO_DATA_RELOCATION
+const QMetaObject &phoenix::pComboButton::getStaticMetaObject() { return staticMetaObject; }
+#endif //Q_NO_DATA_RELOCATION
+
+const QMetaObject *phoenix::pComboButton::metaObject() const
+{
+    return QObject::d_ptr->metaObject ? QObject::d_ptr->metaObject : &staticMetaObject;
+}
+
+void *phoenix::pComboButton::qt_metacast(const char *_clname)
+{
+    if (!_clname) return 0;
+    if (!strcmp(_clname, qt_meta_stringdata_phoenix__pComboButton))
+        return static_cast<void*>(const_cast< pComboButton*>(this));
+    if (!strcmp(_clname, "pWidget"))
+        return static_cast< pWidget*>(const_cast< pComboButton*>(this));
+    return QObject::qt_metacast(_clname);
+}
+
+int phoenix::pComboButton::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
+{
+    _id = QObject::qt_metacall(_c, _id, _a);
+    if (_id < 0)
+        return _id;
+    if (_c == QMetaObject::InvokeMetaMethod) {
+        if (_id < 1)
+            qt_static_metacall(this, _c, _id, _a);
+        _id -= 1;
+    }
+    return _id;
+}
+static const uint qt_meta_data_phoenix__pConsole[] = {
+
+ // content:
+       6,       // revision
+       0,       // classname
+       0,    0, // classinfo
+       0,    0, // methods
+       0,    0, // properties
+       0,    0, // enums/sets
+       0,    0, // constructors
+       0,       // flags
+       0,       // signalCount
+
+       0        // eod
+};
+
+static const char qt_meta_stringdata_phoenix__pConsole[] = {
+    "phoenix::pConsole\0"
+};
+
+void phoenix::pConsole::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
+{
+    Q_UNUSED(_o);
+    Q_UNUSED(_id);
+    Q_UNUSED(_c);
+    Q_UNUSED(_a);
+}
+
+const QMetaObjectExtraData phoenix::pConsole::staticMetaObjectExtraData = {
+    0,  qt_static_metacall 
+};
+
+const QMetaObject phoenix::pConsole::staticMetaObject = {
+    { &QObject::staticMetaObject, qt_meta_stringdata_phoenix__pConsole,
+      qt_meta_data_phoenix__pConsole, &staticMetaObjectExtraData }
+};
+
+#ifdef Q_NO_DATA_RELOCATION
+const QMetaObject &phoenix::pConsole::getStaticMetaObject() { return staticMetaObject; }
+#endif //Q_NO_DATA_RELOCATION
+
+const QMetaObject *phoenix::pConsole::metaObject() const
+{
+    return QObject::d_ptr->metaObject ? QObject::d_ptr->metaObject : &staticMetaObject;
+}
+
+void *phoenix::pConsole::qt_metacast(const char *_clname)
+{
+    if (!_clname) return 0;
+    if (!strcmp(_clname, qt_meta_stringdata_phoenix__pConsole))
+        return static_cast<void*>(const_cast< pConsole*>(this));
+    if (!strcmp(_clname, "pWidget"))
+        return static_cast< pWidget*>(const_cast< pConsole*>(this));
+    return QObject::qt_metacast(_clname);
+}
+
+int phoenix::pConsole::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
+{
+    _id = QObject::qt_metacall(_c, _id, _a);
+    if (_id < 0)
+        return _id;
+    return _id;
+}
+static const uint qt_meta_data_phoenix__pFrame[] = {
+
+ // content:
+       6,       // revision
+       0,       // classname
+       0,    0, // classinfo
+       0,    0, // methods
+       0,    0, // properties
+       0,    0, // enums/sets
+       0,    0, // constructors
+       0,       // flags
+       0,       // signalCount
+
+       0        // eod
+};
+
+static const char qt_meta_stringdata_phoenix__pFrame[] = {
+    "phoenix::pFrame\0"
+};
+
+void phoenix::pFrame::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
+{
+    Q_UNUSED(_o);
+    Q_UNUSED(_id);
+    Q_UNUSED(_c);
+    Q_UNUSED(_a);
+}
+
+const QMetaObjectExtraData phoenix::pFrame::staticMetaObjectExtraData = {
+    0,  qt_static_metacall 
+};
+
+const QMetaObject phoenix::pFrame::staticMetaObject = {
+    { &QObject::staticMetaObject, qt_meta_stringdata_phoenix__pFrame,
+      qt_meta_data_phoenix__pFrame, &staticMetaObjectExtraData }
+};
+
+#ifdef Q_NO_DATA_RELOCATION
+const QMetaObject &phoenix::pFrame::getStaticMetaObject() { return staticMetaObject; }
+#endif //Q_NO_DATA_RELOCATION
+
+const QMetaObject *phoenix::pFrame::metaObject() const
+{
+    return QObject::d_ptr->metaObject ? QObject::d_ptr->metaObject : &staticMetaObject;
+}
+
+void *phoenix::pFrame::qt_metacast(const char *_clname)
+{
+    if (!_clname) return 0;
+    if (!strcmp(_clname, qt_meta_stringdata_phoenix__pFrame))
+        return static_cast<void*>(const_cast< pFrame*>(this));
+    if (!strcmp(_clname, "pWidget"))
+        return static_cast< pWidget*>(const_cast< pFrame*>(this));
+    return QObject::qt_metacast(_clname);
+}
+
+int phoenix::pFrame::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
+{
+    _id = QObject::qt_metacall(_c, _id, _a);
+    if (_id < 0)
+        return _id;
+    return _id;
+}
+static const uint qt_meta_data_phoenix__pHexEdit[] = {
+
+ // content:
+       6,       // revision
+       0,       // classname
+       0,    0, // classinfo
+       1,   14, // methods
+       0,    0, // properties
+       0,    0, // enums/sets
+       0,    0, // constructors
+       0,       // flags
+       0,       // signalCount
+
+ // slots: signature, parameters, type, tag, flags
+      18,   29,   29,   29, 0x0a,
+
+       0        // eod
+};
+
+static const char qt_meta_stringdata_phoenix__pHexEdit[] = {
+    "phoenix::pHexEdit\0onScroll()\0\0"
+};
+
+void phoenix::pHexEdit::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
+{
+    if (_c == QMetaObject::InvokeMetaMethod) {
+        Q_ASSERT(staticMetaObject.cast(_o));
+        pHexEdit *_t = static_cast<pHexEdit *>(_o);
+        switch (_id) {
+        case 0: _t->onScroll(); break;
+        default: ;
+        }
+    }
+    Q_UNUSED(_a);
+}
+
+const QMetaObjectExtraData phoenix::pHexEdit::staticMetaObjectExtraData = {
+    0,  qt_static_metacall 
+};
+
+const QMetaObject phoenix::pHexEdit::staticMetaObject = {
+    { &QObject::staticMetaObject, qt_meta_stringdata_phoenix__pHexEdit,
+      qt_meta_data_phoenix__pHexEdit, &staticMetaObjectExtraData }
+};
+
+#ifdef Q_NO_DATA_RELOCATION
+const QMetaObject &phoenix::pHexEdit::getStaticMetaObject() { return staticMetaObject; }
+#endif //Q_NO_DATA_RELOCATION
+
+const QMetaObject *phoenix::pHexEdit::metaObject() const
+{
+    return QObject::d_ptr->metaObject ? QObject::d_ptr->metaObject : &staticMetaObject;
+}
+
+void *phoenix::pHexEdit::qt_metacast(const char *_clname)
+{
+    if (!_clname) return 0;
+    if (!strcmp(_clname, qt_meta_stringdata_phoenix__pHexEdit))
+        return static_cast<void*>(const_cast< pHexEdit*>(this));
+    if (!strcmp(_clname, "pWidget"))
+        return static_cast< pWidget*>(const_cast< pHexEdit*>(this));
+    return QObject::qt_metacast(_clname);
+}
+
+int phoenix::pHexEdit::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
+{
+    _id = QObject::qt_metacall(_c, _id, _a);
+    if (_id < 0)
+        return _id;
+    if (_c == QMetaObject::InvokeMetaMethod) {
+        if (_id < 1)
+            qt_static_metacall(this, _c, _id, _a);
+        _id -= 1;
+    }
+    return _id;
+}
+static const uint qt_meta_data_phoenix__pHorizontalScroller[] = {
+
+ // content:
+       6,       // revision
+       0,       // classname
+       0,    0, // classinfo
+       1,   14, // methods
+       0,    0, // properties
+       0,    0, // enums/sets
+       0,    0, // constructors
+       0,       // flags
+       0,       // signalCount
+
+ // slots: signature, parameters, type, tag, flags
+      29,   40,   40,   40, 0x0a,
+
+       0        // eod
+};
+
+static const char qt_meta_stringdata_phoenix__pHorizontalScroller[] = {
+    "phoenix::pHorizontalScroller\0onChange()\0"
+    "\0"
+};
+
+void phoenix::pHorizontalScroller::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
+{
+    if (_c == QMetaObject::InvokeMetaMethod) {
+        Q_ASSERT(staticMetaObject.cast(_o));
+        pHorizontalScroller *_t = static_cast<pHorizontalScroller *>(_o);
+        switch (_id) {
+        case 0: _t->onChange(); break;
+        default: ;
+        }
+    }
+    Q_UNUSED(_a);
+}
+
+const QMetaObjectExtraData phoenix::pHorizontalScroller::staticMetaObjectExtraData = {
+    0,  qt_static_metacall 
+};
+
+const QMetaObject phoenix::pHorizontalScroller::staticMetaObject = {
+    { &QObject::staticMetaObject, qt_meta_stringdata_phoenix__pHorizontalScroller,
+      qt_meta_data_phoenix__pHorizontalScroller, &staticMetaObjectExtraData }
+};
+
+#ifdef Q_NO_DATA_RELOCATION
+const QMetaObject &phoenix::pHorizontalScroller::getStaticMetaObject() { return staticMetaObject; }
+#endif //Q_NO_DATA_RELOCATION
+
+const QMetaObject *phoenix::pHorizontalScroller::metaObject() const
+{
+    return QObject::d_ptr->metaObject ? QObject::d_ptr->metaObject : &staticMetaObject;
+}
+
+void *phoenix::pHorizontalScroller::qt_metacast(const char *_clname)
+{
+    if (!_clname) return 0;
+    if (!strcmp(_clname, qt_meta_stringdata_phoenix__pHorizontalScroller))
+        return static_cast<void*>(const_cast< pHorizontalScroller*>(this));
+    if (!strcmp(_clname, "pWidget"))
+        return static_cast< pWidget*>(const_cast< pHorizontalScroller*>(this));
+    return QObject::qt_metacast(_clname);
+}
+
+int phoenix::pHorizontalScroller::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
+{
+    _id = QObject::qt_metacall(_c, _id, _a);
+    if (_id < 0)
+        return _id;
+    if (_c == QMetaObject::InvokeMetaMethod) {
+        if (_id < 1)
+            qt_static_metacall(this, _c, _id, _a);
+        _id -= 1;
+    }
+    return _id;
+}
+static const uint qt_meta_data_phoenix__pHorizontalSlider[] = {
+
+ // content:
+       6,       // revision
+       0,       // classname
+       0,    0, // classinfo
+       1,   14, // methods
+       0,    0, // properties
+       0,    0, // enums/sets
+       0,    0, // constructors
+       0,       // flags
+       0,       // signalCount
+
+ // slots: signature, parameters, type, tag, flags
+      27,   38,   38,   38, 0x0a,
+
+       0        // eod
+};
+
+static const char qt_meta_stringdata_phoenix__pHorizontalSlider[] = {
+    "phoenix::pHorizontalSlider\0onChange()\0"
+    "\0"
+};
+
+void phoenix::pHorizontalSlider::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
+{
+    if (_c == QMetaObject::InvokeMetaMethod) {
+        Q_ASSERT(staticMetaObject.cast(_o));
+        pHorizontalSlider *_t = static_cast<pHorizontalSlider *>(_o);
+        switch (_id) {
+        case 0: _t->onChange(); break;
+        default: ;
+        }
+    }
+    Q_UNUSED(_a);
+}
+
+const QMetaObjectExtraData phoenix::pHorizontalSlider::staticMetaObjectExtraData = {
+    0,  qt_static_metacall 
+};
+
+const QMetaObject phoenix::pHorizontalSlider::staticMetaObject = {
+    { &QObject::staticMetaObject, qt_meta_stringdata_phoenix__pHorizontalSlider,
+      qt_meta_data_phoenix__pHorizontalSlider, &staticMetaObjectExtraData }
+};
+
+#ifdef Q_NO_DATA_RELOCATION
+const QMetaObject &phoenix::pHorizontalSlider::getStaticMetaObject() { return staticMetaObject; }
+#endif //Q_NO_DATA_RELOCATION
+
+const QMetaObject *phoenix::pHorizontalSlider::metaObject() const
+{
+    return QObject::d_ptr->metaObject ? QObject::d_ptr->metaObject : &staticMetaObject;
+}
+
+void *phoenix::pHorizontalSlider::qt_metacast(const char *_clname)
+{
+    if (!_clname) return 0;
+    if (!strcmp(_clname, qt_meta_stringdata_phoenix__pHorizontalSlider))
+        return static_cast<void*>(const_cast< pHorizontalSlider*>(this));
+    if (!strcmp(_clname, "pWidget"))
+        return static_cast< pWidget*>(const_cast< pHorizontalSlider*>(this));
+    return QObject::qt_metacast(_clname);
+}
+
+int phoenix::pHorizontalSlider::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
+{
+    _id = QObject::qt_metacall(_c, _id, _a);
+    if (_id < 0)
+        return _id;
+    if (_c == QMetaObject::InvokeMetaMethod) {
+        if (_id < 1)
+            qt_static_metacall(this, _c, _id, _a);
+        _id -= 1;
+    }
+    return _id;
+}
+static const uint qt_meta_data_phoenix__pIconView[] = {
+
+ // content:
+       6,       // revision
+       0,       // classname
+       0,    0, // classinfo
+       3,   14, // methods
+       0,    0, // properties
+       0,    0, // enums/sets
+       0,    0, // constructors
+       0,       // flags
+       0,       // signalCount
+
+ // slots: signature, parameters, type, tag, flags
+      19,   32,   32,   32, 0x0a,
+      33,   32,   32,   32, 0x0a,
+      44,   32,   32,   32, 0x0a,
+
+       0        // eod
+};
+
+static const char qt_meta_stringdata_phoenix__pIconView[] = {
+    "phoenix::pIconView\0onActivate()\0\0"
+    "onChange()\0onContext()\0"
+};
+
+void phoenix::pIconView::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
+{
+    if (_c == QMetaObject::InvokeMetaMethod) {
+        Q_ASSERT(staticMetaObject.cast(_o));
+        pIconView *_t = static_cast<pIconView *>(_o);
+        switch (_id) {
+        case 0: _t->onActivate(); break;
+        case 1: _t->onChange(); break;
+        case 2: _t->onContext(); break;
+        default: ;
+        }
+    }
+    Q_UNUSED(_a);
+}
+
+const QMetaObjectExtraData phoenix::pIconView::staticMetaObjectExtraData = {
+    0,  qt_static_metacall 
+};
+
+const QMetaObject phoenix::pIconView::staticMetaObject = {
+    { &QObject::staticMetaObject, qt_meta_stringdata_phoenix__pIconView,
+      qt_meta_data_phoenix__pIconView, &staticMetaObjectExtraData }
+};
+
+#ifdef Q_NO_DATA_RELOCATION
+const QMetaObject &phoenix::pIconView::getStaticMetaObject() { return staticMetaObject; }
+#endif //Q_NO_DATA_RELOCATION
+
+const QMetaObject *phoenix::pIconView::metaObject() const
+{
+    return QObject::d_ptr->metaObject ? QObject::d_ptr->metaObject : &staticMetaObject;
+}
+
+void *phoenix::pIconView::qt_metacast(const char *_clname)
+{
+    if (!_clname) return 0;
+    if (!strcmp(_clname, qt_meta_stringdata_phoenix__pIconView))
+        return static_cast<void*>(const_cast< pIconView*>(this));
+    if (!strcmp(_clname, "pWidget"))
+        return static_cast< pWidget*>(const_cast< pIconView*>(this));
+    return QObject::qt_metacast(_clname);
+}
+
+int phoenix::pIconView::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
+{
+    _id = QObject::qt_metacall(_c, _id, _a);
+    if (_id < 0)
+        return _id;
+    if (_c == QMetaObject::InvokeMetaMethod) {
+        if (_id < 3)
+            qt_static_metacall(this, _c, _id, _a);
+        _id -= 3;
+    }
+    return _id;
+}
+static const uint qt_meta_data_phoenix__pLineEdit[] = {
+
+ // content:
+       6,       // revision
+       0,       // classname
+       0,    0, // classinfo
+       2,   14, // methods
+       0,    0, // properties
+       0,    0, // enums/sets
+       0,    0, // constructors
+       0,       // flags
+       0,       // signalCount
+
+ // slots: signature, parameters, type, tag, flags
+      19,   32,   32,   32, 0x0a,
+      33,   32,   32,   32, 0x0a,
+
+       0        // eod
+};
+
+static const char qt_meta_stringdata_phoenix__pLineEdit[] = {
+    "phoenix::pLineEdit\0onActivate()\0\0"
+    "onChange()\0"
+};
+
+void phoenix::pLineEdit::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
+{
+    if (_c == QMetaObject::InvokeMetaMethod) {
+        Q_ASSERT(staticMetaObject.cast(_o));
+        pLineEdit *_t = static_cast<pLineEdit *>(_o);
+        switch (_id) {
+        case 0: _t->onActivate(); break;
+        case 1: _t->onChange(); break;
+        default: ;
+        }
+    }
+    Q_UNUSED(_a);
+}
+
+const QMetaObjectExtraData phoenix::pLineEdit::staticMetaObjectExtraData = {
+    0,  qt_static_metacall 
+};
+
+const QMetaObject phoenix::pLineEdit::staticMetaObject = {
+    { &QObject::staticMetaObject, qt_meta_stringdata_phoenix__pLineEdit,
+      qt_meta_data_phoenix__pLineEdit, &staticMetaObjectExtraData }
+};
+
+#ifdef Q_NO_DATA_RELOCATION
+const QMetaObject &phoenix::pLineEdit::getStaticMetaObject() { return staticMetaObject; }
+#endif //Q_NO_DATA_RELOCATION
+
+const QMetaObject *phoenix::pLineEdit::metaObject() const
+{
+    return QObject::d_ptr->metaObject ? QObject::d_ptr->metaObject : &staticMetaObject;
+}
+
+void *phoenix::pLineEdit::qt_metacast(const char *_clname)
+{
+    if (!_clname) return 0;
+    if (!strcmp(_clname, qt_meta_stringdata_phoenix__pLineEdit))
+        return static_cast<void*>(const_cast< pLineEdit*>(this));
+    if (!strcmp(_clname, "pWidget"))
+        return static_cast< pWidget*>(const_cast< pLineEdit*>(this));
+    return QObject::qt_metacast(_clname);
+}
+
+int phoenix::pLineEdit::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
+{
+    _id = QObject::qt_metacall(_c, _id, _a);
+    if (_id < 0)
+        return _id;
+    if (_c == QMetaObject::InvokeMetaMethod) {
+        if (_id < 2)
+            qt_static_metacall(this, _c, _id, _a);
+        _id -= 2;
+    }
+    return _id;
+}
+static const uint qt_meta_data_phoenix__pListView[] = {
+
+ // content:
+       6,       // revision
+       0,       // classname
+       0,    0, // classinfo
+       6,   14, // methods
+       0,    0, // properties
+       0,    0, // enums/sets
+       0,    0, // constructors
+       0,       // flags
+       0,       // signalCount
+
+ // slots: signature, parameters, type, tag, flags
+      19,   32,   32,   32, 0x0a,
+      33,   32,   32,   32, 0x0a,
+      44,   32,   32,   32, 0x0a,
+      56,   68,   32,   32, 0x0a,
+      75,  102,   32,   32, 0x0a,
+     107,  141,  161,   32, 0x0a,
+
+       0        // eod
+};
+
+static const char qt_meta_stringdata_phoenix__pListView[] = {
+    "phoenix::pListView\0onActivate()\0\0"
+    "onChange()\0onContext()\0onSort(int)\0"
+    "column\0onToggle(QTreeWidgetItem*)\0"
+    "item\0calculateAlignment(double,double)\0"
+    "horizontal,vertical\0int\0"
+};
+
+void phoenix::pListView::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
+{
+    if (_c == QMetaObject::InvokeMetaMethod) {
+        Q_ASSERT(staticMetaObject.cast(_o));
+        pListView *_t = static_cast<pListView *>(_o);
+        switch (_id) {
+        case 0: _t->onActivate(); break;
+        case 1: _t->onChange(); break;
+        case 2: _t->onContext(); break;
+        case 3: _t->onSort((*reinterpret_cast< int(*)>(_a[1]))); break;
+        case 4: _t->onToggle((*reinterpret_cast< QTreeWidgetItem*(*)>(_a[1]))); break;
+        case 5: { int _r = _t->calculateAlignment((*reinterpret_cast< double(*)>(_a[1])),(*reinterpret_cast< double(*)>(_a[2])));
+            if (_a[0]) *reinterpret_cast< int*>(_a[0]) = _r; }  break;
+        default: ;
+        }
+    }
+}
+
+const QMetaObjectExtraData phoenix::pListView::staticMetaObjectExtraData = {
+    0,  qt_static_metacall 
+};
+
+const QMetaObject phoenix::pListView::staticMetaObject = {
+    { &QObject::staticMetaObject, qt_meta_stringdata_phoenix__pListView,
+      qt_meta_data_phoenix__pListView, &staticMetaObjectExtraData }
+};
+
+#ifdef Q_NO_DATA_RELOCATION
+const QMetaObject &phoenix::pListView::getStaticMetaObject() { return staticMetaObject; }
+#endif //Q_NO_DATA_RELOCATION
+
+const QMetaObject *phoenix::pListView::metaObject() const
+{
+    return QObject::d_ptr->metaObject ? QObject::d_ptr->metaObject : &staticMetaObject;
+}
+
+void *phoenix::pListView::qt_metacast(const char *_clname)
+{
+    if (!_clname) return 0;
+    if (!strcmp(_clname, qt_meta_stringdata_phoenix__pListView))
+        return static_cast<void*>(const_cast< pListView*>(this));
+    if (!strcmp(_clname, "pWidget"))
+        return static_cast< pWidget*>(const_cast< pListView*>(this));
+    return QObject::qt_metacast(_clname);
+}
+
+int phoenix::pListView::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
+{
+    _id = QObject::qt_metacall(_c, _id, _a);
+    if (_id < 0)
+        return _id;
+    if (_c == QMetaObject::InvokeMetaMethod) {
+        if (_id < 6)
+            qt_static_metacall(this, _c, _id, _a);
+        _id -= 6;
+    }
+    return _id;
+}
+static const uint qt_meta_data_phoenix__pRadioLabel[] = {
+
+ // content:
+       6,       // revision
+       0,       // classname
+       0,    0, // classinfo
+       1,   14, // methods
+       0,    0, // properties
+       0,    0, // enums/sets
+       0,    0, // constructors
+       0,       // flags
+       0,       // signalCount
+
+ // slots: signature, parameters, type, tag, flags
+      21,   34,   34,   34, 0x0a,
+
+       0        // eod
+};
+
+static const char qt_meta_stringdata_phoenix__pRadioLabel[] = {
+    "phoenix::pRadioLabel\0onActivate()\0\0"
+};
+
+void phoenix::pRadioLabel::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
+{
+    if (_c == QMetaObject::InvokeMetaMethod) {
+        Q_ASSERT(staticMetaObject.cast(_o));
+        pRadioLabel *_t = static_cast<pRadioLabel *>(_o);
+        switch (_id) {
+        case 0: _t->onActivate(); break;
+        default: ;
+        }
+    }
+    Q_UNUSED(_a);
+}
+
+const QMetaObjectExtraData phoenix::pRadioLabel::staticMetaObjectExtraData = {
+    0,  qt_static_metacall 
+};
+
+const QMetaObject phoenix::pRadioLabel::staticMetaObject = {
+    { &QObject::staticMetaObject, qt_meta_stringdata_phoenix__pRadioLabel,
+      qt_meta_data_phoenix__pRadioLabel, &staticMetaObjectExtraData }
+};
+
+#ifdef Q_NO_DATA_RELOCATION
+const QMetaObject &phoenix::pRadioLabel::getStaticMetaObject() { return staticMetaObject; }
+#endif //Q_NO_DATA_RELOCATION
+
+const QMetaObject *phoenix::pRadioLabel::metaObject() const
+{
+    return QObject::d_ptr->metaObject ? QObject::d_ptr->metaObject : &staticMetaObject;
+}
+
+void *phoenix::pRadioLabel::qt_metacast(const char *_clname)
+{
+    if (!_clname) return 0;
+    if (!strcmp(_clname, qt_meta_stringdata_phoenix__pRadioLabel))
+        return static_cast<void*>(const_cast< pRadioLabel*>(this));
+    if (!strcmp(_clname, "pWidget"))
+        return static_cast< pWidget*>(const_cast< pRadioLabel*>(this));
+    return QObject::qt_metacast(_clname);
+}
+
+int phoenix::pRadioLabel::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
+{
+    _id = QObject::qt_metacall(_c, _id, _a);
+    if (_id < 0)
+        return _id;
+    if (_c == QMetaObject::InvokeMetaMethod) {
+        if (_id < 1)
+            qt_static_metacall(this, _c, _id, _a);
+        _id -= 1;
+    }
+    return _id;
+}
+static const uint qt_meta_data_phoenix__pRadioButton[] = {
+
+ // content:
+       6,       // revision
+       0,       // classname
+       0,    0, // classinfo
+       1,   14, // methods
+       0,    0, // properties
+       0,    0, // enums/sets
+       0,    0, // constructors
+       0,       // flags
+       0,       // signalCount
+
+ // slots: signature, parameters, type, tag, flags
+      22,   35,   35,   35, 0x0a,
+
+       0        // eod
+};
+
+static const char qt_meta_stringdata_phoenix__pRadioButton[] = {
+    "phoenix::pRadioButton\0onActivate()\0\0"
+};
+
+void phoenix::pRadioButton::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
+{
+    if (_c == QMetaObject::InvokeMetaMethod) {
+        Q_ASSERT(staticMetaObject.cast(_o));
+        pRadioButton *_t = static_cast<pRadioButton *>(_o);
+        switch (_id) {
+        case 0: _t->onActivate(); break;
+        default: ;
+        }
+    }
+    Q_UNUSED(_a);
+}
+
+const QMetaObjectExtraData phoenix::pRadioButton::staticMetaObjectExtraData = {
+    0,  qt_static_metacall 
+};
+
+const QMetaObject phoenix::pRadioButton::staticMetaObject = {
+    { &QObject::staticMetaObject, qt_meta_stringdata_phoenix__pRadioButton,
+      qt_meta_data_phoenix__pRadioButton, &staticMetaObjectExtraData }
+};
+
+#ifdef Q_NO_DATA_RELOCATION
+const QMetaObject &phoenix::pRadioButton::getStaticMetaObject() { return staticMetaObject; }
+#endif //Q_NO_DATA_RELOCATION
+
+const QMetaObject *phoenix::pRadioButton::metaObject() const
+{
+    return QObject::d_ptr->metaObject ? QObject::d_ptr->metaObject : &staticMetaObject;
+}
+
+void *phoenix::pRadioButton::qt_metacast(const char *_clname)
+{
+    if (!_clname) return 0;
+    if (!strcmp(_clname, qt_meta_stringdata_phoenix__pRadioButton))
+        return static_cast<void*>(const_cast< pRadioButton*>(this));
+    if (!strcmp(_clname, "pWidget"))
+        return static_cast< pWidget*>(const_cast< pRadioButton*>(this));
+    return QObject::qt_metacast(_clname);
+}
+
+int phoenix::pRadioButton::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
+{
+    _id = QObject::qt_metacall(_c, _id, _a);
+    if (_id < 0)
+        return _id;
+    if (_c == QMetaObject::InvokeMetaMethod) {
+        if (_id < 1)
+            qt_static_metacall(this, _c, _id, _a);
+        _id -= 1;
+    }
+    return _id;
+}
+static const uint qt_meta_data_phoenix__pTabFrame[] = {
+
+ // content:
+       6,       // revision
+       0,       // classname
+       0,    0, // classinfo
+       1,   14, // methods
+       0,    0, // properties
+       0,    0, // enums/sets
+       0,    0, // constructors
+       0,       // flags
+       0,       // signalCount
+
+ // slots: signature, parameters, type, tag, flags
+      19,   33,   43,   43, 0x0a,
+
+       0        // eod
+};
+
+static const char qt_meta_stringdata_phoenix__pTabFrame[] = {
+    "phoenix::pTabFrame\0onChange(int)\0"
+    "selection\0\0"
+};
+
+void phoenix::pTabFrame::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
+{
+    if (_c == QMetaObject::InvokeMetaMethod) {
+        Q_ASSERT(staticMetaObject.cast(_o));
+        pTabFrame *_t = static_cast<pTabFrame *>(_o);
+        switch (_id) {
+        case 0: _t->onChange((*reinterpret_cast< int(*)>(_a[1]))); break;
+        default: ;
+        }
+    }
+}
+
+const QMetaObjectExtraData phoenix::pTabFrame::staticMetaObjectExtraData = {
+    0,  qt_static_metacall 
+};
+
+const QMetaObject phoenix::pTabFrame::staticMetaObject = {
+    { &QObject::staticMetaObject, qt_meta_stringdata_phoenix__pTabFrame,
+      qt_meta_data_phoenix__pTabFrame, &staticMetaObjectExtraData }
+};
+
+#ifdef Q_NO_DATA_RELOCATION
+const QMetaObject &phoenix::pTabFrame::getStaticMetaObject() { return staticMetaObject; }
+#endif //Q_NO_DATA_RELOCATION
+
+const QMetaObject *phoenix::pTabFrame::metaObject() const
+{
+    return QObject::d_ptr->metaObject ? QObject::d_ptr->metaObject : &staticMetaObject;
+}
+
+void *phoenix::pTabFrame::qt_metacast(const char *_clname)
+{
+    if (!_clname) return 0;
+    if (!strcmp(_clname, qt_meta_stringdata_phoenix__pTabFrame))
+        return static_cast<void*>(const_cast< pTabFrame*>(this));
+    if (!strcmp(_clname, "pWidget"))
+        return static_cast< pWidget*>(const_cast< pTabFrame*>(this));
+    return QObject::qt_metacast(_clname);
+}
+
+int phoenix::pTabFrame::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
+{
+    _id = QObject::qt_metacall(_c, _id, _a);
+    if (_id < 0)
+        return _id;
+    if (_c == QMetaObject::InvokeMetaMethod) {
+        if (_id < 1)
+            qt_static_metacall(this, _c, _id, _a);
+        _id -= 1;
+    }
+    return _id;
+}
+static const uint qt_meta_data_phoenix__pTextEdit[] = {
+
+ // content:
+       6,       // revision
+       0,       // classname
+       0,    0, // classinfo
+       1,   14, // methods
+       0,    0, // properties
+       0,    0, // enums/sets
+       0,    0, // constructors
+       0,       // flags
+       0,       // signalCount
+
+ // slots: signature, parameters, type, tag, flags
+      19,   30,   30,   30, 0x0a,
+
+       0        // eod
+};
+
+static const char qt_meta_stringdata_phoenix__pTextEdit[] = {
+    "phoenix::pTextEdit\0onChange()\0\0"
+};
+
+void phoenix::pTextEdit::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
+{
+    if (_c == QMetaObject::InvokeMetaMethod) {
+        Q_ASSERT(staticMetaObject.cast(_o));
+        pTextEdit *_t = static_cast<pTextEdit *>(_o);
+        switch (_id) {
+        case 0: _t->onChange(); break;
+        default: ;
+        }
+    }
+    Q_UNUSED(_a);
+}
+
+const QMetaObjectExtraData phoenix::pTextEdit::staticMetaObjectExtraData = {
+    0,  qt_static_metacall 
+};
+
+const QMetaObject phoenix::pTextEdit::staticMetaObject = {
+    { &QObject::staticMetaObject, qt_meta_stringdata_phoenix__pTextEdit,
+      qt_meta_data_phoenix__pTextEdit, &staticMetaObjectExtraData }
+};
+
+#ifdef Q_NO_DATA_RELOCATION
+const QMetaObject &phoenix::pTextEdit::getStaticMetaObject() { return staticMetaObject; }
+#endif //Q_NO_DATA_RELOCATION
+
+const QMetaObject *phoenix::pTextEdit::metaObject() const
+{
+    return QObject::d_ptr->metaObject ? QObject::d_ptr->metaObject : &staticMetaObject;
+}
+
+void *phoenix::pTextEdit::qt_metacast(const char *_clname)
+{
+    if (!_clname) return 0;
+    if (!strcmp(_clname, qt_meta_stringdata_phoenix__pTextEdit))
+        return static_cast<void*>(const_cast< pTextEdit*>(this));
+    if (!strcmp(_clname, "pWidget"))
+        return static_cast< pWidget*>(const_cast< pTextEdit*>(this));
+    return QObject::qt_metacast(_clname);
+}
+
+int phoenix::pTextEdit::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
+{
+    _id = QObject::qt_metacall(_c, _id, _a);
+    if (_id < 0)
+        return _id;
+    if (_c == QMetaObject::InvokeMetaMethod) {
+        if (_id < 1)
+            qt_static_metacall(this, _c, _id, _a);
+        _id -= 1;
+    }
+    return _id;
+}
+static const uint qt_meta_data_phoenix__pVerticalScroller[] = {
+
+ // content:
+       6,       // revision
+       0,       // classname
+       0,    0, // classinfo
+       1,   14, // methods
+       0,    0, // properties
+       0,    0, // enums/sets
+       0,    0, // constructors
+       0,       // flags
+       0,       // signalCount
+
+ // slots: signature, parameters, type, tag, flags
+      27,   38,   38,   38, 0x0a,
+
+       0        // eod
+};
+
+static const char qt_meta_stringdata_phoenix__pVerticalScroller[] = {
+    "phoenix::pVerticalScroller\0onChange()\0"
+    "\0"
+};
+
+void phoenix::pVerticalScroller::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
+{
+    if (_c == QMetaObject::InvokeMetaMethod) {
+        Q_ASSERT(staticMetaObject.cast(_o));
+        pVerticalScroller *_t = static_cast<pVerticalScroller *>(_o);
+        switch (_id) {
+        case 0: _t->onChange(); break;
+        default: ;
+        }
+    }
+    Q_UNUSED(_a);
+}
+
+const QMetaObjectExtraData phoenix::pVerticalScroller::staticMetaObjectExtraData = {
+    0,  qt_static_metacall 
+};
+
+const QMetaObject phoenix::pVerticalScroller::staticMetaObject = {
+    { &QObject::staticMetaObject, qt_meta_stringdata_phoenix__pVerticalScroller,
+      qt_meta_data_phoenix__pVerticalScroller, &staticMetaObjectExtraData }
+};
+
+#ifdef Q_NO_DATA_RELOCATION
+const QMetaObject &phoenix::pVerticalScroller::getStaticMetaObject() { return staticMetaObject; }
+#endif //Q_NO_DATA_RELOCATION
+
+const QMetaObject *phoenix::pVerticalScroller::metaObject() const
+{
+    return QObject::d_ptr->metaObject ? QObject::d_ptr->metaObject : &staticMetaObject;
+}
+
+void *phoenix::pVerticalScroller::qt_metacast(const char *_clname)
+{
+    if (!_clname) return 0;
+    if (!strcmp(_clname, qt_meta_stringdata_phoenix__pVerticalScroller))
+        return static_cast<void*>(const_cast< pVerticalScroller*>(this));
+    if (!strcmp(_clname, "pWidget"))
+        return static_cast< pWidget*>(const_cast< pVerticalScroller*>(this));
+    return QObject::qt_metacast(_clname);
+}
+
+int phoenix::pVerticalScroller::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
+{
+    _id = QObject::qt_metacall(_c, _id, _a);
+    if (_id < 0)
+        return _id;
+    if (_c == QMetaObject::InvokeMetaMethod) {
+        if (_id < 1)
+            qt_static_metacall(this, _c, _id, _a);
+        _id -= 1;
+    }
+    return _id;
+}
+static const uint qt_meta_data_phoenix__pVerticalSlider[] = {
+
+ // content:
+       6,       // revision
+       0,       // classname
+       0,    0, // classinfo
+       1,   14, // methods
+       0,    0, // properties
+       0,    0, // enums/sets
+       0,    0, // constructors
+       0,       // flags
+       0,       // signalCount
+
+ // slots: signature, parameters, type, tag, flags
+      25,   36,   36,   36, 0x0a,
+
+       0        // eod
+};
+
+static const char qt_meta_stringdata_phoenix__pVerticalSlider[] = {
+    "phoenix::pVerticalSlider\0onChange()\0"
+    "\0"
+};
+
+void phoenix::pVerticalSlider::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
+{
+    if (_c == QMetaObject::InvokeMetaMethod) {
+        Q_ASSERT(staticMetaObject.cast(_o));
+        pVerticalSlider *_t = static_cast<pVerticalSlider *>(_o);
+        switch (_id) {
+        case 0: _t->onChange(); break;
+        default: ;
+        }
+    }
+    Q_UNUSED(_a);
+}
+
+const QMetaObjectExtraData phoenix::pVerticalSlider::staticMetaObjectExtraData = {
+    0,  qt_static_metacall 
+};
+
+const QMetaObject phoenix::pVerticalSlider::staticMetaObject = {
+    { &QObject::staticMetaObject, qt_meta_stringdata_phoenix__pVerticalSlider,
+      qt_meta_data_phoenix__pVerticalSlider, &staticMetaObjectExtraData }
+};
+
+#ifdef Q_NO_DATA_RELOCATION
+const QMetaObject &phoenix::pVerticalSlider::getStaticMetaObject() { return staticMetaObject; }
+#endif //Q_NO_DATA_RELOCATION
+
+const QMetaObject *phoenix::pVerticalSlider::metaObject() const
+{
+    return QObject::d_ptr->metaObject ? QObject::d_ptr->metaObject : &staticMetaObject;
+}
+
+void *phoenix::pVerticalSlider::qt_metacast(const char *_clname)
+{
+    if (!_clname) return 0;
+    if (!strcmp(_clname, qt_meta_stringdata_phoenix__pVerticalSlider))
+        return static_cast<void*>(const_cast< pVerticalSlider*>(this));
+    if (!strcmp(_clname, "pWidget"))
+        return static_cast< pWidget*>(const_cast< pVerticalSlider*>(this));
+    return QObject::qt_metacast(_clname);
+}
+
+int phoenix::pVerticalSlider::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
+{
+    _id = QObject::qt_metacall(_c, _id, _a);
+    if (_id < 0)
+        return _id;
+    if (_c == QMetaObject::InvokeMetaMethod) {
+        if (_id < 1)
+            qt_static_metacall(this, _c, _id, _a);
+        _id -= 1;
+    }
+    return _id;
+}
+QT_END_MOC_NAMESPACE
diff -Nru higan/phoenix/qt/platform.moc.hpp nSide/phoenix/qt/platform.moc.hpp
--- higan/phoenix/qt/platform.moc.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/qt/platform.moc.hpp	2015-09-16 13:08:13.552563368 +0900
@@ -0,0 +1,876 @@
+namespace phoenix {
+
+struct pApplication {
+  static XlibDisplay* display;
+
+  static void run();
+  static bool pendingEvents();
+  static void processEvents();
+  static void quit();
+
+  static void initialize();
+  static void syncX();
+};
+
+static QApplication* qtApplication = nullptr;
+
+struct Settings : Configuration::Document {
+  bimap<Keyboard::Scancode, unsigned> keymap;
+
+  struct Geometry : Configuration::Node {
+    unsigned frameX;
+    unsigned frameY;
+    unsigned frameWidth;
+    unsigned frameHeight;
+    unsigned menuHeight;
+    unsigned statusHeight;
+  } geometry;
+
+  void load();
+  void save();
+  Settings();
+};
+
+struct pWindow;
+struct pMenu;
+struct pLayout;
+struct pWidget;
+
+struct pFont {
+  static string serif(unsigned size, string style);
+  static string sans(unsigned size, string style);
+  static string monospace(unsigned size, string style);
+  static Size size(string font, string text);
+
+  static QFont create(string description);
+  static Size size(const QFont& qtFont, string text);
+};
+
+struct pDesktop {
+  static Size size();
+  static Geometry workspace();
+};
+
+struct pMonitor {
+  static unsigned count();
+  static Geometry geometry(unsigned monitor);
+  static unsigned primary();
+};
+
+struct pKeyboard {
+  static bool pressed(Keyboard::Scancode scancode);
+  static vector<bool> state();
+
+  static void initialize();
+};
+
+struct pMouse {
+  static Position position();
+  static bool pressed(Mouse::Button button);
+};
+
+struct pBrowserWindow {
+  static string directory(BrowserWindow::State& state);
+  static string open(BrowserWindow::State& state);
+  static string save(BrowserWindow::State& state);
+};
+
+struct pMessageWindow {
+  static MessageWindow::Response error(MessageWindow::State& state);
+  static MessageWindow::Response information(MessageWindow::State& state);
+  static MessageWindow::Response question(MessageWindow::State& state);
+  static MessageWindow::Response warning(MessageWindow::State& state);
+};
+
+struct pObject {
+  Object& object;
+  signed locks = 0;
+
+  bool locked() const { return locks != 0; }
+  void lock() { locks++; }
+  void unlock() { locks--; }
+
+  pObject(Object& object) : object(object) {}
+  virtual ~pObject() {}
+  void constructor() {}
+  void destructor() {}
+};
+
+struct pTimer : public QObject, public pObject {
+  Q_OBJECT
+
+public:
+  Timer& timer;
+  QTimer* qtTimer;
+
+  void setEnabled(bool enabled);
+  void setInterval(unsigned interval);
+
+  pTimer(Timer& timer) : pObject(timer), timer(timer) {}
+  void constructor();
+  void destructor();
+
+public slots:
+  void onActivate();
+};
+
+struct pWindow : public QObject, public pObject {
+  Q_OBJECT
+
+public:
+  Window& window;
+  struct QtWindow : public QWidget {
+    pWindow& self;
+    void closeEvent(QCloseEvent*);
+    void dragEnterEvent(QDragEnterEvent*);
+    void dropEvent(QDropEvent*);
+    void keyPressEvent(QKeyEvent*);
+    void keyReleaseEvent(QKeyEvent*);
+    void moveEvent(QMoveEvent*);
+    void resizeEvent(QResizeEvent*);
+    QSize sizeHint() const;
+    QtWindow(pWindow& self) : self(self) {}
+  };
+  QtWindow* qtWindow;
+  QVBoxLayout* qtLayout;
+  QMenuBar* qtMenu;
+  QStatusBar* qtStatus;
+  QWidget* qtContainer;
+
+  void append(Layout& layout);
+  void append(Menu& menu);
+  void append(Widget& widget);
+  Geometry frameMargin();
+  bool focused();
+  void remove(Layout& layout);
+  void remove(Menu& menu);
+  void remove(Widget& widget);
+  void setBackgroundColor(Color color);
+  void setDroppable(bool droppable);
+  void setFocused();
+  void setFullScreen(bool fullScreen);
+  void setGeometry(Geometry geometry);
+  void setMenuFont(string font);
+  void setMenuVisible(bool visible);
+  void setModal(bool modal);
+  void setResizable(bool resizable);
+  void setStatusFont(string font);
+  void setStatusText(string text);
+  void setStatusVisible(bool visible);
+  void setTitle(string text);
+  void setVisible(bool visible);
+  void setWidgetFont(string font);
+
+  pWindow(Window& window) : pObject(window), window(window) {}
+  void constructor();
+  void destructor();
+  void updateFrameGeometry();
+};
+
+struct pPopupMenu : public pObject {
+  PopupMenu& popupMenu;
+  QMenu* qtMenu;
+
+  void append(Action& action);
+  void remove(Action& action);
+  void setVisible();
+
+  pPopupMenu(PopupMenu& popupMenu) : pObject(popupMenu), popupMenu(popupMenu) {}
+  void constructor();
+  void destructor();
+};
+
+struct pAction : public pObject {
+  Action& action;
+
+  void setEnabled(bool enabled);
+  void setFont(string font);
+  void setVisible(bool visible);
+
+  pAction(Action& action) : pObject(action), action(action) {}
+  void constructor();
+  void destructor();
+};
+
+struct pMenu : public pAction {
+  Menu& menu;
+  QMenu* qtMenu;
+
+  void append(Action& action);
+  void remove(Action& action);
+  void setFont(string font);
+  void setImage(const image& image);
+  void setText(string text);
+
+  pMenu(Menu& menu) : pAction(menu), menu(menu) {}
+  void constructor();
+  void destructor();
+};
+
+struct pSeparator : public pAction {
+  Separator& separator;
+  QAction* qtAction;
+
+  pSeparator(Separator& separator) : pAction(separator), separator(separator) {}
+  void constructor();
+  void destructor();
+};
+
+struct pItem : public QObject, public pAction {
+  Q_OBJECT
+
+public:
+  Item& item;
+  QAction* qtAction;
+
+  void setImage(const image& image);
+  void setText(string text);
+
+  pItem(Item& item) : pAction(item), item(item) {}
+  void constructor();
+  void destructor();
+
+public slots:
+  void onActivate();
+};
+
+struct pCheckItem : public QObject, public pAction {
+  Q_OBJECT
+
+public:
+  CheckItem& checkItem;
+  QAction* qtAction;
+
+  void setChecked(bool checked);
+  void setText(string text);
+
+  pCheckItem(CheckItem& checkItem) : pAction(checkItem), checkItem(checkItem) {}
+  void constructor();
+  void destructor();
+
+public slots:
+  void onToggle();
+};
+
+struct pRadioItem : public QObject, public pAction {
+  Q_OBJECT
+
+public:
+  RadioItem& radioItem;
+  QAction* qtAction;
+  QActionGroup* qtGroup;
+
+  void setChecked();
+  void setGroup(const group<RadioItem>& group);
+  void setText(string text);
+
+  pRadioItem(RadioItem& radioItem) : pAction(radioItem), radioItem(radioItem) {}
+  void constructor();
+  void destructor();
+
+public slots:
+  void onActivate();
+};
+
+struct pSizable : public pObject {
+  Sizable& sizable;
+
+  virtual Position displacement() { return {0, 0}; }
+
+  pSizable(Sizable& sizable) : pObject(sizable), sizable(sizable) {}
+
+  void constructor() {}
+  void destructor() {}
+};
+
+struct pLayout : public pSizable {
+  Layout& layout;
+
+  pLayout(Layout& layout) : pSizable(layout), layout(layout) {}
+
+  void constructor() {}
+  void destructor() {}
+};
+
+struct pWidget : public pSizable {
+  Widget& widget;
+  QWidget* qtWidget;
+
+  virtual QWidget* container(Widget& widget);
+  bool focused();
+  virtual Size minimumSize();
+  virtual void setEnabled(bool enabled);
+  void setFocused();
+  void setFont(string font);
+  virtual void setGeometry(Geometry geometry);
+  virtual void setVisible(bool visible);
+
+  pWidget(Widget& widget) : pSizable(widget), widget(widget) {}
+  void constructor();
+  void synchronizeState();
+  void destructor();
+  virtual void orphan();
+};
+
+struct pButton : public QObject, public pWidget {
+  Q_OBJECT
+
+public:
+  Button& button;
+  QToolButton* qtButton;
+
+  Size minimumSize();
+  void setBordered(bool bordered);
+  void setImage(const image& image, Orientation orientation);
+  void setText(string text);
+
+  pButton(Button& button) : pWidget(button), button(button) {}
+  void constructor();
+  void destructor();
+  void orphan();
+
+public slots:
+  void onActivate();
+};
+
+struct pCanvas : public QObject, public pWidget {
+  Q_OBJECT
+
+public:
+  Canvas& canvas;
+  QImage* surface = nullptr;
+  unsigned surfaceWidth = 0;
+  unsigned surfaceHeight = 0;
+  struct QtCanvas : public QWidget {
+    pCanvas& self;
+    void dragEnterEvent(QDragEnterEvent*);
+    void dropEvent(QDropEvent*);
+    void leaveEvent(QEvent*);
+    void mouseMoveEvent(QMouseEvent*);
+    void mousePressEvent(QMouseEvent*);
+    void mouseReleaseEvent(QMouseEvent*);
+    void paintEvent(QPaintEvent*);
+    QtCanvas(pCanvas& self);
+  };
+  QtCanvas* qtCanvas;
+
+  void setDroppable(bool droppable);
+  void setGeometry(Geometry geometry);
+  void setMode(Canvas::Mode mode);
+  void setSize(Size size);
+
+  pCanvas(Canvas& canvas) : pWidget(canvas), canvas(canvas) {}
+  void constructor();
+  void destructor();
+  void orphan();
+  void rasterize();
+  void release();
+
+public slots:
+};
+
+struct pCheckButton : public QObject, public pWidget {
+  Q_OBJECT
+
+public:
+  CheckButton& checkButton;
+  QToolButton* qtCheckButton;
+
+  Size minimumSize();
+  void setChecked(bool checked);
+  void setImage(const image& image, Orientation orientation);
+  void setText(string text);
+
+  pCheckButton(CheckButton& checkButton) : pWidget(checkButton), checkButton(checkButton) {}
+  void constructor();
+  void destructor();
+  void orphan();
+
+public slots:
+  void onToggle(bool checked);
+};
+
+struct pCheckLabel : public QObject, public pWidget {
+  Q_OBJECT
+
+public:
+  CheckLabel& checkLabel;
+  QCheckBox* qtCheckLabel;
+
+  Size minimumSize();
+  void setChecked(bool checked);
+  void setText(string text);
+
+  pCheckLabel(CheckLabel& checkLabel) : pWidget(checkLabel), checkLabel(checkLabel) {}
+  void constructor();
+  void destructor();
+  void orphan();
+
+public slots:
+  void onToggle();
+};
+
+struct pComboButton : public QObject, public pWidget {
+  Q_OBJECT
+
+public:
+  ComboButton& comboButton;
+  QComboBox* qtComboButton;
+
+  void append();
+  Size minimumSize();
+  void remove(unsigned selection);
+  void reset();
+  void setSelected(unsigned selection);
+  void setText(unsigned selection, string text);
+
+  pComboButton(ComboButton& comboButton) : pWidget(comboButton), comboButton(comboButton) {}
+  void constructor();
+  void destructor();
+  void orphan();
+
+public slots:
+  void onChange();
+};
+
+struct pConsole : public QObject, public pWidget {
+  Q_OBJECT
+
+public:
+  Console& console;
+  struct QtConsole : public QTextEdit {
+    pConsole& self;
+    void keyPressEvent(QKeyEvent*);
+    void keyPressEventAcknowledge(QKeyEvent*);
+    QtConsole(pConsole& self) : self(self) {}
+  };
+  QtConsole* qtConsole;
+
+  void print(string text);
+  void reset();
+  void setBackgroundColor(Color color);
+  void setForegroundColor(Color color);
+  void setPrompt(string prompt);
+
+  pConsole(Console& console) : pWidget(console), console(console) {}
+  void constructor();
+  void destructor();
+  void orphan();
+  void keyPressEvent(QKeyEvent*);
+};
+
+struct pFrame : public QObject, public pWidget {
+  Q_OBJECT
+
+public:
+  Frame& frame;
+  QGroupBox* qtFrame;
+
+  void setEnabled(bool enabled);
+  void setGeometry(Geometry geometry);
+  void setText(string text);
+  void setVisible(bool visible);
+
+  pFrame(Frame& frame) : pWidget(frame), frame(frame) {}
+  void constructor();
+  void destructor();
+  void orphan();
+};
+
+struct pHexEdit : public QObject, public pWidget {
+  Q_OBJECT
+
+public:
+  HexEdit& hexEdit;
+  struct QtHexEdit : public QTextEdit {
+    pHexEdit& self;
+    void keyPressEvent(QKeyEvent*);
+    void keyPressEventAcknowledge(QKeyEvent*);
+    void wheelEvent(QWheelEvent*);
+    QtHexEdit(pHexEdit& self) : self(self) {}
+  };
+  struct QtHexEditScrollBar : public QScrollBar {
+    pHexEdit& self;
+    bool event(QEvent*);
+    QtHexEditScrollBar(pHexEdit& self) : QScrollBar(Qt::Vertical), self(self) {}
+  };
+  QtHexEdit* qtHexEdit;
+  QHBoxLayout* qtLayout;
+  QtHexEditScrollBar* qtScroll;
+
+  void setBackgroundColor(Color color);
+  void setColumns(unsigned columns);
+  void setForegroundColor(Color color);
+  void setLength(unsigned length);
+  void setOffset(unsigned offset);
+  void setRows(unsigned rows);
+  void update();
+
+  pHexEdit(HexEdit& hexEdit) : pWidget(hexEdit), hexEdit(hexEdit) {}
+  void constructor();
+  void destructor();
+  void orphan();
+  void keyPressEvent(QKeyEvent*);
+  signed rows();
+  signed rowsScrollable();
+  void scrollTo(signed position);
+
+public slots:
+  void onScroll();
+};
+
+struct pHorizontalScroller : public QObject, public pWidget {
+  Q_OBJECT
+
+public:
+  HorizontalScroller& horizontalScroller;
+  QScrollBar* qtScroller;
+
+  Size minimumSize();
+  void setLength(unsigned length);
+  void setPosition(unsigned position);
+
+  pHorizontalScroller(HorizontalScroller& horizontalScroller) : pWidget(horizontalScroller), horizontalScroller(horizontalScroller) {}
+  void constructor();
+  void destructor();
+  void orphan();
+
+public slots:
+  void onChange();
+};
+
+struct pHorizontalSlider : public QObject, public pWidget {
+  Q_OBJECT
+
+public:
+  HorizontalSlider& horizontalSlider;
+  QSlider* qtSlider;
+
+  Size minimumSize();
+  void setLength(unsigned length);
+  void setPosition(unsigned position);
+
+  pHorizontalSlider(HorizontalSlider& horizontalSlider) : pWidget(horizontalSlider), horizontalSlider(horizontalSlider) {}
+  void constructor();
+  void destructor();
+  void orphan();
+
+public slots:
+  void onChange();
+};
+
+struct pIconView : public QObject, public pWidget {
+  Q_OBJECT
+
+public:
+  IconView& iconView;
+  struct QtListWidget : public QListWidget {
+    void resizeEvent(QResizeEvent*);
+  };
+  QtListWidget* qtIconView;
+
+  void append();
+  void remove(unsigned selection);
+  void reset();
+  void setBackgroundColor(Color color);
+  void setFlow(Orientation flow);
+  void setForegroundColor(Color color);
+  void setImage(unsigned selection, const image& image);
+  void setOrientation(Orientation orientation);
+  void setSelected(unsigned selection, bool selected);
+  void setSelected(const vector<unsigned>& selections);
+  void setSelectedAll();
+  void setSelectedNone();
+  void setSingleSelection(bool singleSelection);
+  void setText(unsigned selection, const string& text);
+
+  pIconView(IconView& iconView) : pWidget(iconView), iconView(iconView) {}
+  void constructor();
+  void destructor();
+  void orphan();
+
+public slots:
+  void onActivate();
+  void onChange();
+  void onContext();
+};
+
+struct pLabel : public pWidget {
+  Label& label;
+  QLabel* qtLabel;
+
+  Size minimumSize();
+  void setText(string text);
+
+  pLabel(Label& label) : pWidget(label), label(label) {}
+  void constructor();
+  void destructor();
+  void orphan();
+};
+
+struct pLineEdit : public QObject, public pWidget {
+  Q_OBJECT
+
+public:
+  LineEdit& lineEdit;
+  QLineEdit* qtLineEdit;
+
+  Size minimumSize();
+  void setBackgroundColor(Color color);
+  void setEditable(bool editable);
+  void setForegroundColor(Color color);
+  void setText(string text);
+  string text();
+
+  pLineEdit(LineEdit& lineEdit) : pWidget(lineEdit), lineEdit(lineEdit) {}
+  void constructor();
+  void destructor();
+  void orphan();
+
+public slots:
+  void onActivate();
+  void onChange();
+};
+
+struct pListView : public QObject, public pWidget {
+  Q_OBJECT
+
+public:
+  ListView& listView;
+  struct QtTreeWidget : public QTreeWidget {
+    pListView& self;
+    void mousePressEvent(QMouseEvent*);
+    QtTreeWidget(pListView& self);
+  };
+  struct QtTreeWidgetDelegate : public QStyledItemDelegate {
+    pListView& self;
+    void paint(QPainter* painter, const QStyleOptionViewItem& option, const QModelIndex& index) const;
+    QtTreeWidgetDelegate(pListView& self);
+  };
+  QtTreeWidget* qtListView;
+  QtTreeWidgetDelegate* qtListViewDelegate;
+
+  void appendColumn();
+  void appendItem();
+  void removeColumn(unsigned position);
+  void removeItem(unsigned position);
+  void reset();
+  void resizeColumns();
+  void setActiveColumn(unsigned column);
+  void setBackgroundColor(Color color);
+  void setCheckable(bool checkable);
+  void setChecked(unsigned position, bool checked);
+  void setChecked(const vector<unsigned>& selections);
+  void setCheckedAll();
+  void setCheckedNone();
+  void setColumnBackgroundColor(unsigned position, maybe<Color> color);
+  void setColumnEditable(unsigned position, bool editable);
+  void setColumnFont(unsigned position, maybe<string> font);
+  void setColumnForegroundColor(unsigned position, maybe<Color> color);
+  void setColumnHorizontalAlignment(unsigned position, double alignment);
+  void setColumnResizable(unsigned position, bool resizable);
+  void setColumnSortable(unsigned position, bool sortable);
+  void setColumnText(unsigned position, const string& text);
+  void setColumnVerticalAlignment(unsigned position, double alignment);
+  void setColumnVisible(unsigned position, bool visible);
+  void setColumnWidth(unsigned position, signed width);
+  void setForegroundColor(Color color);
+  void setGridVisible(bool visible);
+  void setHeaderVisible(bool visible);
+  void setImage(unsigned row, unsigned column, const image& image);
+  void setSelected(unsigned position, bool selected);
+  void setSelected(const vector<unsigned>& selections);
+  void setSelectedAll();
+  void setSelectedNone();
+  void setSingleSelection(bool singleSelection);
+  void setText(unsigned row, unsigned column, string text);
+
+  pListView(ListView& listView) : pWidget(listView), listView(listView) {}
+  void constructor();
+  void destructor();
+  void orphan();
+
+public slots:
+  void onActivate();
+  void onChange();
+  void onContext();
+  void onSort(int column);
+  void onToggle(QTreeWidgetItem* item);
+  int calculateAlignment(double horizontal, double vertical);
+};
+
+struct pProgressBar : public pWidget {
+  ProgressBar& progressBar;
+  QProgressBar* qtProgressBar;
+
+  Size minimumSize();
+  void setPosition(unsigned position);
+
+  pProgressBar(ProgressBar& progressBar) : pWidget(progressBar), progressBar(progressBar) {}
+  void constructor();
+  void destructor();
+  void orphan();
+};
+
+struct pRadioLabel : public QObject, public pWidget {
+  Q_OBJECT
+
+public:
+  RadioLabel& radioLabel;
+  QRadioButton* qtRadioLabel;
+
+  bool checked();
+  Size minimumSize();
+  void setChecked();
+  void setGroup(const group<RadioLabel>& group);
+  void setText(string text);
+
+  pRadioLabel(RadioLabel& radioLabel) : pWidget(radioLabel), radioLabel(radioLabel) {}
+  pRadioLabel& parent();
+  void constructor();
+  void destructor();
+  void orphan();
+
+public slots:
+  void onActivate();
+};
+
+struct pRadioButton : public QObject, public pWidget {
+  Q_OBJECT
+
+public:
+  RadioButton& radioButton;
+  QToolButton* qtRadioButton;
+
+  Size minimumSize();
+  void setChecked();
+  void setGroup(const group<RadioButton>& group);
+  void setImage(const image& image, Orientation orientation);
+  void setText(string text);
+
+  pRadioButton(RadioButton& radioButton) : pWidget(radioButton), radioButton(radioButton) {}
+  pRadioButton& parent();
+  void constructor();
+  void destructor();
+  void orphan();
+
+public slots:
+  void onActivate();
+};
+
+struct pTabFrame : public QObject, public pWidget {
+  Q_OBJECT
+
+public:
+  TabFrame& tabFrame;
+  QTabWidget* qtTabFrame;
+
+  void append();
+  QWidget* container(Widget& widget);
+  Position displacement();
+  void remove(unsigned selection);
+  void setEnabled(bool enabled);
+  void setGeometry(Geometry geometry);
+  void setImage(unsigned selection, const image& image);
+  void setSelected(unsigned selection);
+  void setText(unsigned selection, string text);
+  void setVisible(bool visible);
+
+  pTabFrame(TabFrame& tabFrame) : pWidget(tabFrame), tabFrame(tabFrame) {}
+  void constructor();
+  void destructor();
+  void orphan();
+  void synchronizeLayout();
+
+public slots:
+  void onChange(int selection);
+};
+
+struct pTextEdit : public QObject, public pWidget {
+  Q_OBJECT
+
+public:
+  TextEdit& textEdit;
+  QTextEdit* qtTextEdit;
+
+  void setBackgroundColor(Color color);
+  void setCursorPosition(unsigned position);
+  void setEditable(bool editable);
+  void setForegroundColor(Color color);
+  void setText(string text);
+  void setWordWrap(bool wordWrap);
+  string text();
+
+  pTextEdit(TextEdit& textEdit) : pWidget(textEdit), textEdit(textEdit) {}
+  void constructor();
+  void destructor();
+  void orphan();
+
+public slots:
+  void onChange();
+};
+
+struct pVerticalScroller : public QObject, public pWidget {
+  Q_OBJECT
+
+public:
+  VerticalScroller& verticalScroller;
+  QScrollBar* qtScroller;
+
+  Size minimumSize();
+  void setLength(unsigned length);
+  void setPosition(unsigned position);
+
+  pVerticalScroller(VerticalScroller& verticalScroller) : pWidget(verticalScroller), verticalScroller(verticalScroller) {}
+  void constructor();
+  void destructor();
+  void orphan();
+
+public slots:
+  void onChange();
+};
+
+struct pVerticalSlider : public QObject, public pWidget {
+  Q_OBJECT
+
+public:
+  VerticalSlider& verticalSlider;
+  QSlider* qtSlider;
+
+  Size minimumSize();
+  void setLength(unsigned length);
+  void setPosition(unsigned position);
+
+  pVerticalSlider(VerticalSlider& verticalSlider) : pWidget(verticalSlider), verticalSlider(verticalSlider) {}
+  void constructor();
+  void destructor();
+  void orphan();
+
+public slots:
+  void onChange();
+};
+
+struct pViewport : public pWidget {
+  Viewport& viewport;
+  struct QtViewport : public QWidget {
+    pViewport& self;
+    void dragEnterEvent(QDragEnterEvent*);
+    void dropEvent(QDropEvent*);
+    void leaveEvent(QEvent*);
+    void mouseMoveEvent(QMouseEvent*);
+    void mousePressEvent(QMouseEvent*);
+    void mouseReleaseEvent(QMouseEvent*);
+    QtViewport(pViewport& self);
+  };
+  QtViewport* qtViewport;
+
+  uintptr_t handle();
+  void setDroppable(bool droppable);
+
+  pViewport(Viewport& viewport) : pWidget(viewport), viewport(viewport) {}
+  void constructor();
+  void destructor();
+  void orphan();
+};
+
+}
diff -Nru higan/phoenix/qt/popup-menu.cpp nSide/phoenix/qt/popup-menu.cpp
--- higan/phoenix/qt/popup-menu.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/qt/popup-menu.cpp	2015-09-16 13:08:13.557563368 +0900
@@ -0,0 +1,46 @@
+namespace phoenix {
+
+void pPopupMenu::append(Action& action) {
+  if(dynamic_cast<Menu*>(&action)) {
+    qtMenu->addMenu(((Menu&)action).p.qtMenu);
+  } else if(dynamic_cast<Separator*>(&action)) {
+    qtMenu->addAction(((Separator&)action).p.qtAction);
+  } else if(dynamic_cast<Item*>(&action)) {
+    qtMenu->addAction(((Item&)action).p.qtAction);
+  } else if(dynamic_cast<CheckItem*>(&action)) {
+    qtMenu->addAction(((CheckItem&)action).p.qtAction);
+  } else if(dynamic_cast<RadioItem*>(&action)) {
+    qtMenu->addAction(((RadioItem&)action).p.qtAction);
+  }
+}
+
+void pPopupMenu::remove(Action& action) {
+  if(dynamic_cast<Menu*>(&action)) {
+    //QMenu::removeMenu() does not exist
+    qtMenu->clear();
+    for(auto& action : popupMenu.state.action) append(action);
+  } else if(dynamic_cast<Separator*>(&action)) {
+    qtMenu->removeAction(((Separator&)action).p.qtAction);
+  } else if(dynamic_cast<Item*>(&action)) {
+    qtMenu->removeAction(((Item&)action).p.qtAction);
+  } else if(dynamic_cast<CheckItem*>(&action)) {
+    qtMenu->removeAction(((CheckItem&)action).p.qtAction);
+  } else if(dynamic_cast<RadioItem*>(&action)) {
+    qtMenu->removeAction(((RadioItem&)action).p.qtAction);
+  }
+}
+
+void pPopupMenu::setVisible() {
+  qtMenu->popup(QCursor::pos());
+}
+
+void pPopupMenu::constructor() {
+  qtMenu = new QMenu;
+}
+
+void pPopupMenu::destructor() {
+  delete qtMenu;
+  qtMenu = nullptr;
+}
+
+}
diff -Nru higan/phoenix/qt/settings.cpp nSide/phoenix/qt/settings.cpp
--- higan/phoenix/qt/settings.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/qt/settings.cpp	2015-09-16 13:08:13.544563367 +0900
@@ -0,0 +1,26 @@
+namespace phoenix {
+
+static Settings *settings = nullptr;
+
+void Settings::load() {
+  string path = {userpath(), ".config/phoenix/"};
+  Configuration::Document::load({path, "qt.bml"});
+}
+
+void Settings::save() {
+  string path = {userpath(), ".config/phoenix/"};
+  directory::create(path, 0755);
+  Configuration::Document::save({path, "qt.bml"});
+}
+
+Settings::Settings() {
+  geometry.append(geometry.frameX = 4, "FrameX");
+  geometry.append(geometry.frameY = 24, "FrameY");
+  geometry.append(geometry.frameWidth = 8, "FrameWidth");
+  geometry.append(geometry.frameHeight = 28, "FrameHeight");
+  geometry.append(geometry.menuHeight = 20, "MenuHeight");
+  geometry.append(geometry.statusHeight = 20, "StatusHeight");
+  append(geometry, "Geometry");
+}
+
+}
diff -Nru higan/phoenix/qt/timer.cpp nSide/phoenix/qt/timer.cpp
--- higan/phoenix/qt/timer.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/qt/timer.cpp	2015-09-16 13:08:13.552563368 +0900
@@ -0,0 +1,29 @@
+namespace phoenix {
+
+void pTimer::setEnabled(bool enabled) {
+  if(enabled) {
+    qtTimer->start();
+  } else {
+    qtTimer->stop();
+  }
+}
+
+void pTimer::setInterval(unsigned interval) {
+  qtTimer->setInterval(interval);
+}
+
+void pTimer::constructor() {
+  qtTimer = new QTimer;
+  qtTimer->setInterval(0);
+  connect(qtTimer, SIGNAL(timeout()), SLOT(onActivate()));
+}
+
+void pTimer::destructor() {
+  delete qtTimer;
+}
+
+void pTimer::onActivate() {
+  if(timer.onActivate) timer.onActivate();
+}
+
+}
diff -Nru higan/phoenix/qt/utility.cpp nSide/phoenix/qt/utility.cpp
--- higan/phoenix/qt/utility.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/qt/utility.cpp	2015-09-16 13:08:13.558563368 +0900
@@ -0,0 +1,237 @@
+namespace phoenix {
+
+static QIcon CreateIcon(const nall::image& image, bool scale = false) {
+  if(image.empty()) return QIcon();
+  nall::image qtBuffer = image;
+  qtBuffer.transform(0, 32, 255u << 24, 255u << 16, 255u << 8, 255u << 0);
+  if(scale) qtBuffer.scale(16, 16, Interpolation::Linear);
+  QImage qtImage(qtBuffer.data, qtBuffer.width, qtBuffer.height, QImage::Format_ARGB32);
+  return QIcon(QPixmap::fromImage(qtImage));
+}
+
+static lstring DropPaths(QDropEvent* event) {
+  QList<QUrl> urls = event->mimeData()->urls();
+  if(urls.size() == 0) return {};
+
+  lstring paths;
+  for(unsigned n = 0; n < urls.size(); n++) {
+    string path = urls[n].path().toUtf8().constData();
+    if(path.empty()) continue;
+    if(directory::exists(path) && !path.endsWith("/")) path.append("/");
+    paths.append(path);
+  }
+
+  return paths;
+}
+
+static Position GetDisplacement(Sizable* sizable) {
+  Position position;
+  while(sizable->state.parent) {
+    Position displacement = sizable->state.parent->p.displacement();
+    position.x += displacement.x;
+    position.y += displacement.y;
+    sizable = sizable->state.parent;
+  }
+  return position;
+}
+
+static Layout* GetParentWidgetLayout(Sizable* sizable) {
+  while(sizable) {
+    if(sizable->state.parent && dynamic_cast<TabFrame*>(sizable->state.parent)) return (Layout*)sizable;
+    sizable = sizable->state.parent;
+  }
+  return nullptr;
+}
+
+static Widget* GetParentWidget(Sizable* sizable) {
+  while(sizable) {
+    if(sizable->state.parent && dynamic_cast<TabFrame*>(sizable->state.parent)) return (Widget*)sizable->state.parent;
+    sizable = sizable->state.parent;
+  }
+  return nullptr;
+}
+
+static Keyboard::Keycode Keysym(int keysym) {
+  switch(keysym) {
+  case XK_Escape: return Keyboard::Keycode::Escape;
+  case XK_F1: return Keyboard::Keycode::F1;
+  case XK_F2: return Keyboard::Keycode::F2;
+  case XK_F3: return Keyboard::Keycode::F3;
+  case XK_F4: return Keyboard::Keycode::F4;
+  case XK_F5: return Keyboard::Keycode::F5;
+  case XK_F6: return Keyboard::Keycode::F6;
+  case XK_F7: return Keyboard::Keycode::F7;
+  case XK_F8: return Keyboard::Keycode::F8;
+  case XK_F9: return Keyboard::Keycode::F9;
+  case XK_F10: return Keyboard::Keycode::F10;
+  case XK_F11: return Keyboard::Keycode::F11;
+  case XK_F12: return Keyboard::Keycode::F12;
+
+  case XK_Print: return Keyboard::Keycode::PrintScreen;
+  //Keyboard::Keycode::SysRq
+  case XK_Scroll_Lock: return Keyboard::Keycode::ScrollLock;
+  case XK_Pause: return Keyboard::Keycode::Pause;
+  //Keyboard::Keycode::Break
+
+  case XK_Insert: return Keyboard::Keycode::Insert;
+  case XK_Delete: return Keyboard::Keycode::Delete;
+  case XK_Home: return Keyboard::Keycode::Home;
+  case XK_End: return Keyboard::Keycode::End;
+  case XK_Prior: return Keyboard::Keycode::PageUp;
+  case XK_Next: return Keyboard::Keycode::PageDown;
+
+  case XK_Up: return Keyboard::Keycode::Up;
+  case XK_Down: return Keyboard::Keycode::Down;
+  case XK_Left: return Keyboard::Keycode::Left;
+  case XK_Right: return Keyboard::Keycode::Right;
+
+  case XK_grave: return Keyboard::Keycode::Grave;
+  case XK_1: return Keyboard::Keycode::Number1;
+  case XK_2: return Keyboard::Keycode::Number2;
+  case XK_3: return Keyboard::Keycode::Number3;
+  case XK_4: return Keyboard::Keycode::Number4;
+  case XK_5: return Keyboard::Keycode::Number5;
+  case XK_6: return Keyboard::Keycode::Number6;
+  case XK_7: return Keyboard::Keycode::Number7;
+  case XK_8: return Keyboard::Keycode::Number8;
+  case XK_9: return Keyboard::Keycode::Number9;
+  case XK_0: return Keyboard::Keycode::Number0;
+  case XK_minus: return Keyboard::Keycode::Minus;
+  case XK_equal: return Keyboard::Keycode::Equal;
+  case XK_BackSpace: return Keyboard::Keycode::Backspace;
+
+  case XK_asciitilde: return Keyboard::Keycode::Tilde;
+  case XK_exclam: return Keyboard::Keycode::Exclamation;
+  case XK_at: return Keyboard::Keycode::At;
+  case XK_numbersign: return Keyboard::Keycode::Pound;
+  case XK_dollar: return Keyboard::Keycode::Dollar;
+  case XK_percent: return Keyboard::Keycode::Percent;
+  case XK_asciicircum: return Keyboard::Keycode::Power;
+  case XK_ampersand: return Keyboard::Keycode::Ampersand;
+  case XK_asterisk: return Keyboard::Keycode::Asterisk;
+  case XK_parenleft: return Keyboard::Keycode::ParenthesisLeft;
+  case XK_parenright: return Keyboard::Keycode::ParenthesisRight;
+  case XK_underscore: return Keyboard::Keycode::Underscore;
+  case XK_plus: return Keyboard::Keycode::Plus;
+
+  case XK_bracketleft: return Keyboard::Keycode::BracketLeft;
+  case XK_bracketright: return Keyboard::Keycode::BracketRight;
+  case XK_backslash: return Keyboard::Keycode::Backslash;
+  case XK_semicolon: return Keyboard::Keycode::Semicolon;
+  case XK_apostrophe: return Keyboard::Keycode::Apostrophe;
+  case XK_comma: return Keyboard::Keycode::Comma;
+  case XK_period: return Keyboard::Keycode::Period;
+  case XK_slash: return Keyboard::Keycode::Slash;
+
+  case XK_braceleft: return Keyboard::Keycode::BraceLeft;
+  case XK_braceright: return Keyboard::Keycode::BraceRight;
+  case XK_bar: return Keyboard::Keycode::Pipe;
+  case XK_colon: return Keyboard::Keycode::Colon;
+  case XK_quotedbl: return Keyboard::Keycode::Quote;
+  case XK_less: return Keyboard::Keycode::CaretLeft;
+  case XK_greater: return Keyboard::Keycode::CaretRight;
+  case XK_question: return Keyboard::Keycode::Question;
+
+  case XK_Tab: return Keyboard::Keycode::Tab;
+  case XK_Caps_Lock: return Keyboard::Keycode::CapsLock;
+  case XK_Return: return Keyboard::Keycode::Return;
+  case XK_Shift_L: return Keyboard::Keycode::ShiftLeft;
+  case XK_Shift_R: return Keyboard::Keycode::ShiftRight;
+  case XK_Control_L: return Keyboard::Keycode::ControlLeft;
+  case XK_Control_R: return Keyboard::Keycode::ControlRight;
+  case XK_Super_L: return Keyboard::Keycode::SuperLeft;
+  case XK_Super_R: return Keyboard::Keycode::SuperRight;
+  case XK_Alt_L: return Keyboard::Keycode::AltLeft;
+  case XK_Alt_R: return Keyboard::Keycode::AltRight;
+  case XK_space: return Keyboard::Keycode::Space;
+  case XK_Menu: return Keyboard::Keycode::Menu;
+
+  case XK_A: return Keyboard::Keycode::A;
+  case XK_B: return Keyboard::Keycode::B;
+  case XK_C: return Keyboard::Keycode::C;
+  case XK_D: return Keyboard::Keycode::D;
+  case XK_E: return Keyboard::Keycode::E;
+  case XK_F: return Keyboard::Keycode::F;
+  case XK_G: return Keyboard::Keycode::G;
+  case XK_H: return Keyboard::Keycode::H;
+  case XK_I: return Keyboard::Keycode::I;
+  case XK_J: return Keyboard::Keycode::J;
+  case XK_K: return Keyboard::Keycode::K;
+  case XK_L: return Keyboard::Keycode::L;
+  case XK_M: return Keyboard::Keycode::M;
+  case XK_N: return Keyboard::Keycode::N;
+  case XK_O: return Keyboard::Keycode::O;
+  case XK_P: return Keyboard::Keycode::P;
+  case XK_Q: return Keyboard::Keycode::Q;
+  case XK_R: return Keyboard::Keycode::R;
+  case XK_S: return Keyboard::Keycode::S;
+  case XK_T: return Keyboard::Keycode::T;
+  case XK_U: return Keyboard::Keycode::U;
+  case XK_V: return Keyboard::Keycode::V;
+  case XK_W: return Keyboard::Keycode::W;
+  case XK_X: return Keyboard::Keycode::X;
+  case XK_Y: return Keyboard::Keycode::Y;
+  case XK_Z: return Keyboard::Keycode::Z;
+
+  case XK_a: return Keyboard::Keycode::a;
+  case XK_b: return Keyboard::Keycode::b;
+  case XK_c: return Keyboard::Keycode::c;
+  case XK_d: return Keyboard::Keycode::d;
+  case XK_e: return Keyboard::Keycode::e;
+  case XK_f: return Keyboard::Keycode::f;
+  case XK_g: return Keyboard::Keycode::g;
+  case XK_h: return Keyboard::Keycode::h;
+  case XK_i: return Keyboard::Keycode::i;
+  case XK_j: return Keyboard::Keycode::j;
+  case XK_k: return Keyboard::Keycode::k;
+  case XK_l: return Keyboard::Keycode::l;
+  case XK_m: return Keyboard::Keycode::m;
+  case XK_n: return Keyboard::Keycode::n;
+  case XK_o: return Keyboard::Keycode::o;
+  case XK_p: return Keyboard::Keycode::p;
+  case XK_q: return Keyboard::Keycode::q;
+  case XK_r: return Keyboard::Keycode::r;
+  case XK_s: return Keyboard::Keycode::s;
+  case XK_t: return Keyboard::Keycode::t;
+  case XK_u: return Keyboard::Keycode::u;
+  case XK_v: return Keyboard::Keycode::v;
+  case XK_w: return Keyboard::Keycode::w;
+  case XK_x: return Keyboard::Keycode::x;
+  case XK_y: return Keyboard::Keycode::y;
+  case XK_z: return Keyboard::Keycode::z;
+
+  case XK_Num_Lock: return Keyboard::Keycode::NumLock;
+  case XK_KP_Divide: return Keyboard::Keycode::Divide;
+  case XK_KP_Multiply: return Keyboard::Keycode::Multiply;
+  case XK_KP_Subtract: return Keyboard::Keycode::Subtract;
+  case XK_KP_Add: return Keyboard::Keycode::Add;
+  case XK_KP_Enter: return Keyboard::Keycode::Enter;
+  case XK_KP_Decimal: return Keyboard::Keycode::Point;
+
+  case XK_KP_1: return Keyboard::Keycode::Keypad1;
+  case XK_KP_2: return Keyboard::Keycode::Keypad2;
+  case XK_KP_3: return Keyboard::Keycode::Keypad3;
+  case XK_KP_4: return Keyboard::Keycode::Keypad4;
+  case XK_KP_5: return Keyboard::Keycode::Keypad5;
+  case XK_KP_6: return Keyboard::Keycode::Keypad6;
+  case XK_KP_7: return Keyboard::Keycode::Keypad7;
+  case XK_KP_8: return Keyboard::Keycode::Keypad8;
+  case XK_KP_9: return Keyboard::Keycode::Keypad9;
+  case XK_KP_0: return Keyboard::Keycode::Keypad0;
+
+  case XK_KP_Home: return Keyboard::Keycode::KeypadHome;
+  case XK_KP_End: return Keyboard::Keycode::KeypadEnd;
+  case XK_KP_Page_Up: return Keyboard::Keycode::KeypadPageUp;
+  case XK_KP_Page_Down: return Keyboard::Keycode::KeypadPageDown;
+  case XK_KP_Up: return Keyboard::Keycode::KeypadUp;
+  case XK_KP_Down: return Keyboard::Keycode::KeypadDown;
+  case XK_KP_Left: return Keyboard::Keycode::KeypadLeft;
+  case XK_KP_Right: return Keyboard::Keycode::KeypadRight;
+  case XK_KP_Begin: return Keyboard::Keycode::KeypadCenter;
+  case XK_KP_Insert: return Keyboard::Keycode::KeypadInsert;
+  case XK_KP_Delete: return Keyboard::Keycode::KeypadDelete;
+  }
+  return Keyboard::Keycode::None;
+}
+
+}
diff -Nru higan/phoenix/qt/widget/button.cpp nSide/phoenix/qt/widget/button.cpp
--- higan/phoenix/qt/widget/button.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/qt/widget/button.cpp	2015-09-16 13:08:13.545563367 +0900
@@ -0,0 +1,62 @@
+namespace phoenix {
+
+Size pButton::minimumSize() {
+  Size size = pFont::size(qtWidget->font(), button.state.text);
+
+  if(button.state.orientation == Orientation::Horizontal) {
+    size.width += button.state.image.width();
+    size.height = max(button.state.image.height(), size.height);
+  }
+
+  if(button.state.orientation == Orientation::Vertical) {
+    size.width = max(button.state.image.width(), size.width);
+    size.height += button.state.image.height();
+  }
+
+  return {size.width + (button.state.text ? 20 : 12), size.height + 12};
+}
+
+void pButton::setBordered(bool bordered) {
+  qtButton->setAutoRaise(bordered == false);
+}
+
+void pButton::setImage(const image& image, Orientation orientation) {
+  qtButton->setIconSize(QSize(image.width(), image.height()));
+  qtButton->setIcon(CreateIcon(image));
+  qtButton->setStyleSheet("text-align: top;");
+  switch(orientation) {
+  case Orientation::Horizontal: qtButton->setToolButtonStyle(Qt::ToolButtonTextBesideIcon); break;
+  case Orientation::Vertical:   qtButton->setToolButtonStyle(Qt::ToolButtonTextUnderIcon);  break;
+  }
+}
+
+void pButton::setText(string text) {
+  qtButton->setText(QString::fromUtf8(text));
+}
+
+void pButton::constructor() {
+  qtWidget = qtButton = new QToolButton;
+  qtButton->setToolButtonStyle(Qt::ToolButtonTextOnly);
+  connect(qtButton, SIGNAL(released()), SLOT(onActivate()));
+
+  pWidget::synchronizeState();
+  setBordered(button.state.bordered);
+  setImage(button.state.image, button.state.orientation);
+  setText(button.state.text);
+}
+
+void pButton::destructor() {
+  delete qtButton;
+  qtWidget = qtButton = nullptr;
+}
+
+void pButton::orphan() {
+  destructor();
+  constructor();
+}
+
+void pButton::onActivate() {
+  if(button.onActivate) button.onActivate();
+}
+
+}
diff -Nru higan/phoenix/qt/widget/canvas.cpp nSide/phoenix/qt/widget/canvas.cpp
--- higan/phoenix/qt/widget/canvas.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/qt/widget/canvas.cpp	2015-09-16 13:08:13.546563367 +0900
@@ -0,0 +1,155 @@
+namespace phoenix {
+
+void pCanvas::setDroppable(bool droppable) {
+  qtCanvas->setAcceptDrops(droppable);
+}
+
+void pCanvas::setGeometry(Geometry geometry) {
+  if(canvas.state.width == 0 || canvas.state.height == 0) rasterize();
+  unsigned width = canvas.state.width;
+  unsigned height = canvas.state.height;
+  if(width == 0) width = widget.state.geometry.width;
+  if(height == 0) height = widget.state.geometry.height;
+
+  if(width < geometry.width) {
+    geometry.x += (geometry.width - width) / 2;
+    geometry.width = width;
+  }
+
+  if(height < geometry.height) {
+    geometry.y += (geometry.height - height) / 2;
+    geometry.height = height;
+  }
+
+  pWidget::setGeometry(geometry);
+}
+
+void pCanvas::setMode(Canvas::Mode mode) {
+  rasterize();
+  qtCanvas->update();
+}
+
+void pCanvas::setSize(Size size) {
+  rasterize();
+  qtCanvas->update();
+}
+
+void pCanvas::constructor() {
+  qtWidget = qtCanvas = new QtCanvas(*this);
+  qtCanvas->setMouseTracking(true);
+
+  pWidget::synchronizeState();
+  rasterize(), qtCanvas->update();
+}
+
+void pCanvas::destructor() {
+  release();
+  delete qtCanvas;
+  qtWidget = qtCanvas = nullptr;
+}
+
+void pCanvas::orphan() {
+  destructor();
+  constructor();
+}
+
+void pCanvas::rasterize() {
+  unsigned width = canvas.state.width;
+  unsigned height = canvas.state.height;
+  if(width == 0) width = widget.state.geometry.width;
+  if(height == 0) height = widget.state.geometry.height;
+
+  if(canvas.state.mode != Canvas::Mode::Color) {
+    if(width != surfaceWidth || height != surfaceHeight) release();
+    if(!surface) surface = new QImage(width, height, QImage::Format_ARGB32);
+  }
+
+  if(canvas.state.mode == Canvas::Mode::Gradient) {
+    nall::image image;
+    image.allocate(width, height);
+    image.gradient(
+      canvas.state.gradient[0].argb(), canvas.state.gradient[1].argb(), canvas.state.gradient[2].argb(), canvas.state.gradient[3].argb()
+    );
+    memcpy(surface->bits(), image.data(), image.size());
+  }
+
+  if(canvas.state.mode == Canvas::Mode::Image) {
+    nall::image image = canvas.state.image;
+    image.scale(width, height);
+    image.transform(0, 32, 255u << 24, 255u << 16, 255u << 8, 255u << 0);
+    memcpy(surface->bits(), image.data(), image.size());
+  }
+
+  if(canvas.state.mode == Canvas::Mode::Data) {
+    if(width == canvas.state.width && height == canvas.state.height) {
+      memcpy(surface->bits(), canvas.state.data, width * height * sizeof(uint32_t));
+    } else {
+      memset(surface->bits(), 0x00, width * height * sizeof(uint32_t));
+    }
+  }
+
+  surfaceWidth = width;
+  surfaceHeight = height;
+}
+
+void pCanvas::release() {
+  if(surface == nullptr) return;
+  delete surface;
+  surface = nullptr;
+  surfaceWidth = 0;
+  surfaceHeight = 0;
+}
+
+void pCanvas::QtCanvas::dragEnterEvent(QDragEnterEvent* event) {
+  if(event->mimeData()->hasUrls()) {
+    event->acceptProposedAction();
+  }
+}
+
+void pCanvas::QtCanvas::dropEvent(QDropEvent* event) {
+  lstring paths = DropPaths(event);
+  if(paths.empty()) return;
+  if(self.canvas.onDrop) self.canvas.onDrop(paths);
+}
+
+void pCanvas::QtCanvas::leaveEvent(QEvent* event) {
+  if(self.canvas.onMouseLeave) self.canvas.onMouseLeave();
+}
+
+void pCanvas::QtCanvas::mouseMoveEvent(QMouseEvent* event) {
+  if(self.canvas.onMouseMove) self.canvas.onMouseMove({event->pos().x(), event->pos().y()});
+}
+
+void pCanvas::QtCanvas::mousePressEvent(QMouseEvent* event) {
+  if(!self.canvas.onMousePress) return;
+  switch(event->button()) {
+  case Qt::LeftButton: self.canvas.onMousePress(Mouse::Button::Left); break;
+  case Qt::MidButton: self.canvas.onMousePress(Mouse::Button::Middle); break;
+  case Qt::RightButton: self.canvas.onMousePress(Mouse::Button::Right); break;
+  }
+}
+
+void pCanvas::QtCanvas::mouseReleaseEvent(QMouseEvent* event) {
+  if(!self.canvas.onMouseRelease) return;
+  switch(event->button()) {
+  case Qt::LeftButton: self.canvas.onMouseRelease(Mouse::Button::Left); break;
+  case Qt::MidButton: self.canvas.onMouseRelease(Mouse::Button::Middle); break;
+  case Qt::RightButton: self.canvas.onMouseRelease(Mouse::Button::Right); break;
+  }
+}
+
+void pCanvas::QtCanvas::paintEvent(QPaintEvent* event) {
+  Canvas& canvas = self.canvas;
+  QPainter painter(self.qtCanvas);
+
+  if(canvas.state.mode == Canvas::Mode::Color) {
+    painter.fillRect(event->rect(), QBrush(QColor(canvas.state.color.red, canvas.state.color.green, canvas.state.color.blue, canvas.state.color.alpha)));
+  } else {
+    painter.drawImage(0, 0, *self.surface);
+  }
+}
+
+pCanvas::QtCanvas::QtCanvas(pCanvas& self) : self(self) {
+}
+
+}
diff -Nru higan/phoenix/qt/widget/check-button.cpp nSide/phoenix/qt/widget/check-button.cpp
--- higan/phoenix/qt/widget/check-button.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/qt/widget/check-button.cpp	2015-09-16 13:08:13.546563367 +0900
@@ -0,0 +1,63 @@
+namespace phoenix {
+
+Size pCheckButton::minimumSize() {
+  Size size = pFont::size(qtWidget->font(), checkButton.state.text);
+
+  if(checkButton.state.orientation == Orientation::Horizontal) {
+    size.width += checkButton.state.image.width();
+    size.height = max(checkButton.state.image.height(), size.height);
+  }
+
+  if(checkButton.state.orientation == Orientation::Vertical) {
+    size.width = max(checkButton.state.image.width(), size.width);
+    size.height += checkButton.state.image.height();
+  }
+
+  return {size.width + 20, size.height + 12};
+}
+
+void pCheckButton::setChecked(bool checked) {
+  lock();
+  qtCheckButton->setChecked(checked);
+  unlock();
+}
+
+void pCheckButton::setImage(const image& image, Orientation orientation) {
+  qtCheckButton->setIconSize(QSize(image.width(), image.height()));
+  qtCheckButton->setIcon(CreateIcon(image));
+  qtCheckButton->setStyleSheet("text-align: top;");
+  switch(orientation) {
+  case Orientation::Horizontal: qtCheckButton->setToolButtonStyle(Qt::ToolButtonTextBesideIcon); break;
+  case Orientation::Vertical:   qtCheckButton->setToolButtonStyle(Qt::ToolButtonTextUnderIcon); break;
+  }
+}
+
+void pCheckButton::setText(string text) {
+  qtCheckButton->setText(QString::fromUtf8(text));
+}
+
+void pCheckButton::constructor() {
+  qtWidget = qtCheckButton = new QToolButton;
+  qtCheckButton->setCheckable(true);
+  qtCheckButton->setToolButtonStyle(Qt::ToolButtonTextOnly);
+  connect(qtCheckButton, SIGNAL(toggled(bool)), SLOT(onToggle(bool)));
+
+  pWidget::synchronizeState();
+  setChecked(checkButton.state.checked);
+  setText(checkButton.state.text);
+}
+
+void pCheckButton::destructor() {
+}
+
+void pCheckButton::orphan() {
+  destructor();
+  constructor();
+}
+
+void pCheckButton::onToggle(bool checked) {
+  checkButton.state.checked = checked;
+  if(!locked() && checkButton.onToggle) checkButton.onToggle();
+}
+
+}
diff -Nru higan/phoenix/qt/widget/check-label.cpp nSide/phoenix/qt/widget/check-label.cpp
--- higan/phoenix/qt/widget/check-label.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/qt/widget/check-label.cpp	2015-09-16 13:08:13.546563367 +0900
@@ -0,0 +1,42 @@
+namespace phoenix {
+
+Size pCheckLabel::minimumSize() {
+  Size size = pFont::size(qtWidget->font(), checkLabel.state.text);
+  return {size.width + 26, size.height + 6};
+}
+
+void pCheckLabel::setChecked(bool checked) {
+  lock();
+  qtCheckLabel->setChecked(checked);
+  unlock();
+}
+
+void pCheckLabel::setText(string text) {
+  qtCheckLabel->setText(QString::fromUtf8(text));
+}
+
+void pCheckLabel::constructor() {
+  qtWidget = qtCheckLabel = new QCheckBox;
+  connect(qtCheckLabel, SIGNAL(stateChanged(int)), SLOT(onToggle()));
+
+  pWidget::synchronizeState();
+  setChecked(checkLabel.state.checked);
+  setText(checkLabel.state.text);
+}
+
+void pCheckLabel::destructor() {
+  delete qtCheckLabel;
+  qtWidget = qtCheckLabel = nullptr;
+}
+
+void pCheckLabel::orphan() {
+  destructor();
+  constructor();
+}
+
+void pCheckLabel::onToggle() {
+  checkLabel.state.checked = qtCheckLabel->isChecked();
+  if(!locked() && checkLabel.onToggle) checkLabel.onToggle();
+}
+
+}
diff -Nru higan/phoenix/qt/widget/combo-button.cpp nSide/phoenix/qt/widget/combo-button.cpp
--- higan/phoenix/qt/widget/combo-button.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/qt/widget/combo-button.cpp	2015-09-16 13:08:13.546563367 +0900
@@ -0,0 +1,67 @@
+namespace phoenix {
+
+void pComboButton::append() {
+  lock();
+  qtComboButton->addItem("");
+  unlock();
+}
+
+Size pComboButton::minimumSize() {
+  unsigned maximumWidth = 0;
+  for(auto& text : comboButton.state.text) maximumWidth = max(maximumWidth, pFont::size(qtWidget->font(), text).width);
+  Size size = pFont::size(qtWidget->font(), " ");
+  return {maximumWidth + 32, size.height + 12};
+}
+
+void pComboButton::remove(unsigned selection) {
+  lock();
+  qtComboButton->removeItem(selection);
+  if(selection == comboButton.state.selection) comboButton[0].setSelected();
+  unlock();
+}
+
+void pComboButton::reset() {
+  lock();
+  while(qtComboButton->count()) qtComboButton->removeItem(0);
+  unlock();
+}
+
+void pComboButton::setSelected(unsigned selection) {
+  lock();
+  qtComboButton->setCurrentIndex(selection);
+  unlock();
+}
+
+void pComboButton::setText(unsigned selection, string text) {
+  qtComboButton->setItemText(selection, text);
+}
+
+void pComboButton::constructor() {
+  qtWidget = qtComboButton = new QComboBox;
+  connect(qtComboButton, SIGNAL(currentIndexChanged(int)), SLOT(onChange()));
+
+  pWidget::synchronizeState();
+  unsigned selection = comboButton.state.selection;
+  for(unsigned n = 0; n < comboButton.count(); n++) {
+    append();
+    setText(n, comboButton.state.text[n]);
+  }
+  comboButton[selection].setSelected();
+}
+
+void pComboButton::destructor() {
+  delete qtComboButton;
+  qtWidget = qtComboButton = nullptr;
+}
+
+void pComboButton::orphan() {
+  destructor();
+  constructor();
+}
+
+void pComboButton::onChange() {
+  comboButton.state.selection = qtComboButton->currentIndex();
+  if(!locked() && comboButton.onChange) comboButton.onChange();
+}
+
+}
diff -Nru higan/phoenix/qt/widget/console.cpp nSide/phoenix/qt/widget/console.cpp
--- higan/phoenix/qt/widget/console.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/qt/widget/console.cpp	2015-09-16 13:08:13.547563367 +0900
@@ -0,0 +1,52 @@
+namespace phoenix {
+
+void pConsole::print(string text) {
+}
+
+void pConsole::reset() {
+}
+
+void pConsole::setBackgroundColor(Color color) {
+  QPalette palette = qtConsole->palette();
+  palette.setColor(QPalette::Base, QColor(color.red, color.green, color.blue));
+  qtConsole->setPalette(palette);
+  qtConsole->setAutoFillBackground(true);
+}
+
+void pConsole::setForegroundColor(Color color) {
+  QPalette palette = qtConsole->palette();
+  palette.setColor(QPalette::Text, QColor(color.red, color.green, color.blue));
+  qtConsole->setPalette(palette);
+}
+
+void pConsole::setPrompt(string prompt) {
+}
+
+void pConsole::constructor() {
+  qtWidget = qtConsole = new QtConsole(*this);
+
+  pWidget::synchronizeState();
+}
+
+void pConsole::destructor() {
+  delete qtConsole;
+  qtWidget = qtConsole = nullptr;
+}
+
+void pConsole::orphan() {
+  destructor();
+  constructor();
+}
+
+void pConsole::keyPressEvent(QKeyEvent* event) {
+}
+
+void pConsole::QtConsole::keyPressEvent(QKeyEvent* event) {
+  self.keyPressEvent(event);
+}
+
+void pConsole::QtConsole::keyPressEventAcknowledge(QKeyEvent* event) {
+  QTextEdit::keyPressEvent(event);
+}
+
+}
diff -Nru higan/phoenix/qt/widget/frame.cpp nSide/phoenix/qt/widget/frame.cpp
--- higan/phoenix/qt/widget/frame.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/qt/widget/frame.cpp	2015-09-16 13:08:13.547563367 +0900
@@ -0,0 +1,52 @@
+namespace phoenix {
+
+void pFrame::setEnabled(bool enabled) {
+  if(frame.state.layout) frame.state.layout->setEnabled(frame.state.layout->enabled());
+  pWidget::setEnabled(enabled);
+}
+
+void pFrame::setGeometry(Geometry geometry) {
+  pWidget::setGeometry(geometry);
+  if(frame.state.layout == nullptr) return;
+  Size size = pFont::size(widget.state.font, frame.state.text);
+  if(frame.state.text.empty()) size.height = 8;
+  geometry.x += 1, geometry.width -= 2;
+  geometry.y += size.height, geometry.height -= size.height + 1;
+  frame.state.layout->setGeometry(geometry);
+}
+
+void pFrame::setText(string text) {
+  qtFrame->setTitle(QString::fromUtf8(text));
+}
+
+void pFrame::setVisible(bool visible) {
+  if(frame.state.layout) frame.state.layout->setVisible(frame.state.layout->visible());
+  pWidget::setVisible(visible);
+}
+
+void pFrame::constructor() {
+  qtWidget = qtFrame = new QGroupBox;
+  if(QApplication::style()->objectName() == "gtk+") {
+    //QGtkStyle (gtk+) theme disrespects font weight and omits the border, even if native GTK+ theme does not
+    //bold Label controls already exist; so this style sheet forces QGtkStyle to look like a Frame instead
+    qtFrame->setStyleSheet(
+      "QGroupBox { border: 1px solid #aaa; border-radius: 5px; margin-top: 0.5em; }\n"
+      "QGroupBox::title { left: 5px; subcontrol-origin: margin; }\n"
+    );
+  }
+
+  pWidget::synchronizeState();
+  setText(frame.state.text);
+}
+
+void pFrame::destructor() {
+  delete qtFrame;
+  qtWidget = qtFrame = nullptr;
+}
+
+void pFrame::orphan() {
+  destructor();
+  constructor();
+}
+
+}
diff -Nru higan/phoenix/qt/widget/hex-edit.cpp nSide/phoenix/qt/widget/hex-edit.cpp
--- higan/phoenix/qt/widget/hex-edit.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/qt/widget/hex-edit.cpp	2015-09-16 13:08:13.550563367 +0900
@@ -0,0 +1,298 @@
+namespace phoenix {
+
+void pHexEdit::setBackgroundColor(Color color) {
+  QPalette palette = qtHexEdit->palette();
+  palette.setColor(QPalette::Base, QColor(color.red, color.green, color.blue));
+  qtHexEdit->setPalette(palette);
+  qtHexEdit->setAutoFillBackground(true);
+}
+
+void pHexEdit::setColumns(unsigned columns) {
+  update();
+}
+
+void pHexEdit::setForegroundColor(Color color) {
+  QPalette palette = qtHexEdit->palette();
+  palette.setColor(QPalette::Text, QColor(color.red, color.green, color.blue));
+  qtHexEdit->setPalette(palette);
+}
+
+void pHexEdit::setLength(unsigned length) {
+  //add one if last row is not equal to column length (eg only part of the row is present)
+  bool indivisible = hexEdit.state.columns == 0 || (hexEdit.state.length % hexEdit.state.columns) != 0;
+  qtScroll->setRange(0, hexEdit.state.length / hexEdit.state.columns + indivisible - hexEdit.state.rows);
+  update();
+}
+
+void pHexEdit::setOffset(unsigned offset) {
+  lock();
+  qtScroll->setSliderPosition(hexEdit.state.offset / hexEdit.state.columns);
+  unlock();
+  update();
+}
+
+void pHexEdit::setRows(unsigned rows) {
+  qtScroll->setPageStep(hexEdit.state.rows);
+  update();
+}
+
+void pHexEdit::update() {
+  if(!hexEdit.onRead) {
+    qtHexEdit->setPlainText("");
+    return;
+  }
+
+  unsigned cursorPosition = qtHexEdit->textCursor().position();
+
+  string output;
+  unsigned offset = hexEdit.state.offset;
+  for(unsigned row = 0; row < hexEdit.state.rows; row++) {
+    output.append(hex(offset, 8L));
+    output.append("  ");
+
+    string hexdata;
+    string ansidata = " ";
+
+    for(unsigned column = 0; column < hexEdit.state.columns; column++) {
+      if(offset < hexEdit.state.length) {
+        uint8_t data = hexEdit.onRead(offset++);
+        hexdata.append(hex(data, 2L));
+        hexdata.append(" ");
+        ansidata.append(data >= 0x20 && data <= 0x7e ? (char)data : '.');
+      } else {
+        hexdata.append("   ");
+        ansidata.append(" ");
+      }
+    }
+
+    output.append(hexdata);
+    output.append(ansidata);
+    if(offset >= hexEdit.state.length) break;
+    if(row != hexEdit.state.rows - 1) output.append("\n");
+  }
+
+  qtHexEdit->setPlainText(QString::fromUtf8(output));
+  QTextCursor cursor = qtHexEdit->textCursor();
+  cursor.setPosition(cursorPosition);
+  qtHexEdit->setTextCursor(cursor);
+}
+
+void pHexEdit::constructor() {
+  qtWidget = qtHexEdit = new QtHexEdit(*this);
+
+  qtHexEdit->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
+  qtHexEdit->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
+  qtHexEdit->setTextInteractionFlags(Qt::TextSelectableByKeyboard | Qt::TextSelectableByMouse);
+
+  qtLayout = new QHBoxLayout;
+  qtLayout->setAlignment(Qt::AlignRight);
+  qtLayout->setMargin(0);
+  qtLayout->setSpacing(0);
+  qtHexEdit->setLayout(qtLayout);
+
+  qtScroll = new QtHexEditScrollBar(*this);
+  qtScroll->setSingleStep(1);
+  qtLayout->addWidget(qtScroll);
+
+  connect(qtScroll, SIGNAL(actionTriggered(int)), SLOT(onScroll()));
+
+  pWidget::synchronizeState();
+  setColumns(hexEdit.state.columns);
+  setRows(hexEdit.state.rows);
+  setLength(hexEdit.state.length);
+  setOffset(hexEdit.state.offset);
+  update();
+}
+
+void pHexEdit::destructor() {
+  delete qtScroll;
+  delete qtLayout;
+  delete qtHexEdit;
+  qtWidget = qtHexEdit = nullptr;
+  qtLayout = nullptr;
+  qtScroll = nullptr;
+}
+
+void pHexEdit::orphan() {
+  destructor();
+  constructor();
+}
+
+void pHexEdit::keyPressEvent(QKeyEvent* event) {
+  if(!hexEdit.onRead) return;
+
+  //allow Ctrl+C (copy)
+  if(event->key() == Qt::Key_C && event->modifiers() == Qt::ControlModifier) {
+    qtHexEdit->keyPressEventAcknowledge(event);
+    return;
+  }
+
+  //disallow other text operations (cut, paste, etc)
+  if(event->modifiers() & (Qt::ControlModifier | Qt::AltModifier | Qt::MetaModifier)) return;
+
+  QTextCursor cursor = qtHexEdit->textCursor();
+  signed lineWidth = 10 + (hexEdit.state.columns * 3) + 1 + hexEdit.state.columns + 1;
+  signed cursorY = cursor.position() / lineWidth;
+  signed cursorX = cursor.position() % lineWidth;
+
+  unsigned nibble = 0;
+  switch(event->key()) {
+  default: return;
+
+  case Qt::Key_Left:
+    if(cursorX > 0) {
+      cursor.setPosition(cursor.position() - 1);
+      qtHexEdit->setTextCursor(cursor);
+    }
+    return;
+
+  case Qt::Key_Right:
+    if(cursorX < lineWidth - 1) {
+      cursor.setPosition(cursor.position() + 1);
+      qtHexEdit->setTextCursor(cursor);
+    }
+    return;
+
+  case Qt::Key_Home:
+    cursor.setPosition(cursorY * lineWidth + 10);
+    qtHexEdit->setTextCursor(cursor);
+    return;
+
+  case Qt::Key_End:
+    cursor.setPosition(cursorY * lineWidth + 57);
+    qtHexEdit->setTextCursor(cursor);
+    return;
+
+  case Qt::Key_Up:
+    if(cursorY > 0) {
+      cursor.setPosition(cursor.position() - lineWidth);
+      qtHexEdit->setTextCursor(cursor);
+    } else {
+      scrollTo(qtScroll->sliderPosition() - 1);
+    }
+    return;
+
+  case Qt::Key_Down:
+    if(cursorY >= rows() - 1) {
+      //cannot scroll down further
+    } else if(cursorY < hexEdit.state.rows - 1) {
+      cursor.setPosition(cursor.position() + lineWidth);
+      qtHexEdit->setTextCursor(cursor);
+    } else {
+      scrollTo(qtScroll->sliderPosition() + 1);
+    }
+    return;
+
+  case Qt::Key_PageUp:
+    scrollTo(qtScroll->sliderPosition() - hexEdit.state.rows);
+    return;
+
+  case Qt::Key_PageDown:
+    scrollTo(qtScroll->sliderPosition() + hexEdit.state.rows);
+    return;
+
+  case Qt::Key_0: nibble =  0; break;
+  case Qt::Key_1: nibble =  1; break;
+  case Qt::Key_2: nibble =  2; break;
+  case Qt::Key_3: nibble =  3; break;
+  case Qt::Key_4: nibble =  4; break;
+  case Qt::Key_5: nibble =  5; break;
+  case Qt::Key_6: nibble =  6; break;
+  case Qt::Key_7: nibble =  7; break;
+  case Qt::Key_8: nibble =  8; break;
+  case Qt::Key_9: nibble =  9; break;
+  case Qt::Key_A: nibble = 10; break;
+  case Qt::Key_B: nibble = 11; break;
+  case Qt::Key_C: nibble = 12; break;
+  case Qt::Key_D: nibble = 13; break;
+  case Qt::Key_E: nibble = 14; break;
+  case Qt::Key_F: nibble = 15; break;
+  }
+
+  if(cursorX >= 10) {
+    //not on an offset
+    cursorX -= 10;
+    if((cursorX % 3) != 2) {
+      //not on a space
+      bool cursorNibble = (cursorX % 3) == 1;  //0 = high, 1 = low
+      cursorX /= 3;
+      if(cursorX < hexEdit.state.columns) {
+        //not in ANSI region
+        unsigned offset = hexEdit.state.offset + (cursorY * hexEdit.state.columns + cursorX);
+
+        if(offset >= hexEdit.state.length) return;  //do not edit past end of file
+        uint8_t data = hexEdit.onRead(offset);
+
+        //write modified value
+        if(cursorNibble == 1) {
+          data = (data & 0xf0) | (nibble << 0);
+        } else {
+          data = (data & 0x0f) | (nibble << 4);
+        }
+        if(hexEdit.onWrite) hexEdit.onWrite(offset, data);
+
+        //auto-advance cursor to next nibble/byte
+        unsigned step = 1;
+        if(cursorNibble && cursorX != hexEdit.state.columns - 1) step = 2;
+        cursor.setPosition(cursor.position() + step);
+        qtHexEdit->setTextCursor(cursor);
+
+        //refresh output to reflect modified data
+        update();
+      }
+    }
+  }
+}
+
+//number of actual rows
+signed pHexEdit::rows() {
+  return (max(1u, hexEdit.state.length) + hexEdit.state.columns - 1) / hexEdit.state.columns;
+}
+
+//number of scrollable row positions
+signed pHexEdit::rowsScrollable() {
+  return max(0u, rows() - hexEdit.state.rows);
+}
+
+void pHexEdit::scrollTo(signed position) {
+  if(position > rowsScrollable()) position = rowsScrollable();
+  if(position < 0) position = 0;
+  qtScroll->setSliderPosition(position);
+}
+
+void pHexEdit::onScroll() {
+  if(locked()) return;
+  unsigned offset = qtScroll->sliderPosition();
+  hexEdit.state.offset = offset * hexEdit.state.columns;
+  update();
+}
+
+void pHexEdit::QtHexEdit::keyPressEvent(QKeyEvent* event) {
+  self.keyPressEvent(event);
+}
+
+void pHexEdit::QtHexEdit::keyPressEventAcknowledge(QKeyEvent* event) {
+  QTextEdit::keyPressEvent(event);
+}
+
+void pHexEdit::QtHexEdit::wheelEvent(QWheelEvent* event) {
+  if(event->orientation() == Qt::Vertical) {
+    signed offset = event->delta() < 0 ? +1 : -1;
+    self.scrollTo(self.qtScroll->sliderPosition() + offset);
+    event->accept();
+  }
+}
+
+bool pHexEdit::QtHexEditScrollBar::event(QEvent* event) {
+  if(event->type() == QEvent::Wheel) {
+    QWheelEvent* wheelEvent = (QWheelEvent*)event;
+    if(wheelEvent->orientation() == Qt::Vertical) {
+      signed offset = wheelEvent->delta() < 0 ? +1 : -1;
+      self.scrollTo(sliderPosition() + offset);
+      return true;
+    }
+  }
+  return QScrollBar::event(event);
+}
+
+}
diff -Nru higan/phoenix/qt/widget/horizontal-scroller.cpp nSide/phoenix/qt/widget/horizontal-scroller.cpp
--- higan/phoenix/qt/widget/horizontal-scroller.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/qt/widget/horizontal-scroller.cpp	2015-09-16 13:08:13.548563367 +0900
@@ -0,0 +1,43 @@
+namespace phoenix {
+
+Size pHorizontalScroller::minimumSize() {
+  return {0, 15};
+}
+
+void pHorizontalScroller::setLength(unsigned length) {
+  length += length == 0;
+  qtScroller->setRange(0, length - 1);
+  qtScroller->setPageStep(length >> 3);
+}
+
+void pHorizontalScroller::setPosition(unsigned position) {
+  qtScroller->setValue(position);
+}
+
+void pHorizontalScroller::constructor() {
+  qtWidget = qtScroller = new QScrollBar(Qt::Horizontal);
+  qtScroller->setRange(0, 100);
+  qtScroller->setPageStep(101 >> 3);
+  connect(qtScroller, SIGNAL(valueChanged(int)), SLOT(onChange()));
+
+  pWidget::synchronizeState();
+  setLength(horizontalScroller.state.length);
+  setPosition(horizontalScroller.state.position);
+}
+
+void pHorizontalScroller::destructor() {
+  delete qtScroller;
+  qtWidget = qtScroller = nullptr;
+}
+
+void pHorizontalScroller::orphan() {
+  destructor();
+  constructor();
+}
+
+void pHorizontalScroller::onChange() {
+  horizontalScroller.state.position = qtScroller->value();
+  if(horizontalScroller.onChange) horizontalScroller.onChange();
+}
+
+}
diff -Nru higan/phoenix/qt/widget/horizontal-slider.cpp nSide/phoenix/qt/widget/horizontal-slider.cpp
--- higan/phoenix/qt/widget/horizontal-slider.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/qt/widget/horizontal-slider.cpp	2015-09-16 13:08:13.545563367 +0900
@@ -0,0 +1,43 @@
+namespace phoenix {
+
+Size pHorizontalSlider::minimumSize() {
+  return {0, 20};
+}
+
+void pHorizontalSlider::setLength(unsigned length) {
+  length += length == 0;
+  qtSlider->setRange(0, length - 1);
+  qtSlider->setPageStep(length >> 3);
+}
+
+void pHorizontalSlider::setPosition(unsigned position) {
+  qtSlider->setValue(position);
+}
+
+void pHorizontalSlider::constructor() {
+  qtWidget = qtSlider = new QSlider(Qt::Horizontal);
+  qtSlider->setRange(0, 100);
+  qtSlider->setPageStep(101 >> 3);
+  connect(qtSlider, SIGNAL(valueChanged(int)), SLOT(onChange()));
+
+  pWidget::synchronizeState();
+  setLength(horizontalSlider.state.length);
+  setPosition(horizontalSlider.state.position);
+}
+
+void pHorizontalSlider::destructor() {
+  delete qtSlider;
+  qtWidget = qtSlider = nullptr;
+}
+
+void pHorizontalSlider::orphan() {
+  destructor();
+  constructor();
+}
+
+void pHorizontalSlider::onChange() {
+  horizontalSlider.state.position = qtSlider->value();
+  if(horizontalSlider.onChange) horizontalSlider.onChange();
+}
+
+}
diff -Nru higan/phoenix/qt/widget/icon-view.cpp nSide/phoenix/qt/widget/icon-view.cpp
--- higan/phoenix/qt/widget/icon-view.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/qt/widget/icon-view.cpp	2015-09-16 13:08:13.546563367 +0900
@@ -0,0 +1,148 @@
+namespace phoenix {
+
+void pIconView::append() {
+  lock();
+  auto item = new QListWidgetItem(qtIconView);
+  unlock();
+}
+
+void pIconView::remove(unsigned selection) {
+  lock();
+  if(auto item = qtIconView->item(selection)) {
+    delete item;
+  }
+  unlock();
+}
+
+void pIconView::reset() {
+  lock();
+  qtIconView->clear();
+  unlock();
+}
+
+void pIconView::setBackgroundColor(Color color) {
+  QPalette palette = qtIconView->palette();
+  palette.setColor(QPalette::Base, QColor(color.red, color.green, color.blue));
+  qtIconView->setPalette(palette);
+  qtIconView->setAutoFillBackground(true);
+}
+
+void pIconView::setFlow(Orientation flow) {
+  qtIconView->setFlow(flow == Orientation::Horizontal ? QListView::LeftToRight : QListView::TopToBottom);
+  qtIconView->resize(qtIconView->size());  //adjust visibility of scroll bars
+}
+
+void pIconView::setForegroundColor(Color color) {
+  QPalette palette = qtIconView->palette();
+  palette.setColor(QPalette::Text, QColor(color.red, color.green, color.blue));
+  qtIconView->setPalette(palette);
+}
+
+void pIconView::setImage(unsigned selection, const image& image) {
+  if(auto item = qtIconView->item(selection)) {
+    item->setIcon(CreateIcon(image));
+  }
+}
+
+void pIconView::setOrientation(Orientation orientation) {
+  qtIconView->setViewMode(orientation == Orientation::Horizontal ? QListView::ListMode : QListView::IconMode);
+  qtIconView->setWrapping(true);
+}
+
+void pIconView::setSelected(unsigned selection, bool selected) {
+  lock();
+  if(auto item = qtIconView->item(selection)) {
+    item->setSelected(selected);
+  }
+  unlock();
+}
+
+void pIconView::setSelected(const vector<unsigned>& selections) {
+  lock();
+  qtIconView->clearSelection();
+  for(auto& selection : selections) {
+    if(auto item = qtIconView->item(selection)) {
+      item->setSelected(true);
+    }
+  }
+  unlock();
+}
+
+void pIconView::setSelectedAll() {
+  lock();
+  qtIconView->selectAll();
+  unlock();
+}
+
+void pIconView::setSelectedNone() {
+  lock();
+  qtIconView->clearSelection();
+  unlock();
+}
+
+void pIconView::setSingleSelection(bool singleSelection) {
+  qtIconView->setSelectionMode(singleSelection ? QAbstractItemView::SingleSelection : QAbstractItemView::ExtendedSelection);
+}
+
+void pIconView::setText(unsigned selection, const string& text) {
+  if(auto item = qtIconView->item(selection)) {
+    item->setText(QString::fromUtf8(text));
+  }
+}
+
+void pIconView::constructor() {
+  qtWidget = qtIconView = new QtListWidget;
+  qtIconView->setContextMenuPolicy(Qt::CustomContextMenu);
+  qtIconView->setMovement(QListView::Static);
+  qtIconView->setResizeMode(QListView::Adjust);
+  qtIconView->setSelectionRectVisible(true);
+  qtIconView->setHorizontalScrollMode(QAbstractItemView::ScrollPerPixel);
+  qtIconView->setVerticalScrollMode(QAbstractItemView::ScrollPerPixel);
+
+  connect(qtIconView, SIGNAL(itemActivated(QListWidgetItem*)), SLOT(onActivate()));
+  connect(qtIconView, SIGNAL(itemSelectionChanged()), SLOT(onChange()));
+  connect(qtIconView, SIGNAL(customContextMenuRequested(const QPoint&)), SLOT(onContext()));
+
+  setFlow(iconView.state.flow);
+  setOrientation(iconView.state.orientation);
+  setSingleSelection(iconView.state.singleSelection);
+}
+
+void pIconView::destructor() {
+  delete qtIconView;
+  qtWidget = qtIconView = nullptr;
+}
+
+void pIconView::orphan() {
+  destructor();
+  constructor();
+}
+
+void pIconView::onActivate() {
+  if(!locked() && iconView.onActivate) iconView.onActivate();
+}
+
+void pIconView::onChange() {
+  for(auto& selected : iconView.state.selected) selected = false;
+  for(unsigned n = 0; n < qtIconView->count(); n++) {
+    if(auto item = qtIconView->item(n)) {
+      if(item->isSelected()) iconView.state.selected[n] = true;
+    }
+  }
+  if(!locked() && iconView.onChange) iconView.onChange();
+}
+
+void pIconView::onContext() {
+  if(!locked() && iconView.onContext) iconView.onContext();
+}
+
+void pIconView::QtListWidget::resizeEvent(QResizeEvent* event) {
+  //Qt::ScrollBarAsNeeded results in the scroll bar area being reserved from the icon viewport even when scroll bar is hidden
+  //this creates the appearance of an invisible gap that wastes precious screen space
+  //below code simulates a Qt::ScrollBarAsNeeded which uses the extra space when the scroll bar is hidden
+  setHorizontalScrollBarPolicy(horizontalScrollBar()->maximum() > horizontalScrollBar()->minimum() ? Qt::ScrollBarAlwaysOn : Qt::ScrollBarAlwaysOff);
+  setVerticalScrollBarPolicy(verticalScrollBar()->maximum() > verticalScrollBar()->minimum() ? Qt::ScrollBarAlwaysOn : Qt::ScrollBarAlwaysOff);
+  return QListWidget::resizeEvent(event);
+}
+
+}
diff -Nru higan/phoenix/qt/widget/label.cpp nSide/phoenix/qt/widget/label.cpp
--- higan/phoenix/qt/widget/label.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/qt/widget/label.cpp	2015-09-16 13:08:13.548563367 +0900
@@ -0,0 +1,29 @@
+namespace phoenix {
+
+Size pLabel::minimumSize() {
+  Size size = pFont::size(qtWidget->font(), label.state.text);
+  return {size.width, size.height};
+}
+
+void pLabel::setText(string text) {
+  qtLabel->setText(QString::fromUtf8(text));
+}
+
+void pLabel::constructor() {
+  qtWidget = qtLabel = new QLabel;
+
+  pWidget::synchronizeState();
+  setText(label.state.text);
+}
+
+void pLabel::destructor() {
+  delete qtLabel;
+  qtWidget = qtLabel = nullptr;
+}
+
+void pLabel::orphan() {
+  destructor();
+  constructor();
+}
+
+}
diff -Nru higan/phoenix/qt/widget/line-edit.cpp nSide/phoenix/qt/widget/line-edit.cpp
--- higan/phoenix/qt/widget/line-edit.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/qt/widget/line-edit.cpp	2015-09-16 13:08:13.549563367 +0900
@@ -0,0 +1,62 @@
+namespace phoenix {
+
+Size pLineEdit::minimumSize() {
+  Size size = pFont::size(qtWidget->font(), lineEdit.state.text);
+  return {size.width + 12, size.height + 12};
+}
+
+void pLineEdit::setBackgroundColor(Color color) {
+  QPalette palette = qtLineEdit->palette();
+  palette.setColor(QPalette::Base, QColor(color.red, color.green, color.blue));
+  qtLineEdit->setPalette(palette);
+  qtLineEdit->setAutoFillBackground(true);
+}
+
+void pLineEdit::setEditable(bool editable) {
+  qtLineEdit->setReadOnly(!editable);
+}
+
+void pLineEdit::setForegroundColor(Color color) {
+  QPalette palette = qtLineEdit->palette();
+  palette.setColor(QPalette::Text, QColor(color.red, color.green, color.blue));
+  qtLineEdit->setPalette(palette);
+}
+
+void pLineEdit::setText(string text) {
+  qtLineEdit->setText(QString::fromUtf8(text));
+}
+
+string pLineEdit::text() {
+  return qtLineEdit->text().toUtf8().constData();
+}
+
+void pLineEdit::constructor() {
+  qtWidget = qtLineEdit = new QLineEdit;
+  connect(qtLineEdit, SIGNAL(returnPressed()), SLOT(onActivate()));
+  connect(qtLineEdit, SIGNAL(textEdited(const QString&)), SLOT(onChange()));
+
+  pWidget::synchronizeState();
+  setEditable(lineEdit.state.editable);
+  setText(lineEdit.state.text);
+}
+
+void pLineEdit::destructor() {
+  delete qtLineEdit;
+  qtWidget = qtLineEdit = nullptr;
+}
+
+void pLineEdit::orphan() {
+  destructor();
+  constructor();
+}
+
+void pLineEdit::onActivate() {
+  if(lineEdit.onActivate) lineEdit.onActivate();
+}
+
+void pLineEdit::onChange() {
+  lineEdit.state.text = text();
+  if(lineEdit.onChange) lineEdit.onChange();
+}
+
+}
diff -Nru higan/phoenix/qt/widget/list-view.cpp nSide/phoenix/qt/widget/list-view.cpp
--- higan/phoenix/qt/widget/list-view.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/qt/widget/list-view.cpp	2015-09-16 13:08:13.548563367 +0900
@@ -0,0 +1,395 @@
+namespace phoenix {
+
+void pListView::appendColumn() {
+  orphan();
+}
+
+void pListView::appendItem() {
+  lock();
+  auto item = new QTreeWidgetItem(qtListView);
+  for(unsigned column = 0; column < listView.columns(); column++) {
+    auto& state = listView.state.columns[column];
+    if(state.backgroundColor) {
+      item->setBackground(column, QColor(
+        state.backgroundColor->red, state.backgroundColor->green, state.backgroundColor->blue
+      ));
+    }
+    if(state.font) {
+      item->setFont(column, pFont::create(*state.font));
+    }
+    if(state.foregroundColor) {
+      item->setForeground(column, QColor(
+        state.foregroundColor->red, state.foregroundColor->green, state.foregroundColor->blue
+      ));
+    }
+    item->setTextAlignment(column, calculateAlignment(
+      state.horizontalAlignment, state.verticalAlignment
+    ));
+  }
+  if(listView.state.checkable) item->setCheckState(0, Qt::Unchecked);
+  unlock();
+}
+
+void pListView::removeColumn(unsigned position) {
+  orphan();
+}
+
+void pListView::removeItem(unsigned position) {
+  lock();
+  if(auto item = qtListView->topLevelItem(position)) {
+    delete item;
+  }
+  unlock();
+}
+
+void pListView::reset() {
+  lock();
+  qtListView->clear();
+  unlock();
+}
+
+void pListView::resizeColumns() {
+}
+
+//todo: this doesn't work ...
+void pListView::setActiveColumn(unsigned column) {
+  if(column >= listView.columns()) return;
+  qtListView->header()->setSortIndicator(column, Qt::DescendingOrder);
+}
+
+void pListView::setBackgroundColor(Color color) {
+  QPalette palette = qtListView->palette();
+  palette.setColor(QPalette::Base, QColor(color.red, color.green, color.blue));
+  palette.setColor(QPalette::AlternateBase, QColor(max(0, (signed)color.red - 17), max(0, (signed)color.green - 17), max(0, (signed)color.blue - 17)));
+  qtListView->setPalette(palette);
+  qtListView->setAutoFillBackground(true);
+}
+
+void pListView::setCheckable(bool checkable) {
+  lock();
+  if(checkable) {
+    for(unsigned n = 0; n < qtListView->topLevelItemCount(); n++) {
+      if(auto item = qtListView->topLevelItem(n)) {
+        item->setCheckState(0, Qt::Unchecked);
+      }
+    }
+  }
+  unlock();
+}
+
+void pListView::setChecked(unsigned position, bool checked) {
+  lock();
+  if(auto item = qtListView->topLevelItem(position)) {
+    item->setCheckState(0, checked ? Qt::Checked : Qt::Unchecked);
+  }
+  unlock();
+}
+
+void pListView::setChecked(const vector<unsigned>& selections) {
+  lock();
+  setCheckedNone();
+  for(auto& position : selections) setChecked(position, true);
+  unlock();
+}
+
+void pListView::setCheckedAll() {
+  lock();
+  for(unsigned n = 0; n < qtListView->topLevelItemCount(); n++) {
+    if(auto item = qtListView->topLevelItem(n)) {
+      item->setCheckState(0, Qt::Checked);
+    }
+  }
+  unlock();
+}
+
+void pListView::setCheckedNone() {
+  lock();
+  for(unsigned n = 0; n < qtListView->topLevelItemCount(); n++) {
+    if(auto item = qtListView->topLevelItem(n)) {
+      item->setCheckState(0, Qt::Unchecked);
+    }
+  }
+  unlock();
+}
+
+void pListView::setColumnBackgroundColor(unsigned column, maybe<Color> color) {
+  for(unsigned row = 0; row < listView.items(); row++) {
+    if(auto item = qtListView->topLevelItem(row)) {
+      item->setBackground(column, color ? QColor(color->red, color->green, color->blue) : QBrush());
+    }
+  }
+}
+
+void pListView::setColumnEditable(unsigned column, bool editable) {
+}
+
+void pListView::setColumnFont(unsigned column, maybe<string> font) {
+  auto qtFont = pFont::create(font ? *font : widget.state.font);
+  for(unsigned row = 0; row < listView.items(); row++) {
+    if(auto item = qtListView->topLevelItem(row)) {
+      item->setFont(column, qtFont);
+    }
+  }
+}
+
+void pListView::setColumnForegroundColor(unsigned column, maybe<Color> color) {
+  for(unsigned row = 0; row < listView.items(); row++) {
+    if(auto item = qtListView->topLevelItem(row)) {
+      item->setForeground(column, color ? QColor(color->red, color->green, color->blue) : QBrush());
+    }
+  }
+}
+
+void pListView::setColumnHorizontalAlignment(unsigned column, double alignment) {
+  qtListView->headerItem()->setTextAlignment(column, calculateAlignment(alignment, 0.5));
+  for(unsigned row = 0; row < listView.items(); row++) {
+    if(auto item = qtListView->topLevelItem(row)) {
+      auto& state = listView.state.columns[column];
+      item->setTextAlignment(column, calculateAlignment(state.horizontalAlignment, state.verticalAlignment));
+    }
+  }
+}
+
+void pListView::setColumnResizable(unsigned column, bool resizable) {
+  qtListView->header()->setResizeMode(column, resizable ? QHeaderView::Interactive : QHeaderView::Fixed);
+}
+
+void pListView::setColumnSortable(unsigned column, bool sortable) {
+  bool clickable = false;
+  for(auto& column : listView.state.columns) clickable |= column.sortable;
+  qtListView->header()->setClickable(clickable);
+}
+
+void pListView::setColumnText(unsigned column, const string& text) {
+  qtListView->headerItem()->setText(column, QString::fromUtf8(text));
+}
+
+void pListView::setColumnVerticalAlignment(unsigned column, double alignment) {
+  for(unsigned row = 0; row < listView.items(); row++) {
+    if(auto item = qtListView->topLevelItem(row)) {
+      auto& state = listView.state.columns[column];
+      item->setTextAlignment(column, calculateAlignment(state.horizontalAlignment, state.verticalAlignment));
+    }
+  }
+}
+
+void pListView::setColumnVisible(unsigned column, bool visible) {
+  if(column >= listView.columns()) return;
+  qtListView->setColumnHidden(column, !visible);
+}
+
+void pListView::setColumnWidth(unsigned column, signed width) {
+  if(column >= listView.columns()) return;
+  resizeColumns();
+}
+
+void pListView::setForegroundColor(Color color) {
+  QPalette palette = qtListView->palette();
+  palette.setColor(QPalette::Text, QColor(color.red, color.green, color.blue));
+  qtListView->setPalette(palette);
+}
+
+void pListView::setGridVisible(bool visible) {
+  qtListView->repaint();
+}
+
+void pListView::setHeaderVisible(bool visible) {
+  qtListView->setHeaderHidden(!visible);
+  resizeColumns();
+}
+
+void pListView::setImage(unsigned row, unsigned column, const nall::image& image) {
+  if(auto item = qtListView->topLevelItem(row)) {
+    item->setIcon(column, CreateIcon(image));
+  }
+}
+
+void pListView::setSelected(unsigned position, bool selected) {
+  lock();
+  if(auto item = qtListView->topLevelItem(position)) {
+    item->setSelected(selected);
+  }
+  unlock();
+}
+
+void pListView::setSelected(const vector<unsigned>& selections) {
+  lock();
+  setSelectedNone();
+  if(selections.size()) {
+    if(auto item = qtListView->topLevelItem(selections[0])) {
+      qtListView->setCurrentItem(item);
+    }
+    for(auto& position : selections) setSelected(position, true);
+  }
+  unlock();
+}
+
+void pListView::setSelectedAll() {
+  lock();
+  qtListView->selectAll();
+  unlock();
+}
+
+void pListView::setSelectedNone() {
+  lock();
+  qtListView->clearSelection();
+  unlock();
+}
+
+void pListView::setSingleSelection(bool singleSelection) {
+  lock();
+  qtListView->setSelectionMode(singleSelection ? QAbstractItemView::SingleSelection : QAbstractItemView::ExtendedSelection);
+  unlock();
+}
+
+void pListView::setText(unsigned row, unsigned column, string text) {
+  lock();
+  if(auto item = qtListView->topLevelItem(row)) {
+    item->setText(column, QString::fromUtf8(text));
+  }
+  unlock();
+}
+
+void pListView::constructor() {
+  qtWidget = qtListView = new QtTreeWidget(*this);
+  qtListView->setAllColumnsShowFocus(true);
+  qtListView->setAlternatingRowColors(listView.columns() >= 2);
+  qtListView->setColumnCount(max(1u, listView.columns()));
+  qtListView->setContextMenuPolicy(Qt::CustomContextMenu);
+  qtListView->setRootIsDecorated(false);
+  qtListView->header()->setMovable(false);
+
+  qtListViewDelegate = new QtTreeWidgetDelegate(*this);
+  qtListView->setItemDelegate(qtListViewDelegate);
+
+  connect(qtListView, SIGNAL(itemActivated(QTreeWidgetItem*, int)), SLOT(onActivate()));
+  connect(qtListView, SIGNAL(itemSelectionChanged()), SLOT(onChange()));
+  connect(qtListView, SIGNAL(customContextMenuRequested(const QPoint&)), SLOT(onContext()));
+  connect(qtListView->header(), SIGNAL(sectionClicked(int)), SLOT(onSort(int)));
+  connect(qtListView, SIGNAL(itemChanged(QTreeWidgetItem*, int)), SLOT(onToggle(QTreeWidgetItem*)));
+
+  pWidget::synchronizeState();
+  for(unsigned column = 0; column < listView.columns(); column++) {
+    auto& state = listView.state.columns[column];
+    setColumnBackgroundColor(column, state.backgroundColor);
+    setColumnEditable(column, state.editable);
+    setColumnFont(column, state.font);
+    setColumnForegroundColor(column, state.foregroundColor);
+  //setColumnHorizontalAlignment(column, state.horizontalAlignment);
+    setColumnResizable(column, state.resizable);
+    setColumnSortable(column, state.sortable);
+    setColumnText(column, state.text);
+  //setColumnVerticalAlignment(column, state.verticalAlignment);
+    setColumnVisible(column, state.visible);
+  //setColumnWidth(column, state.width);
+    qtListView->headerItem()->setTextAlignment(column, calculateAlignment(state.horizontalAlignment, 0.5));
+  }
+  setActiveColumn(listView.state.activeColumn);
+  setCheckable(listView.state.checkable);
+//setGridVisible(listView.state.gridVisible);
+  setHeaderVisible(listView.state.headerVisible);
+  setSingleSelection(listView.state.singleSelection);
+  for(unsigned row = 0; row < listView.items(); row++) {
+    appendItem();
+    setSelected(row, listView.state.items[row].selected);
+    if(listView.state.checkable) {
+      setChecked(row, listView.state.items[row].checked);
+    }
+    for(unsigned column = 0; column < listView.columns(); column++) {
+      setImage(row, column, listView.state.items[row].image(column, {}));
+      setText(row, column, listView.state.items[row].text(column, ""));
+    }
+  }
+  resizeColumns();
+}
+
+void pListView::destructor() {
+  delete qtListViewDelegate;
+  delete qtListView;
+  qtWidget = qtListView = nullptr;
+  qtListViewDelegate = nullptr;
+}
+
+void pListView::orphan() {
+  destructor();
+  constructor();
+}
+
+void pListView::onActivate() {
+  if(!locked() && listView.onActivate) listView.onActivate();
+}
+
+void pListView::onChange() {
+  for(auto& item : listView.state.items) item.selected = false;
+  for(unsigned position = 0; position < qtListView->topLevelItemCount(); position++) {
+    if(auto item = qtListView->topLevelItem(position)) {
+      if(item->isSelected()) listView.state.items[position].selected = true;
+    }
+  }
+  if(!locked() && listView.onChange) listView.onChange();
+}
+
+void pListView::onContext() {
+  if(!locked() && listView.onContext) listView.onContext();
+}
+
+void pListView::onSort(int column) {
+  if(column >= listView.columns()) return;
+  if(listView.state.columns[column].sortable) {
+    if(!locked() && listView.onSort) listView.onSort(column);
+  }
+}
+
+void pListView::onToggle(QTreeWidgetItem* item) {
+  maybe<unsigned> row;
+  for(unsigned position = 0; position < qtListView->topLevelItemCount(); position++) {
+    if(auto topLevelItem = qtListView->topLevelItem(position)) {
+      if(topLevelItem == item) {
+        row = position;
+        break;
+      }
+    }
+  }
+  if(row) {
+    listView.state.items[*row].checked = (item->checkState(0) == Qt::Checked);
+    if(!locked() && listView.onToggle) listView.onToggle(*row);
+  }
+}
+
+int pListView::calculateAlignment(double horizontal, double vertical) {
+  int alignment = 0;
+  if(horizontal < 0.333) alignment |= Qt::AlignLeft;
+  else if(horizontal > 0.666) alignment |= Qt::AlignRight;
+  else alignment |= Qt::AlignCenter;
+  if(vertical < 0.333) alignment |= Qt::AlignTop;
+  else if(vertical > 0.666) alignment |= Qt::AlignBottom;
+  else alignment |= Qt::AlignVCenter;
+  return alignment;
+}
+
+void pListView::QtTreeWidget::mousePressEvent(QMouseEvent* event) {
+  QTreeWidget::mousePressEvent(event);
+
+  if(event->button() == Qt::RightButton) {
+    self.onContext();
+  }
+}
+
+pListView::QtTreeWidget::QtTreeWidget(pListView& self) : self(self) {
+}
+
+void pListView::QtTreeWidgetDelegate::paint(QPainter* painter, const QStyleOptionViewItem& option, const QModelIndex& index) const {
+  QStyledItemDelegate::paint(painter, option, index);
+  if(self.listView.state.gridVisible) {
+    QPen pen;
+    pen.setColor(QColor(192, 192, 192));
+    pen.setWidth(1);
+    painter->setPen(pen);
+    painter->drawRect(option.rect);
+  }
+}
+
+pListView::QtTreeWidgetDelegate::QtTreeWidgetDelegate(pListView& self) : QStyledItemDelegate(self.qtListView), self(self) {
+}
+
+}
diff -Nru higan/phoenix/qt/widget/progress-bar.cpp nSide/phoenix/qt/widget/progress-bar.cpp
--- higan/phoenix/qt/widget/progress-bar.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/qt/widget/progress-bar.cpp	2015-09-16 13:08:13.549563367 +0900
@@ -0,0 +1,30 @@
+namespace phoenix {
+
+Size pProgressBar::minimumSize() {
+  return {0, 25};
+}
+
+void pProgressBar::setPosition(unsigned position) {
+  qtProgressBar->setValue(position);
+}
+
+void pProgressBar::constructor() {
+  qtWidget = qtProgressBar = new QProgressBar;
+  qtProgressBar->setRange(0, 100);
+  qtProgressBar->setTextVisible(false);
+
+  pWidget::synchronizeState();
+  setPosition(progressBar.state.position);
+}
+
+void pProgressBar::destructor() {
+  delete qtProgressBar;
+  qtWidget = qtProgressBar = nullptr;
+}
+
+void pProgressBar::orphan() {
+  destructor();
+  constructor();
+}
+
+}
diff -Nru higan/phoenix/qt/widget/radio-button.cpp nSide/phoenix/qt/widget/radio-button.cpp
--- higan/phoenix/qt/widget/radio-button.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/qt/widget/radio-button.cpp	2015-09-16 13:08:13.548563367 +0900
@@ -0,0 +1,85 @@
+namespace phoenix {
+
+Size pRadioButton::minimumSize() {
+  Size size = pFont::size(qtWidget->font(), radioButton.state.text);
+
+  if(radioButton.state.orientation == Orientation::Horizontal) {
+    size.width += radioButton.state.image.width();
+    size.height = max(radioButton.state.image.height(), size.height);
+  }
+
+  if(radioButton.state.orientation == Orientation::Vertical) {
+    size.width = max(radioButton.state.image.width(), size.width);
+    size.height += radioButton.state.image.height();
+  }
+
+  return {size.width + 20, size.height + 12};
+}
+
+void pRadioButton::setChecked() {
+  parent().lock();
+  for(auto& item : radioButton.state.group) {
+    bool checked = &item.p == this;
+    item.p.qtRadioButton->setChecked(item.state.checked = checked);
+  }
+  parent().unlock();
+}
+
+void pRadioButton::setGroup(const group<RadioButton>& group) {
+  parent().lock();
+  for(auto& item : radioButton.state.group) {
+    item.p.qtRadioButton->setChecked(item.state.checked);
+  }
+  parent().unlock();
+}
+
+void pRadioButton::setImage(const image& image, Orientation orientation) {
+  qtRadioButton->setIconSize(QSize(image.width(), image.height()));
+  qtRadioButton->setIcon(CreateIcon(image));
+  qtRadioButton->setStyleSheet("text-align: top;");
+  switch(orientation) {
+  case Orientation::Horizontal: qtRadioButton->setToolButtonStyle(Qt::ToolButtonTextBesideIcon); break;
+  case Orientation::Vertical:   qtRadioButton->setToolButtonStyle(Qt::ToolButtonTextUnderIcon);  break;
+  }
+}
+
+void pRadioButton::setText(string text) {
+  qtRadioButton->setText(QString::fromUtf8(text));
+}
+
+pRadioButton& pRadioButton::parent() {
+  if(radioButton.state.group.size()) return radioButton.state.group.first().p;
+  return *this;
+}
+
+void pRadioButton::constructor() {
+  qtWidget = qtRadioButton = new QToolButton;
+  qtRadioButton->setCheckable(true);
+  qtRadioButton->setToolButtonStyle(Qt::ToolButtonTextOnly);
+  connect(qtRadioButton, SIGNAL(toggled(bool)), SLOT(onActivate()));
+
+  pWidget::synchronizeState();
+  setGroup(radioButton.state.group);
+  setText(radioButton.state.text);
+}
+
+void pRadioButton::destructor() {
+  if(qtRadioButton) delete qtRadioButton;
+  qtWidget = qtRadioButton = nullptr;
+}
+
+void pRadioButton::orphan() {
+  destructor();
+  constructor();
+}
+
+void pRadioButton::onActivate() {
+  if(parent().locked()) return;
+  bool wasChecked = radioButton.state.checked;
+  setChecked();
+  if(!wasChecked) {
+    if(radioButton.onActivate) radioButton.onActivate();
+  }
+}
+
+}
diff -Nru higan/phoenix/qt/widget/radio-label.cpp nSide/phoenix/qt/widget/radio-label.cpp
--- higan/phoenix/qt/widget/radio-label.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/qt/widget/radio-label.cpp	2015-09-16 13:08:13.549563367 +0900
@@ -0,0 +1,63 @@
+namespace phoenix {
+
+Size pRadioLabel::minimumSize() {
+  Size size = pFont::size(qtWidget->font(), radioLabel.state.text);
+  return {size.width + 26, size.height + 6};
+}
+
+void pRadioLabel::setChecked() {
+  parent().lock();
+  for(auto& item : radioLabel.state.group) {
+    bool checked = &item == &radioLabel;
+    item.p.qtRadioLabel->setChecked(item.state.checked = checked);
+  }
+  parent().unlock();
+}
+
+void pRadioLabel::setGroup(const group<RadioLabel>& group) {
+  parent().lock();
+  for(auto& item : radioLabel.state.group) {
+    item.p.qtRadioLabel->setChecked(item.state.checked);
+  }
+  parent().unlock();
+}
+
+void pRadioLabel::setText(string text) {
+  qtRadioLabel->setText(QString::fromUtf8(text));
+}
+
+pRadioLabel& pRadioLabel::parent() {
+  if(radioLabel.state.group.size()) return radioLabel.state.group.first().p;
+  return *this;
+}
+
+void pRadioLabel::constructor() {
+  qtWidget = qtRadioLabel = new QRadioButton;
+  qtRadioLabel->setAutoExclusive(false);
+  connect(qtRadioLabel, SIGNAL(toggled(bool)), SLOT(onActivate()));
+
+  pWidget::synchronizeState();
+  setGroup(radioLabel.state.group);
+  setText(radioLabel.state.text);
+}
+
+void pRadioLabel::destructor() {
+  if(qtRadioLabel) delete qtRadioLabel;
+  qtWidget = qtRadioLabel = nullptr;
+}
+
+void pRadioLabel::orphan() {
+  destructor();
+  constructor();
+}
+
+void pRadioLabel::onActivate() {
+  if(parent().locked()) return;
+  bool wasChecked = radioLabel.state.checked;
+  setChecked();
+  if(!wasChecked) {
+    if(radioLabel.onActivate) radioLabel.onActivate();
+  }
+}
+
+}
diff -Nru higan/phoenix/qt/widget/tab-frame.cpp nSide/phoenix/qt/widget/tab-frame.cpp
--- higan/phoenix/qt/widget/tab-frame.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/qt/widget/tab-frame.cpp	2015-09-16 13:08:13.548563367 +0900
@@ -0,0 +1,95 @@
+namespace phoenix {
+
+void pTabFrame::append() {
+  qtTabFrame->addTab(new QWidget, "");
+}
+
+QWidget* pTabFrame::container(Widget& widget) {
+  Layout* widgetLayout = GetParentWidgetLayout(&widget);
+  unsigned selection = 0;
+  for(auto& layout : tabFrame.state.layout) {
+    if(layout == widgetLayout) return qtTabFrame->widget(selection);
+    selection++;
+  }
+  return nullptr;
+}
+
+Position pTabFrame::displacement() {
+  return {5, 33};
+}
+
+void pTabFrame::remove(unsigned selection) {
+  qtTabFrame->removeTab(selection);
+}
+
+void pTabFrame::setEnabled(bool enabled) {
+  for(auto& layout : tabFrame.state.layout) {
+    if(layout) layout->setEnabled(layout->enabled());
+  }
+  pWidget::setEnabled(enabled);
+}
+
+void pTabFrame::setGeometry(Geometry geometry) {
+  pWidget::setGeometry(geometry);
+  geometry.x += 0, geometry.width -= 5;
+  geometry.y += 29, geometry.height -= 33;
+  for(auto& layout : tabFrame.state.layout) {
+    if(layout) layout->setGeometry(geometry);
+  }
+  synchronizeLayout();
+}
+
+void pTabFrame::setImage(unsigned selection, const image& image) {
+  qtTabFrame->setTabIcon(selection, CreateIcon(image));
+}
+
+void pTabFrame::setSelected(unsigned selection) {
+  lock();
+  qtTabFrame->setCurrentIndex(selection);
+  synchronizeLayout();
+  unlock();
+}
+
+void pTabFrame::setText(unsigned selection, string text) {
+  qtTabFrame->setTabText(selection, QString::fromUtf8(text));
+}
+
+void pTabFrame::setVisible(bool visible) {
+  for(auto& layout : tabFrame.state.layout) {
+    if(layout) layout->setVisible(layout->visible());
+  }
+  pWidget::setVisible(visible);
+}
+
+void pTabFrame::constructor() {
+  qtWidget = qtTabFrame = new QTabWidget;
+  connect(qtTabFrame, SIGNAL(currentChanged(int)), SLOT(onChange(int)));
+
+  setSelected(tabFrame.state.selection);
+}
+
+void pTabFrame::destructor() {
+  delete qtTabFrame;
+  qtWidget = qtTabFrame = nullptr;
+}
+
+void pTabFrame::orphan() {
+  destructor();
+  constructor();
+}
+
+void pTabFrame::synchronizeLayout() {
+  unsigned selection = 0;
+  for(auto& layout : tabFrame.state.layout) {
+    if(layout) layout->setVisible(selection == tabFrame.state.selection);
+    selection++;
+  }
+}
+
+void pTabFrame::onChange(int selection) {
+  tabFrame.state.selection = selection;
+  synchronizeLayout();
+  if(!locked() && tabFrame.onChange) tabFrame.onChange();
+}
+
+}
diff -Nru higan/phoenix/qt/widget/text-edit.cpp nSide/phoenix/qt/widget/text-edit.cpp
--- higan/phoenix/qt/widget/text-edit.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/qt/widget/text-edit.cpp	2015-09-16 13:08:13.548563367 +0900
@@ -0,0 +1,66 @@
+namespace phoenix {
+
+void pTextEdit::setBackgroundColor(Color color) {
+  QPalette palette = qtTextEdit->palette();
+  palette.setColor(QPalette::Base, QColor(color.red, color.green, color.blue));
+  qtTextEdit->setPalette(palette);
+  qtTextEdit->setAutoFillBackground(true);
+}
+
+void pTextEdit::setCursorPosition(unsigned position) {
+  QTextCursor cursor = qtTextEdit->textCursor();
+  unsigned lastCharacter = strlen(qtTextEdit->toPlainText().toUtf8().constData());
+  cursor.setPosition(min(position, lastCharacter));
+  qtTextEdit->setTextCursor(cursor);
+}
+
+void pTextEdit::setEditable(bool editable) {
+  qtTextEdit->setTextInteractionFlags(editable ? Qt::TextEditorInteraction : Qt::TextSelectableByKeyboard | Qt::TextSelectableByMouse);
+}
+
+void pTextEdit::setForegroundColor(Color color) {
+  QPalette palette = qtTextEdit->palette();
+  palette.setColor(QPalette::Text, QColor(color.red, color.green, color.blue));
+  qtTextEdit->setPalette(palette);
+}
+
+void pTextEdit::setText(string text) {
+  qtTextEdit->setPlainText(QString::fromUtf8(text));
+}
+
+void pTextEdit::setWordWrap(bool wordWrap) {
+  qtTextEdit->setWordWrapMode(wordWrap ? QTextOption::WordWrap : QTextOption::NoWrap);
+  qtTextEdit->setHorizontalScrollBarPolicy(wordWrap ? Qt::ScrollBarAlwaysOff : Qt::ScrollBarAlwaysOn);
+  qtTextEdit->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOn);
+}
+
+string pTextEdit::text() {
+  return qtTextEdit->toPlainText().toUtf8().constData();
+}
+
+void pTextEdit::constructor() {
+  qtWidget = qtTextEdit = new QTextEdit;
+  connect(qtTextEdit, SIGNAL(textChanged()), SLOT(onChange()));
+
+  pWidget::synchronizeState();
+  setEditable(textEdit.state.editable);
+  setText(textEdit.state.text);
+  setWordWrap(textEdit.state.wordWrap);
+}
+
+void pTextEdit::destructor() {
+  delete qtTextEdit;
+  qtWidget = qtTextEdit = nullptr;
+}
+
+void pTextEdit::orphan() {
+  destructor();
+  constructor();
+}
+
+void pTextEdit::onChange() {
+  textEdit.state.text = text();
+  if(textEdit.onChange) textEdit.onChange();
+}
+
+}
diff -Nru higan/phoenix/qt/widget/vertical-scroller.cpp nSide/phoenix/qt/widget/vertical-scroller.cpp
--- higan/phoenix/qt/widget/vertical-scroller.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/qt/widget/vertical-scroller.cpp	2015-09-16 13:08:13.549563367 +0900
@@ -0,0 +1,43 @@
+namespace phoenix {
+
+Size pVerticalScroller::minimumSize() {
+  return {15, 0};
+}
+
+void pVerticalScroller::setLength(unsigned length) {
+  length += length == 0;
+  qtScroller->setRange(0, length - 1);
+  qtScroller->setPageStep(length >> 3);
+}
+
+void pVerticalScroller::setPosition(unsigned position) {
+  qtScroller->setValue(position);
+}
+
+void pVerticalScroller::constructor() {
+  qtWidget = qtScroller = new QScrollBar(Qt::Vertical);
+  qtScroller->setRange(0, 100);
+  qtScroller->setPageStep(101 >> 3);
+  connect(qtScroller, SIGNAL(valueChanged(int)), SLOT(onChange()));
+
+  pWidget::synchronizeState();
+  setLength(verticalScroller.state.length);
+  setPosition(verticalScroller.state.position);
+}
+
+void pVerticalScroller::destructor() {
+  delete qtScroller;
+  qtWidget = qtScroller = nullptr;
+}
+
+void pVerticalScroller::orphan() {
+  destructor();
+  constructor();
+}
+
+void pVerticalScroller::onChange() {
+  verticalScroller.state.position = qtScroller->value();
+  if(verticalScroller.onChange) verticalScroller.onChange();
+}
+
+}
diff -Nru higan/phoenix/qt/widget/vertical-slider.cpp nSide/phoenix/qt/widget/vertical-slider.cpp
--- higan/phoenix/qt/widget/vertical-slider.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/qt/widget/vertical-slider.cpp	2015-09-16 13:08:13.549563367 +0900
@@ -0,0 +1,43 @@
+namespace phoenix {
+
+Size pVerticalSlider::minimumSize() {
+  return {20, 0};
+}
+
+void pVerticalSlider::setLength(unsigned length) {
+  length += length == 0;
+  qtSlider->setRange(0, length - 1);
+  qtSlider->setPageStep(length >> 3);
+}
+
+void pVerticalSlider::setPosition(unsigned position) {
+  qtSlider->setValue(position);
+}
+
+void pVerticalSlider::constructor() {
+  qtWidget = qtSlider = new QSlider(Qt::Vertical);
+  qtSlider->setRange(0, 100);
+  qtSlider->setPageStep(101 >> 3);
+  connect(qtSlider, SIGNAL(valueChanged(int)), SLOT(onChange()));
+
+  pWidget::synchronizeState();
+  setLength(verticalSlider.state.length);
+  setPosition(verticalSlider.state.position);
+}
+
+void pVerticalSlider::destructor() {
+  delete qtSlider;
+  qtWidget = qtSlider = nullptr;
+}
+
+void pVerticalSlider::orphan() {
+  destructor();
+  constructor();
+}
+
+void pVerticalSlider::onChange() {
+  verticalSlider.state.position = qtSlider->value();
+  if(verticalSlider.onChange) verticalSlider.onChange();
+}
+
+}
diff -Nru higan/phoenix/qt/widget/viewport.cpp nSide/phoenix/qt/widget/viewport.cpp
--- higan/phoenix/qt/widget/viewport.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/qt/widget/viewport.cpp	2015-09-16 13:08:13.549563367 +0900
@@ -0,0 +1,71 @@
+namespace phoenix {
+
+uintptr_t pViewport::handle() {
+  return (uintptr_t)qtViewport->winId();
+}
+
+void pViewport::setDroppable(bool droppable) {
+  qtViewport->setAcceptDrops(droppable);
+}
+
+void pViewport::constructor() {
+  qtWidget = qtViewport = new QtViewport(*this);
+  qtViewport->setMouseTracking(true);
+  qtViewport->setAttribute(Qt::WA_PaintOnScreen, true);
+  qtViewport->setStyleSheet("background: #000000");
+
+  pWidget::synchronizeState();
+}
+
+void pViewport::destructor() {
+  delete qtViewport;
+  qtWidget = qtViewport = nullptr;
+}
+
+void pViewport::orphan() {
+  destructor();
+  constructor();
+}
+
+void pViewport::QtViewport::dragEnterEvent(QDragEnterEvent* event) {
+  if(event->mimeData()->hasUrls()) {
+    event->acceptProposedAction();
+  }
+}
+
+void pViewport::QtViewport::dropEvent(QDropEvent* event) {
+  lstring paths = DropPaths(event);
+  if(paths.empty()) return;
+  if(self.viewport.onDrop) self.viewport.onDrop(paths);
+}
+
+void pViewport::QtViewport::leaveEvent(QEvent* event) {
+  if(self.viewport.onMouseLeave) self.viewport.onMouseLeave();
+}
+
+void pViewport::QtViewport::mouseMoveEvent(QMouseEvent* event) {
+  if(self.viewport.onMouseMove) self.viewport.onMouseMove({event->pos().x(), event->pos().y()});
+}
+
+void pViewport::QtViewport::mousePressEvent(QMouseEvent* event) {
+  if(!self.viewport.onMousePress) return;
+  switch(event->button()) {
+  case Qt::LeftButton: self.viewport.onMousePress(Mouse::Button::Left); break;
+  case Qt::MidButton: self.viewport.onMousePress(Mouse::Button::Middle); break;
+  case Qt::RightButton: self.viewport.onMousePress(Mouse::Button::Right); break;
+  }
+}
+
+void pViewport::QtViewport::mouseReleaseEvent(QMouseEvent* event) {
+  if(!self.viewport.onMouseRelease) return;
+  switch(event->button()) {
+  case Qt::LeftButton: self.viewport.onMouseRelease(Mouse::Button::Left); break;
+  case Qt::MidButton: self.viewport.onMouseRelease(Mouse::Button::Middle); break;
+  case Qt::RightButton: self.viewport.onMouseRelease(Mouse::Button::Right); break;
+  }
+}
+
+pViewport::QtViewport::QtViewport(pViewport& self) : self(self) {
+}
+
+}
diff -Nru higan/phoenix/qt/widget/widget.cpp nSide/phoenix/qt/widget/widget.cpp
--- higan/phoenix/qt/widget/widget.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/qt/widget/widget.cpp	2015-09-16 13:08:13.545563367 +0900
@@ -0,0 +1,68 @@
+namespace phoenix {
+
+QWidget* pWidget::container(Widget& widget) {
+  return nullptr;
+}
+
+bool pWidget::focused() {
+  return qtWidget->hasFocus();
+}
+
+Size pWidget::minimumSize() {
+  return {0, 0};
+}
+
+void pWidget::setEnabled(bool enabled) {
+  if(!widget.parent()) enabled = false;
+  if(widget.state.abstract) enabled = false;
+  if(!widget.enabledToAll()) enabled = false;
+  qtWidget->setEnabled(enabled);
+}
+
+void pWidget::setFocused() {
+  qtWidget->setFocus(Qt::OtherFocusReason);
+}
+
+void pWidget::setFont(string font) {
+  qtWidget->setFont(pFont::create(font));
+}
+
+void pWidget::setGeometry(Geometry geometry) {
+  Position displacement = GetDisplacement(&widget);
+  geometry.x -= displacement.x;
+  geometry.y -= displacement.y;
+
+  qtWidget->setGeometry(geometry.x, geometry.y, geometry.width, geometry.height);
+  if(widget.onSize) widget.onSize();
+}
+
+void pWidget::setVisible(bool visible) {
+  if(!widget.parent()) visible = false;
+  if(widget.state.abstract) visible = false;
+  if(!widget.visibleToAll()) visible = false;
+  qtWidget->setVisible(visible);
+}
+
+void pWidget::constructor() {
+  if(widget.state.abstract) qtWidget = new QWidget;
+}
+
+//pWidget::constructor() called before p{Derived}::constructor(); ergo qtWidget is not yet valid
+//pWidget::synchronizeState() is called to finish construction of p{Derived}::constructor()
+void pWidget::synchronizeState() {
+  setFont(widget.font());
+}
+
+void pWidget::destructor() {
+  if(widget.state.abstract) {
+    delete qtWidget;
+    qtWidget = nullptr;
+  }
+}
+
+void pWidget::orphan() {
+  destructor();
+  constructor();
+}
+
+}
diff -Nru higan/phoenix/qt/window.cpp nSide/phoenix/qt/window.cpp
--- higan/phoenix/qt/window.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/qt/window.cpp	2015-09-16 13:08:13.553563368 +0900
@@ -0,0 +1,314 @@
+namespace phoenix {
+
+void pWindow::append(Layout& layout) {
+  Geometry geometry = window.state.geometry;
+  geometry.x = geometry.y = 0;
+  layout.setGeometry(geometry);
+}
+
+void pWindow::append(Menu& menu) {
+  if(window.state.menuFont != "") menu.p.setFont(window.state.menuFont);
+  else menu.p.setFont(Font::sans(8));
+  qtMenu->addMenu(menu.p.qtMenu);
+}
+
+void pWindow::append(Widget& widget) {
+  if(widget.font().empty() && !window.state.widgetFont.empty()) {
+    widget.setFont(window.state.widgetFont);
+  }
+  if(widget.font().empty()) widget.p.setFont(Font::sans(8));
+  if(GetParentWidget(&widget)) {
+    widget.p.qtWidget->setParent(GetParentWidget(&widget)->p.container(widget));
+  } else {
+    widget.p.qtWidget->setParent(qtContainer);
+  }
+  widget.setVisible(widget.visible());
+}
+
+Geometry pWindow::frameMargin() {
+  unsigned menuHeight = window.state.menuVisible ? settings->geometry.menuHeight : 0;
+  unsigned statusHeight = window.state.statusVisible ? settings->geometry.statusHeight : 0;
+  if(window.state.fullScreen) return {0, menuHeight, 0, menuHeight + statusHeight};
+  return {
+    settings->geometry.frameX,
+    settings->geometry.frameY + menuHeight,
+    settings->geometry.frameWidth,
+    settings->geometry.frameHeight + menuHeight + statusHeight
+  };
+}
+
+bool pWindow::focused() {
+  return qtWindow->isActiveWindow() && !qtWindow->isMinimized();
+}
+
+void pWindow::remove(Layout& layout) {
+}
+
+void pWindow::remove(Menu& menu) {
+  //QMenuBar::removeMenu() does not exist
+  qtMenu->clear();
+  for(auto& menu : window.state.menu) append(menu);
+}
+
+void pWindow::remove(Widget& widget) {
+  //orphan() destroys and recreates widgets (to disassociate them from their parent);
+  //attempting to create widget again after QApplication::quit() crashes libQtGui
+  if(qtApplication) widget.p.orphan();
+}
+
+void pWindow::setBackgroundColor(Color color) {
+  QPalette palette;
+  palette.setColor(QPalette::Background, QColor(color.red, color.green, color.blue /*, color.alpha */));
+  qtContainer->setPalette(palette);
+  qtContainer->setAutoFillBackground(true);
+  //translucency results are very unpleasant without a compositor; so disable for now
+  //qtWindow->setAttribute(Qt::WA_TranslucentBackground, color.alpha != 255);
+}
+
+void pWindow::setDroppable(bool droppable) {
+  qtWindow->setAcceptDrops(droppable);
+}
+
+void pWindow::setFocused() {
+  qtWindow->raise();
+  qtWindow->activateWindow();
+}
+
+void pWindow::setFullScreen(bool fullScreen) {
+  if(fullScreen == false) {
+    setResizable(window.state.resizable);
+    qtWindow->showNormal();
+    qtWindow->adjustSize();
+  } else {
+    qtLayout->setSizeConstraint(QLayout::SetDefaultConstraint);
+    qtContainer->setFixedSize(Desktop::size().width - frameMargin().width, Desktop::size().height - frameMargin().height);
+    qtWindow->showFullScreen();
+  }
+}
+
+void pWindow::setGeometry(Geometry geometry) {
+  lock();
+  Application::processEvents();
+  QApplication::syncX();
+
+  setResizable(window.state.resizable);
+  qtWindow->move(geometry.x - frameMargin().x, geometry.y - frameMargin().y);
+  //qtWindow->adjustSize() fails if larger than 2/3rds screen size
+  qtWindow->resize(qtWindow->sizeHint());
+  if(window.state.resizable) {
+    //required to allow shrinking window from default size
+    qtWindow->setMinimumSize(1, 1);
+    qtContainer->setMinimumSize(1, 1);
+  }
+
+  for(auto& layout : window.state.layout) {
+    geometry.x = geometry.y = 0;
+    layout.setGeometry(geometry);
+  }
+  unlock();
+}
+
+void pWindow::setMenuFont(string font) {
+  qtMenu->setFont(pFont::create(font));
+  for(auto& item : window.state.menu) item.p.setFont(font);
+}
+
+void pWindow::setMenuVisible(bool visible) {
+  qtMenu->setVisible(visible);
+  setGeometry(window.state.geometry);
+}
+
+void pWindow::setModal(bool modal) {
+  if(modal == true) {
+    //windowModality can only be enabled while window is invisible
+    setVisible(false);
+    qtWindow->setWindowModality(Qt::ApplicationModal);
+    setVisible(true);
+    while(window.state.modal) {
+      Application::processEvents();
+      if(Application::main) {
+        Application::main();
+      } else {
+        usleep(20 * 1000);
+      }
+    }
+    qtWindow->setWindowModality(Qt::NonModal);
+  }
+}
+
+void pWindow::setResizable(bool resizable) {
+  if(resizable) {
+    qtLayout->setSizeConstraint(QLayout::SetDefaultConstraint);
+    qtContainer->setMinimumSize(window.state.geometry.width, window.state.geometry.height);
+  } else {
+    qtLayout->setSizeConstraint(QLayout::SetFixedSize);
+    qtContainer->setFixedSize(window.state.geometry.width, window.state.geometry.height);
+  }
+  qtStatus->setSizeGripEnabled(resizable);
+}
+
+void pWindow::setStatusFont(string font) {
+  qtStatus->setFont(pFont::create(font));
+}
+
+void pWindow::setStatusText(string text) {
+  qtStatus->showMessage(QString::fromUtf8(text), 0);
+}
+
+void pWindow::setStatusVisible(bool visible) {
+  qtStatus->setVisible(visible);
+  setGeometry(window.state.geometry);
+}
+
+void pWindow::setTitle(string text) {
+  qtWindow->setWindowTitle(QString::fromUtf8(text));
+}
+
+void pWindow::setVisible(bool visible) {
+  lock();
+  qtWindow->setVisible(visible);
+  if(visible) {
+    updateFrameGeometry();
+    setGeometry(window.state.geometry);
+  }
+  unlock();
+}
+
+void pWindow::setWidgetFont(string font) {
+}
+
+void pWindow::constructor() {
+  qtWindow = new QtWindow(*this);
+  qtWindow->setWindowTitle(" ");
+
+  //if program was given a name, try and set the window taskbar icon to a matching pixmap image
+  if(applicationState.name.empty() == false) {
+    if(file::exists({"/usr/share/pixmaps/", applicationState.name, ".png"})) {
+      qtWindow->setWindowIcon(QIcon(string{"/usr/share/pixmaps/", applicationState.name, ".png"}));
+    } else if(file::exists({"/usr/local/share/pixmaps/", applicationState.name, ".png"})) {
+      qtWindow->setWindowIcon(QIcon(string{"/usr/local/share/pixmaps/", applicationState.name, ".png"}));
+    } else if(file::exists({userpath(), ".local/share/icons/", applicationState.name, ".png"})) {
+      qtWindow->setWindowIcon(QIcon(string{userpath(), ".local/share/icons/", applicationState.name, ".png"}));
+    }
+  }
+
+  qtLayout = new QVBoxLayout(qtWindow);
+  qtLayout->setMargin(0);
+  qtLayout->setSpacing(0);
+  qtWindow->setLayout(qtLayout);
+
+  qtMenu = new QMenuBar(qtWindow);
+  qtMenu->setVisible(false);
+  qtLayout->addWidget(qtMenu);
+
+  qtContainer = new QWidget(qtWindow);
+  qtContainer->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
+  qtContainer->setVisible(true);
+  qtLayout->addWidget(qtContainer);
+
+  qtStatus = new QStatusBar(qtWindow);
+  qtStatus->setSizeGripEnabled(true);
+  qtStatus->setVisible(false);
+  qtLayout->addWidget(qtStatus);
+
+  setGeometry(window.state.geometry);
+  setMenuFont(Font::sans(8));
+  setStatusFont(Font::sans(8));
+
+  QColor color = qtWindow->palette().color(QPalette::ColorRole::Window);
+  window.state.backgroundColor = Color((uint8_t)color.red(), (uint8_t)color.green(), (uint8_t)color.blue(), (uint8_t)color.alpha());
+}
+
+void pWindow::destructor() {
+  delete qtStatus;
+  delete qtContainer;
+  delete qtMenu;
+  delete qtLayout;
+  delete qtWindow;
+}
+
+void pWindow::updateFrameGeometry() {
+  pApplication::syncX();
+  QRect border = qtWindow->frameGeometry();
+  QRect client = qtWindow->geometry();
+
+  settings->geometry.frameX = client.x() - border.x();
+  settings->geometry.frameY = client.y() - border.y();
+  settings->geometry.frameWidth = border.width() - client.width();
+  settings->geometry.frameHeight = border.height() - client.height();
+
+  if(window.state.menuVisible) {
+    pApplication::syncX();
+    settings->geometry.menuHeight = qtMenu->height();
+  }
+
+  if(window.state.statusVisible) {
+    pApplication::syncX();
+    settings->geometry.statusHeight = qtStatus->height();
+  }
+
+  settings->save();
+}
+
+void pWindow::QtWindow::closeEvent(QCloseEvent* event) {
+  event->ignore();
+  if(self.window.onClose) self.window.onClose();
+  else self.window.setVisible(false);
+  if(self.window.state.modal && !self.window.visible()) self.window.setModal(false);
+}
+
+void pWindow::QtWindow::moveEvent(QMoveEvent* event) {
+  if(!self.locked() && self.window.state.fullScreen == false && self.qtWindow->isVisible() == true) {
+    self.window.state.geometry.x += event->pos().x() - event->oldPos().x();
+    self.window.state.geometry.y += event->pos().y() - event->oldPos().y();
+  }
+
+  if(!self.locked() && self.window.onMove) self.window.onMove();
+}
+
+void pWindow::QtWindow::dragEnterEvent(QDragEnterEvent* event) {
+  if(event->mimeData()->hasUrls()) {
+    event->acceptProposedAction();
+  }
+}
+
+void pWindow::QtWindow::dropEvent(QDropEvent* event) {
+  lstring paths = DropPaths(event);
+  if(paths.empty()) return;
+  if(self.window.onDrop) self.window.onDrop(paths);
+}
+
+void pWindow::QtWindow::keyPressEvent(QKeyEvent* event) {
+  Keyboard::Keycode sym = Keysym(event->nativeVirtualKey());
+  if(sym != Keyboard::Keycode::None && self.window.onKeyPress) self.window.onKeyPress(sym);
+}
+
+void pWindow::QtWindow::keyReleaseEvent(QKeyEvent* event) {
+  Keyboard::Keycode sym = Keysym(event->nativeVirtualKey());
+  if(sym != Keyboard::Keycode::None && self.window.onKeyRelease) self.window.onKeyRelease(sym);
+}
+
+void pWindow::QtWindow::resizeEvent(QResizeEvent*) {
+  if(!self.locked() && self.window.state.fullScreen == false && self.qtWindow->isVisible() == true) {
+    self.window.state.geometry.width = self.qtContainer->geometry().width();
+    self.window.state.geometry.height = self.qtContainer->geometry().height();
+  }
+
+  for(auto& layout : self.window.state.layout) {
+    Geometry geometry = self.window.state.geometry;
+    geometry.x = geometry.y = 0;
+    layout.setGeometry(geometry);
+  }
+
+  if(!self.locked() && self.window.onSize) self.window.onSize();
+}
+
+QSize pWindow::QtWindow::sizeHint() const {
+  unsigned width = self.window.state.geometry.width;
+  unsigned height = self.window.state.geometry.height;
+  if(self.window.state.menuVisible) height += settings->geometry.menuHeight;
+  if(self.window.state.statusVisible) height += settings->geometry.statusHeight;
+  return QSize(width, height);
+}
+
+}
diff -Nru higan/phoenix/reference/action/action.cpp nSide/phoenix/reference/action/action.cpp
--- higan/phoenix/reference/action/action.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/action/action.cpp	2015-09-16 13:08:13.588563371 +0900
@@ -0,0 +1,15 @@
+namespace phoenix {
+
+void pAction::setEnabled(bool enabled) {
+}
+
+void pAction::setVisible(bool visible) {
+}
+
+void pAction::constructor() {
+}
+
+void pAction::destructor() {
+}
+
+}
diff -Nru higan/phoenix/reference/action/action.hpp nSide/phoenix/reference/action/action.hpp
--- higan/phoenix/reference/action/action.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/action/action.hpp	2015-09-16 13:08:13.588563371 +0900
@@ -0,0 +1,14 @@
+namespace phoenix {
+
+struct pAction : public pObject {
+  Action& action;
+
+  void setEnabled(bool enabled);
+  void setVisible(bool visible);
+
+  pAction(Action& action) : pObject(action), action(action) {}
+  void constructor();
+  void destructor();
+};
+
+}
diff -Nru higan/phoenix/reference/action/check-item.cpp nSide/phoenix/reference/action/check-item.cpp
--- higan/phoenix/reference/action/check-item.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/action/check-item.cpp	2015-09-16 13:08:13.588563371 +0900
@@ -0,0 +1,15 @@
+namespace phoenix {
+
+void pCheckItem::setChecked(bool checked) {
+}
+
+void pCheckItem::setText(string text) {
+}
+
+void pCheckItem::constructor() {
+}
+
+void pCheckItem::destructor() {
+}
+
+}
diff -Nru higan/phoenix/reference/action/check-item.hpp nSide/phoenix/reference/action/check-item.hpp
--- higan/phoenix/reference/action/check-item.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/action/check-item.hpp	2015-09-16 13:08:13.588563371 +0900
@@ -0,0 +1,14 @@
+namespace phoenix {
+
+struct pCheckItem : public pAction {
+  CheckItem& checkItem;
+
+  void setChecked(bool checked);
+  void setText(string text);
+
+  pCheckItem(CheckItem& checkItem) : pAction(checkItem), checkItem(checkItem) {}
+  void constructor();
+  void destructor();
+};
+
+}
diff -Nru higan/phoenix/reference/action/item.cpp nSide/phoenix/reference/action/item.cpp
--- higan/phoenix/reference/action/item.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/action/item.cpp	2015-09-16 13:08:13.589563371 +0900
@@ -0,0 +1,15 @@
+namespace phoenix {
+
+void pItem::setImage(const image& image) {
+}
+
+void pItem::setText(string text) {
+}
+
+void pItem::constructor() {
+}
+
+void pItem::destructor() {
+}
+
+}
diff -Nru higan/phoenix/reference/action/item.hpp nSide/phoenix/reference/action/item.hpp
--- higan/phoenix/reference/action/item.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/action/item.hpp	2015-09-16 13:08:13.588563371 +0900
@@ -0,0 +1,14 @@
+namespace phoenix {
+
+struct pItem : public pAction {
+  Item& item;
+
+  void setImage(const image& image);
+  void setText(string text);
+
+  pItem(Item& item) : pAction(item), item(item) {}
+  void constructor();
+  void destructor();
+};
+
+}
diff -Nru higan/phoenix/reference/action/menu.cpp nSide/phoenix/reference/action/menu.cpp
--- higan/phoenix/reference/action/menu.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/action/menu.cpp	2015-09-16 13:08:13.589563371 +0900
@@ -0,0 +1,21 @@
+namespace phoenix {
+
+void pMenu::append(Action& action) {
+}
+
+void pMenu::remove(Action& action) {
+}
+
+void pMenu::setImage(const image& image) {
+}
+
+void pMenu::setText(string text) {
+}
+
+void pMenu::constructor() {
+}
+
+void pMenu::destructor() {
+}
+
+}
diff -Nru higan/phoenix/reference/action/menu.hpp nSide/phoenix/reference/action/menu.hpp
--- higan/phoenix/reference/action/menu.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/action/menu.hpp	2015-09-16 13:08:13.588563371 +0900
@@ -0,0 +1,16 @@
+namespace phoenix {
+
+struct pMenu : public pAction {
+  Menu& menu;
+
+  void append(Action& action);
+  void remove(Action& action);
+  void setImage(const image& image);
+  void setText(string text);
+
+  pMenu(Menu& menu) : pAction(menu), menu(menu) {}
+  void constructor();
+  void destructor();
+};
+
+}
diff -Nru higan/phoenix/reference/action/radio-item.cpp nSide/phoenix/reference/action/radio-item.cpp
--- higan/phoenix/reference/action/radio-item.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/action/radio-item.cpp	2015-09-16 13:08:13.588563371 +0900
@@ -0,0 +1,18 @@
+namespace phoenix {
+
+void pRadioItem::setChecked() {
+}
+
+void pRadioItem::setGroup(const group<RadioItem>& group) {
+}
+
+void pRadioItem::setText(string text) {
+}
+
+void pRadioItem::constructor() {
+}
+
+void pRadioItem::destructor() {
+}
+
+}
diff -Nru higan/phoenix/reference/action/radio-item.hpp nSide/phoenix/reference/action/radio-item.hpp
--- higan/phoenix/reference/action/radio-item.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/action/radio-item.hpp	2015-09-16 13:08:13.589563371 +0900
@@ -0,0 +1,15 @@
+namespace phoenix {
+
+struct pRadioItem : public pAction {
+  RadioItem& radioItem;
+
+  void setChecked();
+  void setGroup(const group<RadioItem>& group);
+  void setText(string text);
+
+  pRadioItem(RadioItem& radioItem) : pAction(radioItem), radioItem(radioItem) {}
+  void constructor();
+  void destructor();
+};
+
+}
diff -Nru higan/phoenix/reference/action/separator.cpp nSide/phoenix/reference/action/separator.cpp
--- higan/phoenix/reference/action/separator.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/action/separator.cpp	2015-09-16 13:08:13.588563371 +0900
@@ -0,0 +1,9 @@
+namespace phoenix {
+
+void pSeparator::constructor() {
+}
+
+void pSeparator::destructor() {
+}
+
+}
diff -Nru higan/phoenix/reference/action/separator.hpp nSide/phoenix/reference/action/separator.hpp
--- higan/phoenix/reference/action/separator.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/action/separator.hpp	2015-09-16 13:08:13.588563371 +0900
@@ -0,0 +1,11 @@
+namespace phoenix {
+
+struct pSeparator : public pAction {
+  Separator& separator;
+
+  pSeparator(Separator& separator) : pAction(separator), separator(separator) {}
+  void constructor();
+  void destructor();
+};
+
+}
diff -Nru higan/phoenix/reference/application.cpp nSide/phoenix/reference/application.cpp
--- higan/phoenix/reference/application.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/application.cpp	2015-09-16 13:08:13.594563372 +0900
@@ -0,0 +1,19 @@
+namespace phoenix {
+
+void pApplication::run() {
+}
+
+bool pApplication::pendingEvents() {
+  return false;
+}
+
+void pApplication::processEvents() {
+}
+
+void pApplication::quit() {
+}
+
+void pApplication::initialize() {
+}
+
+}
diff -Nru higan/phoenix/reference/application.hpp nSide/phoenix/reference/application.hpp
--- higan/phoenix/reference/application.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/application.hpp	2015-09-16 13:08:13.594563372 +0900
@@ -0,0 +1,12 @@
+namespace phoenix {
+
+struct pApplication {
+  static void run();
+  static bool pendingEvents();
+  static void processEvents();
+  static void quit();
+
+  static void initialize();
+};
+
+}
diff -Nru higan/phoenix/reference/browser-window.cpp nSide/phoenix/reference/browser-window.cpp
--- higan/phoenix/reference/browser-window.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/browser-window.cpp	2015-09-16 13:08:13.595563372 +0900
@@ -0,0 +1,15 @@
+namespace phoenix {
+
+string pBrowserWindow::directory(BrowserWindow::State& state) {
+  return "";
+}
+
+string pBrowserWindow::open(BrowserWindow::State& state) {
+  return "";
+}
+
+string pBrowserWindow::save(BrowserWindow::State& state) {
+  return "";
+}
+
+}
diff -Nru higan/phoenix/reference/browser-window.hpp nSide/phoenix/reference/browser-window.hpp
--- higan/phoenix/reference/browser-window.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/browser-window.hpp	2015-09-16 13:08:13.595563372 +0900
@@ -0,0 +1,9 @@
+namespace phoenix {
+
+struct pBrowserWindow {
+  static string directory(BrowserWindow::State& state);
+  static string open(BrowserWindow::State& state);
+  static string save(BrowserWindow::State& state);
+};
+
+}
diff -Nru higan/phoenix/reference/desktop.cpp nSide/phoenix/reference/desktop.cpp
--- higan/phoenix/reference/desktop.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/desktop.cpp	2015-09-16 13:08:13.588563371 +0900
@@ -0,0 +1,11 @@
+namespace phoenix {
+
+Size pDesktop::size() {
+  return {0, 0};
+}
+
+Geometry pDesktop::workspace() {
+  return {0, 0, 0, 0};
+}
+
+}
diff -Nru higan/phoenix/reference/desktop.hpp nSide/phoenix/reference/desktop.hpp
--- higan/phoenix/reference/desktop.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/desktop.hpp	2015-09-16 13:08:13.595563372 +0900
@@ -0,0 +1,8 @@
+namespace phoenix {
+
+struct pDesktop {
+  static Size size();
+  static Geometry workspace();
+};
+
+}
diff -Nru higan/phoenix/reference/font.cpp nSide/phoenix/reference/font.cpp
--- higan/phoenix/reference/font.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/font.cpp	2015-09-16 13:08:13.594563372 +0900
@@ -0,0 +1,19 @@
+namespace phoenix {
+
+string pFont::serif(unsigned size, string style) {
+  return "";
+}
+
+string pFont::sans(unsigned size, string style) {
+  return "";
+}
+
+string pFont::monospace(unsigned size, string style) {
+  return "";
+}
+
+Size pFont::size(string font, string text) {
+  return {0, 0};
+}
+
+}
diff -Nru higan/phoenix/reference/font.hpp nSide/phoenix/reference/font.hpp
--- higan/phoenix/reference/font.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/font.hpp	2015-09-16 13:08:13.589563371 +0900
@@ -0,0 +1,10 @@
+namespace phoenix {
+
+struct pFont {
+  static string serif(unsigned size, string style);
+  static string sans(unsigned size, string style);
+  static string monospace(unsigned size, string style);
+  static Size size(string font, string text);
+};
+
+}
diff -Nru higan/phoenix/reference/keyboard.cpp nSide/phoenix/reference/keyboard.cpp
--- higan/phoenix/reference/keyboard.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/keyboard.cpp	2015-09-16 13:08:13.594563372 +0900
@@ -0,0 +1,14 @@
+namespace phoenix {
+
+bool pKeyboard::pressed(Keyboard::Scancode scancode) {
+  return false;
+}
+
+vector<bool> pKeyboard::state() {
+  vector<bool> output;
+  output.resize((unsigned)Keyboard::Scancode::Limit);
+  for(auto& n : output) n = false;
+  return output;
+}
+
+}
diff -Nru higan/phoenix/reference/keyboard.hpp nSide/phoenix/reference/keyboard.hpp
--- higan/phoenix/reference/keyboard.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/keyboard.hpp	2015-09-16 13:08:13.595563372 +0900
@@ -0,0 +1,8 @@
+namespace phoenix {
+
+struct pKeyboard {
+  static bool pressed(Keyboard::Scancode scancode);
+  static vector<bool> state();
+};
+
+}
diff -Nru higan/phoenix/reference/message-window.cpp nSide/phoenix/reference/message-window.cpp
--- higan/phoenix/reference/message-window.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/message-window.cpp	2015-09-16 13:08:13.594563372 +0900
@@ -0,0 +1,19 @@
+namespace phoenix {
+
+MessageWindow::Response pMessageWindow::error(MessageWindow::State& state) {
+  return MessageWindow::Response::Ok;
+}
+
+MessageWindow::Response pMessageWindow::information(MessageWindow::State& state) {
+  return MessageWindow::Response::Ok;
+}
+
+MessageWindow::Response pMessageWindow::question(MessageWindow::State& state) {
+  return MessageWindow::Response::Ok;
+}
+
+MessageWindow::Response pMessageWindow::warning(MessageWindow::State& state) {
+  return MessageWindow::Response::Ok;
+}
+
+}
diff -Nru higan/phoenix/reference/message-window.hpp nSide/phoenix/reference/message-window.hpp
--- higan/phoenix/reference/message-window.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/message-window.hpp	2015-09-16 13:08:13.595563372 +0900
@@ -0,0 +1,10 @@
+namespace phoenix {
+
+struct pMessageWindow {
+  static MessageWindow::Response error(MessageWindow::State& state);
+  static MessageWindow::Response information(MessageWindow::State& state);
+  static MessageWindow::Response question(MessageWindow::State& state);
+  static MessageWindow::Response warning(MessageWindow::State& state);
+};
+
+}
diff -Nru higan/phoenix/reference/monitor.cpp nSide/phoenix/reference/monitor.cpp
--- higan/phoenix/reference/monitor.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/monitor.cpp	2015-09-16 13:08:13.595563372 +0900
@@ -0,0 +1,15 @@
+namespace phoenix {
+
+unsigned pMonitor::count() {
+  return 1;
+}
+
+Geometry pMonitor::geometry(unsigned monitor) {
+  return {0, 0, 0, 0};
+}
+
+unsigned pMonitor::primary() {
+  return 0;
+}
+
+}
diff -Nru higan/phoenix/reference/monitor.hpp nSide/phoenix/reference/monitor.hpp
--- higan/phoenix/reference/monitor.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/monitor.hpp	2015-09-16 13:08:13.588563371 +0900
@@ -0,0 +1,9 @@
+namespace phoenix {
+
+struct pMonitor {
+  static unsigned count();
+  static Geometry geometry(unsigned monitor);
+  static unsigned primary();
+};
+
+}
diff -Nru higan/phoenix/reference/mouse.cpp nSide/phoenix/reference/mouse.cpp
--- higan/phoenix/reference/mouse.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/mouse.cpp	2015-09-16 13:08:13.594563372 +0900
@@ -0,0 +1,11 @@
+namespace phoenix {
+
+Position pMouse::position() {
+  return {0, 0};
+}
+
+bool pMouse::pressed(Mouse::Button button) {
+  return false;
+}
+
+}
diff -Nru higan/phoenix/reference/mouse.hpp nSide/phoenix/reference/mouse.hpp
--- higan/phoenix/reference/mouse.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/mouse.hpp	2015-09-16 13:08:13.594563372 +0900
@@ -0,0 +1,8 @@
+namespace phoenix {
+
+struct pMouse {
+  static Position position();
+  static bool pressed(Mouse::Button button);
+};
+
+}
diff -Nru higan/phoenix/reference/object.cpp nSide/phoenix/reference/object.cpp
--- higan/phoenix/reference/object.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/object.cpp	2015-09-16 13:08:13.588563371 +0900
@@ -0,0 +1,9 @@
+namespace phoenix {
+
+void pObject::constructor() {
+}
+
+void pObject::destructor() {
+}
+
+}
diff -Nru higan/phoenix/reference/object.hpp nSide/phoenix/reference/object.hpp
--- higan/phoenix/reference/object.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/object.hpp	2015-09-16 13:08:13.589563371 +0900
@@ -0,0 +1,14 @@
+namespace phoenix {
+
+struct pObject {
+  Object& object;
+  bool locked;
+
+  pObject(Object& object) : object(object), locked(locked) {}
+  virtual ~pObject() {}
+
+  void constructor();
+  void destructor();
+};
+
+}
diff -Nru higan/phoenix/reference/platform.cpp nSide/phoenix/reference/platform.cpp
--- higan/phoenix/reference/platform.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/platform.cpp	2015-09-16 13:08:13.595563372 +0900
@@ -0,0 +1,45 @@
+#include "platform.hpp"
+
+#include "font.cpp"
+#include "desktop.cpp"
+#include "monitor.cpp"
+#include "keyboard.cpp"
+#include "mouse.cpp"
+#include "browser-window.cpp"
+#include "message-window.cpp"
+#include "object.cpp"
+#include "timer.cpp"
+#include "window.cpp"
+//#include "popup-menu.cpp"
+
+#include "action/action.cpp"
+#include "action/menu.cpp"
+#include "action/separator.cpp"
+#include "action/item.cpp"
+#include "action/check-item.cpp"
+#include "action/radio-item.cpp"
+
+#include "widget/widget.cpp"
+#include "widget/button.cpp"
+#include "widget/canvas.cpp"
+#include "widget/check-button.cpp"
+#include "widget/check-label.cpp"
+#include "widget/combo-button.cpp"
+#include "widget/console.cpp"
+#include "widget/frame.cpp"
+#include "widget/hex-edit.cpp"
+#include "widget/horizontal-scroller.cpp"
+#include "widget/horizontal-slider.cpp"
+#include "widget/label.cpp"
+#include "widget/line-edit.cpp"
+#include "widget/list-view.cpp"
+#include "widget/progress-bar.cpp"
+#include "widget/radio-button.cpp"
+#include "widget/radio-label.cpp"
+#include "widget/tab-frame.cpp"
+#include "widget/text-edit.cpp"
+#include "widget/vertical-scroller.cpp"
+#include "widget/vertical-slider.cpp"
+#include "widget/viewport.cpp"
+
+#include "application.cpp"
diff -Nru higan/phoenix/reference/platform.hpp nSide/phoenix/reference/platform.hpp
--- higan/phoenix/reference/platform.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/platform.hpp	2015-09-16 13:08:13.589563371 +0900
@@ -0,0 +1,53 @@
+namespace phoenix {
+  struct pFont;
+  struct pWindow;
+  struct pMenu;
+  struct pLayout;
+  struct pWidget;
+}
+
+#include "font.hpp"
+#include "desktop.hpp"
+#include "monitor.hpp"
+#include "keyboard.hpp"
+#include "mouse.hpp"
+#include "browser-window.hpp"
+#include "message-window.hpp"
+#include "object.hpp"
+#include "timer.hpp"
+#include "window.hpp"
+//#include "popup-menu.hpp"
+
+#include "action/action.hpp"
+#include "action/menu.hpp"
+#include "action/separator.hpp"
+#include "action/item.hpp"
+#include "action/check-item.hpp"
+#include "action/radio-item.hpp"
+
+#include "widget/sizable.hpp"
+#include "widget/layout.hpp"
+#include "widget/widget.hpp"
+#include "widget/button.hpp"
+#include "widget/canvas.hpp"
+#include "widget/check-button.hpp"
+#include "widget/check-label.hpp"
+#include "widget/combo-button.hpp"
+#include "widget/console.hpp"
+#include "widget/frame.hpp"
+#include "widget/hex-edit.hpp"
+#include "widget/horizontal-scroller.hpp"
+#include "widget/horizontal-slider.hpp"
+#include "widget/label.hpp"
+#include "widget/line-edit.hpp"
+#include "widget/list-view.hpp"
+#include "widget/progress-bar.hpp"
+#include "widget/radio-button.hpp"
+#include "widget/radio-label.hpp"
+#include "widget/tab-frame.hpp"
+#include "widget/text-edit.hpp"
+#include "widget/vertical-scroller.hpp"
+#include "widget/vertical-slider.hpp"
+#include "widget/viewport.hpp"
+
+#include "application.hpp"
diff -Nru higan/phoenix/reference/popup-menu.cpp nSide/phoenix/reference/popup-menu.cpp
--- higan/phoenix/reference/popup-menu.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/popup-menu.cpp	2015-09-16 13:08:13.595563372 +0900
@@ -0,0 +1,18 @@
+namespace phoenix {
+
+void pPopupMenu::append(Action& action) {
+}
+
+void pPopupMenu::remove(Action& action) {
+}
+
+void pPopupMenu::setVisible() {
+}
+
+void pPopupMenu::constructor() {
+}
+
+void pPopupMenu::destructor() {
+}
+
+}
diff -Nru higan/phoenix/reference/popup-menu.hpp nSide/phoenix/reference/popup-menu.hpp
--- higan/phoenix/reference/popup-menu.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/popup-menu.hpp	2015-09-16 13:08:13.594563372 +0900
@@ -0,0 +1,15 @@
+namespace phoenix {
+
+struct pPopupMenu : public pObject {
+  PopupMenu& popupMenu;
+
+  void append(Action& action);
+  void remove(Action& action);
+  void setVisible();
+
+  pPopupMenu(PopupMenu& popupMenu) : pObject(popupMenu), popupMenu(popupMenu) {}
+  void constructor();
+  void destructor();
+};
+
+}
diff -Nru higan/phoenix/reference/timer.cpp nSide/phoenix/reference/timer.cpp
--- higan/phoenix/reference/timer.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/timer.cpp	2015-09-16 13:08:13.594563372 +0900
@@ -0,0 +1,15 @@
+namespace phoenix {
+
+void pTimer::setEnabled(bool enabled) {
+}
+
+void pTimer::setInterval(unsigned interval) {
+}
+
+void pTimer::constructor() {
+}
+
+void pTimer::destructor() {
+}
+
+}
diff -Nru higan/phoenix/reference/timer.hpp nSide/phoenix/reference/timer.hpp
--- higan/phoenix/reference/timer.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/timer.hpp	2015-09-16 13:08:13.589563371 +0900
@@ -0,0 +1,14 @@
+namespace phoenix {
+
+struct pTimer : public pObject {
+  Timer& timer;
+
+  void setEnabled(bool enabled);
+  void setInterval(unsigned interval);
+
+  pTimer(Timer& timer) : pObject(timer), timer(timer) {}
+  void constructor();
+  void destructor();
+};
+
+}
diff -Nru higan/phoenix/reference/widget/button.cpp nSide/phoenix/reference/widget/button.cpp
--- higan/phoenix/reference/widget/button.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/widget/button.cpp	2015-09-16 13:08:13.589563371 +0900
@@ -0,0 +1,18 @@
+namespace phoenix {
+
+void pButton::setBordered(bool bordered) {
+}
+
+void pButton::setImage(const image& image, Orientation orientation) {
+}
+
+void pButton::setText(string text) {
+}
+
+void pButton::constructor() {
+}
+
+void pButton::destructor() {
+}
+
+}
diff -Nru higan/phoenix/reference/widget/button.hpp nSide/phoenix/reference/widget/button.hpp
--- higan/phoenix/reference/widget/button.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/widget/button.hpp	2015-09-16 13:08:13.590563371 +0900
@@ -0,0 +1,15 @@
+namespace phoenix {
+
+struct pButton : public pWidget {
+  Button& button;
+
+  void setBordered(bool bordered);
+  void setImage(const image& image, Orientation orientation);
+  void setText(string text);
+
+  pButton(Button& button) : pWidget(button), button(button) {}
+  void constructor();
+  void destructor();
+};
+
+}
diff -Nru higan/phoenix/reference/widget/canvas.cpp nSide/phoenix/reference/widget/canvas.cpp
--- higan/phoenix/reference/widget/canvas.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/widget/canvas.cpp	2015-09-16 13:08:13.590563371 +0900
@@ -0,0 +1,18 @@
+namespace phoenix {
+
+void pCanvas::setDroppable(bool droppable) {
+}
+
+void pCanvas::setMode(Canvas::Mode mode) {
+}
+
+void pCanvas::setSize(Size size) {
+}
+
+void pCanvas::constructor() {
+}
+
+void pCanvas::destructor() {
+}
+
+}
diff -Nru higan/phoenix/reference/widget/canvas.hpp nSide/phoenix/reference/widget/canvas.hpp
--- higan/phoenix/reference/widget/canvas.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/widget/canvas.hpp	2015-09-16 13:08:13.591563372 +0900
@@ -0,0 +1,15 @@
+namespace phoenix {
+
+struct pCanvas : public pWidget {
+  Canvas& canvas;
+
+  void setDroppable(bool droppable);
+  void setMode(Canvas::Mode mode);
+  void setSize(Size size);
+
+  pCanvas(Canvas& canvas) : pWidget(canvas), canvas(canvas) {}
+  void constructor();
+  void destructor();
+};
+
+}
diff -Nru higan/phoenix/reference/widget/check-button.cpp nSide/phoenix/reference/widget/check-button.cpp
--- higan/phoenix/reference/widget/check-button.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/widget/check-button.cpp	2015-09-16 13:08:13.590563371 +0900
@@ -0,0 +1,18 @@
+namespace phoenix {
+
+void pCheckButton::setChecked(bool checked) {
+}
+
+void pCheckButton::setImage(const image& image, Orientation orientation) {
+}
+
+void pCheckButton::setText(string text) {
+}
+
+void pCheckButton::constructor() {
+}
+
+void pCheckButton::destructor() {
+}
+
+}
diff -Nru higan/phoenix/reference/widget/check-button.hpp nSide/phoenix/reference/widget/check-button.hpp
--- higan/phoenix/reference/widget/check-button.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/widget/check-button.hpp	2015-09-16 13:08:13.590563371 +0900
@@ -0,0 +1,15 @@
+namespace phoenix {
+
+struct pCheckButton : public pWidget {
+  CheckButton& checkButton;
+
+  void setChecked(bool checked);
+  void setImage(const image& image, Orientation orientation);
+  void setText(string text);
+
+  pCheckButton(CheckButton& checkButton) : pWidget(checkButton), checkButton(checkButton) {}
+  void constructor();
+  void destructor();
+};
+
+}
diff -Nru higan/phoenix/reference/widget/check-label.cpp nSide/phoenix/reference/widget/check-label.cpp
--- higan/phoenix/reference/widget/check-label.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/widget/check-label.cpp	2015-09-16 13:08:13.590563371 +0900
@@ -0,0 +1,15 @@
+namespace phoenix {
+
+void pCheckLabel::setChecked(bool checked) {
+}
+
+void pCheckLabel::setText(string text) {
+}
+
+void pCheckLabel::constructor() {
+}
+
+void pCheckLabel::destructor() {
+}
+
+}
diff -Nru higan/phoenix/reference/widget/check-label.hpp nSide/phoenix/reference/widget/check-label.hpp
--- higan/phoenix/reference/widget/check-label.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/widget/check-label.hpp	2015-09-16 13:08:13.591563372 +0900
@@ -0,0 +1,14 @@
+namespace phoenix {
+
+struct pCheckLabel : public pWidget {
+  CheckLabel& checkLabel;
+
+  void setChecked(bool checked);
+  void setText(string text);
+
+  pCheckLabel(CheckLabel& checkLabel) : pWidget(checkLabel), checkLabel(checkLabel) {}
+  void constructor();
+  void destructor();
+};
+
+}
diff -Nru higan/phoenix/reference/widget/combo-button.cpp nSide/phoenix/reference/widget/combo-button.cpp
--- higan/phoenix/reference/widget/combo-button.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/widget/combo-button.cpp	2015-09-16 13:08:13.590563371 +0900
@@ -0,0 +1,24 @@
+namespace phoenix {
+
+void pComboButton::append() {
+}
+
+void pComboButton::remove(unsigned selection) {
+}
+
+void pComboButton::reset() {
+}
+
+void pComboButton::setSelected(unsigned selection) {
+}
+
+void pComboButton::setText(unsigned selection, string text) {
+}
+
+void pComboButton::constructor() {
+}
+
+void pComboButton::destructor() {
+}
+
+}
diff -Nru higan/phoenix/reference/widget/combo-button.hpp nSide/phoenix/reference/widget/combo-button.hpp
--- higan/phoenix/reference/widget/combo-button.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/widget/combo-button.hpp	2015-09-16 13:08:13.591563372 +0900
@@ -0,0 +1,17 @@
+namespace phoenix {
+
+struct pComboButton : public pWidget {
+  ComboButton& comboButton;
+
+  void append();
+  void remove(unsigned selection);
+  void reset();
+  void setSelected(unsigned selection);
+  void setText(unsigned selection, string text);
+
+  pComboButton(ComboButton& comboButton) : pWidget(comboButton), comboButton(comboButton) {}
+  void constructor();
+  void destructor();
+};
+
+}
diff -Nru higan/phoenix/reference/widget/console.cpp nSide/phoenix/reference/widget/console.cpp
--- higan/phoenix/reference/widget/console.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/widget/console.cpp	2015-09-16 13:08:13.591563372 +0900
@@ -0,0 +1,24 @@
+namespace phoenix {
+
+void pConsole::print(string text) {
+}
+
+void pConsole::reset() {
+}
+
+void pConsole::setBackgroundColor(Color color) {
+}
+
+void pConsole::setForegroundColor(Color color) {
+}
+
+void pConsole::setPrompt(string prompt) {
+}
+
+void pConsole::constructor() {
+}
+
+void pConsole::destructor() {
+}
+
+}
diff -Nru higan/phoenix/reference/widget/console.hpp nSide/phoenix/reference/widget/console.hpp
--- higan/phoenix/reference/widget/console.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/widget/console.hpp	2015-09-16 13:08:13.593563372 +0900
@@ -0,0 +1,17 @@
+namespace phoenix {
+
+struct pConsole : public pWidget {
+  Console& console;
+
+  void print(string text);
+  void reset();
+  void setBackgroundColor(Color color);
+  void setForegroundColor(Color color);
+  void setPrompt(string prompt);
+
+  pConsole(Console& console) : pWidget(console), console(console) {}
+  void constructor();
+  void destructor();
+};
+
+}
diff -Nru higan/phoenix/reference/widget/frame.cpp nSide/phoenix/reference/widget/frame.cpp
--- higan/phoenix/reference/widget/frame.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/widget/frame.cpp	2015-09-16 13:08:13.591563372 +0900
@@ -0,0 +1,12 @@
+namespace phoenix {
+
+void pFrame::setText(string text) {
+}
+
+void pFrame::constructor() {
+}
+
+void pFrame::destructor() {
+}
+
+}
diff -Nru higan/phoenix/reference/widget/frame.hpp nSide/phoenix/reference/widget/frame.hpp
--- higan/phoenix/reference/widget/frame.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/widget/frame.hpp	2015-09-16 13:08:13.592563372 +0900
@@ -0,0 +1,13 @@
+namespace phoenix {
+
+struct pFrame : public pWidget {
+  Frame& frame;
+
+  void setText(string text);
+
+  pFrame(Frame& frame) : pWidget(frame), frame(frame) {}
+  void constructor();
+  void destructor();
+};
+
+}
diff -Nru higan/phoenix/reference/widget/hex-edit.cpp nSide/phoenix/reference/widget/hex-edit.cpp
--- higan/phoenix/reference/widget/hex-edit.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/widget/hex-edit.cpp	2015-09-16 13:08:13.593563372 +0900
@@ -0,0 +1,30 @@
+namespace phoenix {
+
+void pHexEdit::setBackgroundColor(Color color) {
+}
+
+void pHexEdit::setColumns(unsigned columns) {
+}
+
+void pHexEdit::setForegroundColor(Color color) {
+}
+
+void pHexEdit::setLength(unsigned length) {
+}
+
+void pHexEdit::setOffset(unsigned offset) {
+}
+
+void pHexEdit::setRows(unsigned rows) {
+}
+
+void pHexEdit::update() {
+}
+
+void pHexEdit::constructor() {
+}
+
+void pHexEdit::destructor() {
+}
+
+}
diff -Nru higan/phoenix/reference/widget/hex-edit.hpp nSide/phoenix/reference/widget/hex-edit.hpp
--- higan/phoenix/reference/widget/hex-edit.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/widget/hex-edit.hpp	2015-09-16 13:08:13.590563371 +0900
@@ -0,0 +1,19 @@
+namespace phoenix {
+
+struct pHexEdit : public pWidget {
+  HexEdit& hexEdit;
+
+  void setBackgroundColor(Color color);
+  void setColumns(unsigned columns);
+  void setForegroundColor(Color color);
+  void setLength(unsigned length);
+  void setOffset(unsigned offset);
+  void setRows(unsigned rows);
+  void update();
+
+  pHexEdit(HexEdit& hexEdit) : pWidget(hexEdit), hexEdit(hexEdit) {}
+  void constructor();
+  void destructor();
+};
+
+}
diff -Nru higan/phoenix/reference/widget/horizontal-scroller.cpp nSide/phoenix/reference/widget/horizontal-scroller.cpp
--- higan/phoenix/reference/widget/horizontal-scroller.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/widget/horizontal-scroller.cpp	2015-09-16 13:08:13.592563372 +0900
@@ -0,0 +1,15 @@
+namespace phoenix {
+
+void pHorizontalScroller::setLength(unsigned length) {
+}
+
+void pHorizontalScroller::setPosition(unsigned position) {
+}
+
+void pHorizontalScroller::constructor() {
+}
+
+void pHorizontalScroller::destructor() {
+}
+
+}
diff -Nru higan/phoenix/reference/widget/horizontal-scroller.hpp nSide/phoenix/reference/widget/horizontal-scroller.hpp
--- higan/phoenix/reference/widget/horizontal-scroller.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/widget/horizontal-scroller.hpp	2015-09-16 13:08:13.592563372 +0900
@@ -0,0 +1,14 @@
+namespace phoenix {
+
+struct pHorizontalScroller : public pWidget {
+  HorizontalScroller& horizontalScroller;
+
+  void setLength(unsigned length);
+  void setPosition(unsigned position);
+
+  pHorizontalScroller(HorizontalScroller& horizontalScroller) : pWidget(horizontalScroller), horizontalScroller(horizontalScroller) {}
+  void constructor();
+  void destructor();
+};
+
+}
diff -Nru higan/phoenix/reference/widget/horizontal-slider.cpp nSide/phoenix/reference/widget/horizontal-slider.cpp
--- higan/phoenix/reference/widget/horizontal-slider.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/widget/horizontal-slider.cpp	2015-09-16 13:08:13.590563371 +0900
@@ -0,0 +1,15 @@
+namespace phoenix {
+
+void pHorizontalSlider::setLength(unsigned length) {
+}
+
+void pHorizontalSlider::setPosition(unsigned position) {
+}
+
+void pHorizontalSlider::constructor() {
+}
+
+void pHorizontalSlider::destructor() {
+}
+
+}
diff -Nru higan/phoenix/reference/widget/horizontal-slider.hpp nSide/phoenix/reference/widget/horizontal-slider.hpp
--- higan/phoenix/reference/widget/horizontal-slider.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/widget/horizontal-slider.hpp	2015-09-16 13:08:13.590563371 +0900
@@ -0,0 +1,14 @@
+namespace phoenix {
+
+struct pHorizontalSlider : public pWidget {
+  HorizontalSlider& horizontalSlider;
+
+  void setLength(unsigned length);
+  void setPosition(unsigned position);
+
+  pHorizontalSlider(HorizontalSlider& horizontalSlider) : pWidget(horizontalSlider), horizontalSlider(horizontalSlider) {}
+  void constructor();
+  void destructor();
+};
+
+}
diff -Nru higan/phoenix/reference/widget/label.cpp nSide/phoenix/reference/widget/label.cpp
--- higan/phoenix/reference/widget/label.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/widget/label.cpp	2015-09-16 13:08:13.592563372 +0900
@@ -0,0 +1,12 @@
+namespace phoenix {
+
+void pLabel::setText(string text) {
+}
+
+void pLabel::constructor() {
+}
+
+void pLabel::destructor() {
+}
+
+}
diff -Nru higan/phoenix/reference/widget/label.hpp nSide/phoenix/reference/widget/label.hpp
--- higan/phoenix/reference/widget/label.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/widget/label.hpp	2015-09-16 13:08:13.591563372 +0900
@@ -0,0 +1,13 @@
+namespace phoenix {
+
+struct pLabel : public pWidget {
+  Label& label;
+
+  void setText(string text);
+
+  pLabel(Label& label) : pWidget(label), label(label) {}
+  void constructor();
+  void destructor();
+};
+
+}
diff -Nru higan/phoenix/reference/widget/layout.hpp nSide/phoenix/reference/widget/layout.hpp
--- higan/phoenix/reference/widget/layout.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/widget/layout.hpp	2015-09-16 13:08:13.593563372 +0900
@@ -0,0 +1,9 @@
+namespace phoenix {
+
+struct pLayout : public pSizable {
+  Layout& layout;
+
+  pLayout(Layout& layout) : pSizable(layout), layout(layout) {}
+};
+
+}
diff -Nru higan/phoenix/reference/widget/line-edit.cpp nSide/phoenix/reference/widget/line-edit.cpp
--- higan/phoenix/reference/widget/line-edit.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/widget/line-edit.cpp	2015-09-16 13:08:13.592563372 +0900
@@ -0,0 +1,24 @@
+namespace phoenix {
+
+void pLineEdit::setBackgroundColor(Color color) {
+}
+
+void pLineEdit::setEditable(bool editable) {
+}
+
+void pLineEdit::setForegroundColor(Color color) {
+}
+
+void pLineEdit::setText(string text) {
+}
+
+string pLineEdit::text() {
+}
+
+void pLineEdit::constructor() {
+}
+
+void pLineEdit::destructor() {
+}
+
+}
diff -Nru higan/phoenix/reference/widget/line-edit.hpp nSide/phoenix/reference/widget/line-edit.hpp
--- higan/phoenix/reference/widget/line-edit.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/widget/line-edit.hpp	2015-09-16 13:08:13.593563372 +0900
@@ -0,0 +1,17 @@
+namespace phoenix {
+
+struct pLineEdit : public pWidget {
+  LineEdit& lineEdit;
+
+  void setBackgroundColor(Color color);
+  void setEditable(bool editable);
+  void setForegroundColor(Color color);
+  void setText(string text);
+  string text();
+
+  pLineEdit(LineEdit& lineEdit) : pWidget(lineEdit), lineEdit(lineEdit) {}
+  void constructor();
+  void destructor();
+};
+
+}
diff -Nru higan/phoenix/reference/widget/list-view.cpp nSide/phoenix/reference/widget/list-view.cpp
--- higan/phoenix/reference/widget/list-view.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/widget/list-view.cpp	2015-09-16 13:08:13.592563372 +0900
@@ -0,0 +1,69 @@
+namespace phoenix {
+
+void pListView::append() {
+}
+
+void pListView::autoSizeColumns() {
+}
+
+void pListView::remove(unsigned selection) {
+}
+
+void pListView::reset() {
+}
+
+void pListView::setBackgroundColor(Color color) {
+}
+
+void pListView::setCheckable(bool checkable) {
+}
+
+void pListView::setChecked(unsigned selection, bool checked) {
+}
+
+void pListView::setChecked(const vector<unsigned>& selections) {
+}
+
+void pListView::setCheckedAll() {
+}
+
+void pListView::setCheckedNone() {
+}
+
+void pListView::setForegroundColor(Color color) {
+}
+
+void pListView::setHeaderText(const lstring& text) {
+}
+
+void pListView::setHeaderVisible(bool visible) {
+}
+
+void pListView::setImage(unsigned selection, unsigned position, const image& image) {
+}
+
+void pListView::setSelected(unsigned selection, bool selected) {
+}
+
+void pListView::setSelected(const vector<unsigned>& selections) {
+}
+
+void pListView::setSelectedAll() {
+}
+
+void pListView::setSelectedNone() {
+}
+
+void pListView::setSingleSelection(bool singleSelection) {
+}
+
+void pListView::setText(unsigned selection, unsigned position, string text) {
+}
+
+void pListView::constructor() {
+}
+
+void pListView::destructor() {
+}
+
+}
diff -Nru higan/phoenix/reference/widget/list-view.hpp nSide/phoenix/reference/widget/list-view.hpp
--- higan/phoenix/reference/widget/list-view.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/widget/list-view.hpp	2015-09-16 13:08:13.593563372 +0900
@@ -0,0 +1,32 @@
+namespace phoenix {
+
+struct pListView : public pWidget {
+  ListView& listView;
+
+  void append();
+  void autoSizeColumns();
+  void remove(unsigned selection);
+  void reset();
+  void setBackgroundColor(Color color);
+  void setCheckable(bool checkable);
+  void setChecked(unsigned selection, bool checked);
+  void setChecked(const vector<unsigned>& selections);
+  void setCheckedAll();
+  void setCheckedNone();
+  void setForegroundColor(Color color);
+  void setHeaderText(const lstring& text);
+  void setHeaderVisible(bool visible);
+  void setImage(unsigned selection, unsigned position, const image& image);
+  void setSelected(unsigned selection, bool selected);
+  void setSelected(const vector<unsigned>& selections);
+  void setSelectedAll();
+  void setSelectedNone();
+  void setSingleSelection(bool singleSelection);
+  void setText(unsigned selection, unsigned position, string text);
+
+  pListView(ListView& listView) : pWidget(listView), listView(listView) {}
+  void constructor();
+  void destructor();
+};
+
+}
diff -Nru higan/phoenix/reference/widget/progress-bar.cpp nSide/phoenix/reference/widget/progress-bar.cpp
--- higan/phoenix/reference/widget/progress-bar.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/widget/progress-bar.cpp	2015-09-16 13:08:13.593563372 +0900
@@ -0,0 +1,12 @@
+namespace phoenix {
+
+void pProgressBar::setPosition(unsigned position) {
+}
+
+void pProgressBar::constructor() {
+}
+
+void pProgressBar::destructor() {
+}
+
+}
diff -Nru higan/phoenix/reference/widget/progress-bar.hpp nSide/phoenix/reference/widget/progress-bar.hpp
--- higan/phoenix/reference/widget/progress-bar.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/widget/progress-bar.hpp	2015-09-16 13:08:13.589563371 +0900
@@ -0,0 +1,13 @@
+namespace phoenix {
+
+struct pProgressBar : public pWidget {
+  ProgressBar& progressBar;
+
+  void setPosition(unsigned position);
+
+  pProgressBar(ProgressBar& progressBar) : pWidget(progressBar), progressBar(progressBar) {}
+  void constructor();
+  void destructor();
+};
+
+}
diff -Nru higan/phoenix/reference/widget/radio-button.cpp nSide/phoenix/reference/widget/radio-button.cpp
--- higan/phoenix/reference/widget/radio-button.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/widget/radio-button.cpp	2015-09-16 13:08:13.592563372 +0900
@@ -0,0 +1,21 @@
+namespace phoenix {
+
+void pRadioButton::setChecked() {
+}
+
+void pRadioButton::setGroup(const group<RadioButton>& group) {
+}
+
+void pRadioButton::setImage(const image& image, Orientation orientation) {
+}
+
+void pRadioButton::setText(string text) {
+}
+
+void pRadioButton::constructor() {
+}
+
+void pRadioButton::destructor() {
+}
+
+}
diff -Nru higan/phoenix/reference/widget/radio-button.hpp nSide/phoenix/reference/widget/radio-button.hpp
--- higan/phoenix/reference/widget/radio-button.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/widget/radio-button.hpp	2015-09-16 13:08:13.593563372 +0900
@@ -0,0 +1,16 @@
+namespace phoenix {
+
+struct pRadioButton : public pWidget {
+  RadioButton& radioButton;
+
+  void setChecked();
+  void setGroup(const group<RadioButton>& group);
+  void setImage(const image& image, Orientation orientation);
+  void setText(string text);
+
+  pRadioButton(RadioButton& radioButton) : pWidget(radioButton), radioButton(radioButton) {}
+  void constructor();
+  void destructor();
+};
+
+}
diff -Nru higan/phoenix/reference/widget/radio-label.cpp nSide/phoenix/reference/widget/radio-label.cpp
--- higan/phoenix/reference/widget/radio-label.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/widget/radio-label.cpp	2015-09-16 13:08:13.593563372 +0900
@@ -0,0 +1,18 @@
+namespace phoenix {
+
+void pRadioLabel::setChecked() {
+}
+
+void pRadioLabel::setGroup(const group<RadioLabel>& group) {
+}
+
+void pRadioLabel::setText(string text) {
+}
+
+void pRadioLabel::constructor() {
+}
+
+void pRadioLabel::destructor() {
+}
+
+}
diff -Nru higan/phoenix/reference/widget/radio-label.hpp nSide/phoenix/reference/widget/radio-label.hpp
--- higan/phoenix/reference/widget/radio-label.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/widget/radio-label.hpp	2015-09-16 13:08:13.590563371 +0900
@@ -0,0 +1,15 @@
+namespace phoenix {
+
+struct pRadioLabel : public pWidget {
+  RadioLabel& radioLabel;
+
+  void setChecked();
+  void setGroup(const group<RadioLabel>& group);
+  void setText(string text);
+
+  pRadioLabel(RadioLabel& radioLabel) : pWidget(radioLabel), radioLabel(radioLabel) {}
+  void constructor();
+  void destructor();
+};
+
+}
diff -Nru higan/phoenix/reference/widget/sizable.hpp nSide/phoenix/reference/widget/sizable.hpp
--- higan/phoenix/reference/widget/sizable.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/widget/sizable.hpp	2015-09-16 13:08:13.592563372 +0900
@@ -0,0 +1,9 @@
+namespace phoenix {
+
+struct pSizable : public pObject {
+  Sizable& sizable;
+
+  pSizable(Sizable& sizable) : pObject(sizable), sizable(sizable) {}
+};
+
+}
diff -Nru higan/phoenix/reference/widget/tab-frame.cpp nSide/phoenix/reference/widget/tab-frame.cpp
--- higan/phoenix/reference/widget/tab-frame.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/widget/tab-frame.cpp	2015-09-16 13:08:13.592563372 +0900
@@ -0,0 +1,24 @@
+namespace phoenix {
+
+void pTabFrame::append() {
+}
+
+void pTabFrame::remove(unsigned selection) {
+}
+
+void pTabFrame::setImage(unsigned selection, const image& image) {
+}
+
+void pTabFrame::setSelected(unsigned selection) {
+}
+
+void pTabFrame::setText(unsigned selection, string text) {
+}
+
+void pTabFrame::constructor() {
+}
+
+void pTabFrame::destructor() {
+}
+
+}
diff -Nru higan/phoenix/reference/widget/tab-frame.hpp nSide/phoenix/reference/widget/tab-frame.hpp
--- higan/phoenix/reference/widget/tab-frame.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/widget/tab-frame.hpp	2015-09-16 13:08:13.591563372 +0900
@@ -0,0 +1,17 @@
+namespace phoenix {
+
+struct pTabFrame : public pWidget {
+  TabFrame& tabFrame;
+
+  void append();
+  void remove(unsigned selection);
+  void setImage(unsigned selection, const image& image);
+  void setSelected(unsigned selection);
+  void setText(unsigned selection, string text);
+
+  pTabFrame(TabFrame& tabFrame) : pWidget(tabFrame), tabFrame(tabFrame) {}
+  void constructor();
+  void destructor();
+};
+
+}
diff -Nru higan/phoenix/reference/widget/text-edit.cpp nSide/phoenix/reference/widget/text-edit.cpp
--- higan/phoenix/reference/widget/text-edit.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/widget/text-edit.cpp	2015-09-16 13:08:13.592563372 +0900
@@ -0,0 +1,30 @@
+namespace phoenix {
+
+void pTextEdit::setBackgroundColor(Color color) {
+}
+
+void pTextEdit::setCursorPosition(unsigned position) {
+}
+
+void pTextEdit::setEditable(bool editable) {
+}
+
+void pTextEdit::setForegroundColor(Color color) {
+}
+
+void pTextEdit::setText(string text) {
+}
+
+void pTextEdit::setWordWrap(bool wordWrap) {
+}
+
+string pTextEdit::text() {
+}
+
+void pTextEdit::constructor() {
+}
+
+void pTextEdit::destructor() {
+}
+
+}
diff -Nru higan/phoenix/reference/widget/text-edit.hpp nSide/phoenix/reference/widget/text-edit.hpp
--- higan/phoenix/reference/widget/text-edit.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/widget/text-edit.hpp	2015-09-16 13:08:13.591563372 +0900
@@ -0,0 +1,19 @@
+namespace phoenix {
+
+struct pTextEdit : public pWidget {
+  TextEdit& textEdit;
+
+  void setBackgroundColor(Color color);
+  void setCursorPosition(unsigned position);
+  void setEditable(bool editable);
+  void setForegroundColor(Color color);
+  void setText(string text);
+  void setWordWrap(bool wordWrap);
+  string text();
+
+  pTextEdit(TextEdit& textEdit) : pWidget(textEdit), textEdit(textEdit) {}
+  void constructor();
+  void destructor();
+};
+
+}
diff -Nru higan/phoenix/reference/widget/vertical-scroller.cpp nSide/phoenix/reference/widget/vertical-scroller.cpp
--- higan/phoenix/reference/widget/vertical-scroller.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/widget/vertical-scroller.cpp	2015-09-16 13:08:13.592563372 +0900
@@ -0,0 +1,15 @@
+namespace phoenix {
+
+void pVerticalScroller::setLength(unsigned length) {
+}
+
+void pVerticalScroller::setPosition(unsigned position) {
+}
+
+void pVerticalScroller::constructor() {
+}
+
+void pVerticalScroller::destructor() {
+}
+
+}
diff -Nru higan/phoenix/reference/widget/vertical-scroller.hpp nSide/phoenix/reference/widget/vertical-scroller.hpp
--- higan/phoenix/reference/widget/vertical-scroller.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/widget/vertical-scroller.hpp	2015-09-16 13:08:13.589563371 +0900
@@ -0,0 +1,14 @@
+namespace phoenix {
+
+struct pVerticalScroller : public pWidget {
+  VerticalScroller& verticalScroller;
+
+  void setLength(unsigned length);
+  void setPosition(unsigned position);
+
+  pVerticalScroller(VerticalScroller& verticalScroller) : pWidget(verticalScroller), verticalScroller(verticalScroller) {}
+  void constructor();
+  void destructor();
+};
+
+}
diff -Nru higan/phoenix/reference/widget/vertical-slider.cpp nSide/phoenix/reference/widget/vertical-slider.cpp
--- higan/phoenix/reference/widget/vertical-slider.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/widget/vertical-slider.cpp	2015-09-16 13:08:13.593563372 +0900
@@ -0,0 +1,15 @@
+namespace phoenix {
+
+void pVerticalSlider::setLength(unsigned length) {
+}
+
+void pVerticalSlider::setPosition(unsigned position) {
+}
+
+void pVerticalSlider::constructor() {
+}
+
+void pVerticalSlider::destructor() {
+}
+
+}
diff -Nru higan/phoenix/reference/widget/vertical-slider.hpp nSide/phoenix/reference/widget/vertical-slider.hpp
--- higan/phoenix/reference/widget/vertical-slider.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/widget/vertical-slider.hpp	2015-09-16 13:08:13.589563371 +0900
@@ -0,0 +1,14 @@
+namespace phoenix {
+
+struct pVerticalSlider : public pWidget {
+  VerticalSlider& verticalSlider;
+
+  void setLength(unsigned length);
+  void setPosition(unsigned position);
+
+  pVerticalSlider(VerticalSlider& verticalSlider) : pWidget(verticalSlider), verticalSlider(verticalSlider) {}
+  void constructor();
+  void destructor();
+};
+
+}
diff -Nru higan/phoenix/reference/widget/viewport.cpp nSide/phoenix/reference/widget/viewport.cpp
--- higan/phoenix/reference/widget/viewport.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/widget/viewport.cpp	2015-09-16 13:08:13.593563372 +0900
@@ -0,0 +1,16 @@
+namespace phoenix {
+
+uintptr_t pViewport::handle() {
+  return 0;
+}
+
+void pViewport::setDroppable(bool droppable) {
+}
+
+void pViewport::constructor() {
+}
+
+void pViewport::destructor() {
+}
+
+}
diff -Nru higan/phoenix/reference/widget/viewport.hpp nSide/phoenix/reference/widget/viewport.hpp
--- higan/phoenix/reference/widget/viewport.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/widget/viewport.hpp	2015-09-16 13:08:13.591563372 +0900
@@ -0,0 +1,14 @@
+namespace phoenix {
+
+struct pViewport : public pWidget {
+  Viewport& viewport;
+
+  uintptr_t handle();
+  void setDroppable(bool droppable);
+
+  pViewport(Viewport& viewport) : pWidget(viewport), viewport(viewport) {}
+  void constructor();
+  void destructor();
+};
+
+}
diff -Nru higan/phoenix/reference/widget/widget.cpp nSide/phoenix/reference/widget/widget.cpp
--- higan/phoenix/reference/widget/widget.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/widget/widget.cpp	2015-09-16 13:08:13.590563371 +0900
@@ -0,0 +1,36 @@
+namespace phoenix {
+
+bool pWidget::enabled() {
+  return false;
+}
+
+bool pWidget::focused() {
+  return false;
+}
+
+Size pWidget::minimumSize() {
+  return {0, 0};
+}
+
+void pWidget::setEnabled(bool enabled) {
+}
+
+void pWidget::setFocused() {
+}
+
+void pWidget::setFont(string font) {
+}
+
+void pWidget::setGeometry(Geometry geometry) {
+}
+
+void pWidget::setVisible(bool visible) {
+}
+
+void pWidget::constructor() {
+}
+
+void pWidget::destructor() {
+}
+
+}
diff -Nru higan/phoenix/reference/widget/widget.hpp nSide/phoenix/reference/widget/widget.hpp
--- higan/phoenix/reference/widget/widget.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/widget/widget.hpp	2015-09-16 13:08:13.591563372 +0900
@@ -0,0 +1,20 @@
+namespace phoenix {
+
+struct pWidget : public pSizable {
+  Widget& widget;
+
+  bool enabled();
+  bool focused();
+  Size minimumSize();
+  void setEnabled(bool enabled);
+  void setFocused();
+  void setFont(string font);
+  void setGeometry(Geometry geometry);
+  void setVisible(bool visible);
+
+  pWidget(Widget& widget) : pSizable(widget), widget(widget) {}
+  void constructor();
+  void destructor();
+};
+
+}
diff -Nru higan/phoenix/reference/window.cpp nSide/phoenix/reference/window.cpp
--- higan/phoenix/reference/window.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/window.cpp	2015-09-16 13:08:13.594563372 +0900
@@ -0,0 +1,86 @@
+namespace phoenix {
+
+Window& pWindow::none() {
+  static Window* window = nullptr;
+  if(window == nullptr) window = new Window;
+  return *window;
+}
+
+void pWindow::append(Layout& layout) {
+}
+
+void pWindow::append(Menu& menu) {
+}
+
+void pWindow::append(Widget& widget) {
+}
+
+bool pWindow::focused() {
+  return false;
+}
+
+Geometry pWindow::frameMargin() {
+  return {0, 0, 0, 0};
+}
+
+void pWindow::remove(Layout& layout) {
+}
+
+void pWindow::remove(Menu& menu) {
+}
+
+void pWindow::remove(Widget& widget) {
+}
+
+void pWindow::setBackgroundColor(Color color) {
+}
+
+void pWindow::setDroppable(bool droppable) {
+}
+
+void pWindow::setFocused() {
+}
+
+void pWindow::setFullScreen(bool fullScreen) {
+}
+
+void pWindow::setGeometry(Geometry geometry) {
+}
+
+void pWindow::setMenuFont(string font) {
+}
+
+void pWindow::setMenuVisible(bool visible) {
+}
+
+void pWindow::setModal(bool modal) {
+}
+
+void pWindow::setResizable(bool resizable) {
+}
+
+void pWindow::setStatusFont(string font) {
+}
+
+void pWindow::setStatusText(string text) {
+}
+
+void pWindow::setStatusVisible(bool visible) {
+}
+
+void pWindow::setTitle(string text) {
+}
+
+void pWindow::setVisible(bool visible) {
+}
+
+void pWindow::setWidgetFont(string font) {
+}
+
+void pWindow::constructor() {
+}
+
+void pWindow::destructor() {
+}
+
+}
diff -Nru higan/phoenix/reference/window.hpp nSide/phoenix/reference/window.hpp
--- higan/phoenix/reference/window.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/reference/window.hpp	2015-09-16 13:08:13.595563372 +0900
@@ -0,0 +1,37 @@
+namespace phoenix {
+
+struct pWindow : public pObject {
+  Window& window;
+
+  static Window& none();
+
+  void append(Layout& layout);
+  void append(Menu& menu);
+  void append(Widget& widget);
+  bool focused();
+  Geometry frameMargin();
+  void remove(Layout& layout);
+  void remove(Menu& menu);
+  void remove(Widget& widget);
+  void setBackgroundColor(Color color);
+  void setDroppable(bool droppable);
+  void setFocused();
+  void setFullScreen(bool fullScreen);
+  void setGeometry(Geometry geometry);
+  void setMenuFont(string font);
+  void setMenuVisible(bool visible);
+  void setModal(bool modal);
+  void setResizable(bool resizable);
+  void setStatusFont(string font);
+  void setStatusText(string text);
+  void setStatusVisible(bool visible);
+  void setTitle(string text);
+  void setVisible(bool visible);
+  void setWidgetFont(string font);
+
+  pWindow(Window& window) : pObject(window), window(window) {}
+  void constructor();
+  void destructor();
+};
+
+}
diff -Nru higan/phoenix/windows/action/action.cpp nSide/phoenix/windows/action/action.cpp
--- higan/phoenix/windows/action/action.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/windows/action/action.cpp	2015-09-16 13:08:13.569563369 +0900
@@ -0,0 +1,16 @@
+namespace phoenix {
+
+void pAction::setEnabled(bool enabled) {
+  if(parentWindow) parentWindow->p.updateMenu();
+}
+
+void pAction::setVisible(bool visible) {
+  if(parentWindow) parentWindow->p.updateMenu();
+}
+
+void pAction::constructor() {
+  parentMenu = 0;
+  parentWindow = 0;
+}
+
+}
diff -Nru higan/phoenix/windows/action/check-item.cpp nSide/phoenix/windows/action/check-item.cpp
--- higan/phoenix/windows/action/check-item.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/windows/action/check-item.cpp	2015-09-16 13:08:13.569563369 +0900
@@ -0,0 +1,24 @@
+namespace phoenix {
+
+void pCheckItem::setChecked(bool checked) {
+  if(parentMenu) CheckMenuItem(parentMenu->p.hmenu, id, checked ? MF_CHECKED : MF_UNCHECKED);
+}
+
+void pCheckItem::setText(string text) {
+  if(parentWindow) parentWindow->p.updateMenu();
+}
+
+void pCheckItem::constructor() {
+}
+
+void pCheckItem::destructor() {
+  if(parentMenu) parentMenu->remove(checkItem);
+}
+
+void pCheckItem::onToggle() {
+  checkItem.state.checked = !checkItem.state.checked;
+  setChecked(checkItem.state.checked);
+  if(checkItem.onToggle) checkItem.onToggle();
+}
+
+}
diff -Nru higan/phoenix/windows/action/item.cpp nSide/phoenix/windows/action/item.cpp
--- higan/phoenix/windows/action/item.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/windows/action/item.cpp	2015-09-16 13:08:13.569563369 +0900
@@ -0,0 +1,37 @@
+namespace phoenix {
+
+void pItem::setImage(const image& image) {
+  createBitmap();
+  if(parentWindow) parentWindow->p.updateMenu();
+}
+
+void pItem::setText(string text) {
+  if(parentWindow) parentWindow->p.updateMenu();
+}
+
+void pItem::constructor() {
+  createBitmap();
+}
+
+void pItem::destructor() {
+  if(hbitmap) { DeleteObject(hbitmap); hbitmap = 0; }
+  if(parentMenu) parentMenu->remove(item);
+}
+
+void pItem::createBitmap() {
+  if(hbitmap) { DeleteObject(hbitmap); hbitmap = 0; }
+
+  if(item.state.image.width() && item.state.image.height()) {
+    nall::image nallImage = item.state.image;
+    nallImage.transform(0, 32, 255u << 24, 255u << 16, 255u << 8, 255u << 0);
+    nallImage.alphaBlend(GetSysColor(COLOR_MENU));  //Windows does not alpha blend menu icons properly (leaves black outline)
+    nallImage.scale(GetSystemMetrics(SM_CXMENUCHECK), GetSystemMetrics(SM_CYMENUCHECK), Interpolation::Linear);
+    hbitmap = CreateBitmap(nallImage);
+  }
+}
+
+void pItem::onActivate() {
+  if(item.onActivate) item.onActivate();
+}
+
+}
diff -Nru higan/phoenix/windows/action/menu.cpp nSide/phoenix/windows/action/menu.cpp
--- higan/phoenix/windows/action/menu.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/windows/action/menu.cpp	2015-09-16 13:08:13.569563369 +0900
@@ -0,0 +1,113 @@
+namespace phoenix {
+
+void pMenu::append(Action& action) {
+  action.p.parentMenu = &menu;
+  if(parentWindow) parentWindow->p.updateMenu();
+}
+
+void pMenu::remove(Action& action) {
+  if(parentWindow) parentWindow->p.updateMenu();
+  action.p.parentMenu = 0;
+}
+
+void pMenu::setImage(const image& image) {
+  createBitmap();
+  if(parentWindow) parentWindow->p.updateMenu();
+}
+
+void pMenu::setText(string text) {
+  if(parentWindow) parentWindow->p.updateMenu();
+}
+
+void pMenu::constructor() {
+  hmenu = 0;
+  createBitmap();
+}
+
+void pMenu::destructor() {
+  if(hbitmap) { DeleteObject(hbitmap); hbitmap = 0; }
+  if(parentMenu) {
+    parentMenu->remove(menu);
+  } else if(parentWindow) {
+    //belongs to window's main menubar
+    parentWindow->remove(menu);
+  }
+}
+
+void pMenu::createBitmap() {
+  if(hbitmap) { DeleteObject(hbitmap); hbitmap = 0; }
+
+  if(menu.state.image.width() && menu.state.image.height()) {
+    nall::image nallImage = menu.state.image;
+    nallImage.transform(0, 32, 255u << 24, 255u << 16, 255u << 8, 255u << 0);
+    nallImage.alphaBlend(GetSysColor(COLOR_MENU));  //Windows does not alpha blend menu icons properly (leaves black outline)
+    nallImage.scale(GetSystemMetrics(SM_CXMENUCHECK), GetSystemMetrics(SM_CYMENUCHECK), Interpolation::Linear);
+    hbitmap = CreateBitmap(nallImage);
+  }
+}
+
+//Windows actions lack the ability to toggle visibility.
+//To support this, menus must be destroyed and recreated when toggling any action's visibility.
+void pMenu::update(Window& parentWindow, Menu* parentMenu) {
+  this->parentMenu = parentMenu;
+  this->parentWindow = &parentWindow;
+
+  if(hmenu) DestroyMenu(hmenu);
+  hmenu = CreatePopupMenu();
+
+  for(auto& action : menu.state.action) {
+    action.p.parentMenu = &menu;
+    action.p.parentWindow = &parentWindow;
+
+    unsigned enabled = action.state.enabled ? 0 : MF_GRAYED;
+    if(dynamic_cast<Menu*>(&action)) {
+      Menu& item = (Menu&)action;
+      if(action.state.visible) {
+        item.p.update(parentWindow, &menu);
+        AppendMenu(hmenu, MF_STRING | MF_POPUP | enabled, (UINT_PTR)item.p.hmenu, utf16_t(item.state.text));
+
+        if(item.state.image.width() && item.state.image.height()) {
+          MENUITEMINFO mii = {sizeof(MENUITEMINFO)};
+          //Windows XP and below displays MIIM_BITMAP + hbmpItem in its own column (separate from check/radio marks)
+          //this causes too much spacing, so use a custom checkmark image instead
+          mii.fMask = MIIM_CHECKMARKS;
+          mii.hbmpUnchecked = item.p.hbitmap;
+          SetMenuItemInfo(hmenu, (UINT_PTR)item.p.hmenu, FALSE, &mii);
+        }
+      }
+    } else if(dynamic_cast<Separator*>(&action)) {
+      Separator& item = (Separator&)action;
+      if(action.state.visible) {
+        AppendMenu(hmenu, MF_SEPARATOR | enabled, item.p.id, L"");
+      }
+    } else if(dynamic_cast<Item*>(&action)) {
+      Item& item = (Item&)action;
+      if(action.state.visible) {
+        AppendMenu(hmenu, MF_STRING | enabled, item.p.id, utf16_t(item.state.text));
+
+        if(item.state.image.width() && item.state.image.height()) {
+          MENUITEMINFO mii = { sizeof(MENUITEMINFO) };
+          //Windows XP and below displays MIIM_BITMAP + hbmpItem in its own column (separate from check/radio marks)
+          //this causes too much spacing, so use a custom checkmark image instead
+          mii.fMask = MIIM_CHECKMARKS;
+          mii.hbmpUnchecked = item.p.hbitmap;
+          SetMenuItemInfo(hmenu, item.p.id, FALSE, &mii);
+        }
+      }
+    } else if(dynamic_cast<CheckItem*>(&action)) {
+      CheckItem& item = (CheckItem&)action;
+      if(action.state.visible) {
+        AppendMenu(hmenu, MF_STRING | enabled, item.p.id, utf16_t(item.state.text));
+      }
+      if(item.state.checked) item.setChecked();
+    } else if(dynamic_cast<RadioItem*>(&action)) {
+      RadioItem& item = (RadioItem&)action;
+      if(action.state.visible) {
+        AppendMenu(hmenu, MF_STRING | enabled, item.p.id, utf16_t(item.state.text));
+      }
+      if(item.state.checked) item.setChecked();
+    }
+  }
+}
+
+}
diff -Nru higan/phoenix/windows/action/radio-item.cpp nSide/phoenix/windows/action/radio-item.cpp
--- higan/phoenix/windows/action/radio-item.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/windows/action/radio-item.cpp	2015-09-16 13:08:13.569563369 +0900
@@ -0,0 +1,32 @@
+namespace phoenix {
+
+void pRadioItem::setChecked() {
+  for(auto &item : radioItem.state.group) {
+    //CheckMenuRadioItem takes: lo, hi, id; checking only id when lo <= id <= hi
+    //phoenix does not force IDs to be linear, so to uncheck id, we use: lo == hi == id + 1 (out of range)
+    //to check id, we use: lo == hi == id (only ID, but in range)
+    if(item.p.parentMenu) CheckMenuRadioItem(item.p.parentMenu->p.hmenu, item.p.id, item.p.id, item.p.id + (id != item.p.id), MF_BYCOMMAND);
+  }
+}
+
+void pRadioItem::setGroup(const group<RadioItem>& group) {
+}
+
+void pRadioItem::setText(string text) {
+  if(parentWindow) parentWindow->p.updateMenu();
+}
+
+void pRadioItem::constructor() {
+}
+
+void pRadioItem::destructor() {
+  if(parentMenu) parentMenu->remove(radioItem);
+}
+
+void pRadioItem::onActivate() {
+  if(radioItem.state.checked) return;
+  radioItem.setChecked();
+  if(radioItem.onActivate) radioItem.onActivate();
+}
+
+}
diff -Nru higan/phoenix/windows/action/separator.cpp nSide/phoenix/windows/action/separator.cpp
--- higan/phoenix/windows/action/separator.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/windows/action/separator.cpp	2015-09-16 13:08:13.569563369 +0900
@@ -0,0 +1,10 @@
+namespace phoenix {
+
+void pSeparator::constructor() {
+}
+
+void pSeparator::destructor() {
+  if(parentMenu) parentMenu->remove(separator);
+}
+
+}
diff -Nru higan/phoenix/windows/application.cpp nSide/phoenix/windows/application.cpp
--- higan/phoenix/windows/application.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/windows/application.cpp	2015-09-16 13:08:13.577563370 +0900
@@ -0,0 +1,219 @@
+namespace phoenix {
+
+static bool Application_keyboardProc(HWND, UINT, WPARAM, LPARAM);
+static void Application_processDialogMessage(MSG&);
+static LRESULT CALLBACK Application_windowProc(HWND, UINT, WPARAM, LPARAM);
+
+void pApplication::run() {
+  MSG msg;
+  if(Application::main) {
+    while(applicationState.quit == false) {
+      Application::main();
+      processEvents();
+    }
+  } else {
+    MSG msg;
+    while(GetMessage(&msg, 0, 0, 0)) {
+      Application_processDialogMessage(msg);
+    }
+  }
+}
+
+bool pApplication::pendingEvents() {
+  MSG msg;
+  return PeekMessage(&msg, 0, 0, 0, PM_NOREMOVE);
+}
+
+void pApplication::processEvents() {
+  while(pendingEvents()) {
+    MSG msg;
+    if(PeekMessage(&msg, 0, 0, 0, PM_REMOVE)) {
+      Application_processDialogMessage(msg);
+    }
+  }
+}
+
+void Application_processDialogMessage(MSG& msg) {
+  if(msg.message == WM_KEYDOWN || msg.message == WM_KEYUP
+  || msg.message == WM_SYSKEYDOWN || msg.message == WM_SYSKEYUP) {
+    if(Application_keyboardProc(msg.hwnd, msg.message, msg.wParam, msg.lParam)) {
+      DispatchMessage(&msg);
+      return;
+    }
+  }
+
+  if(!IsDialogMessage(GetForegroundWindow(), &msg)) {
+    TranslateMessage(&msg);
+    DispatchMessage(&msg);
+  }
+}
+
+void pApplication::quit() {
+  PostQuitMessage(0);
+}
+
+void pApplication::initialize() {
+  CoInitialize(0);
+  InitCommonControls();
+
+  WNDCLASS wc;
+  wc.cbClsExtra = 0;
+  wc.cbWndExtra = 0;
+  wc.hbrBackground = GetSysColorBrush(COLOR_3DFACE);
+  wc.hCursor = LoadCursor(0, IDC_ARROW);
+  wc.hIcon = LoadIcon(GetModuleHandle(0), MAKEINTRESOURCE(2));
+  wc.hInstance = GetModuleHandle(0);
+  wc.lpfnWndProc = Application_windowProc;
+  wc.lpszClassName = L"phoenix_window";
+  wc.lpszMenuName = 0;
+  wc.style = CS_HREDRAW | CS_VREDRAW;
+  RegisterClass(&wc);
+
+  wc.cbClsExtra = 0;
+  wc.cbWndExtra = 0;
+  wc.hbrBackground = GetSysColorBrush(COLOR_3DFACE);
+  wc.hCursor = LoadCursor(0, IDC_ARROW);
+  wc.hIcon = LoadIcon(0, IDI_APPLICATION);
+  wc.hInstance = GetModuleHandle(0);
+  wc.lpfnWndProc = Canvas_windowProc;
+  wc.lpszClassName = L"phoenix_canvas";
+  wc.lpszMenuName = 0;
+  wc.style = CS_HREDRAW | CS_VREDRAW;
+  RegisterClass(&wc);
+
+  wc.cbClsExtra = 0;
+  wc.cbWndExtra = 0;
+  wc.hbrBackground = GetSysColorBrush(COLOR_3DFACE);
+  wc.hCursor = LoadCursor(0, IDC_ARROW);
+  wc.hIcon = LoadIcon(0, IDI_APPLICATION);
+  wc.hInstance = GetModuleHandle(0);
+  wc.lpfnWndProc = Label_windowProc;
+  wc.lpszClassName = L"phoenix_label";
+  wc.lpszMenuName = 0;
+  wc.style = CS_HREDRAW | CS_VREDRAW;
+  RegisterClass(&wc);
+
+  wc.cbClsExtra = 0;
+  wc.cbWndExtra = 0;
+  wc.hbrBackground = CreateSolidBrush(RGB(0, 0, 0));
+  wc.hCursor = LoadCursor(0, IDC_ARROW);
+  wc.hIcon = LoadIcon(0, IDI_APPLICATION);
+  wc.hInstance = GetModuleHandle(0);
+  wc.lpfnWndProc = Viewport_windowProc;
+  wc.lpszClassName = L"phoenix_viewport";
+  wc.lpszMenuName = 0;
+  wc.style = CS_HREDRAW | CS_VREDRAW;
+  RegisterClass(&wc);
+
+  settings = new Settings;
+  pKeyboard::initialize();
+}
+
+static bool Application_keyboardProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam) {
+  if(msg != WM_KEYDOWN && msg != WM_SYSKEYDOWN && msg != WM_KEYUP && msg != WM_SYSKEYUP) return false;
+
+  GUITHREADINFO info;
+  memset(&info, 0, sizeof(GUITHREADINFO));
+  info.cbSize = sizeof(GUITHREADINFO);
+  GetGUIThreadInfo(GetCurrentThreadId(), &info);
+  Object* object = (Object*)GetWindowLongPtr(info.hwndFocus, GWLP_USERDATA);
+  if(object == nullptr) return false;
+
+  if(dynamic_cast<Window*>(object)) {
+    Window& window = (Window&)*object;
+    if(pWindow::modal.size() > 0 && !pWindow::modal.find(&window.p)) return false;
+    Keyboard::Keycode keysym = Keysym(wparam, lparam);
+    if(keysym != Keyboard::Keycode::None) {
+      if((msg == WM_KEYDOWN || msg == WM_SYSKEYDOWN) && window.onKeyPress) window.onKeyPress(keysym);
+      if((msg == WM_KEYUP || msg == WM_SYSKEYUP) && window.onKeyRelease) window.onKeyRelease(keysym);
+    }
+    return false;
+  }
+
+  if(msg == WM_KEYDOWN) {
+    if(dynamic_cast<ListView*>(object)) {
+      ListView& listView = (ListView&)*object;
+      if(wparam == VK_RETURN) {
+        if(listView.selected()) return true;  //returning true generates LVN_ITEMACTIVATE message
+      }
+    } else if(dynamic_cast<LineEdit*>(object)) {
+      LineEdit& lineEdit = (LineEdit&)*object;
+      if(wparam == VK_RETURN) {
+        if(lineEdit.onActivate) lineEdit.onActivate();
+      }
+    } else if(dynamic_cast<TextEdit*>(object)) {
+      TextEdit& textEdit = (TextEdit&)*object;
+      if(wparam == 'A' && GetKeyState(VK_CONTROL) < 0) {
+        //Ctrl+A = select all text
+        //note: this is not a standard accelerator on Windows
+        Edit_SetSel(textEdit.p.hwnd, 0, ~0);
+        return true;
+      } else if(wparam == 'V' && GetKeyState(VK_CONTROL) < 0) {
+        //Ctrl+V = paste text
+        //note: this formats Unix (LF) and OS9 (CR) line-endings to Windows (CR+LF) line-endings
+        //this is necessary as the EDIT control only supports Windows line-endings
+        OpenClipboard(hwnd);
+        HANDLE handle = GetClipboardData(CF_UNICODETEXT);
+        if(handle) {
+          wchar_t* text = (wchar_t*)GlobalLock(handle);
+          if(text) {
+            string data = (const char*)utf8_t(text);
+            data.replace("\r\n", "\n");
+            data.replace("\r", "\n");
+            data.replace("\n", "\r\n");
+            GlobalUnlock(handle);
+            utf16_t output(data);
+            HGLOBAL resource = GlobalAlloc(GMEM_MOVEABLE, (wcslen(output) + 1) * sizeof(wchar_t));
+            if(resource) {
+              wchar_t* write = (wchar_t*)GlobalLock(resource);
+              if(write) {
+                wcscpy(write, output);
+                GlobalUnlock(write);
+                if(SetClipboardData(CF_UNICODETEXT, resource) == FALSE) {
+                  GlobalFree(resource);
+                }
+              }
+            }
+          }
+        }
+        CloseClipboard();
+        return false;
+      }
+    }
+  }
+
+  return false;
+}
+
+/*case WM_GETMINMAXINFO: {
+    MINMAXINFO* mmi = (MINMAXINFO*)lparam;
+    mmi->ptMinTrackSize.x = 256 + window.p.frameMargin().width;
+    mmi->ptMinTrackSize.y = 256 + window.p.frameMargin().height;
+    return TRUE;
+    break;
+  }*/
+
+static LRESULT CALLBACK Application_windowProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam) {
+  Object* object = (Object*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
+  if(object == nullptr) return DefWindowProc(hwnd, msg, wparam, lparam);
+  Window& window = dynamic_cast<Window*>(object) ? (Window&)*object : *((Widget*)object)->Sizable::state.window;
+
+  bool process = true;
+  if(!pWindow::modal.empty() && !pWindow::modal.find(&window.p)) process = false;
+  if(applicationState.quit) process = false;
+  if(process == false) return DefWindowProc(hwnd, msg, wparam, lparam);
+
+  switch(msg) {
+  case WM_CLOSE: window.p.onClose(); return TRUE;
+  case WM_MOVE: window.p.onMove(); break;
+  case WM_SIZE: window.p.onSize(); break;
+  case WM_DROPFILES: window.p.onDrop(wparam); return FALSE;
+  case WM_ERASEBKGND: if(window.p.onEraseBackground()) return true; break;
+  case WM_ENTERMENULOOP: case WM_ENTERSIZEMOVE: window.p.onModalBegin(); return FALSE;
+  case WM_EXITMENULOOP: case WM_EXITSIZEMOVE: window.p.onModalEnd(); return FALSE;
+  }
+
+  return Shared_windowProc(DefWindowProc, hwnd, msg, wparam, lparam);
+}
+
+}
diff -Nru higan/phoenix/windows/browser-window.cpp nSide/phoenix/windows/browser-window.cpp
--- higan/phoenix/windows/browser-window.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/windows/browser-window.cpp	2015-09-16 13:08:13.578563370 +0900
@@ -0,0 +1,105 @@
+namespace phoenix {
+
+static int CALLBACK BrowserWindowCallbackProc(HWND hwnd, UINT msg, LPARAM lparam, LPARAM lpdata) {
+  if(msg == BFFM_INITIALIZED) {
+    if(lpdata) {
+      auto state = (BrowserWindow::State*)lpdata;
+      utf16_t wpath(string{state->path}.transform("/", "\\"));
+      if(state->title) SetWindowText(hwnd, utf16_t(state->title));
+      SendMessage(hwnd, BFFM_SETSELECTION, TRUE, (LPARAM)(wchar_t*)wpath);
+    }
+  }
+  return 0;
+}
+
+static string BrowserWindow_fileDialog(bool save, BrowserWindow::State& state) {
+  string path = string{state.path}.replace("/", "\\");
+
+  string filters;
+  for(auto& filter : state.filters) {
+    lstring part = filter.split("(");
+    if(part.size() != 2) continue;
+    part[1].rtrim(")");
+    part[1].replace(" ", "");
+    part[1].transform(",", ";");
+    filters.append(filter, "\t", part[1], "\t");
+  }
+
+  utf16_t wfilters(filters);
+  wchar_t wname[PATH_MAX + 1] = L"";
+  utf16_t wpath(path);
+  utf16_t wtitle(state.title);
+
+  wchar_t* p = wfilters;
+  while(*p != L'\0') {
+    if(*p == L'\t') *p = L'\0';
+    p++;
+  }
+
+  if(path.empty() == false) {
+    //clear COMDLG32 MRU (most recently used) file list
+    //this is required in order for lpstrInitialDir to be honored in Windows 7 and above
+    registry::remove("HKCU/Software/Microsoft/Windows/CurrentVersion/Explorer/ComDlg32/LastVisitedPidlMRU/");
+    registry::remove("HKCU/Software/Microsoft/Windows/CurrentVersion/Explorer/ComDlg32/OpenSavePidlMRU/");
+  }
+
+  OPENFILENAME ofn;
+  memset(&ofn, 0, sizeof(OPENFILENAME));
+  ofn.lStructSize = sizeof(OPENFILENAME);
+  ofn.hwndOwner = state.parent ? state.parent->p.hwnd : 0;
+  ofn.lpstrFilter = wfilters;
+  ofn.lpstrInitialDir = wpath;
+  ofn.lpstrFile = wname;
+  ofn.lpstrTitle = wtitle;
+  ofn.nMaxFile = PATH_MAX;
+  ofn.Flags = OFN_EXPLORER | OFN_FILEMUSTEXIST | OFN_HIDEREADONLY;
+  ofn.lpstrDefExt = L"";
+
+  bool result = (save == false ? GetOpenFileName(&ofn) : GetSaveFileName(&ofn));
+  if(result == false) return "";
+  string name = (const char*)utf8_t(wname);
+  name.transform("\\", "/");
+  return name;
+}
+
+string pBrowserWindow::directory(BrowserWindow::State& state) {
+  wchar_t wname[PATH_MAX + 1] = L"";
+
+  BROWSEINFO bi;
+  bi.hwndOwner = state.parent ? state.parent->p.hwnd : 0;
+  bi.pidlRoot = NULL;
+  bi.pszDisplayName = wname;
+  bi.lpszTitle = L"\nChoose a directory:";
+  bi.ulFlags = BIF_NEWDIALOGSTYLE | BIF_RETURNONLYFSDIRS;
+  bi.lpfn = BrowserWindowCallbackProc;
+  bi.lParam = (LPARAM)&state;
+  bi.iImage = 0;
+  bool result = false;
+  LPITEMIDLIST pidl = SHBrowseForFolder(&bi);
+  if(pidl) {
+    if(SHGetPathFromIDList(pidl, wname)) {
+      result = true;
+      IMalloc *imalloc = 0;
+      if(SUCCEEDED(SHGetMalloc(&imalloc))) {
+        imalloc->Free(pidl);
+        imalloc->Release();
+      }
+    }
+  }
+  if(result == false) return "";
+  string name = (const char*)utf8_t(wname);
+  if(!name) return "";
+  name.transform("\\", "/");
+  if(name.endsWith("/") == false) name.append("/");
+  return name;
+}
+
+string pBrowserWindow::open(BrowserWindow::State& state) {
+  return BrowserWindow_fileDialog(0, state);
+}
+
+string pBrowserWindow::save(BrowserWindow::State& state) {
+  return BrowserWindow_fileDialog(1, state);
+}
+
+}
diff -Nru higan/phoenix/windows/desktop.cpp nSide/phoenix/windows/desktop.cpp
--- higan/phoenix/windows/desktop.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/windows/desktop.cpp	2015-09-16 13:08:13.569563369 +0900
@@ -0,0 +1,13 @@
+namespace phoenix {
+
+Size pDesktop::size() {
+  return {GetSystemMetrics(SM_CXVIRTUALSCREEN), GetSystemMetrics(SM_CYVIRTUALSCREEN)};
+}
+
+Geometry pDesktop::workspace() {
+  RECT rc;
+  SystemParametersInfo(SPI_GETWORKAREA, 0, &rc, 0);
+  return {rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top};
+}
+
+}
diff -Nru higan/phoenix/windows/font.cpp nSide/phoenix/windows/font.cpp
--- higan/phoenix/windows/font.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/windows/font.cpp	2015-09-16 13:08:13.576563370 +0900
@@ -0,0 +1,64 @@
+namespace phoenix {
+
+string pFont::serif(unsigned size, string style) {
+  if(size == 0) size = 8;
+  if(style == "") style = "Normal";
+  return {"Georgia, ", size, ", ", style};
+}
+
+string pFont::sans(unsigned size, string style) {
+  if(size == 0) size = 8;
+  if(style == "") style = "Normal";
+  return {"Tahoma, ", size, ", ", style};
+}
+
+string pFont::monospace(unsigned size, string style) {
+  if(size == 0) size = 8;
+  if(style == "") style = "Normal";
+  return {"Lucida Console, ", size, ", ", style};
+}
+
+Size pFont::size(string font, string text) {
+  HFONT hfont = pFont::create(font);
+  Size size = pFont::size(hfont, text);
+  pFont::free(hfont);
+  return size;
+}
+
+HFONT pFont::create(string description) {
+  lstring part = description.split(",", 2L).strip();
+
+  string family = "Sans";
+  unsigned size = 8u;
+  bool bold = false;
+  bool italic = false;
+
+  if(part[0] != "") family = part[0];
+  if(part.size() >= 2) size = decimal(part[1]);
+  if(part.size() >= 3) bold = (bool)part[2].find("Bold");
+  if(part.size() >= 3) italic = (bool)part[2].find("Italic");
+
+  return CreateFont(
+    -(size * 96.0 / 72.0 + 0.5),
+    0, 0, 0, bold == false ? FW_NORMAL : FW_BOLD, italic, 0, 0, 0, 0, 0, 0, 0,
+    utf16_t(family)
+  );
+}
+
+void pFont::free(HFONT hfont) {
+  DeleteObject(hfont);
+}
+
+Size pFont::size(HFONT hfont, string text) {
+  //temporary fix: empty text string returns height of zero; bad for eg Button height
+  if(text.empty()) text = " ";
+
+  HDC hdc = GetDC(0);
+  SelectObject(hdc, hfont);
+  RECT rc = {0, 0, 0, 0};
+  DrawText(hdc, utf16_t(text), -1, &rc, DT_CALCRECT);
+  ReleaseDC(0, hdc);
+  return {rc.right, rc.bottom};
+}
+
+}
diff -Nru higan/phoenix/windows/header.hpp nSide/phoenix/windows/header.hpp
--- higan/phoenix/windows/header.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/windows/header.hpp	2015-09-16 13:08:13.577563370 +0900
@@ -0,0 +1,56 @@
+#define UNICODE
+#define WINVER 0x0601
+#define _WIN32_WINNT WINVER
+#define _WIN32_IE WINVER
+#define __MSVCRT_VERSION__ WINVER
+#define NOMINMAX
+
+#include <winsock2.h>
+#include <windows.h>
+#include <windowsx.h>
+#include <commctrl.h>
+#include <uxtheme.h>
+#include <io.h>
+#include <shlobj.h>
+#include <nall/windows/registry.hpp>
+#include <nall/windows/utf8.hpp>
+
+//MinGW/32-bit has painfully outdated platform headers ...
+
+#if !defined(Button_SetImageList)
+  typedef struct {
+    HIMAGELIST himl;
+    RECT margin;
+    UINT uAlign;
+  } BUTTON_IMAGELIST, *PBUTTON_IMAGELIST;
+
+  #define BUTTON_IMAGELIST_ALIGN_LEFT 0
+  #define BUTTON_IMAGELIST_ALIGN_RIGHT 1
+  #define BUTTON_IMAGELIST_ALIGN_TOP 2
+  #define BUTTON_IMAGELIST_ALIGN_BOTTOM 3
+  #define BUTTON_IMAGELIST_ALIGN_CENTER 4
+
+  #define BCM_FIRST 0x1600
+  #define BCM_SETIMAGELIST (BCM_FIRST+2)
+  #define Button_SetImageList(hwnd, pbuttonImagelist) (WINBOOL)SNDMSG((hwnd),BCM_SETIMAGELIST,0,(LPARAM)(pbuttonImagelist))
+#endif
+
+#if !defined(BP_CHECKBOX)
+  #define BP_CHECKBOX 3
+#endif
+
+#if !defined(CBS_UNCHECKEDNORMAL)
+  #define CBS_UNCHECKEDNORMAL 1
+#endif
+
+#if !defined(CBS_CHECKEDNORMAL)
+  #define CBS_CHECKEDNORMAL 5
+#endif
+
+#if !defined(LVCFMT_FIXED_WIDTH)
+  #define LVCFMT_FIXED_WIDTH 0x0100
+#endif
+
+#if !defined(TBS_TRANSPARENTBKGND)
+  #define TBS_TRANSPARENTBKGND 0x1000
+#endif
diff -Nru higan/phoenix/windows/keyboard.cpp nSide/phoenix/windows/keyboard.cpp
--- higan/phoenix/windows/keyboard.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/windows/keyboard.cpp	2015-09-16 13:08:13.578563370 +0900
@@ -0,0 +1,144 @@
+namespace phoenix {
+
+void pKeyboard::initialize() {
+  auto append = [](Keyboard::Scancode scancode, unsigned keysym) {
+    settings->keymap.insert(scancode, keysym);
+  };
+
+  append(Keyboard::Scancode::Escape, VK_ESCAPE);
+  append(Keyboard::Scancode::F1, VK_F1);
+  append(Keyboard::Scancode::F2, VK_F2);
+  append(Keyboard::Scancode::F3, VK_F3);
+  append(Keyboard::Scancode::F4, VK_F4);
+  append(Keyboard::Scancode::F5, VK_F5);
+  append(Keyboard::Scancode::F6, VK_F6);
+  append(Keyboard::Scancode::F7, VK_F7);
+  append(Keyboard::Scancode::F8, VK_F8);
+  append(Keyboard::Scancode::F9, VK_F9);
+  append(Keyboard::Scancode::F10, VK_F10);
+  append(Keyboard::Scancode::F11, VK_F11);
+  append(Keyboard::Scancode::F12, VK_F12);
+
+  append(Keyboard::Scancode::PrintScreen, VK_SNAPSHOT);
+  append(Keyboard::Scancode::ScrollLock, VK_SCROLL);
+  append(Keyboard::Scancode::Pause, VK_PAUSE);
+
+  append(Keyboard::Scancode::Insert, VK_INSERT);
+  append(Keyboard::Scancode::Delete, VK_DELETE);
+  append(Keyboard::Scancode::Home, VK_HOME);
+  append(Keyboard::Scancode::End, VK_END);
+  append(Keyboard::Scancode::PageUp, VK_PRIOR);
+  append(Keyboard::Scancode::PageDown, VK_NEXT);
+
+  append(Keyboard::Scancode::Up, VK_UP);
+  append(Keyboard::Scancode::Down, VK_DOWN);
+  append(Keyboard::Scancode::Left, VK_LEFT);
+  append(Keyboard::Scancode::Right, VK_RIGHT);
+
+  append(Keyboard::Scancode::Grave, VK_OEM_3);
+  append(Keyboard::Scancode::Number1, '1');
+  append(Keyboard::Scancode::Number2, '2');
+  append(Keyboard::Scancode::Number3, '3');
+  append(Keyboard::Scancode::Number4, '4');
+  append(Keyboard::Scancode::Number5, '5');
+  append(Keyboard::Scancode::Number6, '6');
+  append(Keyboard::Scancode::Number7, '7');
+  append(Keyboard::Scancode::Number8, '8');
+  append(Keyboard::Scancode::Number9, '9');
+  append(Keyboard::Scancode::Number0, '0');
+  append(Keyboard::Scancode::Minus, VK_OEM_MINUS);
+  append(Keyboard::Scancode::Equal, VK_OEM_PLUS);
+  append(Keyboard::Scancode::Backspace, VK_BACK);
+
+  append(Keyboard::Scancode::BracketLeft, VK_OEM_4);
+  append(Keyboard::Scancode::BracketRight, VK_OEM_6);
+  append(Keyboard::Scancode::Backslash, VK_OEM_5);
+  append(Keyboard::Scancode::Semicolon, VK_OEM_1);
+  append(Keyboard::Scancode::Apostrophe, VK_OEM_7);
+  append(Keyboard::Scancode::Comma, VK_OEM_COMMA);
+  append(Keyboard::Scancode::Period, VK_OEM_PERIOD);
+  append(Keyboard::Scancode::Slash, VK_OEM_2);
+
+  append(Keyboard::Scancode::Tab, VK_TAB);
+  append(Keyboard::Scancode::CapsLock, VK_CAPITAL);
+  append(Keyboard::Scancode::Return, VK_RETURN);
+  append(Keyboard::Scancode::ShiftLeft, VK_LSHIFT);
+  append(Keyboard::Scancode::ShiftRight, VK_RSHIFT);
+  append(Keyboard::Scancode::ControlLeft, VK_LCONTROL);
+  append(Keyboard::Scancode::ControlRight, VK_RCONTROL);
+  append(Keyboard::Scancode::SuperLeft, VK_LWIN);
+  append(Keyboard::Scancode::SuperRight, VK_RWIN);
+  append(Keyboard::Scancode::AltLeft, VK_LMENU);
+  append(Keyboard::Scancode::AltRight, VK_RMENU);
+  append(Keyboard::Scancode::Space, VK_SPACE);
+  append(Keyboard::Scancode::Menu, VK_APPS);
+
+  append(Keyboard::Scancode::A, 'A');
+  append(Keyboard::Scancode::B, 'B');
+  append(Keyboard::Scancode::C, 'C');
+  append(Keyboard::Scancode::D, 'D');
+  append(Keyboard::Scancode::E, 'E');
+  append(Keyboard::Scancode::F, 'F');
+  append(Keyboard::Scancode::G, 'G');
+  append(Keyboard::Scancode::H, 'H');
+  append(Keyboard::Scancode::I, 'I');
+  append(Keyboard::Scancode::J, 'J');
+  append(Keyboard::Scancode::K, 'K');
+  append(Keyboard::Scancode::L, 'L');
+  append(Keyboard::Scancode::M, 'M');
+  append(Keyboard::Scancode::N, 'N');
+  append(Keyboard::Scancode::O, 'O');
+  append(Keyboard::Scancode::P, 'P');
+  append(Keyboard::Scancode::Q, 'Q');
+  append(Keyboard::Scancode::R, 'R');
+  append(Keyboard::Scancode::S, 'S');
+  append(Keyboard::Scancode::T, 'T');
+  append(Keyboard::Scancode::U, 'U');
+  append(Keyboard::Scancode::V, 'V');
+  append(Keyboard::Scancode::W, 'W');
+  append(Keyboard::Scancode::X, 'X');
+  append(Keyboard::Scancode::Y, 'Y');
+  append(Keyboard::Scancode::Z, 'Z');
+
+  append(Keyboard::Scancode::NumLock, VK_NUMLOCK);
+  append(Keyboard::Scancode::Divide, VK_DIVIDE);
+  append(Keyboard::Scancode::Multiply, VK_MULTIPLY);
+  append(Keyboard::Scancode::Subtract, VK_SUBTRACT);
+  append(Keyboard::Scancode::Add, VK_ADD);
+//append(Keyboard::Scancode::Enter, ...);
+  append(Keyboard::Scancode::Point, VK_DECIMAL);
+
+  append(Keyboard::Scancode::Keypad1, VK_NUMPAD1);
+  append(Keyboard::Scancode::Keypad2, VK_NUMPAD2);
+  append(Keyboard::Scancode::Keypad3, VK_NUMPAD3);
+  append(Keyboard::Scancode::Keypad4, VK_NUMPAD4);
+  append(Keyboard::Scancode::Keypad5, VK_NUMPAD5);
+  append(Keyboard::Scancode::Keypad6, VK_NUMPAD6);
+  append(Keyboard::Scancode::Keypad7, VK_NUMPAD7);
+  append(Keyboard::Scancode::Keypad8, VK_NUMPAD8);
+  append(Keyboard::Scancode::Keypad9, VK_NUMPAD9);
+  append(Keyboard::Scancode::Keypad0, VK_NUMPAD0);
+}
+
+bool pKeyboard::pressed(Keyboard::Scancode scancode) {
+  if(auto result = settings->keymap.find(scancode)) {
+    return GetAsyncKeyState(result()) & 0x8000;
+  }
+  return false;
+}
+
+vector<bool> pKeyboard::state() {
+  vector<bool> output;
+  output.resize((unsigned)Keyboard::Scancode::Limit);
+  for(auto& n : output) n = false;
+
+  for(auto node : settings->keymap) {
+    if(GetAsyncKeyState(node.value) & 0x8000) {
+      output[(unsigned)node.key] = true;
+    }
+  }
+
+  return output;
+}
+
+}
diff -Nru higan/phoenix/windows/message-window.cpp nSide/phoenix/windows/message-window.cpp
--- higan/phoenix/windows/message-window.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/windows/message-window.cpp	2015-09-16 13:08:13.576563370 +0900
@@ -0,0 +1,54 @@
+namespace phoenix {
+
+static MessageWindow::Response MessageWindow_response(MessageWindow::Buttons buttons, UINT response) {
+  if(response == IDOK) return MessageWindow::Response::Ok;
+  if(response == IDCANCEL) return MessageWindow::Response::Cancel;
+  if(response == IDYES) return MessageWindow::Response::Yes;
+  if(response == IDNO) return MessageWindow::Response::No;
+
+  //default responses if window was closed without a button selected
+  if(buttons == MessageWindow::Buttons::Ok) return MessageWindow::Response::Ok;
+  if(buttons == MessageWindow::Buttons::OkCancel) return MessageWindow::Response::Cancel;
+  if(buttons == MessageWindow::Buttons::YesNo) return MessageWindow::Response::No;
+  if(buttons == MessageWindow::Buttons::YesNoCancel) return MessageWindow::Response::Cancel;
+
+  throw;
+}
+
+static UINT MessageWindow_buttons(MessageWindow::Buttons buttons) {
+  if(buttons == MessageWindow::Buttons::Ok) return MB_OK;
+  if(buttons == MessageWindow::Buttons::OkCancel) return MB_OKCANCEL;
+  if(buttons == MessageWindow::Buttons::YesNo) return MB_YESNO;
+  if(buttons == MessageWindow::Buttons::YesNoCancel) return MB_YESNOCANCEL;
+  throw;
+}
+
+MessageWindow::Response pMessageWindow::error(MessageWindow::State& state) {
+  UINT flags = MB_ICONERROR | MessageWindow_buttons(state.buttons);
+  return MessageWindow_response(state.buttons, MessageBox(
+    state.parent ? state.parent->p.hwnd : 0, utf16_t(state.text), utf16_t(state.title), flags
+  ));
+}
+
+MessageWindow::Response pMessageWindow::information(MessageWindow::State& state) {
+  UINT flags = MB_ICONINFORMATION | MessageWindow_buttons(state.buttons);
+  return MessageWindow_response(state.buttons, MessageBox(
+    state.parent ? state.parent->p.hwnd : 0, utf16_t(state.text), utf16_t(state.title), flags
+  ));
+}
+
+MessageWindow::Response pMessageWindow::question(MessageWindow::State& state) {
+  UINT flags = MB_ICONQUESTION | MessageWindow_buttons(state.buttons);
+  return MessageWindow_response(state.buttons, MessageBox(
+    state.parent ? state.parent->p.hwnd : 0, utf16_t(state.text), utf16_t(state.title), flags
+  ));
+}
+
+MessageWindow::Response pMessageWindow::warning(MessageWindow::State& state) {
+  UINT flags = MB_ICONWARNING | MessageWindow_buttons(state.buttons);
+  return MessageWindow_response(state.buttons, MessageBox(
+    state.parent ? state.parent->p.hwnd : 0, utf16_t(state.text), utf16_t(state.title), flags
+  ));
+}
+
+}
diff -Nru higan/phoenix/windows/monitor.cpp nSide/phoenix/windows/monitor.cpp
--- higan/phoenix/windows/monitor.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/windows/monitor.cpp	2015-09-16 13:08:13.580563370 +0900
@@ -0,0 +1,43 @@
+namespace phoenix {
+
+struct MonitorInfo {
+  unsigned monitor = 0;
+  unsigned primary = 0;
+  unsigned index = 0;
+  Geometry geometry;
+};
+
+static BOOL CALLBACK MonitorEnumProc(HMONITOR hMonitor, HDC hdcMonitor, LPRECT lprcMonitor, LPARAM dwData) {
+  MonitorInfo& info = *(MonitorInfo*)dwData;
+  MONITORINFOEX mi;
+  memset(&mi, 0, sizeof(MONITORINFOEX));
+  mi.cbSize = sizeof(MONITORINFOEX);
+  GetMonitorInfo(hMonitor, &mi);
+  string displayName = (const char*)utf8_t(mi.szDevice);
+  if(displayName.beginsWith(R"(\\.\DISPLAYV)")) return TRUE;  //ignore pseudo-monitors
+  if(mi.dwFlags & MONITORINFOF_PRIMARY) info.primary = info.index;
+  if(info.monitor == info.index) {
+    info.geometry = {lprcMonitor->left, lprcMonitor->top, lprcMonitor->right - lprcMonitor->left, lprcMonitor->bottom - lprcMonitor->top};
+  }
+  info.index++;
+  return TRUE;
+}
+
+unsigned pMonitor::count() {
+  return GetSystemMetrics(SM_CMONITORS);
+}
+
+Geometry pMonitor::geometry(unsigned monitor) {
+  MonitorInfo info;
+  info.monitor = monitor;
+  EnumDisplayMonitors(NULL, NULL, MonitorEnumProc, (LPARAM)&info);
+  return info.geometry;
+}
+
+unsigned pMonitor::primary() {
+  MonitorInfo info;
+  EnumDisplayMonitors(NULL, NULL, MonitorEnumProc, (LPARAM)&info);
+  return info.primary;
+}
+
+}
diff -Nru higan/phoenix/windows/mouse.cpp nSide/phoenix/windows/mouse.cpp
--- higan/phoenix/windows/mouse.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/windows/mouse.cpp	2015-09-16 13:08:13.577563370 +0900
@@ -0,0 +1,18 @@
+namespace phoenix {
+
+Position pMouse::position() {
+  POINT point = {0};
+  GetCursorPos(&point);
+  return {point.x, point.y};
+}
+
+bool pMouse::pressed(Mouse::Button button) {
+  switch(button) {
+  case Mouse::Button::Left: return GetAsyncKeyState(VK_LBUTTON) & 0x8000;
+  case Mouse::Button::Middle: return GetAsyncKeyState(VK_MBUTTON) & 0x8000;
+  case Mouse::Button::Right: return GetAsyncKeyState(VK_RBUTTON) & 0x8000;
+  }
+  return false;
+}
+
+}
diff -Nru higan/phoenix/windows/object.cpp nSide/phoenix/windows/object.cpp
--- higan/phoenix/windows/object.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/windows/object.cpp	2015-09-16 13:08:13.569563369 +0900
@@ -0,0 +1,17 @@
+namespace phoenix {
+
+vector<pObject*> pObject::objects;
+
+pObject::pObject(Object& object) : object(object) {
+  static unsigned uniqueId = 100;
+  objects.append(this);
+  id = uniqueId++;
+  locked = false;
+}
+
+Object* pObject::find(unsigned id) {
+  for(auto& item : objects) if(item->id == id) return &item->object;
+  return nullptr;
+}
+
+}
diff -Nru higan/phoenix/windows/phoenix.Manifest nSide/phoenix/windows/phoenix.Manifest
--- higan/phoenix/windows/phoenix.Manifest	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/windows/phoenix.Manifest	2015-09-16 13:08:13.576563370 +0900
@@ -0,0 +1,14 @@
+<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
+<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
+  <assemblyIdentity type="win32" name="phoenix" version="1.0.0.0" processorArchitecture="*"/>
+  <dependency>
+    <dependentAssembly>
+      <assemblyIdentity type="win32" name="Microsoft.Windows.Common-Controls" version="6.0.0.0" processorArchitecture="*" publicKeyToken="6595b64144ccf1df" language="*"/>
+    </dependentAssembly>
+  </dependency>
+  <asmv3:application xmlns:asmv3="urn:schemas-microsoft-com:asm.v3">
+    <asmv3:windowsSettings xmlns="http://schemas.microsoft.com/SMI/2005/WindowsSettings">
+      <dpiAware>true</dpiAware>
+    </asmv3:windowsSettings>
+  </asmv3:application>
+</assembly>
diff -Nru higan/phoenix/windows/phoenix.rc nSide/phoenix/windows/phoenix.rc
--- higan/phoenix/windows/phoenix.rc	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/windows/phoenix.rc	2015-09-16 13:08:13.578563370 +0900
@@ -0,0 +1 @@
+1 24 "phoenix.Manifest"
diff -Nru higan/phoenix/windows/platform.cpp nSide/phoenix/windows/platform.cpp
--- higan/phoenix/windows/platform.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/windows/platform.cpp	2015-09-16 13:08:13.579563370 +0900
@@ -0,0 +1,47 @@
+#include "platform.hpp"
+
+#include "utility.cpp"
+#include "settings.cpp"
+
+#include "desktop.cpp"
+#include "monitor.cpp"
+#include "keyboard.cpp"
+#include "mouse.cpp"
+#include "browser-window.cpp"
+#include "message-window.cpp"
+#include "object.cpp"
+#include "font.cpp"
+#include "timer.cpp"
+#include "window.cpp"
+
+#include "action/action.cpp"
+#include "action/menu.cpp"
+#include "action/separator.cpp"
+#include "action/item.cpp"
+#include "action/check-item.cpp"
+#include "action/radio-item.cpp"
+
+#include "widget/widget.cpp"
+#include "widget/button.cpp"
+#include "widget/canvas.cpp"
+#include "widget/check-button.cpp"
+#include "widget/check-label.cpp"
+#include "widget/combo-button.cpp"
+#include "widget/console.cpp"
+#include "widget/frame.cpp"
+#include "widget/hex-edit.cpp"
+#include "widget/horizontal-scroller.cpp"
+#include "widget/horizontal-slider.cpp"
+#include "widget/label.cpp"
+#include "widget/line-edit.cpp"
+#include "widget/list-view.cpp"
+#include "widget/progress-bar.cpp"
+#include "widget/radio-button.cpp"
+#include "widget/radio-label.cpp"
+#include "widget/tab-frame.cpp"
+#include "widget/text-edit.cpp"
+#include "widget/vertical-scroller.cpp"
+#include "widget/vertical-slider.cpp"
+#include "widget/viewport.cpp"
+
+#include "application.cpp"
diff -Nru higan/phoenix/windows/platform.hpp nSide/phoenix/windows/platform.hpp
--- higan/phoenix/windows/platform.hpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/windows/platform.hpp	2015-09-16 13:08:13.571563369 +0900
@@ -0,0 +1,647 @@
+namespace phoenix {
+
+struct AppMessage {
+  enum : unsigned {
+    ListView_onActivate = 0,
+  };
+};
+
+typedef LRESULT CALLBACK (*WindowProc)(HWND, UINT, WPARAM, LPARAM);
+
+struct pApplication {
+  static void run();
+  static bool pendingEvents();
+  static void processEvents();
+  static void quit();
+
+  static void initialize();
+};
+
+struct Settings {
+  bimap<Keyboard::Scancode, unsigned> keymap;
+};
+
+struct pFont;
+struct pObject;
+struct pWindow;
+struct pMenu;
+struct pLayout;
+struct pWidget;
+
+struct pFont {
+  static string serif(unsigned size, string style);
+  static string sans(unsigned size, string style);
+  static string monospace(unsigned size, string style);
+  static Size size(string font, string text);
+
+  static HFONT create(string description);
+  static void free(HFONT hfont);
+  static Size size(HFONT hfont, string text);
+};
+
+struct pDesktop {
+  static Size size();
+  static Geometry workspace();
+};
+
+struct pMonitor {
+  static unsigned count();
+  static Geometry geometry(unsigned monitor);
+  static unsigned primary();
+};
+
+struct pKeyboard {
+  static bool pressed(Keyboard::Scancode scancode);
+  static vector<bool> state();
+
+  static void initialize();
+};
+
+struct pMouse {
+  static Position position();
+  static bool pressed(Mouse::Button button);
+};
+
+struct pBrowserWindow {
+  static string directory(BrowserWindow::State& state);
+  static string open(BrowserWindow::State& state);
+  static string save(BrowserWindow::State& state);
+};
+
+struct pMessageWindow {
+  static MessageWindow::Response error(MessageWindow::State& state);
+  static MessageWindow::Response information(MessageWindow::State& state);
+  static MessageWindow::Response question(MessageWindow::State& state);
+  static MessageWindow::Response warning(MessageWindow::State& state);
+};
+
+struct pObject {
+  static vector<pObject*> objects;
+
+  Object& object;
+  uintptr_t id;
+  bool locked;
+
+  pObject(Object& object);
+  static Object* find(unsigned id);
+  virtual ~pObject() {}
+
+  void constructor() {}
+  void destructor() {}
+};
+
+struct pTimer : public pObject {
+  Timer& timer;
+  UINT_PTR htimer;
+
+  void setEnabled(bool enabled);
+  void setInterval(unsigned interval);
+
+  pTimer(Timer& timer) : pObject(timer), timer(timer) {}
+  void constructor();
+};
+
+struct pWindow : public pObject {
+  static vector<pWindow*> modal;
+  static void updateModality();
+
+  Window& window;
+  HWND hwnd;
+  HMENU hmenu;
+  HWND hstatus;
+  HFONT hstatusfont;
+  HBRUSH brush;
+  COLORREF brushColor;
+
+  static Window& none();
+
+  void append(Layout& layout);
+  void append(Menu& menu);
+  void append(Widget& widget);
+  bool focused();
+  Geometry frameMargin();
+  Geometry geometry();
+  void remove(Layout& layout);
+  void remove(Menu& menu);
+  void remove(Widget& widget);
+  void setBackgroundColor(Color color);
+  void setDroppable(bool droppable);
+  void setFocused();
+  void setFullScreen(bool fullScreen);
+  void setGeometry(Geometry geometry);
+  void setMenuFont(string font);
+  void setMenuVisible(bool visible);
+  void setModal(bool modal);
+  void setResizable(bool resizable);
+  void setStatusFont(string font);
+  void setStatusText(string text);
+  void setStatusVisible(bool visible);
+  void setTitle(string text);
+  void setVisible(bool visible);
+  void setWidgetFont(string font);
+
+  pWindow(Window& window) : pObject(window), window(window) {}
+  void constructor();
+  void destructor();
+  void updateMenu();
+
+  void onClose();
+  void onDrop(WPARAM wparam);
+  bool onEraseBackground();
+  void onModalBegin();
+  void onModalEnd();
+  void onMove();
+  void onSize();
+};
+
+struct pAction : public pObject {
+  Action& action;
+  Menu* parentMenu;
+  Window* parentWindow;
+
+  void setEnabled(bool enabled);
+  void setVisible(bool visible);
+
+  pAction(Action& action) : pObject(action), action(action) {}
+  void constructor();
+};
+
+struct pMenu : public pAction {
+  Menu& menu;
+  HMENU hmenu;
+  HBITMAP hbitmap;
+
+  void append(Action& action);
+  void remove(Action& action);
+  void setImage(const image& image);
+  void setText(string text);
+
+  pMenu(Menu& menu) : pAction(menu), menu(menu), hbitmap(0) {}
+  void constructor();
+  void destructor();
+  void createBitmap();
+  void update(Window& parentWindow, Menu* parentMenu = nullptr);
+};
+
+struct pSeparator : public pAction {
+  Separator& separator;
+
+  pSeparator(Separator& separator) : pAction(separator), separator(separator) {}
+  void constructor();
+  void destructor();
+};
+
+struct pItem : public pAction {
+  Item& item;
+  HBITMAP hbitmap;
+
+  void setImage(const image& image);
+  void setText(string text);
+
+  pItem(Item& item) : pAction(item), item(item), hbitmap(0) {}
+  void constructor();
+  void destructor();
+  void createBitmap();
+
+  void onActivate();
+};
+
+struct pCheckItem : public pAction {
+  CheckItem& checkItem;
+
+  void setChecked(bool checked);
+  void setText(string text);
+
+  pCheckItem(CheckItem& checkItem) : pAction(checkItem), checkItem(checkItem) {}
+  void constructor();
+  void destructor();
+
+  void onToggle();
+};
+
+struct pRadioItem : public pAction {
+  RadioItem& radioItem;
+
+  void setChecked();
+  void setGroup(const group<RadioItem>& group);
+  void setText(string text);
+
+  pRadioItem(RadioItem& radioItem) : pAction(radioItem), radioItem(radioItem) {}
+  void constructor();
+  void destructor();
+
+  void onActivate();
+};
+
+struct pSizable : public pObject {
+  Sizable& sizable;
+
+  pSizable(Sizable& sizable) : pObject(sizable), sizable(sizable) {}
+};
+
+struct pLayout : public pSizable {
+  Layout& layout;
+
+  pLayout(Layout& layout) : pSizable(layout), layout(layout) {}
+};
+
+struct pWidget : public pSizable {
+  Widget& widget;
+  HWND parentHwnd;
+  HWND hwnd;
+  HFONT hfont;
+
+  bool focused();
+  virtual Size minimumSize();
+  virtual void setEnabled(bool enabled);
+  void setFocused();
+  void setFont(string font);
+  virtual void setGeometry(Geometry geometry);
+  virtual void setVisible(bool visible);
+
+  pWidget(Widget& widget) : pSizable(widget), widget(widget) { parentHwnd = pWindow::none().p.hwnd; }
+  void constructor();
+  void destructor();
+  virtual void orphan();
+  void setDefaultFont();
+  void synchronize();
+};
+
+struct pButton : public pWidget {
+  Button& button;
+  HBITMAP hbitmap;
+  HIMAGELIST himagelist;
+
+  Size minimumSize();
+  void setBordered(bool bordered);
+  void setImage(const image& image, Orientation orientation);
+  void setText(string text);
+
+  pButton(Button& button) : pWidget(button), button(button), hbitmap(0), himagelist(0) {}
+  void constructor();
+  void destructor();
+  void orphan();
+
+  void onActivate();
+};
+
+struct pCanvas : public pWidget {
+  Canvas& canvas;
+  uint32_t* surface = nullptr;
+  unsigned surfaceWidth = 0;
+  unsigned surfaceHeight = 0;
+
+  void setDroppable(bool droppable);
+  void setGeometry(Geometry geometry);
+  void setMode(Canvas::Mode mode);
+  void setSize(Size size);
+
+  pCanvas(Canvas& canvas) : pWidget(canvas), canvas(canvas) {}
+  void constructor();
+  void destructor();
+  void orphan();
+  void paint();
+  void rasterize();
+  void redraw();
+  void release();
+};
+
+struct pCheckButton : public pWidget {
+  CheckButton& checkButton;
+  HBITMAP hbitmap;
+  HIMAGELIST himagelist;
+
+  Size minimumSize();
+  void setChecked(bool checked);
+  void setImage(const image& image, Orientation orientation);
+  void setText(string text);
+
+  pCheckButton(CheckButton& checkButton) : pWidget(checkButton), checkButton(checkButton) {}
+  void constructor();
+  void destructor();
+  void orphan();
+
+  void onToggle();
+};
+
+struct pCheckLabel : public pWidget {
+  CheckLabel& checkLabel;
+
+  Size minimumSize();
+  void setChecked(bool checked);
+  void setText(string text);
+
+  pCheckLabel(CheckLabel& checkLabel) : pWidget(checkLabel), checkLabel(checkLabel) {}
+  void constructor();
+  void destructor();
+  void orphan();
+
+  void onToggle();
+};
+
+struct pComboButton : public pWidget {
+  ComboButton& comboButton;
+
+  void append(string text);
+  void remove(unsigned selection);
+  Size minimumSize();
+  void reset();
+  void setGeometry(Geometry geometry);
+  void setSelection(unsigned selection);
+  void setText(unsigned selection, string text);
+
+  pComboButton(ComboButton& comboButton) : pWidget(comboButton), comboButton(comboButton) {}
+  void constructor();
+  void destructor();
+  void orphan();
+
+  void onChange();
+};
+
+struct pConsole : public pWidget {
+  Console& console;
+  LRESULT CALLBACK (*windowProc)(HWND, UINT, LPARAM, WPARAM);
+  HBRUSH backgroundBrush = nullptr;
+
+  void print(string text);
+  void reset();
+  void setBackgroundColor(Color color);
+  void setForegroundColor(Color color);
+  void setPrompt(string prompt);
+
+  pConsole(Console& console) : pWidget(console), console(console) {}
+  void constructor();
+  void destructor();
+  void orphan();
+  bool keyPress(unsigned key);
+};
+
+struct pFrame : public pWidget {
+  Frame& frame;
+
+  void setEnabled(bool enabled);
+  void setGeometry(Geometry geometry);
+  void setText(string text);
+  void setVisible(bool visible);
+
+  pFrame(Frame& frame) : pWidget(frame), frame(frame) {}
+  void constructor();
+  void destructor();
+  void orphan();
+};
+
+struct pHexEdit : public pWidget {
+  HexEdit& hexEdit;
+  WindowProc windowProc = nullptr;
+  HWND scrollBar = nullptr;
+  HBRUSH backgroundBrush = nullptr;
+
+  void setBackgroundColor(Color color);
+  void setColumns(unsigned columns);
+  void setForegroundColor(Color color);
+  void setLength(unsigned length);
+  void setOffset(unsigned offset);
+  void setRows(unsigned rows);
+  void update();
+
+  pHexEdit(HexEdit& hexEdit) : pWidget(hexEdit), hexEdit(hexEdit) {}
+  void constructor();
+  void destructor();
+  void orphan();
+  bool keyPress(unsigned key);
+  signed rows();
+  signed rowsScrollable();
+  signed scrollPosition();
+  void scrollTo(signed position);
+};
+
+struct pHorizontalScroller : public pWidget {
+  HorizontalScroller& horizontalScroller;
+
+  Size minimumSize();
+  void setLength(unsigned length);
+  void setPosition(unsigned position);
+
+  pHorizontalScroller(HorizontalScroller& horizontalScroller) : pWidget(horizontalScroller), horizontalScroller(horizontalScroller) {}
+  void constructor();
+  void destructor();
+  void orphan();
+
+  void onChange(WPARAM wparam);
+};
+
+struct pHorizontalSlider : public pWidget {
+  HorizontalSlider& horizontalSlider;
+
+  Size minimumSize();
+  void setLength(unsigned length);
+  void setPosition(unsigned position);
+
+  pHorizontalSlider(HorizontalSlider& horizontalSlider) : pWidget(horizontalSlider), horizontalSlider(horizontalSlider) {}
+  void constructor();
+  void destructor();
+  void orphan();
+
+  void onChange();
+};
+
+struct pLabel : public pWidget {
+  Label& label;
+
+  Size minimumSize();
+  void setText(string text);
+
+  pLabel(Label& label) : pWidget(label), label(label) {}
+  void constructor();
+  void destructor();
+  void orphan();
+};
+
+struct pLineEdit : public pWidget {
+  LineEdit& lineEdit;
+  HBRUSH backgroundBrush = nullptr;
+
+  Size minimumSize();
+  void setBackgroundColor(Color color);
+  void setEditable(bool editable);
+  void setForegroundColor(Color color);
+  void setText(string text);
+  string text();
+
+  pLineEdit(LineEdit& lineEdit) : pWidget(lineEdit), lineEdit(lineEdit) {}
+  void constructor();
+  void destructor();
+  void orphan();
+
+  void onChange();
+};
+
+struct pListView : public pWidget {
+  ListView& listView;
+  HIMAGELIST imageList;
+  vector<vector<unsigned>> imageMap;
+  vector<image> images;
+  bool lostFocus;
+
+  void append(const lstring& text);
+  void autoSizeColumns();
+  void remove(unsigned selection);
+  void reset();
+  void setBackgroundColor(Color color);
+  void setCheckable(bool checkable);
+  void setChecked(unsigned selection, bool checked);
+  void setForegroundColor(Color color);
+  void setGeometry(Geometry geometry);
+  void setHeaderText(const lstring& text);
+  void setHeaderVisible(bool visible);
+  void setImage(unsigned selection, unsigned position, const image& image);
+  void setSelected(bool selected);
+  void setSelection(unsigned selection);
+  void setText(unsigned selection, unsigned position, string text);
+
+  pListView(ListView& listView) : pWidget(listView), listView(listView), imageList(nullptr) {}
+  void constructor();
+  void destructor();
+  void orphan();
+  void buildImageList();
+
+  void onActivate(LPARAM lparam);
+  void onChange(LPARAM lparam);
+  LRESULT onCustomDraw(LPARAM lparam);
+};
+
+struct pProgressBar : public pWidget {
+  ProgressBar& progressBar;
+
+  Size minimumSize();
+  void setPosition(unsigned position);
+
+  pProgressBar(ProgressBar& progressBar) : pWidget(progressBar), progressBar(progressBar) {}
+  void constructor();
+  void destructor();
+  void orphan();
+};
+
+struct pRadioButton : public pWidget {
+  RadioButton& radioButton;
+  HBITMAP hbitmap;
+  HIMAGELIST himagelist;
+
+  Size minimumSize();
+  void setChecked();
+  void setGroup(const group<RadioButton>& group);
+  void setImage(const image& image, Orientation orientation);
+  void setText(string text);
+
+  pRadioButton(RadioButton& radioButton) : pWidget(radioButton), radioButton(radioButton) {}
+  void constructor();
+  void destructor();
+  void orphan();
+
+  void onActivate();
+};
+
+struct pRadioLabel : public pWidget {
+  RadioLabel& radioLabel;
+
+  Size minimumSize();
+  void setChecked();
+  void setGroup(const group<RadioLabel>& group);
+  void setText(string text);
+
+  pRadioLabel(RadioLabel& radioLabel) : pWidget(radioLabel), radioLabel(radioLabel) {}
+  void constructor();
+  void destructor();
+  void orphan();
+
+  void onActivate();
+};
+
+struct pTabFrame : public pWidget {
+  TabFrame& tabFrame;
+  WindowProc windowProc = nullptr;
+  HIMAGELIST imageList = nullptr;
+
+  void append(string text, const image& image);
+  void remove(unsigned selection);
+  void setEnabled(bool enabled);
+  void setGeometry(Geometry geometry);
+  void setImage(unsigned selection, const image& image);
+  void setSelection(unsigned selection);
+  void setText(unsigned selection, string text);
+  void setVisible(bool visible);
+
+  pTabFrame(TabFrame& tabFrame) : pWidget(tabFrame), tabFrame(tabFrame) {}
+  void constructor();
+  void destructor();
+  void orphan();
+  void buildImageList();
+  void synchronizeLayout();
+
+  void onChange();
+  void onDrawItem(LPARAM lparam);
+};
+
+struct pTextEdit : public pWidget {
+  TextEdit& textEdit;
+  HBRUSH backgroundBrush = nullptr;
+
+  void setBackgroundColor(Color color);
+  void setCursorPosition(unsigned position);
+  void setEditable(bool editable);
+  void setForegroundColor(Color color);
+  void setText(string text);
+  void setWordWrap(bool wordWrap);
+  string text();
+
+  pTextEdit(TextEdit& textEdit) : pWidget(textEdit), textEdit(textEdit) {}
+  void constructor();
+  void destructor();
+  void orphan();
+
+  void onChange();
+};
+
+struct pVerticalScroller : public pWidget {
+  VerticalScroller& verticalScroller;
+
+  Size minimumSize();
+  void setLength(unsigned length);
+  void setPosition(unsigned position);
+
+  pVerticalScroller(VerticalScroller& verticalScroller) : pWidget(verticalScroller), verticalScroller(verticalScroller) {}
+  void constructor();
+  void destructor();
+  void orphan();
+
+  void onChange(WPARAM wparam);
+};
+
+struct pVerticalSlider : public pWidget {
+  VerticalSlider& verticalSlider;
+
+  Size minimumSize();
+  void setLength(unsigned length);
+  void setPosition(unsigned position);
+
+  pVerticalSlider(VerticalSlider& verticalSlider) : pWidget(verticalSlider), verticalSlider(verticalSlider) {}
+  void constructor();
+  void destructor();
+  void orphan();
+
+  void onChange();
+};
+
+struct pViewport : public pWidget {
+  Viewport& viewport;
+
+  uintptr_t handle();
+  void setDroppable(bool droppable);
+
+  pViewport(Viewport& viewport) : pWidget(viewport), viewport(viewport) {}
+  void constructor();
+  void destructor();
+  void orphan();
+};
+
+}
diff -Nru higan/phoenix/windows/settings.cpp nSide/phoenix/windows/settings.cpp
--- higan/phoenix/windows/settings.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/windows/settings.cpp	2015-09-16 13:08:13.568563369 +0900
@@ -0,0 +1,5 @@
+namespace phoenix {
+
+static Settings* settings = nullptr;
+
+}
diff -Nru higan/phoenix/windows/timer.cpp nSide/phoenix/windows/timer.cpp
--- higan/phoenix/windows/timer.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/windows/timer.cpp	2015-09-16 13:08:13.576563370 +0900
@@ -0,0 +1,35 @@
+namespace phoenix {
+
+static vector<pTimer*> timers;
+
+static void CALLBACK Timer_timeoutProc(HWND hwnd, UINT msg, UINT_PTR timerID, DWORD time) {
+  for(auto& timer : timers) {
+    if(timer->htimer == timerID) {
+      if(timer->timer.onActivate) timer->timer.onActivate();
+      return;
+    }
+  }
+}
+
+void pTimer::setEnabled(bool enabled) {
+  if(htimer) {
+    KillTimer(NULL, htimer);
+    htimer = 0;
+  }
+
+  if(enabled == true) {
+    htimer = SetTimer(NULL, 0u, timer.state.interval, Timer_timeoutProc);
+  }
+}
+
+void pTimer::setInterval(unsigned interval) {
+  //destroy and recreate timer if interval changed
+  setEnabled(timer.state.enabled);
+}
+
+void pTimer::constructor() {
+  timers.append(this);
+  htimer = 0;
+}
+
+}
diff -Nru higan/phoenix/windows/utility.cpp nSide/phoenix/windows/utility.cpp
--- higan/phoenix/windows/utility.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/windows/utility.cpp	2015-09-16 13:08:13.580563370 +0900
@@ -0,0 +1,358 @@
+namespace phoenix {
+
+static const unsigned Windows2000  = 0x0500;
+static const unsigned WindowsXP    = 0x0501;
+static const unsigned WindowsVista = 0x0600;
+static const unsigned Windows7     = 0x0601;
+
+static unsigned OsVersion() {
+  OSVERSIONINFO versionInfo = {0};
+  versionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
+  GetVersionEx(&versionInfo);
+  return (versionInfo.dwMajorVersion << 8) + (versionInfo.dwMajorVersion << 0);
+}
+
+static HBITMAP CreateBitmap(const image& icon) {
+  HDC hdc = GetDC(0);
+  BITMAPINFO bitmapInfo;
+  memset(&bitmapInfo, 0, sizeof(BITMAPINFO));
+  bitmapInfo.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
+  bitmapInfo.bmiHeader.biWidth = icon.width();
+  bitmapInfo.bmiHeader.biHeight = -(signed)icon.height();  //bitmaps are stored upside down unless we negate height
+  bitmapInfo.bmiHeader.biPlanes = 1;
+  bitmapInfo.bmiHeader.biBitCount = 32;
+  bitmapInfo.bmiHeader.biCompression = BI_RGB;
+  bitmapInfo.bmiHeader.biSizeImage = icon.size();
+  void* bits = nullptr;
+  HBITMAP hbitmap = CreateDIBSection(hdc, &bitmapInfo, DIB_RGB_COLORS, &bits, NULL, 0);
+  if(bits) memory::copy(bits, icon.data(), icon.size());
+  ReleaseDC(0, hdc);
+  return hbitmap;
+}
+
+static lstring DropPaths(WPARAM wparam) {
+  auto dropList = HDROP(wparam);
+  auto fileCount = DragQueryFile(dropList, ~0u, nullptr, 0);
+
+  lstring paths;
+  for(unsigned n = 0; n < fileCount; n++) {
+    auto length = DragQueryFile(dropList, n, nullptr, 0);
+    auto buffer = new wchar_t[length + 1];
+
+    if(DragQueryFile(dropList, n, buffer, length + 1)) {
+      string path = (const char*)utf8_t(buffer);
+      path.transform("\\", "/");
+      if(directory::exists(path) && !path.endsWith("/")) path.append("/");
+      paths.append(path);
+    }
+
+    delete[] buffer;
+  }
+
+  return paths;
+}
+
+static Layout* GetParentWidgetLayout(Sizable* sizable) {
+  while(sizable) {
+    if(sizable->state.parent && dynamic_cast<TabFrame*>(sizable->state.parent)) return (Layout*)sizable;
+    sizable = sizable->state.parent;
+  }
+  return nullptr;
+}
+
+static Widget* GetParentWidget(Sizable* sizable) {
+  while(sizable) {
+    if(sizable->state.parent && dynamic_cast<TabFrame*>(sizable->state.parent)) return (Widget*)sizable->state.parent;
+    sizable = sizable->state.parent;
+  }
+  return nullptr;
+}
+
+static unsigned GetWindowZOrder(HWND hwnd) {
+  unsigned z = 0;
+  for(HWND next = hwnd; next != NULL; next = GetWindow(next, GW_HWNDPREV)) z++;
+  return z;
+}
+
+static void ImageList_Append(HIMAGELIST imageList, const nall::image& source, unsigned scale) {
+  auto image = source;
+  if(image.empty()) {
+    image.allocate(scale, scale);
+    image.fill(GetSysColor(COLOR_WINDOW));
+  }
+  image.transform(0, 32, 255u << 24, 255u << 16, 255u << 8, 255u << 0);
+  image.scale(scale, scale);
+  HBITMAP bitmap = CreateBitmap(image);
+  ImageList_Add(imageList, bitmap, NULL);
+  DeleteObject(bitmap);
+}
+
+static Keyboard::Keycode Keysym(unsigned keysym, unsigned keyflags) {
+  #define pressed(keysym) (GetAsyncKeyState(keysym) & 0x8000)
+  #define enabled(keysym) (GetKeyState(keysym))
+  #define shifted() (pressed(VK_LSHIFT) || pressed(VK_RSHIFT))
+  #define extended() (keyflags & (1 << 24))
+
+  switch(keysym) {
+  case VK_ESCAPE: return Keyboard::Keycode::Escape;
+  case VK_F1: return Keyboard::Keycode::F1;
+  case VK_F2: return Keyboard::Keycode::F2;
+  case VK_F3: return Keyboard::Keycode::F3;
+  case VK_F4: return Keyboard::Keycode::F4;
+  case VK_F5: return Keyboard::Keycode::F5;
+  case VK_F6: return Keyboard::Keycode::F6;
+  case VK_F7: return Keyboard::Keycode::F7;
+  case VK_F8: return Keyboard::Keycode::F8;
+  case VK_F9: return Keyboard::Keycode::F9;
+  //Keyboard::Keycode::F10 (should be captured under VK_MENU from WM_SYSKEY(UP,DOWN); but this is not working...)
+  case VK_F11: return Keyboard::Keycode::F11;
+  case VK_F12: return Keyboard::Keycode::F12;
+
+  //Keyboard::Keycode::PrintScreen
+  //Keyboard::Keycode::SysRq
+  case VK_SCROLL: return Keyboard::Keycode::ScrollLock;
+  case VK_PAUSE: return Keyboard::Keycode::Pause;
+  //Keyboard::Keycode::Break
+
+  case VK_INSERT: return extended() ? Keyboard::Keycode::Insert : Keyboard::Keycode::KeypadInsert;
+  case VK_DELETE: return extended() ? Keyboard::Keycode::Delete : Keyboard::Keycode::KeypadDelete;
+  case VK_HOME: return extended() ? Keyboard::Keycode::Home : Keyboard::Keycode::KeypadHome;
+  case VK_END: return extended() ? Keyboard::Keycode::End : Keyboard::Keycode::KeypadEnd;
+  case VK_PRIOR: return extended() ? Keyboard::Keycode::PageUp : Keyboard::Keycode::KeypadPageUp;
+  case VK_NEXT: return extended() ? Keyboard::Keycode::PageDown : Keyboard::Keycode::KeypadPageDown;
+
+  case VK_UP: return extended() ? Keyboard::Keycode::Up : Keyboard::Keycode::KeypadUp;
+  case VK_DOWN: return extended() ? Keyboard::Keycode::Down : Keyboard::Keycode::KeypadDown;
+  case VK_LEFT: return extended() ? Keyboard::Keycode::Left : Keyboard::Keycode::KeypadLeft;
+  case VK_RIGHT: return extended() ? Keyboard::Keycode::Right : Keyboard::Keycode::KeypadRight;
+
+  case VK_OEM_3: return !shifted() ? Keyboard::Keycode::Grave : Keyboard::Keycode::Tilde;
+  case '1': return !shifted() ? Keyboard::Keycode::Number1 : Keyboard::Keycode::Exclamation;
+  case '2': return !shifted() ? Keyboard::Keycode::Number2 : Keyboard::Keycode::At;
+  case '3': return !shifted() ? Keyboard::Keycode::Number3 : Keyboard::Keycode::Pound;
+  case '4': return !shifted() ? Keyboard::Keycode::Number4 : Keyboard::Keycode::Dollar;
+  case '5': return !shifted() ? Keyboard::Keycode::Number5 : Keyboard::Keycode::Percent;
+  case '6': return !shifted() ? Keyboard::Keycode::Number6 : Keyboard::Keycode::Power;
+  case '7': return !shifted() ? Keyboard::Keycode::Number7 : Keyboard::Keycode::Ampersand;
+  case '8': return !shifted() ? Keyboard::Keycode::Number8 : Keyboard::Keycode::Asterisk;
+  case '9': return !shifted() ? Keyboard::Keycode::Number9 : Keyboard::Keycode::ParenthesisLeft;
+  case '0': return !shifted() ? Keyboard::Keycode::Number0 : Keyboard::Keycode::ParenthesisRight;
+  case VK_OEM_MINUS: return !shifted() ? Keyboard::Keycode::Minus : Keyboard::Keycode::Underscore;
+  case VK_OEM_PLUS: return !shifted() ? Keyboard::Keycode::Equal : Keyboard::Keycode::Plus;
+  case VK_BACK: return Keyboard::Keycode::Backspace;
+
+  case VK_OEM_4: return !shifted() ? Keyboard::Keycode::BracketLeft : Keyboard::Keycode::BraceLeft;
+  case VK_OEM_6: return !shifted() ? Keyboard::Keycode::BracketRight : Keyboard::Keycode::BraceRight;
+  case VK_OEM_5: return !shifted() ? Keyboard::Keycode::Backslash : Keyboard::Keycode::Pipe;
+  case VK_OEM_1: return !shifted() ? Keyboard::Keycode::Semicolon : Keyboard::Keycode::Colon;
+  case VK_OEM_7: return !shifted() ? Keyboard::Keycode::Apostrophe : Keyboard::Keycode::Quote;
+  case VK_OEM_COMMA: return !shifted() ? Keyboard::Keycode::Comma : Keyboard::Keycode::CaretLeft;
+  case VK_OEM_PERIOD: return !shifted() ? Keyboard::Keycode::Period : Keyboard::Keycode::CaretRight;
+  case VK_OEM_2: return !shifted() ? Keyboard::Keycode::Slash : Keyboard::Keycode::Question;
+
+  case VK_TAB: return Keyboard::Keycode::Tab;
+  case VK_CAPITAL: return Keyboard::Keycode::CapsLock;
+  case VK_RETURN: return !extended() ? Keyboard::Keycode::Return : Keyboard::Keycode::Enter;
+  case VK_SHIFT: return !pressed(VK_RSHIFT) ? Keyboard::Keycode::ShiftLeft : Keyboard::Keycode::ShiftRight;
+  case VK_CONTROL: return !pressed(VK_RCONTROL) ? Keyboard::Keycode::ControlLeft : Keyboard::Keycode::ControlRight;
+  case VK_LWIN: return Keyboard::Keycode::SuperLeft;
+  case VK_RWIN: return Keyboard::Keycode::SuperRight;
+  case VK_MENU:
+    if(keyflags & (1 << 24)) return Keyboard::Keycode::AltRight;
+    return Keyboard::Keycode::AltLeft;
+  case VK_SPACE: return Keyboard::Keycode::Space;
+  case VK_APPS: return Keyboard::Keycode::Menu;
+
+  case 'A': case 'B': case 'C': case 'D': case 'E': case 'F': case 'G': case 'H': case 'I': case 'J': case 'K': case 'L': case 'M':
+  case 'N': case 'O': case 'P': case 'Q': case 'R': case 'S': case 'T': case 'U': case 'V': case 'W': case 'X': case 'Y': case 'Z':
+    if(enabled(VK_CAPITAL)) {
+      if(shifted()) {
+        return (Keyboard::Keycode)((unsigned)Keyboard::Keycode::a + keysym - 'A');
+      } else {
+        return (Keyboard::Keycode)((unsigned)Keyboard::Keycode::A + keysym - 'A');
+      }
+    } else {
+      if(shifted()) {
+        return (Keyboard::Keycode)((unsigned)Keyboard::Keycode::A + keysym - 'A');
+      } else {
+        return (Keyboard::Keycode)((unsigned)Keyboard::Keycode::a + keysym - 'A');
+      }
+    }
+    break;
+
+  case VK_NUMLOCK: return Keyboard::Keycode::NumLock;
+  case VK_DIVIDE: return Keyboard::Keycode::Divide;
+  case VK_MULTIPLY: return Keyboard::Keycode::Multiply;
+  case VK_SUBTRACT: return Keyboard::Keycode::Subtract;
+  case VK_ADD: return Keyboard::Keycode::Add;
+  case VK_DECIMAL: return Keyboard::Keycode::Point;
+  case VK_NUMPAD1: return Keyboard::Keycode::Keypad1;
+  case VK_NUMPAD2: return Keyboard::Keycode::Keypad2;
+  case VK_NUMPAD3: return Keyboard::Keycode::Keypad3;
+  case VK_NUMPAD4: return Keyboard::Keycode::Keypad4;
+  case VK_NUMPAD5: return Keyboard::Keycode::Keypad5;
+  case VK_NUMPAD6: return Keyboard::Keycode::Keypad6;
+  case VK_NUMPAD7: return Keyboard::Keycode::Keypad7;
+  case VK_NUMPAD8: return Keyboard::Keycode::Keypad8;
+  case VK_NUMPAD9: return Keyboard::Keycode::Keypad9;
+  case VK_NUMPAD0: return Keyboard::Keycode::Keypad0;
+
+  case VK_CLEAR: return Keyboard::Keycode::KeypadCenter;
+  }
+
+  return Keyboard::Keycode::None;
+
+  #undef pressed
+  #undef enabled
+  #undef shifted
+  #undef extended
+}
+
+static unsigned ScrollEvent(HWND hwnd, WPARAM wparam) {
+  SCROLLINFO info;
+  memset(&info, 0, sizeof(SCROLLINFO));
+  info.cbSize = sizeof(SCROLLINFO);
+  info.fMask = SIF_ALL;
+  GetScrollInfo(hwnd, SB_CTL, &info);
+
+  switch(LOWORD(wparam)) {
+  case SB_LEFT: info.nPos = info.nMin; break;
+  case SB_RIGHT: info.nPos = info.nMax; break;
+  case SB_LINELEFT: info.nPos--; break;
+  case SB_LINERIGHT: info.nPos++; break;
+  case SB_PAGELEFT: info.nPos -= info.nMax >> 3; break;
+  case SB_PAGERIGHT: info.nPos += info.nMax >> 3; break;
+  case SB_THUMBTRACK: info.nPos = info.nTrackPos; break;
+  }
+
+  info.fMask = SIF_POS;
+  SetScrollInfo(hwnd, SB_CTL, &info, TRUE);
+
+  //Windows may clamp position to scroller range
+  GetScrollInfo(hwnd, SB_CTL, &info);
+  return info.nPos;
+}
+
+static LRESULT CALLBACK Shared_windowProc(WindowProc windowProc, HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam) {
+  Object* object = (Object*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
+  if(object == nullptr) return DefWindowProc(hwnd, msg, wparam, lparam);
+  Window& window = dynamic_cast<Window*>(object) ? *(Window*)object : *((Widget*)object)->Sizable::state.window;
+
+  bool process = true;
+  if(!pWindow::modal.empty() && !pWindow::modal.find(&window.p)) process = false;
+  if(applicationState.quit) process = false;
+  if(process == false) return DefWindowProc(hwnd, msg, wparam, lparam);
+
+  switch(msg) {
+  case WM_CTLCOLORBTN:
+  case WM_CTLCOLOREDIT:
+  case WM_CTLCOLORSTATIC: {
+    Object* object = (Object*)GetWindowLongPtr((HWND)lparam, GWLP_USERDATA);
+    if(object == nullptr) break;
+    //allow custom colors for various widgets
+    //note that this happens always: default colors are black text on a white background, unless overridden
+    //this intentionally overrides the default behavior of Windows to paint disabled controls with the window background color
+    if(dynamic_cast<Console*>(object)) {
+      Console& console = *(Console*)object;
+      Color& background = console.state.backgroundColor;
+      Color& foreground = console.state.foregroundColor;
+      SetTextColor((HDC)wparam, RGB(foreground.red, foreground.green, foreground.blue));
+      SetBkColor((HDC)wparam, RGB(background.red, background.green, background.blue));
+      return (LRESULT)console.p.backgroundBrush;
+    } else if(dynamic_cast<HexEdit*>(object)) {
+      HexEdit& hexEdit = *(HexEdit*)object;
+      Color& background = hexEdit.state.backgroundColor;
+      Color& foreground = hexEdit.state.foregroundColor;
+      SetTextColor((HDC)wparam, RGB(foreground.red, foreground.green, foreground.blue));
+      SetBkColor((HDC)wparam, RGB(background.red, background.green, background.blue));
+      return (LRESULT)hexEdit.p.backgroundBrush;
+    } else if(dynamic_cast<LineEdit*>(object)) {
+      LineEdit& lineEdit = *(LineEdit*)object;
+      Color& background = lineEdit.state.backgroundColor;
+      Color& foreground = lineEdit.state.foregroundColor;
+      SetTextColor((HDC)wparam, RGB(foreground.red, foreground.green, foreground.blue));
+      SetBkColor((HDC)wparam, RGB(background.red, background.green, background.blue));
+      return (LRESULT)lineEdit.p.backgroundBrush;
+    } else if(dynamic_cast<TextEdit*>(object)) {
+      TextEdit& textEdit = *(TextEdit*)object;
+      Color& background = textEdit.state.backgroundColor;
+      Color& foreground = textEdit.state.foregroundColor;
+      SetTextColor((HDC)wparam, RGB(foreground.red, foreground.green, foreground.blue));
+      SetBkColor((HDC)wparam, RGB(background.red, background.green, background.blue));
+      return (LRESULT)textEdit.p.backgroundBrush;
+    } else if(!GetParentWidget((Sizable*)object) && window.p.brush) {
+      SetBkColor((HDC)wparam, window.p.brushColor);
+      return (INT_PTR)window.p.brush;
+    }
+    break;
+  }
+
+  case WM_DRAWITEM: {
+    unsigned id = LOWORD(wparam);
+    HWND control = GetDlgItem(hwnd, id);
+    Object* object = (Object*)GetWindowLongPtr(control, GWLP_USERDATA);
+    if(object == nullptr) break;
+    if(dynamic_cast<TabFrame*>(object)) { ((TabFrame*)object)->p.onDrawItem(lparam); return TRUE; }
+    break;
+  }
+
+  case WM_COMMAND: {
+    unsigned id = LOWORD(wparam);
+    HWND control = GetDlgItem(hwnd, id);
+    Object* object = control ? (Object*)GetWindowLongPtr(control, GWLP_USERDATA) : pObject::find(id);
+    if(object == nullptr) break;
+    if(dynamic_cast<Item*>(object)) { ((Item*)object)->p.onActivate(); return FALSE; }
+    if(dynamic_cast<CheckItem*>(object)) { ((CheckItem*)object)->p.onToggle(); return FALSE; }
+    if(dynamic_cast<RadioItem*>(object)) { ((RadioItem*)object)->p.onActivate(); return FALSE; }
+    if(dynamic_cast<Button*>(object)) { ((Button*)object)->p.onActivate(); return FALSE; }
+    if(dynamic_cast<CheckButton*>(object)) { ((CheckButton*)object)->p.onToggle(); return FALSE; }
+    if(dynamic_cast<CheckLabel*>(object)) { ((CheckLabel*)object)->p.onToggle(); return FALSE; }
+    if(dynamic_cast<ComboButton*>(object) && HIWORD(wparam) == CBN_SELCHANGE) { ((ComboButton*)object)->p.onChange(); return FALSE; }
+    if(dynamic_cast<LineEdit*>(object) && HIWORD(wparam) == EN_CHANGE) { ((LineEdit*)object)->p.onChange(); return FALSE; }
+    if(dynamic_cast<RadioButton*>(object)) { ((RadioButton*)object)->p.onActivate(); return FALSE; }
+    if(dynamic_cast<RadioLabel*>(object)) { ((RadioLabel*)object)->p.onActivate(); return FALSE; }
+    if(dynamic_cast<TextEdit*>(object) && HIWORD(wparam) == EN_CHANGE) { ((TextEdit*)object)->p.onChange(); return FALSE; }
+    break;
+  }
+
+  case WM_NOTIFY: {
+    unsigned id = LOWORD(wparam);
+    HWND control = GetDlgItem(hwnd, id);
+    Object* object = (Object*)GetWindowLongPtr(control, GWLP_USERDATA);
+    if(object == nullptr) break;
+    if(dynamic_cast<ListView*>(object) && ((LPNMHDR)lparam)->code == LVN_ITEMACTIVATE) { ((ListView*)object)->p.onActivate(lparam); break; }
+    if(dynamic_cast<ListView*>(object) && ((LPNMHDR)lparam)->code == LVN_ITEMCHANGED) { ((ListView*)object)->p.onChange(lparam); break; }
+    if(dynamic_cast<ListView*>(object) && ((LPNMHDR)lparam)->code == NM_CUSTOMDRAW) { return ((ListView*)object)->p.onCustomDraw(lparam); }
+    if(dynamic_cast<TabFrame*>(object) && ((LPNMHDR)lparam)->code == TCN_SELCHANGE) { ((TabFrame*)object)->p.onChange(); break; }
+    break;
+  }
+
+  case WM_APP + AppMessage::ListView_onActivate: {
+    ListView* listView = (ListView*)lparam;
+    if(listView && listView->onActivate) listView->onActivate();
+    break;
+  }
+
+  case WM_HSCROLL:
+  case WM_VSCROLL: {
+    Object* object = nullptr;
+    if(lparam) {
+      object = (Object*)GetWindowLongPtr((HWND)lparam, GWLP_USERDATA);
+    } else {
+      unsigned id = LOWORD(wparam);
+      HWND control = GetDlgItem(hwnd, id);
+      object = (Object*)GetWindowLongPtr(control, GWLP_USERDATA);
+    }
+    if(object == nullptr) break;
+    if(dynamic_cast<HorizontalScroller*>(object)) { ((HorizontalScroller*)object)->p.onChange(wparam); return TRUE; }
+    if(dynamic_cast<VerticalScroller*>(object)) { ((VerticalScroller*)object)->p.onChange(wparam); return TRUE; }
+    if(dynamic_cast<HorizontalSlider*>(object)) { ((HorizontalSlider*)object)->p.onChange(); return TRUE; }
+    if(dynamic_cast<VerticalSlider*>(object)) { ((VerticalSlider*)object)->p.onChange(); return TRUE; }
+    break;
+  }
+  }
+
+  return windowProc(hwnd, msg, wparam, lparam);
+}
+
+}
diff -Nru higan/phoenix/windows/widget/button.cpp nSide/phoenix/windows/widget/button.cpp
--- higan/phoenix/windows/widget/button.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/windows/widget/button.cpp	2015-09-16 13:08:13.571563369 +0900
@@ -0,0 +1,102 @@
+namespace phoenix {
+
+#ifndef Button_SetImageList
+  //MinGW/32-bit has painfully outdated platform headers ...
+  typedef struct {
+    HIMAGELIST himl;
+    RECT margin;
+    UINT uAlign;
+  } BUTTON_IMAGELIST, *PBUTTON_IMAGELIST;
+
+  #define BUTTON_IMAGELIST_ALIGN_LEFT 0
+  #define BUTTON_IMAGELIST_ALIGN_RIGHT 1
+  #define BUTTON_IMAGELIST_ALIGN_TOP 2
+  #define BUTTON_IMAGELIST_ALIGN_BOTTOM 3
+  #define BUTTON_IMAGELIST_ALIGN_CENTER 4
+
+  #define BCM_FIRST 0x1600
+  #define BCM_SETIMAGELIST (BCM_FIRST+2)
+  #define Button_SetImageList(hwnd, pbuttonImagelist) (WINBOOL)SNDMSG((hwnd),BCM_SETIMAGELIST,0,(LPARAM)(pbuttonImagelist))
+#endif
+
+Size pButton::minimumSize() {
+  Size size = pFont::size(hfont, button.state.text);
+
+  if(button.state.orientation == Orientation::Horizontal) {
+    size.width += button.state.image.width();
+    size.height = max(button.state.image.height(), size.height);
+  }
+
+  if(button.state.orientation == Orientation::Vertical) {
+    size.width = max(button.state.image.width(), size.width);
+    size.height += button.state.image.height();
+  }
+
+  return {size.width + (button.state.text ? 20 : 10), size.height + 10};
+}
+
+void pButton::setBordered(bool bordered) {
+}
+
+void pButton::setImage(const image& image, Orientation orientation) {
+  nall::image nallImage = image;
+  nallImage.transform(0, 32, 255u << 24, 255u << 16, 255u << 8, 255u << 0);
+
+  if(hbitmap) { DeleteObject(hbitmap); hbitmap = 0; }
+  if(himagelist) { ImageList_Destroy(himagelist); himagelist = 0; }
+
+  //Windows XP and earlier do not support translucent images
+  //so we must blend with the button background color (which does not look great with XP gradient-button themes)
+  if(OsVersion() < WindowsVista) nallImage.alphaBlend(GetSysColor(COLOR_BTNFACE));
+  hbitmap = CreateBitmap(nallImage);
+  himagelist = ImageList_Create(nallImage.width(), nallImage.height(), ILC_COLOR32, 1, 0);
+  ImageList_Add(himagelist, hbitmap, NULL);
+  BUTTON_IMAGELIST list;
+  list.himl = himagelist;
+  switch(orientation) {
+  case Orientation::Horizontal: SetRect(&list.margin, 5, 0, 0, 0); list.uAlign = BUTTON_IMAGELIST_ALIGN_LEFT; break;
+  case Orientation::Vertical:   SetRect(&list.margin, 0, 5, 0, 0); list.uAlign = BUTTON_IMAGELIST_ALIGN_TOP;  break;
+  }
+  Button_SetImageList(hwnd, &list);
+
+  setText(button.state.text);  //update text to display nicely with image (or lack thereof)
+}
+
+void pButton::setText(string text) {
+  if(text.empty()) {
+    //bitmaps will not show up if text is empty
+    SetWindowLongPtr(hwnd, GWL_STYLE, GetWindowLongPtr(hwnd, GWL_STYLE) |  BS_BITMAP);
+  } else {
+    //text will not show up if BS_BITMAP is set
+    SetWindowLongPtr(hwnd, GWL_STYLE, GetWindowLongPtr(hwnd, GWL_STYLE) & ~BS_BITMAP);
+  }
+
+  SetWindowText(hwnd, utf16_t(text));
+}
+
+void pButton::constructor() {
+  hwnd = CreateWindow(L"BUTTON", L"", WS_CHILD | WS_TABSTOP, 0, 0, 0, 0, parentHwnd, (HMENU)id, GetModuleHandle(0), 0);
+  SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)&button);
+  setDefaultFont();
+  setBordered(button.state.bordered);
+  setImage(button.state.image, button.state.orientation);
+//setText(button.state.text);  //called by setImage();
+  synchronize();
+}
+
+void pButton::destructor() {
+  if(hbitmap) { DeleteObject(hbitmap); hbitmap = 0; }
+  if(himagelist) { ImageList_Destroy(himagelist); himagelist = 0; }
+  DestroyWindow(hwnd);
+}
+
+void pButton::orphan() {
+  destructor();
+  constructor();
+}
+
+void pButton::onActivate() {
+  if(button.onActivate) button.onActivate();
+}
+
+}
diff -Nru higan/phoenix/windows/widget/canvas.cpp nSide/phoenix/windows/widget/canvas.cpp
--- higan/phoenix/windows/widget/canvas.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/windows/widget/canvas.cpp	2015-09-16 13:08:13.572563370 +0900
@@ -0,0 +1,209 @@
+namespace phoenix {
+
+static LRESULT CALLBACK Canvas_windowProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam) {
+  Object* object = (Object*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
+  if(object == nullptr) return DefWindowProc(hwnd, msg, wparam, lparam);
+  if(!dynamic_cast<Canvas*>(object)) return DefWindowProc(hwnd, msg, wparam, lparam);
+  Canvas& canvas = (Canvas&)*object;
+
+  if(msg == WM_DROPFILES) {
+    lstring paths = DropPaths(wparam);
+    if(paths.empty() == false) {
+      if(canvas.onDrop) canvas.onDrop(paths);
+    }
+    return FALSE;
+  }
+
+  if(msg == WM_GETDLGCODE) {
+    return DLGC_STATIC | DLGC_WANTCHARS;
+  }
+
+  if(msg == WM_ERASEBKGND) {
+    //background is erased during WM_PAINT to prevent flickering
+    return TRUE;
+  }
+
+  if(msg == WM_PAINT) {
+    canvas.p.paint();
+    return TRUE;
+  }
+
+  if(msg == WM_MOUSEMOVE) {
+    TRACKMOUSEEVENT tracker = {sizeof(TRACKMOUSEEVENT), TME_LEAVE, hwnd};
+    TrackMouseEvent(&tracker);
+    if(canvas.onMouseMove) canvas.onMouseMove({(int16_t)LOWORD(lparam), (int16_t)HIWORD(lparam)});
+  }
+
+  if(msg == WM_MOUSELEAVE) {
+    if(canvas.onMouseLeave) canvas.onMouseLeave();
+  }
+
+  if(msg == WM_LBUTTONDOWN || msg == WM_MBUTTONDOWN || msg == WM_RBUTTONDOWN) {
+    if(canvas.onMousePress) switch(msg) {
+    case WM_LBUTTONDOWN: canvas.onMousePress(Mouse::Button::Left); break;
+    case WM_MBUTTONDOWN: canvas.onMousePress(Mouse::Button::Middle); break;
+    case WM_RBUTTONDOWN: canvas.onMousePress(Mouse::Button::Right); break;
+    }
+  }
+
+  if(msg == WM_LBUTTONUP || msg == WM_MBUTTONUP || msg == WM_RBUTTONUP) {
+    if(canvas.onMouseRelease) switch(msg) {
+    case WM_LBUTTONUP: canvas.onMouseRelease(Mouse::Button::Left); break;
+    case WM_MBUTTONUP: canvas.onMouseRelease(Mouse::Button::Middle); break;
+    case WM_RBUTTONUP: canvas.onMouseRelease(Mouse::Button::Right); break;
+    }
+  }
+
+  return DefWindowProc(hwnd, msg, wparam, lparam);
+}
+
+void pCanvas::setDroppable(bool droppable) {
+  DragAcceptFiles(hwnd, droppable);
+}
+
+void pCanvas::setGeometry(Geometry geometry) {
+  if(canvas.state.width == 0 || canvas.state.height == 0) rasterize();
+  unsigned width = canvas.state.width;
+  unsigned height = canvas.state.height;
+  if(width == 0) width = widget.state.geometry.width;
+  if(height == 0) height = widget.state.geometry.height;
+
+  if(width < geometry.width) {
+    geometry.x += (geometry.width - width) / 2;
+    geometry.width = width;
+  }
+
+  if(height < geometry.height) {
+    geometry.y += (geometry.height - height) / 2;
+    geometry.height = height;
+  }
+
+  pWidget::setGeometry(geometry);
+}
+
+void pCanvas::setMode(Canvas::Mode mode) {
+  rasterize(), redraw();
+}
+
+void pCanvas::setSize(Size size) {
+  rasterize(), redraw();
+}
+
+void pCanvas::constructor() {
+  hwnd = CreateWindow(L"phoenix_canvas", L"", WS_CHILD, 0, 0, 0, 0, parentHwnd, (HMENU)id, GetModuleHandle(0), 0);
+  SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)&canvas);
+  setDroppable(canvas.state.droppable);
+  rasterize();
+  synchronize();
+}
+
+void pCanvas::destructor() {
+  release();
+  DestroyWindow(hwnd);
+}
+
+void pCanvas::orphan() {
+  destructor();
+  constructor();
+}
+
+void pCanvas::paint() {
+  if(surface == nullptr) return;
+
+  PAINTSTRUCT ps;
+  BeginPaint(hwnd, &ps);
+
+  uint32_t* data = surface;
+  unsigned width = surfaceWidth;
+  unsigned height = surfaceHeight;
+
+  HDC hdc = CreateCompatibleDC(ps.hdc);
+  BITMAPINFO bmi;
+  memset(&bmi, 0, sizeof(BITMAPINFO));
+  bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
+  bmi.bmiHeader.biPlanes = 1;
+  bmi.bmiHeader.biBitCount = 32;
+  bmi.bmiHeader.biCompression = BI_RGB;
+  bmi.bmiHeader.biWidth = width;
+  bmi.bmiHeader.biHeight = -height;  //GDI stores bitmaps upside now; negative height flips bitmap
+  bmi.bmiHeader.biSizeImage = width * height * sizeof(uint32_t);
+  void* bits = nullptr;
+  HBITMAP bitmap = CreateDIBSection(hdc, &bmi, DIB_RGB_COLORS, &bits, NULL, 0);
+  if(bits) memcpy(bits, data, width * height * sizeof(uint32_t));
+  SelectObject(hdc, bitmap);
+
+  BLENDFUNCTION bf;
+  bf.BlendOp = AC_SRC_OVER;
+  bf.BlendFlags = 0;
+  bf.SourceConstantAlpha = 255;
+  bf.AlphaFormat = AC_SRC_ALPHA;
+
+  RECT rc;
+  GetClientRect(hwnd, &rc);
+  DrawThemeParentBackground(hwnd, ps.hdc, &rc);
+  AlphaBlend(ps.hdc, 0, 0, width, height, hdc, 0, 0, width, height, bf);
+
+  DeleteObject(bitmap);
+  DeleteDC(hdc);
+
+  EndPaint(hwnd, &ps);
+}
+
+void pCanvas::rasterize() {
+  unsigned width = canvas.state.width;
+  unsigned height = canvas.state.height;
+  if(width == 0) width = widget.state.geometry.width;
+  if(height == 0) height = widget.state.geometry.height;
+
+  if(width != surfaceWidth || height != surfaceHeight) release();
+  if(!surface) surface = new uint32_t[width * height];
+
+  if(canvas.state.mode == Canvas::Mode::Color) {
+    nall::image image;
+    image.allocate(width, height);
+    image.fill(canvas.state.color.argb());
+    memcpy(surface, image.data(), image.size());
+  }
+
+  if(canvas.state.mode == Canvas::Mode::Gradient) {
+    nall::image image;
+    image.allocate(width, height);
+    image.gradient(
+      canvas.state.gradient[0].argb(), canvas.state.gradient[1].argb(), canvas.state.gradient[2].argb(), canvas.state.gradient[3].argb()
+    );
+    memcpy(surface, image.data(), image.size());
+  }
+
+  if(canvas.state.mode == Canvas::Mode::Image) {
+    nall::image image = canvas.state.image;
+    image.scale(width, height);
+    image.transform(0, 32, 255u << 24, 255u << 16, 255u << 8, 255u << 0);
+    memcpy(surface, image.data(), image.size());
+  }
+
+  if(canvas.state.mode == Canvas::Mode::Data) {
+    if(width == canvas.state.width && height == canvas.state.height) {
+      memcpy(surface, canvas.state.data, width * height * sizeof(uint32_t));
+    } else {
+      memset(surface, 0x00, width * height * sizeof(uint32_t));
+    }
+  }
+
+  surfaceWidth = width;
+  surfaceHeight = height;
+}
+
+void pCanvas::redraw() {
+  InvalidateRect(hwnd, 0, false);
+}
+
+void pCanvas::release() {
+  if(surface) {
+    delete[] surface;
+    surface = nullptr;
+    surfaceWidth = 0;
+    surfaceHeight = 0;
+  }
+}
+
+}
diff -Nru higan/phoenix/windows/widget/check-button.cpp nSide/phoenix/windows/widget/check-button.cpp
--- higan/phoenix/windows/widget/check-button.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/windows/widget/check-button.cpp	2015-09-16 13:08:13.572563370 +0900
@@ -0,0 +1,84 @@
+namespace phoenix {
+
+Size pCheckButton::minimumSize() {
+  Size size = pFont::size(hfont, checkButton.state.text);
+
+  if(checkButton.state.orientation == Orientation::Horizontal) {
+    size.width += checkButton.state.image.width();
+    size.height = max(checkButton.state.image.height(), size.height);
+  }
+
+  if(checkButton.state.orientation == Orientation::Vertical) {
+    size.width = max(checkButton.state.image.width(), size.width);
+    size.height += checkButton.state.image.height();
+  }
+
+  return {size.width + 20, size.height + 10};
+}
+
+void pCheckButton::setChecked(bool checked) {
+  SendMessage(hwnd, BM_SETCHECK, (WPARAM)checked, 0);
+}
+
+void pCheckButton::setImage(const image& image, Orientation orientation) {
+  nall::image nallImage = image;
+  nallImage.transform(0, 32, 255u << 24, 255u << 16, 255u << 8, 255u << 0);
+
+  if(hbitmap) { DeleteObject(hbitmap); hbitmap = 0; }
+  if(himagelist) { ImageList_Destroy(himagelist); himagelist = 0; }
+
+  if(OsVersion() < WindowsVista) nallImage.alphaBlend(GetSysColor(COLOR_BTNFACE));
+  hbitmap = CreateBitmap(nallImage);
+  himagelist = ImageList_Create(nallImage.width(), nallImage.height(), ILC_COLOR32, 1, 0);
+  ImageList_Add(himagelist, hbitmap, NULL);
+  BUTTON_IMAGELIST list;
+  list.himl = himagelist;
+  switch(orientation) {
+  case Orientation::Horizontal: SetRect(&list.margin, 5, 0, 0, 0); list.uAlign = BUTTON_IMAGELIST_ALIGN_LEFT; break;
+  case Orientation::Vertical:   SetRect(&list.margin, 0, 5, 0, 0); list.uAlign = BUTTON_IMAGELIST_ALIGN_TOP;  break;
+  }
+  Button_SetImageList(hwnd, &list);
+
+  setText(checkButton.state.text);
+}
+
+void pCheckButton::setText(string text) {
+  if(text.empty()) {
+    SetWindowLongPtr(hwnd, GWL_STYLE, GetWindowLongPtr(hwnd, GWL_STYLE) |  BS_BITMAP);
+  } else {
+    SetWindowLongPtr(hwnd, GWL_STYLE, GetWindowLongPtr(hwnd, GWL_STYLE) & ~BS_BITMAP);
+  }
+
+  SetWindowText(hwnd, utf16_t(text));
+}
+
+void pCheckButton::constructor() {
+  hwnd = CreateWindow(L"BUTTON", L"",
+    WS_CHILD | WS_TABSTOP | BS_CHECKBOX | BS_PUSHLIKE,
+    0, 0, 0, 0, parentHwnd, (HMENU)id, GetModuleHandle(0), 0);
+  SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)&checkButton);
+  setDefaultFont();
+  setChecked(checkButton.state.checked);
+  setImage(checkButton.state.image, checkButton.state.orientation);
+//setText(checkButton.state.text);
+  synchronize();
+}
+
+void pCheckButton::destructor() {
+  if(hbitmap) { DeleteObject(hbitmap); hbitmap = 0; }
+  if(himagelist) { ImageList_Destroy(himagelist); himagelist = 0; }
+  DestroyWindow(hwnd);
+}
+
+void pCheckButton::orphan() {
+  destructor();
+  constructor();
+}
+
+void pCheckButton::onToggle() {
+  checkButton.state.checked = !checkButton.state.checked;
+  setChecked(checkButton.state.checked);
+  if(checkButton.onToggle) checkButton.onToggle();
+}
+
+}
diff -Nru higan/phoenix/windows/widget/check-label.cpp nSide/phoenix/windows/widget/check-label.cpp
--- higan/phoenix/windows/widget/check-label.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/windows/widget/check-label.cpp	2015-09-16 13:08:13.572563370 +0900
@@ -0,0 +1,44 @@
+namespace phoenix {
+
+Size pCheckLabel::minimumSize() {
+  Size size = pFont::size(hfont, checkLabel.state.text);
+  return {size.width + 20, size.height + 4};
+}
+
+void pCheckLabel::setChecked(bool checked) {
+  SendMessage(hwnd, BM_SETCHECK, (WPARAM)checked, 0);
+}
+
+void pCheckLabel::setText(string text) {
+  SetWindowText(hwnd, utf16_t(text));
+}
+
+void pCheckLabel::constructor() {
+  hwnd = CreateWindow(
+    L"BUTTON", L"",
+    WS_CHILD | WS_TABSTOP | BS_CHECKBOX,
+    0, 0, 0, 0, parentHwnd, (HMENU)id, GetModuleHandle(0), 0
+  );
+  SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)&checkLabel);
+  setDefaultFont();
+  setChecked(checkLabel.state.checked);
+  setText(checkLabel.state.text);
+  synchronize();
+}
+
+void pCheckLabel::destructor() {
+  DestroyWindow(hwnd);
+}
+
+void pCheckLabel::orphan() {
+  destructor();
+  constructor();
+}
+
+void pCheckLabel::onToggle() {
+  checkLabel.state.checked = !checkLabel.state.checked;
+  setChecked(checkLabel.state.checked);
+  if(checkLabel.onToggle) checkLabel.onToggle();
+}
+
+}
diff -Nru higan/phoenix/windows/widget/combo-button.cpp nSide/phoenix/windows/widget/combo-button.cpp
--- higan/phoenix/windows/widget/combo-button.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/windows/widget/combo-button.cpp	2015-09-16 13:08:13.572563370 +0900
@@ -0,0 +1,77 @@
+namespace phoenix {
+
+void pComboButton::append(string text) {
+  SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)(wchar_t*)utf16_t(text));
+  if(SendMessage(hwnd, CB_GETCOUNT, 0, 0) == 1) setSelection(0);
+}
+
+Size pComboButton::minimumSize() {
+  unsigned maximumWidth = 0;
+  for(auto& text : comboButton.state.text) maximumWidth = max(maximumWidth, pFont::size(hfont, text).width);
+  return {maximumWidth + 24, pFont::size(hfont, " ").height + 10};
+}
+
+void pComboButton::remove(unsigned selection) {
+  locked = true;
+  SendMessage(hwnd, CB_DELETESTRING, selection, 0);
+  locked = false;
+
+  if(selection == comboButton.state.selection) comboButton.setSelection(0);
+}
+
+void pComboButton::reset() {
+  SendMessage(hwnd, CB_RESETCONTENT, 0, 0);
+}
+
+void pComboButton::setGeometry(Geometry geometry) {
+  //height = minimum drop-down list height; use CB_SETITEMHEIGHT to control actual widget height
+  pWidget::setGeometry({geometry.x, geometry.y, geometry.width, 1});
+  RECT rc;
+  GetWindowRect(hwnd, &rc);
+  unsigned adjustedHeight = geometry.height - ((rc.bottom - rc.top) - SendMessage(hwnd, CB_GETITEMHEIGHT, (WPARAM)-1, 0));
+  SendMessage(hwnd, CB_SETITEMHEIGHT, (WPARAM)-1, adjustedHeight);
+}
+
+void pComboButton::setSelection(unsigned selection) {
+  SendMessage(hwnd, CB_SETCURSEL, selection, 0);
+}
+
+void pComboButton::setText(unsigned selection, string text) {
+  locked = true;
+  SendMessage(hwnd, CB_DELETESTRING, selection, 0);
+  SendMessage(hwnd, CB_INSERTSTRING, selection, (LPARAM)(wchar_t*)utf16_t(text));
+  setSelection(comboButton.state.selection);
+  locked = false;
+}
+
+void pComboButton::constructor() {
+  hwnd = CreateWindow(
+    L"COMBOBOX", L"",
+    WS_CHILD | WS_TABSTOP | CBS_DROPDOWNLIST | CBS_HASSTRINGS,
+    0, 0, 0, 0,
+    parentHwnd, (HMENU)id, GetModuleHandle(0), 0
+  );
+  SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)&comboButton);
+  setDefaultFont();
+  for(auto& text : comboButton.state.text) append(text);
+  setSelection(comboButton.state.selection);
+  synchronize();
+}
+
+void pComboButton::destructor() {
+  DestroyWindow(hwnd);
+}
+
+void pComboButton::orphan() {
+  destructor();
+  constructor();
+}
+
+void pComboButton::onChange() {
+  unsigned selection = SendMessage(hwnd, CB_GETCURSEL, 0, 0);
+  if(selection == comboButton.state.selection) return;
+  comboButton.state.selection = selection;
+  if(comboButton.onChange) comboButton.onChange();
+}
+
+}
diff -Nru higan/phoenix/windows/widget/console.cpp nSide/phoenix/windows/widget/console.cpp
--- higan/phoenix/windows/widget/console.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/windows/widget/console.cpp	2015-09-16 13:08:13.573563370 +0900
@@ -0,0 +1,56 @@
+namespace phoenix {
+
+static LRESULT CALLBACK Console_windowProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam) {
+  Console& console = *(Console*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
+  if(msg == WM_CHAR) {
+    if(console.p.keyPress(wparam)) return 0;
+  }
+  return console.p.windowProc(hwnd, msg, wparam, lparam);
+}
+
+void pConsole::print(string text) {
+}
+
+void pConsole::reset() {
+}
+
+void pConsole::setBackgroundColor(Color color) {
+  if(backgroundBrush) DeleteObject(backgroundBrush);
+  backgroundBrush = CreateSolidBrush(RGB(color.red, color.green, color.blue));
+}
+
+void pConsole::setForegroundColor(Color color) {
+}
+
+void pConsole::setPrompt(string prompt) {
+}
+
+void pConsole::constructor() {
+  hwnd = CreateWindowEx(
+    WS_EX_CLIENTEDGE, L"EDIT", L"",
+    WS_CHILD | WS_TABSTOP | ES_READONLY | ES_MULTILINE | ES_WANTRETURN,
+    0, 0, 0, 0, parentHwnd, (HMENU)id, GetModuleHandle(0), 0
+  );
+  SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)&console);
+  setDefaultFont();
+  setBackgroundColor(console.state.backgroundColor);
+
+  windowProc = (LRESULT CALLBACK (*)(HWND, UINT, LPARAM, WPARAM))GetWindowLongPtr(hwnd, GWLP_WNDPROC);
+  SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR)Console_windowProc);
+  synchronize();
+}
+
+void pConsole::destructor() {
+  DestroyWindow(hwnd);
+}
+
+void pConsole::orphan() {
+  destructor();
+  constructor();
+}
+
+bool pConsole::keyPress(unsigned scancode) {
+  return false;
+}
+
+}
diff -Nru higan/phoenix/windows/widget/frame.cpp nSide/phoenix/windows/widget/frame.cpp
--- higan/phoenix/windows/widget/frame.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/windows/widget/frame.cpp	2015-09-16 13:08:13.572563370 +0900
@@ -0,0 +1,50 @@
+namespace phoenix {
+
+void pFrame::setEnabled(bool enabled) {
+  if(frame.state.layout) frame.state.layout->setEnabled(frame.state.layout->enabled());
+  pWidget::setEnabled(enabled);
+}
+
+void pFrame::setGeometry(Geometry geometry) {
+  bool empty = frame.state.text.empty();
+  Size size = pFont::size(hfont, frame.state.text);
+  pWidget::setGeometry({
+    geometry.x, geometry.y - (empty ? size.height >> 1 : 0),
+    geometry.width, geometry.height + (empty ? size.height >> 1 : 0)
+  });
+  if(frame.state.layout == nullptr) return;
+  if(empty) size.height = 1;
+  geometry.x += 1, geometry.width -= 2;
+  geometry.y += size.height, geometry.height -= size.height + 2;
+  frame.state.layout->setGeometry(geometry);
+}
+
+void pFrame::setText(string text) {
+  SetWindowText(hwnd, utf16_t(text));
+}
+
+void pFrame::setVisible(bool visible) {
+  if(frame.state.layout) frame.state.layout->setVisible(frame.state.layout->visible());
+  pWidget::setVisible(visible);
+}
+
+void pFrame::constructor() {
+  hwnd = CreateWindow(L"BUTTON", L"",
+    WS_CHILD | BS_GROUPBOX,
+    0, 0, 0, 0, parentHwnd, (HMENU)id, GetModuleHandle(0), 0);
+  SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)&frame);
+  setDefaultFont();
+  setText(frame.state.text);
+  synchronize();
+}
+
+void pFrame::destructor() {
+  DestroyWindow(hwnd);
+}
+
+void pFrame::orphan() {
+  destructor();
+  constructor();
+}
+
+}
diff -Nru higan/phoenix/windows/widget/hex-edit.cpp nSide/phoenix/windows/widget/hex-edit.cpp
--- higan/phoenix/windows/widget/hex-edit.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/windows/widget/hex-edit.cpp	2015-09-16 13:08:13.576563370 +0900
@@ -0,0 +1,258 @@
+namespace phoenix {
+
+static LRESULT CALLBACK HexEdit_windowProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam) {
+  HexEdit& hexEdit = *(HexEdit*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
+
+  switch(msg) {
+  case WM_KEYDOWN:
+    if(hexEdit.p.keyPress(wparam)) return 0;
+    break;
+
+  case WM_MOUSEWHEEL: {
+    signed offset = -((int16_t)HIWORD(wparam) / WHEEL_DELTA);
+    hexEdit.p.scrollTo(hexEdit.p.scrollPosition() + offset);
+    return true;
+  }
+
+  case WM_SIZE: {
+    RECT rc;
+    GetClientRect(hexEdit.p.hwnd, &rc);
+    SetWindowPos(hexEdit.p.scrollBar, HWND_TOP, rc.right - 18, 0, 18, rc.bottom, SWP_SHOWWINDOW);
+    break;
+  }
+
+  case WM_VSCROLL: {
+    SCROLLINFO info;
+    memset(&info, 0, sizeof(SCROLLINFO));
+    info.cbSize = sizeof(SCROLLINFO);
+    info.fMask = SIF_ALL;
+    GetScrollInfo((HWND)lparam, SB_CTL, &info);
+    switch(LOWORD(wparam)) {
+    case SB_LEFT: info.nPos = info.nMin; break;
+    case SB_RIGHT: info.nPos = info.nMax; break;
+    case SB_LINELEFT: info.nPos--; break;
+    case SB_LINERIGHT: info.nPos++; break;
+    case SB_PAGELEFT: info.nPos -= info.nMax >> 3; break;
+    case SB_PAGERIGHT: info.nPos += info.nMax >> 3; break;
+    case SB_THUMBTRACK: info.nPos = info.nTrackPos; break;
+    }
+
+    info.fMask = SIF_POS;
+    SetScrollInfo((HWND)lparam, SB_CTL, &info, TRUE);
+    GetScrollInfo((HWND)lparam, SB_CTL, &info);  //get clamped position
+
+    hexEdit.p.scrollTo(info.nPos);
+    return TRUE;
+  }
+  }
+
+  return hexEdit.p.windowProc(hwnd, msg, wparam, lparam);
+}
+
+void pHexEdit::setBackgroundColor(Color color) {
+  if(backgroundBrush) DeleteObject(backgroundBrush);
+  backgroundBrush = CreateSolidBrush(RGB(color.red, color.green, color.blue));
+}
+
+void pHexEdit::setColumns(unsigned columns) {
+  update();
+}
+
+void pHexEdit::setForegroundColor(Color color) {
+}
+
+void pHexEdit::setLength(unsigned length) {
+  SetScrollRange(scrollBar, SB_CTL, 0, rowsScrollable(), TRUE);
+  EnableWindow(scrollBar, rowsScrollable() > 0);
+  update();
+}
+
+void pHexEdit::setOffset(unsigned offset) {
+  SetScrollPos(scrollBar, SB_CTL, offset / hexEdit.state.columns, TRUE);
+  update();
+}
+
+void pHexEdit::setRows(unsigned rows) {
+  update();
+}
+
+void pHexEdit::update() {
+  if(!hexEdit.onRead) {
+    SetWindowText(hwnd, L"");
+    return;
+  }
+
+  unsigned cursorPosition = Edit_GetSel(hwnd);
+
+  string output;
+  unsigned offset = hexEdit.state.offset;
+  for(unsigned row = 0; row < hexEdit.state.rows; row++) {
+    output.append(hex(offset, 8L));
+    output.append("  ");
+
+    string hexdata;
+    string ansidata = " ";
+    for(unsigned column = 0; column < hexEdit.state.columns; column++) {
+      if(offset < hexEdit.state.length) {
+        uint8_t data = hexEdit.onRead(offset++);
+        hexdata.append(hex(data, 2L));
+        hexdata.append(" ");
+        ansidata.append(data >= 0x20 && data <= 0x7e ? (char)data : '.');
+      } else {
+        hexdata.append("   ");
+        ansidata.append(" ");
+      }
+    }
+
+    output.append(hexdata);
+    output.append(ansidata);
+    if(offset >= hexEdit.state.length) break;
+    if(row != hexEdit.state.rows - 1) output.append("\r\n");
+  }
+
+  SetWindowText(hwnd, utf16_t(output));
+  Edit_SetSel(hwnd, LOWORD(cursorPosition), HIWORD(cursorPosition));
+}
+
+void pHexEdit::constructor() {
+  hwnd = CreateWindowEx(
+    WS_EX_CLIENTEDGE, L"EDIT", L"",
+    WS_CHILD | WS_TABSTOP | ES_AUTOHSCROLL | ES_READONLY | ES_MULTILINE | ES_WANTRETURN,
+    0, 0, 0, 0, parentHwnd, (HMENU)id, GetModuleHandle(0), 0
+  );
+  SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)&hexEdit);
+
+  scrollBar = CreateWindowEx(
+    0, L"SCROLLBAR", L"",
+    WS_VISIBLE | WS_CHILD | SBS_VERT,
+    0, 0, 0, 0, hwnd, (HMENU)id, GetModuleHandle(0), 0
+  );
+  SetWindowLongPtr(scrollBar, GWLP_USERDATA, (LONG_PTR)&hexEdit);
+
+  windowProc = (WindowProc)GetWindowLongPtr(hwnd, GWLP_WNDPROC);
+  SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR)HexEdit_windowProc);
+
+  setDefaultFont();
+  setBackgroundColor(hexEdit.state.backgroundColor);
+  setLength(hexEdit.state.length);
+  setOffset(hexEdit.state.offset);
+  update();
+  PostMessage(hwnd, EM_SETSEL, 10, 10);
+
+  synchronize();
+}
+
+void pHexEdit::destructor() {
+  DestroyWindow(hwnd);
+}
+
+void pHexEdit::orphan() {
+  destructor();
+  constructor();
+}
+
+bool pHexEdit::keyPress(unsigned scancode) {
+  if(!hexEdit.onRead) return false;
+
+  signed position = LOWORD(Edit_GetSel(hwnd));
+  signed lineWidth = 10 + (hexEdit.state.columns * 3) + 1 + hexEdit.state.columns + 2;
+  signed cursorY = position / lineWidth;
+  signed cursorX = position % lineWidth;
+
+  if(scancode == VK_HOME) {
+    signed offset = cursorY * lineWidth + 10;
+    Edit_SetSel(hwnd, offset, offset);
+    return true;
+  }
+
+  if(scancode == VK_END) {
+    signed offset = cursorY * lineWidth + 57;
+    Edit_SetSel(hwnd, offset, offset);
+    return true;
+  }
+
+  if(scancode == VK_UP) {
+    if(cursorY > 0) return false;
+    scrollTo(scrollPosition() - 1);
+    return true;
+  }
+
+  if(scancode == VK_DOWN) {
+    if(cursorY >= rows() - 1) return true;
+    if(cursorY < hexEdit.state.rows - 1) return false;
+    scrollTo(scrollPosition() + 1);
+    return true;
+  }
+
+  if(scancode == VK_PRIOR) {
+    scrollTo(scrollPosition() - hexEdit.state.rows);
+    return true;
+  }
+
+  if(scancode == VK_NEXT) {
+    scrollTo(scrollPosition() + hexEdit.state.rows);
+    return true;
+  }
+
+  //convert scancode to hex nibble
+       if(scancode >= '0' && scancode <= '9') scancode = scancode - '0';
+  else if(scancode >= 'A' && scancode <= 'F') scancode = scancode - 'A' + 10;
+  else if(scancode >= 'a' && scancode <= 'f') scancode = scancode - 'a' + 10;
+  else return false;
+
+  if(cursorX >= 10) {
+    //not on an offset
+    cursorX -= 10;
+    if((cursorX % 3) != 2) {
+      //not on a space
+      bool cursorNibble = (cursorX % 3) == 1;  //0 = high, 1 = low
+      cursorX /= 3;
+      if(cursorX < hexEdit.state.columns) {
+        //not in ANSI region
+        unsigned offset = hexEdit.state.offset + (cursorY * hexEdit.state.columns + cursorX);
+
+        if(offset >= hexEdit.state.length) return false;  //do not edit past end of data
+        uint8_t data = hexEdit.onRead(offset);
+
+        //write modified value
+        if(cursorNibble == 1) {
+          data = (data & 0xf0) | (scancode << 0);
+        } else {
+          data = (data & 0x0f) | (scancode << 4);
+        }
+        if(hexEdit.onWrite) hexEdit.onWrite(offset, data);
+
+        //auto-advance cursor to next nibble or byte
+        position++;
+        if(cursorNibble && cursorX != hexEdit.state.columns - 1) position++;
+        Edit_SetSel(hwnd, position, position);
+
+        //refresh output to reflect modified data
+        update();
+      }
+    }
+  }
+
+  return true;
+}
+
+signed pHexEdit::rows() {
+  return (max(1u, hexEdit.state.length) + hexEdit.state.columns - 1) / hexEdit.state.columns;
+}
+
+signed pHexEdit::rowsScrollable() {
+  return max(0u, rows() - hexEdit.state.rows);
+}
+
+signed pHexEdit::scrollPosition() {
+  return hexEdit.state.offset / hexEdit.state.columns;
+}
+
+void pHexEdit::scrollTo(signed position) {
+  if(position > rowsScrollable()) position = rowsScrollable();
+  if(position < 0) position = 0;
+  if(position == scrollPosition()) return;
+  hexEdit.setOffset(position * hexEdit.state.columns);
+}
+
+}
diff -Nru higan/phoenix/windows/widget/horizontal-scroller.cpp nSide/phoenix/windows/widget/horizontal-scroller.cpp
--- higan/phoenix/windows/widget/horizontal-scroller.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/windows/widget/horizontal-scroller.cpp	2015-09-16 13:08:13.574563370 +0900
@@ -0,0 +1,45 @@
+namespace phoenix {
+
+Size pHorizontalScroller::minimumSize() {
+  return {0, 18};
+}
+
+void pHorizontalScroller::setLength(unsigned length) {
+  length += (length == 0);
+  SetScrollRange(hwnd, SB_CTL, 0, length - 1, TRUE);
+  horizontalScroller.setPosition(0);
+}
+
+void pHorizontalScroller::setPosition(unsigned position) {
+  SetScrollPos(hwnd, SB_CTL, position, TRUE);
+}
+
+void pHorizontalScroller::constructor() {
+  hwnd = CreateWindow(
+    L"SCROLLBAR", L"", WS_CHILD | WS_TABSTOP | SBS_HORZ,
+    0, 0, 0, 0, parentHwnd, (HMENU)id, GetModuleHandle(0), 0
+  );
+  SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)&horizontalScroller);
+  unsigned position = horizontalScroller.state.position;
+  setLength(horizontalScroller.state.length);
+  horizontalScroller.setPosition(position);
+  synchronize();
+}
+
+void pHorizontalScroller::destructor() {
+  DestroyWindow(hwnd);
+}
+
+void pHorizontalScroller::orphan() {
+  destructor();
+  constructor();
+}
+
+void pHorizontalScroller::onChange(WPARAM wparam) {
+  unsigned position = ScrollEvent(hwnd, wparam);
+  if(position == horizontalScroller.state.position) return;
+  horizontalScroller.state.position = position;
+  if(horizontalScroller.onChange) horizontalScroller.onChange();
+}
+
+}
diff -Nru higan/phoenix/windows/widget/horizontal-slider.cpp nSide/phoenix/windows/widget/horizontal-slider.cpp
--- higan/phoenix/windows/widget/horizontal-slider.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/windows/widget/horizontal-slider.cpp	2015-09-16 13:08:13.571563369 +0900
@@ -0,0 +1,47 @@
+namespace phoenix {
+
+Size pHorizontalSlider::minimumSize() {
+  return {0, 25};
+}
+
+void pHorizontalSlider::setLength(unsigned length) {
+  length += (length == 0);
+  SendMessage(hwnd, TBM_SETRANGE, (WPARAM)true, (LPARAM)MAKELONG(0, length - 1));
+  SendMessage(hwnd, TBM_SETPAGESIZE, 0, (LPARAM)(length >> 3));
+  horizontalSlider.setPosition(0);
+}
+
+void pHorizontalSlider::setPosition(unsigned position) {
+  SendMessage(hwnd, TBM_SETPOS, (WPARAM)true, (LPARAM)position);
+}
+
+void pHorizontalSlider::constructor() {
+  hwnd = CreateWindow(
+    TRACKBAR_CLASS, L"", WS_CHILD | WS_TABSTOP | TBS_TRANSPARENTBKGND | TBS_NOTICKS | TBS_BOTH | TBS_HORZ,
+    0, 0, 0, 0, parentHwnd, (HMENU)id, GetModuleHandle(0), 0
+  );
+  SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)&horizontalSlider);
+
+  unsigned position = horizontalSlider.state.position;
+  setLength(horizontalSlider.state.length);
+  horizontalSlider.setPosition(position);
+  synchronize();
+}
+
+void pHorizontalSlider::destructor() {
+  DestroyWindow(hwnd);
+}
+
+void pHorizontalSlider::orphan() {
+  destructor();
+  constructor();
+}
+
+void pHorizontalSlider::onChange() {
+  unsigned position = SendMessage(hwnd, TBM_GETPOS, 0, 0);
+  if(position == horizontalSlider.state.position) return;
+  horizontalSlider.state.position = position;
+  if(horizontalSlider.onChange) horizontalSlider.onChange();
+}
+
+}
diff -Nru higan/phoenix/windows/widget/label.cpp nSide/phoenix/windows/widget/label.cpp
--- higan/phoenix/windows/widget/label.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/windows/widget/label.cpp	2015-09-16 13:08:13.574563370 +0900
@@ -0,0 +1,68 @@
+namespace phoenix {
+
+Size pLabel::minimumSize() {
+  Size size = pFont::size(hfont, label.state.text);
+  return {size.width, size.height};
+}
+
+void pLabel::setText(string text) {
+  SetWindowText(hwnd, utf16_t(text));
+  InvalidateRect(hwnd, 0, false);
+}
+
+void pLabel::constructor() {
+  hwnd = CreateWindow(L"phoenix_label", L"",
+    WS_CHILD,
+    0, 0, 0, 0, parentHwnd, (HMENU)id, GetModuleHandle(0), 0);
+  SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)&label);
+  setDefaultFont();
+  setText(label.state.text);
+  synchronize();
+}
+
+void pLabel::destructor() {
+  DestroyWindow(hwnd);
+}
+
+void pLabel::orphan() {
+  destructor();
+  constructor();
+}
+
+static LRESULT CALLBACK Label_windowProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam) {
+  HWND parentHwnd = GetParent(hwnd);
+  Label* label = (Label*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
+  if(label == nullptr) return DefWindowProc(hwnd, msg, wparam, lparam);
+  Window* window = (Window*)label->Sizable::state.window;
+  if(window == nullptr) return DefWindowProc(hwnd, msg, wparam, lparam);
+
+  switch(msg) {
+  case WM_GETDLGCODE: return DLGC_STATIC | DLGC_WANTCHARS;
+  case WM_ERASEBKGND: return TRUE;
+  case WM_PAINT: {
+    PAINTSTRUCT ps;
+    BeginPaint(hwnd, &ps);
+    RECT rc;
+    GetClientRect(hwnd, &rc);
+    DrawThemeParentBackground(hwnd, ps.hdc, &rc);
+    SetBkMode(ps.hdc, TRANSPARENT);
+    SelectObject(ps.hdc, ((Widget*)label)->p.hfont);
+    unsigned length = GetWindowTextLength(hwnd);
+    wchar_t text[length + 1];
+    GetWindowText(hwnd, text, length + 1);
+    text[length] = 0;
+    DrawText(ps.hdc, text, -1, &rc, DT_CALCRECT | DT_END_ELLIPSIS);
+    unsigned height = rc.bottom;
+    GetClientRect(hwnd, &rc);
+    rc.top = (rc.bottom - height) / 2;
+    rc.bottom = rc.top + height;
+    DrawText(ps.hdc, text, -1, &rc, DT_LEFT | DT_END_ELLIPSIS);
+    EndPaint(hwnd, &ps);
+    return FALSE;
+  }
+  }
+
+  return DefWindowProc(hwnd, msg, wparam, lparam);
+}
+
+}
diff -Nru higan/phoenix/windows/widget/line-edit.cpp nSide/phoenix/windows/widget/line-edit.cpp
--- higan/phoenix/windows/widget/line-edit.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/windows/widget/line-edit.cpp	2015-09-16 13:08:13.574563370 +0900
@@ -0,0 +1,63 @@
+namespace phoenix {
+
+Size pLineEdit::minimumSize() {
+  Size size = pFont::size(hfont, lineEdit.state.text);
+  return {size.width + 12, size.height + 10};
+}
+
+void pLineEdit::setBackgroundColor(Color color) {
+  if(backgroundBrush) DeleteObject(backgroundBrush);
+  backgroundBrush = CreateSolidBrush(RGB(color.red, color.green, color.blue));
+}
+
+void pLineEdit::setEditable(bool editable) {
+  SendMessage(hwnd, EM_SETREADONLY, editable == false, 0);
+}
+
+void pLineEdit::setForegroundColor(Color color) {
+}
+
+void pLineEdit::setText(string text) {
+  locked = true;
+  SetWindowText(hwnd, utf16_t(text));
+  locked = false;
+}
+
+string pLineEdit::text() {
+  unsigned length = GetWindowTextLength(hwnd);
+  wchar_t text[length + 1];
+  GetWindowText(hwnd, text, length + 1);
+  text[length] = 0;
+  return (const char*)utf8_t(text);
+}
+
+void pLineEdit::constructor() {
+  hwnd = CreateWindowEx(
+    WS_EX_CLIENTEDGE, L"EDIT", L"",
+    WS_CHILD | WS_TABSTOP | ES_AUTOHSCROLL | ES_AUTOVSCROLL,
+    0, 0, 0, 0, parentHwnd, (HMENU)id, GetModuleHandle(0), 0
+  );
+  SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)&lineEdit);
+  setDefaultFont();
+  setBackgroundColor(lineEdit.state.backgroundColor);
+  setEditable(lineEdit.state.editable);
+  setText(lineEdit.state.text);
+  synchronize();
+}
+
+void pLineEdit::destructor() {
+  lineEdit.state.text = text();
+  DestroyWindow(hwnd);
+}
+
+void pLineEdit::orphan() {
+  destructor();
+  constructor();
+}
+
+void pLineEdit::onChange() {
+  if(locked) return;
+  if(lineEdit.onChange) lineEdit.onChange();
+}
+
+}
diff -Nru higan/phoenix/windows/widget/list-view.cpp nSide/phoenix/windows/widget/list-view.cpp
--- higan/phoenix/windows/widget/list-view.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/windows/widget/list-view.cpp	2015-09-16 13:08:13.573563370 +0900
@@ -0,0 +1,288 @@
+namespace phoenix {
+
+unsigned ListView_GetColumnCount(HWND hwnd) {
+  unsigned count = 0;
+  LVCOLUMN column;
+  column.mask = LVCF_WIDTH;
+  while(ListView_GetColumn(hwnd, count++, &column));
+  return --count;
+}
+
+void ListView_SetImage(HWND hwnd, HIMAGELIST imageList, unsigned row, unsigned column, unsigned imageID) {
+  //if this is the first image assigned, set image list now
+  //do not set sooner, or image blocks will appear in a list with no images
+  if(ListView_GetImageList(hwnd, LVSIL_SMALL) != imageList) {
+    ListView_SetImageList(hwnd, imageList, LVSIL_SMALL);
+  }
+
+  LVITEM item;
+  item.mask = LVIF_IMAGE;
+  item.iItem = row;
+  item.iSubItem = column;
+  item.iImage = imageID;
+  ListView_SetItem(hwnd, &item);
+}
+
+void pListView::append(const lstring& list) {
+  wchar_t empty[] = L"";
+  unsigned row = ListView_GetItemCount(hwnd);
+  LVITEM item;
+  item.mask = LVIF_TEXT;
+  item.iItem = row;
+  item.iSubItem = 0;
+  item.pszText = empty;
+  locked = true;
+  ListView_InsertItem(hwnd, &item);
+  locked = false;
+  for(unsigned column = 0; column < list.size(); column++) {
+    utf16_t wtext(list(column, ""));
+    ListView_SetItemText(hwnd, row, column, wtext);
+  }
+}
+
+void pListView::autoSizeColumns() {
+  unsigned columns = ListView_GetColumnCount(hwnd);
+  for(unsigned n = 0; n < columns; n++) {
+    ListView_SetColumnWidth(hwnd, n, LVSCW_AUTOSIZE_USEHEADER);
+  }
+}
+
+void pListView::remove(unsigned selection) {
+  ListView_DeleteItem(hwnd, selection);
+}
+
+void pListView::reset() {
+  ListView_DeleteAllItems(hwnd);
+  buildImageList();  //free previously allocated images
+}
+
+void pListView::setBackgroundColor(Color color) {
+  ListView_SetBkColor(hwnd, RGB(color.red, color.green, color.blue));
+}
+
+void pListView::setCheckable(bool checkable) {
+  ListView_SetExtendedListViewStyle(hwnd, LVS_EX_FULLROWSELECT | LVS_EX_SUBITEMIMAGES | (checkable ? LVS_EX_CHECKBOXES : 0));
+}
+
+void pListView::setChecked(unsigned selection, bool checked) {
+  locked = true;
+  ListView_SetCheckState(hwnd, selection, checked);
+  locked = false;
+}
+
+void pListView::setForegroundColor(Color color) {
+}
+
+void pListView::setGeometry(Geometry geometry) {
+  pWidget::setGeometry(geometry);
+  autoSizeColumns();
+}
+
+void pListView::setHeaderText(const lstring& list) {
+  while(ListView_DeleteColumn(hwnd, 0));
+
+  lstring headers = list;
+  if(headers.size() == 0) headers.append("");  //must have at least one column
+
+  for(unsigned n = 0; n < headers.size(); n++) {
+    LVCOLUMN column;
+    column.mask = LVCF_FMT | LVCF_TEXT | LVCF_SUBITEM;
+    column.fmt = LVCFMT_LEFT;
+    column.iSubItem = n;
+    utf16_t headerText(headers[n]);
+    column.pszText = headerText;
+    ListView_InsertColumn(hwnd, n, &column);
+  }
+  autoSizeColumns();
+}
+
+void pListView::setHeaderVisible(bool visible) {
+  SetWindowLong(
+    hwnd, GWL_STYLE,
+    (GetWindowLong(hwnd, GWL_STYLE) & ~LVS_NOCOLUMNHEADER) |
+    (visible ? 0 : LVS_NOCOLUMNHEADER)
+  );
+}
+
+void pListView::setImage(unsigned selection, unsigned position, const image& image) {
+  //assign existing image
+  for(unsigned n = 0; n < images.size(); n++) {
+    if(images[n] == image) {
+      imageMap(selection)(position) = n;
+      return ListView_SetImage(hwnd, imageList, selection, position, n);
+    }
+  }
+
+  //append and assign new image
+  imageMap(selection)(position) = images.size();
+  images.append(image);
+  ImageList_Append(imageList, image, 15);
+  ListView_SetImage(hwnd, imageList, selection, position, imageMap(selection)(position));
+}
+
+void pListView::setSelected(bool selected) {
+  locked = true;
+  lostFocus = false;
+  if(selected == false) {
+    ListView_SetItemState(hwnd, -1, 0, LVIS_FOCUSED | LVIS_SELECTED);
+  } else {
+    setSelection(listView.state.selection);
+  }
+  locked = false;
+}
+
+void pListView::setSelection(unsigned selection) {
+  locked = true;
+  lostFocus = false;
+  ListView_SetItemState(hwnd, selection, LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);
+  locked = false;
+}
+
+void pListView::setText(unsigned selection, unsigned position, string text) {
+  utf16_t wtext(text);
+  ListView_SetItemText(hwnd, selection, position, wtext);
+}
+
+void pListView::constructor() {
+  lostFocus = false;
+  hwnd = CreateWindowEx(
+    WS_EX_CLIENTEDGE, WC_LISTVIEW, L"",
+    WS_CHILD | WS_TABSTOP | LVS_REPORT | LVS_SINGLESEL | LVS_SHOWSELALWAYS | LVS_NOSORTHEADER | LVS_NOCOLUMNHEADER,
+    0, 0, 0, 0, parentHwnd, (HMENU)id, GetModuleHandle(0), 0
+  );
+  SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)&listView);
+  setDefaultFont();
+  setHeaderText(listView.state.headerText);
+  setBackgroundColor(listView.state.backgroundColor);
+  setHeaderVisible(listView.state.headerVisible);
+  setCheckable(listView.state.checkable);
+  for(auto& text : listView.state.text) append(text);
+  for(unsigned n = 0; n < listView.state.checked.size(); n++) setChecked(n, listView.state.checked[n]);
+  buildImageList();
+  if(listView.state.selected) setSelection(listView.state.selection);
+  autoSizeColumns();
+  synchronize();
+}
+
+void pListView::destructor() {
+  DestroyWindow(hwnd);
+}
+
+void pListView::orphan() {
+  destructor();
+  constructor();
+}
+
+void pListView::buildImageList() {
+  auto& list = listView.state.image;
+  unsigned columns = listView.state.text.size();
+  unsigned rows = max(1u, listView.state.headerText.size());
+
+  ListView_SetImageList(hwnd, NULL, LVSIL_SMALL);
+  if(imageList) ImageList_Destroy(imageList);
+  imageList = ImageList_Create(15, 15, ILC_COLOR32, 1, 0);
+
+  imageMap.reset();
+  images.reset();
+  images.append(nall::image());  //empty icon for cells without an image assigned (I_IMAGENONE does not work)
+
+  //create a vector of unique images from all images used (many cells may use the same image)
+  for(unsigned y = 0; y < list.size(); y++) {
+    for(unsigned x = 0; x < list[y].size(); x++) {
+      bool found = false;
+      for(unsigned z = 0; z < images.size(); z++) {
+        if(list[y][x] == images[z]) {
+          found = true;
+          imageMap(y)(x) = z;
+          break;
+        }
+      }
+
+      if(found == false) {
+        imageMap(y)(x) = images.size();
+        images.append(list[y][x]);
+      }
+    }
+  }
+
+  //build image list
+  for(auto& imageItem : images) ImageList_Append(imageList, imageItem, 15);
+  if(images.size() <= 1) return;
+
+  //set images for all cells
+  for(unsigned y = 0; y < columns; y++) {
+    for(unsigned x = 0; x < rows; x++) {
+      ListView_SetImage(hwnd, imageList, y, x, imageMap(y)(x));
+    }
+  }
+}
+
+void pListView::onActivate(LPARAM lparam) {
+  LPNMLISTVIEW nmlistview = (LPNMLISTVIEW)lparam;
+  if(listView.state.text.empty() || !listView.state.selected) return;
+//LVN_ITEMACTIVATE is not re-entrant until DispatchMessage() completes
+//if(listView.onActivate) listView.onActivate();
+  PostMessage(parentHwnd, WM_APP + AppMessage::ListView_onActivate, 0, (LPARAM)&listView);
+}
+
+void pListView::onChange(LPARAM lparam) {
+  LPNMLISTVIEW nmlistview = (LPNMLISTVIEW)lparam;
+  if(!(nmlistview->uChanged & LVIF_STATE)) return;
+
+  unsigned selection = nmlistview->iItem;
+  unsigned imagemask = ((nmlistview->uNewState & LVIS_STATEIMAGEMASK) >> 12) - 1;
+  if(imagemask == 0 || imagemask == 1) {
+    if(!locked) {
+      listView.state.checked[selection] = !listView.state.checked[selection];
+      if(listView.onToggle) listView.onToggle(selection);
+    }
+  } else if((nmlistview->uOldState & LVIS_FOCUSED) && !(nmlistview->uNewState & LVIS_FOCUSED)) {
+    lostFocus = true;
+    listView.state.selected = false;
+    listView.state.selection = 0;
+  } else if(!(nmlistview->uOldState & LVIS_SELECTED) && (nmlistview->uNewState & LVIS_SELECTED)) {
+    lostFocus = false;
+    listView.state.selected = true;
+    listView.state.selection = selection;
+    if(!locked && listView.onChange) listView.onChange();
+  } else if(!lostFocus && !listView.state.selected) {
+    lostFocus = false;
+    listView.state.selected = false;
+    listView.state.selection = 0;
+    if(!locked && listView.onChange) listView.onChange();
+  } else if(listView.selected() && ListView_GetSelectedCount(hwnd) == 0) {
+    listView.state.selected = false;
+    listView.state.selection = 0;
+    if(!locked && listView.onChange) listView.onChange();
+  }
+}
+
+LRESULT pListView::onCustomDraw(LPARAM lparam) {
+  LPNMLVCUSTOMDRAW lvcd = (LPNMLVCUSTOMDRAW)lparam;
+
+  switch(lvcd->nmcd.dwDrawStage) {
+
+  case CDDS_PREPAINT: {
+    return CDRF_NOTIFYITEMDRAW;
+  }
+
+  case CDDS_ITEMPREPAINT: {
+    Color& background = listView.state.backgroundColor;
+    Color& foreground = listView.state.foregroundColor;
+    lvcd->clrText = RGB(foreground.red, foreground.green, foreground.blue);
+    lvcd->clrTextBk = RGB(background.red, background.green, background.blue);
+    if(listView.state.headerText.size() >= 2 && lvcd->nmcd.dwItemSpec % 2) {
+      //draw alternating row colors if there are two or more columns
+      lvcd->clrTextBk = RGB(max(0, (signed)background.red - 17), max(0, (signed)background.green - 17), max(0, (signed)background.blue - 17));
+    }
+    return CDRF_DODEFAULT;
+  }
+
+  default: {
+    return CDRF_DODEFAULT;
+  }
+
+  }
+}
+
+}
diff -Nru higan/phoenix/windows/widget/progress-bar.cpp nSide/phoenix/windows/widget/progress-bar.cpp
--- higan/phoenix/windows/widget/progress-bar.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/windows/widget/progress-bar.cpp	2015-09-16 13:08:13.575563370 +0900
@@ -0,0 +1,31 @@
+namespace phoenix {
+
+Size pProgressBar::minimumSize() {
+  return {0, 23};
+}
+
+void pProgressBar::setPosition(unsigned position) {
+  SendMessage(hwnd, PBM_SETPOS, (WPARAM)position, 0);
+}
+
+void pProgressBar::constructor() {
+  hwnd = CreateWindow(PROGRESS_CLASS, L"",
+    WS_CHILD | PBS_SMOOTH,
+    0, 0, 0, 0, parentHwnd, (HMENU)id, GetModuleHandle(0), 0);
+  SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)&progressBar);
+  SendMessage(hwnd, PBM_SETRANGE, 0, MAKELPARAM(0, 100));
+  SendMessage(hwnd, PBM_SETSTEP, MAKEWPARAM(1, 0), 0);
+  setPosition(progressBar.state.position);
+  synchronize();
+}
+
+void pProgressBar::destructor() {
+  DestroyWindow(hwnd);
+}
+
+void pProgressBar::orphan() {
+  destructor();
+  constructor();
+}
+
+}
diff -Nru higan/phoenix/windows/widget/radio-button.cpp nSide/phoenix/windows/widget/radio-button.cpp
--- higan/phoenix/windows/widget/radio-button.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/windows/widget/radio-button.cpp	2015-09-16 13:08:13.573563370 +0900
@@ -0,0 +1,89 @@
+namespace phoenix {
+
+Size pRadioButton::minimumSize() {
+  Size size = pFont::size(hfont, radioButton.state.text);
+
+  if(radioButton.state.orientation == Orientation::Horizontal) {
+    size.width += radioButton.state.image.width();
+    size.height = max(radioButton.state.image.height(), size.height);
+  }
+
+  if(radioButton.state.orientation == Orientation::Vertical) {
+    size.width = max(radioButton.state.image.width(), size.width);
+    size.height += radioButton.state.image.height();
+  }
+
+  return {size.width + 20, size.height + 10};
+}
+
+void pRadioButton::setChecked() {
+  for(auto& item : radioButton.state.group) {
+    SendMessage(item.p.hwnd, BM_SETCHECK, (WPARAM)(&item == &radioButton), 0);
+  }
+}
+
+void pRadioButton::setGroup(const group<RadioButton>& group) {
+}
+
+void pRadioButton::setImage(const image& image, Orientation orientation) {
+  nall::image nallImage = image;
+  nallImage.transform(0, 32, 255u << 24, 255u << 16, 255u << 8, 255u << 0);
+
+  if(hbitmap) { DeleteObject(hbitmap); hbitmap = 0; }
+  if(himagelist) { ImageList_Destroy(himagelist); himagelist = 0; }
+
+  if(OsVersion() < WindowsVista) nallImage.alphaBlend(GetSysColor(COLOR_BTNFACE));
+  hbitmap = CreateBitmap(nallImage);
+  himagelist = ImageList_Create(nallImage.width(), nallImage.height(), ILC_COLOR32, 1, 0);
+  ImageList_Add(himagelist, hbitmap, NULL);
+  BUTTON_IMAGELIST list;
+  list.himl = himagelist;
+  switch(orientation) {
+  case Orientation::Horizontal: SetRect(&list.margin, 5, 0, 0, 0); list.uAlign = BUTTON_IMAGELIST_ALIGN_LEFT; break;
+  case Orientation::Vertical:   SetRect(&list.margin, 0, 5, 0, 0); list.uAlign = BUTTON_IMAGELIST_ALIGN_TOP;  break;
+  }
+  Button_SetImageList(hwnd, &list);
+
+  setText(radioButton.state.text);
+}
+
+void pRadioButton::setText(string text) {
+  if(text.empty()) {
+    SetWindowLongPtr(hwnd, GWL_STYLE, GetWindowLongPtr(hwnd, GWL_STYLE) |  BS_BITMAP);
+  } else {
+    SetWindowLongPtr(hwnd, GWL_STYLE, GetWindowLongPtr(hwnd, GWL_STYLE) & ~BS_BITMAP);
+  }
+
+  SetWindowText(hwnd, utf16_t(text));
+}
+
+void pRadioButton::constructor() {
+  hwnd = CreateWindow(L"BUTTON", L"",
+    WS_CHILD | WS_TABSTOP | BS_CHECKBOX | BS_PUSHLIKE,
+    0, 0, 0, 0, parentHwnd, (HMENU)id, GetModuleHandle(0), 0);
+  SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)&radioButton);
+  setDefaultFont();
+  if(radioButton.state.checked) setChecked();
+  setImage(radioButton.state.image, radioButton.state.orientation);
+//setText(radioButton.state.text);
+  synchronize();
+}
+
+void pRadioButton::destructor() {
+  if(hbitmap) { DeleteObject(hbitmap); hbitmap = 0; }
+  if(himagelist) { ImageList_Destroy(himagelist); himagelist = 0; }
+  DestroyWindow(hwnd);
+}
+
+void pRadioButton::orphan() {
+  destructor();
+  constructor();
+}
+
+void pRadioButton::onActivate() {
+  if(radioButton.state.checked) return;
+  radioButton.setChecked();
+  if(radioButton.onActivate) radioButton.onActivate();
+}
+
+}
diff -Nru higan/phoenix/windows/widget/radio-label.cpp nSide/phoenix/windows/widget/radio-label.cpp
--- higan/phoenix/windows/widget/radio-label.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/windows/widget/radio-label.cpp	2015-09-16 13:08:13.575563370 +0900
@@ -0,0 +1,49 @@
+namespace phoenix {
+
+Size pRadioLabel::minimumSize() {
+  Size size = pFont::size(hfont, radioLabel.state.text);
+  return {size.width + 20, size.height + 4};
+}
+
+void pRadioLabel::setChecked() {
+  for(auto& item : radioLabel.state.group) {
+    SendMessage(item.p.hwnd, BM_SETCHECK, (WPARAM)(&item == &radioLabel), 0);
+  }
+}
+
+void pRadioLabel::setGroup(const group<RadioLabel>& group) {
+}
+
+void pRadioLabel::setText(string text) {
+  SetWindowText(hwnd, utf16_t(text));
+}
+
+void pRadioLabel::constructor() {
+  hwnd = CreateWindow(
+    L"BUTTON", L"",
+    WS_CHILD | WS_TABSTOP | BS_RADIOBUTTON,
+    0, 0, 0, 0, parentHwnd, (HMENU)id, GetModuleHandle(0), 0
+  );
+  SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)&radioLabel);
+  setDefaultFont();
+  if(radioLabel.state.checked) setChecked();
+  setText(radioLabel.state.text);
+  synchronize();
+}
+
+void pRadioLabel::destructor() {
+  DestroyWindow(hwnd);
+}
+
+void pRadioLabel::orphan() {
+  destructor();
+  constructor();
+}
+
+void pRadioLabel::onActivate() {
+  if(radioLabel.state.checked) return;
+  radioLabel.setChecked();
+  if(radioLabel.onActivate) radioLabel.onActivate();
+}
+
+}
diff -Nru higan/phoenix/windows/widget/tab-frame.cpp nSide/phoenix/windows/widget/tab-frame.cpp
--- higan/phoenix/windows/widget/tab-frame.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/windows/widget/tab-frame.cpp	2015-09-16 13:08:13.574563370 +0900
@@ -0,0 +1,143 @@
+namespace phoenix {
+
+static LRESULT CALLBACK TabFrame_windowProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam) {
+  Object* object = (Object*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
+  if(object == nullptr) return DefWindowProc(hwnd, msg, wparam, lparam);
+  TabFrame& tabFrame = (TabFrame&)*object;
+  return Shared_windowProc(tabFrame.p.windowProc, hwnd, msg, wparam, lparam);
+}
+
+void pTabFrame::append(string text, const image& image) {
+  unsigned selection = TabCtrl_GetItemCount(hwnd);
+  wchar_t wtext[] = L"";
+  TCITEM item;
+  item.mask = TCIF_TEXT;
+  item.pszText = wtext;
+  TabCtrl_InsertItem(hwnd, selection, &item);
+  setText(selection, text);
+  if(!image.empty()) setImage(selection, image);
+}
+
+void pTabFrame::remove(unsigned selection) {
+  TabCtrl_DeleteItem(hwnd, selection);
+  buildImageList();
+}
+
+void pTabFrame::setEnabled(bool enabled) {
+  pWidget::setEnabled(enabled);
+  for(auto& layout : tabFrame.state.layout) {
+    if(layout) layout->setEnabled(layout->enabled());
+  }
+}
+
+void pTabFrame::setGeometry(Geometry geometry) {
+  pWidget::setGeometry(geometry);
+  geometry.x += 1, geometry.width -= 4;
+  geometry.y += 21, geometry.height -= 23;
+  for(auto& layout : tabFrame.state.layout) {
+    if(layout) layout->setGeometry(geometry);
+  }
+}
+
+void pTabFrame::setImage(unsigned selection, const image& image) {
+  buildImageList();
+}
+
+void pTabFrame::setSelection(unsigned selection) {
+  TabCtrl_SetCurSel(hwnd, selection);
+  synchronizeLayout();
+}
+
+void pTabFrame::setText(unsigned selection, string text) {
+  utf16_t wtext(text);
+  TCITEM item;
+  item.mask = TCIF_TEXT;
+  item.pszText = (wchar_t*)wtext;
+  TabCtrl_SetItem(hwnd, selection, &item);
+}
+
+void pTabFrame::setVisible(bool visible) {
+  pWidget::setVisible(visible);
+  for(auto& layout : tabFrame.state.layout) {
+    if(layout) layout->setVisible(layout->visible());
+  }
+}
+
+void pTabFrame::constructor() {
+  hwnd = CreateWindow(WC_TABCONTROL, L"",
+    WS_CHILD | WS_TABSTOP,
+    0, 0, 0, 0, parentHwnd, (HMENU)id, GetModuleHandle(0), 0);
+  SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)&tabFrame);
+
+  windowProc = (WindowProc)GetWindowLongPtr(hwnd, GWLP_WNDPROC);
+  SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR)TabFrame_windowProc);
+
+  setDefaultFont();
+  for(auto& text : tabFrame.state.text) append(text, {});
+  buildImageList();
+  setSelection(tabFrame.state.selection);
+  synchronize();
+}
+
+void pTabFrame::destructor() {
+  if(imageList) { ImageList_Destroy(imageList); imageList = nullptr; }
+  DestroyWindow(hwnd);
+}
+
+void pTabFrame::orphan() {
+  destructor();
+  constructor();
+}
+
+void pTabFrame::buildImageList() {
+  if(imageList) ImageList_Destroy(imageList);
+  unsigned size = pFont::size(hfont, " ").height;
+  imageList = ImageList_Create(size, size, ILC_COLOR32, 1, 0);
+  for(auto& image : tabFrame.state.image) {
+    ImageList_Append(imageList, image, size);
+  }
+  TabCtrl_SetImageList(hwnd, imageList);
+  for(unsigned n = 0; n < tabFrame.state.image.size(); n++) {
+    TCITEM item;
+    item.mask = TCIF_IMAGE;
+    item.iImage = (tabFrame.state.image(n).empty() ? -1 : n);
+    TabCtrl_SetItem(hwnd, n, &item);
+  }
+}
+
+void pTabFrame::synchronizeLayout() {
+  unsigned selection = 0;
+  for(auto& layout : tabFrame.state.layout) {
+    if(layout) layout->setVisible(selection == tabFrame.state.selection);
+    selection++;
+  }
+}
+
+void pTabFrame::onChange() {
+  tabFrame.state.selection = TabCtrl_GetCurSel(hwnd);
+  synchronizeLayout();
+  if(tabFrame.onChange) tabFrame.onChange();
+}
+
+//called only if TCS_OWNERDRAWFIXED style is used
+//this style disables XP/Vista theming of the TabFrame
+void pTabFrame::onDrawItem(LPARAM lparam) {
+  LPDRAWITEMSTRUCT item = (LPDRAWITEMSTRUCT)lparam;
+  FillRect(item->hDC, &item->rcItem, GetSysColorBrush(COLOR_3DFACE));
+  SetBkMode(item->hDC, TRANSPARENT);
+  SetTextColor(item->hDC, GetSysColor(COLOR_BTNTEXT));
+
+  unsigned selection = item->itemID;
+  if(selection < tabFrame.state.text.size()) {
+    string text = tabFrame.state.text[selection];
+    Size size = pFont::size(hfont, text);
+    unsigned width = item->rcItem.right - item->rcItem.left + 1;
+    if(!tabFrame.state.image[selection].empty()) {
+      width += size.height + 2;
+      ImageList_Draw(imageList, selection, item->hDC, item->rcItem.left + (width - size.width) / 2 - (size.height + 3), item->rcItem.top + 2, ILD_NORMAL);
+    }
+    TextOut(item->hDC, item->rcItem.left + (width - size.width) / 2, item->rcItem.top + 2, utf16_t(text), text.size());
+  }
+}
+
+}
diff -Nru higan/phoenix/windows/widget/text-edit.cpp nSide/phoenix/windows/widget/text-edit.cpp
--- higan/phoenix/windows/widget/text-edit.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/windows/widget/text-edit.cpp	2015-09-16 13:08:13.574563370 +0900
@@ -0,0 +1,76 @@
+namespace phoenix {
+
+void pTextEdit::setBackgroundColor(Color color) {
+  if(backgroundBrush) DeleteObject(backgroundBrush);
+  backgroundBrush = CreateSolidBrush(RGB(color.red, color.green, color.blue));
+}
+
+void pTextEdit::setCursorPosition(unsigned position) {
+  if(position == ~0) position >>= 1;  //Edit_SetSel takes signed type
+  Edit_SetSel(hwnd, position, position);
+  Edit_ScrollCaret(hwnd);
+}
+
+void pTextEdit::setEditable(bool editable) {
+  SendMessage(hwnd, EM_SETREADONLY, editable == false, (LPARAM)0);
+}
+
+void pTextEdit::setForegroundColor(Color color) {
+}
+
+void pTextEdit::setText(string text) {
+  locked = true;
+  string output = text;
+  output.replace("\r", "");
+  output.replace("\n", "\r\n");
+  SetWindowText(hwnd, utf16_t(output));
+  locked = false;
+}
+
+void pTextEdit::setWordWrap(bool wordWrap) {
+  //ES_AUTOHSCROLL cannot be changed after widget creation.
+  //As a result, we must destroy and re-create widget to change this setting.
+  orphan();
+}
+
+string pTextEdit::text() {
+  unsigned length = GetWindowTextLength(hwnd);
+  wchar_t buffer[length + 1];
+  GetWindowText(hwnd, buffer, length + 1);
+  buffer[length] = 0;
+  string text = (const char*)utf8_t(buffer);
+  text.replace("\r", "");
+  return text;
+}
+
+void pTextEdit::constructor() {
+  hwnd = CreateWindowEx(
+    WS_EX_CLIENTEDGE, L"EDIT", L"",
+    WS_CHILD | WS_TABSTOP | WS_VSCROLL | ES_AUTOVSCROLL | ES_MULTILINE | ES_WANTRETURN | (textEdit.state.wordWrap == false ? WS_HSCROLL | ES_AUTOHSCROLL : 0),
+    0, 0, 0, 0, parentHwnd, (HMENU)id, GetModuleHandle(0), 0
+  );
+  SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)&textEdit);
+  setDefaultFont();
+  setBackgroundColor(textEdit.state.backgroundColor);
+  setCursorPosition(textEdit.state.cursorPosition);
+  setEditable(textEdit.state.editable);
+  setText(textEdit.state.text);
+  synchronize();
+}
+
+void pTextEdit::destructor() {
+  textEdit.state.text = text();
+  DestroyWindow(hwnd);
+}
+
+void pTextEdit::orphan() {
+  destructor();
+  constructor();
+}
+
+void pTextEdit::onChange() {
+  if(locked) return;
+  if(textEdit.onChange) textEdit.onChange();
+}
+
+}
diff -Nru higan/phoenix/windows/widget/vertical-scroller.cpp nSide/phoenix/windows/widget/vertical-scroller.cpp
--- higan/phoenix/windows/widget/vertical-scroller.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/windows/widget/vertical-scroller.cpp	2015-09-16 13:08:13.575563370 +0900
@@ -0,0 +1,45 @@
+namespace phoenix {
+
+Size pVerticalScroller::minimumSize() {
+  return {18, 0};
+}
+
+void pVerticalScroller::setLength(unsigned length) {
+  length += (length == 0);
+  SetScrollRange(hwnd, SB_CTL, 0, length - 1, TRUE);
+  verticalScroller.setPosition(0);
+}
+
+void pVerticalScroller::setPosition(unsigned position) {
+  SetScrollPos(hwnd, SB_CTL, position, TRUE);
+}
+
+void pVerticalScroller::constructor() {
+  hwnd = CreateWindow(
+    L"SCROLLBAR", L"", WS_CHILD | SBS_VERT,
+    0, 0, 0, 0, parentHwnd, (HMENU)id, GetModuleHandle(0), 0
+  );
+  SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)&verticalScroller);
+  unsigned position = verticalScroller.state.position;
+  setLength(verticalScroller.state.length);
+  verticalScroller.setPosition(position);
+  synchronize();
+}
+
+void pVerticalScroller::destructor() {
+  DestroyWindow(hwnd);
+}
+
+void pVerticalScroller::orphan() {
+  destructor();
+  constructor();
+}
+
+void pVerticalScroller::onChange(WPARAM wparam) {
+  unsigned position = ScrollEvent(hwnd, wparam);
+  if(position == verticalScroller.state.position) return;
+  verticalScroller.state.position = position;
+  if(verticalScroller.onChange) verticalScroller.onChange();
+}
+
+}
diff -Nru higan/phoenix/windows/widget/vertical-slider.cpp nSide/phoenix/windows/widget/vertical-slider.cpp
--- higan/phoenix/windows/widget/vertical-slider.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/windows/widget/vertical-slider.cpp	2015-09-16 13:08:13.575563370 +0900
@@ -0,0 +1,47 @@
+namespace phoenix {
+
+Size pVerticalSlider::minimumSize() {
+  return {0, 25};
+}
+
+void pVerticalSlider::setLength(unsigned length) {
+  length += (length == 0);
+  SendMessage(hwnd, TBM_SETRANGE, (WPARAM)true, (LPARAM)MAKELONG(0, length - 1));
+  SendMessage(hwnd, TBM_SETPAGESIZE, 0, (LPARAM)(length >> 3));
+  verticalSlider.setPosition(0);
+}
+
+void pVerticalSlider::setPosition(unsigned position) {
+  SendMessage(hwnd, TBM_SETPOS, (WPARAM)true, (LPARAM)position);
+}
+
+void pVerticalSlider::constructor() {
+  hwnd = CreateWindow(
+    TRACKBAR_CLASS, L"", WS_CHILD | WS_TABSTOP | TBS_TRANSPARENTBKGND | TBS_NOTICKS | TBS_BOTH | TBS_VERT,
+    0, 0, 0, 0, parentHwnd, (HMENU)id, GetModuleHandle(0), 0
+  );
+  SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)&verticalSlider);
+
+  unsigned position = verticalSlider.state.position;
+  setLength(verticalSlider.state.length);
+  verticalSlider.setPosition(position);
+  synchronize();
+}
+
+void pVerticalSlider::destructor() {
+  DestroyWindow(hwnd);
+}
+
+void pVerticalSlider::orphan() {
+  destructor();
+  constructor();
+}
+
+void pVerticalSlider::onChange() {
+  unsigned position = SendMessage(hwnd, TBM_GETPOS, 0, 0);
+  if(position == verticalSlider.state.position) return;
+  verticalSlider.state.position = position;
+  if(verticalSlider.onChange) verticalSlider.onChange();
+}
+
+}
diff -Nru higan/phoenix/windows/widget/viewport.cpp nSide/phoenix/windows/widget/viewport.cpp
--- higan/phoenix/windows/widget/viewport.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/windows/widget/viewport.cpp	2015-09-16 13:08:13.575563370 +0900
@@ -0,0 +1,76 @@
+namespace phoenix {
+
+static LRESULT CALLBACK Viewport_windowProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam) {
+  Object* object = (Object*)GetWindowLongPtr(hwnd, GWLP_USERDATA);
+  if(object == nullptr) return DefWindowProc(hwnd, msg, wparam, lparam);
+  if(!dynamic_cast<Viewport*>(object)) return DefWindowProc(hwnd, msg, wparam, lparam);
+  Viewport& viewport = (Viewport&)*object;
+
+  if(msg == WM_DROPFILES) {
+    lstring paths = DropPaths(wparam);
+    if(paths.empty() == false) {
+      if(viewport.onDrop) viewport.onDrop(paths);
+    }
+    return FALSE;
+  }
+
+  if(msg == WM_GETDLGCODE) {
+    return DLGC_STATIC | DLGC_WANTCHARS;
+  }
+
+  if(msg == WM_MOUSEMOVE) {
+    TRACKMOUSEEVENT tracker = {sizeof(TRACKMOUSEEVENT), TME_LEAVE, hwnd};
+    TrackMouseEvent(&tracker);
+    if(viewport.onMouseMove) viewport.onMouseMove({(int16_t)LOWORD(lparam), (int16_t)HIWORD(lparam)});
+  }
+
+  if(msg == WM_MOUSELEAVE) {
+    if(viewport.onMouseLeave) viewport.onMouseLeave();
+  }
+
+  if(msg == WM_LBUTTONDOWN || msg == WM_MBUTTONDOWN || msg == WM_RBUTTONDOWN) {
+    if(viewport.onMousePress) switch(msg) {
+    case WM_LBUTTONDOWN: viewport.onMousePress(Mouse::Button::Left); break;
+    case WM_MBUTTONDOWN: viewport.onMousePress(Mouse::Button::Middle); break;
+    case WM_RBUTTONDOWN: viewport.onMousePress(Mouse::Button::Right); break;
+    }
+  }
+
+  if(msg == WM_LBUTTONUP || msg == WM_MBUTTONUP || msg == WM_RBUTTONUP) {
+    if(viewport.onMouseRelease) switch(msg) {
+    case WM_LBUTTONUP: viewport.onMouseRelease(Mouse::Button::Left); break;
+    case WM_MBUTTONUP: viewport.onMouseRelease(Mouse::Button::Middle); break;
+    case WM_RBUTTONUP: viewport.onMouseRelease(Mouse::Button::Right); break;
+    }
+  }
+
+  return DefWindowProc(hwnd, msg, wparam, lparam);
+}
+
+uintptr_t pViewport::handle() {
+  return (uintptr_t)hwnd;
+}
+
+void pViewport::setDroppable(bool droppable) {
+  DragAcceptFiles(hwnd, droppable);
+}
+
+void pViewport::constructor() {
+  hwnd = CreateWindow(L"phoenix_viewport", L"",
+    WS_CHILD | WS_DISABLED,
+    0, 0, 0, 0, parentHwnd, (HMENU)id, GetModuleHandle(0), 0);
+  SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)&viewport);
+  setDroppable(viewport.state.droppable);
+  synchronize();
+}
+
+void pViewport::destructor() {
+  DestroyWindow(hwnd);
+}
+
+void pViewport::orphan() {
+  destructor();
+  constructor();
+}
+
+}
diff -Nru higan/phoenix/windows/widget/widget.cpp nSide/phoenix/windows/widget/widget.cpp
--- higan/phoenix/windows/widget/widget.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/windows/widget/widget.cpp	2015-09-16 13:08:13.571563369 +0900
@@ -0,0 +1,82 @@
+namespace phoenix {
+
+bool pWidget::focused() {
+  return GetFocus() == hwnd;
+}
+
+Size pWidget::minimumSize() {
+  return {0, 0};
+}
+
+void pWidget::setEnabled(bool enabled) {
+  if(!widget.parent()) enabled = false;
+  if(widget.state.abstract) enabled = false;
+  if(!widget.enabledToAll()) enabled = false;
+  EnableWindow(hwnd, enabled);
+}
+
+void pWidget::setFocused() {
+  SetFocus(hwnd);
+}
+
+void pWidget::setFont(string font) {
+  if(hfont) DeleteObject(hfont);
+  hfont = pFont::create(font);
+  SendMessage(hwnd, WM_SETFONT, (WPARAM)hfont, 0);
+}
+
+void pWidget::setGeometry(Geometry geometry) {
+  if(GetParentWidget(&sizable)) {
+    Position displacement = GetParentWidget(&sizable)->state.geometry.position();
+    geometry.x -= displacement.x;
+    geometry.y -= displacement.y;
+  }
+  SetWindowPos(hwnd, NULL, geometry.x, geometry.y, geometry.width, geometry.height, SWP_NOZORDER);
+  if(widget.onSize) widget.onSize();
+}
+
+void pWidget::setVisible(bool visible) {
+  if(!widget.parent()) visible = false;
+  if(widget.state.abstract) visible = false;
+  if(!widget.visibleToAll()) visible = false;
+  ShowWindow(hwnd, visible ? SW_SHOWNORMAL : SW_HIDE);
+}
+
+void pWidget::constructor() {
+  hfont = pFont::create(Font::sans(8));
+  if(widget.state.abstract) {
+    hwnd = CreateWindow(L"phoenix_label", L"",
+    WS_CHILD,
+    0, 0, 0, 0, parentHwnd, (HMENU)id, GetModuleHandle(0), 0);
+    SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)&widget);
+  }
+}
+
+void pWidget::destructor() {
+  if(widget.state.abstract) {
+    DestroyWindow(hwnd);
+  }
+}
+
+void pWidget::orphan() {
+  destructor();
+  constructor();
+}
+
+void pWidget::setDefaultFont() {
+  string description = widget.state.font;
+  if(description.empty()) description = Font::sans(8);
+  hfont = pFont::create(description);
+  SendMessage(hwnd, WM_SETFONT, (WPARAM)hfont, 0);
+}
+
+//calling Widget::setParent destroys widget and re-creates it:
+//need to re-apply visiblity and enabled status; called by each subclassed setParent() function
+//constructors are called top-down, so set each widget to the top of the z-order (so children appear on top of parents)
+void pWidget::synchronize() {
+  widget.setEnabled(widget.enabled());
+  widget.setVisible(widget.visible());
+  SetWindowPos(hwnd, HWND_TOP, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE);
+}
+
+}
diff -Nru higan/phoenix/windows/window.cpp nSide/phoenix/windows/window.cpp
--- higan/phoenix/windows/window.cpp	1970-01-01 09:00:00.000000000 +0900
+++ nSide/phoenix/windows/window.cpp	2015-09-16 13:08:13.578563370 +0900
@@ -0,0 +1,339 @@
+namespace phoenix {
+
+vector<pWindow*> pWindow::modal;
+
+//EnableWindow(hwnd, false) sends WM_KILLFOCUS; deactivating said window
+//EnableWindow(hwnd, true) does not restore lost focus
+//when a modal loop finishes, and the dialog is dismissed, the application loses focus entirely
+//due to anti-focus-stealing code in Windows, SetForegroundWindow() cannot restore lost focus
+//further, GetActiveWindow() returns nothing when all windows have lost focus
+//thus, we must use a focus-stealing hack to reclaim the focus we never intended to dismiss;
+//and we must replicate GetActiveWindow() by scanning the Z-order of windows for this process
+
+void pWindow::updateModality() {
+  //bind thread input to process that currently has input focus
+  auto threadId = GetWindowThreadProcessId(GetForegroundWindow(), NULL);
+  AttachThreadInput(threadId, GetCurrentThreadId(), TRUE);
+
+  pWindow* topMost = nullptr;
+  for(auto& object : pObject::objects) {
+    if(dynamic_cast<pWindow*>(object) == nullptr) continue;
+    pWindow* p = (pWindow*)object;
+    bool enable = modal.size() == 0 || modal.find(p);
+    if(IsWindowEnabled(p->hwnd) != enable) EnableWindow(p->hwnd, enable);
+    if(enable && p->window.visible()) {
+      if(topMost == nullptr) topMost = p;
+      else if(GetWindowZOrder(p->hwnd) < GetWindowZOrder(topMost->hwnd)) topMost = p;
+    }
+  }
+
+  //set input focus on top-most window
+  if(topMost) {
+    SetForegroundWindow(topMost->hwnd);
+    SetActiveWindow(topMost->hwnd);
+  }
+
+  //unbind thread input hook
+  AttachThreadInput(threadId, GetCurrentThreadId(), FALSE);
+}
+
+static const unsigned FixedStyle = WS_SYSMENU | WS_CAPTION | WS_MINIMIZEBOX | WS_BORDER;
+static const unsigned ResizableStyle = WS_SYSMENU | WS_CAPTION | WS_MINIMIZEBOX | WS_MAXIMIZEBOX | WS_THICKFRAME;
+
+Window& pWindow::none() {
+  static Window* window = nullptr;
+  if(window == nullptr) window = new Window;
+  return *window;
+}
+
+void pWindow::append(Layout& layout) {
+  Geometry geom = window.state.geometry;
+  geom.x = geom.y = 0;
+  layout.setGeometry(geom);
+}
+
+void pWindow::append(Menu& menu) {
+  menu.p.parentWindow = &window;
+  updateMenu();
+}
+
+void pWindow::append(Widget& widget) {
+  if(GetParentWidget(&widget)) {
+    widget.p.parentHwnd = GetParentWidget(&widget)->p.hwnd;
+  } else {
+    widget.p.parentHwnd = window.p.hwnd;
+  }
+  widget.p.orphan();
+
+  if(widget.font().empty() && !window.state.widgetFont.empty()) {
+    widget.setFont(window.state.widgetFont);
+  }
+}
+
+bool pWindow::focused() {
+  return (GetForegroundWindow() == hwnd);
+}
+
+Geometry pWindow::frameMargin() {
+  unsigned style = window.state.resizable ? ResizableStyle : FixedStyle;
+  if(window.state.fullScreen) style = 0;
+  RECT rc = {0, 0, 640, 480};
+  AdjustWindowRect(&rc, style, window.state.menuVisible);
+  unsigned statusHeight = 0;
+  if(window.state.statusVisible) {
+    RECT src;
+    GetClientRect(hstatus, &src);
+    statusHeight = src.bottom - src.top;
+  }
+  return {abs(rc.left), abs(rc.top), (rc.right - rc.left) - 640, (rc.bottom - rc.top) + statusHeight - 480};
+}
+
+Geometry pWindow::geometry() {
+  Geometry margin = frameMargin();
+
+  RECT rc;
+  if(IsIconic(hwnd)) {
+    //GetWindowRect returns -32000(x),-32000(y) when window is minimized
+    WINDOWPLACEMENT wp;
+    GetWindowPlacement(hwnd, &wp);
+    rc = wp.rcNormalPosition;
+  } else {
+    GetWindowRect(hwnd, &rc);
+  }
+
+  signed x = rc.left + margin.x;
+  signed y = rc.top + margin.y;
+  unsigned width = (rc.right - rc.left) - margin.width;
+  unsigned height = (rc.bottom - rc.top) - margin.height;
+
+  return {x, y, width, height};
+}
+
+void pWindow::remove(Layout& layout) {
+}
+
+void pWindow::remove(Menu& menu) {
+  updateMenu();
+}
+
+void pWindow::remove(Widget& widget) {
+  widget.p.orphan();
+}
+
+void pWindow::setBackgroundColor(Color color) {
+  if(brush) DeleteObject(brush);
+  brushColor = RGB(color.red, color.green, color.blue);
+  brush = CreateSolidBrush(brushColor);
+}
+
+void pWindow::setDroppable(bool droppable) {
+  DragAcceptFiles(hwnd, droppable);
+}
+
+void pWindow::setFocused() {
+  if(window.state.visible == false) setVisible(true);
+  SetFocus(hwnd);
+}
+
+void pWindow::setFullScreen(bool fullScreen) {
+  locked = true;
+  if(fullScreen == false) {
+    SetWindowLongPtr(hwnd, GWL_STYLE, WS_VISIBLE | (window.state.resizable ? ResizableStyle : FixedStyle));
+    setGeometry(window.state.geometry);
+  } else {
+    HMONITOR monitor = MonitorFromWindow(hwnd, MONITOR_DEFAULTTONEAREST);
+    MONITORINFOEX info;
+    memset(&info, 0, sizeof(MONITORINFOEX));
+    info.cbSize = sizeof(MONITORINFOEX);
+    GetMonitorInfo(monitor, &info);
+    RECT rc = info.rcMonitor;
+    Geometry geometry = {rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top};
+    SetWindowLongPtr(hwnd, GWL_STYLE, WS_VISIBLE | WS_POPUP);
+    Geometry margin = frameMargin();
+    setGeometry({
+      geometry.x + margin.x, geometry.y + margin.y,
+      geometry.width - margin.width, geometry.height - margin.height
+    });
+  }
+  locked = false;
+}
+
+void pWindow::setGeometry(Geometry geometry) {
+  locked = true;
+  Geometry margin = frameMargin();
+  SetWindowPos(
+    hwnd, NULL,
+    geometry.x - margin.x, geometry.y - margin.y,
+    geometry.width + margin.width, geometry.height + margin.height,
+    SWP_NOZORDER | SWP_FRAMECHANGED
+  );
+  SetWindowPos(hstatus, NULL, 0, 0, 0, 0, SWP_NOZORDER | SWP_FRAMECHANGED);
+  for(auto& layout : window.state.layout) {
+    Geometry geom = this->geometry();
+    geom.x = geom.y = 0;
+    layout.setGeometry(geom);
+  }
+  locked = false;
+}
+
+void pWindow::setMenuFont(string font) {
+}
+
+void pWindow::setMenuVisible(bool visible) {
+  locked = true;
+  SetMenu(hwnd, visible ? hmenu : 0);
+  setGeometry(window.state.geometry);
+  locked = false;
+}
+
+void pWindow::setModal(bool modality) {
+  if(modality == true) {
+    modal.appendOnce(this);
+    updateModality();
+    while(window.state.modal) {
+      Application::processEvents();
+      if(Application::main) {
+        Application::main();
+      } else {
+        usleep(20 * 1000);
+      }
+    }
+    if(auto position = modal.find(this)) modal.remove(position());
+    updateModality();
+  }
+}
+
+void pWindow::setResizable(bool resizable) {
+  SetWindowLongPtr(hwnd, GWL_STYLE, window.state.resizable ? ResizableStyle : FixedStyle);
+  setGeometry(window.state.geometry);
+}
+
+void pWindow::setStatusFont(string font) {
+  if(hstatusfont) DeleteObject(hstatusfont);
+  hstatusfont = pFont::create(font);
+  SendMessage(hstatus, WM_SETFONT, (WPARAM)hstatusfont, 0);
+}
+
+void pWindow::setStatusText(string text) {
+  SendMessage(hstatus, SB_SETTEXT, 0, (LPARAM)(wchar_t*)utf16_t(text));
+}
+
+void pWindow::setStatusVisible(bool visible) {
+  locked = true;
+  ShowWindow(hstatus, visible ? SW_SHOWNORMAL : SW_HIDE);
+  setGeometry(window.state.geometry);
+  locked = false;
+}
+
+void pWindow::setTitle(string text) {
+  SetWindowText(hwnd, utf16_t(text));
+}
+
+void pWindow::setVisible(bool visible) {
+  ShowWindow(hwnd, visible ? SW_SHOWNORMAL : SW_HIDE);
+  if(visible == false) setModal(false);
+}
+
+void pWindow::setWidgetFont(string font) {
+}
+
+void pWindow::constructor() {
+  brush = 0;
+
+  hwnd = CreateWindow(L"phoenix_window", L"", ResizableStyle, 128, 128, 256, 256, 0, 0, GetModuleHandle(0), 0);
+  hmenu = CreateMenu();
+  hstatus = CreateWindow(STATUSCLASSNAME, L"", WS_CHILD, 0, 0, 0, 0, hwnd, 0, GetModuleHandle(0), 0);
+  hstatusfont = 0;
+  setStatusFont(Font::sans(8));
+
+  //status bar will be capable of receiving tab focus if it is not disabled
+  SetWindowLongPtr(hstatus, GWL_STYLE, GetWindowLong(hstatus, GWL_STYLE) | WS_DISABLED);
+
+  SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)&window);
+  setDroppable(window.state.droppable);
+  setGeometry({128, 128, 256, 256});
+
+  DWORD color = GetSysColor(COLOR_3DFACE);
+  window.state.backgroundColor = Color((uint8_t)(color >> 16), (uint8_t)(color >> 8), (uint8_t)(color >> 0), 255u);
+}
+
+void pWindow::destructor() {
+  DeleteObject(hstatusfont);
+  DestroyWindow(hstatus);
+  DestroyMenu(hmenu);
+  DestroyWindow(hwnd);
+}
+
+void pWindow::updateMenu() {
+  if(hmenu) DestroyMenu(hmenu);
+  hmenu = CreateMenu();
+
+  for(auto& menu : window.state.menu) {
+    menu.p.update(window);
+    if(menu.visible()) {
+      AppendMenu(hmenu, MF_STRING | MF_POPUP, (UINT_PTR)menu.p.hmenu, utf16_t(menu.state.text));
+    }
+  }
+
+  SetMenu(hwnd, window.state.menuVisible ? hmenu : 0);
+}
+
+void pWindow::onClose() {
+  if(window.onClose) window.onClose();
+  else window.setVisible(false);
+  if(window.state.modal && !window.state.visible) window.setModal(false);
+}
+
+void pWindow::onDrop(WPARAM wparam) {
+  lstring paths = DropPaths(wparam);
+  if(paths.empty()) return;
+  if(window.onDrop) window.onDrop(paths);
+}
+
+bool pWindow::onEraseBackground() {
+  if(brush == 0) return false;
+  RECT rc;
+  GetClientRect(hwnd, &rc);
+  PAINTSTRUCT ps;
+  BeginPaint(hwnd, &ps);
+  FillRect(ps.hdc, &rc, brush);
+  EndPaint(hwnd, &ps);
+  return true;
+}
+
+void pWindow::onModalBegin() {
+  if(Application::Windows::onModalBegin) Application::Windows::onModalBegin();
+}
+
+void pWindow::onModalEnd() {
+  if(Application::Windows::onModalEnd) Application::Windows::onModalEnd();
+}
+
+void pWindow::onMove() {
+  if(locked) return;
+
+  Geometry windowGeometry = geometry();
+  window.state.geometry.x = windowGeometry.x;
+  window.state.geometry.y = windowGeometry.y;
+
+  if(window.onMove) window.onMove();
+}
+
+void pWindow::onSize() {
+  if(locked) return;
+  SetWindowPos(hstatus, NULL, 0, 0, 0, 0, SWP_NOZORDER | SWP_FRAMECHANGED);
+
+  Geometry windowGeometry = geometry();
+  window.state.geometry.width = windowGeometry.width;
+  window.state.geometry.height = windowGeometry.height;
+
+  for(auto& layout : window.state.layout) {
+    Geometry geom = geometry();
+    geom.x = geom.y = 0;
+    layout.setGeometry(geom);
+  }
+
+  if(window.onSize) window.onSize();
+}
+
+}

