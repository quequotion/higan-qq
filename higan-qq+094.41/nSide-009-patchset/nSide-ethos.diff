diff -Nru higan/target-ethos/bootstrap.cpp higan/target-ethos/bootstrap.cpp
--- higan/target-ethos/bootstrap.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/target-ethos/bootstrap.cpp	2015-09-16 14:06:03.413919283 +0900
@@ -0,0 +1,15 @@
+#include <fc/interface/interface.hpp>
+#include <sfc/interface/interface.hpp>
+#include <gb/interface/interface.hpp>
+#include <gba/interface/interface.hpp>
+
+void Program::bootstrap() {
+  interface = new Interface;
+
+  emulator.append(new Famicom::Interface);
+  emulator.append(new SuperFamicom::Interface);
+  emulator.append(new GameBoy::Interface);
+  emulator.append(new GameBoyAdvance::Interface);
+
+  for(auto& system : emulator) system->bind = interface;
+}
diff -Nru higan/target-ethos/configuration/configuration.cpp higan/target-ethos/configuration/configuration.cpp
--- higan/target-ethos/configuration/configuration.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/target-ethos/configuration/configuration.cpp	2015-09-16 14:06:03.413919283 +0900
@@ -0,0 +1,60 @@
+#include "../ethos.hpp"
+ConfigurationSettings* config = nullptr;
+
+ConfigurationSettings::ConfigurationSettings() {
+  video.append(video.driver = ruby::Video::safestDriver(), "Driver");
+  video.append(video.synchronize = false, "Synchronize");
+  video.append(video.shader = "Blur", "Shader");
+  video.append(video.scaleMode = 0, "ScaleMode");
+  video.append(video.aspectCorrection = true, "AspectCorrection");
+  video.append(video.colorEmulation = true, "ColorEmulation");
+  video.maskOverscan.assign(video.maskOverscan.enable = false);
+  video.maskOverscan.append(video.maskOverscan.horizontal = 8, "Horizontal");
+  video.maskOverscan.append(video.maskOverscan.vertical = 8, "Vertical");
+  video.append(video.maskOverscan, "MaskOverscan");
+  video.append(video.saturation = 100, "Saturation");
+  video.append(video.gamma = 100, "Gamma");
+  video.append(video.luminance = 100, "Luminance");
+  video.append(video.startFullScreen = false, "StartFullScreen");
+  append(video, "Video");
+
+  audio.append(audio.driver = ruby::Audio::safestDriver(), "Driver");
+  audio.append(audio.synchronize = true, "Synchronize");
+  audio.append(audio.frequency = 48000, "Frequency");
+  audio.append(audio.latency = 60, "Latency");
+  audio.append(audio.resampler = 2, "Resampler");
+  audio.append(audio.volume = 100, "Volume");
+  audio.append(audio.mute = false, "Mute");
+  append(audio, "Audio");
+
+  input.append(input.driver = ruby::Input::safestDriver(), "Driver");
+  input.focus.append(input.focus.pause = false, "Pause");
+  input.focus.append(input.focus.allow = false, "AllowInput");
+  input.append(input.focus, "Focus");
+  append(input, "Input");
+
+  timing.append(timing.video = 60.0, "Video");
+  timing.append(timing.audio = 48000.0, "Audio");
+  append(timing, "Timing");
+
+  server.append(server.hostname = "", "Hostname");
+  server.append(server.username = "", "Username");
+  server.append(server.password = "", "Password");
+  append(server, "Server");
+
+  library.append(library.selection = -1, "Selection");
+  library.append(library.mediaMode = 0, "MediaMode");
+  library.append(library.showOnStartup = true, "ShowOnStartup");
+  append(library, "Library");
+
+  load();
+}
+
+void ConfigurationSettings::load() {
+  Configuration::Document::load(program->path("settings.bml"));
+  save();  //creates file if it does not exist
+}
+
+void ConfigurationSettings::save() {
+  Configuration::Document::save(program->path("settings.bml"));
+}
diff -Nru higan/target-ethos/configuration/configuration.hpp higan/target-ethos/configuration/configuration.hpp
--- higan/target-ethos/configuration/configuration.hpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/target-ethos/configuration/configuration.hpp	2015-09-16 14:06:03.413919283 +0900
@@ -0,0 +1,60 @@
+struct ConfigurationSettings : Configuration::Document {
+  struct Video : Configuration::Node {
+    string driver;
+    bool synchronize;
+    string shader;
+    unsigned scaleMode;
+    bool aspectCorrection;
+    bool colorEmulation;
+    struct MaskOverscan : Configuration::Node {
+      bool enable;
+      unsigned horizontal;
+      unsigned vertical;
+    } maskOverscan;
+    unsigned saturation;
+    unsigned gamma;
+    unsigned luminance;
+    bool startFullScreen;
+  } video;
+
+  struct Audio : Configuration::Node {
+    string driver;
+    bool synchronize;
+    unsigned frequency;
+    unsigned latency;
+    unsigned resampler;
+    unsigned volume;
+    bool mute;
+  } audio;
+
+  struct Input : Configuration::Node {
+    string driver;
+    struct Focus : Configuration::Node {
+      bool pause;
+      bool allow;
+    } focus;
+  } input;
+
+  struct Timing : Configuration::Node {
+    double video;
+    double audio;
+  } timing;
+
+  struct Server : Configuration::Node {
+    string hostname;
+    string username;
+    string password;
+  } server;
+
+  struct Library : Configuration::Node {
+    signed selection;
+    unsigned mediaMode;
+    bool showOnStartup;
+  } library;
+
+  void load();
+  void save();
+  ConfigurationSettings();
+};
+
+extern ConfigurationSettings* config;
diff -Nru higan/target-ethos/ethos.cpp higan/target-ethos/ethos.cpp
--- higan/target-ethos/ethos.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/target-ethos/ethos.cpp	2015-09-16 14:06:03.409919282 +0900
@@ -0,0 +1,190 @@
+#include "ethos.hpp"
+#include "bootstrap.cpp"
+#include "resource/resource.cpp"
+
+Program* program = nullptr;
+Video* video = nullptr;
+Audio* audio = nullptr;
+Input* input = nullptr;
+DSP dspaudio;
+
+Emulator::Interface& system() {
+  if(program->active == nullptr) throw;
+  return *program->active;
+}
+
+//if file already exists in the same path as the binary; use it (portable mode)
+//if not, use default requested path (*nix/user mode)
+auto locate(string pathname, string filename) -> string {
+  string location{programpath(), filename};
+  if(file_system_object::exists(location)) return location;
+  return {pathname, filename};
+}
+
+bool Program::focused() {
+  return config->input.focus.allow || presentation->focused();
+}
+
+string Program::path(string name) {
+  string path = {basepath, name};
+  if(file::exists(path) || directory::exists(path)) return path;
+  path = {userpath, name};
+  if(file::exists(path) || directory::exists(path)) return path;
+  path = {sharedpath, name};
+  if(file::exists(path) || directory::exists(path)) return path;
+  return {userpath, name};
+}
+
+void Program::main() {
+  inputManager->poll();
+  utility->updateStatus();
+  autopause = config->input.focus.pause && presentation->focused() == false;
+
+  if(active == nullptr || system().loaded() == false || pause || autopause) {
+    audio->clear();
+    usleep(20 * 1000);
+    return;
+  }
+
+  system().run();
+}
+
+Program::Program(int argc, char** argv) {
+  ananke.open("ananke");
+
+  program = this;
+  pause = false;
+  autopause = false;
+
+  basepath = nall::programpath();
+  userpath = {nall::configpath(), "ethos/"};
+  sharedpath = {nall::sharedpath(), "ethos/"};
+  directory::create(userpath);
+
+  bootstrap();
+  active = nullptr;
+
+  normalFont = Font::sans(8);
+  boldFont = Font::sans(8, "Bold");
+  titleFont = Font::sans(16, "Bold");
+  monospaceFont = Font::monospace(8);
+
+  config = new ConfigurationSettings;
+  video = Video::create(config->video.driver);
+  audio = Audio::create(config->audio.driver);
+  input = Input::create(config->input.driver);
+
+  utility = new Utility;
+  inputManager = new InputManager;
+  windowManager = new WindowManager;
+  libraryManager = new LibraryManager;
+  presentation = new Presentation;
+  dipSwitches = new DipSwitches;
+  videoSettings = new VideoSettings;
+  audioSettings = new AudioSettings;
+  inputSettings = new InputSettings;
+  hotkeySettings = new HotkeySettings;
+  timingSettings = new TimingSettings;
+  serverSettings = new ServerSettings;
+  advancedSettings = new AdvancedSettings;
+  settings = new Settings;
+  cheatDatabase = new CheatDatabase;
+  cheatEditor = new CheatEditor;
+  stateManager = new StateManager;
+  tools = new Tools;
+  windowManager->loadGeometry();
+  presentation->setVisible();
+  utility->resize();
+
+  if(argc == 1 && config->library.showOnStartup) libraryManager->show();
+
+  video->set(Video::Handle, presentation->viewport.handle());
+  //video->set(Video::Synchronize, config->video.synchronize);
+  if(!video->cap(Video::Depth) || !video->set(Video::Depth, depth = 30u)) {
+    video->set(Video::Depth, depth = 24u);
+  }
+  if(!video->init()) {
+    delete video;
+    video = Video::create("None");
+    video->init();
+  }
+
+  audio->set(Audio::Handle, presentation->viewport.handle());
+  if(!audio->init()) {
+    delete audio;
+    audio = Audio::create("None");
+    audio->init();
+  }
+
+  input->set(Input::Handle, presentation->viewport.handle());
+  if(!input->init()) {
+    delete input;
+    input = Input::create("None");
+    input->init();
+  }
+
+  dspaudio.setPrecision(16);
+  dspaudio.setBalance(0.0);
+  dspaudio.setFrequency(96000);
+
+  utility->synchronizeRuby();
+  utility->updateShader();
+
+  if(config->video.startFullScreen && argc >= 2) utility->toggleFullScreen();
+  Application::processEvents();
+
+  if(argc >= 2) utility->loadMedia(argv[1]);
+
+  Application::main = {&Program::main, this};
+  Application::run();
+
+  utility->unload();
+  config->save();
+  inputManager->saveConfiguration();
+  windowManager->saveGeometry();
+
+  ananke.close();
+}
+
+int main(int argc, char** argv) {
+  #if defined(PLATFORM_WINDOWS)
+  utf8_args(argc, argv);
+  #endif
+
+  Application::setName("ethos");
+
+  Application::Windows::onModalBegin = [&] {
+    audio->clear();
+  };
+
+  Application::Cocoa::onActivate = [&] {
+    presentation->setVisible();
+  };
+
+  Application::Cocoa::onAbout = [&] {
+    MessageWindow()
+    .setTitle({"About ", Emulator::Name})
+    .setText({
+      Emulator::Name, " v", Emulator::Version, "\n",
+      #if defined(PROFILE_ACCURACY) or defined(PROFILE_BALANCED) or defined(PROFILE_PERFORMANCE)
+      Emulator::Profile, " Profile\n",
+      #endif
+      "Original Author: ", Emulator::Author, "\n",
+      "License: ", Emulator::License, "\n",
+      "Website: ", Emulator::Website
+    })
+    .information();
+  };
+
+  Application::Cocoa::onPreferences = [&] {
+    settings->setVisible();
+  };
+
+  Application::Cocoa::onQuit = [&] {
+    Application::quit();
+  };
+
+  new Program(argc, argv);
+  delete program;
+  return 0;
+}
diff -Nru higan/target-ethos/ethos.hpp higan/target-ethos/ethos.hpp
--- higan/target-ethos/ethos.hpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/target-ethos/ethos.hpp	2015-09-16 14:06:03.415919283 +0900
@@ -0,0 +1,52 @@
+#include <nall/nall.hpp>
+#include <ruby/ruby.hpp>
+#include <phoenix/phoenix.hpp>
+using namespace nall;
+using namespace ruby;
+using namespace phoenix;
+extern Video* video;
+extern Audio* audio;
+extern Input* input;
+
+#include <emulator/emulator.hpp>
+Emulator::Interface& system();
+
+#include "configuration/configuration.hpp"
+#include "interface/interface.hpp"
+#include "utility/utility.hpp"
+#include "input/input.hpp"
+#include "window/window.hpp"
+#include "general/general.hpp"
+#include "settings/settings.hpp"
+#include "tools/tools.hpp"
+#include "resource/resource.hpp"
+
+auto locate(string pathname, string filename) -> string;
+
+struct Program {
+  vector<Emulator::Interface*> emulator;
+  Emulator::Interface* active = nullptr;
+  library ananke;
+
+  bool pause;
+  bool autopause;
+  unsigned depth;  //color depth; 24(bpp) or 30(bpp)
+
+  string basepath;
+  string userpath;
+  string sharedpath;
+
+  string normalFont;
+  string boldFont;
+  string titleFont;
+  string monospaceFont;
+
+  bool focused();
+  string path(string filename);
+  void main();
+  void bootstrap();
+  Program(int argc, char** argv);
+};
+
+extern Program* program;
+extern DSP dspaudio;
diff -Nru higan/target-ethos/general/dip-switches.cpp higan/target-ethos/general/dip-switches.cpp
--- higan/target-ethos/general/dip-switches.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/target-ethos/general/dip-switches.cpp	2015-09-16 14:06:03.415919283 +0900
@@ -0,0 +1,64 @@
+DipSwitches* dipSwitches = nullptr;
+
+DipSwitch::DipSwitch() {
+  append(name, {100, 0}, 5);
+  append(value, {~0, 0});
+}
+
+DipSwitches::DipSwitches() {
+  setTitle("DIP Switches");
+  layout.setMargin(5);
+  accept.setText("Accept");
+
+  append(layout);
+  for(auto& dipItem : dip) layout.append(dipItem, {~0, 0}, 5);
+  layout.append(controlLayout, {~0, 0});
+    controlLayout.append(spacer, {~0, 0});
+    controlLayout.append(accept, {80, 0});
+
+  setGeometry({128, 128, 250, layout.minimumSize().height});
+  windowManager->append(this, "DipSwitches");
+
+  onClose = accept.onActivate = [&] {
+    setModal(false);
+    setVisible(false);
+  };
+}
+
+unsigned DipSwitches::run(const Markup::Node& node) {
+  for(auto& dipItem : dip) {
+    dipItem.name.setEnabled(false);
+    dipItem.name.setText("(empty)");
+    dipItem.value.setEnabled(false);
+    dipItem.value.reset();
+    dipItem.values.reset();
+  }
+
+  unsigned index = 0;
+  for(auto& setting : node.find("setting")) {
+    dip[index].name.setEnabled();
+    dip[index].name.setText(setting["name"].text());
+    dip[index].value.setEnabled();
+    for(auto& option : setting.find("option")) {
+      if(auto result = Eval::integer(option["value"].text())) {
+        dip[index].value.append(option["name"].text());
+        dip[index].values.append(result());
+      }
+    }
+
+    if(++index >= Slots) break;
+  }
+
+  setVisible();
+  accept.setFocused();
+
+  audio->clear();
+  setModal();
+
+  unsigned result = 0;
+  for(auto& dipItem : dip) {
+    if(dipItem.value.enabled() == false) continue;
+    result |= dipItem.values[dipItem.value.selection()];
+  }
+  return result;
+}
diff -Nru higan/target-ethos/general/dip-switches.hpp higan/target-ethos/general/dip-switches.hpp
--- higan/target-ethos/general/dip-switches.hpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/target-ethos/general/dip-switches.hpp	2015-09-16 14:06:03.415919283 +0900
@@ -0,0 +1,22 @@
+struct DipSwitch : HorizontalLayout {
+  Label name;
+  ComboButton value;
+  vector<unsigned> values;
+
+  DipSwitch();
+};
+
+struct DipSwitches : Window {
+  enum : unsigned { Slots = 8 };
+
+  VerticalLayout layout;
+  DipSwitch dip[Slots];
+  HorizontalLayout controlLayout;
+    Widget spacer;
+    Button accept;
+
+  unsigned run(const Markup::Node& node);
+  DipSwitches();
+};
+
+extern DipSwitches* dipSwitches;
diff -Nru higan/target-ethos/general/general.cpp higan/target-ethos/general/general.cpp
--- higan/target-ethos/general/general.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/target-ethos/general/general.cpp	2015-09-16 14:06:03.415919283 +0900
@@ -0,0 +1,4 @@
+#include "../ethos.hpp"
+#include "library.cpp"
+#include "presentation.cpp"
+#include "dip-switches.cpp"
diff -Nru higan/target-ethos/general/general.hpp higan/target-ethos/general/general.hpp
--- higan/target-ethos/general/general.hpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/target-ethos/general/general.hpp	2015-09-16 14:06:03.415919283 +0900
@@ -0,0 +1,3 @@
+#include "library.hpp"
+#include "presentation.hpp"
+#include "dip-switches.hpp"
diff -Nru higan/target-ethos/general/library.cpp higan/target-ethos/general/library.cpp
--- higan/target-ethos/general/library.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/target-ethos/general/library.cpp	2015-09-16 14:06:03.414919283 +0900
@@ -0,0 +1,301 @@
+LibraryManager* libraryManager = nullptr;
+
+LibraryBrowser::LibraryBrowser(Emulator::Interface& emulator) : emulator(emulator) {
+  setMargin(5);
+
+  informationType.setText({
+    "Title:\n",
+    "Serial:"
+  });
+
+  for(auto& media : emulator.media) {
+    mediaMode.append(media.name);
+  }
+
+  unsigned height = Font::size(program->normalFont, " ").height;
+
+  append(folders, {~0, ~0}, 5);
+  append(informationLayout, {~0, 0});
+  informationLayout.append(informationType, {0, height * 2}, 5);
+  informationLayout.append(information, {~0, height * 2}, 5);
+  informationLayout.append(mediaMode, {0, 0});
+
+  folders.onActivate = {&LibraryBrowser::onActivate, this};
+  folders.onChange = {&LibraryBrowser::onChange, this};
+  mediaMode.onChange = {&LibraryBrowser::setMode, this};
+}
+
+void LibraryBrowser::onActivate() {
+  if(folders.selected() == false) return;
+  if(libraryManager->loadButton.enabled() == false) return;
+
+  unsigned selection = folders.selection();
+  string pathname = {this->pathname, folders.text(selection, 0), typeSuffix};
+
+  libraryManager->loaded.append(folders.text(selection, 0));
+  libraryManager->setInformation(false);
+
+  if(libraryManager->slotLoad == false) {
+    utility->loadMedia(pathname);
+  } else {
+    libraryManager->loadPathname = pathname;
+    libraryManager->setModal(false);
+  }
+}
+
+void LibraryBrowser::onChange() {
+  if(folders.selected() == false) return information.setText("");
+
+  string manifest = {pathname, folders.text(folders.selection(), 0), typeSuffix, "manifest.bml"};
+  auto document = BML::unserialize(file::read(manifest));
+
+  information.setText({
+    document["information/title"].text(), "\n",
+    document["information/serial"].text()
+  });
+}
+
+void LibraryBrowser::refresh() {
+  folders.reset();
+  lstring pathnames = directory::ifolders(pathname, typeMask);
+  unsigned selection = 0;
+  for(auto& pathname : pathnames) {
+    folders.append(string{pathname}.rtrim(typeSuffix));
+    folders.setImage(selection++, 0, {resource::game, sizeof resource::game});
+  }
+  folders.setSelection(0);
+  onChange();
+}
+
+void LibraryBrowser::setMode() {
+  config->library.mediaMode = mediaMode.selection();
+  auto& media = emulator.media[mediaMode.selection()];
+
+  pathname = {utility->libraryPath(), media.name, "/"};
+  type = media.type;
+  typeMask = {"*.", type};
+  typeSuffix = {".", type, "/"};
+
+  refresh();
+  folders.setFocused();
+  libraryManager->synchronize();
+}
+
+LibraryImport::LibraryImport() {
+  setMargin(5);
+  information.setText({
+    "Higan, manages games in a library. To play a game, you must first import the game.\n"
+    "After doing so, the game will appear inside your library, and can then be loaded and played."
+  });
+  importButton.setText("Import Game ...");
+  append(information, {~0, 0}, 5);
+  append(importButton, {0, 0});
+
+  importButton.onActivate = {&LibraryImport::onImportActivate, this};
+}
+
+void LibraryImport::onImportActivate() {
+  if(program->ananke.open() == false) {
+    MessageWindow().setText({
+      "ananke must be installed to use this feature.\n",
+      "ananke will not work."
+    }).warning();
+    return;
+  }
+  function<string ()> browse = program->ananke.sym("ananke_browse");
+  if(!browse) return;
+  audio->clear();  //ananke's browser is modal
+  string pathname = browse();
+  pathname.rtrim("/");
+  if(pathname.empty()) return;
+
+  //after importing game, take user to the relevant game list to show the newly imported title
+  string type = suffixname(pathname);
+  for(signed bootable = 1; bootable >= 0; bootable--) {
+    unsigned selection = 0;
+    for(auto& browser : libraryManager->browsers) {
+      unsigned mode = 0;
+      for(auto& media : browser->emulator.media) {
+        if(type == media.type && media.bootable == bootable) {
+          browser->mediaMode.setSelection(mode);
+          libraryManager->libraryFrame.setSelection(selection);
+          libraryManager->onChange();
+
+          //find game in list and select it
+          string name = filename(nall::basename(pathname));
+          for(unsigned n = 0; n < browser->folders.rows(); n++) {
+            if(browser->folders.text(n, 0) == name) {
+              browser->folders.setSelection(n);
+              browser->onChange();
+              break;
+            }
+          }
+
+          return;
+        }
+        mode++;
+      }
+      selection++;
+    }
+  }
+}
+
+LibraryManager::LibraryManager() {
+  libraryManager = this;
+
+  setTitle("Game Library");
+  setGeometry({128, 128, 640, 680});
+  windowManager->append(this, "LibraryManager");
+
+  layout.setMargin(5);
+  bootstrap();
+  libraryFrame.append("Import");
+  libraryFrame.setLayout(browsers.size(), libraryImport);
+  loadButton.setText("Load");
+
+  unsigned height = Font::size(program->normalFont, " ").height;
+
+  append(layout);
+  layout.append(libraryFrame, {~0, ~0}, 5);
+  layout.append(informationLayout, {~0, 0});
+  informationLayout.append(information, {~0, height * 3}, 5);
+  informationLayout.append(skipButton, {80, 0}, 5);
+  informationLayout.append(loadButton, {80, 0});
+
+  onClose = skipButton.onActivate = [&] {
+    setModal(false);
+    setVisible(false);
+  };
+
+  libraryFrame.onChange = {&LibraryManager::onChange, this};
+  loadButton.onActivate = {&LibraryManager::onLoad, this};
+
+  //initial config value of -1 defaults to import tab on first launch
+  if(config->library.selection < 0) config->library.selection = browsers.size();
+  libraryFrame.setSelection(config->library.selection);
+
+  if(libraryFrame.selection() < browsers.size()) {
+    browsers[libraryFrame.selection()]->mediaMode.setSelection(config->library.mediaMode);
+    browsers[libraryFrame.selection()]->setMode();
+  }
+}
+
+void LibraryManager::bootstrap() {
+  unsigned selection = 0;
+  for(auto& emulator : program->emulator) {
+    LibraryBrowser* browser = new LibraryBrowser(*emulator);
+    libraryFrame.append(emulator->information.name);
+    libraryFrame.setLayout(selection++, *browser);
+    browsers.append(browser);
+  }
+}
+
+string LibraryManager::load(const string& type) {
+  requestedLoadType = type;
+  unsigned selection = 0;
+  for(auto& browser : browsers) {
+    unsigned mode = 0;
+    for(auto& media : browser->emulator.media) {
+      if(type == media.type && media.bootable == false) {
+        libraryFrame.setSelection(selection);
+        browser->mediaMode.setSelection(mode);
+        browser->setMode();
+
+        slotLoad = true;
+        loadPathname = "";
+        show();
+        setModal();
+        slotLoad = false;
+        browser->mediaMode.setSelection(config->library.mediaMode = 0);
+        return loadPathname;
+      }
+      mode++;
+    }
+    selection++;
+  }
+  return "";  //should never occur
+}
+
+void LibraryManager::onChange() {
+  unsigned selection = libraryFrame.selection();
+  config->library.selection = selection;
+  if(selection < browsers.size()) {
+    browsers[selection]->setMode();
+  } else {
+    loadButton.setEnabled(false);
+  }
+}
+
+void LibraryManager::onLoad() {
+  unsigned selection = libraryFrame.selection();
+  if(selection < browsers.size()) browsers[selection]->onActivate();
+}
+
+void LibraryManager::setInformation(bool load) {
+  string text;
+  if(loaded.size() == 0) {
+    text = {" \nPlease select a game to load ...\n "};
+  } else if(loaded.size() == 1 && load == false) {
+    text = {" \n", loaded[0], "\n "};
+  } else if(loaded.size() == 1 && load == true) {
+    text = {loaded[0], " \nPlease select a slot game to load ...\n "};
+  } else if(loaded.size() == 2 && load == false) {
+    text = {loaded[0], "\n", loaded[1], "\n "};
+  } else if(loaded.size() == 2 && load == true) {
+    text = {loaded[0], "\n", loaded[1], "\nPlease select a slot game to load ..."};
+  } else if(loaded.size() == 3) {
+    text = {loaded[0], "\n", loaded[1], "\n", loaded[2]};
+  }
+  information.setText(text);
+}
+
+void LibraryManager::show() {
+  if(slotLoad == false) {
+    loaded.reset();
+    requestedLoadType.reset();
+    skipButton.setText("Cancel");
+  } else {
+    skipButton.setText("Skip");
+  }
+
+  setInformation(true);
+  setVisible();
+  setFocused();
+  onChange();
+}
+
+//set library to show a specific media type, and then show the library
+void LibraryManager::show(const string& type) {
+  unsigned selection = 0;
+  for(auto& browser : browsers) {
+    unsigned mode = 0;
+    for(auto& media : browser->emulator.media) {
+      if(media.bootable && media.type == type) {
+        libraryFrame.setSelection(selection);
+        browser->mediaMode.setSelection(mode);
+        browser->setMode();
+        return show();
+      }
+      mode++;
+    }
+    selection++;
+  }
+}
+
+void LibraryManager::synchronize() {
+  if(libraryFrame.selection() < browsers.size()) {
+    auto& emulator = browsers[libraryFrame.selection()]->emulator;
+    auto& media = emulator.media[browsers[libraryFrame.selection()]->mediaMode.selection()];
+
+    if(requestedLoadType.empty()) {
+      loadButton.setEnabled(media.bootable);
+    } else {
+      bool enabled = (requestedLoadType == media.type);
+      //allow Super Game Boy to load Game Boy Color games
+      if(requestedLoadType == "gb" && loaded.size() == 1 && media.type == "gbc") enabled = true;
+      loadButton.setEnabled(enabled);
+    }
+  } else {
+    loadButton.setEnabled(false);
+  }
+}
diff -Nru higan/target-ethos/general/library.hpp higan/target-ethos/general/library.hpp
--- higan/target-ethos/general/library.hpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/target-ethos/general/library.hpp	2015-09-16 14:06:03.413919283 +0900
@@ -0,0 +1,55 @@
+struct LibraryBrowser : VerticalLayout {
+  ListView folders;
+  HorizontalLayout informationLayout;
+    Label informationType;
+    Label information;
+    ComboButton mediaMode;
+
+  LibraryBrowser(Emulator::Interface& emulator);
+  void onActivate();
+  void onChange();
+  void refresh();
+  void setMode();
+
+  Emulator::Interface& emulator;
+  string pathname;
+  string type;
+  string typeMask;
+  string typeSuffix;
+};
+
+struct LibraryImport : VerticalLayout {
+  Label information;
+  Button importButton;
+
+  LibraryImport();
+  void onImportActivate();
+};
+
+struct LibraryManager : Window {
+  VerticalLayout layout;
+  TabFrame libraryFrame;
+    vector<LibraryBrowser*> browsers;
+    LibraryImport libraryImport;
+  HorizontalLayout informationLayout;
+    Label information;
+    Button skipButton;
+    Button loadButton;
+
+  LibraryManager();
+  void bootstrap();
+  string load(const string& type);
+  void onChange();
+  void onLoad();
+  void setInformation(bool load);
+  void show();
+  void show(const string& type);
+  void synchronize();
+
+  lstring loaded;
+  string requestedLoadType;
+  bool slotLoad = false;
+  string loadPathname;
+};
+
+extern LibraryManager* libraryManager;
diff -Nru higan/target-ethos/general/presentation.cpp higan/target-ethos/general/presentation.cpp
--- higan/target-ethos/general/presentation.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/target-ethos/general/presentation.cpp	2015-09-16 14:06:03.415919283 +0900
@@ -0,0 +1,257 @@
+Presentation* presentation = nullptr;
+
+void Presentation::synchronize() {
+  for(auto& emulator : emulatorList) emulator->menu.setVisible(false);
+  for(auto& emulator : emulatorList) {
+    if(emulator->interface == program->active) {
+      active = emulator;
+      emulator->menu.setVisible(true);
+    }
+  }
+
+  shaderNone.setChecked();
+  if(config->video.shader == "None") shaderNone.setChecked();
+  if(config->video.shader == "Blur") shaderBlur.setChecked();
+  if(config->video.shader == "Display Emulation") shaderEmulation.setChecked();
+  for(auto& shader : shaderList) {
+    string name = filename(config->video.shader.split(".shader/", 1L)(0));
+    if(name == shader->text()) shader->setChecked();
+  }
+
+  switch(config->video.scaleMode) {
+  case 0: centerVideo.setChecked(); break;
+  case 1: scaleVideo.setChecked(); break;
+  case 2: stretchVideo.setChecked(); break;
+  }
+  aspectCorrection.setChecked(config->video.aspectCorrection);
+  maskOverscan.setChecked(config->video.maskOverscan.enable);
+  synchronizeVideo.setChecked(config->video.synchronize);
+  synchronizeAudio.setChecked(config->audio.synchronize);
+  muteAudio.setChecked(config->audio.mute);
+
+  if(program->active == nullptr) {
+    toolsMenu.setVisible(false);
+  } else {
+    toolsMenu.setVisible(true);
+    saveStateMenu.setVisible(system().information.capability.states);
+    loadStateMenu.setVisible(system().information.capability.states);
+    stateMenuSeparator.setVisible(system().information.capability.states);
+    resizeWindow.setVisible(config->video.scaleMode != 2);
+    stateManager.setVisible(system().information.capability.states);
+    cheatEditor.setVisible(system().information.capability.cheats);
+    synchronizeTime.setVisible(system().rtc());
+  }
+}
+
+void Presentation::setSystemName(string name) {
+  if(active) active->menu.setText(systemName = name);
+}
+
+Presentation::Presentation() {
+  bootstrap();
+  loadShaders();
+  setGeometry({256, 256, 720, 480});
+  windowManager->append(this, "Presentation");
+
+  setTitle({::Emulator::Name, " v", ::Emulator::Version});
+  setBackgroundColor({0, 0, 0});
+  setMenuVisible();
+  setStatusVisible();
+
+  setDroppable();
+  viewport.setDroppable();
+
+  loadMenu.setText("Library");
+  settingsMenu.setText("Settings");
+    videoMenu.setText("Video");
+      centerVideo.setText("Center");
+      scaleVideo.setText("Scale");
+      stretchVideo.setText("Stretch");
+      RadioItem::group(centerVideo, scaleVideo, stretchVideo);
+      aspectCorrection.setText("Aspect Correction");
+      maskOverscan.setText("Mask Overscan");
+    shaderMenu.setText("Shader");
+      shaderNone.setText("None");
+      shaderBlur.setText("Blur");
+      shaderEmulation.setText("Display Emulation");
+    synchronizeVideo.setText("Synchronize Video");
+    synchronizeAudio.setText("Synchronize Audio");
+    muteAudio.setText("Mute Audio");
+    configurationSettings.setText("Configuration ...");
+  toolsMenu.setText("Tools");
+    saveStateMenu.setText("Save State");
+      for(unsigned n = 0; n < 5; n++) saveStateItem[n].setText({"Slot ", 1 + n});
+    loadStateMenu.setText("Load State");
+      for(unsigned n = 0; n < 5; n++) loadStateItem[n].setText({"Slot ", 1 + n});
+    resizeWindow.setText("Resize Window");
+    stateManager.setText("State Manager");
+    cheatEditor.setText("Cheat Editor");
+    synchronizeTime.setText("Synchronize Time");
+
+  append(loadMenu);
+    for(auto& item : loadBootableMedia) loadMenu.append(*item);
+  for(auto& systemItem : emulatorList) append(systemItem->menu);
+  append(settingsMenu);
+    settingsMenu.append(videoMenu);
+      videoMenu.append(centerVideo);
+      videoMenu.append(scaleVideo);
+      videoMenu.append(stretchVideo);
+      videoMenu.append(*new Separator);
+      videoMenu.append(aspectCorrection);
+      videoMenu.append(maskOverscan);
+    settingsMenu.append(shaderMenu);
+      shaderMenu.append(shaderNone);
+      shaderMenu.append(shaderBlur);
+      if(config->video.driver == "OpenGL") shaderMenu.append(shaderEmulation);
+      if(shaderList.size() > 0) {
+        shaderMenu.append(*new Separator);
+        for(auto& shader : shaderList) shaderMenu.append(*shader);
+      }
+    settingsMenu.append(*new Separator);
+    settingsMenu.append(synchronizeVideo);
+    settingsMenu.append(synchronizeAudio);
+    settingsMenu.append(muteAudio);
+    if(Intrinsics::platform() != Intrinsics::Platform::MacOSX) {
+      settingsMenu.append(*new Separator);
+      settingsMenu.append(configurationSettings);
+    }
+  append(toolsMenu);
+    toolsMenu.append(saveStateMenu);
+      for(unsigned n = 0; n < 5; n++) saveStateMenu.append(saveStateItem[n]);
+    toolsMenu.append(loadStateMenu);
+      for(unsigned n = 0; n < 5; n++) loadStateMenu.append(loadStateItem[n]);
+    toolsMenu.append(stateMenuSeparator);
+    toolsMenu.append(resizeWindow);
+    toolsMenu.append(stateManager);
+    toolsMenu.append(cheatEditor);
+    toolsMenu.append(synchronizeTime);
+
+  append(layout);
+  layout.append(viewport, {0, 0, 1, 1});
+
+  onDrop = viewport.onDrop = [&](lstring paths) {
+    if(paths.size() && directory::exists(paths[0])) {
+      utility->loadMedia(paths[0]);
+      setFocused();
+    }
+  };
+
+  onSize = [&] {
+    utility->resize();
+  };
+
+  onClose = [&] {
+    setVisible(false);
+    if(Intrinsics::platform() == Intrinsics::Platform::MacOSX) {
+      utility->unload();
+    } else {
+      Application::quit();
+    }
+  };
+
+  shaderNone.onActivate = [&] { config->video.shader = "None"; utility->updateShader(); };
+  shaderBlur.onActivate = [&] { config->video.shader = "Blur"; utility->updateShader(); };
+  shaderEmulation.onActivate = [&] { config->video.shader = "Display Emulation"; utility->updateShader(); };
+  centerVideo.onActivate  = [&] { config->video.scaleMode = 0; utility->resize(); };
+  scaleVideo.onActivate   = [&] { config->video.scaleMode = 1; utility->resize(); };
+  stretchVideo.onActivate = [&] { config->video.scaleMode = 2; utility->resize(); };
+  aspectCorrection.onToggle = [&] { config->video.aspectCorrection = aspectCorrection.checked(); utility->resize(); };
+  maskOverscan.onToggle = [&] { config->video.maskOverscan.enable = maskOverscan.checked(); };
+  synchronizeVideo.onToggle = [&] { config->video.synchronize = synchronizeVideo.checked(); utility->synchronizeRuby(); };
+  synchronizeAudio.onToggle = [&] { config->audio.synchronize = synchronizeAudio.checked(); utility->synchronizeRuby(); };
+  muteAudio.onToggle = [&] { config->audio.mute = muteAudio.checked(); utility->synchronizeRuby(); };
+  configurationSettings.onActivate = [&] { settings->setVisible(); };
+  for(unsigned n = 0; n < 5; n++) saveStateItem[n].onActivate = [=] { utility->saveState(1 + n); };
+  for(unsigned n = 0; n < 5; n++) loadStateItem[n].onActivate = [=] { utility->loadState(1 + n); };
+  resizeWindow.onActivate = [&] { utility->resize(true); };
+  stateManager.onActivate = [&] { tools->panels.setSelection(1); tools->setVisible(); };
+  cheatEditor.onActivate = [&] { tools->panels.setSelection(0); tools->setVisible(); };
+  synchronizeTime.onActivate = [&] { system().rtcsync(); };
+
+  synchronize();
+}
+
+void Presentation::bootstrap() {
+  for(auto& emulator : program->emulator) {
+    for(auto& media : emulator->media) {
+      if(media.bootable == false) continue;
+      Item* item = new Item;
+      item->setText({media.name, " ..."});
+      item->onActivate = [=] { libraryManager->show(media.type); };
+      loadBootableMedia.append(item);
+    }
+  }
+
+  for(auto& emulator : program->emulator) {
+    auto iEmulator = new Emulator;
+    iEmulator->interface = emulator;
+
+    iEmulator->menu.setText(emulator->information.name);
+    iEmulator->power.setText("Power");
+    iEmulator->reset.setText("Reset");
+    iEmulator->unload.setText("Unload");
+
+    for(auto& port : emulator->port) {
+      auto iPort = new Emulator::Port;
+      iPort->menu.setText(port.name);
+      iEmulator->port.append(iPort);
+
+      for(auto& device : port.device) {
+        auto iDevice = new RadioItem;
+        iDevice->setText(device.name);
+        iDevice->onActivate = [=] { utility->connect(port.id, device.id); };
+        iPort->group.append(*iDevice);
+        iPort->device.append(iDevice);
+      }
+
+      RadioItem::group(iPort->group);
+    }
+
+    iEmulator->menu.append(iEmulator->power);
+    if(emulator->information.resettable)
+    iEmulator->menu.append(iEmulator->reset);
+    iEmulator->menu.append(*new Separator);
+    unsigned visiblePorts = 0;
+    for(auto& iPort : iEmulator->port) {
+      iEmulator->menu.append(iPort->menu);
+      if(iPort->device.size() <= 1) iPort->menu.setVisible(false);
+      else visiblePorts++;
+      for(auto& iDevice : iPort->device) {
+        iPort->menu.append(*iDevice);
+      }
+    }
+    iEmulator->menu.append(iEmulator->controllerSeparator);
+    if(visiblePorts == 0) iEmulator->controllerSeparator.setVisible(false);
+    iEmulator->menu.append(iEmulator->unload);
+
+    iEmulator->power.onActivate = {&Utility::power, utility};
+    iEmulator->reset.onActivate = {&Utility::reset, utility};
+    iEmulator->unload.onActivate = {&Utility::unload, utility};
+
+    emulatorList.append(iEmulator);
+  }
+}
+
+void Presentation::loadShaders() {
+  //only the OpenGL driver has video shader support
+  if(config->video.driver == "OpenGL") {
+    string pathname = program->path("Video Shaders/");
+    lstring shaders = directory::folders(pathname, "*.shader");
+    for(auto& name : shaders) {
+      auto shader = new RadioItem;
+      shader->setText(name.split(".shader/", 1L)(0));
+      shader->onActivate = [=] {
+        config->video.shader = {pathname, name};
+        utility->updateShader();
+      };
+      shaderList.append(shader);
+    }
+  }
+
+  nall::group<RadioItem> group;
+  group.append(shaderNone);
+  group.append(shaderBlur);
+  group.append(shaderEmulation);
+  for(auto& shader : shaderList) group.append(*shader);
+  RadioItem::group(group);
+}
diff -Nru higan/target-ethos/general/presentation.hpp higan/target-ethos/general/presentation.hpp
--- higan/target-ethos/general/presentation.hpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/target-ethos/general/presentation.hpp	2015-09-16 14:06:03.415919283 +0900
@@ -0,0 +1,63 @@
+struct Presentation : Window {
+  FixedLayout layout;
+  Viewport viewport;
+
+  struct Emulator {
+    ::Emulator::Interface* interface;
+
+    Menu menu;
+      Item power;
+      Item reset;
+      Item unload;
+      Separator controllerSeparator;
+      struct Port {
+        Menu menu;
+        nall::group<RadioItem> group;
+        vector<RadioItem*> device;
+      };
+      vector<Port*> port;
+    function<void (string)> callback;
+  };
+  vector<Emulator*> emulatorList;
+  Emulator* active = nullptr;
+
+  Menu loadMenu;
+    vector<Item*> loadBootableMedia;
+  Menu settingsMenu;
+    Menu videoMenu;
+      RadioItem centerVideo;
+      RadioItem scaleVideo;
+      RadioItem stretchVideo;
+      CheckItem aspectCorrection;
+      CheckItem maskOverscan;
+    Menu shaderMenu;
+      RadioItem shaderNone;
+      RadioItem shaderBlur;
+      RadioItem shaderEmulation;
+      vector<RadioItem*> shaderList;
+    CheckItem synchronizeVideo;
+    CheckItem synchronizeAudio;
+    CheckItem muteAudio;
+    Item configurationSettings;
+  Menu toolsMenu;
+    Menu saveStateMenu;
+      Item saveStateItem[5];
+    Menu loadStateMenu;
+      Item loadStateItem[5];
+    Separator stateMenuSeparator;
+    Item resizeWindow;
+    Item stateManager;
+    Item cheatEditor;
+    Item synchronizeTime;
+
+  void synchronize();
+  void setSystemName(string name);
+  void loadShaders();
+  void bootstrap();
+  Presentation();
+
+//internal:
+  string systemName;
+};
+
+extern Presentation* presentation;
diff -Nru higan/target-ethos/GNUmakefile higan/target-ethos/GNUmakefile
--- higan/target-ethos/GNUmakefile	1970-01-01 09:00:00.000000000 +0900
+++ higan/target-ethos/GNUmakefile	2015-09-16 14:06:03.417919283 +0900
@@ -0,0 +1,128 @@
+ifndef name
+  name := ethos
+endif
+
+ifndef DESTDIR
+  DESTDIR := /
+endif
+
+processors := arm gsu hg51b lr35902 r6502 r65816 spc700 upd96050
+include processor/GNUmakefile
+
+include fc/GNUmakefile
+include sfc/GNUmakefile
+include gb/GNUmakefile
+include gba/GNUmakefile
+
+ui_objects := ethos-ethos ethos-configuration ethos-interface ethos-utility
+ui_objects += ethos-input ethos-window ethos-general ethos-settings ethos-tools
+ui_objects += ruby phoenix
+ui_objects += $(if $(call streq,$(platform),windows),ethos-resource)
+
+# platform
+ifeq ($(platform),windows)
+  ruby := video.direct3d video.wgl video.directdraw video.gdi
+  ruby += audio.xaudio2 audio.directsound
+  ruby += input.windows
+else ifeq ($(platform),macosx)
+  ruby := video.cgl
+  ruby += audio.openal
+  ruby += input.carbon
+else ifeq ($(platform),linux)
+  ruby := video.glx video.xv video.xshm video.sdl
+  ruby += audio.alsa audio.openal audio.oss audio.pulseaudio audio.pulseaudiosimple audio.ao
+  ruby += input.udev input.sdl input.xlib
+else ifeq ($(platform),bsd)
+  ruby := video.glx video.xv video.xshm video.sdl
+  ruby += audio.openal audio.oss
+  ruby += input.sdl input.xlib
+endif
+
+# ruby
+include ruby/GNUmakefile
+link += $(rubylink)
+
+# phoenix
+include phoenix/GNUmakefile
+link += $(phoenixlink)
+
+# rules
+objects := $(ui_objects) $(objects)
+objects := $(patsubst %,obj/%.o,$(objects))
+
+obj/ruby.o: ruby/ruby.cpp $(call rwildcard,ruby/)
+	$(compiler) $(rubyflags) -c $< -o $@
+
+obj/phoenix.o: phoenix/phoenix.cpp $(call rwildcard,phoenix/)
+	$(compiler) $(phoenixflags) -c $< -o $@
+
+obj/ethos-ethos.o: $(ui)/ethos.cpp $(call rwildcard,$(ui)/)
+obj/ethos-configuration.o: $(ui)/configuration/configuration.cpp $(call rwildcard,$(ui)/)
+obj/ethos-interface.o: $(ui)/interface/interface.cpp $(call rwildcard,$(ui)/)
+obj/ethos-utility.o: $(ui)/utility/utility.cpp $(call rwildcard,$(ui)/)
+obj/ethos-input.o: $(ui)/input/input.cpp $(call rwildcard,$(ui)/)
+obj/ethos-window.o: $(ui)/window/window.cpp $(call rwildcard,$(ui)/)
+obj/ethos-general.o: $(ui)/general/general.cpp $(call rwildcard,$(ui)/)
+obj/ethos-settings.o: $(ui)/settings/settings.cpp $(call rwildcard,$(ui)/)
+obj/ethos-tools.o: $(ui)/tools/tools.cpp $(call rwildcard,$(ui)/)
+
+obj/ethos-resource.o:
+ifeq ($(arch),x86)
+	windres --target=pe-i386 data/resource.rc obj/ethos-resource.o
+else
+	windres data/resource.rc obj/ethos-resource.o
+endif
+
+# targets
+build: $(objects)
+ifeq ($(shell id -un),root)
+	$(error "make install should not be run as root")
+else ifeq ($(platform),windows)
+	$(strip $(compiler) -shared -o out/phoenix.dll obj/phoenix.o $(phoenixlink))
+	$(strip $(compiler) -o out/$(name) $(subst obj/phoenix.o,,$(objects)) $(link) -Lout -lphoenix)
+else ifeq ($(platform),macosx)
+	if [ -d out/$(name).app ]; then rm -r out/$(name).app; fi
+	mkdir out/$(name).app
+	mkdir out/$(name).app/Contents
+	mkdir out/$(name).app/Contents/MacOS
+	mkdir out/$(name).app/Contents/Resources
+	cp data/Info.plist out/$(name).app/Contents/Info.plist
+	sips -s format icns data/higan.png --out out/$(name).app/Contents/Resources/higan.icns
+	$(strip $(compiler) -o out/$(name).app/Contents/MacOS/$(name) $(objects) $(link))
+else
+	$(strip $(compiler) -o out/$(name) $(objects) $(link))
+endif
+
+resource:
+	sourcery $(ui)/resource/resource.bml $(ui)/resource/resource.cpp $(ui)/resource/resource.hpp
+
+install:
+ifeq ($(shell id -un),root)
+	$(error "make install should not be run as root")
+else ifeq ($(platform),windows)
+else ifeq ($(platform),macosx)
+	install -d $(DESTDIR)Library/Application\ Support/$(name)
+	cp -R profile/* $(DESTDIR)Library/Application\ Support/$(name)
+	cp data/cheats.bml $(DESTDIR)Library/Application\ Support/$(name)/cheats.bml
+	chmod -R 777 $(DESTDIR)Library/Application\ Support/$(name)
+else
+	install -d $(DESTDIR)$(prefix)/bin/
+	cp out/$(name) $(DESTDIR)$(prefix)/bin/$(name)
+	install -d $(DESTDIR)$(prefix)/share/pixmaps/
+	cp data/$(name).png $(DESTDIR)$(prefix)/share/pixmaps/$(name).png
+	install -d $(DESTDIR)$(prefix)/share/applications/
+	cp data/$(name).desktop $(DESTDIR)$(prefix)/share/applications/$(name).desktop
+	install -d $(DESTDIR)usr/share/$(name)
+	cp -R profile/* $(DESTDIR)usr/share/$(name)
+	cp data/cheats.bml $(DESTDIR)usr/share/$(name)/cheats.bml
+	chmod -R 777 $(DESTDIR)usr/share/$(name)
+endif
+
+uninstall:
+ifeq ($(shell id -un),root)
+	$(error "make uninstall should not be run as root")
+else ifeq ($(platform),windows)
+else ifeq ($(platform),macosx)
+else
+	rm $(DESTDIR)$(prefix)/bin/$(name)
+endif
diff -Nru higan/target-ethos/input/hotkeys.cpp higan/target-ethos/input/hotkeys.cpp
--- higan/target-ethos/input/hotkeys.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/target-ethos/input/hotkeys.cpp	2015-09-16 14:06:03.408919282 +0900
@@ -0,0 +1,158 @@
+void InputManager::appendHotkeys() {
+  {
+    auto hotkey = new HotkeyInput;
+    hotkey->name    = "Toggle Fullscreen Mode";
+    hotkey->mapping = "1/Button/F11";
+
+    hotkey->press = [] {
+      utility->toggleFullScreen();
+    };
+  }
+
+  {
+    auto hotkey = new HotkeyInput;
+    hotkey->name    = "Toggle Mouse Capture";
+    hotkey->mapping = "1/Button/F12";
+
+    hotkey->press = [] {
+      input->acquired() ? input->release() : input->acquire();
+    };
+  }
+
+  {
+    auto hotkey = new HotkeyInput;
+    hotkey->name = "Show Library";
+    hotkey->mapping = "1/Button/L";
+
+    hotkey->press = [] {
+      libraryManager->show();
+    };
+  }
+
+  {
+    auto hotkey = new HotkeyInput;
+    hotkey->name = "Pause Emulation";
+    hotkey->mapping = "1/Button/P";
+
+    hotkey->press = [] {
+      program->pause = !program->pause;
+    };
+  }
+
+  {
+    auto hotkey = new HotkeyInput;
+    hotkey->name    = "Fast Forward";
+    hotkey->mapping = "1/Button/Tilde";
+
+    hotkey->press = [] {
+      video->set(Video::Synchronize, false);
+      audio->set(Audio::Synchronize, false);
+    };
+
+    hotkey->release = [] {
+      video->set(Video::Synchronize, ::config->video.synchronize);
+      audio->set(Audio::Synchronize, ::config->audio.synchronize);
+    };
+  }
+
+  {
+    auto hotkey = new HotkeyInput;
+    hotkey->name    = "Power Cycle";
+    hotkey->mapping = "None";
+
+    hotkey->press = [] {
+      utility->power();
+    };
+  }
+
+  {
+    auto hotkey = new HotkeyInput;
+    hotkey->name    = "Soft Reset";
+    hotkey->mapping = "None";
+
+    hotkey->press = [] {
+      utility->reset();
+    };
+  }
+
+  static unsigned activeSlot = 1;
+
+  {
+    auto hotkey = new HotkeyInput;
+    hotkey->name    = "Save State";
+    hotkey->mapping = "1/Button/F5";
+
+    hotkey->press = [&] {
+      utility->saveState(activeSlot);
+    };
+  }
+
+  {
+    auto hotkey = new HotkeyInput;
+    hotkey->name    = "Load State";
+    hotkey->mapping = "1/Button/F7";
+
+    hotkey->press = [&] {
+      utility->loadState(activeSlot);
+    };
+  }
+
+  {
+    auto hotkey = new HotkeyInput;
+    hotkey->name    = "Decrement Slot";
+    hotkey->mapping = "1/Button/F6";
+
+    hotkey->press = [&] {
+      if(--activeSlot == 0) activeSlot = 5;
+      utility->showMessage({"Selected slot ", activeSlot});
+    };
+  }
+
+  {
+    auto hotkey = new HotkeyInput;
+    hotkey->name    = "Increment Slot";
+    hotkey->mapping = "1/Button/F8";
+
+    hotkey->press = [&] {
+      if(++activeSlot == 6) activeSlot = 1;
+      utility->showMessage({"Selected slot ", activeSlot});
+    };
+  }
+
+  {
+    auto hotkey = new HotkeyInput;
+    hotkey->name    = "Close Emulator";
+    hotkey->mapping = "None";
+
+    hotkey->press = [] {
+      Application::quit();
+    };
+  }
+
+  {
+    auto hotkey = new HotkeyInput;
+    hotkey->name    = "Export Memory";
+    hotkey->mapping = "None";
+
+    hotkey->press = [&] {
+      if(program->active == nullptr) return;
+      system().exportMemory();
+      utility->showMessage("Memory exported");
+    };
+  }
+
+  Configuration::Node node;
+  for(auto& hotkey : hotkeyMap) {
+    node.append(hotkey->mapping, string{hotkey->name}.replace(" ", ""));
+  }
+  config.append(node, "Hotkey");
+}
+
+void InputManager::pollHotkeys() {
+  for(auto& hotkey : hotkeyMap) {
+    bool state = hotkey->poll();
+    if(hotkey->state == 0 && state == 1) if(hotkey->press) hotkey->press();
+    if(hotkey->state == 1 && state == 0) if(hotkey->release) hotkey->release();
+    hotkey->state = state;
+  }
+}
diff -Nru higan/target-ethos/input/input.cpp higan/target-ethos/input/input.cpp
--- higan/target-ethos/input/input.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/target-ethos/input/input.cpp	2015-09-16 14:06:03.409919282 +0900
@@ -0,0 +1,294 @@
+#include "../ethos.hpp"
+#include "hotkeys.cpp"
+InputManager* inputManager = nullptr;
+HID::Null hidNull;
+
+void AbstractInput::bind() {
+  inputList.reset();
+  lstring list = mapping.split(",");
+
+  for(auto& mapping : list) {
+    lstring values = mapping.split("/");
+    if(values.size() == 1) continue;  //skip "None" mapping
+
+    uint64_t id = hex(values[0]);
+    string group = values(1, "");
+    string input = values(2, "");
+    string qualifier = values(3, "");
+
+    Input item;
+    for(auto& device : inputManager->devices) {
+      if(id != device->id()) continue;
+      if(group == "Rumble") {
+        item.device = &*device;
+        item.id = id;
+        item.group = 0;
+        item.input = 0;
+        break;
+      }
+      if(auto groupID = device->find(group)) {
+        if(auto inputID = device->group(groupID()).find(input)) {
+          item.device = &*device;
+          item.id = id;
+          item.group = groupID();
+          item.input = inputID();
+          item.qualifier = Input::Qualifier::None;
+          if(qualifier == "Lo") item.qualifier = Input::Qualifier::Lo;
+          if(qualifier == "Hi") item.qualifier = Input::Qualifier::Hi;
+          break;
+        }
+      }
+    }
+    if(item.device == nullptr) continue;
+
+    inputList.append(item);
+  }
+}
+
+bool AbstractInput::append(string encode) {
+  lstring mappings = mapping.split(",");
+  if(mappings.find(encode)) return true;  //mapping already bound
+  if(mapping.empty() || mapping == "None") mapping = encode;  //remove "None"
+  else mapping.append(",", encode);  //add to existing mapping list
+  bind();
+  return true;
+}
+
+//
+
+bool DigitalInput::bind(HID::Device& device, unsigned group, unsigned input, int16_t oldValue, int16_t newValue) {
+  if(device.isNull() || (device.isKeyboard() && device.group(group).input(input).name() == "Escape")) {
+    inputList.reset();
+    mapping = "None";
+    return true;
+  }
+
+  string encode = {hex(device.id()), "/", device.group(group).name(), "/", device.group(group).input(input).name()};
+
+  if((device.isKeyboard() && group == HID::Keyboard::GroupID::Button)
+  || (device.isMouse() && group == HID::Mouse::GroupID::Button)
+  || (device.isJoypad() && group == HID::Joypad::GroupID::Button)
+  ) {
+    if(newValue != 0) return append(encode);
+  }
+
+  if((device.isJoypad() && group == HID::Joypad::GroupID::Axis)
+  || (device.isJoypad() && group == HID::Joypad::GroupID::Hat)
+  ) {
+    if(newValue < -16384) return append({encode, "/Lo"});
+    if(newValue > +16384) return append({encode, "/Hi"});
+  }
+
+  return false;
+}
+
+int16_t DigitalInput::poll() {
+  if(program->focused() == false) return 0;
+  if(inputList.size() == 0) return 0;
+  bool result = logic;
+
+  for(auto& item : inputList) {
+    HID::Device& device = *(item.device);
+    int16_t value = device.group(item.group).input(item.input).value();
+    bool output = logic;
+    if((device.isKeyboard() && item.group == HID::Keyboard::GroupID::Button)
+    || (device.isMouse() && item.group == HID::Mouse::GroupID::Button)
+    || (device.isJoypad() && item.group == HID::Joypad::GroupID::Button)
+    ) {
+      output = value;
+    }
+    if((device.isJoypad() && item.group == HID::Joypad::GroupID::Axis)
+    || (device.isJoypad() && item.group == HID::Joypad::GroupID::Hat)
+    ) {
+      if(item.qualifier == Input::Qualifier::Lo) output = value < -16384;
+      if(item.qualifier == Input::Qualifier::Hi) output = value > +16384;
+    }
+    if(logic == 0) result |= output;
+    if(logic == 1) result &= output;
+  }
+
+  return result;
+}
+
+//
+
+bool RelativeInput::bind(HID::Device& device, unsigned group, unsigned input, int16_t oldValue, int16_t newValue) {
+  if(device.isNull() || (device.isKeyboard() && device.group(group).input(input).name() == "Escape")) {
+    inputList.reset();
+    mapping = "None";
+    return true;
+  }
+
+  string encode = {hex(device.id()), "/", device.group(group).name(), "/", device.group(group).input(input).name()};
+
+  if((device.isMouse() && group == HID::Mouse::GroupID::Axis)
+  || (device.isJoypad() && group == HID::Joypad::GroupID::Axis)
+  || (device.isJoypad() && group == HID::Joypad::GroupID::Hat)
+  ) {
+    if(newValue < -16384) return append(encode);
+    if(newValue > +16384) return append(encode);
+  }
+
+  return false;
+}
+
+int16_t RelativeInput::poll() {
+  if(program->focused() == false) return 0;
+  if(inputList.size() == 0) return 0;
+  int16_t result = 0;
+
+  for(auto& item : inputList) {
+    HID::Device& device = *(item.device);
+    int16_t value = device.group(item.group).input(item.input).value();
+    if(device.isJoypad() && item.group == HID::Joypad::GroupID::Axis) value >>= 8;
+    if(device.isJoypad() && item.group == HID::Joypad::GroupID::Hat) value = (value < 0 ? -1 : value > 0 ? + 1 : 0);
+    if(device.isMouse() && input->acquired() == false) value = 0;
+    result += value;
+  }
+
+  return result;
+}
+
+//
+
+bool RumbleInput::bind(HID::Device& device, unsigned group, unsigned input, int16_t oldValue, int16_t newValue) {
+  if(device.isNull() || (device.isKeyboard() && device.group(group).input(input).name() == "Escape")) {
+    inputList.reset();
+    mapping = "None";
+    return true;
+  }
+
+  string encode = {hex(device.id()), "/Rumble"};
+
+  if(device.isJoypad() && group == HID::Joypad::GroupID::Button) {
+    if(newValue != 0) return append(encode);
+  }
+
+  return false;
+}
+
+void RumbleInput::rumble(bool enable) {
+  if(program->focused() == false) return;
+  if(inputList.size() == 0) return;
+
+  for(auto& item : inputList) {
+    input->rumble(item.id, enable);
+  }
+}
+
+//
+
+HotkeyInput::HotkeyInput() {
+  logic = 1;  //AND
+  inputManager->hotkeyMap.append(this);
+}
+
+//
+
+//convert an input mapping string to a more human-readable form for the UI
+string InputManager::sanitize(string mapping, string concatenate) const {
+  lstring values = mapping.split(",");
+  for(auto& value : values) {
+    lstring part = value.split("/");
+    if(part.size() < 2) continue;  //skip "None" mapping
+    if(part[0] == "1") part[0] = "Keyboard";
+    else if(part[0] == "2") part[0] = "Mouse";
+    else part[0] = {"Joypad(", part[0].slice(0, 3), ")"};
+    value = part.merge(".");
+  }
+  return values.merge(concatenate);
+}
+
+void InputManager::onChange(shared_pointer<HID::Device> device, unsigned group, unsigned input, int16_t oldValue, int16_t newValue) {
+  if(settings->focused()) {
+    inputSettings->inputEvent(*device, group, input, oldValue, newValue);
+    hotkeySettings->inputEvent(*device, group, input, oldValue, newValue);
+  }
+}
+
+HID::Device* InputManager::findMouse() {
+  for(auto& device : devices) {
+    if(device->isMouse()) return &*device;
+  }
+  return nullptr;
+}
+
+void InputManager::bind() {
+  for(auto& input : inputMap) input->bind();
+  for(auto& input : hotkeyMap) input->bind();
+}
+
+void InputManager::poll() {
+  auto devices = input->poll();
+  bool changed = devices.size() != this->devices.size();
+  if(changed == false) {
+    for(unsigned n = 0; n < devices.size(); n++) {
+      changed = devices[n] != this->devices[n];
+      if(changed) break;
+    }
+  }
+  if(changed == true) {
+    this->devices = devices;
+    bind();
+  }
+
+  if(presentation->focused()) pollHotkeys();
+}
+
+void InputManager::saveConfiguration() {
+  config.save(program->path("input.bml"));
+}
+
+InputManager::InputManager() {
+  inputManager = this;
+  bootstrap();
+
+  input->onChange({&InputManager::onChange, this});
+}
+
+void InputManager::bootstrap() {
+  unsigned guid = 0;
+  for(auto& emulator : program->emulator) {
+    Configuration::Node emulatorNode;
+
+    for(auto& port : emulator->port) {
+      Configuration::Node portNode;
+
+      for(auto& device : port.device) {
+        Configuration::Node deviceNode;
+
+        for(auto& number : device.order) {
+          auto& input = device.input(number);
+
+          AbstractInput* abstract = nullptr;
+          if(input.type == 0) abstract = new DigitalInput;
+          if(input.type == 1) abstract = new RelativeInput;
+          if(input.type == 2) abstract = new RumbleInput;
+          if(abstract == nullptr) continue;
+
+          abstract->name = string{input.name}.replace(" ", "");
+          abstract->mapping = "None";
+          abstract->logic = 0;  //OR
+
+          input.guid = guid++;
+          inputMap.append(abstract);
+
+          deviceNode.append(abstract->mapping, abstract->name);
+        }
+
+        portNode.append(deviceNode, string{device.name}.replace(" ", ""));
+      }
+
+      emulatorNode.append(portNode, string{port.name}.replace(" ", ""));
+    }
+
+    config.append(emulatorNode, string{emulator->information.name}.replace(" ", ""));
+  }
+
+  appendHotkeys();
+
+  config.load(program->path("input.bml"));
+  config.save(program->path("input.bml"));
+
+  bind();
+}
diff -Nru higan/target-ethos/input/input.hpp higan/target-ethos/input/input.hpp
--- higan/target-ethos/input/input.hpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/target-ethos/input/input.hpp	2015-09-16 14:06:03.409919282 +0900
@@ -0,0 +1,71 @@
+extern HID::Null hidNull;
+
+struct AbstractInput {
+  string name;
+  string mapping;
+  bool logic = 0;  //0 = OR, 1 = AND
+  bool state = 0;
+
+  struct Input {
+    HID::Device* device = nullptr;
+    uint64_t id = 0;
+    unsigned group = 0;
+    unsigned input = 0;
+    enum class Qualifier : unsigned { None, Lo, Hi } qualifier;
+  };
+  vector<Input> inputList;
+
+  void bind();
+  bool append(string mapping);
+  virtual bool bind(HID::Device& device, unsigned group, unsigned input, int16_t oldValue, int16_t newValue) { return false; }
+  virtual int16_t poll() { return 0; }
+  virtual void rumble(bool enable) {}
+};
+
+struct DigitalInput : AbstractInput {
+  using AbstractInput::bind;
+  bool bind(HID::Device& device, unsigned group, unsigned input, int16_t oldValue, int16_t newValue);
+  int16_t poll();
+};
+
+struct RelativeInput : AbstractInput {
+  using AbstractInput::bind;
+  bool bind(HID::Device& device, unsigned group, unsigned input, int16_t oldValue, int16_t newValue);
+  int16_t poll();
+};
+
+struct RumbleInput : AbstractInput {
+  using AbstractInput::bind;
+  bool bind(HID::Device& device, unsigned group, unsigned input, int16_t oldValue, int16_t newValue);
+  void rumble(bool enable);
+};
+
+struct HotkeyInput : DigitalInput {
+  function<void ()> press;
+  function<void ()> release;
+  HotkeyInput();
+};
+
+struct InputManager {
+  vector<shared_pointer<HID::Device>> devices;
+  vector<AbstractInput*> inputMap;
+  vector<HotkeyInput*> hotkeyMap;
+
+  string sanitize(string mapping, string concatenate) const;
+  void onChange(shared_pointer<HID::Device> device, unsigned group, unsigned input, int16_t oldValue, int16_t newValue);
+  HID::Device* findMouse();
+  void bind();
+  void poll();
+  void saveConfiguration();
+  void bootstrap();
+  InputManager();
+
+  //hotkeys.cpp
+  void appendHotkeys();
+  void pollHotkeys();
+
+private:
+  Configuration::Document config;
+};
+
+extern InputManager* inputManager;
diff -Nru higan/target-ethos/interface/interface.cpp higan/target-ethos/interface/interface.cpp
--- higan/target-ethos/interface/interface.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/target-ethos/interface/interface.cpp	2015-09-16 14:06:03.416919283 +0900
@@ -0,0 +1,139 @@
+#include "../ethos.hpp"
+Interface* interface = nullptr;
+
+void Interface::loadRequest(unsigned id, string name, string type, bool required) {
+  return utility->loadRequest(id, name, type, required);
+}
+
+void Interface::loadRequest(unsigned id, string path, bool required) {
+  return utility->loadRequest(id, path, required);
+}
+
+void Interface::saveRequest(unsigned id, string path, bool required) {
+  return utility->saveRequest(id, path, required);
+}
+
+uint32_t Interface::videoColor(unsigned source, uint16_t a, uint16_t r, uint16_t g, uint16_t b) {
+  if(config->video.shader != "Display Emulation") {
+    if(config->video.saturation != 100) {
+      uint16_t grayscale = uclamp<16>((r + g + b) / 3);
+      double saturation = config->video.saturation * 0.01;
+      double inverse = max(0.0, 1.0 - saturation);
+      r = uclamp<16>(r * saturation + grayscale * inverse);
+      g = uclamp<16>(g * saturation + grayscale * inverse);
+      b = uclamp<16>(b * saturation + grayscale * inverse);
+    }
+
+    if(config->video.gamma != 100) {
+      double exponent = config->video.gamma * 0.01;
+      double reciprocal = 1.0 / 32767.0;
+      r = r > 32767 ? r : 32767 * pow(r * reciprocal, exponent);
+      g = g > 32767 ? g : 32767 * pow(g * reciprocal, exponent);
+      b = b > 32767 ? b : 32767 * pow(b * reciprocal, exponent);
+    }
+
+    if(config->video.luminance != 100) {
+      double luminance = config->video.luminance * 0.01;
+      r = r * luminance;
+      g = g * luminance;
+      b = b * luminance;
+    }
+  }
+
+  if(program->depth == 30) {
+    a >>= 14, r >>= 6, g >>= 6, b >>= 6;
+    return a << 30 | r << 20 | g << 10 | b << 0;
+  }
+
+  if(program->depth == 24) {
+    a >>= 8, r >>= 8, g >>= 8, b >>= 8;
+    return a << 24 | r << 16 | g << 8 | b << 0;
+  }
+
+  return 0u;
+}
+
+void Interface::videoRefresh(const uint32_t* palette, const uint32_t* data, unsigned pitch, unsigned width, unsigned height) {
+  uint32_t* output;
+  unsigned outputPitch;
+
+  if(video->lock(output, outputPitch, width, height)) {
+    pitch >>= 2, outputPitch >>= 2;
+
+    for(unsigned y = 0; y < height; y++) {
+      const uint32_t* sp = data + y * pitch;
+      uint32_t* dp = output + y * outputPitch;
+      for(unsigned x = 0; x < width; x++) {
+        *dp++ = palette[*sp++];
+      }
+    }
+
+    if(system().information.overscan && config->video.maskOverscan.enable) {
+      unsigned h = config->video.maskOverscan.horizontal;
+      unsigned v = config->video.maskOverscan.vertical;
+
+      if(h) for(unsigned y = 0; y < height; y++) {
+        memset(output + y * outputPitch, 0, 4 * h);
+        memset(output + y * outputPitch + (width - h), 0, 4 * h);
+      }
+
+      if(v) for(unsigned y = 0; y < v; y++) {
+        memset(output + y * outputPitch, 0, 4 * width);
+        memset(output + (height - 1 - y) * outputPitch, 0, 4 * width);
+      }
+    }
+
+    video->unlock();
+    video->refresh();
+  }
+
+  static unsigned frameCounter = 0;
+  static time_t previous, current;
+  frameCounter++;
+
+  time(&current);
+  if(current != previous) {
+    previous = current;
+    utility->setStatusText({"FPS: ", frameCounter});
+    frameCounter = 0;
+  }
+}
+
+void Interface::audioSample(int16_t lsample, int16_t rsample) {
+  signed samples[] = {lsample, rsample};
+  dspaudio.sample(samples);
+  while(dspaudio.pending()) {
+    dspaudio.read(samples);
+    audio->sample(samples[0], samples[1]);
+  }
+}
+
+int16_t Interface::inputPoll(unsigned port, unsigned device, unsigned input) {
+  unsigned guid = system().port[port].device[device].input[input].guid;
+  return inputManager->inputMap[guid]->poll();
+}
+
+void Interface::inputRumble(unsigned port, unsigned device, unsigned input, bool enable) {
+  unsigned guid = system().port[port].device[device].input[input].guid;
+  return inputManager->inputMap[guid]->rumble(enable);
+}
+
+unsigned Interface::dipSettings(const Markup::Node& node) {
+  return dipSwitches->run(node);
+}
+
+string Interface::path(unsigned group) {
+  return utility->path(group);
+}
+
+string Interface::server() {
+  return {
+    config->server.username, ":",
+    config->server.password, "@",
+    config->server.hostname
+  };
+}
+
+void Interface::notify(string text) {
+  MessageWindow().setParent(*presentation).setText(text).information();
+}
diff -Nru higan/target-ethos/interface/interface.hpp higan/target-ethos/interface/interface.hpp
--- higan/target-ethos/interface/interface.hpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/target-ethos/interface/interface.hpp	2015-09-16 14:06:03.416919283 +0900
@@ -0,0 +1,16 @@
+struct Interface : Emulator::Interface::Bind {
+  void loadRequest(unsigned id, string name, string type, bool required);
+  void loadRequest(unsigned id, string path, bool required);
+  void saveRequest(unsigned id, string path, bool required);
+  uint32_t videoColor(unsigned source, uint16_t alpha, uint16_t red, uint16_t green, uint16_t blue);
+  void videoRefresh(const uint32_t* palette, const uint32_t* data, unsigned pitch, unsigned width, unsigned height);
+  void audioSample(int16_t lsample, int16_t rsample);
+  int16_t inputPoll(unsigned port, unsigned device, unsigned input);
+  void inputRumble(unsigned port, unsigned device, unsigned input, bool enable);
+  unsigned dipSettings(const Markup::Node& node);
+  string path(unsigned group);
+  string server();
+  void notify(string text);
+};
+
+extern Interface* interface;
Binary files higan/target-ethos/resource/advanced.png and higan/target-ethos/resource/advanced.png differ
Binary files higan/target-ethos/resource/audio.png and higan/target-ethos/resource/audio.png differ
Binary files higan/target-ethos/resource/cheat-editor.png and higan/target-ethos/resource/cheat-editor.png differ
Binary files higan/target-ethos/resource/folder.png and higan/target-ethos/resource/folder.png differ
Binary files higan/target-ethos/resource/game.png and higan/target-ethos/resource/game.png differ
Binary files higan/target-ethos/resource/home.png and higan/target-ethos/resource/home.png differ
Binary files higan/target-ethos/resource/hotkeys.png and higan/target-ethos/resource/hotkeys.png differ
Binary files higan/target-ethos/resource/input.png and higan/target-ethos/resource/input.png differ
diff -Nru higan/target-ethos/resource/resource.bml higan/target-ethos/resource/resource.bml
--- higan/target-ethos/resource/resource.bml	1970-01-01 09:00:00.000000000 +0900
+++ higan/target-ethos/resource/resource.bml	2015-09-16 14:06:03.411919283 +0900
@@ -0,0 +1,15 @@
+resource name=resource
+  binary id=advanced name=advanced.png
+  binary id=audio name=audio.png
+  binary id=cheatEditor name=cheat-editor.png
+  binary id=folder name=folder.png
+  binary id=game name=game.png
+  binary id=home name=home.png
+  binary id=hotkeys name=hotkeys.png
+  binary id=input name=input.png
+  binary id=server name=server.png
+  binary id=stateManager name=state-manager.png
+  binary id=timing name=timing.png
+  binary id=unverified name=unverified.png
+  binary id=up name=up.png
+  binary id=video name=video.png
diff -Nru higan/target-ethos/resource/resource.cpp higan/target-ethos/resource/resource.cpp
--- higan/target-ethos/resource/resource.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/target-ethos/resource/resource.cpp	2015-09-16 14:06:03.410919282 +0900
@@ -0,0 +1,411 @@
+namespace resource {
+
+const uint8_t advanced[611] = {
+  137,80,78,71,13,10,26,10,0,0,0,13,73,72,68,82,0,0,0,16,0,0,0,16,8,6,0,0,0,31,243,255,
+  97,0,0,0,6,98,75,71,68,0,255,0,255,0,255,160,189,167,147,0,0,0,9,112,72,89,115,0,0,11,19,0,
+  0,11,19,1,0,154,156,24,0,0,0,7,116,73,77,69,7,213,9,26,12,19,57,139,99,194,72,0,0,1,240,73,
+  68,65,84,56,203,165,146,75,104,19,97,20,133,191,153,248,76,138,77,20,10,130,74,176,204,198,133,182,221,69,172,46,
+  52,20,98,102,235,66,112,33,84,164,168,181,45,18,82,2,21,3,67,66,160,107,65,116,101,64,138,226,194,137,141,208,
+  98,87,130,210,54,137,73,23,21,130,85,105,211,151,134,32,68,68,58,51,110,102,134,49,29,235,194,179,251,185,231,156,
+  123,239,185,63,252,39,4,231,35,157,81,162,128,10,200,241,88,34,247,23,77,52,157,81,108,142,216,82,84,251,175,246,
+  3,168,166,153,171,248,250,181,1,205,108,180,29,233,140,98,52,26,117,35,157,81,12,247,90,195,170,69,1,196,116,70,
+  137,90,100,171,171,215,219,230,102,28,5,120,240,240,62,241,88,66,6,114,0,34,160,14,222,28,50,158,62,155,48,0,
+  245,246,173,17,54,215,215,144,58,37,234,245,175,247,90,179,137,221,25,21,44,49,128,96,21,111,12,12,26,154,182,37,
+  232,186,110,232,186,70,97,126,78,40,188,47,2,200,59,5,43,180,116,176,17,233,187,72,185,82,97,185,246,5,32,25,
+  143,37,238,254,243,140,78,188,202,191,52,74,149,18,221,39,123,40,150,11,152,19,76,2,186,171,65,48,146,58,12,212,
+  172,247,149,144,78,215,9,137,163,71,142,209,108,54,121,55,247,22,183,53,60,78,241,248,112,152,190,80,39,29,1,47,
+  217,153,77,142,183,127,75,46,125,94,58,215,125,170,135,128,63,192,74,109,249,242,133,240,249,249,233,169,215,85,192,0,
+  16,131,145,84,23,80,123,52,38,51,91,94,100,182,188,72,199,65,31,0,230,222,114,46,255,2,73,146,56,123,186,215,
+  250,100,118,30,34,80,28,31,14,51,245,166,196,150,166,35,238,243,179,81,111,218,35,154,35,203,217,39,143,57,208,238,
+  231,76,168,23,96,204,105,0,192,238,93,30,246,248,14,241,243,199,47,178,249,5,128,112,171,73,46,175,82,253,88,253,
+  35,108,17,96,101,227,59,251,125,1,218,246,122,120,62,243,1,32,252,105,114,116,218,73,52,77,146,107,235,171,11,64,
+  210,190,66,48,146,186,4,76,56,184,219,196,59,225,55,55,226,213,246,234,188,84,188,0,0,0,0,73,69,78,68,174,
+  66,96,130,
+};
+
+const uint8_t audio[592] = {
+  137,80,78,71,13,10,26,10,0,0,0,13,73,72,68,82,0,0,0,16,0,0,0,16,8,6,0,0,0,31,243,255,
+  97,0,0,0,4,115,66,73,84,8,8,8,8,124,8,100,136,0,0,0,25,116,69,88,116,83,111,102,116,119,97,114,
+  101,0,119,119,119,46,105,110,107,115,99,97,112,101,46,111,114,103,155,238,60,26,0,0,1,226,73,68,65,84,56,141,
+  165,147,191,79,83,81,20,199,63,231,246,245,165,68,168,3,193,201,63,64,99,66,4,139,128,113,100,241,71,88,40,88,
+  162,46,36,242,106,58,233,0,127,132,49,93,173,12,13,137,160,169,105,2,196,133,196,168,131,131,137,16,23,69,172,147,
+  58,176,184,152,247,76,244,93,222,61,14,198,218,22,140,65,191,227,57,159,156,123,190,223,123,175,168,42,255,35,243,167,
+  70,126,58,159,11,130,32,253,79,3,10,133,137,193,20,242,56,142,227,212,129,7,20,10,19,131,105,63,243,84,85,179,
+  173,245,161,224,94,112,122,118,121,172,147,247,46,77,79,134,64,198,243,188,175,168,222,73,251,153,235,51,51,51,217,202,
+  221,74,210,10,58,167,239,141,104,53,23,60,236,223,168,76,126,105,110,32,72,166,124,187,236,205,207,205,31,86,152,43,
+  149,74,217,209,145,51,120,158,7,64,110,118,169,56,114,109,233,232,230,194,213,39,10,235,104,124,179,205,130,162,244,245,
+  29,225,248,177,19,168,170,12,156,60,69,38,211,133,136,0,32,66,111,34,148,1,68,101,69,144,209,61,25,188,217,122,
+  205,187,198,91,0,26,141,109,182,183,183,176,214,2,144,114,44,2,99,34,136,26,247,10,116,72,4,105,102,0,16,134,
+  97,115,101,187,107,81,126,191,141,93,163,137,168,164,0,172,209,196,79,164,45,120,3,16,70,33,97,20,162,170,216,216,
+  98,99,219,4,4,83,64,244,153,42,234,37,169,1,96,83,91,78,48,0,81,20,177,179,179,3,192,135,79,31,137,109,
+  220,26,191,167,164,111,252,132,245,130,194,139,182,107,84,85,173,215,235,137,136,88,35,102,113,117,117,229,242,248,197,241,
+  238,95,192,203,133,43,183,0,134,139,247,71,129,60,98,250,59,45,244,168,106,183,115,174,123,121,233,65,209,126,79,206,
+  173,61,90,139,156,115,109,94,93,226,134,65,139,27,149,233,207,173,117,217,239,51,77,77,77,157,197,184,245,67,93,61,
+  189,213,106,245,219,30,160,51,196,78,213,106,181,231,56,115,222,247,253,100,191,254,95,55,56,136,126,0,228,148,200,42,
+  201,231,90,24,0,0,0,0,73,69,78,68,174,66,96,130,
+};
+
+const uint8_t cheatEditor[937] = {
+  137,80,78,71,13,10,26,10,0,0,0,13,73,72,68,82,0,0,0,16,0,0,0,16,8,6,0,0,0,31,243,255,
+  97,0,0,0,6,98,75,71,68,0,255,0,255,0,255,160,189,167,147,0,0,0,9,112,72,89,115,0,0,11,19,0,
+  0,11,19,1,0,154,156,24,0,0,0,7,116,73,77,69,7,213,11,28,23,56,34,56,174,182,224,0,0,3,54,73,
+  68,65,84,56,203,93,147,75,76,92,117,20,198,191,255,99,230,222,121,128,115,65,96,102,128,162,19,4,154,73,83,19,
+  23,197,87,221,24,74,210,141,169,85,27,31,171,54,193,84,107,213,210,102,72,67,26,98,162,13,148,88,155,52,172,76,
+  136,143,133,27,92,17,18,187,168,166,52,93,24,181,117,12,29,168,52,242,152,41,101,24,198,14,51,112,231,206,253,255,
+  143,27,192,73,191,213,57,223,201,247,203,73,78,14,195,182,70,70,47,246,2,248,206,52,205,135,167,62,248,56,142,42,
+  141,140,94,28,147,82,190,245,201,233,254,186,106,127,122,28,239,241,157,70,8,49,241,225,201,211,150,109,219,139,87,199,
+  174,12,238,248,151,191,26,205,28,234,233,237,3,112,231,177,240,203,0,190,222,5,40,165,204,123,243,179,252,196,241,190,
+  30,165,212,126,0,24,190,244,197,43,209,230,104,164,88,218,96,90,235,238,170,112,59,227,98,146,49,225,217,5,112,206,
+  75,11,11,255,192,52,12,86,46,151,227,87,199,174,12,74,41,175,197,98,49,172,60,88,209,90,235,249,237,176,197,133,
+  184,222,209,253,105,80,120,106,84,245,6,61,169,84,10,203,233,37,118,226,120,95,167,109,219,239,119,117,117,121,24,56,
+  230,239,207,3,192,15,211,227,240,112,33,166,90,227,71,155,234,90,14,49,0,216,5,156,235,31,184,197,57,95,156,155,
+  155,133,105,152,204,10,89,81,210,64,118,109,85,3,152,60,123,38,241,25,23,98,188,190,249,192,254,104,199,155,30,80,
+  9,68,244,63,0,0,180,214,71,102,238,206,208,234,234,10,92,229,98,99,163,128,100,50,233,0,24,186,249,13,63,239,
+  15,181,189,22,123,238,148,233,22,39,161,221,13,0,143,1,206,158,73,252,198,57,255,118,118,46,165,67,161,16,50,15,
+  50,68,68,227,207,215,39,158,242,120,107,207,119,118,15,248,221,210,52,42,91,139,208,202,6,136,192,170,1,19,225,240,
+  168,75,116,210,205,231,77,184,46,158,14,55,33,77,122,51,120,208,246,190,112,105,64,74,190,134,98,238,6,12,211,132,
+  55,244,6,110,255,148,80,2,0,38,34,145,193,35,149,202,245,78,203,234,14,9,33,149,114,169,236,58,168,11,212,176,
+  70,211,240,24,203,38,255,117,120,10,158,198,28,178,91,119,17,106,108,2,247,182,99,245,254,207,196,127,140,70,223,117,
+  114,185,161,206,112,88,207,44,45,93,43,108,109,58,249,194,6,247,29,214,45,66,50,252,107,151,80,136,153,104,111,168,
+  71,50,49,135,252,148,68,197,113,160,221,50,8,4,238,58,206,240,190,214,86,74,45,47,95,56,166,84,111,173,233,83,
+  194,231,83,141,175,243,239,255,206,172,32,24,12,32,254,101,3,242,47,173,185,123,163,17,42,222,240,66,85,42,112,221,
+  77,128,8,28,229,114,189,227,56,234,152,82,159,79,6,2,151,61,82,154,194,66,193,111,181,31,8,61,187,7,126,146,
+  184,55,244,23,204,87,183,36,24,49,93,208,112,29,7,170,178,9,128,32,225,245,102,130,126,255,158,219,109,109,101,173,
+  181,156,89,75,23,155,47,60,225,111,217,123,212,8,156,251,5,201,143,254,64,199,157,48,42,191,215,64,107,130,172,149,
+  80,218,221,6,0,226,109,203,202,165,215,215,95,92,119,28,153,103,196,194,253,90,60,115,248,29,131,115,15,140,134,39,
+  97,68,235,144,94,200,34,155,45,224,145,87,33,62,114,16,190,72,12,68,12,143,30,254,73,172,234,65,246,1,184,197,
+  152,52,133,244,59,0,1,68,219,83,218,61,53,237,212,68,80,202,246,253,7,17,166,115,66,199,238,239,170,0,0,0,
+  0,73,69,78,68,174,66,96,130,
+};
+
+const uint8_t folder[1176] = {
+  137,80,78,71,13,10,26,10,0,0,0,13,73,72,68,82,0,0,0,32,0,0,0,32,8,6,0,0,0,115,122,122,
+  244,0,0,0,4,115,66,73,84,8,8,8,8,124,8,100,136,0,0,0,9,112,72,89,115,0,0,13,215,0,0,13,
+  215,1,66,40,155,120,0,0,0,25,116,69,88,116,83,111,102,116,119,97,114,101,0,119,119,119,46,105,110,107,115,99,
+  97,112,101,46,111,114,103,155,238,60,26,0,0,4,21,73,68,65,84,88,133,237,151,61,111,28,69,24,199,127,51,187,
+  119,123,175,246,57,145,48,9,5,86,148,194,31,0,9,5,33,83,110,149,130,26,137,2,90,58,62,64,36,62,64,74,
+  132,68,133,104,161,67,72,167,64,23,201,138,2,138,210,69,194,198,196,40,22,198,247,186,119,222,151,153,157,25,138,123,
+  201,58,119,142,19,114,82,40,248,75,143,118,118,118,247,121,126,243,60,51,179,187,34,12,67,94,167,228,107,141,254,95,
+  0,240,1,110,220,184,225,43,165,126,54,198,188,119,209,3,66,136,220,90,251,249,195,135,15,191,92,25,64,154,166,91,
+  149,74,229,157,155,55,111,250,73,146,224,156,3,192,90,11,48,63,159,182,253,59,119,238,220,222,222,222,254,254,209,163,
+  71,199,43,1,80,74,101,213,106,213,29,29,29,209,233,116,112,206,45,53,0,33,4,155,155,155,249,193,193,193,71,192,
+  237,149,0,104,173,211,44,203,196,165,75,27,24,99,176,214,158,9,92,204,132,16,130,106,181,90,63,60,60,252,98,123,
+  123,251,214,172,127,153,156,115,218,90,251,241,222,222,222,143,207,5,0,178,44,203,188,78,167,75,167,211,153,3,204,142,
+  179,32,197,64,91,91,91,245,70,163,65,179,217,68,8,129,16,2,0,41,229,188,29,69,17,247,238,221,187,5,60,31,
+  224,242,229,203,105,191,223,247,54,54,90,104,173,23,0,150,149,98,166,56,142,1,230,16,69,139,227,24,99,76,237,188,
+  224,115,128,221,221,93,117,237,218,53,217,235,245,230,25,0,150,130,204,178,81,212,108,196,197,224,82,202,25,64,229,66,
+  0,0,99,140,109,54,215,100,154,102,220,63,180,220,221,63,27,228,188,58,63,171,25,204,228,153,22,206,93,185,206,219,
+  31,232,226,61,158,39,190,93,255,253,155,79,206,0,56,231,116,183,219,245,187,221,46,143,59,13,62,253,240,93,174,191,
+  181,81,112,54,61,62,47,250,18,200,105,207,60,206,147,206,152,175,190,187,255,254,236,188,152,1,221,104,212,171,90,107,
+  212,31,146,102,181,204,254,223,99,162,56,159,140,108,233,104,207,35,17,11,77,1,52,42,62,42,211,8,65,103,118,121,
+  190,21,27,99,116,191,63,160,219,237,18,103,150,122,181,132,53,147,27,228,212,193,179,134,59,207,220,83,179,19,179,214,
+  145,100,134,52,203,193,137,249,6,86,44,65,86,169,4,180,90,45,50,35,168,5,37,172,83,120,114,53,175,139,113,154,
+  83,111,250,140,134,57,214,186,39,11,0,121,158,171,40,26,209,239,15,208,230,13,170,129,143,115,14,79,158,155,231,23,
+  147,131,81,170,209,185,37,240,37,113,170,173,49,249,209,2,128,49,38,43,151,75,84,155,27,172,213,202,56,64,10,177,
+  188,248,47,40,227,28,163,84,147,91,135,231,9,130,178,199,105,146,41,33,196,201,2,128,181,54,27,141,198,28,15,20,
+  235,245,75,232,220,190,210,232,51,109,137,51,3,78,224,79,253,148,61,201,232,84,229,130,167,147,176,152,129,212,247,125,
+  188,32,160,73,153,76,217,11,131,76,230,152,195,186,201,62,97,236,196,84,110,151,173,72,156,131,193,40,181,185,115,139,
+  0,214,218,100,60,30,211,25,248,84,90,101,162,68,147,233,233,75,8,200,141,69,27,135,206,45,185,153,110,203,47,153,
+  149,68,25,134,227,196,19,210,91,90,130,84,8,129,12,26,148,74,62,163,68,19,37,154,84,25,148,182,47,29,108,153,
+  226,44,231,52,209,62,231,148,32,142,227,83,122,81,133,74,13,30,159,196,12,99,189,212,209,191,145,0,134,177,66,25,
+  83,250,245,234,94,47,124,252,12,128,181,54,6,129,245,107,100,185,37,138,53,74,95,60,15,94,84,82,10,78,134,9,
+  82,200,56,220,221,157,59,62,51,7,146,36,33,74,12,87,175,4,84,3,143,160,188,186,111,86,41,4,105,170,144,82,
+  12,139,253,197,18,36,0,154,18,235,85,143,122,105,21,85,127,42,231,28,253,36,65,88,59,88,0,104,183,219,98,103,
+  103,199,68,177,98,112,234,248,243,100,136,236,190,226,14,184,68,199,199,67,155,36,195,7,187,237,118,45,12,195,120,14,
+  0,120,81,20,253,244,203,161,248,76,173,227,255,182,255,202,31,187,103,228,192,2,88,157,30,28,63,248,225,235,226,53,
+  49,251,53,107,183,219,205,96,109,237,205,90,208,218,116,56,41,133,92,201,18,200,141,49,42,75,107,185,16,121,62,58,
+  233,1,127,133,97,216,91,0,152,66,72,32,96,146,153,124,21,0,83,5,64,10,168,48,12,207,44,45,241,255,207,233,
+  235,6,248,7,188,50,165,151,203,8,55,43,0,0,0,0,73,69,78,68,174,66,96,130,
+};
+
+const uint8_t game[1490] = {
+  137,80,78,71,13,10,26,10,0,0,0,13,73,72,68,82,0,0,0,32,0,0,0,32,8,6,0,0,0,115,122,122,
+  244,0,0,0,4,115,66,73,84,8,8,8,8,124,8,100,136,0,0,5,137,73,68,65,84,88,133,237,150,91,108,20,
+  231,21,199,127,231,155,155,151,181,124,89,3,181,113,193,183,13,16,81,82,21,225,52,50,1,132,91,53,20,212,132,155,
+  212,84,149,18,161,40,82,213,151,72,68,81,108,212,74,121,168,122,81,165,190,24,171,125,141,218,226,66,171,66,91,37,
+  65,145,82,225,2,9,6,148,132,40,73,9,55,219,4,112,146,58,49,23,239,125,102,190,62,204,236,120,236,176,182,1,
+  169,79,29,233,232,236,203,156,255,239,252,207,249,190,29,248,255,115,31,79,182,135,157,153,94,116,102,47,91,239,181,134,
+  186,31,113,173,216,159,173,249,10,90,243,215,76,47,91,254,103,0,217,30,118,106,225,143,183,219,215,219,250,225,103,201,
+  180,173,179,53,28,186,23,136,187,6,8,58,151,253,147,233,13,142,151,106,97,226,76,63,238,194,54,50,237,143,222,19,
+  132,220,173,56,134,57,144,95,243,3,43,111,8,147,31,253,3,180,7,98,80,189,226,123,152,159,95,102,193,197,227,69,
+  129,237,201,95,240,234,124,106,206,219,129,108,47,59,48,204,1,111,211,139,150,145,254,22,217,11,175,160,68,163,148,66,
+  137,38,123,225,21,252,133,105,114,233,245,129,19,123,249,238,124,234,206,203,129,108,47,59,180,48,224,111,124,193,150,150,
+  46,138,19,23,64,107,4,184,253,225,1,220,155,163,160,65,139,34,153,222,140,57,62,76,213,197,227,69,17,182,37,127,
+  206,107,179,213,158,211,129,64,92,6,178,15,108,180,189,134,86,74,19,23,17,64,68,16,17,204,68,93,224,130,161,80,
+  2,185,203,175,227,54,180,145,79,175,179,181,230,240,92,78,204,234,64,36,158,126,212,246,83,203,64,187,56,141,107,65,
+  160,52,126,142,252,245,147,248,185,207,167,94,208,58,72,8,137,214,110,140,241,17,170,46,189,57,171,19,21,29,200,246,
+  176,93,139,12,228,210,235,108,63,245,85,242,163,255,68,187,249,168,115,63,51,6,133,137,160,251,40,12,68,41,148,8,
+  249,43,71,241,26,150,145,111,127,196,22,164,226,78,220,17,32,219,195,118,95,228,79,217,116,151,237,213,53,147,191,50,
+  136,8,129,128,8,34,10,17,65,41,99,70,168,169,12,20,174,30,195,91,216,66,182,173,211,169,4,241,37,128,178,120,
+  174,227,17,219,175,91,66,225,234,49,20,160,68,161,172,5,80,158,125,205,82,204,228,226,105,226,18,101,21,65,20,175,
+  158,192,75,45,37,219,182,214,17,228,208,100,15,155,43,2,100,122,217,22,136,63,108,251,117,77,20,174,190,137,8,72,
+  185,168,83,27,117,111,47,92,73,242,107,79,97,47,94,61,189,243,16,72,194,113,136,64,113,108,8,175,174,153,108,235,
+  26,71,41,57,28,135,136,0,244,75,40,224,80,177,190,209,102,201,215,41,140,157,14,108,151,169,249,154,53,205,136,72,
+  232,66,0,34,165,201,169,217,71,89,97,88,85,88,245,29,40,195,10,156,248,236,29,212,3,143,81,168,89,236,136,76,
+  45,100,4,32,47,225,227,179,205,158,248,164,40,215,222,193,105,90,19,21,20,81,24,201,69,40,59,137,136,160,115,227,
+  228,222,221,71,238,221,126,252,204,245,72,220,176,18,209,8,140,154,165,44,88,190,29,179,182,5,49,76,18,45,221,56,
+  185,12,206,237,255,20,181,158,218,133,105,35,72,254,138,191,9,250,251,137,225,51,69,243,198,117,236,198,111,32,202,68,
+  148,194,94,180,122,234,4,220,188,140,200,116,203,205,234,38,18,15,61,131,149,90,142,89,221,136,149,90,142,8,36,58,
+  182,80,219,245,83,18,84,33,39,250,139,190,231,63,81,253,75,142,68,141,223,233,20,100,122,217,134,200,129,98,251,90,
+  219,79,53,225,223,184,68,98,245,110,148,225,128,8,197,243,127,70,231,198,131,113,68,173,88,56,171,118,163,37,236,73,
+  107,52,160,18,13,232,145,33,244,241,254,146,246,220,199,227,226,21,1,166,65,164,59,109,107,197,86,84,162,1,9,174,
+  64,40,78,226,126,252,6,160,49,106,59,240,198,223,195,88,210,133,170,237,8,133,53,104,144,170,122,244,232,16,254,177,
+  59,139,207,10,80,134,208,168,131,170,251,121,75,45,93,131,206,127,17,118,45,248,55,47,66,225,38,102,227,90,180,214,
+  81,169,224,183,6,39,20,255,215,190,138,226,115,2,64,120,47,24,230,65,99,211,30,83,39,171,241,174,31,199,168,107,
+  71,223,56,15,94,1,107,229,15,65,153,83,215,176,214,96,215,161,71,79,226,205,33,62,47,128,50,132,54,140,3,254,
+  242,78,75,234,27,17,237,66,241,22,214,146,46,164,174,131,80,25,173,65,236,26,252,209,33,188,193,190,146,214,238,19,
+  115,253,27,206,247,131,196,248,108,15,59,146,85,242,7,86,126,211,182,59,127,140,246,242,168,240,78,40,3,96,85,227,
+  141,156,194,27,236,43,77,228,220,93,205,191,225,53,192,3,252,138,133,103,17,85,128,13,84,1,206,175,223,98,244,201,
+  85,92,72,101,174,109,241,201,24,102,115,39,248,110,112,52,145,72,188,52,216,231,190,255,169,251,244,131,253,28,5,204,
+  80,163,124,220,191,4,82,9,192,2,156,153,241,219,51,92,249,118,27,151,155,115,195,223,145,69,29,134,170,95,134,248,
+  46,88,73,252,145,33,74,131,125,238,209,97,247,71,221,47,115,44,38,94,6,80,4,142,135,91,90,25,192,8,1,236,
+  88,68,16,47,159,229,90,103,147,30,110,187,117,170,91,26,90,149,212,183,226,143,156,164,56,216,231,30,254,183,187,103,
+  215,65,222,10,197,227,162,241,81,107,130,177,204,10,96,134,16,102,8,80,6,114,0,231,192,7,140,173,72,249,87,86,
+  76,158,218,160,111,127,170,74,111,255,197,251,253,89,247,39,207,252,157,211,49,209,184,160,31,134,23,203,21,1,252,24,
+  189,17,203,101,48,3,176,14,159,99,172,165,198,191,182,218,26,89,255,187,51,254,207,158,59,194,233,25,66,238,140,40,
+  197,34,26,193,108,167,160,188,7,118,44,199,195,138,1,150,187,44,11,20,103,68,33,150,167,45,226,124,142,97,121,28,
+  54,211,71,83,22,143,47,150,23,235,62,14,51,173,235,187,5,184,211,59,113,241,114,141,153,179,158,215,243,95,119,198,
+  63,107,9,247,71,127,0,0,0,0,73,69,78,68,174,66,96,130,
+};
+
+const uint8_t home[606] = {
+  137,80,78,71,13,10,26,10,0,0,0,13,73,72,68,82,0,0,0,16,0,0,0,16,8,6,0,0,0,31,243,255,
+  97,0,0,0,6,98,75,71,68,0,0,0,0,0,0,249,67,187,127,0,0,0,9,112,72,89,115,0,0,13,215,0,
+  0,13,215,1,66,40,155,120,0,0,0,7,116,73,77,69,7,213,10,14,20,37,19,83,42,210,59,0,0,1,235,73,
+  68,65,84,56,203,149,147,191,107,83,81,20,128,191,123,251,222,75,211,64,242,36,160,85,135,100,81,123,19,104,85,172,
+  17,92,28,140,66,19,167,135,212,74,39,145,162,163,24,92,58,180,110,193,169,254,24,234,212,37,139,245,199,96,19,240,
+  15,240,63,16,121,91,92,196,90,219,240,98,81,137,33,121,215,33,246,217,151,80,33,103,186,92,206,247,221,115,14,231,
+  194,1,225,41,85,172,128,174,128,246,148,122,200,48,177,7,123,74,105,79,169,61,73,113,104,120,177,56,163,203,55,111,
+  252,87,34,250,225,154,235,110,20,148,98,253,220,89,182,39,78,113,228,240,56,39,188,38,83,107,107,212,92,151,130,82,
+  215,14,185,110,117,64,176,31,126,83,156,97,247,248,49,148,202,50,22,141,210,106,181,24,219,252,74,182,92,30,144,136,
+  126,184,122,251,22,157,100,146,116,42,77,42,149,2,64,107,104,183,219,236,214,235,156,44,149,66,18,177,31,126,247,160,
+  68,199,48,201,229,46,96,219,118,208,154,214,26,0,223,247,249,185,181,69,114,110,46,144,136,10,232,130,82,188,127,84,
+  198,107,54,57,63,157,35,30,143,35,132,8,9,124,223,15,206,134,16,140,230,243,212,92,23,3,184,3,172,78,157,62,
+  195,253,210,61,54,170,111,3,240,201,202,51,86,30,63,69,139,17,116,167,133,48,70,209,221,223,44,47,45,209,238,165,
+  204,202,121,120,190,48,153,33,17,79,0,160,212,4,153,140,34,155,205,244,94,20,146,145,244,149,222,196,83,121,144,22,
+  90,107,22,38,51,204,195,186,236,239,211,178,44,76,211,196,48,140,224,254,75,227,7,0,31,234,59,116,187,126,144,11,
+  48,32,144,82,34,165,196,146,159,1,232,96,241,241,83,3,128,111,222,47,58,34,18,90,36,99,96,179,254,14,207,231,
+  40,0,151,46,78,115,53,26,67,234,113,46,75,147,237,77,66,21,24,253,21,252,155,126,239,165,239,222,14,162,217,56,
+  112,245,3,65,36,18,193,182,109,18,137,4,2,137,16,16,139,197,112,28,103,0,178,44,43,252,23,174,207,58,175,0,
+  135,225,98,245,229,139,215,119,255,0,86,248,213,163,133,187,128,26,0,0,0,0,73,69,78,68,174,66,96,130,
+};
+
+const uint8_t hotkeys[587] = {
+  137,80,78,71,13,10,26,10,0,0,0,13,73,72,68,82,0,0,0,16,0,0,0,16,8,6,0,0,0,31,243,255,
+  97,0,0,0,4,115,66,73,84,8,8,8,8,124,8,100,136,0,0,0,9,112,72,89,115,0,0,13,215,0,0,13,
+  215,1,66,40,155,120,0,0,0,25,116,69,88,116,83,111,102,116,119,97,114,101,0,119,119,119,46,105,110,107,115,99,
+  97,112,101,46,111,114,103,155,238,60,26,0,0,1,200,73,68,65,84,56,141,181,146,177,107,83,81,20,198,127,247,222,
+  115,95,95,8,73,159,136,180,209,38,177,21,7,165,21,26,16,204,228,34,102,8,8,34,212,168,127,72,193,191,160,131,
+  45,174,29,178,184,180,116,17,212,12,25,4,23,137,32,168,56,85,227,146,162,85,112,145,212,190,151,52,125,185,14,109,
+  53,29,164,193,226,7,151,115,46,231,124,223,189,231,240,169,82,169,196,113,160,15,146,122,189,174,142,37,48,191,48,159,
+  30,134,80,169,84,252,193,187,58,24,161,88,156,157,242,60,223,3,239,187,136,216,100,210,88,99,196,199,152,139,190,245,
+  175,2,87,28,76,3,30,74,189,72,38,82,229,106,181,26,203,31,45,127,195,57,123,201,250,186,108,69,143,59,103,50,
+  32,99,86,108,216,239,179,174,148,187,15,242,174,213,106,253,204,159,157,104,110,111,255,40,0,175,127,11,52,26,141,93,
+  224,205,254,249,219,247,131,252,228,196,50,142,157,173,173,206,251,67,59,56,10,115,119,230,174,163,226,183,202,169,200,104,
+  175,80,171,213,186,0,114,20,113,239,229,91,151,193,61,82,112,111,101,101,237,249,96,77,45,173,45,37,78,118,131,166,
+  159,24,57,163,181,70,27,141,86,123,209,104,131,214,10,173,13,206,57,0,246,123,94,61,88,120,88,4,144,157,86,120,
+  45,83,184,112,106,102,122,6,107,61,68,4,43,22,99,4,173,13,56,71,223,245,137,162,136,48,10,49,90,211,104,188,
+  156,173,84,110,158,95,93,125,220,20,17,239,118,144,62,225,133,97,135,205,175,159,72,37,211,160,0,20,74,41,218,237,
+  54,249,92,142,56,142,249,178,249,153,108,54,79,106,52,144,245,15,31,111,0,139,98,180,46,7,65,0,206,145,61,157,
+  99,183,31,31,154,127,52,157,166,215,235,1,138,169,201,115,116,186,93,50,99,227,102,196,179,119,129,69,137,227,120,227,
+  233,179,39,90,169,225,157,236,156,3,199,55,24,112,226,191,98,104,31,252,55,129,95,252,113,137,228,164,151,154,151,0,
+  0,0,0,73,69,78,68,174,66,96,130,
+};
+
+const uint8_t input[812] = {
+  137,80,78,71,13,10,26,10,0,0,0,13,73,72,68,82,0,0,0,16,0,0,0,16,8,6,0,0,0,31,243,255,
+  97,0,0,0,6,98,75,71,68,0,172,0,77,0,0,52,214,215,123,0,0,0,9,112,72,89,115,0,0,11,19,0,
+  0,11,19,1,0,154,156,24,0,0,0,7,116,73,77,69,7,213,4,7,15,10,39,178,201,163,153,0,0,0,140,116,
+  69,88,116,67,111,109,109,101,110,116,0,77,101,110,117,45,115,105,122,101,100,32,105,99,111,110,10,61,61,61,61,61,
+  61,61,61,61,61,10,10,40,99,41,32,50,48,48,51,32,74,97,107,117,98,32,39,106,105,109,109,97,99,39,32,83,
+  116,101,105,110,101,114,44,32,10,104,116,116,112,58,47,47,106,105,109,109,97,99,46,109,117,115,105,99,104,97,108,108,
+  46,99,122,10,10,99,114,101,97,116,101,100,32,119,105,116,104,32,116,104,101,32,71,73,77,80,44,10,104,116,116,112,
+  58,47,47,119,119,119,46,103,105,109,112,46,111,114,103,103,138,199,71,0,0,2,33,73,68,65,84,56,203,149,146,203,
+  107,83,65,20,198,127,147,220,228,38,214,210,164,177,54,245,209,135,160,184,73,176,20,255,130,130,123,17,138,136,130,168,
+  32,88,8,193,133,173,15,180,221,136,46,68,10,10,130,72,22,93,213,186,19,68,208,133,187,34,84,179,19,68,20,42,
+  21,53,53,183,105,244,230,117,111,230,184,184,105,154,66,178,232,129,3,195,240,205,55,191,249,230,40,58,212,199,179,132,
+  255,170,221,51,97,41,95,2,124,235,42,178,96,80,191,58,62,95,40,181,234,84,167,195,117,124,223,250,14,237,141,27,
+  225,16,162,53,142,93,102,237,251,186,181,161,122,6,79,204,231,237,77,173,175,157,129,70,165,99,67,177,184,175,43,140,
+  235,247,99,21,107,216,174,143,129,35,253,189,192,253,86,173,175,195,11,82,129,93,97,252,166,137,17,12,16,12,26,252,
+  94,181,136,14,198,137,200,198,153,86,161,145,74,79,206,0,119,90,55,203,86,6,167,84,193,202,217,116,71,187,40,230,
+  255,225,214,28,220,170,67,69,153,209,84,250,178,52,164,179,42,149,158,148,185,135,143,182,93,255,235,229,61,170,203,115,
+  88,185,34,249,181,18,162,96,223,240,30,162,177,46,234,135,47,112,240,212,109,108,219,230,198,173,41,12,0,173,53,133,
+  66,97,11,235,248,57,114,111,30,211,63,212,199,200,104,15,134,25,160,248,243,15,185,85,135,3,231,47,98,89,22,65,
+  51,184,149,129,104,241,90,188,86,129,16,3,215,151,88,212,167,249,186,244,133,207,239,62,241,170,52,206,254,155,239,81,
+  129,16,34,2,141,71,120,4,162,209,34,32,226,125,172,0,134,137,27,234,101,228,193,42,43,43,43,228,223,190,134,128,
+  137,214,26,192,51,105,18,136,96,189,184,198,143,233,97,214,23,167,26,68,26,183,238,182,36,35,72,93,35,186,209,13,
+  3,163,153,252,242,2,82,43,81,90,94,160,251,228,93,0,142,37,71,121,250,236,73,115,93,23,221,68,111,230,181,25,
+  98,104,108,130,202,135,231,132,198,38,208,90,163,68,72,36,146,36,18,73,68,20,74,137,135,223,48,216,70,96,154,38,
+  71,175,100,128,76,219,169,178,109,111,114,203,229,50,0,149,74,101,59,65,54,155,197,117,93,118,82,74,169,45,131,72,
+  36,210,68,2,168,86,171,0,212,106,181,142,6,142,227,120,70,237,70,121,7,53,251,31,168,192,0,159,97,230,172,204,
+  0,0,0,0,73,69,78,68,174,66,96,130,
+};
+
+const uint8_t server[408] = {
+  137,80,78,71,13,10,26,10,0,0,0,13,73,72,68,82,0,0,0,16,0,0,0,16,8,6,0,0,0,31,243,255,
+  97,0,0,0,6,98,75,71,68,0,0,0,0,0,0,249,67,187,127,0,0,0,9,112,72,89,115,0,0,11,18,0,
+  0,11,18,1,210,221,126,252,0,0,0,7,116,73,77,69,7,214,2,16,22,3,20,11,54,9,17,0,0,1,37,73,
+  68,65,84,56,203,157,146,61,75,195,80,20,134,159,155,92,242,63,164,46,221,2,226,238,32,226,38,82,255,131,17,10,
+  34,56,74,196,42,232,228,80,63,210,95,32,4,99,5,255,134,131,110,46,130,56,152,22,170,129,214,170,225,82,18,7,
+  13,26,242,97,240,29,207,121,207,203,121,206,189,130,2,181,246,182,61,160,65,185,58,178,164,217,88,152,95,164,86,55,
+  115,155,131,167,7,188,174,107,149,5,80,171,155,44,55,47,48,140,180,77,169,9,87,206,10,0,165,1,66,8,12,67,
+  98,206,78,3,49,32,0,184,189,190,39,138,190,60,178,140,245,180,189,207,220,20,168,151,30,143,98,134,247,15,197,235,
+  56,76,121,100,69,86,122,207,111,223,21,29,128,56,142,127,16,170,176,70,163,97,170,254,123,131,74,172,238,225,82,102,
+  179,204,17,117,93,163,63,24,231,178,58,71,7,121,132,118,42,224,230,174,15,177,200,101,93,91,109,166,38,53,77,227,
+  196,105,183,100,98,82,106,130,49,28,101,110,144,40,8,130,220,35,203,132,231,242,184,81,248,10,0,238,249,89,97,64,
+  199,235,186,214,31,127,222,182,183,118,118,139,2,172,141,245,77,194,48,204,157,76,88,129,194,0,124,223,231,191,146,101,
+  124,85,244,9,241,192,132,130,214,14,135,66,0,0,0,0,73,69,78,68,174,66,96,130,
+};
+
+const uint8_t stateManager[378] = {
+  137,80,78,71,13,10,26,10,0,0,0,13,73,72,68,82,0,0,0,16,0,0,0,16,8,6,0,0,0,31,243,255,
+  97,0,0,0,6,98,75,71,68,0,0,0,0,0,0,249,67,187,127,0,0,0,9,112,72,89,115,0,0,13,215,0,
+  0,13,215,1,66,40,155,120,0,0,0,7,116,73,77,69,7,213,6,16,18,41,48,44,67,93,90,0,0,1,7,73,
+  68,65,84,56,203,189,146,189,74,3,65,28,196,127,251,145,69,177,176,73,44,124,128,128,207,225,19,8,130,136,31,129,
+  136,104,37,34,104,173,32,10,130,181,165,112,6,242,20,190,78,138,120,8,90,104,178,183,123,107,17,15,205,37,94,238,
+  82,56,229,252,255,59,179,179,179,226,168,221,4,216,19,130,136,10,8,129,125,224,73,103,135,175,78,46,73,146,1,225,
+  123,90,4,33,36,215,15,183,81,8,32,142,15,154,225,188,125,138,148,211,151,245,48,198,153,250,4,175,134,49,55,157,
+  14,58,35,30,163,59,250,214,148,186,254,138,177,180,118,47,70,6,25,217,183,134,237,213,151,82,2,221,94,131,193,231,
+  59,90,215,144,204,9,169,70,222,114,150,83,183,215,40,20,210,191,115,253,181,156,231,151,148,35,245,14,231,146,31,129,
+  245,250,219,92,81,52,128,181,31,60,199,203,149,90,216,202,71,168,218,130,79,253,236,71,44,213,6,64,234,221,255,182,
+  48,33,96,236,43,155,27,135,99,131,212,123,164,82,164,222,231,62,208,56,39,90,59,107,247,139,11,254,76,235,218,84,
+  7,231,146,194,8,95,134,90,101,183,231,143,210,134,0,0,0,0,73,69,78,68,174,66,96,130,
+};
+
+const uint8_t timing[897] = {
+  137,80,78,71,13,10,26,10,0,0,0,13,73,72,68,82,0,0,0,16,0,0,0,16,8,6,0,0,0,31,243,255,
+  97,0,0,0,6,98,75,71,68,0,0,0,0,0,0,249,67,187,127,0,0,0,9,112,72,89,115,0,0,13,215,0,
+  0,13,215,1,66,40,155,120,0,0,0,7,116,73,77,69,7,213,9,15,8,58,5,128,132,46,85,0,0,3,14,73,
+  68,65,84,56,203,101,146,75,76,92,101,28,197,127,223,119,239,188,152,185,119,96,34,8,210,202,35,88,29,108,48,150,
+  190,226,162,177,59,220,152,138,193,186,32,26,54,38,68,87,181,53,38,44,77,99,26,31,137,198,68,77,172,53,177,139,
+  62,240,17,77,76,163,46,176,5,77,85,40,5,58,88,43,218,17,233,76,167,204,12,195,204,189,195,12,119,190,207,141,
+  109,40,158,228,236,206,57,255,71,142,96,19,142,28,24,25,210,146,23,5,226,97,148,14,8,67,122,90,138,27,85,181,
+  126,230,157,207,94,127,101,179,94,108,48,246,104,248,116,247,190,71,123,182,247,198,9,71,194,8,1,90,67,113,181,196,
+  204,84,130,75,151,230,211,131,195,231,142,245,60,146,10,34,117,146,80,242,180,185,193,124,97,112,120,192,46,27,138,85,
+  159,131,40,190,118,103,138,221,113,140,120,224,65,26,59,83,205,141,205,149,55,61,189,115,213,208,191,172,8,183,93,73,
+  0,141,62,62,56,60,96,223,88,43,208,254,80,136,104,245,237,187,214,180,235,45,182,110,107,161,119,111,142,104,195,46,
+  131,192,187,13,200,167,163,192,14,121,228,192,200,208,238,125,59,118,150,180,71,91,87,35,45,91,226,155,207,68,74,137,
+  16,2,51,16,67,178,68,165,116,2,167,52,19,4,253,131,4,6,182,247,198,89,46,103,105,109,109,166,144,255,135,248,
+  227,167,72,103,125,119,63,75,8,42,94,31,158,232,39,149,172,114,242,195,7,170,120,242,156,169,209,123,194,145,48,150,
+  23,66,41,133,207,103,81,118,139,132,234,44,70,94,218,134,223,222,203,115,109,57,108,219,66,200,24,210,127,16,195,187,
+  201,194,212,199,209,161,23,250,131,18,168,23,2,154,154,26,200,23,242,40,165,168,41,141,227,20,57,250,222,239,68,98,
+  221,76,76,76,160,148,66,107,133,97,26,152,134,4,165,5,208,101,2,43,90,19,43,187,85,58,58,218,169,84,214,80,
+  74,81,44,22,233,238,238,230,229,195,175,114,237,218,85,106,181,26,82,74,180,82,104,13,72,52,176,32,5,226,162,83,
+  114,88,252,59,141,82,10,207,243,240,60,143,67,135,14,147,72,36,200,100,210,88,150,69,173,86,195,178,108,202,110,25,
+  167,228,128,207,112,63,57,253,150,35,129,179,115,147,243,216,134,133,83,114,241,249,252,140,141,141,49,58,58,74,42,181,
+  116,39,48,28,142,160,53,44,95,207,50,55,57,79,133,218,12,128,124,227,203,163,39,126,62,63,53,217,24,182,25,255,
+  254,87,180,214,244,245,61,65,58,157,98,173,82,65,107,77,32,16,192,52,77,242,153,28,238,178,203,197,31,167,171,95,
+  77,156,121,6,192,0,232,188,183,107,110,97,54,249,236,254,253,143,249,255,252,99,145,92,33,207,253,109,91,8,6,130,
+  4,131,33,252,190,0,55,255,202,144,191,190,194,201,15,206,234,217,165,217,247,167,230,127,154,3,178,6,192,76,114,58,
+  239,55,253,87,150,174,102,246,52,53,196,162,109,45,173,120,69,143,74,126,141,114,182,204,173,228,45,46,143,207,242,245,
+  231,223,174,143,255,118,225,248,249,233,239,190,1,210,64,78,108,232,74,61,208,249,228,174,254,231,239,187,103,235,83,117,
+  254,186,22,41,164,169,209,202,93,119,139,233,66,58,241,197,248,169,143,128,20,112,5,88,4,180,224,255,136,252,23,118,
+  155,26,40,3,171,64,22,40,0,234,182,248,95,201,36,100,6,22,194,54,223,0,0,0,0,73,69,78,68,174,66,96,
+  130,
+};
+
+const uint8_t unverified[1675] = {
+  137,80,78,71,13,10,26,10,0,0,0,13,73,72,68,82,0,0,0,32,0,0,0,32,8,6,0,0,0,115,122,122,
+  244,0,0,0,4,115,66,73,84,8,8,8,8,124,8,100,136,0,0,6,66,73,68,65,84,88,133,229,151,217,115,84,
+  85,30,199,191,231,119,238,146,78,210,183,59,107,147,116,167,151,132,152,72,132,208,128,27,13,9,104,160,28,202,146,161,
+  3,79,83,214,164,242,52,207,62,251,224,195,252,13,62,88,53,37,102,134,69,12,250,162,165,14,58,162,65,81,17,179,
+  66,7,59,91,111,233,108,244,96,210,33,73,247,237,123,231,161,23,110,98,2,1,103,158,230,86,253,234,156,170,123,239,
+  249,124,206,249,253,234,87,117,128,255,247,135,253,158,159,143,118,116,119,106,76,239,37,157,94,253,234,139,191,125,242,36,
+  107,208,239,129,103,152,126,94,177,213,32,67,218,135,109,199,186,78,60,201,58,252,73,225,26,99,231,188,190,131,242,169,
+  147,29,88,211,56,159,137,70,207,184,234,247,254,28,154,24,8,254,79,5,142,118,116,119,106,132,243,222,67,62,217,225,
+  170,195,59,189,223,224,224,179,45,40,85,20,30,143,68,30,91,226,177,4,142,118,116,119,130,211,133,87,94,123,69,42,
+  171,182,225,131,43,55,161,105,192,157,169,89,28,122,174,5,102,197,194,167,195,225,199,146,216,182,64,91,71,151,159,56,
+  191,248,122,215,105,241,233,150,167,240,246,197,175,0,157,65,32,2,17,67,48,52,7,223,129,93,48,91,44,60,22,10,
+  159,113,55,236,187,25,26,239,31,251,175,8,180,117,116,249,193,232,194,159,94,247,75,45,45,77,24,15,207,195,251,180,
+  19,7,118,185,112,247,94,18,43,171,105,16,99,24,11,207,227,57,111,19,20,139,149,71,67,83,219,146,120,164,64,91,
+  71,151,159,49,186,112,224,240,33,105,207,158,102,68,226,255,6,24,64,44,187,243,249,68,18,139,75,171,16,56,129,24,
+  195,100,100,1,251,91,159,202,74,132,31,45,241,80,129,60,124,223,33,159,84,235,172,67,96,124,6,85,21,102,16,17,
+  194,211,119,241,237,207,227,152,187,187,4,129,19,4,226,16,136,192,115,239,188,187,119,66,177,150,241,72,40,116,198,221,
+  224,221,82,98,203,62,208,126,172,251,20,35,186,224,245,249,164,29,14,59,62,191,54,130,180,154,1,39,2,103,12,137,
+  123,247,113,127,37,5,81,224,16,57,135,40,80,97,78,68,184,118,115,12,110,143,27,190,246,118,137,129,125,212,126,188,
+  251,15,219,22,104,63,214,125,10,76,191,232,61,152,133,255,235,251,81,112,70,133,99,38,202,206,69,158,135,103,71,129,
+  19,132,220,156,51,194,15,131,147,112,215,123,224,59,210,38,211,22,18,191,73,65,30,190,247,69,159,84,227,112,224,155,
+  159,126,1,129,65,224,4,119,109,5,170,203,205,32,98,208,52,29,43,43,41,168,25,173,112,244,198,84,8,156,192,25,
+  97,110,97,17,187,154,60,80,172,86,33,58,21,58,237,118,183,254,52,53,57,48,182,169,192,145,227,93,127,4,195,251,
+  173,47,100,119,254,93,255,120,1,46,16,161,209,85,13,171,82,12,98,12,101,74,49,26,221,54,164,83,42,150,150,215,
+  10,223,100,225,188,48,231,68,88,72,36,209,220,232,130,181,204,42,132,67,225,51,70,137,7,41,120,235,45,210,117,246,
+  81,149,221,37,181,182,54,227,198,208,36,56,123,144,87,145,115,216,42,20,112,198,178,117,64,12,196,24,86,83,234,186,
+  111,178,115,130,73,22,81,91,109,133,44,8,224,140,16,28,159,197,97,223,126,212,185,93,178,78,236,211,223,158,192,213,
+  171,122,125,189,119,96,121,121,209,207,4,19,111,110,116,98,62,177,84,200,125,185,165,4,205,245,59,64,68,88,76,174,
+  224,202,181,0,198,166,230,145,74,169,133,221,154,100,17,12,217,230,100,171,84,240,236,30,55,146,203,107,72,165,51,216,
+  183,219,133,196,92,28,125,125,215,83,200,104,175,230,79,96,93,10,166,38,6,238,120,26,90,71,102,98,81,191,217,98,
+  229,77,13,78,220,189,151,4,39,194,174,134,26,84,150,149,130,17,67,40,150,192,226,210,202,131,156,115,66,133,181,4,
+  109,207,55,98,109,85,133,36,114,212,213,150,67,49,155,80,93,105,198,254,221,78,68,67,97,156,59,255,97,42,147,86,
+  79,94,253,242,236,103,91,22,225,212,248,192,168,167,161,117,36,30,139,250,45,214,50,190,211,227,192,210,242,26,246,63,
+  227,130,32,16,136,17,130,147,179,80,85,173,80,108,2,113,232,58,208,224,172,66,173,205,10,103,109,5,44,102,19,136,
+  8,149,229,165,24,25,30,197,63,206,93,78,111,132,111,42,96,148,152,142,70,252,86,107,57,63,122,112,55,100,89,0,
+  67,182,251,217,42,21,36,147,107,40,41,150,80,95,87,133,213,149,20,158,105,178,67,49,155,10,29,146,136,80,102,41,
+  198,224,208,109,244,252,253,114,58,147,86,95,219,8,223,82,96,189,68,180,179,185,201,195,157,142,26,164,83,42,136,8,
+  178,40,64,18,57,100,81,64,131,179,26,110,71,37,148,210,34,16,35,176,28,220,170,152,48,56,20,64,79,207,229,116,
+  38,157,222,20,254,80,129,188,132,171,222,59,50,60,28,232,116,56,106,72,42,50,97,240,86,12,153,140,134,88,252,30,
+  150,146,171,112,218,203,193,11,13,42,11,87,204,121,120,239,67,225,143,20,0,128,208,68,255,168,211,179,119,100,104,232,
+  182,159,139,197,188,178,170,28,247,151,83,80,211,26,154,118,238,128,82,106,2,203,117,71,34,6,115,105,81,246,216,123,
+  122,211,170,150,57,249,245,23,239,110,9,223,150,64,78,34,104,119,182,4,98,145,200,201,138,138,42,254,114,219,30,216,
+  119,88,97,46,41,42,180,102,34,134,210,146,34,12,15,7,240,94,79,111,122,117,109,229,116,223,151,239,253,51,183,132,
+  254,36,2,4,64,2,80,4,64,14,79,14,133,170,108,158,224,108,60,126,130,139,37,188,169,209,9,77,211,11,69,87,
+  82,44,99,104,56,128,119,123,46,169,139,191,46,252,249,135,190,75,87,1,8,57,70,190,225,105,219,21,16,1,200,27,
+  99,58,18,8,91,202,107,39,98,177,217,227,110,151,157,219,107,170,161,105,58,138,77,89,248,217,158,75,234,194,124,244,
+  47,253,63,126,220,103,128,231,5,8,217,107,128,110,60,145,205,4,120,78,64,50,68,65,98,102,58,24,43,85,42,38,
+  127,25,139,190,228,114,216,169,206,97,195,224,208,109,156,237,185,164,198,167,39,222,24,233,191,114,61,7,55,66,141,247,
+  15,29,64,230,81,2,66,78,66,200,9,228,133,100,0,242,220,204,68,188,200,100,14,7,39,166,219,18,137,69,250,248,
+  211,43,153,104,248,206,155,163,195,95,223,48,64,141,64,45,23,25,195,184,165,128,102,176,231,134,49,47,198,1,136,11,
+  115,161,184,44,149,196,18,191,174,30,142,132,110,253,53,24,184,126,99,3,72,221,16,105,67,20,82,240,176,171,89,190,
+  14,36,195,104,12,209,32,152,223,101,30,144,218,16,107,134,113,93,33,110,231,110,152,79,135,132,245,169,201,195,141,133,
+  149,49,236,222,40,179,110,215,143,43,176,217,63,70,120,126,141,141,185,222,214,243,31,50,77,124,34,176,20,164,223,0,
+  0,0,0,73,69,78,68,174,66,96,130,
+};
+
+const uint8_t up[652] = {
+  137,80,78,71,13,10,26,10,0,0,0,13,73,72,68,82,0,0,0,16,0,0,0,16,8,6,0,0,0,31,243,255,
+  97,0,0,0,4,115,66,73,84,8,8,8,8,124,8,100,136,0,0,0,25,116,69,88,116,83,111,102,116,119,97,114,
+  101,0,119,119,119,46,105,110,107,115,99,97,112,101,46,111,114,103,155,238,60,26,0,0,2,30,73,68,65,84,56,141,
+  149,147,79,104,19,65,20,198,191,55,187,51,217,141,133,122,104,76,255,209,130,4,237,193,64,42,168,208,213,138,104,68,
+  98,69,45,20,114,107,74,201,73,144,98,22,193,171,199,82,145,160,23,15,69,79,30,165,66,241,226,77,42,94,68,80,
+  208,67,41,180,42,149,148,52,137,166,154,38,217,217,25,15,81,172,33,169,246,29,223,251,230,199,124,223,155,33,173,53,
+  218,213,201,155,124,30,0,150,102,189,233,118,26,214,110,224,184,60,221,223,21,73,246,117,29,76,58,46,79,239,9,224,
+  184,60,26,16,251,178,87,206,76,6,199,70,147,193,128,8,102,29,151,71,255,11,224,184,188,3,132,197,137,115,211,214,
+  150,151,199,150,183,137,248,200,37,11,132,69,199,229,29,255,4,16,225,209,232,112,162,167,55,52,72,159,75,31,240,177,
+  244,30,157,157,157,20,27,58,209,13,194,195,93,1,142,203,211,253,7,34,137,179,71,199,249,74,254,13,12,198,97,50,
+  142,87,107,11,136,13,29,23,161,253,61,137,230,60,216,142,195,81,193,237,108,42,225,218,235,229,101,104,242,32,132,137,
+  58,125,199,54,21,241,46,255,28,23,78,95,13,154,166,248,43,15,182,211,247,212,88,198,82,228,161,34,75,16,1,1,
+  30,224,40,203,117,8,219,64,65,174,162,168,86,113,254,212,69,139,216,159,60,216,111,223,241,99,227,221,135,250,98,148,
+  175,172,193,228,6,56,55,80,81,5,84,141,175,16,54,131,176,25,150,191,189,64,184,55,68,71,14,15,135,137,53,242,
+  160,145,140,153,30,232,142,100,111,76,220,177,5,15,64,65,194,135,135,215,185,5,188,45,60,131,100,21,16,35,36,6,
+  50,208,90,67,41,160,94,175,225,241,211,249,74,177,180,57,99,18,67,234,83,110,197,158,185,119,185,225,137,163,122,247,
+  250,19,171,44,115,240,141,109,112,193,192,76,130,193,9,115,15,110,87,101,77,91,191,236,7,137,33,101,46,205,122,78,
+  211,38,180,214,10,165,250,23,48,131,96,112,6,30,104,64,100,77,91,47,231,60,218,245,29,0,128,210,62,126,212,139,
+  141,43,251,26,178,174,160,85,235,63,99,182,106,250,74,162,90,219,134,50,53,160,21,124,73,240,189,61,0,164,47,17,
+  31,188,6,98,0,49,2,17,246,0,32,108,220,186,63,25,110,37,38,194,70,115,239,39,48,247,197,219,182,208,154,34,
+  0,0,0,0,73,69,78,68,174,66,96,130,
+};
+
+const uint8_t video[662] = {
+  137,80,78,71,13,10,26,10,0,0,0,13,73,72,68,82,0,0,0,16,0,0,0,16,8,6,0,0,0,31,243,255,
+  97,0,0,0,4,115,66,73,84,8,8,8,8,124,8,100,136,0,0,0,9,112,72,89,115,0,0,13,215,0,0,13,
+  215,1,66,40,155,120,0,0,0,25,116,69,88,116,83,111,102,116,119,97,114,101,0,119,119,119,46,105,110,107,115,99,
+  97,112,101,46,111,114,103,155,238,60,26,0,0,2,19,73,68,65,84,56,141,165,147,203,106,20,65,20,134,191,83,85,
+  115,109,72,50,32,6,98,18,35,38,11,183,222,54,186,112,99,6,29,240,25,124,4,55,130,184,81,80,4,241,49,124,
+  131,108,92,8,9,17,34,226,222,96,188,129,38,16,131,97,72,156,233,234,233,158,238,58,46,58,17,19,3,65,60,155,
+  42,170,234,255,207,119,206,161,164,221,110,243,63,225,58,157,206,29,17,121,168,170,181,127,17,138,136,87,213,187,78,85,
+  31,183,111,92,143,154,141,38,121,174,199,103,116,130,181,134,110,183,91,95,90,124,245,196,169,106,109,116,116,132,249,155,
+  207,73,233,3,160,122,132,209,222,81,77,34,94,190,184,205,200,232,40,64,195,237,223,167,161,207,133,171,99,136,200,30,
+  34,128,148,171,0,90,238,223,44,111,179,250,238,61,83,83,147,37,81,154,166,128,160,226,136,211,80,10,20,68,228,128,
+  73,54,204,217,238,254,4,28,103,103,103,49,18,74,3,239,61,33,20,24,99,24,228,82,102,43,155,4,148,194,205,31,
+  59,196,62,5,160,97,90,124,88,91,99,122,122,146,36,73,112,73,146,80,20,1,140,35,201,203,108,138,32,64,156,164,
+  236,244,18,84,29,149,250,94,181,137,101,122,230,52,21,103,240,222,227,226,56,70,131,98,76,133,65,112,251,0,36,233,
+  144,108,104,112,181,232,224,248,172,229,243,199,79,204,205,205,210,239,247,75,2,69,17,107,73,131,3,5,69,81,107,169,
+  216,35,134,97,135,76,156,154,192,24,202,18,188,247,0,24,227,176,213,232,111,197,161,24,154,62,69,81,160,8,113,28,
+  227,66,40,187,217,106,56,178,205,193,177,6,81,213,33,70,49,34,37,129,115,174,183,254,109,163,245,236,209,249,99,197,
+  191,41,210,156,245,245,13,128,29,233,116,58,183,106,181,218,3,17,141,64,12,48,83,169,56,87,169,86,197,26,3,64,
+  17,2,89,150,105,62,204,135,192,87,208,160,202,174,247,201,125,151,231,249,66,158,231,11,0,170,26,181,78,140,189,157,
+  111,183,207,93,186,120,153,241,147,227,168,42,91,91,223,89,121,189,162,75,203,75,171,73,111,112,37,203,50,191,79,35,
+  135,191,179,49,102,164,222,172,63,109,70,205,107,214,154,51,128,22,161,248,50,240,131,197,222,110,255,158,136,196,127,190,
+  255,5,119,143,242,70,185,147,13,30,0,0,0,0,73,69,78,68,174,66,96,130,
+};
+
+};
diff -Nru higan/target-ethos/resource/resource.hpp higan/target-ethos/resource/resource.hpp
--- higan/target-ethos/resource/resource.hpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/target-ethos/resource/resource.hpp	2015-09-16 14:06:03.411919283 +0900
@@ -0,0 +1,16 @@
+namespace resource {
+  extern const uint8_t advanced[611];
+  extern const uint8_t audio[592];
+  extern const uint8_t cheatEditor[937];
+  extern const uint8_t folder[1176];
+  extern const uint8_t game[1490];
+  extern const uint8_t home[606];
+  extern const uint8_t hotkeys[587];
+  extern const uint8_t input[812];
+  extern const uint8_t server[408];
+  extern const uint8_t stateManager[378];
+  extern const uint8_t timing[897];
+  extern const uint8_t unverified[1675];
+  extern const uint8_t up[652];
+  extern const uint8_t video[662];
+};
Binary files higan/target-ethos/resource/server.png and higan/target-ethos/resource/server.png differ
Binary files higan/target-ethos/resource/state-manager.png and higan/target-ethos/resource/state-manager.png differ
Binary files higan/target-ethos/resource/timing.png and higan/target-ethos/resource/timing.png differ
Binary files higan/target-ethos/resource/unverified.png and higan/target-ethos/resource/unverified.png differ
Binary files higan/target-ethos/resource/up.png and higan/target-ethos/resource/up.png differ
Binary files higan/target-ethos/resource/video.png and higan/target-ethos/resource/video.png differ
diff -Nru higan/target-ethos/settings/advanced.cpp higan/target-ethos/settings/advanced.cpp
--- higan/target-ethos/settings/advanced.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/target-ethos/settings/advanced.cpp	2015-09-16 14:06:03.420919283 +0900
@@ -0,0 +1,86 @@
+AdvancedSettings* advancedSettings = nullptr;
+
+AdvancedSettings::AdvancedSettings() {
+  driverTitle.setFont(program->boldFont);
+  driverTitle.setText("Driver Selection:");
+  videoLabel.setText("Video:");
+  audioLabel.setText("Audio:");
+  inputLabel.setText("Input:");
+  libraryTitle.setFont(program->boldFont);
+  libraryTitle.setText("Game Library:");
+  libraryLabel.setText("Path:");
+  libraryPath.setEditable(false);
+  libraryPath.setText(utility->libraryPath());
+  libraryBrowse.setText("Browse ...");
+  libraryShowOnStartup.setChecked(config->library.showOnStartup);
+  libraryShowOnStartup.setText("Show game library on program start");
+  information.setText("Note: changing advanced settings requires program restart to take effect.");
+  infoLabel.setFont(program->boldFont);
+  infoLabel.setText({
+    "ethos v", Emulator::Version, "\n",
+    #if defined(PROFILE_ACCURACY) or defined(PROFILE_BALANCED) or defined(PROFILE_PERFORMANCE)
+    "  ", Emulator::Profile, " Profile\n",
+    #endif
+    "  Author: ", Emulator::Author, "\n",
+    "  License: ", Emulator::License, "\n",
+    "  Website: ", Emulator::Website
+  });
+
+  //lstring list;
+
+  //list.split(";", video->availableDrivers());
+  //for(unsigned n = 0; n < list.size(); n++) {
+  //  videoDriver.append(list[n]);
+  //  if(list[n] == config->video.driver) videoDriver.setSelection(n);
+  //}
+
+  for(auto& driver : Video::availableDrivers()) {
+    videoDriver.append(driver);
+    if(driver == config->video.driver) videoDriver.setSelection(videoDriver.rows() - 1);
+  }
+
+  for(auto& driver : Audio::availableDrivers()) {
+    audioDriver.append(driver);
+    if(driver == config->audio.driver) audioDriver.setSelection(audioDriver.rows() - 1);
+  }
+
+  for(auto& driver : Input::availableDrivers()) {
+    inputDriver.append(driver);
+    if(driver == config->input.driver) inputDriver.setSelection(inputDriver.rows() - 1);
+  }
+
+  append(driverTitle, {~0, 0});
+  append(driverLayout, {~0, 0}, 15);
+    driverLayout.append(videoLabel, {0, 0}, 5);
+    driverLayout.append(videoDriver, {~0, 0}, 5);
+    driverLayout.append(audioLabel, {0, 0}, 5);
+    driverLayout.append(audioDriver, {~0, 0}, 5);
+    driverLayout.append(inputLabel, {0, 0}, 5);
+    driverLayout.append(inputDriver, {~0, 0});
+  append(libraryTitle, {~0, 0});
+  append(libraryLayout, {~0, 0});
+    libraryLayout.append(libraryLabel, {0, 0}, 5);
+    libraryLayout.append(libraryPath, {~0, 0}, 5);
+    libraryLayout.append(libraryBrowse, {80, 0});
+  append(libraryShowOnStartup, {~0, 0}, 15);
+  append(information, {~0, 0}, 15);
+  if(Intrinsics::platform() != Intrinsics::Platform::MacOSX) {
+    append(spacer, {~0, ~0});
+    append(infoLabel, {~0, 0});
+  }
+
+  videoDriver.onChange = [&] { config->video.driver = videoDriver.text(); };
+  audioDriver.onChange = [&] { config->audio.driver = audioDriver.text(); };
+  inputDriver.onChange = [&] { config->input.driver = inputDriver.text(); };
+
+  libraryBrowse.onActivate = [&] {
+    string path = BrowserWindow().setParent(*settings).setPath(userpath()).directory();
+    if(path.empty()) return;
+    file::write({configpath(), "higan/library.bml"}, {"Path: ", path, "\n"});
+    libraryPath.setText(path);
+  };
+
+  libraryShowOnStartup.onToggle = [&] {
+    config->library.showOnStartup = libraryShowOnStartup.checked();
+  };
+}
diff -Nru higan/target-ethos/settings/advanced.hpp higan/target-ethos/settings/advanced.hpp
--- higan/target-ethos/settings/advanced.hpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/target-ethos/settings/advanced.hpp	2015-09-16 14:06:03.420919283 +0900
@@ -0,0 +1,26 @@
+struct AdvancedSettings : SettingsLayout {
+  Label driverTitle;
+  HorizontalLayout driverLayout;
+    Label videoLabel;
+    ComboButton videoDriver;
+    Label audioLabel;
+    ComboButton audioDriver;
+    Label inputLabel;
+    ComboButton inputDriver;
+
+  Label libraryTitle;
+  HorizontalLayout libraryLayout;
+    Label libraryLabel;
+    LineEdit libraryPath;
+    Button libraryBrowse;
+  CheckLabel libraryShowOnStartup;
+
+  Label information;
+
+  Widget spacer;
+  Label infoLabel;
+
+  AdvancedSettings();
+};
+
+extern AdvancedSettings* advancedSettings;
diff -Nru higan/target-ethos/settings/audio.cpp higan/target-ethos/settings/audio.cpp
--- higan/target-ethos/settings/audio.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/target-ethos/settings/audio.cpp	2015-09-16 14:06:03.420919283 +0900
@@ -0,0 +1,79 @@
+AudioSettings* audioSettings = nullptr;
+
+AudioSlider::AudioSlider() {
+  append(name, {75, 0});
+  append(value, {75, 0});
+  append(slider, {~0, 0});
+}
+
+AudioSettings::AudioSettings() {
+  frequencyLabel.setText("Frequency:");
+  frequency.append("32000hz");
+  frequency.append("44100hz");
+  frequency.append("48000hz");
+  frequency.append("96000hz");
+  latencyLabel.setText("Latency:");
+  latency.append("20ms");
+  latency.append("40ms");
+  latency.append("60ms");
+  latency.append("80ms");
+  latency.append("100ms");
+  resamplerLabel.setText("Resampler:");
+  resampler.append("Linear");
+  resampler.append("Hermite");
+  resampler.append("Sinc");
+  volume.name.setText("Volume:");
+  volume.slider.setLength(201);
+
+  append(controlLayout, {~0, 0}, 5);
+    controlLayout.append(frequencyLabel, {0, 0}, 5);
+    controlLayout.append(frequency, {~0, 0}, 5);
+    controlLayout.append(latencyLabel, {0, 0}, 5);
+    controlLayout.append(latency, {~0, 0}, 5);
+    controlLayout.append(resamplerLabel, {0, 0}, 5);
+    controlLayout.append(resampler, {~0, 0});
+  append(volume, {~0, 0});
+
+  switch(config->audio.frequency) { default:
+  case 32000: frequency.setSelection(0); break;
+  case 44100: frequency.setSelection(1); break;
+  case 48000: frequency.setSelection(2); break;
+  case 96000: frequency.setSelection(3); break;
+  }
+  switch(config->audio.latency) { default:
+  case  20: latency.setSelection(0); break;
+  case  40: latency.setSelection(1); break;
+  case  60: latency.setSelection(2); break;
+  case  80: latency.setSelection(3); break;
+  case 100: latency.setSelection(4); break;
+  }
+  resampler.setSelection(config->audio.resampler);
+  volume.slider.setPosition(config->audio.volume);
+
+  frequency.onChange = latency.onChange = resampler.onChange = volume.slider.onChange =
+  {&AudioSettings::synchronize, this};
+
+  synchronize();
+}
+
+void AudioSettings::synchronize() {
+  switch(frequency.selection()) {
+  case 0: config->audio.frequency = 32000; break;
+  case 1: config->audio.frequency = 44100; break;
+  case 2: config->audio.frequency = 48000; break;
+  case 3: config->audio.frequency = 96000; break;
+  }
+  switch(latency.selection()) {
+  case 0: config->audio.latency =  20; break;
+  case 1: config->audio.latency =  40; break;
+  case 2: config->audio.latency =  60; break;
+  case 3: config->audio.latency =  80; break;
+  case 4: config->audio.latency = 100; break;
+  }
+  config->audio.resampler = resampler.selection();
+  config->audio.volume = volume.slider.position();
+
+  volume.value.setText({config->audio.volume, "%"});
+
+  utility->synchronizeRuby();
+}
diff -Nru higan/target-ethos/settings/audio.hpp higan/target-ethos/settings/audio.hpp
--- higan/target-ethos/settings/audio.hpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/target-ethos/settings/audio.hpp	2015-09-16 14:06:03.418919283 +0900
@@ -0,0 +1,23 @@
+struct AudioSlider : HorizontalLayout {
+  Label name;
+  Label value;
+  HorizontalSlider slider;
+
+  AudioSlider();
+};
+
+struct AudioSettings : SettingsLayout {
+  HorizontalLayout controlLayout;
+    Label frequencyLabel;
+    ComboButton frequency;
+    Label latencyLabel;
+    ComboButton latency;
+    Label resamplerLabel;
+    ComboButton resampler;
+  AudioSlider volume;
+
+  void synchronize();
+  AudioSettings();
+};
+
+extern AudioSettings* audioSettings;
diff -Nru higan/target-ethos/settings/hotkey.cpp higan/target-ethos/settings/hotkey.cpp
--- higan/target-ethos/settings/hotkey.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/target-ethos/settings/hotkey.cpp	2015-09-16 14:06:03.420919283 +0900
@@ -0,0 +1,58 @@
+HotkeySettings* hotkeySettings = nullptr;
+
+HotkeySettings::HotkeySettings() {
+  inputList.setHeaderText({"Name", "Mapping"});
+  inputList.setHeaderVisible();
+  eraseButton.setText("Erase");
+
+  append(inputList, {~0, ~0}, 5);
+  append(controlLayout, {~0, 0});
+    controlLayout.append(spacer, {~0, 0});
+    controlLayout.append(eraseButton, {80, 0});
+
+  inputList.onChange = {&HotkeySettings::synchronize, this};
+  inputList.onActivate = {&HotkeySettings::assignInput, this};
+  eraseButton.onActivate = {&HotkeySettings::eraseInput, this};
+
+  for(auto& hotkey : inputManager->hotkeyMap) inputList.append({"", ""});
+  refresh();
+}
+
+void HotkeySettings::synchronize() {
+  eraseButton.setEnabled(inputList.selected());
+}
+
+void HotkeySettings::refresh() {
+  unsigned index = 0;
+  for(auto& hotkey : inputManager->hotkeyMap) {
+    string mapping = inputManager->sanitize(hotkey->mapping, " and ");
+    inputList.setText(index++, {hotkey->name, mapping});
+  }
+  synchronize();
+}
+
+void HotkeySettings::eraseInput() {
+  activeInput = inputManager->hotkeyMap[inputList.selection()];
+  inputEvent(hidNull, 0, 0, 0, 1);
+}
+
+void HotkeySettings::assignInput() {
+  activeInput = inputManager->hotkeyMap[inputList.selection()];
+
+  settings->setStatusText({"Set assignment for [", activeInput->name, "] ..."});
+  settings->layout.setEnabled(false);
+  setEnabled(false);
+}
+
+void HotkeySettings::inputEvent(HID::Device& device, unsigned group, unsigned input, int16_t oldValue, int16_t newValue) {
+  if(activeInput == nullptr) return;
+  if(device.isMouse()) return;
+  if(device.isJoypad() && group == HID::Joypad::GroupID::Axis) return;
+  if(activeInput->bind(device, group, input, oldValue, newValue) == false) return;
+
+  activeInput = nullptr;
+  settings->setStatusText("");
+  settings->layout.setEnabled(true);
+  setEnabled(true);
+  refresh();
+}
diff -Nru higan/target-ethos/settings/hotkey.hpp higan/target-ethos/settings/hotkey.hpp
--- higan/target-ethos/settings/hotkey.hpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/target-ethos/settings/hotkey.hpp	2015-09-16 14:06:03.419919283 +0900
@@ -0,0 +1,18 @@
+struct HotkeySettings : SettingsLayout {
+  ListView inputList;
+  HorizontalLayout controlLayout;
+    Widget spacer;
+    Button eraseButton;
+
+  void synchronize();
+  void refresh();
+  void eraseInput();
+  void assignInput();
+  void inputEvent(HID::Device& device, unsigned group, unsigned input, int16_t oldValue, int16_t newValue);
+  HotkeySettings();
+
+private:
+  HotkeyInput* activeInput = nullptr;
+};
+
+extern HotkeySettings* hotkeySettings;
diff -Nru higan/target-ethos/settings/input.cpp higan/target-ethos/settings/input.cpp
--- higan/target-ethos/settings/input.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/target-ethos/settings/input.cpp	2015-09-16 14:06:03.419919283 +0900
@@ -0,0 +1,187 @@
+InputSettings* inputSettings = nullptr;
+
+InputSettings::InputSettings() {
+  focusLabel.setText("When Focus is Lost:");
+  focusPause.setText("Pause Emulation");
+  focusAllow.setText("Allow Input");
+  inputList.setHeaderText({"Name", "Mapping"});
+  inputList.setHeaderVisible();
+  resetButton.setText("Reset");
+  eraseButton.setText("Erase");
+
+  append(focusLayout, {~0, 0}, 5);
+    focusLayout.append(focusLabel, {0, 0}, 5);
+    focusLayout.append(focusPause, {0, 0}, 5);
+    focusLayout.append(focusAllow, {0, 0});
+  append(selectionLayout, {~0, 0}, 5);
+    selectionLayout.append(systemList, {~0, 0}, 5);
+    selectionLayout.append(portList, {~0, 0}, 5);
+    selectionLayout.append(deviceList, {~0, 0});
+  append(inputList, {~0, ~0}, 5);
+  append(controlLayout, {~0, 0});
+    controlLayout.append(assign[0], {100, 0}, 5);
+    controlLayout.append(assign[1], {100, 0}, 5);
+    controlLayout.append(assign[2], {100, 0}, 5);
+    controlLayout.append(spacer, {~0, 0});
+    controlLayout.append(resetButton, {80, 0}, 5);
+    controlLayout.append(eraseButton, {80, 0});
+
+  for(auto& emulator : program->emulator) {
+    systemList.append(emulator->information.name);
+  }
+
+  focusPause.setChecked(config->input.focus.pause);
+  focusAllow.setChecked(config->input.focus.allow);
+  focusAllow.setEnabled(!config->input.focus.pause);
+
+  focusPause.onToggle = [&] { config->input.focus.pause = focusPause.checked(); focusAllow.setEnabled(!focusPause.checked()); };
+  focusAllow.onToggle = [&] { config->input.focus.allow = focusAllow.checked(); };
+  systemList.onChange = {&InputSettings::systemChanged, this};
+  portList.onChange = {&InputSettings::portChanged, this};
+  deviceList.onChange = {&InputSettings::deviceChanged, this};
+  inputList.onChange = {&InputSettings::synchronize, this};
+  inputList.onActivate = {&InputSettings::assignInput, this};
+  assign[0].onActivate = [&] { assignMouseInput(0); };
+  assign[1].onActivate = [&] { assignMouseInput(1); };
+  assign[2].onActivate = [&] { assignMouseInput(2); };
+  resetButton.onActivate = {&InputSettings::resetInput, this};
+  eraseButton.onActivate = {&InputSettings::eraseInput, this};
+
+  systemChanged();
+}
+
+void InputSettings::synchronize() {
+  if(inputList.selected() == false) {
+    assign[0].setVisible(false);
+    assign[1].setVisible(false);
+    assign[2].setVisible(false);
+  } else {
+    unsigned number = activeDevice().order[inputList.selection()];
+    auto& input = activeDevice().input[number];
+    auto selectedInput = inputManager->inputMap[input.guid];
+
+    if(dynamic_cast<DigitalInput*>(selectedInput)) {
+      assign[0].setText("Mouse Left");
+      assign[1].setText("Mouse Middle");
+      assign[2].setText("Mouse Right");
+      assign[0].setVisible(true);
+      assign[1].setVisible(true);
+      assign[2].setVisible(true);
+    }
+
+    if(dynamic_cast<RelativeInput*>(selectedInput)) {
+      assign[0].setText("Mouse X-axis");
+      assign[1].setText("Mouse Y-axis");
+      assign[0].setVisible(true);
+      assign[1].setVisible(true);
+      assign[2].setVisible(false);
+    }
+  }
+
+  eraseButton.setEnabled(inputList.selected());
+}
+
+Emulator::Interface& InputSettings::activeSystem() {
+  return *program->emulator[systemList.selection()];
+}
+
+Emulator::Interface::Port& InputSettings::activePort() {
+  return activeSystem().port[portList.selection()];
+}
+
+Emulator::Interface::Device& InputSettings::activeDevice() {
+  return activePort().device[deviceList.selection()];
+}
+
+void InputSettings::systemChanged() {
+  portList.reset();
+  for(auto& port : activeSystem().port) {
+    portList.append(port.name);
+  }
+  portChanged();
+}
+
+void InputSettings::portChanged() {
+  deviceList.reset();
+  for(auto& device : activePort().device) {
+    deviceList.append(device.name);
+  }
+  deviceChanged();
+}
+
+void InputSettings::deviceChanged() {
+  inputList.reset();
+  for(unsigned number : activeDevice().order) inputList.append({"", ""});
+  inputChanged();
+  synchronize();
+}
+
+void InputSettings::inputChanged() {
+  unsigned index = 0;
+  for(unsigned number : activeDevice().order) {
+    auto& input = activeDevice().input[number];
+    auto abstract = inputManager->inputMap(input.guid);
+    string mapping = inputManager->sanitize(abstract->mapping, " or ");
+    inputList.setText(index++, {input.name, mapping});
+  }
+}
+
+void InputSettings::resetInput() {
+  if(MessageWindow().setParent(*settings).setText("All inputs will be erased. Are you sure you want to do this?")
+  .question() == MessageWindow::Response::No) return;
+
+  auto& device = activeDevice();
+  unsigned length = device.input.size();
+  for(unsigned n = 0; n < length; n++) {
+    activeInput = inputManager->inputMap[device.input[n].guid];
+    inputEvent(hidNull, 0, 0, 0, 1);
+  }
+}
+
+void InputSettings::eraseInput() {
+  unsigned number = activeDevice().order[inputList.selection()];
+  auto& input = activeDevice().input[number];
+  activeInput = inputManager->inputMap[input.guid];
+  inputEvent(hidNull, 0, 0, 0, 1);
+}
+
+void InputSettings::assignInput() {
+  unsigned number = activeDevice().order[inputList.selection()];
+  auto& input = activeDevice().input[number];
+  activeInput = inputManager->inputMap[input.guid];
+
+  settings->setStatusText({"Set assignment for [", activeDevice().name, "::", input.name, "] ..."});
+  settings->layout.setEnabled(false);
+  setEnabled(false);
+}
+
+void InputSettings::assignMouseInput(unsigned n) {
+  unsigned number = activeDevice().order[inputList.selection()];
+  auto& input = activeDevice().input[number];
+  activeInput = inputManager->inputMap[input.guid];
+
+  if(dynamic_cast<DigitalInput*>(activeInput)) {
+    if(auto hidMouse = inputManager->findMouse()) {
+      return inputEvent(*hidMouse, HID::Mouse::GroupID::Button, n, 0, 1, true);
+    }
+  }
+
+  if(dynamic_cast<RelativeInput*>(activeInput)) {
+    if(auto hidMouse = inputManager->findMouse()) {
+      return inputEvent(*hidMouse, HID::Mouse::GroupID::Axis, n, 0, +32767, true);
+    }
+  }
+}
+
+void InputSettings::inputEvent(HID::Device& device, unsigned group, unsigned input, int16_t oldValue, int16_t newValue, bool allowMouseInput) {
+  if(activeInput == nullptr) return;
+  if(allowMouseInput == false && device.isMouse()) return;
+  if(activeInput->bind(device, group, input, oldValue, newValue) == false) return;
+
+  activeInput = nullptr;
+  inputChanged();
+  settings->setStatusText("");
+  settings->layout.setEnabled(true);
+  setEnabled(true);
+  synchronize();
+}
diff -Nru higan/target-ethos/settings/input.hpp higan/target-ethos/settings/input.hpp
--- higan/target-ethos/settings/input.hpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/target-ethos/settings/input.hpp	2015-09-16 14:06:03.420919283 +0900
@@ -0,0 +1,38 @@
+struct InputSettings : SettingsLayout {
+  HorizontalLayout focusLayout;
+    Label focusLabel;
+    CheckLabel focusPause;
+    CheckLabel focusAllow;
+  HorizontalLayout selectionLayout;
+    ComboButton systemList;
+    ComboButton portList;
+    ComboButton deviceList;
+  ListView inputList;
+  HorizontalLayout controlLayout;
+    Button assign[3];
+    Widget spacer;
+    Button resetButton;
+    Button eraseButton;
+
+  void synchronize();
+
+  Emulator::Interface& activeSystem();
+  Emulator::Interface::Port& activePort();
+  Emulator::Interface::Device& activeDevice();
+
+  void systemChanged();
+  void portChanged();
+  void deviceChanged();
+  void inputChanged();
+  void resetInput();
+  void eraseInput();
+  void assignInput();
+  void assignMouseInput(unsigned n);
+  void inputEvent(HID::Device& device, unsigned group, unsigned input, int16_t oldValue, int16_t newValue, bool allowMouseInput = false);
+  InputSettings();
+
+private:
+  AbstractInput* activeInput = nullptr;
+};
+
+extern InputSettings* inputSettings;
diff -Nru higan/target-ethos/settings/server.cpp higan/target-ethos/settings/server.cpp
--- higan/target-ethos/settings/server.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/target-ethos/settings/server.cpp	2015-09-16 14:06:03.419919283 +0900
@@ -0,0 +1,29 @@
+ServerSettings* serverSettings = nullptr;
+
+ServerSettings::ServerSettings() {
+  hostLabel.setText("Hostname:");
+  userLabel.setText("Username:");
+  passLabel.setText("Password:");
+
+  unsigned width = min(
+    Font::size(program->normalFont, "Hostname:").width,
+    Font::size(program->normalFont, "Username:").width
+  );
+
+  append(hostLayout, {~0, 0}, 5);
+    hostLayout.append(hostLabel, {width, 0}, 5);
+    hostLayout.append(hostEdit, {~0, 0});
+  append(userLayout, {~0, 0});
+    userLayout.append(userLabel, {width, 0}, 5);
+    userLayout.append(userEdit, {~0, 0}, 5);
+    userLayout.append(passLabel, {0, 0}, 5);
+    userLayout.append(passEdit, {~0, 0});
+
+  hostEdit.setText(config->server.hostname);
+  userEdit.setText(config->server.username);
+  passEdit.setText(config->server.password);
+
+  hostEdit.onChange = [&] { config->server.hostname = hostEdit.text(); };
+  userEdit.onChange = [&] { config->server.username = userEdit.text(); };
+  passEdit.onChange = [&] { config->server.password = passEdit.text(); };
+}
diff -Nru higan/target-ethos/settings/server.hpp higan/target-ethos/settings/server.hpp
--- higan/target-ethos/settings/server.hpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/target-ethos/settings/server.hpp	2015-09-16 14:06:03.420919283 +0900
@@ -0,0 +1,14 @@
+struct ServerSettings : SettingsLayout {
+  HorizontalLayout hostLayout;
+    Label hostLabel;
+    LineEdit hostEdit;
+  HorizontalLayout userLayout;
+    Label userLabel;
+    LineEdit userEdit;
+    Label passLabel;
+    LineEdit passEdit;
+
+  ServerSettings();
+};
+
+extern ServerSettings* serverSettings;
diff -Nru higan/target-ethos/settings/settings.cpp higan/target-ethos/settings/settings.cpp
--- higan/target-ethos/settings/settings.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/target-ethos/settings/settings.cpp	2015-09-16 14:06:03.418919283 +0900
@@ -0,0 +1,46 @@
+#include "../ethos.hpp"
+#include "video.cpp"
+#include "audio.cpp"
+#include "input.cpp"
+#include "hotkey.cpp"
+#include "timing.cpp"
+#include "server.cpp"
+#include "advanced.cpp"
+Settings* settings = nullptr;
+
+SettingsLayout::SettingsLayout() {
+  setMargin(5);
+}
+
+Settings::Settings() {
+  setGeometry({128, 128, 640, 360});
+  windowManager->append(this, "Settings");
+
+  setTitle("Configuration Settings");
+  setStatusVisible();
+
+  layout.setMargin(5);
+  panels.append("Video", {resource::video, sizeof resource::video});
+  panels.append("Audio", {resource::audio, sizeof resource::audio});
+  panels.append("Input", {resource::input, sizeof resource::input});
+  panels.append("Hotkeys", {resource::hotkeys, sizeof resource::hotkeys});
+  panels.append("Timing", {resource::timing, sizeof resource::timing});
+  panels.append("Server", {resource::server, sizeof resource::server});
+  panels.append("Advanced", {resource::advanced, sizeof resource::advanced});
+  panels.setLayout(0, *videoSettings);
+  panels.setLayout(1, *audioSettings);
+  panels.setLayout(2, *inputSettings);
+  panels.setLayout(3, *hotkeySettings);
+  panels.setLayout(4, *timingSettings);
+  panels.setLayout(5, *serverSettings);
+  panels.setLayout(6, *advancedSettings);
+  panels.setSelection(2);
+
+  append(layout);
+  layout.append(panels, {~0, ~0});
+
+  onClose = [&] {
+    timingSettings->analysis.stop = true;
+    setVisible(false);
+  };
+}
diff -Nru higan/target-ethos/settings/settings.hpp higan/target-ethos/settings/settings.hpp
--- higan/target-ethos/settings/settings.hpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/target-ethos/settings/settings.hpp	2015-09-16 14:06:03.418919283 +0900
@@ -0,0 +1,20 @@
+struct SettingsLayout : VerticalLayout {
+  SettingsLayout();
+};
+
+#include "video.hpp"
+#include "audio.hpp"
+#include "input.hpp"
+#include "hotkey.hpp"
+#include "timing.hpp"
+#include "server.hpp"
+#include "advanced.hpp"
+
+struct Settings : Window {
+  VerticalLayout layout;
+  TabFrame panels;
+
+  Settings();
+};
+
+extern Settings* settings;
diff -Nru higan/target-ethos/settings/timing.cpp higan/target-ethos/settings/timing.cpp
--- higan/target-ethos/settings/timing.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/target-ethos/settings/timing.cpp	2015-09-16 14:06:03.419919283 +0900
@@ -0,0 +1,126 @@
+TimingSettings* timingSettings = nullptr;
+
+TimingAdjustment::TimingAdjustment() {
+  assign.setEnabled(false);
+  assign.setText("Assign");
+  analyze.setText("Analyze");
+  stop.setEnabled(false);
+  stop.setText("Stop");
+
+  append(name, {40, 0});
+  append(value, {100, 0}, 5);
+  append(assign, {80, 0}, 5);
+  append(spacer, {~0, 0});
+  append(analyze, {80, 0}, 5);
+  append(stop, {80, 0});
+}
+
+TimingSettings::TimingSettings() {
+  videoAdjust.name.setText("Video:");
+  videoAdjust.value.setText({config->timing.video});
+  audioAdjust.name.setText("Audio:");
+  audioAdjust.value.setText({config->timing.audio});
+
+  append(videoAdjust, {~0, 0}, 5);
+  append(audioAdjust, {~0, 0}, 5);
+
+  videoAdjust.value.onChange = [&] { videoAdjust.assign.setEnabled(true); };
+  audioAdjust.value.onChange = [&] { audioAdjust.assign.setEnabled(true); };
+  videoAdjust.assign.onActivate = [&] {
+    config->timing.video = atof(videoAdjust.value.text());
+    videoAdjust.value.setText({config->timing.video});
+    videoAdjust.assign.setEnabled(false);
+    utility->synchronizeDSP();
+  };
+  audioAdjust.assign.onActivate = [&] {
+    config->timing.audio = atof(audioAdjust.value.text());
+    audioAdjust.value.setText({config->timing.audio});
+    audioAdjust.assign.setEnabled(false);
+    utility->synchronizeDSP();
+  };
+  videoAdjust.analyze.onActivate = {&TimingSettings::analyzeVideoFrequency, this};
+  audioAdjust.analyze.onActivate = {&TimingSettings::analyzeAudioFrequency, this};
+  videoAdjust.stop.onActivate = audioAdjust.stop.onActivate = [&] { analysis.stop = true; };
+}
+
+void TimingSettings::analyzeVideoFrequency() {
+  video->set(Video::Synchronize, true);
+  audio->set(Audio::Synchronize, false);
+  videoAdjust.stop.setEnabled(true);
+  analyzeStart();
+  do {
+    uint32_t* output;
+    unsigned pitch;
+    if(video->lock(output, pitch, 16, 16)) {
+      pitch >>= 2;
+      for(unsigned y = 0; y < 16; y++) memset(output + y * pitch, 0, 4 * 16);
+      video->unlock();
+      video->refresh();
+    }
+  } while(analyzeTick("Video"));
+  analyzeStop();
+}
+
+void TimingSettings::analyzeAudioFrequency() {
+  video->set(Video::Synchronize, false);
+  audio->set(Audio::Synchronize, true);
+  audioAdjust.stop.setEnabled(true);
+  analyzeStart();
+  do {
+    audio->sample(0, 0);
+  } while(analyzeTick("Audio"));
+  analyzeStop();
+}
+
+void TimingSettings::analyzeStart() {
+  audio->clear();
+
+//settings->panels.setEnabled(false);
+  videoAdjust.analyze.setEnabled(false);
+  audioAdjust.analyze.setEnabled(false);
+  settings->setStatusText("Initializing ...");
+  Application::processEvents();
+
+  analysis.stop = false;
+  analysis.seconds = 0;
+  analysis.counter = 0;
+  analysis.sample.reset();
+  analysis.systemTime = time(0);
+}
+
+bool TimingSettings::analyzeTick(string type) {
+  analysis.counter++;
+
+  time_t systemTime = time(0);
+  if(systemTime > analysis.systemTime) {
+    analysis.systemTime = systemTime;
+    Application::processEvents();
+
+    if(analysis.seconds < 3) {
+      analysis.seconds++;
+    } else {
+      analysis.sample.append(analysis.counter);
+      uintmax_t sum = 0;
+      for(auto& point : analysis.sample) sum += point;
+      settings->setStatusText({
+        type, " sample rate: ", (double)sum / analysis.sample.size(), "hz",
+        " (", analysis.sample.size(), " sample points)"
+      });
+    }
+
+    analysis.counter = 0;
+  }
+
+  return !analysis.stop;
+}
+
+void TimingSettings::analyzeStop() {
+  video->set(Video::Synchronize, config->video.synchronize);
+  audio->set(Audio::Synchronize, config->audio.synchronize);
+
+//settings->panels.setEnabled(true);
+  videoAdjust.analyze.setEnabled(true);
+  audioAdjust.analyze.setEnabled(true);
+  videoAdjust.stop.setEnabled(false);
+  audioAdjust.stop.setEnabled(false);
+}
diff -Nru higan/target-ethos/settings/timing.hpp higan/target-ethos/settings/timing.hpp
--- higan/target-ethos/settings/timing.hpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/target-ethos/settings/timing.hpp	2015-09-16 14:06:03.420919283 +0900
@@ -0,0 +1,34 @@
+struct TimingAdjustment : HorizontalLayout {
+  Label name;
+  LineEdit value;
+  Button assign;
+  Widget spacer;
+  Button analyze;
+  Button stop;
+
+  TimingAdjustment();
+};
+
+struct TimingSettings : SettingsLayout {
+  TimingAdjustment videoAdjust;
+  TimingAdjustment audioAdjust;
+
+  void analyzeVideoFrequency();
+  void analyzeAudioFrequency();
+
+  void analyzeStart();
+  bool analyzeTick(string type);
+  void analyzeStop();
+
+  TimingSettings();
+
+  struct Analysis {
+    bool stop;
+    unsigned seconds;
+    unsigned counter;
+    vector<unsigned> sample;
+    time_t systemTime;
+  } analysis;
+};
+
+extern TimingSettings* timingSettings;
diff -Nru higan/target-ethos/settings/video.cpp higan/target-ethos/settings/video.cpp
--- higan/target-ethos/settings/video.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/target-ethos/settings/video.cpp	2015-09-16 14:06:03.419919283 +0900
@@ -0,0 +1,64 @@
+VideoSettings* videoSettings = nullptr;
+
+VideoSlider::VideoSlider() {
+  append(name, {75, 0});
+  append(value, {75, 0});
+  append(slider, {~0, 0});
+}
+
+VideoSettings::VideoSettings() {
+  colorAdjustment.setFont(program->boldFont);
+  colorAdjustment.setText("Color adjustment:");
+  saturation.name.setText("Saturation:");
+  saturation.slider.setLength(201);
+  gamma.name.setText("Gamma:");
+  gamma.slider.setLength(101);
+  luminance.name.setText("Luminance:");
+  luminance.slider.setLength(101);
+  colorEmulation.setText("Color emulation");
+  overscanAdjustment.setFont(program->boldFont);
+  overscanAdjustment.setText("Overscan mask:");
+  overscanHorizontal.name.setText("Horizontal:");
+  overscanHorizontal.slider.setLength(17);
+  overscanVertical.name.setText("Vertical:");
+  overscanVertical.slider.setLength(17);
+
+  append(colorAdjustment, {~0, 0});
+  append(saturation, {~0, 0});
+  append(gamma, {~0, 0});
+  append(luminance, {~0, 0});
+  append(colorEmulation, {~0, 0}, 5);
+  append(overscanAdjustment, {~0, 0});
+  append(overscanHorizontal, {~0, 0});
+  append(overscanVertical, {~0, 0}, 5);
+
+  colorEmulation.setChecked(config->video.colorEmulation);
+  saturation.slider.setPosition(config->video.saturation);
+  gamma.slider.setPosition(config->video.gamma - 100);
+  luminance.slider.setPosition(config->video.luminance);
+  overscanHorizontal.slider.setPosition(config->video.maskOverscan.horizontal);
+  overscanVertical.slider.setPosition(config->video.maskOverscan.vertical);
+
+  synchronize();
+
+  saturation.slider.onChange = gamma.slider.onChange = luminance.slider.onChange = colorEmulation.onToggle =
+  overscanHorizontal.slider.onChange = overscanVertical.slider.onChange =
+  {&VideoSettings::synchronize, this};
+}
+
+void VideoSettings::synchronize() {
+  config->video.saturation = saturation.slider.position();
+  config->video.gamma = 100 + gamma.slider.position();
+  config->video.luminance = luminance.slider.position();
+  config->video.colorEmulation = colorEmulation.checked();
+  config->video.maskOverscan.horizontal = overscanHorizontal.slider.position();
+  config->video.maskOverscan.vertical = overscanVertical.slider.position();
+
+  saturation.value.setText({config->video.saturation, "%"});
+  gamma.value.setText({config->video.gamma, "%"});
+  luminance.value.setText({config->video.luminance, "%"});
+  overscanHorizontal.value.setText({config->video.maskOverscan.horizontal, "px"});
+  overscanVertical.value.setText({config->video.maskOverscan.vertical, "px"});
+
+  utility->updatePalette();
+}
diff -Nru higan/target-ethos/settings/video.hpp higan/target-ethos/settings/video.hpp
--- higan/target-ethos/settings/video.hpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/target-ethos/settings/video.hpp	2015-09-16 14:06:03.418919283 +0900
@@ -0,0 +1,23 @@
+struct VideoSlider : HorizontalLayout {
+  Label name;
+  Label value;
+  HorizontalSlider slider;
+
+  VideoSlider();
+};
+
+struct VideoSettings : SettingsLayout {
+  Label colorAdjustment;
+  VideoSlider saturation;
+  VideoSlider gamma;
+  VideoSlider luminance;
+  CheckLabel colorEmulation;
+  Label overscanAdjustment;
+  VideoSlider overscanHorizontal;
+  VideoSlider overscanVertical;
+
+  void synchronize();
+  VideoSettings();
+};
+
+extern VideoSettings* videoSettings;
diff -Nru higan/target-ethos/tools/cheat-database.cpp higan/target-ethos/tools/cheat-database.cpp
--- higan/target-ethos/tools/cheat-database.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/target-ethos/tools/cheat-database.cpp	2015-09-16 14:06:03.413919283 +0900
@@ -0,0 +1,66 @@
+CheatDatabase* cheatDatabase = nullptr;
+
+CheatDatabase::CheatDatabase() {
+  setGeometry({256, 256, 600, 360});
+  windowManager->append(this, "CheatDatabase");
+
+  layout.setMargin(5);
+  cheatList.setCheckable();
+  selectAllButton.setText("Select All");
+  unselectAllButton.setText("Unselect All");
+  acceptButton.setText("Add Codes");
+
+  append(layout);
+  layout.append(cheatList, {~0, ~0}, 5);
+  layout.append(controlLayout, {~0, 0});
+    controlLayout.append(selectAllButton, {100, 0}, 5);
+    controlLayout.append(unselectAllButton, {100, 0}, 5);
+    controlLayout.append(spacer, {~0, 0});
+    controlLayout.append(acceptButton, {80, 0});
+
+  selectAllButton.onActivate = [&] {
+    for(unsigned n = 0; n < cheat.size(); n++) cheatList.setChecked(n, true);
+  };
+
+  unselectAllButton.onActivate = [&] {
+    for(unsigned n = 0; n < cheat.size(); n++) cheatList.setChecked(n, false);
+  };
+
+  acceptButton.onActivate = {&CheatDatabase::addCodes, this};
+}
+
+void CheatDatabase::findCodes() {
+  const string sha256 = system().sha256();
+  cheatList.reset();
+  cheat.reset();
+
+  auto document = BML::unserialize(string::read(program->path("cheats.bml")));
+  for(auto cartridge : document.find("cartridge")) {
+    if(cartridge["sha256"].text() != sha256) continue;
+
+    setTitle(cartridge["name"].text());
+    for(auto cheat : cartridge.find("cheat")) {
+      cheatList.append(cheat["description"].text());
+      this->cheat.append({cheat["code"].text(), cheat["description"].text()});
+    }
+
+    setVisible();
+    return;
+  }
+
+  MessageWindow().setParent(*tools).setText("Sorry, no cheat codes were found.").information();
+}
+
+void CheatDatabase::addCodes() {
+  for(unsigned n = 0; n < cheat.size(); n++) {
+    if(cheatList.checked(n) == false) continue;
+    if(cheatEditor->import(cheat[n].code, cheat[n].desc) == false) {
+      MessageWindow().setParent(*this).setText("Ran out of empty slots for cheat codes.\nNot all cheat codes were added.").warning();
+      break;
+    }
+  }
+
+  setVisible(false);
+  cheatEditor->synchronize();
+  cheatEditor->refresh();
+}
diff -Nru higan/target-ethos/tools/cheat-database.hpp higan/target-ethos/tools/cheat-database.hpp
--- higan/target-ethos/tools/cheat-database.hpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/target-ethos/tools/cheat-database.hpp	2015-09-16 14:06:03.412919283 +0900
@@ -0,0 +1,22 @@
+struct CheatDatabase : Window {
+  VerticalLayout layout;
+  ListView cheatList;
+  HorizontalLayout controlLayout;
+    Button selectAllButton;
+    Button unselectAllButton;
+    Widget spacer;
+    Button acceptButton;
+
+  void findCodes();
+  void addCodes();
+  CheatDatabase();
+
+private:
+  struct Cheat {
+    string code;
+    string desc;
+  };
+  vector<Cheat> cheat;
+};
+
+extern CheatDatabase* cheatDatabase;
diff -Nru higan/target-ethos/tools/cheat-editor.cpp higan/target-ethos/tools/cheat-editor.cpp
--- higan/target-ethos/tools/cheat-editor.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/target-ethos/tools/cheat-editor.cpp	2015-09-16 14:06:03.412919283 +0900
@@ -0,0 +1,177 @@
+CheatEditor* cheatEditor = nullptr;
+
+CheatEditor::CheatEditor() {
+  cheatList.setHeaderText({"Slot", "Code", "Description"});
+  cheatList.setHeaderVisible();
+  cheatList.setCheckable();
+  for(unsigned n = 0; n < Codes; n++) cheatList.append({"", "", ""});
+  codeLabel.setText("Code(s):");
+  descLabel.setText("Description:");
+  findButton.setText("Find Codes ...");
+  resetButton.setText("Reset");
+  eraseButton.setText("Erase");
+  unsigned width = max(
+    Font::size(program->normalFont, "Codes(s)"    ).width,
+    Font::size(program->normalFont, "Description:").width
+  );
+
+  append(cheatList, {~0, ~0}, 5);
+  append(codeLayout, {~0, 0}, 5);
+    codeLayout.append(codeLabel, {width, 0}, 5);
+    codeLayout.append(codeEdit, {~0, 0});
+  append(descLayout, {~0, 0}, 5);
+    descLayout.append(descLabel, {width, 0}, 5);
+    descLayout.append(descEdit, {~0, 0});
+  append(controlLayout, {~0, 0});
+    controlLayout.append(findButton, {0, 0}, 5);
+    controlLayout.append(spacer, {~0, 0});
+    controlLayout.append(resetButton, {80, 0}, 5);
+    controlLayout.append(eraseButton, {80, 0});
+
+  cheatList.onChange = {&CheatEditor::synchronize, this};
+  cheatList.onToggle = [&](unsigned) { update(); };
+  codeEdit.onChange = {&CheatEditor::updateCode, this};
+  descEdit.onChange = {&CheatEditor::updateDesc, this};
+  findButton.onActivate = {&CheatDatabase::findCodes, cheatDatabase};
+  resetButton.onActivate = [&] {
+    if(MessageWindow().setParent(*tools).setText("All codes will be erased. Are you sure you want to do this?")
+    .question() == MessageWindow::Response::Yes) reset();
+  };
+  eraseButton.onActivate = {&CheatEditor::erase, this};
+
+  cheatList.setSelection(0);
+  synchronize();
+}
+
+void CheatEditor::synchronize() {
+  setEnabled(program->active);
+
+  if(cheatList.selected()) {
+    unsigned n = cheatList.selection();
+    codeEdit.setText(cheat[n].code);
+    descEdit.setText(cheat[n].desc);
+    codeEdit.setEnabled(true);
+    descEdit.setEnabled(true);
+    eraseButton.setEnabled(true);
+  } else {
+    codeEdit.setText("");
+    descEdit.setText("");
+    codeEdit.setEnabled(false);
+    descEdit.setEnabled(false);
+    eraseButton.setEnabled(false);
+  }
+}
+
+void CheatEditor::refresh() {
+  for(unsigned n = 0; n < Codes; n++) {
+    string code = cheat[n].code;
+    string desc = cheat[n].code.empty() && cheat[n].desc.empty() ? "(empty)" : cheat[n].desc;
+    lstring codes = code.split("+");
+    if(codes.size() > 1) code = {codes[0], "+..."};
+    cheatList.setText(n, {decimal(1 + n, 3L), code, desc});
+  }
+  cheatList.autoSizeColumns();
+}
+
+void CheatEditor::update() {
+  lstring codes;
+  for(unsigned n = 0; n < Codes; n++) {
+    string code = cheat[n].code;
+    if(cheatList.checked(n) && !code.empty()) codes.append(code);
+  }
+  system().cheatSet(codes);
+}
+
+void CheatEditor::reset() {
+  for(unsigned n = 0; n < Codes; n++) {
+    cheatList.setChecked(n, false);
+    cheat[n].code = "";
+    cheat[n].desc = "";
+  }
+  codeEdit.setText("");
+  descEdit.setText("");
+  refresh();
+  update();
+}
+
+void CheatEditor::erase() {
+  unsigned n = cheatList.selection();
+  cheatList.setChecked(n, false);
+  cheat[n].code = "";
+  cheat[n].desc = "";
+  codeEdit.setText("");
+  descEdit.setText("");
+  refresh();
+  update();
+}
+
+void CheatEditor::updateCode() {
+  unsigned n = cheatList.selection();
+  cheat[n].code = codeEdit.text();
+  refresh();
+  update();
+}
+
+void CheatEditor::updateDesc() {
+  unsigned n = cheatList.selection();
+  cheat[n].desc = descEdit.text();
+  refresh();
+}
+
+bool CheatEditor::load(string filename) {
+  string data = string::read(filename);
+  if(data.empty()) return false;
+
+  unsigned n = 0;
+  auto document = BML::unserialize(data);
+  for(auto node : document["cartridge"].find("cheat")) {
+    cheatList.setChecked(n, (bool)node["enabled"]);
+    cheat[n].code = node["code"].text();
+    cheat[n].desc = node["description"].text();
+    if(++n >= Codes) break;
+  }
+
+  refresh();
+  update();
+  return true;
+}
+
+bool CheatEditor::save(string filename) {
+  signed lastSave = -1;
+  for(signed n = 127; n >= 0; n--) {
+    if(!cheat[n].code.empty() || !cheat[n].desc.empty()) {
+      lastSave = n;
+      break;
+    }
+  }
+
+  if(lastSave == -1) {
+    file::remove(filename);
+    return true;
+  }
+
+  file fp;
+  if(fp.open(filename, file::mode::write) == false) return false;
+
+  fp.print("cartridge sha256:", system().sha256(), "\n");
+  for(unsigned n = 0; n <= lastSave; n++) {
+    fp.print("  cheat", cheatList.checked(n) ? " enabled\n" : "\n");
+    fp.print("    description:", cheat[n].desc, "\n");
+    fp.print("    code:", cheat[n].code, "\n");
+  }
+  fp.close();
+
+  return true;
+}
+
+bool CheatEditor::import(string code, string desc) {
+  for(unsigned n = 0; n < Codes; n++) {
+    if(cheat[n].code.empty() && cheat[n].desc.empty()) {
+      cheatList.setChecked(n, false);
+      cheat[n].code = code;
+      cheat[n].desc = desc;
+      return true;
+    }
+  }
+  return false;
+}
diff -Nru higan/target-ethos/tools/cheat-editor.hpp higan/target-ethos/tools/cheat-editor.hpp
--- higan/target-ethos/tools/cheat-editor.hpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/target-ethos/tools/cheat-editor.hpp	2015-09-16 14:06:03.412919283 +0900
@@ -0,0 +1,38 @@
+struct CheatEditor : ToolsLayout {
+  ListView cheatList;
+  HorizontalLayout codeLayout;
+    Label codeLabel;
+    LineEdit codeEdit;
+  HorizontalLayout descLayout;
+    Label descLabel;
+    LineEdit descEdit;
+  HorizontalLayout controlLayout;
+    Button findButton;
+    Widget spacer;
+    Button resetButton;
+    Button eraseButton;
+
+  void reset();
+  void erase();
+  void updateCode();
+  void updateDesc();
+
+  bool load(string filename);
+  bool save(string filename);
+  bool import(string code, string desc);
+
+  void update();
+  void refresh();
+  void synchronize();
+  CheatEditor();
+
+private:
+  enum : unsigned { Codes = 128 };
+  struct Cheat {
+    string code;
+    string desc;
+  };
+  Cheat cheat[Codes];
+};
+
+extern CheatEditor* cheatEditor;
diff -Nru higan/target-ethos/tools/state-manager.cpp higan/target-ethos/tools/state-manager.cpp
--- higan/target-ethos/tools/state-manager.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/target-ethos/tools/state-manager.cpp	2015-09-16 14:06:03.412919283 +0900
@@ -0,0 +1,158 @@
+StateManager* stateManager = nullptr;
+
+StateManager::StateManager() {
+  stateList.setHeaderText({"Slot", "Description"});
+  stateList.setHeaderVisible();
+  for(unsigned n = 0; n < Slots; n++) stateList.append({decimal(1 + n, 2L), "(empty)"});
+  stateList.autoSizeColumns();
+  descLabel.setText("Description:");
+  saveButton.setText("Save");
+  loadButton.setText("Load");
+  resetButton.setText("Reset");
+  eraseButton.setText("Erase");
+
+  append(stateList, {~0, ~0}, 5);
+  append(descLayout, {~0, 0}, 5);
+    descLayout.append(descLabel, {0, 0}, 5);
+    descLayout.append(descEdit, {~0, 0});
+  append(controlLayout, {~0, 0});
+    controlLayout.append(saveButton, {80, 0}, 5);
+    controlLayout.append(loadButton, {80, 0}, 5);
+    controlLayout.append(spacer, {~0, 0});
+    controlLayout.append(resetButton, {80, 0}, 5);
+    controlLayout.append(eraseButton, {80, 0});
+
+  stateList.onChange = {&StateManager::synchronize, this};
+  stateList.onActivate = {&StateManager::slotLoad, this};
+  descEdit.onChange = {&StateManager::slotSaveDescription, this};
+  saveButton.onActivate = {&StateManager::slotSave, this};
+  loadButton.onActivate = {&StateManager::slotLoad, this};
+  resetButton.onActivate = [&] {
+    if(MessageWindow().setParent(*tools).setText("All states will be erased. Are you sure you want to do this?")
+    .question() == MessageWindow::Response::Yes) reset();
+  };
+  eraseButton.onActivate = {&StateManager::slotErase, this};
+
+  stateList.setSelection(0);
+  synchronize();
+}
+
+void StateManager::synchronize() {
+  setEnabled(program->active);
+
+  descEdit.setText("");
+  descEdit.setEnabled(false);
+  controlLayout.setEnabled(stateList.selected());
+  if(stateList.selected() == false) return;
+
+  if(slot[stateList.selection()].capacity() > 0) {
+    descEdit.setText(slotLoadDescription(stateList.selection()));
+    descEdit.setEnabled(true);
+  }
+}
+
+void StateManager::refresh() {
+  for(unsigned n = 0; n < Slots; n++) {
+    stateList.setText(n, {decimal(1 + n, 2L), slotLoadDescription(n)});
+  }
+  stateList.autoSizeColumns();
+}
+
+void StateManager::reset() {
+  for(auto& slot : this->slot) slot = serializer();
+  synchronize();
+  refresh();
+}
+
+bool StateManager::load(string filename, unsigned revision) {
+  for(auto& slot : this->slot) slot = serializer();
+  synchronize();
+
+  file fp;
+  if(fp.open(filename, file::mode::read) == false) return false;
+
+  if(fp.readl(4) == 0x31415342 /* 'BSA1' */ && fp.readl(4) == revision) {
+    for(auto &slot : this->slot) {
+      if(fp.read() == false) continue;  //slot is empty
+      unsigned size = fp.readl(4);
+      uint8_t* data = new uint8_t[size];
+      fp.read(data, size);
+      slot = serializer(data, size);
+      delete[] data;
+    }
+  }
+
+  refresh();
+  synchronize();
+  return true;
+}
+
+bool StateManager::save(string filename, unsigned revision) {
+  bool hasSave = false;
+  for(auto& slot : this->slot) hasSave |= slot.capacity() > 0;
+  if(hasSave == false) {
+    file::remove(filename);
+    return true;
+  }
+
+  directory::create(filename.pathname());
+
+  file fp;
+  if(fp.open(filename, file::mode::write) == false) return false;
+
+  fp.writel(0x31415342, 4);  //'BSA1'
+  fp.writel(revision, 4);
+  for(auto& slot : this->slot) {
+    fp.write(slot.capacity() > 0);
+    if(slot.capacity()) {
+      fp.writel(slot.capacity(), 4);
+      fp.write(slot.data(), slot.capacity());
+    }
+  }
+
+  return true;
+}
+
+void StateManager::slotLoad() {
+  if(stateList.selected() == false) return;
+  serializer s(slot[stateList.selection()].data(), slot[stateList.selection()].capacity());
+  system().unserialize(s);
+}
+
+void StateManager::slotSave() {
+  if(stateList.selected()) {
+    slot[stateList.selection()] = system().serialize();
+  }
+  refresh();
+  synchronize();
+  descEdit.setFocused();
+}
+
+void StateManager::slotErase() {
+  if(stateList.selected()) {
+    slot[stateList.selection()] = serializer();
+  }
+  refresh();
+  synchronize();
+}
+
+string StateManager::slotLoadDescription(unsigned id) {
+  if(slot[id].capacity() == 0) return "(empty)";
+  char text[DescriptionLength];
+  memory::copy(text, (const char*)slot[id].data() + HeaderLength, DescriptionLength);
+  return text;
+  //string text;
+  //text.reserve(DescriptionLength);
+  //memory::copy(text.pointer(), (const char*)slot[id].data() + HeaderLength, DescriptionLength);
+  //text.resize(text.length());
+  //return text;
+}
+
+void StateManager::slotSaveDescription() {
+  if(stateList.selected() == false) return;
+  string text = descEdit.text();
+  if(slot[stateList.selection()].capacity() > 0) {
+    memory::copy((char*)slot[stateList.selection()].data() + HeaderLength, (const char*)text, DescriptionLength);
+  }
+  refresh();
+}
diff -Nru higan/target-ethos/tools/state-manager.hpp higan/target-ethos/tools/state-manager.hpp
--- higan/target-ethos/tools/state-manager.hpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/target-ethos/tools/state-manager.hpp	2015-09-16 14:06:03.413919283 +0900
@@ -0,0 +1,36 @@
+struct StateManager : ToolsLayout {
+  ListView stateList;
+  HorizontalLayout descLayout;
+    Label descLabel;
+    LineEdit descEdit;
+  HorizontalLayout controlLayout;
+    Button saveButton;
+    Button loadButton;
+    Widget spacer;
+    Button resetButton;
+    Button eraseButton;
+
+  void reset();
+  bool load(string filename, unsigned revision);
+  bool save(string filename, unsigned revision);
+
+  void slotLoad();
+  void slotSave();
+  void slotErase();
+  string slotLoadDescription(unsigned id);
+  void slotSaveDescription();
+
+  void refresh();
+  void synchronize();
+  StateManager();
+
+private:
+  enum : unsigned {
+    Slots = 32,
+    HeaderLength = 72,
+    DescriptionLength = 512,
+  };
+  serializer slot[Slots];
+};
+
+extern StateManager* stateManager;
diff -Nru higan/target-ethos/tools/tools.cpp higan/target-ethos/tools/tools.cpp
--- higan/target-ethos/tools/tools.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/target-ethos/tools/tools.cpp	2015-09-16 14:06:03.413919283 +0900
@@ -0,0 +1,25 @@
+#include "../ethos.hpp"
+#include "cheat-database.cpp"
+#include "cheat-editor.cpp"
+#include "state-manager.cpp"
+Tools* tools = nullptr;
+
+ToolsLayout::ToolsLayout() {
+  setMargin(5);
+}
+
+Tools::Tools() {
+  setGeometry({128, 128, 640, 360});
+  windowManager->append(this, "Tools");
+
+  setTitle("Tools");
+
+  layout.setMargin(5);
+  panels.append("Cheat Editor", {resource::cheatEditor, sizeof resource::cheatEditor});
+  panels.append("State Manager", {resource::stateManager, sizeof resource::stateManager});
+  panels.setLayout(0, *cheatEditor);
+  panels.setLayout(1, *stateManager);
+
+  append(layout);
+  layout.append(panels, {~0, ~0});
+}
diff -Nru higan/target-ethos/tools/tools.hpp higan/target-ethos/tools/tools.hpp
--- higan/target-ethos/tools/tools.hpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/target-ethos/tools/tools.hpp	2015-09-16 14:06:03.412919283 +0900
@@ -0,0 +1,16 @@
+struct ToolsLayout : VerticalLayout {
+  ToolsLayout();
+};
+
+#include "cheat-database.hpp"
+#include "cheat-editor.hpp"
+#include "state-manager.hpp"
+
+struct Tools : Window {
+  VerticalLayout layout;
+  TabFrame panels;
+
+  Tools();
+};
+
+extern Tools* tools;
diff -Nru higan/target-ethos/utility/utility.cpp higan/target-ethos/utility/utility.cpp
--- higan/target-ethos/utility/utility.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/target-ethos/utility/utility.cpp	2015-09-16 14:06:03.417919283 +0900
@@ -0,0 +1,320 @@
+#include "../ethos.hpp"
+Utility* utility = nullptr;
+
+void Utility::setInterface(Emulator::Interface* emulator) {
+  program->active = emulator;
+  presentation->synchronize();
+}
+
+//load from command-line, etc
+void Utility::loadMedia(string pathname) {
+  pathname.transform("\\", "/");
+  if(pathname.endsWith("/")) pathname.rtrim("/");
+
+  if(!directory::exists(pathname)) return;
+  string type = suffixname(pathname).ltrim(".");
+
+  //determine type by comparing extension against all emulation cores
+  for(auto& emulator : program->emulator) {
+    for(auto& media : emulator->media) {
+      if(media.bootable == false) continue;
+      if(type != media.type) continue;
+      loadMedia(emulator, media, {pathname, "/"});
+      libraryManager->setVisible(false);
+      return;
+    }
+  }
+
+  MessageWindow().setText("Unable to determine media type.").warning();
+}
+
+//load base cartridge
+void Utility::loadMedia(Emulator::Interface* emulator, Emulator::Interface::Media& media, string pathname) {
+  unload();
+  setInterface(emulator);
+  //path(0) = program->path({media.name, ".sys/"});
+  path(0) = locate({utility->libraryPath(), "System/"}, {media.name, ".sys/"});
+  path(media.id) = pathname;
+  this->pathname.append(pathname);
+
+  system().load(media.id);
+  system().power();
+
+  presentation->setSystemName(media.name);
+  presentation->setVisible();
+  load();
+}
+
+//request from emulation core to load non-volatile media folder
+void Utility::loadRequest(unsigned id, string name, string type, bool required) {
+  string pathname = libraryManager->load(type);
+  if(pathname.empty()) return;
+  path(id) = pathname;
+  this->pathname.append(pathname);
+
+  system().load(id);
+}
+
+//request from emulation core to load non-volatile media file
+void Utility::loadRequest(unsigned id, string path, bool required) {
+  string pathname = {this->path(system().group(id)), path};
+  if(file::exists(pathname) == false) {
+    if(required) MessageWindow().setParent(*presentation).setText({
+      "Missing required file: ", path, "\n\n",
+      "From location:\n", this->path(system().group(id))
+    }).error();
+    return;
+  }
+  mmapstream stream(pathname);
+  return system().load(id, stream);
+}
+
+//request from emulation core to save non-volatile media file
+void Utility::saveRequest(unsigned id, string path, bool required) {
+  string pathname = {this->path(system().group(id)), path};
+  filestream stream(pathname, file::mode::write);
+  return system().save(id, stream);
+}
+
+void Utility::connect(unsigned port, unsigned device) {
+  if(program->active == nullptr) return;
+  system().connect(port, device);
+}
+
+void Utility::power() {
+  if(program->active == nullptr) return;
+  system().power();
+}
+
+void Utility::reset() {
+  if(program->active == nullptr) return;
+  system().reset();
+}
+
+void Utility::load() {
+  presentation->setTitle(system().title());
+
+  cheatEditor->load({pathname[0], "cheats.bml"});
+  stateManager->load({pathname[0], "ethos/states.bsa"}, 1);
+
+  synchronizeDSP();
+
+  resize();
+  updateShader();
+  cheatEditor->synchronize();
+  cheatEditor->refresh();
+}
+
+void Utility::unload() {
+  if(program->active == nullptr) return;
+
+  cheatEditor->save({pathname[0], "cheats.bml"});
+  stateManager->save({pathname[0], "ethos/states.bsa"}, 1);
+
+  system().unload();
+  path.reset();
+  pathname.reset();
+  cheatEditor->reset();
+  stateManager->reset();
+  setInterface(nullptr);
+
+  video->clear();
+  audio->clear();
+  presentation->setTitle({"ethos v", Emulator::Version});
+  cheatDatabase->setVisible(false);
+  cheatEditor->setVisible(false);
+  stateManager->setVisible(false);
+}
+
+void Utility::saveState(unsigned slot) {
+  if(program->active == nullptr) return;
+  serializer s = system().serialize();
+  if(s.size() == 0) return;
+  directory::create({pathname[0], "ethos/"});
+  if(file::write({pathname[0], "ethos/state-", slot, ".bsa"}, s.data(), s.size()) == false);
+  showMessage({"Saved to slot ", slot});
+}
+
+void Utility::loadState(unsigned slot) {
+  if(program->active == nullptr) return;
+  auto memory = file::read({pathname[0], "ethos/state-", slot, ".bsa"});
+  if(memory.size() == 0) return showMessage({"Unable to locate slot ", slot, " state"});
+  serializer s(memory.data(), memory.size());
+  if(system().unserialize(s) == false) return showMessage({"Slot ", slot, " state incompatible"});
+  showMessage({"Loaded from slot ", slot});
+}
+
+void Utility::synchronizeDSP() {
+  if(program->active == nullptr) return;
+
+  if(config->video.synchronize == false) {
+    return dspaudio.setFrequency(system().audioFrequency());
+  }
+
+  double inputRatio = system().audioFrequency() / system().videoFrequency();
+  double outputRatio = config->timing.audio / config->timing.video;
+  double frequency = inputRatio / outputRatio * config->audio.frequency;
+
+  dspaudio.setFrequency(frequency);
+}
+
+void Utility::synchronizeRuby() {
+  video->set(Video::Synchronize, config->video.synchronize);
+  audio->set(Audio::Synchronize, config->audio.synchronize);
+  audio->set(Audio::Frequency, config->audio.frequency);
+  audio->set(Audio::Latency, config->audio.latency);
+
+  switch(config->audio.resampler) {
+  case 0: dspaudio.setResampler(DSP::ResampleEngine::Linear);  break;
+  case 1: dspaudio.setResampler(DSP::ResampleEngine::Hermite); break;
+  case 2: dspaudio.setResampler(DSP::ResampleEngine::Sinc);    break;
+  }
+  dspaudio.setResamplerFrequency(config->audio.frequency);
+  dspaudio.setVolume(config->audio.mute ? 0.0 : config->audio.volume * 0.01);
+  synchronizeDSP();
+}
+
+void Utility::updatePalette() {
+  if(program->active == nullptr) return;
+
+  if(config->video.shader == "Display Emulation" && config->video.driver == "OpenGL") {
+    system().paletteUpdate(Emulator::Interface::PaletteMode::Channel);
+  } else if(config->video.colorEmulation) {
+    system().paletteUpdate(Emulator::Interface::PaletteMode::Emulation);
+  } else {
+    system().paletteUpdate(Emulator::Interface::PaletteMode::Standard);
+  }
+}
+
+void Utility::updateShader() {
+  if(config->video.shader == "None") {
+    video->set(Video::Shader, (string)"");
+    video->set(Video::Filter, Video::FilterNearest);
+  } else if(config->video.shader == "Blur") {
+    video->set(Video::Shader, (string)"");
+    video->set(Video::Filter, Video::FilterLinear);
+  } else if(config->video.shader == "Display Emulation" && config->video.driver != "OpenGL") {
+    video->set(Video::Shader, (string)"");
+    video->set(Video::Filter, Video::FilterLinear);
+  } else if(config->video.shader == "Display Emulation") {
+    if(program->active) {
+      string pathname = program->path("Video Shaders/");
+      pathname.append("Display Emulation/");
+      pathname.append(presentation->systemName, ".shader/");
+      if(directory::exists(pathname)) {
+        video->set(Video::Shader, pathname);
+      } else {
+        video->set(Video::Shader, (string)"");
+        video->set(Video::Filter, Video::FilterLinear);
+      }
+    } else {
+      video->set(Video::Shader, (string)"");
+      video->set(Video::Filter, Video::FilterLinear);
+    }
+  } else {
+    video->set(Video::Shader, config->video.shader);
+  }
+  updatePalette();
+}
+
+void Utility::resize(bool resizeWindow) {
+  if(program->active == nullptr) {
+    auto geometry = presentation->geometry();
+    presentation->viewport.setGeometry({0, 0, geometry.width, geometry.height});
+    return;
+  }
+
+  Geometry geometry = presentation->geometry();
+  unsigned width  = system().information.width;
+  unsigned height = system().information.height;
+
+  unsigned scaledWidth  = geometry.width  / width;
+  unsigned scaledHeight = geometry.height / height;
+  unsigned multiplier   = max(1u, min(scaledWidth, scaledHeight));
+
+  if(config->video.aspectCorrection) {
+    width *= system().information.aspectRatio;
+  }
+
+  width  *= multiplier;
+  height *= multiplier;
+
+  unsigned scaleMode = 0;
+
+  if(config->video.scaleMode == 1) {
+    width  = (double)width * ((double)geometry.height / height);
+    height = geometry.height;
+  }
+
+  if(config->video.scaleMode == 2) {
+    width  = geometry.width;
+    height = geometry.height;
+  }
+
+  if(resizeWindow == false) {
+    if(geometry.width  < width ) width  = geometry.width;
+    if(geometry.height < height) height = geometry.height;
+
+    presentation->viewport.setGeometry({
+      (geometry.width - width) / 2, (geometry.height - height) / 2, width, height
+    });
+  } else {
+    presentation->setGeometry({geometry.x, geometry.y, width, height});
+    presentation->viewport.setGeometry({0, 0, width, height});
+  }
+
+  presentation->synchronize();
+}
+
+void Utility::toggleFullScreen() {
+  static Geometry geometry;
+
+  if(presentation->fullScreen() == false) {
+    geometry = presentation->geometry();
+    presentation->setMenuVisible(false);
+    presentation->setStatusVisible(false);
+    presentation->setFullScreen(true);
+    if(!input->acquired()) input->acquire();
+  } else {
+    if(input->acquired()) input->release();
+    presentation->setMenuVisible(true);
+    presentation->setStatusVisible(true);
+    presentation->setFullScreen(false);
+    presentation->setGeometry(geometry);
+  }
+
+  resize();
+}
+
+void Utility::updateStatus() {
+  time_t currentTime = time(0);
+  string text;
+  if((currentTime - statusTime) <= 2) {
+    text = statusMessage;
+  } else if(program->active == nullptr) {
+    text = "No cartridge loaded";
+  } else if(program->pause || program->autopause) {
+    text = "Paused";
+  } else {
+    text = statusText;
+  }
+  if(text != presentation->statusText()) {
+    presentation->setStatusText(text);
+  }
+}
+
+void Utility::setStatusText(string text) {
+  statusText = text;
+}
+
+void Utility::showMessage(string message) {
+  statusTime = time(0);
+  statusMessage = message;
+}
+
+string Utility::libraryPath() {
+  string path = string::read({configpath(), "ethos/library.bml"}).strip().ltrim("Path: ").transform("\\", "/");
+  if(path.empty()) path = {userpath(), "Emulation/"};
+  if(path.endsWith("/") == false) path.append("/");
+  return path;
+}
diff -Nru higan/target-ethos/utility/utility.hpp higan/target-ethos/utility/utility.hpp
--- higan/target-ethos/utility/utility.hpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/target-ethos/utility/utility.hpp	2015-09-16 14:06:03.416919283 +0900
@@ -0,0 +1,42 @@
+struct Utility {
+  void setInterface(Emulator::Interface* emulator);
+
+  void loadMedia(string pathname);
+  void loadMedia(Emulator::Interface* emulator, Emulator::Interface::Media& media, string pathname);
+
+  void loadRequest(unsigned id, string name, string type, bool required);
+  void loadRequest(unsigned id, string path, bool required);
+  void saveRequest(unsigned id, string path, bool required);
+
+  void connect(unsigned port, unsigned device);
+  void power();
+  void reset();
+  void load();
+  void unload();
+
+  void saveState(unsigned slot);
+  void loadState(unsigned slot);
+
+  void synchronizeDSP();
+  void synchronizeRuby();
+  void updatePalette();
+  void updateShader();
+  void resize(bool resizeWindow = false);
+  void toggleFullScreen();
+
+  void updateStatus();
+  void setStatusText(string text);
+  void showMessage(string message);
+
+  string libraryPath();
+
+  lstring path;
+  lstring pathname;
+
+private:
+  string statusText;
+  string statusMessage;
+  time_t statusTime = 0;
+};
+
+extern Utility* utility;
diff -Nru higan/target-ethos/window/window.cpp higan/target-ethos/window/window.cpp
--- higan/target-ethos/window/window.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/target-ethos/window/window.cpp	2015-09-16 14:06:03.415919283 +0900
@@ -0,0 +1,39 @@
+#include "../ethos.hpp"
+WindowManager* windowManager = nullptr;
+
+void WindowManager::append(Window* window, string name) {
+  window->setMenuFont(program->normalFont);
+  window->setWidgetFont(program->normalFont);
+  window->setStatusFont(program->boldFont);
+  windowList.append({window, name, window->geometry().text()});
+}
+
+void WindowManager::loadGeometry() {
+  static bool initialized = false;
+  if(initialized == false) {
+    initialized = true;
+    Configuration::Node geometry;
+    for(auto& window : windowList) {
+      geometry.append(window.geometry, window.name);
+    }
+    config.append(geometry, "Geometry");
+  }
+  config.load(program->path("geometry.bml"));
+  config.save(program->path("geometry.bml"));
+  for(auto& window : windowList) {
+    window.window->setGeometry(window.geometry);
+  }
+}
+
+void WindowManager::saveGeometry() {
+  for(auto& window : windowList) {
+    window.geometry = window.window->geometry().text();
+  }
+  config.save(program->path("geometry.bml"));
+}
+
+void WindowManager::hideAll() {
+  for(auto& window : windowList) {
+    window.window->setVisible(false);
+  }
+}
diff -Nru higan/target-ethos/window/window.hpp higan/target-ethos/window/window.hpp
--- higan/target-ethos/window/window.hpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/target-ethos/window/window.hpp	2015-09-16 14:06:03.416919283 +0900
@@ -0,0 +1,18 @@
+struct WindowManager {
+  struct WindowList {
+    Window* window;
+    string name;
+    string geometry;
+  };
+  vector<WindowList> windowList;
+
+  void append(Window* window, string name);
+  void loadGeometry();
+  void saveGeometry();
+  void hideAll();
+
+private:
+  Configuration::Document config;
+};
+
+extern WindowManager* windowManager;

