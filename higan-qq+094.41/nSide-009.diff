diff -Nru higan/ananke/ananke.cpp higan/ananke/ananke.cpp
--- higan/ananke/ananke.cpp	2015-09-16 02:20:06.353574578 +0900
+++ higan/ananke/ananke.cpp	2015-09-16 14:33:30.612088241 +0900
@@ -10,6 +10,7 @@
 using namespace phoenix;
 
 namespace Database {
+  #include "database/famicom.hpp"
   #include "database/super-famicom.hpp"
   #include "database/sufami-turbo.hpp"
   #include "database/bsx-satellaview.hpp"
@@ -37,6 +38,7 @@
 
   //famicom.cpp
   void copyFamicomSaves(const string &pathname);
+  string createFamicomDatabase(vector<uint8_t> &buffer, Markup::Node &document, const string &manifest);
   string createFamicomHeuristic(vector<uint8_t> &buffer);
   string openFamicom(vector<uint8_t> &buffer);
   string syncFamicom(const string &pathname);
diff -Nru higan/ananke/bsx-satellaview.cpp higan/ananke/bsx-satellaview.cpp
--- higan/ananke/bsx-satellaview.cpp	2015-09-16 02:20:06.353574578 +0900
+++ higan/ananke/bsx-satellaview.cpp	2015-09-16 14:33:30.611088241 +0900
@@ -51,7 +51,7 @@
 
   for(auto &item : databaseItem) {
     item.append("\n");
-    auto document = Markup::Document(item);
+    auto document = BML::unserialize(item);
 
     if(document["release/information/sha256"].text() == sha256) {
       return createBsxSatellaviewDatabase(buffer, document, item);
diff -Nru higan/ananke/database/famicom.hpp higan/ananke/database/famicom.hpp
--- higan/ananke/database/famicom.hpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/ananke/database/famicom.hpp	2015-09-16 14:33:30.611088241 +0900
@@ -0,0 +1,2510 @@
+string Famicom = R"(
+
+database revision=2012-10-22
+
+release
+  cartridge region=NTSC
+    board type=KONAMI-VRC-6
+    chip type=VRC6
+      pinout a0=0 a1=1
+    prg
+      rom name=program.rom size=0x40000
+    chr
+      rom name=character.rom size=0x20000
+  information
+    title:    悪魔城伝説
+    name:     Akumajou Densetsu
+    region:   JP
+    revision: 1.0
+    board:    351951
+    serial:   KON-RC845
+    sha256:   c70f0f5d4054ce7c4850259879c9823add73ccc234ddcf96d95681bb78bd2c58
+    configuration
+      rom name=program.rom size=0x40000
+      rom name=character.rom size=0x20000
+
+release
+  cartridge region=NTSC
+    board type=KONAMI-UNROM
+    chip type=74HC32
+    mirror mode=vertical
+    prg
+      rom name=program.rom size=0x20000
+    chr
+      ram size=0x2000
+  information
+    title:    悪魔城ドラキュラ
+    name:     Akumajou Dracula
+    region:   JP
+    revision: 1.0
+    board:    353525
+    serial:   KON-RV003
+    sha256:   60b1aebdc0a19afc5d3e7dc4f09d8a968580e007197461a8a142656702c27f0d
+    configuration
+      rom name=program.rom size=0x20000
+      ram name=character.ram size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=HVC-TLSROM
+    chip type=MMC3B
+    prg
+      rom name=program.rom size=0x40000
+    chr
+      rom name=character.rom size=0x20000
+  information
+    title:    アルマジロ
+    name:     Armadillo
+    region:   JP
+    revision: 1.0
+    board:    HVC-TLSROM-01
+    serial:   IGS-9T
+    sha256:   54526dc9444c0eb4b0e5814f98b5e522bcb9881a6f2c0644fc7a21ca8c03502b
+    configuration
+      rom name=program.rom size=0x40000
+      rom name=character.rom size=0x20000
+
+release
+  cartridge region=NTSC
+    board type=NAMCOT-3401
+    mirror mode=horizontal
+    prg
+      rom name=program.rom size=0x8000
+    chr
+      rom name=character.rom size=0x8000
+  information
+    title:    バベルの塔
+    name:     Babel no Tou
+    region:   JP
+    revision: 1.0
+    board:    3401
+    serial:   NAM-NBL-3900-16
+    sha256:   a9d7e89bd4ea28cfd169e32c4516ef5d059e19afb9dfa4ede8412f2373dfb0a7
+    configuration
+      rom name=program.rom size=0x8000
+      rom name=character.rom size=0x8000
+
+release
+  cartridge region=NTSC
+    board type=HVC-CNROM
+      security pass=0x3
+    mirror mode=horizontal
+    prg
+      rom name=program.rom size=0x8000
+    chr
+      rom name=character.rom size=0x2000
+  information
+    title:    B-ワイング
+    name:     B-Wings
+    region:   JP
+    revision: 1.0
+    board:    HVC-CNROM-256K-01
+    serial:   DFC-BW
+    sha256:   2b4ac20082e2f45a8f8fd4922a0e995829719a523e118a9eec891c3206adf25b
+    configuration
+      rom name=program.rom size=0x8000
+      rom name=character.rom size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=HVC-CNROM
+      security pass=0x3
+    mirror mode=vertical
+    prg
+      rom name=program.rom size=0x4000
+    chr
+      rom name=character.rom size=0x2000
+  information
+    title:    バード・ウィーク
+    name:     Bird Week
+    region:   JP
+    revision: 1.0
+    board:    HVC-CNROM-256K-01
+    serial:   TFS-BK
+    sha256:   acf054b0886a2ca74a0280fc36bc1d55e9845acc29759f1893c1da4c1389f9c2
+    configuration
+      rom name=program.rom size=0x4000
+      rom name=character.rom size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=JALECO-JF-05
+    mirror mode=vertical
+    prg
+      rom name=program.rom size=0x4000
+    chr
+      rom name=character.rom size=0x4000
+  information
+    title:    シティコネクション
+    name:     City Connection
+    region:   JP
+    revision: 1.0
+    board:    JF-05
+    serial:   JF-05
+    sha256:   72c69f068099e42844bfe17e7d37f439243fad10b283650cac041e78443e0300
+    configuration
+      rom name=program.rom size=0x4000
+      rom name=character.rom size=0x4000
+
+release
+  cartridge region=NTSC
+    board type=KONAMI-VRC-2
+    chip type=VRC2
+      pinout a0=0 a1=1
+    prg
+      rom name=program.rom size=0x20000
+    chr
+      rom name=character.rom size=0x20000
+  information
+    title:    コントラ 魂斗羅
+    name:     Contra
+    region:   JP
+    revision: 1.0
+    board:    LROG009-00
+    serial:   KON-RC826
+    sha256:   62c9d4e0578cb1e615ce9bb2c8ebc15b1e8de4c928c5c07ba9a85c11aa36ae4d
+    configuration
+      rom name=program.rom size=0x20000
+      rom name=character.rom size=0x20000
+
+release
+  cartridge region=NTSC
+    board type=HVC-UNROM
+    chip type=74HC08
+    mirror mode=horizontal
+    prg
+      rom name=program.rom size=0x20000
+    chr
+      ram size=0x2000
+  information
+    title:    クレイジークライマー
+    name:     Crazy Climber
+    region:   JP
+    revision: 1.0
+    board:    HVC-UNROM-02
+    serial:   NBF-CY (04)
+    sha256:   e24d3c754dce20e27046afeacb2dfc217950d4be766ded80c20283392cb3891e
+    configuration
+      rom name=program.rom size=0x20000
+      ram name=character.ram size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=IREM-H3001
+    chip type=IF-H3001
+    prg
+      rom name=program.rom size=0x40000
+    chr
+      rom name=character.rom size=0x40000
+  information
+    title:    大工の源さん2 赤毛のダンの逆襲
+    name:     Daiku no Gen-san 2 - Akage no Dan no Gyakushuu
+    region:   JP
+    revision: 1.0
+    board:    FC-00-017C
+    serial:   IF-29
+    sha256:   a1d9bcf389d6837581cd33a26b4e13917d084e3e69dbe89453e443fc9976fa22
+    configuration
+      rom name=program.rom size=0x40000
+      rom name=character.rom size=0x40000
+
+release
+  cartridge region=NTSC
+    board type=NAMCOT-3453
+    chip type=118
+    prg
+      rom name=program.rom size=0x20000
+    chr
+      rom name=character.rom size=0x20000
+  information
+    title:    デビルマン
+    name:     Devil Man
+    region:   JP
+    revision: 1.0
+    board:    UNK-NAMCOT-DM
+    serial:   NAM-DM-5500
+    sha256:   d2140fc2e6354a9f4d0154dabac757e5559890edba4885799c1c979d8b7a8b20
+    configuration
+      rom name=program.rom size=0x20000
+      rom name=character.rom size=0x20000
+
+release
+  cartridge region=NTSC
+    board type=TAITO-TC0190FMC
+    chip type=TC0190FMC
+    chip type=PAL16R4
+    prg
+      rom name=program.rom size=0x20000
+    chr
+      rom name=character.rom size=0x40000
+  information
+    title:    ドンドコドン2
+    name:     Don Doko Don 2
+    region:   JP
+    revision: 1.0
+    board:    J9100287A
+    serial:   TFC-DDII-5900-41
+    sha256:   fb0b3aab3fb22ab78b1d94fcbc730ed440591fdc359caec9e9f1d45682a38d01
+    configuration
+      rom name=program.rom size=0x20000
+      rom name=character.rom size=0x40000
+
+release
+  cartridge region=NTSC
+    board type=HVC-NROM-128
+    mirror mode=horizontal
+    prg
+      rom name=program.rom size=0x4000
+    chr
+      rom name=character.rom size=0x2000
+  information
+    title:    ドンキーコング
+    name:     Donkey Kong
+    region:   JP
+    revision: 1.0
+    board:    9011-01
+    serial:   HVC-DK
+    sha256:   dd108e55b60070b4c0147f7dba31844ed83065255466bfacd5038e6382483026
+    configuration
+      rom name=program.rom size=0x4000
+      rom name=character.rom size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=HVC-NROM-128
+    mirror mode=horizontal
+    prg
+      rom name=program.rom size=0x4000
+    chr
+      rom name=character.rom size=0x2000
+  information
+    title:    ドンキーコング
+    name:     Donkey Kong
+    region:   JP
+    revision: 1.1
+    board:    HVC-NROM-02
+    serial:   HVC-DK
+    sha256:   aa408f5a6b97c0d738e7e8b489a5617ad4a9ecdee2b05c4ee504210ce31b2825
+    configuration
+      rom name=program.rom size=0x4000
+      rom name=character.rom size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=HVC-HROM
+    prg
+      rom name=program.rom size=0x4000
+    chr
+      rom name=character.rom size=0x2000
+  information
+    title:    ドンキーコングJr
+    name:     Donkey Kong Jr.
+    region:   JP
+    revision: 1.0
+    board:    HVC-HROM-01
+    serial:   HVC-JR
+    sha256:   950ebe68e7f74219b9e5e104200b03165d59c24264f02e32c12be967fd311ac2
+    configuration
+      rom name=program.rom size=0x4000
+      rom name=character.rom size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=NAMCOT-3425
+    chip type=118
+    prg
+      rom name=program.rom size=0x20000
+    chr
+      rom name=character.rom size=0x8000
+  information
+    title:    ドラゴンバスター
+    name:     Dragon Buster
+    region:   JP
+    revision: 1.0
+    board:    3425
+    serial:   NAM-DB-4900
+    sha256:   b1a7377282123b3b18107e0d929666af8831bebde78ceaf7fe410c2132cd61ce
+    configuration
+      rom name=program.rom size=0x20000
+      rom name=character.rom size=0x8000
+
+release
+  cartridge region=NTSC
+    board type=HVC-RROM
+    mirror mode=vertical
+    prg
+      rom name=program.rom size=0x4000
+    chr
+      rom name=character.rom size=0x2000
+  information
+    title:    ダックハント
+    name:     Duck Hunt
+    region:   JP
+    revision: 1.0
+    board:    HVC-RROM-05
+    serial:   HVC-DH
+    sha256:   7026334a7e8742b61b450f4b3b182922c6a69fc723d7cd19c83db365f15e45ba
+    configuration
+      rom name=program.rom size=0x4000
+      rom name=character.rom size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=FDS
+    prg
+      rom name=program.rom size=0x2000
+      ram size=0x8000
+    chr
+      ram size=0x2000
+  information
+    title:    Famicom Disk System
+    name:     Famicom Disk System
+    region:   JP
+    revision: 1.0
+    board:    Famicom Disk System
+    serial:   N/A
+    sha256:   99c18490ed9002d9c6d999b9d8d15be5c051bdfa7cc7e73318053c9a994b0178
+    configuration
+      rom name=program.rom size=0x2000
+      ram name=work.ram size=0x8000
+      ram name=character.ram size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=BANDAI-JUMP2
+    chip type=LZ93D50
+    prg
+      rom name=program.rom size=0x80000
+      ram name=save.ram size=0x2000
+    chr
+      ram size=0x2000
+  information
+    title:    ファミコンジャンプII 最強の7人
+    name:     Famicom Jump II - Saikyou no 7 Nin
+    region:   JP
+    revision: 1.0
+    board:    BA-JUMP2
+    serial:   BA-FJ2
+    sha256:   dd031b72924e1d080f8758412c73224a274ae5e5a50d90310d578975df74101f
+    configuration
+      rom name=program.rom size=0x80000
+      ram name=save.ram size=0x2000
+      ram name=character.ram size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=HVC-FJROM
+    chip type=MMC4
+    prg
+      rom name=program.rom size=0x20000
+      ram name=save.ram size=0x2000
+    chr
+      rom name=character.rom size=0x10000
+  information
+    title:    ファミコンウォーズ
+    name:     Famicom Wars
+    region:   JP
+    revision: 1.0
+    board:    HVC-FJROM-01
+    serial:   HVC-FW
+    sha256:   7586cdd8b742ba3c4f0ea3eefaa2f6f2215af197a5269e3de9026bcdf236e981
+    configuration
+      rom name=program.rom size=0x20000
+      ram name=save.ram size=0x2000
+      rom name=character.rom size=0x10000
+
+release
+  cartridge region=NTSC
+    board type=BANDAI-PT-554
+    mirror mode=horizontal
+    prg
+      rom name=program.rom size=0x8000
+    chr
+      rom name=character.rom size=0x8000
+  information
+    title:    ファミリートレーナー3 エアロビスタジオ
+    name:     Family Trainer 3 - Aerobics Studio
+    region:   JP
+    revision: 1.0
+    board:    BA-エアロビ
+    serial:   FT-03
+    sha256:   27c6e9bf1de790ce831a4e9211c897fab813b2f4447a897efaad905f2488d761
+    configuration
+      rom name=program.rom size=0x8000
+      rom name=character.rom size=0x8000
+
+release
+  cartridge region=NTSC
+    board type=HVC-SNROM
+    chip type=MMC1A
+    prg
+      rom name=program.rom size=0x40000
+      ram name=save.ram size=0x2000
+    chr
+      ram size=0x2000
+  information
+    title:    ファイナルファンタジーII
+    name:     Final Fantasy II
+    region:   JP
+    revision: 1.0
+    board:    HVC-SNROM-07
+    serial:   SQF-FY
+    sha256:   60c65138a0edecee77e7fa808291d6198ef2ebd10b1fd2bc4f047298d93a4cc0
+    configuration
+      rom name=program.rom size=0x40000
+      ram name=save.ram size=0x2000
+      ram name=character.ram size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=HVC-SXROM
+    chip type=MMC1B2
+    prg
+      rom name=program.rom size=0x80000
+      ram name=save.ram size=0x8000
+    chr
+      ram size=0x2000
+  information
+    title:    ファイナルファンタジーI・II
+    name:     Final Fantasy I & II
+    region:   JP
+    revision: 1.0
+    board:    HVC-SXROM-01
+    serial:   SQF-FO
+    sha256:   a637619a8b794ac9382723930b5be0e5a3d37991d2804b1ee637eced44b2b494
+    configuration
+      rom name=program.rom size=0x80000
+      ram name=save.ram size=0x8000
+      ram name=character.ram size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=HVC-TNROM
+    chip type=MMC3B
+    prg
+      rom name=program.rom size=0x80000
+      ram name=save.ram size=0x2000
+    chr
+      ram size=0x2000
+  information
+    title:    ファイナルファンタジーIII
+    name:     Final Fantasy III
+    region:   JP
+    revision: 1.0
+    board:    HVC-TNROM-01
+    serial:   SQF-FC
+    sha256:   7ff89b50156b6f5b3d78d3d2eeec8a9221d9f7b18f8350abf89b7867a205f710
+    configuration
+      rom name=program.rom size=0x80000
+      ram name=save.ram size=0x2000
+      ram name=character.ram size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=HVC-FKROM
+    chip type=MMC4
+    prg
+      rom name=program.rom size=0x40000
+      ram name=save.ram size=0x2000
+    chr
+      rom name=character.rom size=0x20000
+  information
+    title:    ファイアーエムブレム 暗黒竜と光の剣
+    name:     Fire Emblem 1 - Ankoku Ryuu to Hikari no Tsurugi
+    region:   JP
+    revision: 1.0
+    board:    HVC-FKROM-01
+    serial:   HVC-VX
+    sha256:   60db7fd78cc849658a42ca648f0d294ebf21e477ddf0753f0e6bbffaad6192ab
+    configuration
+      rom name=program.rom size=0x40000
+      ram name=save.ram size=0x2000
+      rom name=character.rom size=0x20000
+
+release
+  cartridge region=NTSC
+    board type=HVC-FKROM
+    chip type=MMC4
+    prg
+      rom name=program.rom size=0x40000
+      ram name=save.ram size=0x2000
+    chr
+      rom name=character.rom size=0x20000
+  information
+    title:    ファイアーエムブレム外伝
+    name:     Fire Emblem 2 - Gaiden
+    region:   JP
+    revision: 1.0
+    board:    HVC-FKROM-01
+    serial:   HVC-2I
+    sha256:   0d899d67c7a61b13151f465c38c63a0d2d6a42d6be2d4ecac0fef87d55d92f92
+    configuration
+      rom name=program.rom size=0x40000
+      ram name=save.ram size=0x2000
+      rom name=character.rom size=0x20000
+
+release
+  cartridge region=NTSC
+    board type=NAMCOT-3301
+    mirror mode=horizontal
+    prg
+      rom name=program.rom size=0x4000
+    chr
+      rom name=character.rom size=0x2000
+  information
+    title:    ギャラガ
+    name:     Galaga
+    region:   JP
+    revision: 1.0
+    board:    3301
+    serial:   NAM-NGG-4500-05
+    sha256:   e6fe68b9f12578e74ba016ca146aaf8232b20475fb675c7d32e0ea4e47eb1cc8
+    configuration
+      rom name=program.rom size=0x4000
+      rom name=character.rom size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=NAMCOT-3301
+    mirror mode=horizontal
+    prg
+      rom name=program.rom size=0x2000
+    chr
+      rom name=character.rom size=0x2000
+  information
+    title:    ギャラクシアン
+    name:     Galaxian
+    region:   JP
+    revision: 1.0
+    board:    3301
+    serial:   NAM-NGX-4500-01
+    sha256:   50178a2856f8ed3574b4e7fd45b9d1ec44c660d51fe9783d0012a19df5892cce
+    configuration
+      rom name=program.rom size=0x2000
+      rom name=character.rom size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=SUNSOFT-5B
+    chip type=Sunsoft-5B
+    prg
+      rom name=program.rom size=0x40000
+    chr
+      rom name=character.rom size=0x20000
+  information
+    title:    ギミック!
+    name:     Gimmick!
+    region:   JP
+    revision: 1.0
+    board:    FC-GMK
+    serial:   SUN-GMK-6200
+    sha256:   1bbe4b3e20a004a4f741018e31e6ae291772b8876d6fb6f01494c9c5b0917c6c
+    configuration
+      rom name=program.rom size=0x40000
+      rom name=character.rom size=0x20000
+
+release
+  cartridge region=NTSC
+    board type=KONAMI-74*139/74
+    mirror mode=vertical
+    prg
+      rom name=program.rom size=0x8000
+    chr
+      rom name=character.rom size=0x4000
+  information
+    title:    グーニーズ
+    name:     Goonies, The
+    region:   JP
+    revision: 1.0
+    board:    302047A
+    serial:   KON-RC809
+    sha256:   f837e0807ade4bb8036d40746e2433ed66986f043fc2be722e765e45a676cd5d
+    configuration
+      rom name=program.rom size=0x8000
+      rom name=character.rom size=0x4000
+
+release
+  cartridge region=NTSC
+    board type=HVC-SROM
+    mirror mode=vertical
+    prg
+      rom name=program.rom size=0x4000
+    chr
+      rom name=character.rom size=0x2000
+  information
+    title:    ホーガンズアレイ
+    name:     Hogan's Alley
+    region:   JP
+    revision: 1.0
+    board:    HVC-SROM-03
+    serial:   HVC-HA
+    sha256:   8e4a04076b6a728a7e65a09737776dcb9defed7922bf0437d9a89bbe8c724b55
+    configuration
+      rom name=program.rom size=0x4000
+      rom name=character.rom size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=IREM-HOLYDIVER
+    prg
+      rom name=program.rom size=0x20000
+    chr
+      rom name=character.rom size=0x20000
+  information
+    title:    ホーリーダイヴァー
+    name:     Holy Diver
+    region:   JP
+    revision: 1.0
+    board:    UNK-IF-12
+    serial:   IF-12
+    sha256:   1c1ad2992f728c7fb6a8f3980b1a0f8e01e5b24a0c43c713300846d87be5987a
+    configuration
+      rom name=program.rom size=0x20000
+      rom name=character.rom size=0x20000
+
+release
+  cartridge region=NTSC
+    board type=IREM-G101
+    chip type=G-101
+    prg
+      rom name=program.rom size=0x20000
+      ram size=0x2000
+    chr
+      rom name=character.rom size=0x20000
+  information
+    title:    イメージファイト
+    name:     Image Fight
+    region:   JP
+    revision: 1.0
+    board:    FC-00-015
+    serial:   IF-14
+    sha256:   c9707547555d8c38014540204649125f7b36d3990433bfebb63c49742e2dc3a2
+    configuration
+      rom name=program.rom size=0x20000
+      ram name=work.ram size=0x2000
+      rom name=character.rom size=0x20000
+
+release
+  cartridge region=NTSC
+    board type=JALECO-JF-27
+    chip type=SS88006
+    prg
+      rom name=program.rom size=0x20000
+      ram name=save.ram size=0x2000
+    chr
+      rom name=character.rom size=0x20000
+  information
+    title:    じゃじゃ丸撃魔伝 ~幻の金魔城~
+    name:     Jajamaru Gekimaden - Maboroshi no Kinmajou
+    region:   JP
+    revision: 1.0
+    board:    JF-27B
+    serial:   JF-27
+    sha256:   ea770788f68e4bb089e4205807931d64b83175a0106e7563d0a6d3ebac369991
+    configuration
+      rom name=program.rom size=0x20000
+      ram name=save.ram size=0x2000
+      rom name=character.rom size=0x20000
+
+release
+  cartridge region=NTSC
+    board type=HVC-EKROM
+    chip type=MMC5A
+    prg
+      rom name=program.rom size=0x80000
+      ram name=save.ram size=0x2000
+    chr
+      rom name=character.rom size=0x40000
+  information
+    title:    ジャストブリード
+    name:     Just Breed
+    region:   JP
+    revision: 1.0
+    board:    HVC-EKROM-01
+    serial:   EFC-I5
+    sha256:   f40341cf7e76480465ba8ab2d09e44644c3e3af7d647dc04c8b38357b26e014a
+    configuration
+      rom name=program.rom size=0x80000
+      ram name=save.ram size=0x2000
+      rom name=character.rom size=0x40000
+
+release
+  cartridge region=NTSC
+    board type=IREM-TAM-S1
+    chip type=TAM-S1
+    prg
+      rom name=program.rom size=0x40000
+    chr
+      ram size=0x2000
+  information
+    title:    快傑ヤンチャ丸
+    name:     Kaiketsu Yanchamaru
+    region:   JP
+    revision: 1.0
+    board:    FC-00-003
+    serial:   IF-07
+    sha256:   ced7f840a0cae6fe82aca994858e3c407d2ff9b2396f0b43cdbaddc7e9f2bc1d
+    configuration
+      rom name=program.rom size=0x40000
+      ram name=character.ram size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=HVC-NROM-256
+    mirror mode=vertical
+    prg
+      rom name=program.rom size=0x8000
+    chr
+      rom name=character.rom size=0x2000
+  information
+    title:    マッハライダー
+    name:     Mach Rider
+    region:   JP
+    revision: 1.1
+    board:    3I
+    serial:   HVC-MR
+    sha256:   944105c6dcc57314968d53a2e0dcdfc0e2b60678a53839ba25925416a7ac0e8c
+    configuration
+      rom name=program.rom size=0x8000
+      rom name=character.rom size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=JALECO-JF-24
+    chip type=SS88006
+    prg
+      rom name=program.rom size=0x20000
+    chr
+      rom name=character.rom size=0x20000
+  information
+    title:    マジック・ジョン
+    name:     Magic John
+    region:   JP
+    revision: 1.0
+    board:    JF-24A
+    serial:   JF-30
+    sha256:   497c3015516cb6ae2f20d70b8fb1b70b8c4cfcd64e118992c438cfe7b0579f2b
+    configuration
+      rom name=program.rom size=0x20000
+      rom name=character.rom size=0x20000
+
+release
+  cartridge region=NTSC
+    board type=IREM-G101
+    chip type=G-101
+    mirror mode=screen-1
+    prg
+      rom name=program.rom size=0x20000
+    chr
+      rom name=character.rom size=0x20000
+  information
+    title:    メジャーリーグ
+    name:     Major League
+    region:   JP
+    revision: 1.0
+    board:    UNK-IF-13
+    serial:   IF-13
+    sha256:   4ef61de405406bfa9eeaf19ed1d882444c41bb606ac78673b7ec8ee323d0e073
+    configuration
+      rom name=program.rom size=0x20000
+      rom name=character.rom size=0x20000
+
+release
+  cartridge region=NTSC
+    board type=IREM-BNROM
+    mirror mode=horizontal
+    prg
+      rom name=program.rom size=0x20000
+    chr
+      ram size=0x2000
+  information
+    title:    魔鐘
+    name:     Mashou
+    region:   JP
+    revision: 1.0
+    board:    IREM-I-IM
+    serial:   IF-05
+    sha256:   4ac0926d1e4704e75e7dfc27c4d990ebdbe685002b9af1a80a385604f3cb162c
+    configuration
+      rom name=program.rom size=0x20000
+      ram name=character.ram size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=HVC-SJROM
+    chip type=MMC1A
+    prg
+      rom name=program.rom size=0x20000
+      ram name=save.ram size=0x2000
+    chr
+      rom name=character.rom size=0x8000
+  information
+    title:    ザ・マネーゲーム
+    name:     Money Game, The
+    region:   JP
+    revision: 1.0
+    board:    HVC-SJROM-01
+    serial:   SFL-MY
+    sha256:   f2aef1a9ade54330ff821083fda7e03c7a5f93d77f4da359069d84f98ab1f852
+    configuration
+      rom name=program.rom size=0x20000
+      ram name=save.ram size=0x2000
+      rom name=character.rom size=0x8000
+
+release
+  cartridge region=NTSC
+    board type=HVC-TKROM
+    chip type=MMC3A
+    prg
+      rom name=program.rom size=0x40000
+      ram name=save.ram size=0x2000
+    chr
+      rom name=character.rom size=0x20000
+  information
+    title:    MOTHER
+    name:     MOTHER
+    region:   JP
+    revision: 1.0
+    board:    HVC-TKROM-01
+    serial:   HVC-MX
+    sha256:   aa0fe1b0b1e0c3a0a01695f1914fbb5e92649db33b74a9bdcb51be1481221f49
+    configuration
+      rom name=program.rom size=0x40000
+      ram name=save.ram size=0x2000
+      rom name=character.rom size=0x20000
+
+release
+  cartridge region=NTSC
+    board type=IREM-74*161/161/21/138
+    prg
+      rom name=program.rom size=0x20000
+    chr
+      rom name=character.rom size=0x8000
+      ram size=0x2000
+  information
+    title:    ナポレオン戦記
+    name:     Napoleon Senki
+    region:   JP
+    revision: 1.0
+    board:    LROG017-00
+    serial:   IF-09
+    sha256:   83d326a461cca8dc539283dc8017985e9a6cd1893db4674de1a086c7cb8b0269
+    configuration
+      rom name=program.rom size=0x20000
+      rom name=character.rom size=0x8000
+      ram name=character.ram size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=HVC-TLROM
+    chip type=MMC3C
+    prg
+      rom name=program.rom size=0x20000
+    chr
+      rom name=character.rom size=0x20000
+  information
+    title:    熱血格闘伝説
+    name:     Nekketsu Kakutou Densetsu
+    region:   JP
+    revision: 1.0
+    board:    HVC-TLROM-04
+    serial:   TJC-NA
+    sha256:   3c419e3ecf328c03364afbcf5bd15bf0029a525db9e8f74379ae1cce4062b3c3
+    configuration
+      rom name=program.rom size=0x20000
+      rom name=character.rom size=0x20000
+
+release
+  cartridge region=NTSC
+    board type=JALECO-JF-06
+    mirror mode=vertical
+    prg
+      rom name=program.rom size=0x4000
+    chr
+      rom name=character.rom size=0x4000
+  information
+    title:    忍者じゃじゃ丸くん
+    name:     Ninja Jajamaru-kun
+    region:   JP
+    revision: 1.0
+    board:    JF-06
+    serial:   JF-06
+    sha256:   bf546b0ce7fc60d89020ff7c0fadc7369925ba68a84d25b03de4190a91c46a95
+    configuration
+      rom name=program.rom size=0x4000
+      rom name=character.rom size=0x4000
+
+release
+  cartridge region=NTSC
+    board type=JALECO-JF-25
+    chip type=SS88006
+    prg
+      rom name=program.rom size=0x20000
+    chr
+      rom name=character.rom size=0x20000
+  information
+    title:    忍者じゃじゃ丸 銀河大作戦
+    name:     Ninja Jajamaru - Ginga Daisakusen
+    region:   JP
+    revision: 1.0
+    board:    JF-25
+    serial:   JF-32
+    sha256:   648cf7ac553517573cc9b3955ab50566a91974b2348154910bfa53ef15d55b56
+    configuration
+      rom name=program.rom size=0x20000
+      rom name=character.rom size=0x20000
+
+release
+  cartridge region=NTSC
+    board type=IREM-G101
+    chip type=G-101
+    prg
+      rom name=program.rom size=0x20000
+    chr
+      rom name=character.rom size=0x20000
+  information
+    title:    パーマン えんばんを とりかえせ!!
+    name:     Paaman - Enban o Torikaese!!
+    region:   JP
+    revision: 1.0
+    board:    FC-00-016
+    serial:   IF-20
+    sha256:   6d2887d978262401f315836411537a208272cba7721f598308d92983f1f5731a
+    configuration
+      rom name=program.rom size=0x20000
+      rom name=character.rom size=0x20000
+
+cartridge region=NTSC
+  board type=IREM-G101
+  chip type=G-101
+  prg
+    rom name=program.rom size=0x40000
+  chr
+    rom name=character.rom size=0x20000
+
+information
+  title:    パーマン2 秘密結社マドー団をたおせ!
+  name:     Paaman Part 2 - Himitsu Kessha Madoodan o Taose!
+  region:   JP
+  revision: 1.0
+  board:    FC-00-018
+  serial:   IF-25
+  sha256:   ece3f1fefbcc9c4a6da801d931a5bda85241975d96b5b4931bcd635bc3e0f1a5
+  configuration
+    rom name=program.rom size=0x40000
+    rom name=character.rom size=0x20000
+
+release
+  cartridge region=NTSC
+    board type=NAMCOT-3416
+    chip type=118
+    mirror mode=vertical
+    prg
+      rom name=program.rom size=0x20000
+    chr
+      rom name=character.rom size=0x10000
+  information
+    title:    カイの冒険: The Quest of Ki
+    name:     Quest of Ki, The
+    region:   JP
+    revision: 1.0
+    board:    3416
+    serial:   NAM-QK-3900
+    sha256:   67123fe28cf5fbadeafc77400a0812f0135ab36706ec7d1267f84931d044e71d
+    configuration
+      rom name=program.rom size=0x20000
+      rom name=character.rom size=0x10000
+
+release
+  cartridge region=NTSC
+    board type=HVC-UN1ROM
+    chip type=74HC32
+    mirror mode=horizontal
+    prg
+      rom name=program.rom size=0x20000
+    chr
+      ram size=0x2000
+  information
+    title:    戦場の狼
+    name:     Senjou no Ookami
+    region:   JP
+    revision: 1.0
+    board:    HVC-UN1ROM-01
+    serial:   CAP-SJ
+    sha256:   dbc22a40e8a79c5ccf1d6e5126c9b10bb3d9b3e708fe5316c298c3d03dbc7977
+    configuration
+      rom name=program.rom size=0x20000
+      ram name=character.ram size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=NAMCOT-3417
+    chip type=109
+    mirror mode=vertical
+    prg
+      rom name=program.rom size=0x8000
+    chr
+      rom name=character.rom size=0x8000
+  information
+    title:    スカイキッド
+    name:     SkyKid
+    region:   JP
+    revision: 1.0
+    board:    3417
+    serial:   NAM-NSK-3900-18
+    sha256:   4fbd928f06fbc4ea537cdae7f6a906053df7cd80c35b5cfeac9dfb9d3033efb8
+    configuration
+      rom name=program.rom size=0x8000
+      rom name=character.rom size=0x8000
+
+release
+  cartridge region=NTSC
+    board type=HVC-CNROM
+      security pass=0x1
+    mirror mode=vertical
+    prg
+      rom name=program.rom size=0x8000
+    chr
+      rom name=character.rom size=0x2000
+  information
+    title:    スパイVSスパイ
+    name:     Spy vs. Spy
+    region:   JP
+    revision: 1.0
+    board:    HVC-CNROM-256K-01
+    serial:   KSC-SP
+    sha256:   a9cf92ec1a080faa195d0b3dcb48fbb5ee3362f0f2f14e14e4257def48ac4346
+    configuration
+      rom name=program.rom size=0x8000
+      rom name=character.rom size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=HVC-NROM-256
+    mirror mode=vertical
+    prg
+      rom name=program.rom size=0x8000
+    chr
+      rom name=character.rom size=0x2000
+  information
+    title:    スーパーマリオブラザーズ
+    name:     Super Mario Bros.
+    region:   JP
+    revision: 1.0
+    board:    HVC-NROM-256K-02
+    serial:   HVC-SM
+    sha256:   fcb6a0ef3a20c19b356005fbb21dc8009563b1cb5a9aaebc8e9386b4a8c5912e
+    configuration
+      rom name=program.rom size=0x8000
+      rom name=character.rom size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=HVC-SKROM
+    chip type=MMC1A
+    prg
+      rom name=program.rom size=0x20000
+      ram name=save.ram size=0x2000
+    chr
+      rom name=character.rom size=0x20000
+  information
+    title:    闘将!! 拉麺男 炸裂超人一○二芸
+    name:     Tatakae!! Rahmen Man - Sakuretsu Choujin 102 Gei
+    region:   JP
+    revision: 1.0
+    board:    HVC-SKROM-02
+    serial:   SHI-RN
+    sha256:   a086ff08e7eae822285975d04f5d227f2434d5f1819969e233ff8670f7d57439
+    configuration
+      rom name=program.rom size=0x20000
+      ram name=save.ram size=0x2000
+      rom name=character.rom size=0x20000
+
+release
+  cartridge region=NTSC
+    board type=HVC-NROM-256
+    mirror mode=horizontal
+    prg
+      rom name=program.rom size=0x8000
+    chr
+      rom name=character.rom size=0x2000
+  information
+    title:    テグザー
+    name:     Thexder
+    region:   JP
+    revision: 1.0
+    board:    HVC-NROM-256K-02S
+    serial:   SQF-TX
+    sha256:   18d41a2dc65d8afce295eaf29c391539a69d7cfe6dd32503713ae13d4495a545
+    configuration
+      rom name=program.rom size=0x8000
+      rom name=character.rom size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=KONAMI-VRC-4
+    chip type=VRC4
+      pinout a0=2 a1=3
+    prg
+      rom name=program.rom size=0x20000
+    chr
+      rom name=character.rom size=0x20000
+  information
+    title:    タイニートゥーンアドベンチャー
+    name:     Tiny Toon Adventures
+    region:   JP
+    revision: 1.0
+    board:    352396
+    serial:   KON-RC860
+    sha256:   4b80a1db42ecde039f01c52a74146887f9dfc2ad54fe3706bcdf625ec3e2de97
+    configuration
+      rom name=program.rom size=0x20000
+      rom name=character.rom size=0x20000
+
+release
+  cartridge region=NTSC
+    board type=KONAMI-VRC-7
+    chip type=VRC7
+    prg
+      rom name=program.rom size=0x20000
+    chr
+      rom name=character.rom size=0x20000
+  information
+    title:    タイニートゥーンアドベンチャー2 モンタナランドへようこそ
+    name:     Tiny Toon Adventures 2 - Montana Land e Youkoso
+    region:   JP
+    revision: 1.0
+    board:    353429
+    serial:   KON-RV051
+    sha256:   dabde0dbf12d01237350cf6ad6463ce79651ac1e80d57b7b3b55c1819e72fd8a
+    configuration
+      rom name=program.rom size=0x20000
+      rom name=character.rom size=0x20000
+
+release
+  cartridge region=NTSC
+    board type=FDS
+    prg
+      rom name=program.rom size=0x2000
+      ram size=0x8000
+    chr
+      ram size=0x2000
+  information
+    title:    Twin Famicom Disk System
+    name:     Twin Famicom Disk System
+    region:   JP
+    revision: 1.0
+    board:    Famicom Disk System
+    serial:   N/A
+    sha256:   a0a9d57cbace21bf9c85c2b85e86656317f0768d7772acc90c7411ab1dbff2bf
+    configuration
+      rom name=program.rom size=0x2000
+      ram name=work.ram size=0x8000
+      ram name=character.ram size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=KONAMI-VRC-2
+    chip type=VRC2
+      pinout a0=1 a1=0 chr-shift=1
+    prg
+      rom name=program.rom size=0x20000
+    chr
+      rom name=character.rom size=0x20000
+  information
+    title:    ツインビー3 ポコポコ大魔王
+    name:     TwinBee 3 - Poko Poko Dai Maou
+    region:   JP
+    revision: 1.0
+    board:    351618
+    serial:   KON-RC841
+    sha256:   092db8cfadf0a96c67dd0734c966c47dfb80ffb830485d8ee702284ae8eac4aa
+    configuration
+      rom name=program.rom size=0x20000
+      rom name=character.rom size=0x20000
+
+release
+  cartridge region=NTSC
+    board type=JALECO-JF-16
+    prg
+      rom name=program.rom size=0x20000
+    chr
+      rom name=character.rom size=0x20000
+  information
+    title:    宇宙船コスモキャリア
+    name:     Uchuusen - Cosmo Carrier
+    region:   JP
+    revision: 1.0
+    board:    JF-16
+    serial:   JF-16
+    sha256:   407e54848ad9991399f0383118f138d3a0532bb03bb488ed856deb7f2eb4efbf
+    configuration
+      rom name=program.rom size=0x20000
+      rom name=character.rom size=0x20000
+
+release
+  cartridge region=NTSC
+    board type=HVC-NROM-128
+    mirror mode=vertical
+    prg
+      rom name=program.rom size=0x4000
+    chr
+      rom name=character.rom size=0x2000
+  information
+    title:    Wild Gunman
+    name:     Wild Gunman
+    region:   JP
+    revision: 1.1
+    board:    2I
+    serial:   HVC-WG
+    sha256:   adff304553b64384f86f6c2b63571f43972b9d087f92359a1b9b93b54d523542
+    configuration
+      rom name=program.rom size=0x4000
+      rom name=character.rom size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=NES-SKROM
+    chip type=MMC1B2
+    prg
+      rom name=program.rom size=0x20000
+      ram name=save.ram size=0x2000
+    chr
+      rom name=character.rom size=0x20000
+  information
+    title:    Advanced Dungeons & Dragons: Heroes of the Lance
+    name:     Advanced Dungeons & Dragons - Heroes of the Lance
+    region:   NA
+    revision: 1.0
+    board:    NES-SKROM-04
+    serial:   NES-LQ-USA
+    sha256:   df2609c80e818bb95983b30a3ac1435ea2332ac83e29fde469f397e1d5a2db93
+    configuration
+      rom name=program.rom size=0x20000
+      ram name=save.ram size=0x2000
+      rom name=character.rom size=0x20000
+
+release
+  cartridge region=NTSC
+    board type=NES-SGROM
+    chip type=MMC1A
+    prg
+      rom name=program.rom size=0x40000
+    chr
+      ram size=0x2000
+  information
+    title:    Bionic Commando
+    name:     Bionic Commando
+    region:   NA
+    revision: 1.0
+    board:    NES-SGROM-03
+    serial:   NES-CM-USA
+    sha256:   aeb61fd5cf5a5ed73344c46a43f8a8d539f601ff57e8f56c49bc1caea4ab3d9e
+    configuration
+      rom name=program.rom size=0x40000
+      ram name=character.ram size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=NES-SLROM
+    chip type=MMC1B2
+    prg
+      rom name=program.rom size=0x20000
+    chr
+      rom name=character.rom size=0x20000
+  information
+    title:    Clash at Demonhead
+    name:     Clash at Demonhead
+    region:   NA
+    revision: 1.0
+    board:    NES-SLROM-05
+    serial:   NES-B6-USA
+    sha256:   cf226f0d9486103bbaa19ee124b673d47aa2b3766334b6b7587d704c03e6649e
+    configuration
+      rom name=program.rom size=0x20000
+      rom name=character.rom size=0x20000
+
+release
+  cartridge region=NTSC
+    board type=NES-TKROM
+    chip type=MMC3B
+    prg
+      rom name=program.rom size=0x40000
+      ram name=save.ram size=0x2000
+    chr
+      rom name=character.rom size=0x20000
+  information
+    title:    Crystalis
+    name:     Crystalis
+    region:   NA
+    revision: 1.0
+    board:    NES-TKROM-01
+    serial:   NES-G0-USA
+    sha256:   5ad644d368f70b61700b74a1d04778888efcbbf98d5435d79f9fcefd23ac39c2
+    configuration
+      rom name=program.rom size=0x40000
+      ram name=save.ram size=0x2000
+      rom name=character.rom size=0x20000
+
+release
+  cartridge region=NTSC
+    board type=NES-CNROM
+    mirror mode=vertical
+    prg
+      rom name=program.rom size=0x8000
+    chr
+      rom name=character.rom size=0x8000
+  information
+    title:    Cybernoid: The Fighting Machine
+    name:     Cybernoid - The Fighting Machine
+    region:   NA
+    revision: 1.0
+    board:    NES-CNROM-06
+    serial:   NES-YN-USA
+    sha256:   ad1e14d08657d99c8b70f779931f62524b4beb529090b82b368925d8b642e40c
+    configuration
+      rom name=program.rom size=0x8000
+      rom name=character.rom size=0x8000
+
+release
+  cartridge region=NTSC
+    board type=NES-BNROM
+    mirror mode=horizontal
+    prg
+      rom name=program.rom size=0x20000
+    chr
+      ram size=0x2000
+  information
+    title:    Deadly Towers
+    name:     Deadly Towers
+    region:   NA
+    revision: 1.0
+    board:    NES-BN-ROM-01
+    serial:   NES-DE-USA
+    sha256:   0115356b0791cc8ddcb7d3163d6ef7aa664f3ff4e68dba561ffffb79eefcbca9
+    configuration
+      rom name=program.rom size=0x20000
+      ram name=character.ram size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=NES-SNROM
+    chip type=MMC1B2
+    prg
+      rom name=program.rom size=0x40000
+      ram name=save.ram size=0x2000
+    chr
+      ram size=0x2000
+  information
+    title:    Destiny of an Emperor
+    name:     Destiny of an Emperor
+    region:   NA
+    revision: 1.0
+    board:    NES-SNROM-05
+    serial:   NES-YZ-USA
+    sha256:   6d082c801942ce6787b471428ab4c8a6acb3e21f3f38fa197f2aeb698d9a2d7e
+    configuration
+      rom name=program.rom size=0x40000
+      ram name=save.ram size=0x2000
+      ram name=character.ram size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=NES-NROM-128
+    mirror mode=horizontal
+    prg
+      rom name=program.rom size=0x4000
+    chr
+      rom name=character.rom size=0x2000
+  information
+    title:    Donkey Kong
+    name:     Donkey Kong
+    region:   NA
+    revision: 1.0
+    board:    NES-NROM-128-01
+    serial:   NES-DK-USA
+    sha256:   aa408f5a6b97c0d738e7e8b489a5617ad4a9ecdee2b05c4ee504210ce31b2825
+    configuration
+      rom name=program.rom size=0x4000
+      rom name=character.rom size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=NES-NROM-128
+    mirror mode=vertical
+    prg
+      rom name=program.rom size=0x4000
+    chr
+      rom name=character.rom size=0x2000
+  information
+    title:    Donkey Kong Jr.
+    name:     Donkey Kong Jr.
+    region:   NA
+    revision: 1.0
+    board:    NES-NROM-128-03
+    serial:   NES-JR-USA
+    sha256:   950ebe68e7f74219b9e5e104200b03165d59c24264f02e32c12be967fd311ac2
+    configuration
+      rom name=program.rom size=0x4000
+      rom name=character.rom size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=NES-SAROM
+    chip type=MMC1B2
+    prg
+      rom name=program.rom size=0x10000
+      ram name=save.ram size=0x2000
+    chr
+      rom name=character.rom size=0x4000
+  information
+    title:    Dragon Warrior
+    name:     Dragon Warrior
+    region:   NA
+    revision: 1.0
+    board:    NES-SAROM-01
+    serial:   NES-DQ-USA
+    sha256:   abc5bcb459316a7d245065149ea72b5a8317f62fa6ed578569e15b670d3c0022
+    configuration
+      rom name=program.rom size=0x10000
+      ram name=save.ram size=0x2000
+      rom name=character.rom size=0x4000
+
+release
+  cartridge region=NTSC
+    board type=NES-SAROM
+    chip type=MMC1B2
+    prg
+      rom name=program.rom size=0x10000
+      ram name=save.ram size=0x2000
+    chr
+      rom name=character.rom size=0x4000
+  information
+    title:    Dragon Warrior
+    name:     Dragon Warrior
+    region:   NA
+    revision: 1.1
+    board:    NES-SAROM-02
+    serial:   NES-DQ-USA
+    sha256:   d968a138b19d39dad24aceb3464c7b90e8d50416297273586d3faf1f094eb35c
+    configuration
+      rom name=program.rom size=0x10000
+      ram name=save.ram size=0x2000
+      rom name=character.rom size=0x4000
+
+release
+  cartridge region=NTSC
+    board type=NES-SNROM
+    chip type=MMC1B2
+    prg
+      rom name=program.rom size=0x40000
+      ram name=save.ram size=0x2000
+    chr
+      ram size=0x2000
+  information
+    title:    Dragon Warrior II
+    name:     Dragon Warrior II
+    region:   NA
+    revision: 1.0
+    board:    NES-SNROM-05
+    serial:   NES-D2-USA
+    sha256:   c15ab051ff066f018cf4b0159780c58026114bb47a6376ef81c1571a39a8fe9b
+    configuration
+      rom name=program.rom size=0x40000
+      ram name=save.ram size=0x2000
+      ram name=character.ram size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=NES-SUROM
+    chip type=MMC1B3
+    prg
+      rom name=program.rom size=0x80000
+      ram name=save.ram size=0x2000
+    chr
+      ram size=0x2000
+  information
+    title:    Dragon Warrior III
+    name:     Dragon Warrior III
+    region:   NA
+    revision: 1.0
+    board:    NES-SUROM-01
+    serial:   NES-D3-USA
+    sha256:   f91a8bfc25bd267f5ae77bafa7fc650f77f8e50067869e99682b32d5b410644e
+    configuration
+      rom name=program.rom size=0x80000
+      ram name=save.ram size=0x2000
+      ram name=character.ram size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=NES-SUROM
+    chip type=MMC1B3
+    prg
+      rom name=program.rom size=0x80000
+      ram name=save.ram size=0x2000
+    chr
+      ram size=0x2000
+  information
+    title:    Dragon Warrior IV
+    name:     Dragon Warrior IV
+    region:   NA
+    revision: 1.0
+    board:    NES-SUROM-02
+    serial:   NES-D4-USA
+    sha256:   e49cb745370065a40aff078ae52b5de1c0db137fedcbe93b78ab18d76479deed
+    configuration
+      rom name=program.rom size=0x80000
+      ram name=save.ram size=0x2000
+      ram name=character.ram size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=NES-NROM-128
+    mirror mode=vertical
+    prg
+      rom name=program.rom size=0x4000
+    chr
+      rom name=character.rom size=0x2000
+  information
+    title:    Duck Hunt
+    name:     Duck Hunt
+    region:   NA
+    revision: 1.0
+    board:    NES-NROM-128-03
+    serial:   NES-DH-USA
+    serial:   NES-DH-CAN
+    sha256:   7026334a7e8742b61b450f4b3b182922c6a69fc723d7cd19c83db365f15e45ba
+    configuration
+      rom name=program.rom size=0x4000
+      rom name=character.rom size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=NES-UNROM
+    chip type=74HC32
+    mirror mode=vertical
+    prg
+      rom name=program.rom size=0x20000
+    chr
+      ram size=0x2000
+  information
+    title:    Disney's DuckTales
+    name:     DuckTales
+    region:   NA
+    revision: 1.0
+    board:    NES-UNROM-09
+    serial:   NES-UK-USA
+    sha256:   8ba8baed01a9fbaf1e9ff29e0c9825db1963ac2aff211d6f1f3bcfd3839e2013
+    configuration
+      rom name=program.rom size=0x20000
+      ram name=character.ram size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=NES-UNROM
+    chip type=74HC32
+    mirror mode=vertical
+    prg
+      rom name=program.rom size=0x20000
+    chr
+      ram size=0x2000
+  information
+    title:    Disney's DuckTales 2
+    name:     DuckTales 2
+    region:   NA
+    revision: 1.0
+    board:    NES-UNROM-10
+    serial:   NES-DL-USA
+    sha256:   54c70628739c9cfab40b8d79555e9076adae34127ef369988ca91635b4a688bf
+    configuration
+      rom name=program.rom size=0x20000
+      ram name=character.ram size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=NES-NROM-128
+    mirror mode=vertical
+    prg
+      rom name=program.rom size=0x4000
+    chr
+      rom name=character.rom size=0x2000
+  information
+    title:    Excitebike
+    name:     Excitebike
+    region:   NA
+    revision: 1.0
+    board:    NES-NROM-128-04
+    serial:   NES-EB-USA
+    sha256:   e9f4c9d1b7c66c6af83f2db5d4f704cf5f4b3c86e26a49c05539237807d8875e
+    configuration
+      rom name=program.rom size=0x4000
+      rom name=character.rom size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=NES-SNROM
+    chip type=MMC1B2
+    prg
+      rom name=program.rom size=0x40000
+      ram name=save.ram size=0x2000
+    chr
+      ram size=0x2000
+  information
+    title:    Final Fantasy
+    name:     Final Fantasy
+    region:   NA
+    revision: 1.0
+    board:    NES-SNROM-05
+    serial:   NES-FF-USA
+    serial:   NES-FF-CAN
+    sha256:   fa456d852372173ea31b192459ba1a2026f779df67793327ba6e132476c1d034
+    configuration
+      rom name=program.rom size=0x40000
+      ram name=save.ram size=0x2000
+      ram name=character.ram size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=NES-DRROM
+    chip type=109
+    prg
+      rom name=program.rom size=0x20000
+    chr
+      rom name=character.rom size=0x10000
+      ram size=0x800
+  information
+    title:    Gauntlet
+    name:     Gauntlet
+    region:   NA
+    revision: 1.0
+    board:    NES-DRROM-01
+    serial:   NES-GL-USA
+    sha256:   fd2a8520314fb183e15fd62f48df97f92eb9c81140da4e6ab9ff0386e4797071
+    configuration
+      rom name=program.rom size=0x20000
+      rom name=character.rom size=0x10000
+      ram name=nametable.ram size=0x800
+
+release
+  cartridge region=NTSC
+    board type=NES-GNROM
+    mirror mode=vertical
+    prg
+      rom name=program.rom size=0x20000
+    chr
+      rom name=character.rom size=0x8000
+  information
+    title:    Gumshoe
+    name:     Gumshoe
+    region:   NA
+    revision: 1.0
+    board:    NES-GN-ROM-01
+    serial:   NES-GS-USA
+    sha256:   4628f32db9b826d19fe5dd8e2c45a9f70e1041f15b7b44b06dee2f01731566e8
+    configuration
+      rom name=program.rom size=0x20000
+      rom name=character.rom size=0x8000
+
+release
+  cartridge region=NTSC
+    board type=NES-TQROM
+    chip type=MMC3B
+    prg
+      rom name=program.rom size=0x20000
+    chr
+      rom name=character.rom size=0x10000
+      ram size=0x2000
+  information
+    title:    High Speed
+    name:     High Speed
+    region:   NA
+    revision: 1.0
+    board:    NES-TQROM-01
+    serial:   NES-8H-USA
+    sha256:   710e907230bbd82143286b40a56a298b25cf326697a9f07bfd8e043c1936a4b1
+    configuration
+      rom name=program.rom size=0x20000
+      rom name=character.rom size=0x10000
+      rom name=nametable.ram size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=NES-NROM-128
+    mirror mode=vertical
+    prg
+      rom name=program.rom size=0x4000
+    chr
+      rom name=character.rom size=0x2000
+  information
+    title:    Hogan's Alley
+    name:     Hogan's Alley
+    region:   NA
+    revision: 1.0
+    board:    NES-NROM-128-04
+    serial:   NES-HA-USA
+    sha256:   8e4a04076b6a728a7e65a09737776dcb9defed7922bf0437d9a89bbe8c724b55
+    configuration
+      rom name=program.rom size=0x4000
+      rom name=character.rom size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=ACCLAIM-MC-ACC
+    chip type=MC-ACC
+    prg
+      rom name=program.rom size=0x20000
+    chr
+      rom name=character.rom size=0x40000
+  information
+    title:    The Incredible Crash Dummies
+    name:     Incredible Crash Dummies, The
+    region:   NA
+    revision: 1.0
+    board:    55741
+    serial:   NES-CQ-USA
+    sha256:   c42fc592821b474b486ae32d1d63e8938f1735a6d45db026f7b78b2ec51427ac
+    configuration
+      rom name=program.rom size=0x20000
+      rom name=character.rom size=0x40000
+
+release
+  cartridge region=NTSC
+    board type=NES-TSROM
+    chip type=MMC3C
+    prg
+      rom name=program.rom size=0x40000
+      ram size=0x2000
+    chr
+      rom name=character.rom size=0x40000
+  information
+    title:    King's Quest V
+    name:     King's Quest V
+    region:   NA
+    revision: 1.0
+    board:    NES-TSROM-08
+    serial:   NES-8Q-USA
+    sha256:   997ddca52ac724481ad5daafbc4e61547a541d673214eac579a8de746b26978d
+    configuration
+      rom name=program.rom size=0x40000
+      ram name=work.ram size=0x2000
+      rom name=character.rom size=0x40000
+
+release
+  cartridge region=NTSC
+    board type=NES-TKROM
+    chip type=MMC3C
+    prg
+      rom name=program.rom size=0x80000
+      ram name=save.ram size=0x2000
+    chr
+      rom name=character.rom size=0x40000
+  information
+    title:    Kirby's Adventure
+    name:     Kirby's Adventure
+    region:   NA
+    revision: 1.0
+    board:    NES-TKROM-10
+    serial:   NES-KR-USA
+    sha256:   a6b81fec11c24a33fd763db5c28005e760a1614e70c1bb5ccde0bd4242431000
+    configuration
+      rom name=program.rom size=0x80000
+      ram name=save.ram size=0x2000
+      rom name=character.rom size=0x40000
+
+release
+  cartridge region=NTSC
+    board type=NES-TKROM
+    chip type=MMC3C
+    prg
+      rom name=program.rom size=0x80000
+      ram name=save.ram size=0x2000
+    chr
+      rom name=character.rom size=0x40000
+  information
+    title:    Kirby's Adventure
+    name:     Kirby's Adventure
+    region:   NA
+    revision: 1.1
+    board:    NES-TKROM-10
+    serial:   NES-KR-USA
+    sha256:   1250a80faf865aa5ee5585ad7639e5ef2b3fa541554effda5fad2cc5dc2acef5
+    configuration
+      rom name=program.rom size=0x80000
+      ram name=save.ram size=0x2000
+      rom name=character.rom size=0x40000
+
+release
+  cartridge region=NTSC
+    board type=NES-TKROM
+    chip type=MMC3C
+    prg
+      rom name=program.rom size=0x80000
+      ram name=save.ram size=0x2000
+    chr
+      rom name=character.rom size=0x40000
+  information
+    title:    Kirby's Adventure
+    name:     Kirby's Adventure
+    region:   QC
+    revision: 1.0
+    board:    NES-TKROM-10
+    serial:   NES-K5-CAN
+    sha256:   24fca0fe86464c807ab5d58a2d56155a3fa1994e9bd78d119e3f8f84c8aee785
+    configuration
+      rom name=program.rom size=0x80000
+      ram name=save.ram size=0x2000
+      rom name=character.rom size=0x40000
+
+release
+  cartridge region=NTSC
+    board type=NES-SNROM
+    chip type=MMC1A
+    prg
+      rom name=program.rom size=0x20000
+      ram name=save.ram size=0x2000
+    chr
+      ram size=0x2000
+  information
+    title:    The Legend of Zelda
+    name:     Legend of Zelda, The
+    region:   NA
+    revision: 1.0
+    board:    NES-SNROM-02
+    serial:   NES-ZL-USA
+    sha256:   085e5397a3487357c263dfa159fb0fe20a5f3ea8ef82d7af6a7e848d3b9364e8
+    configuration
+      rom name=program.rom size=0x20000
+      ram name=save.ram size=0x2000
+      ram name=character.ram size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=NES-SNROM
+    chip type=MMC1B3
+    prg
+      rom name=program.rom size=0x20000
+      ram name=save.ram size=0x2000
+    chr
+      ram size=0x2000
+  information
+    title:    The Legend of Zelda
+    name:     Legend of Zelda, The
+    region:   NA
+    revision: 1.1
+    board:    NES-SNROM-05
+    serial:   NES-ZL-USA
+    sha256:   ec0d4ebf6d2fcecd1d95fef7329954efe79676959bc281ea908b226459bc6dc2
+    configuration
+      rom name=program.rom size=0x20000
+      ram name=save.ram size=0x2000
+      ram name=character.ram size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=NES-TLROM
+    chip type=MMC3C
+    prg
+      rom name=program.rom size=0x40000
+    chr
+      rom name=character.rom size=0x20000
+  information
+    title:    Little Samson
+    name:     Little Samson
+    region:   NA
+    revision: 1.0
+    board:    NES-TLROM-03
+    serial:   NES-LT-USA
+    sha256:   a5165565263eaf8bdc45a8e6a615704f9bf271cd6d547d22c098c80cbaffd879
+    configuration
+      rom name=program.rom size=0x40000
+      rom name=character.rom size=0x20000
+
+release
+  cartridge region=NTSC
+    board type=NES-NROM-256
+    mirror mode=vertical
+    prg
+      rom name=program.rom size=0x8000
+    chr
+      rom name=character.rom size=0x2000
+  information
+    title:    Mach Rider
+    name:     Mach Rider
+    region:   NA
+    revision: 1.0
+    board:    NES-NROM-256-05
+    serial:   NES-MR-USA
+    sha256:   ef238662a27934d6dbe1692e822786a74a9a2c8bc58c38aa0fd5cfb3e2f1abce
+    configuration
+      rom name=program.rom size=0x8000
+      rom name=character.rom size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=NES-NROM-256
+    mirror mode=vertical
+    prg
+      rom name=program.rom size=0x8000
+    chr
+      rom name=character.rom size=0x2000
+  information
+    title:    Mach Rider
+    name:     Mach Rider
+    region:   NA
+    revision: 1.1
+    board:    NES-NROM-256-02
+    serial:   NES-MR-CAN
+    sha256:   944105c6dcc57314968d53a2e0dcdfc0e2b60678a53839ba25925416a7ac0e8c
+    configuration
+      rom name=program.rom size=0x8000
+      rom name=character.rom size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=NES-NROM-128
+    mirror mode=horizontal
+    prg
+      rom name=program.rom size=0x4000
+    chr
+      rom name=character.rom size=0x2000
+  information
+    title:    Mario Bros.
+    name:     Mario Bros.
+    region:   NA
+    revision: 1.0
+    board:    NES-NROM-128-06
+    serial:   NES-MA-USA
+    serial:   NES-MA-CAN
+    sha256:   0cc334007d3eae698cdcd034d12ec9bab2b5266e85bc703cf24ccb4e2d63b654
+    configuration
+      rom name=program.rom size=0x4000
+      rom name=character.rom size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=NES-SGROM
+    chip type=MMC1B2
+    prg
+      rom name=program.rom size=0x40000
+    chr
+      ram size=0x2000
+  information
+    title:    Mega Man 2
+    name:     Mega Man 2
+    region:   NA
+    revision: 1.0
+    board:    NES-SGROM-04
+    serial:   NES-XR-USA
+    sha256:   1e588d435e75d80c5c0b578b4fa8d196f2cf4346c11c9a7b7e435d768828ad01
+    configuration
+      rom name=program.rom size=0x40000
+      ram name=character.ram size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=NES-EVENT
+    chip type=MMC1B2
+    prg
+      rom name=program.rom size=0x40000
+      ram size=0x2000
+    chr
+      ram size=0x2000
+  information
+    title:    Nintendo World Championships 1990
+    name:     Nintendo World Championships 1990
+    region:   NA
+    revision: 1.0
+    board:    NES-EVENT-02
+    serial:   NES-90-USA
+    sha256:   cf4670ae9dd91bd178c80ab7391c8a059f9eecb86d744bd51b9258e21825fd3c
+    configuration
+      rom name=program.rom size=0x40000
+      ram name=work.ram size=0x2000
+      ram name=character.ram size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=NES-TQROM
+    chip type=MMC3A
+    prg
+      rom name=program.rom size=0x20000
+    chr
+      rom name=character.rom size=0x10000
+      ram size=0x2000
+  information
+    title:    Pin-Bot
+    name:     Pin-Bot
+    region:   NA
+    revision: 1.0
+    board:    NES-TQROM-01
+    serial:   NES-IO-USA
+    sha256:   f4ddb0f1a02f823ebed30b55547344de3c8fb9d87254ff993584373ecadd9141
+    configuration
+      rom name=program.rom size=0x20000
+      rom name=character.rom size=0x10000
+      rom name=nametable.ram size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=NES-CNROM
+    mirror mode=horizontal
+    prg
+      rom name=program.rom size=0x8000
+    chr
+      rom name=character.rom size=0x8000
+  information
+    title:    Puzznic
+    name:     Puzznic
+    region:   NA
+    revision: 1.0
+    board:    NES-CNROM-07
+    serial:   NES-ZP-USA
+    sha256:   0cf2fc17a59a0932ce43e6b2e9ea4e2570f03139784b5c9df429a499e734b92e
+    configuration
+      rom name=program.rom size=0x8000
+      rom name=character.rom size=0x8000
+
+release
+  cartridge region=NTSC
+    board type=NES-HKROM
+    chip type=MMC6B
+    prg
+      rom name=program.rom size=0x40000
+      ram name=save.ram size=0x400
+    chr
+      rom name=character.rom size=0x40000
+  information
+    title:    StarTropics
+    name:     StarTropics
+    region:   NA
+    revision: 1.0
+    board:    NES-HKROM-01
+    serial:   NES-OC-USA
+    sha256:   69de2c7552fa81ca5921da0e457abf1be35f18ffbad159788a76141be59c9f6b
+    configuration
+      rom name=program.rom size=0x40000
+      ram name=save.ram size=0x400
+      rom name=character.rom size=0x40000
+
+release
+  cartridge region=NTSC
+    board type=NES-NROM-256
+    mirror mode=vertical
+    prg
+      rom name=program.rom size=0x8000
+    chr
+      rom name=character.rom size=0x2000
+  information
+    title:    Super Mario Bros.
+    name:     Super Mario Bros.
+    region:   NA
+    revision: 1.0
+    board:    NES-NROM-256-04
+    serial:   NES-SM-USA
+    sha256:   fcb6a0ef3a20c19b356005fbb21dc8009563b1cb5a9aaebc8e9386b4a8c5912e
+    configuration
+      rom name=program.rom size=0x8000
+      rom name=character.rom size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=NES-MHROM
+    mirror mode=vertical
+    prg
+      rom name=program.rom size=0x10000
+    chr
+      rom name=character.rom size=0x4000
+  information
+    title:    Super Mario Bros. / Duck Hunt
+    name:     Super Mario Bros. + Duck Hunt
+    region:   NA
+    revision: 1.0
+    board:    NES-MHROM-04
+    serial:   NES-MH-USA
+    sha256:   5dde385041aa7364c78205f2ba49615f416c701b6025e38aa1d7b9c4f99a62db
+    configuration
+      rom name=program.rom size=0x10000
+      rom name=character.rom size=0x4000
+
+release
+  cartridge region=NTSC
+    board type=NES-TSROM
+    chip type=MMC3A
+    prg
+      rom name=program.rom size=0x20000
+      ram size=0x2000
+    chr
+      rom name=character.rom size=0x20000
+  information
+    title:    Super Mario Bros. 2
+    name:     Super Mario Bros. 2
+    region:   NA
+    revision: 1.0
+    board:    NES-TSROM-01
+    serial:   NES-MW-USA
+    sha256:   cba920f9394733c82253685d7783f26a3033ba58a94623e9abf7892329b969b9
+    configuration
+      rom name=program.rom size=0x20000
+      ram name=work.ram size=0x2000
+      rom name=character.rom size=0x20000
+
+release
+  cartridge region=NTSC
+    board type=NES-TSROM
+    chip type=MMC3B
+    prg
+      rom name=program.rom size=0x20000
+      ram size=0x2000
+    chr
+      rom name=character.rom size=0x20000
+  information
+    title:    Super Mario Bros. 2
+    name:     Super Mario Bros. 2
+    region:   NA
+    revision: 1.1
+    board:    NES-TSROM-08
+    serial:   NES-MW-USA
+    serial:   NES-MW-CAN
+    sha256:   728d0ca6751b0c039fc3e34f2e7f27a870afcab30f5e270244ac40979c5f69ca
+    configuration
+      rom name=program.rom size=0x20000
+      ram name=work.ram size=0x2000
+      rom name=character.rom size=0x20000
+
+release
+  cartridge region=NTSC
+    board type=NES-TSROM
+    chip type=MMC3B
+    prg
+      rom name=program.rom size=0x40000
+      ram size=0x2000
+    chr
+      rom name=character.rom size=0x20000
+  information
+    title:    Super Mario Bros. 3
+    name:     Super Mario Bros. 3
+    region:   NA
+    revision: 1.0
+    board:    NES-TSROM-06
+    serial:   NES-UM-USA
+    sha256:   d77d17d34af24871d7ce1160ccd3330555835c8e940b7100e095ac38973d927a
+    configuration
+      rom name=program.rom size=0x40000
+      ram name=work.ram size=0x2000
+      rom name=character.rom size=0x20000
+
+release
+  cartridge region=NTSC
+    board type=NES-TSROM
+    chip type=MMC3B
+    prg
+      rom name=program.rom size=0x40000
+      ram size=0x2000
+    chr
+      rom name=character.rom size=0x20000
+  information
+    title:    Super Mario Bros. 3
+    name:     Super Mario Bros. 3
+    region:   NA
+    revision: 1.1
+    board:    NES-TSROM-07
+    serial:   NES-UM-USA
+    serial:   NES-UM-CAN
+    sha256:   959fdd32c71735d6fb2bd16a646d39f4ee65623273dd035e6a968e991bd13ef8
+    configuration
+      rom name=program.rom size=0x40000
+      ram name=work.ram size=0x2000
+      rom name=character.rom size=0x20000
+
+release
+  cartridge region=NTSC
+    board type=NES-QJ
+    chip type=MMC3
+    prg
+      rom name=program.rom size=0x40000
+    chr
+      rom name=character.rom size=0x40000
+  information
+    title:    Super Spike V'Ball / Nintendo World Cup
+    name:     Super Spike V'Ball + Nintendo World Cup
+    region:   NA
+    revision: 1.0
+    board:    NES-QJ
+    serial:   NES-QJ-USA
+    sha256:   8951dccb6640b48c857f321ef01c06110c5b8870f5d901dcc538ab1b8db7e2a1
+    configuration
+      rom name=program.rom size=0x40000
+      rom name=character.rom size=0x40000
+
+release
+  cartridge region=NTSC
+    board type=NES-SEROM
+    chip type=MMC1B2
+    prg
+      rom name=program.rom size=0x8000
+    chr
+      rom name=character.rom size=0x4000
+  information
+    title:    Tetris
+    name:     Tetris
+    region:   NA
+    revision: 1.0
+    board:    NES-SEROM-04
+    serial:   NES-EI-USA
+    serial:   NES-EI-CAN
+    sha256:   2ae5fb18a1bf841077e3872ba05060f030ea0bfc573994b2f8fe2fb570dc7853
+    configuration
+      rom name=program.rom size=0x8000
+      rom name=character.rom size=0x4000
+
+release
+  cartridge region=NTSC
+    board type=NES-TLROM
+    chip type=MMC3B
+    prg
+      rom name=program.rom size=0x20000
+    chr
+      rom name=character.rom size=0x20000
+  information
+    title:    Totally Rad
+    name:     Totally Rad
+    region:   NA
+    revision: 1.0
+    board:    NES-TLROM-03
+    serial:   NES-6T-USA
+    sha256:   0bd29c5b583570e195e05a4272e69b74257db1f4ff928d59c8eb1022bad871ce
+    configuration
+      rom name=program.rom size=0x20000
+      rom name=character.rom size=0x20000
+
+release
+  cartridge region=NTSC
+    board type=NES-TKROM
+    chip type=MMC3C
+    prg
+      rom name=program.rom size=0x40000
+      ram name=save.ram size=0x2000
+    chr
+      rom name=character.rom size=0x40000
+  information
+    title:    Wario's Woods
+    name:     Wario's Woods
+    region:   NA
+    revision: 1.0
+    board:    NES-TKROM-10
+    serial:   NES-WB-USA
+    sha256:   c12771e8155b030eff0081bfabd98e57a162d6592899f29dd16f141f0e6e08a3
+    configuration
+      rom name=program.rom size=0x40000
+      ram name=save.ram size=0x2000
+      rom name=character.rom size=0x40000
+
+release
+  cartridge region=NTSC
+    board type=NES-NROM-128
+    mirror mode=vertical
+    prg
+      rom name=program.rom size=0x4000
+    chr
+      rom name=character.rom size=0x2000
+  information
+    title:    Wild Gunman
+    name:     Wild Gunman
+    region:   NA
+    revision: 1.0
+    board:    NES-NROM-128-01
+    serial:   NES-WG-USA
+    sha256:   62aec65696ecf24a487b7cdd19bad5cbd19f4229a89a7888634d468c67da378a
+    configuration
+      rom name=program.rom size=0x4000
+      rom name=character.rom size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=NES-NROM-128
+    mirror mode=vertical
+    prg
+      rom name=program.rom size=0x4000
+    chr
+      rom name=character.rom size=0x2000
+  information
+    title:    Wild Gunman
+    name:     Wild Gunman
+    region:   NA
+    revision: 1.1
+    board:    NES-NROM-128-04
+    serial:   NES-WG-USA
+    sha256:   adff304553b64384f86f6c2b63571f43972b9d087f92359a1b9b93b54d523542
+    configuration
+      rom name=program.rom size=0x4000
+      rom name=character.rom size=0x2000
+
+release
+  cartridge region=NTSC
+    board type=NES-CNROM
+    mirror mode=horizontal
+    prg
+      rom name=program.rom size=0x8000
+    chr
+      rom name=character.rom size=0x8000
+  information
+    title:    World Class Track Meet
+    name:     World Class Track Meet
+    region:   NA
+    revision: 1.0
+    board:    NES-CN-ROM-256-05
+    serial:   NES-WT-USA
+    sha256:   6c74bcb9ac50428266cfc4d13892b6e93c6936ba569bf3f0f2068e45a9b675fc
+    configuration
+      rom name=program.rom size=0x8000
+      rom name=character.rom size=0x8000
+
+release
+  cartridge region=NTSC
+    board type=NES-CNROM
+    mirror mode=horizontal
+    prg
+      rom name=program.rom size=0x8000
+    chr
+      rom name=character.rom size=0x8000
+  information
+    title:    World Class Track Meet
+    name:     World Class Track Meet
+    region:   NA
+    revision: 1.1
+    board:    NES-CNROM-07
+    serial:   NES-WT-USA
+    sha256:   ac766a8d99bfd8e95c02b9a9c68279c72ba5b3307b78edc67b52781ed185fa89
+    configuration
+      rom name=program.rom size=0x8000
+      rom name=character.rom size=0x8000
+
+release
+  cartridge region=NTSC
+    board type=NES-HKROM
+    chip type=MMC6B
+    prg
+      rom name=program.rom size=0x40000
+      ram name=save.ram size=0x400
+    chr
+      rom name=character.rom size=0x40000
+  information
+    title:    Zoda's Revenge: StarTropics 2
+    name:     Zoda's Revenge - StarTropics 2
+    region:   NA
+    revision: 1.0
+    board:    NES-HKROM-02
+    serial:   NES-6C-USA
+    sha256:   d0850075065ecbd125a33accc952de5d012527be45aa14a1b8223a9adf1643ae
+    configuration
+      rom name=program.rom size=0x40000
+      ram name=save.ram size=0x400
+      rom name=character.rom size=0x40000
+
+release
+  cartridge region=PAL
+    board type=NES-NROM-128
+    mirror mode=vertical
+    prg
+      rom name=program.rom size=0x4000
+    chr
+      rom name=character.rom size=0x2000
+  information
+    title:    Hogan's Alley
+    name:     Hogan's Alley
+    region:   EU
+    revision: 1.0
+    board:    NES-NROM-128-03
+    serial:   NES-HA-EEC
+    sha256:   8e4a04076b6a728a7e65a09737776dcb9defed7922bf0437d9a89bbe8c724b55
+    configuration
+      rom name=program.rom size=0x4000
+      rom name=character.rom size=0x2000
+
+release
+  cartridge region=PAL
+    board type=NES-TSROM
+    chip type=MMC3C
+    prg
+      rom name=program.rom size=0x20000
+      ram size=0x2000
+    chr
+      rom name=character.rom size=0x20000
+  information
+    title:    Noah's Ark
+    name:     Noah's Ark
+    region:   EU
+    revision: 1.0
+    board:    NES-TSROM-08
+    serial:   NES-NH-NOE
+    sha256:   6157c99fe7a214025c65fd3649e4afe9cd2d38c333e65af028b935e49fbeb500
+    configuration
+      rom name=program.rom size=0x20000
+      ram name=work.ram size=0x2000
+      rom name=character.rom size=0x20000
+
+release
+  cartridge region=PAL
+    board type=PAL-ZZ
+    chip type=MMC3
+    prg
+      rom name=program.rom size=0x40000
+    chr
+      rom name=character.rom size=0x40000
+  information
+    title:    Super Mario Bros. / Tetris / Nintendo World Cup
+    name:     Super Mario Bros. + Tetris + Nintendo World Cup
+    region:   EU
+    revision: 1.0
+    board:    ZZ
+    serial:   NES-ZZ-FRG
+    serial:   NES-ZZ-SCN
+    sha256:   4c00009eb345474229372fc34ebe2abb4996eef7486ce8977e69edfc88816935
+    configuration
+      rom name=program.rom size=0x40000
+      rom name=character.rom size=0x40000
+
+release
+  cartridge region=PAL
+    board type=PAL-ZZ
+    chip type=MMC3
+    prg
+      rom name=program.rom size=0x40000
+    chr
+      rom name=character.rom size=0x40000
+  information
+    title:    Super Mario Bros. / Tetris / Nintendo World Cup
+    name:     Super Mario Bros. + Tetris + Nintendo World Cup
+    region:   EU
+    revision: 1.1
+    board:    ZZ
+    serial:   NES-ZZ-FRG
+    sha256:   18fc0f452d796e522d776c1a848ca7ca8b1c25b44d553b6fd15becd2ea65076e
+    configuration
+      rom name=program.rom size=0x40000
+      rom name=character.rom size=0x40000
+
+release
+  cartridge region=PAL
+    board type=NES-TKROM
+    chip type=MMC3C
+    prg
+      rom name=program.rom size=0x40000
+      ram name=save.ram size=0x2000
+    chr
+      rom name=character.rom size=0x40000
+  information
+    title:    Wario's Woods
+    name:     Wario's Woods
+    region:   EU
+    revision: 1.0
+    board:    NES-TKROM-10
+    serial:   NES-WB-NOE
+    sha256:   9fe815d8fd175ef9ef03fb010638f2b6b7aa9d11d5a40eda2476450918543e6f
+    configuration
+      rom name=program.rom size=0x40000
+      ram name=save.ram size=0x2000
+      rom name=character.rom size=0x40000
+
+)";
diff -Nru higan/ananke/database/playchoice-10.hpp higan/ananke/database/playchoice-10.hpp
--- higan/ananke/database/playchoice-10.hpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/ananke/database/playchoice-10.hpp	2015-09-16 14:33:30.580088238 +0900
@@ -0,0 +1,53 @@
+string Famicom = R"(
+
+database revision=2012-10-22
+
+release
+  cartridge region=NTSC
+    board type=NES-NROM-256
+    mirror mode=vertical
+    prg
+      rom name=program.rom size=0x8000
+    chr
+      rom name=character.rom size=0x2000
+    pc10
+      rom name=instructions.rom size=0x2000
+      rom name=key.rom size=0x9
+  information
+    title:    Super Mario Bros.
+    name:     Super Mario Bros.
+    region:   NA
+    revision: 1.0
+    sha256:   613da8bfaaa0be4b8308292acc5973d409f54ed143e14f082e1ef95442520ac2
+    configuration
+      rom name=program.rom size=0x8000
+      rom name=character.rom size=0x2000
+      rom name=instructions.rom size=0x2000
+      rom name=key.rom size=0x9
+
+release
+  cartridge region=NTSC
+    board type=NES-TSROM
+    chip type=MMC3B
+    prg
+      rom name=program.rom size=0x40000
+      ram size=0x2000
+    chr
+      rom name=character.rom size=0x20000
+    pc10 mode=single
+      rom name=instructions.rom size=0x2000
+      rom name=key.rom size=0x9
+  information
+    title:    Super Mario Bros. 3
+    name:     Super Mario Bros. 3
+    region:   NA
+    revision: 1.0
+    sha256:   01d456bcd2389a33cb536a86a9fcd524db52b6dbb30628e6d78297cdec4e3e29
+    configuration
+      rom name=program.rom size=0x40000
+      ram name=work.ram size=0x2000
+      rom name=character.rom size=0x20000
+      rom name=instructions.rom size=0x2000
+      rom name=key.rom size=0x9
+
+)";
diff -Nru higan/ananke/database/sufami-turbo.hpp higan/ananke/database/sufami-turbo.hpp
--- higan/ananke/database/sufami-turbo.hpp	2015-09-16 02:20:06.353574578 +0900
+++ higan/ananke/database/sufami-turbo.hpp	2015-09-16 14:33:30.580088238 +0900
@@ -146,7 +146,7 @@
 release
   cartridge linkable
     rom name=program.rom size=0x80000
-    ram name=save.ram size=0x800
+    ram name=save.ram size=0x2000
   information
     title:    SDガンダムジェネレーション コロニー格闘記
     name:     SD Gundam Generation - Colony Kakutouki
@@ -156,7 +156,7 @@
     sha256:   e639b5d5d722432b6809ccc6801dc584e1a3016379f34b335ed2dfa73b1ebf69
     configuration
       rom name=program.rom size=0x80000
-      ram name=save.ram size=0x800
+      ram name=save.ram size=0x2000
       linkable
 
 )";
diff -Nru higan/ananke/database/super-famicom.hpp higan/ananke/database/super-famicom.hpp
--- higan/ananke/database/super-famicom.hpp	2015-09-16 02:20:06.355574578 +0900
+++ higan/ananke/database/super-famicom.hpp	2015-09-16 14:33:30.604088241 +0900
@@ -8,7 +8,7 @@
     bsx
       rom name=program.rom size=0x100000
       ram name=save.ram size=0x8000
-      ram name=download.ram size=0x40000
+      ram name=download.ram size=0x80000
       map id=io address=00-3f,80-bf:5000-5fff
       map id=rom address=00-3f,80-bf:8000-ffff
       map id=rom address=40-5f,c0-ff:0000-ffff
@@ -26,7 +26,7 @@
     configuration
       rom name=program.rom size=0x100000
       ram name=save.ram size=0x8000
-      ram name=download.ram size=0x40000
+      ram name=download.ram size=0x80000
 
 release
   cartridge region=NTSC
diff -Nru higan/ananke/famicom.cpp higan/ananke/famicom.cpp
--- higan/ananke/famicom.cpp	2015-09-16 02:20:06.355574578 +0900
+++ higan/ananke/famicom.cpp	2015-09-16 14:33:30.611088241 +0900
@@ -1,11 +1,42 @@
 void Ananke::copyFamicomSaves(const string &pathname) {
   if(!file::exists({pathname, "save.ram"})) {
     if(file::exists({information.path, nall::basename(information.name), ".sav"})) {
-      file::copy({information.path, nall::basename(information.name), ".srm"}, {pathname, "save.ram"});
+      file::copy({information.path, nall::basename(information.name), ".sav"}, {pathname, "save.ram"});
     }
   }
 }
 
+string Ananke::createFamicomDatabase(vector<uint8_t> &buffer, Markup::Node &document, const string &manifest) {
+  string pathname = {
+    libraryPath, "Famicom/",
+    document["release/information/name"].text(),
+    " (", document["release/information/region"].text(), ")",
+    " (", document["release/information/revision"].text(), ")",
+    ".fc/"
+  };
+  directory::create(pathname);
+
+  //strip "release" root node from database entry (since a single game manifest isn't part of a database)
+  string markup = manifest;
+  markup.replace("\n  ", "\n");
+  markup.replace("information", "\ninformation");
+  markup.ltrim<1>("release\n");
+
+  file::write({pathname, "manifest.bml"}, markup);
+
+  unsigned offset = 0;
+  for(auto &node : document["release/information/configuration"]) {
+    if(node.name != "rom") continue;
+    string name = node["name"].text();
+    unsigned size = node["size"].decimal();
+    file::write({pathname, name}, buffer.data() + offset, size);
+    offset += size;
+  }
+
+  copyFamicomSaves(pathname);
+  return pathname;
+}
+
 string Ananke::createFamicomHeuristic(vector<uint8_t> &buffer) {
   string pathname = {
     libraryPath, "Famicom/",
@@ -16,7 +47,7 @@
 
   FamicomCartridge info(buffer.data(), buffer.size());
   string markup = {"unverified\n\n", info.markup};
-  markup.append("\ninformation\n  title: ", nall::basename(information.name), "\n");
+  markup.append("\ninformation\n  title: ", nall::basename(information.name));
   if(!information.manifest.empty()) markup = information.manifest;  //override with embedded beat manifest, if one exists
 
   file::write({pathname, "manifest.bml"}, markup);
@@ -28,6 +59,33 @@
 }
 
 string Ananke::openFamicom(vector<uint8_t> &buffer) {
+  bool ines = true;
+  ines = ines && buffer.data()[0] == 'N';
+  ines = ines && buffer.data()[1] == 'E';
+  ines = ines && buffer.data()[2] == 'S';
+  ines = ines && buffer.data()[3] == 0x1A;
+  if(ines && buffer.data()[4] == 0x01) {
+    string sha256_1 = nall::sha256(buffer.data() + 0x0010, 0x2000);
+    string sha256_2 = nall::sha256(buffer.data() + 0x2010, 0x2000);
+    if(sha256_1 == sha256_2) {
+      buffer.remove(16,0x2000);
+    }
+  }
+  string sha256 = nall::sha256(buffer.data() + (ines ? 16 : 0), buffer.size() - (ines ? 16 : 0));
+
+  string databaseText = string::read({configpath(), "ananke/database/Famicom.bml"}).strip();
+  if(databaseText.empty()) databaseText = string{Database::Famicom}.strip();
+  lstring databaseItem = databaseText.split("\n\n");
+
+  for(auto &item : databaseItem) {
+    auto document = BML::unserialize(item);
+
+    if(document["release/information/sha256"].text() == sha256) {
+      if(ines) buffer.remove(0, 16);
+      return createFamicomDatabase(buffer, document, item);
+    }
+  }
+
   return createFamicomHeuristic(buffer);
 }
 
@@ -35,5 +93,32 @@
 //game folders discard iNES header required for heuristic detection
 //a games database of all commercial Famicom software will be required
 string Ananke::syncFamicom(const string &pathname) {
-  return "";
+  vector<uint8_t> buffer;
+
+  auto append = [&](string filename) {
+    filename = {pathname, filename};
+    auto data = file::read(filename);
+    if(data.size() == 0) return;  //file does not exist
+
+    unsigned position = buffer.size();
+    buffer.resize(buffer.size() + data.size());
+    memcpy(buffer.data() + position, data.data(), data.size());
+  };
+
+  append("program.rom");
+  append("character.rom");
+
+  if(buffer.size() == 0) return "";
+
+  auto save = file::read({pathname, "save.ram"});
+  if(save.size() == 0) save = file::read({pathname, "save.rwm"});
+
+  directory::remove(pathname);
+  information.path = pathname;
+  information.name = notdir(string{pathname}.rtrim<1>("/"));
+  string outputPath = openFamicom(buffer);
+
+  if(save.size()) file::write({outputPath, "save.ram"}, save);
+
+  return outputPath;
 }
diff -Nru higan/ananke/Makefile higan/ananke/Makefile
--- higan/ananke/Makefile	2015-09-16 02:20:06.353574578 +0900
+++ higan/ananke/Makefile	1970-01-01 09:00:00.000000000 +0900
@@ -1,49 +0,0 @@
-include ../nall/Makefile
-include ../phoenix/Makefile
-
-path := /usr/local/lib
-flags := $(flags) -O3 -fomit-frame-pointer -I..
-
-all:
-	$(compiler) $(cppflags) $(flags) -fPIC -o obj/ananke.o -c ananke.cpp
-ifeq ($(platform),windows)
-	$(compiler) $(phoenixflags) -fPIC -o obj/phoenix.o -c ../phoenix/phoenix.cpp
-	$(compiler) $(link) -shared -o phoenix.dll obj/phoenix.o $(phoenixlink)
-	$(compiler) $(link) -shared -o ananke.dll obj/ananke.o -L. -lphoenix
-else ifeq ($(platform),macosx)
-	$(compiler) $(link) -shared -dynamiclib -undefined suppress -flat_namespace -o libananke.dylib obj/ananke.o
-else
-	$(compiler) $(link) -shared -Wl,-soname,libananke.so.1 -o libananke.so obj/ananke.o
-endif
-
-resource: force
-	sourcery resource/resource.bml resource/resource.cpp resource/resource.hpp
-
-clean:
-	-@$(call delete,obj/*.o)
-	-@$(call delete,*.dll)
-	-@$(call delete,*.so)
-
-install: uninstall
-ifeq ($(platform),windows)
-else ifeq ($(platform),macosx)
-	if [ ! -d ~/Library/Application\ Support/ananke ]; then mkdir ~/Library/Application\ Support/ananke; fi
-	sudo cp libananke.dylib $(path)/libananke.1.dylib
-	sudo ln -s $(path)/libananke.1.dylib $(path)/libananke.dylib
-else
-	if [ ! -d ~/.config/ananke ]; then mkdir ~/.config/ananke; fi
-	sudo cp libananke.so $(path)/libananke.so.1
-	sudo ln -s $(path)/libananke.so.1 $(path)/libananke.so
-endif
-
-uninstall:
-ifeq ($(platform),windows)
-else ifeq ($(platform),macosx)
-	if [ -f $(path)/libananke.dylib ]; then sudo rm $(path)/libananke.dylib; fi
-	if [ -f $(path)/libananke.1.dylib ]; then sudo rm $(path)/libananke.1.dylib; fi
-else
-	if [ -f $(path)/libananke.so ]; then sudo rm $(path)/libananke.so; fi
-	if [ -f $(path)/libananke.so.1 ]; then sudo rm $(path)/libananke.so.1; fi
-endif
-
-force:
diff -Nru higan/ananke/GNUmakefile higan/ananke/GNUmakefile
--- higan/ananke/GNUmakefile	1970-01-01 09:00:00.000000000 +0900
+++ higan/ananke/GNUmakefile	2015-09-16 14:33:30.612088241 +0900
@@ -0,0 +1,55 @@
+include ../nall/GNUmakefile
+
+ifeq ($(arch),x86)
+  flags += -m32
+  link += -m32
+endif
+
+include ../phoenix/GNUmakefile
+
+path := /usr/local/lib
+flags := $(flags) -O3 -fomit-frame-pointer -I..
+
+all:
+	$(compiler) $(cppflags) $(flags) -fPIC -o obj/ananke.o -c ananke.cpp
+ifeq ($(platform),windows)
+	$(compiler) $(phoenixflags) -fPIC -o obj/phoenix.o -c ../phoenix/phoenix.cpp
+	$(compiler) $(link) -shared -o phoenix.dll obj/phoenix.o $(phoenixlink)
+	$(compiler) $(link) -shared -o ananke.dll obj/ananke.o -L. -lphoenix
+else ifeq ($(platform),macosx)
+	$(compiler) $(link) -shared -dynamiclib -undefined suppress -flat_namespace -o libananke.dylib obj/ananke.o
+else
+	$(compiler) $(link) -shared -Wl,-soname,libananke.so.1 -o libananke.so obj/ananke.o
+endif
+
+resource: force
+	sourcery resource/resource.bml resource/resource.cpp resource/resource.hpp
+
+clean:
+	-@$(call delete,obj/*.o)
+	-@$(call delete,*.dll)
+	-@$(call delete,*.so)
+
+install: uninstall
+ifeq ($(platform),windows)
+else ifeq ($(platform),macosx)
+	if [ ! -d ~/Library/Application\ Support/ananke ]; then mkdir ~/Library/Application\ Support/ananke; fi
+	sudo cp libananke.dylib $(path)/libananke.1.dylib
+	sudo ln -s $(path)/libananke.1.dylib $(path)/libananke.dylib
+else
+	if [ ! -d ~/.config/ananke ]; then mkdir ~/.config/ananke; fi
+	sudo cp libananke.so $(path)/libananke.so.1
+	sudo ln -s $(path)/libananke.so.1 $(path)/libananke.so
+endif
+
+uninstall:
+ifeq ($(platform),windows)
+else ifeq ($(platform),macosx)
+	if [ -f $(path)/libananke.dylib ]; then sudo rm $(path)/libananke.dylib; fi
+	if [ -f $(path)/libananke.1.dylib ]; then sudo rm $(path)/libananke.1.dylib; fi
+else
+	if [ -f $(path)/libananke.so ]; then sudo rm $(path)/libananke.so; fi
+	if [ -f $(path)/libananke.so.1 ]; then sudo rm $(path)/libananke.so.1; fi
+endif
+
+force:
diff -Nru higan/ananke/heuristics/famicom.hpp higan/ananke/heuristics/famicom.hpp
--- higan/ananke/heuristics/famicom.hpp	2015-09-16 02:20:06.355574578 +0900
+++ higan/ananke/heuristics/famicom.hpp	2015-09-16 14:33:30.580088238 +0900
@@ -1,7 +1,7 @@
 #ifndef NALL_EMULATION_FAMICOM_HPP
 #define NALL_EMULATION_FAMICOM_HPP
 
-#include <nall/sha256.hpp>
+#include <nall/hash/sha256.hpp>
 #include <nall/string.hpp>
 
 namespace nall {
@@ -17,62 +17,128 @@
   unsigned prgram;
   unsigned chrrom;
   unsigned chrram;
+  bool     battery;
+  bool     region;
+  bool     vs;
+  // NES 2.0
+  bool     pc10;
+  bool     nes2;
+  unsigned submapper;
 };
 
 FamicomCartridge::FamicomCartridge(const uint8_t *data, unsigned size) {
   markup = "";
   if(size < 16) return;
-  if(data[0] != 'N') return;
-  if(data[1] != 'E') return;
-  if(data[2] != 'S') return;
-  if(data[3] !=  26) return;
-
-  mapper = ((data[7] >> 4) << 4) | (data[6] >> 4);
-  mirror = ((data[6] & 0x08) >> 2) | (data[6] & 0x01);
-  prgrom = data[4] * 0x4000;
-  chrrom = data[5] * 0x2000;
-  prgram = 0u;
-  chrram = chrrom == 0u ? 8192u : 0u;
+  if(data[0] != 'N' ) return;
+  if(data[1] != 'E' ) return;
+  if(data[2] != 'S' ) return;
+  if(data[3] != 0x1A) return;
+
+  mapper  = ((data[7] >> 4) << 4) | (data[6] >> 4);
+  prgrom  = data[4] * 0x4000;
+  chrrom  = data[5] * 0x2000;
+  prgram  = 0u;
+  chrram  = chrrom == 0u ? 8192u : 0u;
+  mirror  = ((data[6] & 0x08) >> 2) | (data[6] & 0x01);
+  battery = data[6] & 0x02;
+  vs      = data[7] & 0x01;
+  nes2    = data[7] & 0x0c == 0x08;
+  if(!nes2) {
+    // ignore the last 9 bytes of headers that have "DiskDude!" or other
+    // messages written there
+    if(data[12] == 0 && data[13] == 0 && data[14] == 0 && data[15] == 0) {
+      prgram = data[8] * 0x2000;
+      region = data[9] & 0x01;
+    } else {
+      mapper &= 0x0f;
+      vs = false;
+      pc10 = false;
+    }
+  } else {
+    pc10 = data[7] & 0x02;
+    mapper |= (data[8] & 0x0f) << 8;
+    submapper |= data[8] >> 4;
+    prgrom += (data[9] & 0x0f) * 0x400000;
+    chrrom += (data[9] >> 4) * 0x200000;
+    prgram = (data[10] & 0x0f == 0 ? 0 : 64) << (data[10] & 0x0f); // no battery
+    prgram += (data[10] >> 4 == 0 ? 0 : 64) << (data[10] >> 4); // battery
+    chrram = (data[11] & 0x0f == 0 ? 0 : 64) << (data[11] & 0x0f); // no battery
+    chrram += (data[11] >> 4 == 0 ? 0 : 64) << (data[11] >> 4); // battery
+    region = data[12] & 0x01;
+  }
+
+  // Galaxian has its PRG ROM doubled to fit within iNES's constraints.
+  if(prgrom == 0x4000 && (prgrom + chrrom + 0x10 == size + 0x2000)) prgrom = 0x2000;
 
-  markup.append("cartridge\n");
+  markup.append("cartridge region=", region == 0 ? "NTSC" : "PAL", "\n");
 
   switch(mapper) {
   default:
-    markup.append("  board type=NES-NROM-256\n");
+    if(prgrom <= 8192) {
+      markup.append("  board type=NAMCOT-3301\n");
+    } else if(prgrom <= 16384) {
+      markup.append("  board type=NES-NROM-128\n");
+    } else {
+      markup.append("  board type=NES-NROM-256\n");
+    }
     markup.append("  mirror mode=", mirror == 0 ? "horizontal" : "vertical", "\n");
     break;
 
   case   1:
-    markup.append("  board type=NES-SXROM\n");
-    markup.append("  chip type=MMC1B2\n");
-    prgram = 8192;
+  case 155:
+    if(prgram <= 8192) {
+      markup.append("  board type=NES-SUROM\n");
+    } else {
+      markup.append("  board type=NES-SXROM\n");
+    }
+    markup.append("  chip type=MMC1", mapper != 155 ? "B2" : "A", "\n");
+    if(!nes2 && !prgram) prgram = 8192;
     break;
 
   case   2:
-    markup.append("  board type=NES-UOROM\n");
+  case  94:
+  case 180:
+         if(mapper == 94)     markup.append("  board type=HVC-UN1ROM\n");
+    else if(prgrom <= 131072) markup.append("  board type=NES-UNROM\n");
+    else                 markup.append("  board type=NES-UOROM\n");
+    markup.append("  chip type=74HC", mapper != 180 ? "32" : "08", "\n");
     markup.append("  mirror mode=", mirror == 0 ? "horizontal" : "vertical", "\n");
     break;
 
   case   3:
+  case 185:
     markup.append("  board type=NES-CNROM\n");
+    if(mapper == 185) {
+      markup.append("    security pass=0x", hex(submapper & 3), "\n");
+    }
     markup.append("  mirror mode=", mirror == 0 ? "horizontal" : "vertical", "\n");
     break;
 
   case   4:
-    //MMC3
-    markup.append("  board type=NES-TLROM\n");
-    markup.append("  chip type=MMC3B\n");
-    prgram = 8192;
-    //MMC6
-  //markup.append("  board type=NES-HKROM\n");
-  //markup.append("  chip type=MMC6n");
-  //prgram = 1024;
+  case 118:
+  case 119:
+    if(prgram != 0x400) {
+      switch(mapper) {
+      case   4:
+        if(mirror & 2) markup.append("  board type=NES-TR1ROM\n");
+        else           markup.append("  board type=NES-TLROM\n");
+        break;
+      case 118: markup.append("  board type=NES-TLSROM\n"); break;
+      case 119: markup.append("  board type=NES-TQROM\n"); break;
+      }
+      markup.append("  chip type=MMC3B\n");
+    } else {
+      markup.append("  board type=NES-HKROM\n");
+      markup.append("  chip type=MMC6n");
+    }
+    if(!nes2 && !prgram) prgram = 8192;
+    if(mapper == 119 && !nes2 && !chrram) chrram = 0x2000;
     break;
 
   case   5:
     markup.append("  board type=NES-ELROM\n");
     markup.append("  chip type=MMC5\n");
-    prgram = 65536;
+    if(!nes2 && !prgram) prgram = 32768;
     break;
 
   case   7:
@@ -82,46 +148,94 @@
   case   9:
     markup.append("  board type=NES-PNROM\n");
     markup.append("  chip type=MMC2\n");
-    prgram = 8192;
+    if(!nes2 && !prgram) prgram = 8192;
     break;
 
   case  10:
     markup.append("  board type=NES-FKROM\n");
     markup.append("  chip type=MMC4\n");
-    prgram = 8192;
+    if(!nes2 && !prgram) prgram = 8192;
     break;
 
-  case  16:
-    markup.append("  board type=BANDAI-FCG\n");
-    markup.append("  chip type=LZ93D50\n");
+  case  13:
+    markup.append("  board type=NES-CPROM\n");
+    markup.append("  mirror mode=", mirror == 0 ? "horizontal" : "vertical", "\n");
     break;
 
-  case  21:
-  case  23:
-  case  25:
-    //VRC4
+  case  16:
+  case 153:
+  case 159:
+    switch(mapper) {
+    case  16:
+      markup.append("  board type=BANDAI-FCG\n");
+      markup.append("  chip type=LZ93D50\n");
+      markup.append("  chip type=24C02\n");
+      break;
+    case 153:
+      markup.append("  board type=BANDAI-JUMP2\n");
+      markup.append("  chip type=LZ93D50\n");
+      if(!nes2 && !prgram) prgram = 8192;
+      break;
+    case 159:
+      markup.append("  board type=BANDAI-LZ93D50\n");
+      markup.append("  chip type=LZ93D50\n");
+      markup.append("  chip type=24C01\n");
+      break;
+    }
+    break;
+
+  case  18:
+    markup.append("  board type=JALECO-JF-24\n");
+    markup.append("  chip type=SS88006\n");
+    break;
+
+  case  21: //VRC4a,VRC4c
+  case  23: //VRC4e,VRC4f,VRC2b
+  case  25: //VRC4b,VRC4d,VRC2c
     markup.append("  board type=KONAMI-VRC-4\n");
-    markup.append("  chip type=VRC4\n");
-    markup.append("    pinout a0=1 a1=0\n");
-    prgram = 8192;
+    markup.append("  chip type=", submapper == 15 ? "VRC2" : "VRC4", "\n");
+    if(submapper == 0) {
+      switch(mapper) {
+      case 21: markup.append("    pinout a0=1 a1=2\n"); break;
+      case 23: markup.append("    pinout a0=0 a1=1\n"); break;
+      case 25: markup.append("    pinout a0=1 a1=0\n"); break;
+      }
+    } else if(submapper == 15) {
+      markup.append("    pinout",
+        " a0=", submapper == 25,
+        " a1=", submapper == 23,
+      "\n");
+    } else {
+      markup.append("    pinout",
+        " a0=", submapper & 7,
+        " a1=", (submapper & 7) + (((submapper & 8) >> 2) - 1),
+      "\n");
+    }
+    if(!nes2 && !prgram) prgram = 8192;
     break;
 
   case  22:
-    //VRC2
+    //VRC2a
     markup.append("  board type=KONAMI-VRC-2\n");
     markup.append("  chip type=VRC2\n");
-    markup.append("    pinout a0=0 a1=1\n");
+    markup.append("    pinout a0=1 a1=0\n");
     break;
 
   case  24:
+  case  26:
     markup.append("  board type=KONAMI-VRC-6\n");
     markup.append("  chip type=VRC6\n");
+    switch(mapper) {
+    case 24: markup.append("    pinout a0=0 a1=1\n"); break;
+    case 26: markup.append("    pinout a0=1 a1=0\n"); break;
+    }
+    if(!nes2 && !prgram) prgram = 8192;
     break;
 
-  case  26:
-    markup.append("  board type=KONAMI-VRC-6\n");
-    markup.append("  chip type=VRC6\n");
-    prgram = 8192;
+  case  32:
+    markup.append("  board type=IREM-G101\n");
+    markup.append("  chip type=G-101\n");
+    if(submapper == 1) markup.append("  mirror mode=screen-1\n");
     break;
 
   case  34:
@@ -129,6 +243,11 @@
     markup.append("  mirror mode=", mirror == 0 ? "horizontal" : "vertical", "\n");
     break;
 
+  case  65:
+    markup.append("  board type=IREM-H3001\n");
+    markup.append("  chip type=IF-H3001\n");
+    break;
+
   case  66:
     markup.append("  board type=NES-GNROM\n");
     markup.append("  mirror mode=", mirror == 0 ? "horizontal" : "vertical", "\n");
@@ -137,14 +256,19 @@
   case  69:
     markup.append("  board type=SUNSOFT-5B\n");
     markup.append("  chip type=5B\n");
-    prgram = 8192;
+    if(!nes2 && !prgram) prgram = 8192;
+    break;
+
+  case  70:
+    markup.append("  board type=BANDAI-74*161/161/32\n");
+    markup.append("  mirror mode=", mirror == 0 ? "horizontal" : "vertical", "\n");
     break;
 
   case  73:
     markup.append("  board type=KONAMI-VRC-3\n");
     markup.append("  chip type=VRC3\n");
     markup.append("  mirror mode=", mirror == 0 ? "horizontal" : "vertical", "\n");
-    prgram = 8192;
+    if(!nes2 && !prgram) prgram = 8192;
     break;
 
   case  75:
@@ -152,16 +276,69 @@
     markup.append("  chip type=VRC1\n");
     break;
 
+  case  77:
+    markup.append("  board type=IREM-74*161/161/21/138\n");
+    break;
+
+  case  78:
+    markup.append("  board type=",
+      submapper != 3 ? "JALECO-JF-16" : "IREM-HOLYDIVER",
+    "\n");
+    break;
+
   case  85:
     markup.append("  board type=KONAMI-VRC-7\n");
     markup.append("  chip type=VRC7\n");
-    prgram = 8192;
+    if(!nes2 && !prgram) prgram = 8192;
+    break;
+
+  case  86:
+    markup.append("  board type=JALECO-JF-13\n");
+    markup.append("  chip type=uPD7756C\n");
+    markup.append("  mirror mode=", mirror == 0 ? "horizontal" : "vertical", "\n");
+    break;
+
+  case  87:
+    markup.append("  board type=JALECO-JF-09\n");
+    markup.append("  mirror mode=", mirror == 0 ? "horizontal" : "vertical", "\n");
+    break;
+
+  case  97:
+    markup.append("  board type=IREM-TAM-S1\n");
+    markup.append("  chip type=TAM-S1\n");
+    break;
+
+  case 140:
+    markup.append("  board type=JALECO-JF-14\n");
+    markup.append("  mirror mode=", mirror == 0 ? "horizontal" : "vertical", "\n");
+    break;
+
+  case  76:
+  case  88:
+  case  95:
+  case 154:
+  case 206:
+    switch(mapper) {
+    case  76: markup.append("  board type=NAMCOT-3446\n"); break;
+    case  88: markup.append("  board type=NAMCOT-3443\n"); break;
+    case  95: markup.append("  board type=NAMCOT-3425\n"); break;
+    case 154: markup.append("  board type=NAMCOT-3453\n"); break;
+    case 206: markup.append("  board type=NAMCOT-3401\n"); break;
+    // Normally 3416, but バベルの塔 (Babel no Tou) uses bankswitching despite
+    // fitting entirely in the memory map, and other 32KB programs are not
+    // broken by having it enabled.
+    }
+    markup.append("  chip type=Namcot108\n");
+    markup.append("  mirror mode=", mirror == 0 ? "horizontal" : "vertical", "\n");
     break;
   }
 
   markup.append("  prg\n");
   if(prgrom) markup.append("    rom name=program.rom size=0x", hex(prgrom), "\n");
-  if(prgram) markup.append("    ram name=save.ram size=0x", hex(prgram), "\n");
+  if(prgram) {
+    if(battery) markup.append("    ram name=save.ram size=0x", hex(prgram), "\n");
+    else        markup.append("    ram size=0x", hex(prgram), "\n");
+  }
 
   markup.append("  chr\n");
   if(chrrom) markup.append("    rom name=character.rom size=0x", hex(chrrom), "\n");
diff -Nru higan/ananke/heuristics/game-boy-advance.hpp higan/ananke/heuristics/game-boy-advance.hpp
--- higan/ananke/heuristics/game-boy-advance.hpp	2015-09-16 02:20:06.355574578 +0900
+++ higan/ananke/heuristics/game-boy-advance.hpp	2015-09-16 14:33:30.577088238 +0900
@@ -1,7 +1,7 @@
 #ifndef NALL_EMULATION_GAME_BOY_ADVANCE_HPP
 #define NALL_EMULATION_GAME_BOY_ADVANCE_HPP
 
-#include <nall/sha256.hpp>
+#include <nall/hash/sha256.hpp>
 #include <nall/string.hpp>
 #include <nall/vector.hpp>
 
diff -Nru higan/ananke/heuristics/game-boy.hpp higan/ananke/heuristics/game-boy.hpp
--- higan/ananke/heuristics/game-boy.hpp	2015-09-16 02:20:06.355574578 +0900
+++ higan/ananke/heuristics/game-boy.hpp	2015-09-16 14:33:30.577088238 +0900
@@ -1,7 +1,7 @@
 #ifndef NALL_EMULATION_GAME_BOY_HPP
 #define NALL_EMULATION_GAME_BOY_HPP
 
-#include <nall/sha256.hpp>
+#include <nall/hash/sha256.hpp>
 #include <nall/string.hpp>
 
 namespace nall {
diff -Nru higan/ananke/heuristics/super-famicom.hpp higan/ananke/heuristics/super-famicom.hpp
--- higan/ananke/heuristics/super-famicom.hpp	2015-09-16 02:20:06.355574578 +0900
+++ higan/ananke/heuristics/super-famicom.hpp	2015-09-16 14:33:30.579088238 +0900
@@ -1,7 +1,7 @@
 #ifndef NALL_EMULATION_SUPER_FAMICOM_HPP
 #define NALL_EMULATION_SUPER_FAMICOM_HPP
 
-#include <nall/sha256.hpp>
+#include <nall/hash/sha256.hpp>
 #include <nall/string.hpp>
 
 namespace nall {
@@ -328,12 +328,14 @@
     markup.append(
       "  bsx\n"
       "    rom name=program.rom size=0x", hex(rom_size), "\n"
-      "    ram id=save name=save.ram size=0x", hex(ram_size), "\n"
-      "    ram id=download name=bsx.ram size=0x40000\n"
+      "    ram name=save.ram size=0x", hex(ram_size), "\n"
+      "    ram name=download.ram size=0x80000\n"
       "    map id=io address=00-3f,80-bf:5000-5fff\n"
       "    map id=rom address=00-3f,80-bf:8000-ffff\n"
-      "    map id=rom address=40-7f,c0-ff:0000-ffff\n"
-      "    map id=ram address=20-3f:6000-7fff\n"
+      "    map id=rom address=40-5f,c0-ff:0000-ffff\n"
+      "    map id=rom address=78-7d:0000-ffff\n"
+      "    map id=ram address=20-3f:6000-7fff mask=0xe000\n"
+      "    map id=ram address=70-77:0000-ffff\n"
     );
   }
 
diff -Nru higan/ananke/sufami-turbo.cpp higan/ananke/sufami-turbo.cpp
--- higan/ananke/sufami-turbo.cpp	2015-09-16 02:20:06.356574579 +0900
+++ higan/ananke/sufami-turbo.cpp	2015-09-16 14:33:30.577088238 +0900
@@ -62,7 +62,7 @@
 
   for(auto &item : databaseItem) {
     item.append("\n");
-    auto document = Markup::Document(item);
+    auto document = BML::unserialize(item);
 
     if(document["release/information/sha256"].text() == sha256) {
       return createSufamiTurboDatabase(buffer, document, item);
diff -Nru higan/ananke/super-famicom.cpp higan/ananke/super-famicom.cpp
--- higan/ananke/super-famicom.cpp	2015-09-16 02:20:06.356574579 +0900
+++ higan/ananke/super-famicom.cpp	2015-09-16 14:33:30.575088238 +0900
@@ -129,7 +129,7 @@
 
   for(auto &item : databaseItem) {
     item.append("\n");
-    auto document = Markup::Document(item);
+    auto document = BML::unserialize(item);
 
     if(document["release/information/sha256"].text() == sha256) {
       return createSuperFamicomDatabase(buffer, document, item);
diff -Nru higan/emulator/interface.hpp higan/emulator/interface.hpp
--- higan/emulator/interface.hpp	2015-09-16 02:20:06.370574580 +0900
+++ higan/emulator/interface.hpp	2015-09-16 13:08:13.696563382 +0900
@@ -109,6 +109,9 @@
   //utility functions
   enum class PaletteMode : unsigned { Literal, Channel, Standard, Emulation };
   virtual auto paletteUpdate(PaletteMode mode) -> void {}
+
+  //debugger functions
+  virtual auto exportMemory() -> void {}
 };
 
 }
diff -Nru higan/fc/apu/apu.cpp higan/fc/apu/apu.cpp
--- higan/fc/apu/apu.cpp	2015-09-16 02:20:06.370574580 +0900
+++ higan/fc/apu/apu.cpp	2015-09-16 13:08:13.517563364 +0900
@@ -1,6 +1,9 @@
 #include <fc/fc.hpp>
 
+#define APU_CPP
 namespace Famicom {
+  
+APU apu;
 
 #include "envelope.cpp"
 #include "sweep.cpp"
@@ -9,7 +12,6 @@
 #include "noise.cpp"
 #include "dmc.cpp"
 #include "serialization.cpp"
-APU apu;
 
 const uint8 APU::length_counter_table[32] = {
   0x0a, 0xfe, 0x14, 0x02, 0x28, 0x04, 0x50, 0x06, 0xa0, 0x08, 0x3c, 0x0a, 0x0e, 0x0c, 0x1a, 0x0e,
@@ -32,11 +34,9 @@
   398, 354, 316, 298, 276, 236, 210, 198, 176, 148, 132, 118,  98, 78, 66, 50,
 };
 
-void APU::Main() {
-  apu.main();
-}
+void APU::Enter() { apu.enter(); }
 
-void APU::main() {
+void APU::enter() {
   while(true) {
     if(scheduler.sync == Scheduler::SynchronizeMode::All) {
       scheduler.exit(Scheduler::ExitReason::SynchronizeEvent);
@@ -67,7 +67,7 @@
 }
 
 void APU::tick() {
-  clock += 12;
+  clock += (system.region() == System::Region::NTSC ? 12 : 16);
   if(clock >= 0 && scheduler.sync != Scheduler::SynchronizeMode::All) co_switch(cpu.thread);
 }
 
@@ -92,7 +92,7 @@
 }
 
 void APU::reset() {
-  create(APU::Main, 21477272);
+  create(APU::Enter, system.cpu_frequency());
 
   pulse[0].reset();
   pulse[1].reset();
@@ -249,7 +249,10 @@
       frame.irq_pending = false;
       set_irq_line();
     }
-    frame.divider = FrameCounter::NtscPeriod;
+    if(system.region() == System::Region::NTSC)
+      frame.divider = FrameCounter::NtscPeriod;
+    else
+      frame.divider = FrameCounter::PalPeriod;
     break;
   }
 }
@@ -287,7 +290,12 @@
   noise.envelope.clock();
 
   if(frame.counter == 0) {
-    if(frame.mode & 2) frame.divider += FrameCounter::NtscPeriod;
+    if(frame.mode & 2) {
+      if(system.region() == System::Region::NTSC)
+        frame.divider += FrameCounter::NtscPeriod;
+      else
+        frame.divider += FrameCounter::PalPeriod;
+    }
     if(frame.mode == 0) {
       frame.irq_pending = true;
       set_irq_line();
@@ -299,7 +307,10 @@
   frame.divider -= 2;
   if(frame.divider <= 0) {
     clock_frame_counter();
-    frame.divider += FrameCounter::NtscPeriod;
+    if(system.region() == System::Region::NTSC)
+      frame.divider += FrameCounter::NtscPeriod;
+    else
+      frame.divider += FrameCounter::PalPeriod;
   }
 }
 
diff -Nru higan/fc/apu/apu.hpp higan/fc/apu/apu.hpp
--- higan/fc/apu/apu.hpp	2015-09-16 02:20:06.370574580 +0900
+++ higan/fc/apu/apu.hpp	2015-09-16 13:08:13.519563364 +0900
@@ -1,6 +1,6 @@
 struct APU : Thread {
-  static void Main();
-  void main();
+  static void Enter();
+  void enter();
   void tick();
   void set_irq_line();
   void set_sample(int16 sample);
@@ -35,7 +35,10 @@
   #include "dmc.hpp"
 
   struct FrameCounter {
-    enum : unsigned { NtscPeriod = 14915 };  //~(21.477MHz / 6 / 240hz)
+    enum : unsigned {
+      NtscPeriod = 14915,  //~(21.477MHz / 6 / 240hz)
+      PalPeriod = 18473, // conjectural
+    };
 
     bool irq_pending;
 
diff -Nru higan/fc/apu/dmc.cpp higan/fc/apu/dmc.cpp
--- higan/fc/apu/dmc.cpp	2015-09-16 02:20:06.371574580 +0900
+++ higan/fc/apu/dmc.cpp	2015-09-16 13:08:13.518563364 +0900
@@ -1,3 +1,5 @@
+#ifdef APU_CPP
+
 void APU::DMC::start() {
   if(length_counter == 0) {
     read_addr = 0x4000 + (addr_latch << 6);
@@ -57,7 +59,10 @@
       }
     }
 
-    period_counter = ntsc_dmc_period_table[period];
+    if(system.region() == System::Region::NTSC)
+      period_counter = ntsc_dmc_period_table[period];
+    else
+      period_counter = pal_dmc_period_table[period];
   }
 
   if(length_counter > 0 && have_dma_buffer == false && dma_delay_counter == 0) {
@@ -115,3 +120,5 @@
   s.integer(have_sample);
   s.integer(sample);
 }
+
+#endif
diff -Nru higan/fc/apu/envelope.cpp higan/fc/apu/envelope.cpp
--- higan/fc/apu/envelope.cpp	2015-09-16 02:20:06.371574580 +0900
+++ higan/fc/apu/envelope.cpp	2015-09-16 13:08:13.517563364 +0900
@@ -1,3 +1,5 @@
+#ifdef APU_CPP
+
 unsigned APU::Envelope::volume() const {
   return use_speed_as_volume ? speed : decay_volume;
 }
@@ -37,3 +39,5 @@
   s.integer(decay_counter);
   s.integer(decay_volume);
 }
+
+#endif
diff -Nru higan/fc/apu/noise.cpp higan/fc/apu/noise.cpp
--- higan/fc/apu/noise.cpp	2015-09-16 02:20:06.371574580 +0900
+++ higan/fc/apu/noise.cpp	2015-09-16 13:08:13.518563364 +0900
@@ -1,3 +1,5 @@
+#ifdef APU_CPP
+
 void APU::Noise::clock_length() {
   if(envelope.loop_mode == 0) {
     if(length_counter > 0) length_counter--;
@@ -19,7 +21,10 @@
     }
 
     lfsr = (lfsr >> 1) | (feedback << 14);
-    period_counter = apu.ntsc_noise_period_table[period];
+    if(system.region() == System::Region::NTSC)
+      period_counter = apu.ntsc_noise_period_table[period];
+    else
+      period_counter = apu.pal_noise_period_table[period];
   }
 
   return result;
@@ -55,3 +60,5 @@
   s.integer(short_mode);
   s.integer(lfsr);
 }
+
+#endif
diff -Nru higan/fc/apu/pulse.cpp higan/fc/apu/pulse.cpp
--- higan/fc/apu/pulse.cpp	2015-09-16 02:20:06.371574580 +0900
+++ higan/fc/apu/pulse.cpp	2015-09-16 13:08:13.516563364 +0900
@@ -1,3 +1,5 @@
+#ifdef APU_CPP
+
 void APU::Pulse::clock_length() {
   if(envelope.loop_mode == 0) {
     if(length_counter) length_counter--;
@@ -49,3 +51,5 @@
   s.integer(period);
   s.integer(period_counter);
 }
+
+#endif
diff -Nru higan/fc/apu/serialization.cpp higan/fc/apu/serialization.cpp
--- higan/fc/apu/serialization.cpp	2015-09-16 02:20:06.371574580 +0900
+++ higan/fc/apu/serialization.cpp	2015-09-16 13:08:13.518563364 +0900
@@ -1,3 +1,5 @@
+#ifdef APU_CPP
+
 void APU::serialize(serializer& s) {
   Thread::serialize(s);
 
@@ -26,3 +28,5 @@
   s.integer(counter);
   s.integer(divider);
 }
+
+#endif
diff -Nru higan/fc/apu/sweep.cpp higan/fc/apu/sweep.cpp
--- higan/fc/apu/sweep.cpp	2015-09-16 02:20:06.371574580 +0900
+++ higan/fc/apu/sweep.cpp	2015-09-16 13:08:13.518563364 +0900
@@ -1,3 +1,5 @@
+#ifdef APU_CPP
+
 bool APU::Sweep::check_period() {
   if(pulse_period > 0x7ff) return false;
 
@@ -51,3 +53,5 @@
   s.integer(reload);
   s.integer(pulse_period);
 }
+
+#endif
diff -Nru higan/fc/apu/triangle.cpp higan/fc/apu/triangle.cpp
--- higan/fc/apu/triangle.cpp	2015-09-16 02:20:06.371574580 +0900
+++ higan/fc/apu/triangle.cpp	2015-09-16 13:08:13.518563364 +0900
@@ -1,3 +1,5 @@
+#ifdef APU_CPP
+
 void APU::Triangle::clock_length() {
   if(halt_length_counter == 0) {
     if(length_counter > 0) length_counter--;
@@ -56,3 +58,5 @@
   s.integer(linear_length_counter);
   s.integer(reload_linear);
 }
+
+#endif
diff -Nru higan/fc/arcade/arcade.hpp higan/fc/arcade/arcade.hpp
--- higan/fc/arcade/arcade.hpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/fc/arcade/arcade.hpp	2015-09-16 13:08:13.512563363 +0900
@@ -0,0 +1,2 @@
+#include <fc/arcade/vs/vs.hpp>
+#include <fc/arcade/pc10/pc10.hpp>
diff -Nru higan/fc/arcade/pc10/pc10.cpp higan/fc/arcade/pc10/pc10.cpp
--- higan/fc/arcade/pc10/pc10.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/fc/arcade/pc10/pc10.cpp	2015-09-16 13:08:13.513563364 +0900
@@ -0,0 +1,134 @@
+#include <fc/fc.hpp>
+
+#define PC10_ARCADE_BOARD_CPP
+namespace Famicom {
+
+PC10ArcadeBoard pc10arcadeboard;
+
+#include "video-circuit.cpp"
+#include "serialization.cpp"
+
+void PC10ArcadeBoard::init() {
+  dip = 0;
+}
+
+void PC10ArcadeBoard::load() {
+}
+
+void PC10ArcadeBoard::unload() {
+}
+
+void PC10ArcadeBoard::power() {
+  vram_access = 1; // 0: Z80,                  1: video circuit
+  controls    = 1; // 0: disable START/SELECT, 1: enable START/SELECT
+  ppu_output  = 1; // 0: disable,              1: enable
+  apu_output  = 1; // 0: disable,              1: enable
+  cpu_reset   = 1; // 0: reset,                1: run
+  cpu_stop    = 1; // 0: stop,                 1: run
+  display     = 1; // 0: video circuit,        1: PPU
+  z80_nmi     = 0; // 0: disable,              1: enable
+  watchdog    = 1; // 0: enable,               1: disable
+  ppu_reset   = 1; // 0: reset,                1: run
+  channel     = 0; // 0-9 internally, 1-10 to players
+  sram_bank   = 1; // bank at $8c00-8fff
+  video_power();
+  update_video();
+}
+
+void PC10ArcadeBoard::reset() {
+}
+
+void PC10ArcadeBoard::set_dip(uint16 dip) {
+  this->dip = dip;
+}
+
+uint8 PC10ArcadeBoard::read(uint16 addr) {
+  if(addr <= 0x7fff) return bios[addr & 0x3fff];
+  if(addr <= 0x87ff) return wram[addr & 0x07ff];
+  if(addr <= 0x8bff) return sram[addr & 0x03ff];
+  if(addr <= 0x8fff) return sram[(addr & 0x03ff) | (sram_bank << 10)];
+  if(addr <= 0x97ff) return 0x00; // VRAM is write-only
+  if(addr <= 0xbfff) return 0x00;
+  if(addr <= 0xdfff) return cartridge.board->instrom.read(addr & 0x1fff);
+  if(addr <= 0xffff) {
+    uint8 data = 0xe7;
+    if(!prom_test || prom_address < 0x40)
+      data |= (((cartridge.board->keyrom.read(prom_address >> 3) >> (prom_address & 7)) & 1) << 3) ^ 0x08;
+    else
+      data |= (prom_address & 2 ? 0x00 : cartridge.board->keyrom.read(8)) ^ 0x08;
+    data |= ((prom_address & 0x20) >> 1) ^ 0x10;
+    return data;
+  };
+}
+
+void PC10ArcadeBoard::write(uint16 addr, uint8 data) {
+       if(addr <= 0x7fff) return;
+  else if(addr <= 0x87ff) wram[addr & 0x07ff] = data;
+  else if(addr <= 0x8bff) sram[addr & 0x03ff] = data;
+  else if(addr <= 0x8fff) sram[(addr & 0x03ff) | (sram_bank << 10)] = data;
+  else if(addr <= 0x97ff) vram[addr & 0x07ff] = data;
+  else if(addr <= 0xbfff) return;
+  else if(addr <= 0xdfff) return;
+  else if(addr <= 0xffff) {
+    prom_test = data & 0x10;
+    if(prom_clock && (data & 0x08) == 0) prom_address++;
+    prom_clock = data & 0x08;
+    if((data & 0x01) == 0) prom_address = 0;
+    return;
+  }
+}
+
+uint8 PC10ArcadeBoard::io_read(uint16 addr) {
+  uint8 data = 0x00;
+  bool channel_select = false;
+  bool enter          = false;
+  bool reset          = false;
+  bool coin_2         = false;
+  bool service        = false;
+  bool coin_1         = false;
+  switch(addr & 0x0003) {
+  case 0x0000:
+    data |= channel_select      << 0;
+    data |= enter               << 1;
+    data |= reset               << 2;
+    data |= cpu.status.nmi_line << 3;
+    data |= 0                   << 4;
+    data |= coin_2              << 5;
+    data |= service             << 6;
+    data |= coin_1              << 7;
+    break;
+  case 0x0001: data = (dip >> 0) & 0xff; break;
+  case 0x0002: data = (dip >> 8) & 0xff; break;
+  case 0x0003: data = 0x00; break;
+  }
+  return data;
+}
+
+void PC10ArcadeBoard::io_write(uint16 addr, uint8 data) {
+  data &= 0x01;
+  switch(addr & 0x001f) {
+  case 0x0000: vram_access = data; break;
+  case 0x0001: controls    = data; break;
+  case 0x0002: ppu_output  = data; break;
+  case 0x0003: apu_output  = data; break;
+  case 0x0004: cpu_reset   = data; break;
+  case 0x0005: cpu_stop    = data; break;
+  case 0x0006: display     = data; break;
+  case 0x0008: z80_nmi     = data; break;
+  case 0x0009: watchdog    = data; break;
+  case 0x000a: ppu_reset   = data; break;
+  case 0x000b: channel = (channel & 0xe) | (data << 0); break;
+  case 0x000c: channel = (channel & 0xd) | (data << 1); break;
+  case 0x000d: channel = (channel & 0xb) | (data << 2); break;
+  case 0x000e: channel = (channel & 0x7) | (data << 3); break;
+  case 0x000f: sram_bank   = data; break;
+  }
+  switch(addr & 0x13) {
+  case 0x0010: break;
+  case 0x0011: break;
+  case 0x0012: break;
+  case 0x0013: break;
+  }
+}
+
+}
diff -Nru higan/fc/arcade/pc10/pc10.hpp higan/fc/arcade/pc10/pc10.hpp
--- higan/fc/arcade/pc10/pc10.hpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/fc/arcade/pc10/pc10.hpp	2015-09-16 13:08:13.513563364 +0900
@@ -0,0 +1,60 @@
+struct PC10ArcadeBoard {
+  uint8 bios[16384];
+  uint8 wram[2048];
+  uint8 sram[2048];
+  uint8 vram[2048];
+  //Z80 memory map
+  //0000-7fff: BIOS
+  //8000-87ff: WRAM
+  //8800-8bff: SRAM bank 0
+  //8c00-8fff: SRAM switchable bank (0 or 1)
+  //9000-97ff: VRAM
+  //9800-bfff: open bus
+  //c000-dfff: cartridge instruction ROM
+  //e000-ffff: cartridge IO registers
+
+  uint8 chrrom[0x2000 * 3];
+  uint8 cgrom[0x100 * 3];
+
+  uint16 dip;
+
+  bool vram_access;
+  bool controls;
+  bool ppu_output;
+  bool apu_output;
+  bool cpu_reset;
+  bool cpu_stop;
+  bool display;
+  bool z80_nmi;
+  bool watchdog;
+  bool ppu_reset;
+  uint4 channel;
+  bool sram_bank;
+
+  bool prom_test;
+  bool prom_clock;
+  uint7 prom_address;
+
+  uint32 video_output[256 * 240];
+
+  void init();
+  void load();
+  void unload();
+  void power();
+  void reset();
+
+  void set_dip(uint16 dip);
+  uint8 read(uint16 addr);
+  void write(uint16 addr, uint8 data);
+
+  uint8 io_read(uint16 addr);
+  void io_write(uint16 addr, uint8 data);
+
+  void serialize(serializer& s);
+
+private:
+  void video_power();
+  void update_video();
+};
+
+extern PC10ArcadeBoard pc10arcadeboard;
diff -Nru higan/fc/arcade/pc10/serialization.cpp higan/fc/arcade/pc10/serialization.cpp
--- higan/fc/arcade/pc10/serialization.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/fc/arcade/pc10/serialization.cpp	2015-09-16 13:08:13.513563364 +0900
@@ -0,0 +1,24 @@
+#ifdef PC10_ARCADE_BOARD_CPP
+
+void PC10ArcadeBoard::serialize(serializer& s) {
+  s.array(wram);
+  s.array(sram);
+  s.array(vram);
+
+  s.integer(dip);
+
+  s.integer(vram_access);
+  s.integer(controls);
+  s.integer(ppu_output);
+  s.integer(apu_output);
+  s.integer(cpu_reset);
+  s.integer(cpu_stop);
+  s.integer(display);
+  s.integer(z80_nmi);
+  s.integer(watchdog);
+  s.integer(ppu_reset);
+  s.integer(channel);
+  s.integer(sram_bank);
+}
+
+#endif
diff -Nru higan/fc/arcade/pc10/video-circuit.cpp higan/fc/arcade/pc10/video-circuit.cpp
--- higan/fc/arcade/pc10/video-circuit.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/fc/arcade/pc10/video-circuit.cpp	2015-09-16 13:08:13.513563364 +0900
@@ -0,0 +1,187 @@
+#ifdef PC10_ARCADE_BOARD_CPP
+
+void PC10ArcadeBoard::video_power() {
+  uint8 default_vram[0x0800] = {
+0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,
+0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,
+0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,
+0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,
+
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+
+0xff,0x1b,0xdb,0x1b,0xdc,0x1b,0xdc,0x1b,0xdc,0x1b,0xdc,0x1b,0xdc,0x1b,0xdc,0x1b,
+0xdc,0x1b,0xdc,0x1b,0xdc,0x1b,0xdc,0x1b,0xdc,0x1b,0xdc,0x1b,0xdc,0x1b,0xdc,0x1b,
+0xdc,0x1b,0xdc,0x1b,0xdc,0x1b,0xdc,0x1b,0xdc,0x1b,0xdc,0x1b,0xdc,0x1b,0xdc,0x1b,
+0xdc,0x1b,0xdc,0x1b,0xdc,0x1b,0xdc,0x1b,0xdc,0x1b,0xdc,0x1b,0xdd,0x1b,0xff,0x1b,
+
+0xff,0x1b,0xe2,0x1b,0xfa,0x1b,0xfa,0x1b,0xfa,0x1b,0xfa,0x1b,0xfa,0x1b,0xfa,0x1b,
+0xfa,0x1b,0xfa,0x1b,0xfa,0x1b,0xfa,0x1b,0xfa,0x1b,0xfa,0x1b,0xfa,0x1b,0xfa,0x1b,
+0xfa,0x1b,0xfa,0x1b,0xfa,0x1b,0xfa,0x1b,0xfa,0x1b,0xfa,0x1b,0xfa,0x1b,0xfa,0x1b,
+0xfa,0x1b,0xfa,0x1b,0xfa,0x1b,0x64,0x1b,0x65,0x1b,0xfa,0x1b,0xde,0x1b,0xff,0x1b,
+
+0xff,0x1b,0xe2,0x1b,0xd8,0x1b,0xd8,0x1b,0x66,0x1b,0x67,0x1b,0x68,0x1b,0x69,0x1b,
+0x6a,0x1b,0xd8,0x1b,0xd8,0x1b,0xd8,0x1b,0xd8,0x1b,0x6b,0x1b,0x6c,0x1b,0x6d,0x1b,
+0x6e,0x1b,0xd8,0x1b,0xd8,0x1b,0x6f,0x1b,0xd8,0x1b,0xd8,0x1b,0xd8,0x1b,0xd8,0x1b,
+0xd8,0x1b,0x70,0x1b,0x71,0x1b,0x72,0x1b,0xd8,0x1b,0xd8,0x1b,0xde,0x1b,0xff,0x1b,
+
+0xff,0x1b,0xe2,0x1b,0xd9,0x1b,0xd9,0x1b,0x73,0x1b,0x74,0x1b,0x75,0x1b,0x76,0x1b,
+0x77,0x1b,0x78,0x1b,0x79,0x1b,0x7a,0x1b,0x7b,0x1b,0x7c,0x1b,0x7d,0x1b,0x7e,0x1b,
+0x7f,0x1b,0x80,0x1b,0x81,0x1b,0x82,0x1b,0x83,0x1b,0x84,0x1b,0x85,0x1b,0xd9,0x1b,
+0xd9,0x1b,0x86,0x1b,0x87,0x1b,0x88,0x1b,0x89,0x1b,0xd9,0x1b,0xde,0x1b,0xff,0x1b,
+
+0xff,0x1b,0xe2,0x1b,0xfa,0x1b,0xfa,0x1b,0x8a,0x1b,0x8b,0x1b,0x8c,0x1b,0x8d,0x1b,
+0x8e,0x1b,0x8f,0x1b,0x90,0x1b,0x91,0x1b,0x92,0x1b,0x93,0x1b,0x94,0x1b,0x95,0x1b,
+0x96,0x1b,0x97,0x1b,0x98,0x1b,0x99,0x1b,0x9a,0x1b,0x9b,0x1b,0x9c,0x1b,0xfa,0x1b,
+0xfa,0x1b,0x9d,0x1b,0x9e,0x1b,0x9f,0x1b,0xa0,0x1b,0xfa,0x1b,0xde,0x1b,0xff,0x1b,
+
+0xff,0x1b,0xe2,0x1b,0xfa,0x1b,0xa1,0x1b,0xa2,0x1b,0xa3,0x1b,0xa4,0x1b,0xa5,0x1b,
+0xa6,0x1b,0xa7,0x1b,0xa8,0x1b,0xa9,0x1b,0xaa,0x1b,0xab,0x1b,0xac,0x1b,0xad,0x1b,
+0xae,0x1b,0xaf,0x1b,0xb0,0x1b,0xb1,0x1b,0xb2,0x1b,0xb3,0x1b,0xb4,0x1b,0xb5,0x1b,
+0xb6,0x1b,0xb7,0x1b,0xb8,0x1b,0xb9,0x1b,0xba,0x1b,0xfa,0x1b,0xde,0x1b,0xff,0x1b,
+
+0xff,0x1b,0xe2,0x1b,0xda,0x1b,0xbb,0x1b,0xbc,0x1b,0xbd,0x1b,0xbe,0x1b,0xbf,0x1b,
+0xc0,0x1b,0xc1,0x1b,0xc2,0x1b,0xc3,0x1b,0xc4,0x1b,0xc5,0x1b,0xc6,0x1b,0xc7,0x1b,
+0xc8,0x1b,0xc9,0x1b,0xca,0x1b,0xcb,0x1b,0xcc,0x1b,0xcd,0x1b,0xce,0x1b,0xda,0x1b,
+0xcf,0x1b,0xd0,0x1b,0xd1,0x1b,0xd2,0x1b,0xda,0x1b,0xda,0x1b,0xde,0x1b,0xff,0x1b,
+
+0xff,0x1b,0xe2,0x1b,0xd8,0x1b,0xd8,0x1b,0xd8,0x1b,0xd8,0x1b,0xd8,0x1b,0xd8,0x1b,
+0xd3,0x1b,0xd4,0x1b,0xd5,0x1b,0xd8,0x1b,0xd8,0x1b,0xd8,0x1b,0xd8,0x1b,0xd8,0x1b,
+0xd8,0x1b,0xd8,0x1b,0xd8,0x1b,0xd8,0x1b,0xd8,0x1b,0xd8,0x1b,0xd8,0x1b,0xd8,0x1b,
+0xd8,0x1b,0xd8,0x1b,0xd8,0x1b,0xd8,0x1b,0xd8,0x1b,0xd8,0x1b,0xde,0x1b,0xff,0x1b,
+
+0xff,0x1b,0xe2,0x1b,0xfa,0x1b,0xfa,0x1b,0xfa,0x1b,0xfa,0x1b,0xfa,0x1b,0xfa,0x1b,
+0xd6,0x1b,0xd7,0x1b,0xfa,0x1b,0xfa,0x1b,0xfa,0x1b,0xfa,0x1b,0xfa,0x1b,0xfa,0x1b,
+0xfa,0x1b,0xfa,0x1b,0xfa,0x1b,0xfa,0x1b,0xfa,0x1b,0xfa,0x1b,0xfa,0x1b,0xfa,0x1b,
+0xfa,0x1b,0xfa,0x1b,0xfa,0x1b,0xfa,0x1b,0xfa,0x1b,0xfa,0x1b,0xde,0x1b,0xff,0x1b,
+
+0xff,0x1b,0xe1,0x1b,0xe0,0x1b,0xe0,0x1b,0xe0,0x1b,0xe0,0x1b,0xe0,0x1b,0xe0,0x1b,
+0xe0,0x1b,0xe0,0x1b,0xe0,0x1b,0xe0,0x1b,0xe0,0x1b,0xe0,0x1b,0xe0,0x1b,0xe0,0x1b,
+0xe0,0x1b,0xe0,0x1b,0xe0,0x1b,0xe0,0x1b,0xe0,0x1b,0xe0,0x1b,0xe0,0x1b,0xe0,0x1b,
+0xe0,0x1b,0xe0,0x1b,0xe0,0x1b,0xe0,0x1b,0xe0,0x1b,0xe0,0x1b,0xdf,0x1b,0xff,0x1b,
+
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xe3,0x1b,0xe4,0x1b,0xe5,0x1b,0xe6,0x1b,0xe7,0x1b,0xe8,0x1b,
+0xe9,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xea,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xeb,0x1b,0xec,0x1b,0xed,0x1b,0xee,0x1b,0xef,0x1b,0xf0,0x1b,
+0xf1,0x1b,0xf2,0x1b,0xf3,0x1b,0xf4,0x1b,0xf5,0x1b,0xf6,0x1b,0xf7,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,0xff,0x1b,
+
+0x14,0xf9,0x15,0xf9,0x15,0xf9,0x15,0xf9,0x15,0xf9,0x15,0xf9,0x15,0xf9,0x15,0xf9,
+0x15,0xf9,0x15,0xf9,0x15,0xf9,0x15,0xf9,0x15,0xf9,0x15,0xf9,0x15,0xf9,0x15,0xf9,
+0x15,0xf9,0x15,0xf9,0x15,0xf9,0x15,0xf9,0x16,0xf9,0x14,0xf9,0x15,0xf9,0x15,0xf9,
+0x15,0xf9,0x15,0xf9,0x15,0xf9,0x15,0xf9,0x15,0xf9,0x15,0xf9,0x15,0xf9,0x16,0xf9,
+
+0x1b,0xf9,0xff,0xf9,0xff,0xf9,0xff,0xf9,0xff,0xf9,0xff,0xf9,0xff,0xf9,0xff,0xf9,
+0xff,0xf9,0xff,0xf9,0xff,0xf9,0xff,0xf9,0xff,0xf9,0xff,0xf9,0xff,0xf9,0xff,0xf9,
+0xff,0xf9,0xff,0xf9,0xff,0xf9,0xff,0xf9,0x17,0xf9,0x1b,0xf9,0x1c,0xf9,0x1d,0xf9,
+0x1e,0xf9,0x1f,0xf9,0x20,0xf9,0xff,0xf9,0xff,0xf9,0xff,0xf9,0x00,0xf9,0x17,0xf9,
+
+0x1b,0xf9,0xff,0xf9,0xff,0xf9,0xff,0xf9,0xff,0xf9,0x26,0xf9,0x27,0xf9,0x28,0xf9,
+0x29,0xf9,0x2a,0xf9,0x2b,0xf9,0x2c,0xf9,0x2d,0xf9,0x2e,0xf9,0xff,0xf9,0x2f,0xf9,
+0x2f,0xf9,0xff,0xf9,0xff,0xf9,0xff,0xf9,0x17,0xf9,0x1b,0xf9,0x21,0xf9,0x22,0xf9,
+0x23,0xf9,0x24,0xf9,0x25,0xf9,0xff,0xf9,0xff,0xf9,0xff,0xf9,0x01,0xf9,0x17,0xf9,
+
+0x1a,0xf9,0x19,0xf9,0x19,0xf9,0x19,0xf9,0x19,0xf9,0x19,0xf9,0x19,0xf9,0x19,0xf9,
+0x19,0xf9,0x19,0xf9,0x19,0xf9,0x19,0xf9,0x19,0xf9,0x19,0xf9,0x19,0xf9,0x19,0xf9,
+0x19,0xf9,0x19,0xf9,0x19,0xf9,0x19,0xf9,0x18,0xf9,0x1a,0xf9,0x19,0xf9,0x19,0xf9,
+0x19,0xf9,0x19,0xf9,0x19,0xf9,0x19,0xf9,0x19,0xf9,0x19,0xf9,0x19,0xf9,0x18,0xf9,
+
+0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,
+0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,
+0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,
+0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,0xf8,
+  };
+  for(unsigned addr = 0x9040; addr <= 0x97bf; addr++) {
+    vram[addr & 0x07ff] = default_vram[(addr & 0x07ff) - 0x40];
+  }
+}
+
+void PC10ArcadeBoard::update_video() {
+  uint16 addr;
+  unsigned tile_id;
+  uint8 y;
+  uint8 x;
+  uint8 byte;
+  unsigned color;
+  for(unsigned tile_y = 1; tile_y < 31; tile_y++) {
+    for(unsigned tile_x = 0; tile_x < 32; tile_x++) {
+      addr = tile_y * 64 + tile_x * 2;
+      tile_id = ((vram[addr + 0] & 0xff) << 0) + ((vram[addr + 1] & 0x07) << 8);
+      for(unsigned pixel_y = 0; pixel_y < 8; pixel_y++) {
+        y = ((tile_y - 1) << 3) + pixel_y;
+        for(unsigned pixel_x = 0; pixel_x < 8; pixel_x++) {
+          x = (tile_x << 3) + pixel_x;
+          color = vram[tile_y * 64 + tile_x * 2 + 1] & 0xf8;
+          for(unsigned plane = 0; plane < 3; plane++) {
+            byte = chrrom[(plane << 13) + (tile_id << 3) + pixel_y];
+            color += ((byte >> (7 - pixel_x)) & 1) << plane;
+          }
+          video_output[y * 256 + x] = color;
+        }
+      }
+    }
+  }
+}
+
+#endif
diff -Nru higan/fc/arcade/vs/serialization.cpp higan/fc/arcade/vs/serialization.cpp
--- higan/fc/arcade/vs/serialization.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/fc/arcade/vs/serialization.cpp	2015-09-16 13:08:13.514563364 +0900
@@ -0,0 +1,10 @@
+#ifdef VS_ARCADE_BOARD_CPP
+
+void VSArcadeBoard::serialize(serializer& s) {
+  s.array(ram);
+
+  s.integer(swap_controllers);
+  s.integer(dip);
+}
+
+#endif
diff -Nru higan/fc/arcade/vs/vs.cpp higan/fc/arcade/vs/vs.cpp
--- higan/fc/arcade/vs/vs.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/fc/arcade/vs/vs.cpp	2015-09-16 13:08:13.514563364 +0900
@@ -0,0 +1,76 @@
+#include <fc/fc.hpp>
+
+#define VS_ARCADE_BOARD_CPP
+namespace Famicom {
+
+VSArcadeBoard vsarcadeboard;
+
+#include "serialization.cpp"
+
+void VSArcadeBoard::init() {
+}
+
+void VSArcadeBoard::load() {
+}
+
+void VSArcadeBoard::unload() {
+}
+
+void VSArcadeBoard::power() {
+}
+
+void VSArcadeBoard::reset() {
+}
+
+void VSArcadeBoard::set_dip(uint16 dip) {
+  this->dip = dip;
+}
+
+uint8 VSArcadeBoard::read(uint16 addr) {
+  if(addr == 0x4016) return r4016();
+  if(addr == 0x4017) return r4017();
+  if((addr & 0xe020) == 0x4020) return r4020();
+  if(addr >= 0x6000 && addr <= 0x7fff) return ram[addr & 0x07ff];
+}
+
+void VSArcadeBoard::write(uint16 addr, uint8 data) {
+  if(addr == 0x4016) w4016(data);
+  if((addr & 0xe020) == 0x4020) w4020(data);
+  if(addr >= 0x6000 && addr <= 0x7fff) ram[addr & 0x07ff] = data;
+}
+
+uint8 VSArcadeBoard::r4016() {
+  uint8 data = 0x80; // 0x00 for slave CPU, 0x80 for master CPU
+  if(!swap_controllers) data |= input.port1->data() & 0x03;
+  else                  data |= input.port2->data() & 0x03;
+  data |= input.expansion->data1(); // buttons 1 and 3
+  data |= (dip & 0x03) << 3;
+  data |= input.expansion->data() << 2; // Service button and coins
+  return data;
+}
+
+uint8 VSArcadeBoard::r4017() {
+  uint8 data = 0x00;
+  if(!swap_controllers) data |= input.port2->data() & 0x03;
+  else                  data |= input.port1->data() & 0x03;
+  data |= input.expansion->data2(); // buttons 2 and 4
+  data |= dip & 0xfc;
+  return data;
+}
+
+uint8 VSArcadeBoard::r4020() {
+  write(0x4020, cpu.mdr());
+  return cpu.mdr();
+}
+
+void VSArcadeBoard::w4016(uint8 data) {
+  input.port1->latch(data & 1);
+  input.port2->latch(data & 1);
+  input.expansion->latch(data & 1);
+}
+
+void VSArcadeBoard::w4020(uint8 data) {
+  // increment coin counter
+}
+
+}
diff -Nru higan/fc/arcade/vs/vs.hpp higan/fc/arcade/vs/vs.hpp
--- higan/fc/arcade/vs/vs.hpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/fc/arcade/vs/vs.hpp	2015-09-16 13:08:13.513563364 +0900
@@ -0,0 +1,27 @@
+struct VSArcadeBoard {
+  uint8 ram[2048];
+
+  bool swap_controllers;
+  uint16 dip; // 16-bit for DualSystem games
+
+  void init();
+  void load();
+  void unload();
+  void power();
+  void reset();
+
+  void set_dip(uint16 dip);
+  uint8 read(uint16 addr);
+  void write(uint16 addr, uint8 data);
+
+  void serialize(serializer& s);
+
+private:
+  uint8 r4016();
+  uint8 r4017();
+  uint8 r4020();
+  void w4016(uint8 data);
+  void w4020(uint8 data);
+};
+
+extern VSArcadeBoard vsarcadeboard;
diff -Nru higan/fc/cartridge/board/bandai-74-161-02-74.cpp higan/fc/cartridge/board/bandai-74-161-02-74.cpp
--- higan/fc/cartridge/board/bandai-74-161-02-74.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/fc/cartridge/board/bandai-74-161-02-74.cpp	2015-09-16 13:08:13.529563365 +0900
@@ -0,0 +1,82 @@
+//BANDAI-74*161/02/74
+
+struct Bandai74_161_02_74 : Board {
+
+uint2 prg_bank;
+bool chr_plane;
+uint2 chr_bank;
+uint16 chr_abus;
+
+void enter() {
+  while(true) {
+    if(scheduler.sync == Scheduler::SynchronizeMode::All) {
+      scheduler.exit(Scheduler::ExitReason::SynchronizeEvent);
+    }
+
+    chr_abus_test(ppu.status.chr_abus);
+    tick();
+  }
+}
+
+uint8 prg_read(unsigned addr) {
+  if(addr & 0x8000) return read(prgrom, (prg_bank << 15) | (addr & 0x7fff));
+  return cpu.mdr();
+}
+
+void prg_write(unsigned addr, uint8 data) {
+  if(addr & 0x8000) {
+    data &= prg_read(addr);
+    prg_bank = (data & 0x03) >> 0;
+    chr_plane = (data & 0x04) >> 2;
+  }
+}
+
+unsigned chr_addr(unsigned addr) {
+  switch(addr & 0x1000) {
+  case 0x0000: return (addr & 0x0fff) | (chr_plane << 14) | (chr_bank << 12);
+  case 0x1000: return (addr & 0x0fff) | (chr_plane << 14);
+  }
+}
+
+uint8 chr_read(unsigned addr) {
+  chr_abus_test(addr);
+  if(addr & 0x2000) return ppu.ciram_read(addr & 0x07ff);
+  return Board::chr_read(chr_addr(addr));
+}
+
+void chr_write(unsigned addr, uint8 data) {
+  chr_abus_test(addr);
+  if(addr & 0x2000) return ppu.ciram_write(addr & 0x07ff, data);
+  Board::chr_write(chr_addr(addr), data);
+}
+
+void chr_abus_test(unsigned addr) {
+  if((addr & 0x3000) != (chr_abus & 0x3000) && (addr & 0x3000) == 0x2000) {
+    // NOR logic reverses bank numbers
+    chr_bank = (((addr & 0x0300) ^ 0x0300) >> 8);
+  }
+  chr_abus = addr & 0x3000;
+}
+
+void power() {
+}
+
+void reset() {
+  prg_bank = 0;
+  chr_plane = 0;
+  chr_bank = 0;
+  chr_abus = 0;
+}
+
+void serialize(serializer& s) {
+  Board::serialize(s);
+  s.integer(prg_bank);
+  s.integer(chr_plane);
+  s.integer(chr_bank);
+  s.integer(chr_abus);
+}
+
+Bandai74_161_02_74(Markup::Node& cartridge) : Board(cartridge) {
+}
+
+};
diff -Nru higan/fc/cartridge/board/bandai-74-161-161-32.cpp higan/fc/cartridge/board/bandai-74-161-161-32.cpp
--- higan/fc/cartridge/board/bandai-74-161-161-32.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/fc/cartridge/board/bandai-74-161-161-32.cpp	2015-09-16 13:08:13.532563365 +0900
@@ -0,0 +1,63 @@
+//BANDAI-74*161/161/32
+
+struct Bandai74_161_161_32 : Board {
+
+struct Settings {
+  bool mirror;  //0 = vertical, 1 = horizontal
+} settings;
+
+uint4 prg_bank;
+uint4 chr_bank;
+
+uint8 prg_read(unsigned addr) {
+  if((addr & 0x8000) == 0x0000) return cpu.mdr();
+  if((addr & 0xc000) == 0x8000) return read(prgrom, (prg_bank << 14) | (addr & 0x3fff));
+  else                          return read(prgrom, (    0x0f << 14) | (addr & 0x3fff));
+}
+
+void prg_write(unsigned addr, uint8 data) {
+  if(addr & 0x8000) {
+    //TODO: check for bus conflicts
+    data &= prg_read(addr);
+    prg_bank = (data & 0xf0) >> 4;
+    chr_bank = (data & 0x0f) >> 0;
+  }
+}
+
+uint8 chr_read(unsigned addr) {
+  if(addr & 0x2000) {
+    if(settings.mirror == 1) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    return ppu.ciram_read(addr);
+  }
+  addr = (chr_bank * 0x2000) + (addr & 0x1fff);
+  return Board::chr_read(addr);
+}
+
+void chr_write(unsigned addr, uint8 data) {
+  if(addr & 0x2000) {
+    if(settings.mirror == 1) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    return ppu.ciram_write(addr, data);
+  }
+  addr = (chr_bank * 0x2000) + (addr & 0x1fff);
+  Board::chr_write(addr, data);
+}
+
+void power() {
+}
+
+void reset() {
+  prg_bank = 0;
+  chr_bank = 0;
+}
+
+void serialize(serializer& s) {
+  Board::serialize(s);
+  s.integer(prg_bank);
+  s.integer(chr_bank);
+}
+
+Bandai74_161_161_32(Markup::Node& cartridge) : Board(cartridge) {
+  settings.mirror = cartridge["mirror/mode"].text() == "horizontal";
+}
+
+};
diff -Nru higan/fc/cartridge/board/bandai-fcg.cpp higan/fc/cartridge/board/bandai-fcg.cpp
--- higan/fc/cartridge/board/bandai-fcg.cpp	2015-09-16 02:20:06.371574580 +0900
+++ higan/fc/cartridge/board/bandai-fcg.cpp	2015-09-16 13:08:13.531563365 +0900
@@ -1,117 +1,100 @@
 //BANDAI-FCG
+//BANDAI-FCG-1
+//BANDAI-FCG-2
+//BANDAI-JUMP2
+//BANDAI-LZ93D50
 
 struct BandaiFCG : Board {
 
-uint8 chr_bank[8];
-uint8 prg_bank;
-uint2 mirror;
-bool irq_counter_enable;
-uint16 irq_counter;
-uint16 irq_latch;
-
-void main() {
-  while(true) {
-    if(scheduler.sync == Scheduler::SynchronizeMode::All) {
-      scheduler.exit(Scheduler::ExitReason::SynchronizeEvent);
-    }
+enum class Revision : unsigned {
+  FCGAll,
+  FCG1,
+  FCG2,
+  JUMP2,
+  LZ93D50,
+} revision;
 
-    if(irq_counter_enable) {
-      if(--irq_counter == 0xffff) {
-        cpu.set_irq_line(1);
-        irq_counter_enable = false;
-      }
-    }
+FCG fcg;
 
-    tick();
-  }
-}
-
-unsigned ciram_addr(unsigned addr) const {
-  switch(mirror) {
-  case 0: return ((addr & 0x0400) >> 0) | (addr & 0x03ff);
-  case 1: return ((addr & 0x0800) >> 1) | (addr & 0x03ff);
-  case 2: return 0x0000 | (addr & 0x03ff);
-  case 3: return 0x0400 | (addr & 0x03ff);
-  }
+void enter() {
+  fcg.enter();
 }
 
 uint8 prg_read(unsigned addr) {
-  if(addr & 0x8000) {
-    bool region = addr & 0x4000;
-    unsigned bank = (region == 0 ? prg_bank : 0x0f);
-    return prgrom.read((bank << 14) | (addr & 0x3fff));
+  if((addr & 0xe000) == 0x6000) {
+    switch(revision) {
+    case Revision::LZ93D50:
+      //TODO: serial EEPROM support
+      return 0x00 | (cpu.mdr() & 0xef);
+    case Revision::JUMP2:
+      return fcg.eeprom_i2c_scl ? fcg.ram_read(addr) : cpu.mdr();
+    }
+  }
+  if((addr & 0x8000) == 0x8000) {
+    if(revision != Revision::JUMP2)
+      return read(prgrom, fcg.prg_addr(addr));
+    else
+      return read(prgrom, fcg.prg_addr(addr) | ((fcg.chr_bank[(ppu.status.chr_abus >> 10) & 3] & 1) << 18));
   }
   return cpu.mdr();
 }
 
 void prg_write(unsigned addr, uint8 data) {
-  if(addr >= 0x6000) {
-    switch(addr & 15) {
-    case 0x00: case 0x01: case 0x02: case 0x03:
-    case 0x04: case 0x05: case 0x06: case 0x07:
-      chr_bank[addr & 7] = data;
-      break;
-    case 0x08:
-      prg_bank = data & 0x0f;
-      break;
-    case 0x09:
-      mirror = data & 0x03;
-      break;
-    case 0x0a:
-      cpu.set_irq_line(0);
-      irq_counter_enable = data & 0x01;
-      irq_counter = irq_latch;
-      break;
-    case 0x0b:
-      irq_latch = (irq_latch & 0xff00) | (data << 0);
-      break;
-    case 0x0c:
-      irq_latch = (irq_latch & 0x00ff) | (data << 8);
-      break;
-    case 0x0d:
+  if((addr & 0xe000) == 0x6000) {
+    switch(revision) {
+    case Revision::FCGAll:
+    case Revision::FCG1:
+    case Revision::FCG2:
+      return fcg.reg_write(addr, data);
+    case Revision::LZ93D50:
       //TODO: serial EEPROM support
       break;
+    case Revision::JUMP2:
+      if(fcg.eeprom_i2c_scl) return fcg.ram_write(addr, data);
+      else                   break;
+    }
+  }
+  if((addr & 0x8000) == 0x8000) {
+    switch(revision) {
+    case Revision::FCGAll:
+    case Revision::LZ93D50:
+    case Revision::JUMP2:
+      return fcg.reg_write(addr, data);
     }
   }
 }
 
 uint8 chr_read(unsigned addr) {
-  if(addr & 0x2000) return ppu.ciram_read(ciram_addr(addr));
-  addr = (chr_bank[addr >> 10] << 10) | (addr & 0x03ff);
-  return Board::chr_read(addr);
+  if(addr & 0x2000) return ppu.ciram_read(fcg.ciram_addr(addr));
+  if(chrrom.size()) return Board::chr_read(fcg.chr_addr(addr));
+  if(chrram.size()) return Board::chr_read(addr);
 }
 
 void chr_write(unsigned addr, uint8 data) {
-  if(addr & 0x2000) return ppu.ciram_write(ciram_addr(addr), data);
-  addr = (chr_bank[addr >> 10] << 10) | (addr & 0x03ff);
-  return Board::chr_write(addr, data);
+  if(addr & 0x2000) return ppu.ciram_write(fcg.ciram_addr(addr), data);
+  if(chrram.size()) Board::chr_write(addr, data);
 }
 
 void power() {
-  reset();
+  fcg.power();
 }
 
 void reset() {
-  for(auto &n : chr_bank) n = 0;
-  prg_bank = 0;
-  mirror = 0;
-  irq_counter_enable = 0;
-  irq_counter = 0;
-  irq_latch = 0;
+  fcg.reset();
 }
 
 void serialize(serializer& s) {
   Board::serialize(s);
-
-  s.array(chr_bank);
-  s.integer(prg_bank);
-  s.integer(mirror);
-  s.integer(irq_counter_enable);
-  s.integer(irq_counter);
-  s.integer(irq_latch);
+  fcg.serialize(s);
 }
 
-BandaiFCG(Markup::Node& document) : Board(document) {
+BandaiFCG(Markup::Node& cartridge) : Board(cartridge), fcg(*this, cartridge) {
+  string type = cartridge["board/type"].text();
+  revision = Revision::FCGAll;
+  if(type.match("*FCG-1*"  )) revision = Revision::FCG1;
+  if(type.match("*FCG-2*"  )) revision = Revision::FCG2;
+  if(type.match("*JUMP2*"  )) revision = Revision::JUMP2;
+  if(type.match("*LZ93D50*")) revision = Revision::LZ93D50;
 }
 
 };
diff -Nru higan/fc/cartridge/board/board.cpp higan/fc/cartridge/board/board.cpp
--- higan/fc/cartridge/board/board.cpp	2015-09-16 02:20:06.371574580 +0900
+++ higan/fc/cartridge/board/board.cpp	2015-09-16 13:08:13.529563365 +0900
@@ -1,30 +1,58 @@
+#include "bandai-74-161-02-74.cpp"
+#include "bandai-74-161-161-32.cpp"
 #include "bandai-fcg.cpp"
+#include "irem-74-161-161-21-138.cpp"
+#include "irem-g101.cpp"
+#include "irem-h3001.cpp"
+#include "irem-holydiver.cpp"
+#include "irem-tam-s1.cpp"
+#include "jaleco-jf-0x.cpp"
+#include "jaleco-jf-16.cpp"
+#include "jaleco-jf-2x.cpp"
 #include "konami-vrc1.cpp"
 #include "konami-vrc2.cpp"
 #include "konami-vrc3.cpp"
 #include "konami-vrc4.cpp"
 #include "konami-vrc6.cpp"
 #include "konami-vrc7.cpp"
+#include "namco-163.cpp"
+#include "namco-34xx.cpp"
 #include "nes-axrom.cpp"
 #include "nes-bnrom.cpp"
-#include "nes-cnrom.cpp"
+#include "nes-cxrom.cpp"
+#include "nes-event.cpp"
 #include "nes-exrom.cpp"
 #include "nes-fxrom.cpp"
 #include "nes-gxrom.cpp"
 #include "nes-hkrom.cpp"
 #include "nes-nrom.cpp"
 #include "nes-pxrom.cpp"
+#include "nes-qj.cpp"
 #include "nes-sxrom.cpp"
 #include "nes-txrom.cpp"
 #include "nes-uxrom.cpp"
+#include "pal-zz.cpp"
+#include "sunsoft-4.cpp"
 #include "sunsoft-5b.cpp"
+#include "taito-tc.cpp"
+#include "fds.cpp"
+#include "vs.cpp"
+
+// Unlicensed board definitions; feel free to remove
+#include "unlicensed/camerica.cpp"
+#include "unlicensed/colordreams-74-377.cpp"
+#include "unlicensed/mlt-action52.cpp"
+#include "unlicensed/nina.cpp"
+// Homebrew board definitions; feel free to remove
+#include "unlicensed/noconflicts-cnrom.cpp"
+#include "unlicensed/single-chip.cpp"
 
-uint8 Board::Memory::read(unsigned addr) const {
-  return data[mirror(addr, size)];
+uint8 Board::read(MappedRAM& memory, unsigned addr) {
+  return memory.read(mirror(addr, memory.size()));
 }
 
-void Board::Memory::write(unsigned addr, uint8 byte) {
-  if(writable) data[mirror(addr, size)] = byte;
+void Board::write(MappedRAM& memory, unsigned addr, uint8 byte) {
+  memory.write(mirror(addr, memory.size()), byte);
 }
 
 unsigned Board::mirror(unsigned addr, unsigned size) {
@@ -45,30 +73,29 @@
   return base;
 }
 
-void Board::main() {
+void Board::enter() {
   while(true) {
     if(scheduler.sync == Scheduler::SynchronizeMode::All) {
       scheduler.exit(Scheduler::ExitReason::SynchronizeEvent);
     }
 
-    cartridge.clock += 12 * 4095;
     tick();
   }
 }
 
 void Board::tick() {
-  cartridge.clock += 12;
+  cartridge.clock += (system.region() == System::Region::NTSC ? 12 : 16);
   if(cartridge.clock >= 0 && scheduler.sync != Scheduler::SynchronizeMode::All) co_switch(cpu.thread);
 }
 
 uint8 Board::chr_read(unsigned addr) {
-  if(chrram.size) return chrram.data[mirror(addr, chrram.size)];
-  if(chrrom.size) return chrrom.data[mirror(addr, chrrom.size)];
-  return 0u;
+  if(chrram.size()) return read(chrram, addr);
+  if(chrrom.size()) return read(chrrom, addr);
+  return ppu.status.mdr;
 }
 
 void Board::chr_write(unsigned addr, uint8 data) {
-  if(chrram.size) chrram.data[mirror(addr, chrram.size)] = data;
+  if(chrram.size()) write(chrram, addr, data);
 }
 
 void Board::power() {
@@ -78,135 +105,238 @@
 }
 
 void Board::serialize(serializer& s) {
-  if(prgram.size) s.array(prgram.data, prgram.size);
-  if(chrram.size) s.array(chrram.data, chrram.size);
+  if(prgram.size()) s.array(prgram.data(), prgram.size());
+  if(chrram.size()) s.array(chrram.data(), chrram.size());
 }
 
-Board::Board(Markup::Node& document) {
-  cartridge.board = this;
-  auto cartridge = document["cartridge"];
-
-  information.type = cartridge["board/type"].text();
-  information.battery = (bool)cartridge["prg/ram/name"];
-
-  auto prom = cartridge["prg/rom"];
-  auto pram = cartridge["prg/ram"];
-  auto crom = cartridge["chr/rom"];
-  auto cram = cartridge["chr/ram"];
-
-  prgrom.size = prom["size"].decimal();
-  prgram.size = pram["size"].decimal();
-  chrrom.size = crom["size"].decimal();
-  chrram.size = cram["size"].decimal();
-
-  if(prgrom.size) prgrom.data = new uint8[prgrom.size]();
-  if(prgram.size) prgram.data = new uint8[prgram.size]();
-  if(chrrom.size) chrrom.data = new uint8[chrrom.size]();
-  if(chrram.size) chrram.data = new uint8[chrram.size]();
-
-  if(auto name = prom["name"].text()) interface->loadRequest(ID::ProgramROM, name, true);
-  if(auto name = pram["name"].text()) interface->loadRequest(ID::ProgramRAM, name, false);
-  if(auto name = crom["name"].text()) interface->loadRequest(ID::CharacterROM, name, true);
-  if(auto name = cram["name"].text()) interface->loadRequest(ID::CharacterRAM, name, false);
-
-  if(auto name = pram["name"].text()) Famicom::cartridge.memory.append({ID::ProgramRAM, name});
-  if(auto name = cram["name"].text()) Famicom::cartridge.memory.append({ID::CharacterRAM, name});
-
-  prgram.writable = true;
-  chrram.writable = true;
+Board::Board(Markup::Node& cartridge) {
+  Famicom::cartridge.board = this;
 }
 
 Board::~Board() {
 }
 
-Board* Board::load(string manifest) {
-  auto document = BML::unserialize(manifest);
-  cartridge.information.title = document["information/title"].text();
-
-  string type = document["cartridge/board/type"].text();
-
-  if(type == "BANDAI-FCG"  ) return new BandaiFCG(document);
-
-  if(type == "KONAMI-VRC-1") return new KonamiVRC1(document);
-  if(type == "KONAMI-VRC-2") return new KonamiVRC2(document);
-  if(type == "KONAMI-VRC-3") return new KonamiVRC3(document);
-  if(type == "KONAMI-VRC-4") return new KonamiVRC4(document);
-  if(type == "KONAMI-VRC-6") return new KonamiVRC6(document);
-  if(type == "KONAMI-VRC-7") return new KonamiVRC7(document);
-
-  if(type == "NES-AMROM"   ) return new NES_AxROM(document);
-  if(type == "NES-ANROM"   ) return new NES_AxROM(document);
-  if(type == "NES-AN1ROM"  ) return new NES_AxROM(document);
-  if(type == "NES-AOROM"   ) return new NES_AxROM(document);
-
-  if(type == "NES-BNROM"   ) return new NES_BNROM(document);
-
-  if(type == "NES-CNROM"   ) return new NES_CNROM(document);
-
-  if(type == "NES-EKROM"   ) return new NES_ExROM(document);
-  if(type == "NES-ELROM"   ) return new NES_ExROM(document);
-  if(type == "NES-ETROM"   ) return new NES_ExROM(document);
-  if(type == "NES-EWROM"   ) return new NES_ExROM(document);
-
-  if(type == "NES-FJROM"   ) return new NES_FxROM(document);
-  if(type == "NES-FKROM"   ) return new NES_FxROM(document);
-
-  if(type == "NES-GNROM"   ) return new NES_GxROM(document);
-  if(type == "NES-MHROM"   ) return new NES_GxROM(document);
-
-  if(type == "NES-HKROM"   ) return new NES_HKROM(document);
-
-  if(type == "NES-NROM"    ) return new NES_NROM(document);
-  if(type == "NES-NROM-128") return new NES_NROM(document);
-  if(type == "NES-NROM-256") return new NES_NROM(document);
-
-  if(type == "NES-PEEOROM" ) return new NES_PxROM(document);
-  if(type == "NES-PNROM"   ) return new NES_PxROM(document);
-
-  if(type == "NES-SAROM"   ) return new NES_SxROM(document);
-  if(type == "NES-SBROM"   ) return new NES_SxROM(document);
-  if(type == "NES-SCROM"   ) return new NES_SxROM(document);
-  if(type == "NES-SC1ROM"  ) return new NES_SxROM(document);
-  if(type == "NES-SEROM"   ) return new NES_SxROM(document);
-  if(type == "NES-SFROM"   ) return new NES_SxROM(document);
-  if(type == "NES-SFEXPROM") return new NES_SxROM(document);
-  if(type == "NES-SGROM"   ) return new NES_SxROM(document);
-  if(type == "NES-SHROM"   ) return new NES_SxROM(document);
-  if(type == "NES-SH1ROM"  ) return new NES_SxROM(document);
-  if(type == "NES-SIROM"   ) return new NES_SxROM(document);
-  if(type == "NES-SJROM"   ) return new NES_SxROM(document);
-  if(type == "NES-SKROM"   ) return new NES_SxROM(document);
-  if(type == "NES-SLROM"   ) return new NES_SxROM(document);
-  if(type == "NES-SL1ROM"  ) return new NES_SxROM(document);
-  if(type == "NES-SL2ROM"  ) return new NES_SxROM(document);
-  if(type == "NES-SL3ROM"  ) return new NES_SxROM(document);
-  if(type == "NES-SLRROM"  ) return new NES_SxROM(document);
-  if(type == "NES-SMROM"   ) return new NES_SxROM(document);
-  if(type == "NES-SNROM"   ) return new NES_SxROM(document);
-  if(type == "NES-SOROM"   ) return new NES_SxROM(document);
-  if(type == "NES-SUROM"   ) return new NES_SxROM(document);
-  if(type == "NES-SXROM"   ) return new NES_SxROM(document);
-
-  if(type == "NES-TBROM"   ) return new NES_TxROM(document);
-  if(type == "NES-TEROM"   ) return new NES_TxROM(document);
-  if(type == "NES-TFROM"   ) return new NES_TxROM(document);
-  if(type == "NES-TGROM"   ) return new NES_TxROM(document);
-  if(type == "NES-TKROM"   ) return new NES_TxROM(document);
-  if(type == "NES-TKSROM"  ) return new NES_TxROM(document);
-  if(type == "NES-TLROM"   ) return new NES_TxROM(document);
-  if(type == "NES-TL1ROM"  ) return new NES_TxROM(document);
-  if(type == "NES-TL2ROM"  ) return new NES_TxROM(document);
-  if(type == "NES-TLSROM"  ) return new NES_TxROM(document);
-  if(type == "NES-TNROM"   ) return new NES_TxROM(document);
-  if(type == "NES-TQROM"   ) return new NES_TxROM(document);
-  if(type == "NES-TR1ROM"  ) return new NES_TxROM(document);
-  if(type == "NES-TSROM"   ) return new NES_TxROM(document);
-  if(type == "NES-TVROM"   ) return new NES_TxROM(document);
+Board* Board::load(Markup::Node cartridge) {
+  if(auto vs_node = cartridge["vs"]) return new VS(vs_node);
+  string type = cartridge["board/type"].text();
+
+  if(substr(type,0,4) == "HVC-"
+  || substr(type,0,4) == "NES-"
+  || substr(type,0,4) == "PAL-") {
+    type = substr(type,4);
+    if(type == "AMROM"   ) return new NES_AxROM(cartridge);
+    if(type == "ANROM"   ) return new NES_AxROM(cartridge);
+    if(type == "AN1ROM"  ) return new NES_AxROM(cartridge);
+    if(type == "AOROM"   ) return new NES_AxROM(cartridge);
+
+    if(type == "BNROM"   ) return new NES_BNROM(cartridge);
+
+    if(type == "BTR"     ) return new Sunsoft5B(cartridge);
+
+    if(type == "CNROM"   ) return new NES_CxROM(cartridge);
+    if(type == "CPROM"   ) return new NES_CxROM(cartridge);
+
+    if(type == "DEROM"   ) return new Namco34xx(cartridge);
+    if(type == "DE1ROM"  ) return new Namco34xx(cartridge);
+    if(type == "DRROM"   ) return new Namco34xx(cartridge);
+
+    if(type == "EVENT"   ) return new NES_Event(cartridge);
+
+    if(type == "EKROM"   ) return new NES_ExROM(cartridge);
+    if(type == "ELROM"   ) return new NES_ExROM(cartridge);
+    if(type == "ETROM"   ) return new NES_ExROM(cartridge);
+    if(type == "EWROM"   ) return new NES_ExROM(cartridge);
+
+    if(type == "FJROM"   ) return new NES_FxROM(cartridge);
+    if(type == "FKROM"   ) return new NES_FxROM(cartridge);
+
+    if(type == "GNROM"   ) return new NES_GxROM(cartridge);
+    if(type == "MHROM"   ) return new NES_GxROM(cartridge);
+
+    if(type == "HKROM"   ) return new NES_HKROM(cartridge);
+
+    if(type == "JLROM"   ) return new Sunsoft5B(cartridge);
+    if(type == "JSROM"   ) return new Sunsoft5B(cartridge);
+
+    if(type == "FAMILYBASIC") return new NES_NROM(cartridge);
+    if(type == "HROM"       ) return new NES_NROM(cartridge);
+    if(type == "NROM"       ) return new NES_NROM(cartridge);
+    if(type == "NROM-128"   ) return new NES_NROM(cartridge);
+    if(type == "NROM-256"   ) return new NES_NROM(cartridge);
+    if(type == "RROM"       ) return new NES_NROM(cartridge);
+    if(type == "RROM-128"   ) return new NES_NROM(cartridge);
+    if(type == "RTROM"      ) return new NES_NROM(cartridge);
+    if(type == "SROM"       ) return new NES_NROM(cartridge);
+    if(type == "STROM"      ) return new NES_NROM(cartridge);
+
+    if(type == "PEEOROM" ) return new NES_PxROM(cartridge);
+    if(type == "PNROM"   ) return new NES_PxROM(cartridge);
+
+    if(type == "QJ"      ) return new NES_QJ(cartridge);
+
+    if(type == "SAROM"   ) return new NES_SxROM(cartridge);
+    if(type == "SBROM"   ) return new NES_SxROM(cartridge);
+    if(type == "SCROM"   ) return new NES_SxROM(cartridge);
+    if(type == "SC1ROM"  ) return new NES_SxROM(cartridge);
+    if(type == "SEROM"   ) return new NES_SxROM(cartridge);
+    if(type == "SFROM"   ) return new NES_SxROM(cartridge);
+    if(type == "SF1ROM"  ) return new NES_SxROM(cartridge);
+    if(type == "SFEXPROM") return new NES_SxROM(cartridge);
+    if(type == "SGROM"   ) return new NES_SxROM(cartridge);
+    if(type == "SHROM"   ) return new NES_SxROM(cartridge);
+    if(type == "SH1ROM"  ) return new NES_SxROM(cartridge);
+    if(type == "SIROM"   ) return new NES_SxROM(cartridge);
+    if(type == "SJROM"   ) return new NES_SxROM(cartridge);
+    if(type == "SKROM"   ) return new NES_SxROM(cartridge);
+    if(type == "SLROM"   ) return new NES_SxROM(cartridge);
+    if(type == "SL1ROM"  ) return new NES_SxROM(cartridge);
+    if(type == "SL2ROM"  ) return new NES_SxROM(cartridge);
+    if(type == "SL3ROM"  ) return new NES_SxROM(cartridge);
+    if(type == "SLRROM"  ) return new NES_SxROM(cartridge);
+    if(type == "SMROM"   ) return new NES_SxROM(cartridge);
+    if(type == "SNROM"   ) return new NES_SxROM(cartridge);
+    if(type == "SNWEPROM") return new NES_SxROM(cartridge);
+    if(type == "SOROM"   ) return new NES_SxROM(cartridge);
+    if(type == "SUROM"   ) return new NES_SxROM(cartridge);
+    if(type == "SXROM"   ) return new NES_SxROM(cartridge);
+
+    if(type == "TBROM"   ) return new NES_TxROM(cartridge);
+    if(type == "TEROM"   ) return new NES_TxROM(cartridge);
+    if(type == "TFROM"   ) return new NES_TxROM(cartridge);
+    if(type == "TGROM"   ) return new NES_TxROM(cartridge);
+    if(type == "TKROM"   ) return new NES_TxROM(cartridge);
+    if(type == "TKEPROM" ) return new NES_TxROM(cartridge);
+    if(type == "TKSROM"  ) return new NES_TxROM(cartridge);
+    if(type == "TLROM"   ) return new NES_TxROM(cartridge);
+    if(type == "TL1ROM"  ) return new NES_TxROM(cartridge);
+    if(type == "TL2ROM"  ) return new NES_TxROM(cartridge);
+    if(type == "TLSROM"  ) return new NES_TxROM(cartridge);
+    if(type == "TNROM"   ) return new NES_TxROM(cartridge);
+    if(type == "TQROM"   ) return new NES_TxROM(cartridge);
+    if(type == "TR1ROM"  ) return new NES_TxROM(cartridge);
+    if(type == "TSROM"   ) return new NES_TxROM(cartridge);
+    if(type == "TVROM"   ) return new NES_TxROM(cartridge);
+
+    if(type == "UNROM"   ) return new NES_UxROM(cartridge);
+    if(type == "UN1ROM"  ) return new NES_UxROM(cartridge);
+    if(type == "UOROM"   ) return new NES_UxROM(cartridge);
+
+    if(type == "ZZ"      ) return new PAL_ZZ(cartridge);
+  }
 
-  if(type == "NES-UNROM"   ) return new NES_UxROM(document);
-  if(type == "NES-UOROM"   ) return new NES_UxROM(document);
+  if(type == "ACCLAIM-MC-ACC") return new NES_TxROM(cartridge);
 
-  if(type == "SUNSOFT-5B"  ) return new Sunsoft5B(document);
+  if(type == "BANDAI-74*161/02/74" ) return new Bandai74_161_02_74(cartridge);
+  if(type == "BANDAI-74*161/32"    ) return new NES_CxROM(cartridge);
+  if(type == "BANDAI-74*161/161/32") return new Bandai74_161_161_32(cartridge);
+  if(type == "BANDAI-CNROM"        ) return new NES_CxROM(cartridge);
+  if(type == "BANDAI-FCG"          ) return new BandaiFCG(cartridge);
+  if(type == "BANDAI-FCG-1"        ) return new BandaiFCG(cartridge);
+  if(type == "BANDAI-FCG-2"        ) return new BandaiFCG(cartridge);
+  if(type == "BANDAI-GNROM"        ) return new NES_GxROM(cartridge);
+  if(type == "BANDAI-JUMP2"        ) return new BandaiFCG(cartridge);
+  if(type == "BANDAI-LZ93D50"      ) return new BandaiFCG(cartridge);
+  if(type == "BANDAI-NROM-128"     ) return new NES_NROM(cartridge);
+  if(type == "BANDAI-NROM-256"     ) return new NES_NROM(cartridge);
+  if(type == "BANDAI-PT-554"       ) return new NES_CxROM(cartridge);
+
+  if(type == "IREM-74*161/161/21/138") return new Irem74_161_161_21_138(cartridge);
+  if(type == "IREM-BNROM"            ) return new NES_BNROM(cartridge);
+  if(type == "IREM-FCG-1"            ) return new BandaiFCG(cartridge);
+  if(type == "IREM-G101"             ) return new IremG101(cartridge);
+  if(type == "IREM-H3001"            ) return new IremH3001(cartridge);
+  if(type == "IREM-HOLYDIVER"        ) return new IremHolyDiver(cartridge);
+  if(type == "IREM-NROM-128"         ) return new NES_NROM(cartridge);
+  if(type == "IREM-NROM-256"         ) return new NES_NROM(cartridge);
+  if(type == "IREM-TAM-S1"           ) return new IremTamS1(cartridge);
+  if(type == "IREM-UNROM"            ) return new NES_UxROM(cartridge);
+
+  if(type == "JALECO-JF-05") return new JalecoJF0x(cartridge);
+  if(type == "JALECO-JF-06") return new JalecoJF0x(cartridge);
+  if(type == "JALECO-JF-07") return new JalecoJF0x(cartridge);
+  if(type == "JALECO-JF-08") return new JalecoJF0x(cartridge);
+  if(type == "JALECO-JF-09") return new JalecoJF0x(cartridge);
+  if(type == "JALECO-JF-10") return new JalecoJF0x(cartridge);
+  if(type == "JALECO-JF-11") return new JalecoJF0x(cartridge);
+  if(type == "JALECO-JF-14") return new JalecoJF0x(cartridge);
+  if(type == "JALECO-JF-16") return new JalecoJF16(cartridge);
+  if(type == "JALECO-JF-22") return new KonamiVRC1(cartridge);
+  if(type == "JALECO-JF-23") return new JalecoJF2x(cartridge);
+  if(type == "JALECO-JF-24") return new JalecoJF2x(cartridge);
+  if(type == "JALECO-JF-25") return new JalecoJF2x(cartridge);
+  if(type == "JALECO-JF-27") return new JalecoJF2x(cartridge);
+  if(type == "JALECO-JF-29") return new JalecoJF2x(cartridge);
+  if(type == "JALECO-JF-37") return new JalecoJF2x(cartridge);
+  if(type == "JALECO-JF-40") return new JalecoJF2x(cartridge);
+
+  if(type == "KONAMI-74*139/74") return new JalecoJF0x(cartridge);
+  if(type == "KONAMI-CNROM"    ) return new NES_CxROM(cartridge);
+  if(type == "KONAMI-NROM-128" ) return new NES_NROM(cartridge);
+  if(type == "KONAMI-SLROM"    ) return new NES_SxROM(cartridge);
+  if(type == "KONAMI-TLROM"    ) return new NES_TxROM(cartridge);
+  if(type == "KONAMI-UNROM"    ) return new NES_UxROM(cartridge);
+  if(type == "KONAMI-VRC-1"    ) return new KonamiVRC1(cartridge);
+  if(type == "KONAMI-VRC-2"    ) return new KonamiVRC2(cartridge);
+  if(type == "KONAMI-VRC-3"    ) return new KonamiVRC3(cartridge);
+  if(type == "KONAMI-VRC-4"    ) return new KonamiVRC4(cartridge);
+  if(type == "KONAMI-VRC-6"    ) return new KonamiVRC6(cartridge);
+  if(type == "KONAMI-VRC-7"    ) return new KonamiVRC7(cartridge);
+
+  if(type == "NAMCOT-129" ) return new Namco163(cartridge);
+  if(type == "NAMCOT-163" ) return new Namco163(cartridge);
+  if(type == "NAMCOT-175" ) return new Namco163(cartridge);
+  if(type == "NAMCOT-340" ) return new Namco163(cartridge);
+  if(type == "NAMCOT-3301") return new NES_NROM(cartridge);
+  if(type == "NAMCOT-3302") return new NES_NROM(cartridge);
+  if(type == "NAMCOT-3305") return new NES_NROM(cartridge);
+  if(type == "NAMCOT-3311") return new NES_NROM(cartridge);
+  if(type == "NAMCOT-3312") return new NES_NROM(cartridge);
+  if(type == "NAMCOT-3401") return new Namco34xx(cartridge);
+  if(type == "NAMCOT-3406") return new Namco34xx(cartridge);
+  if(type == "NAMCOT-3407") return new Namco34xx(cartridge);
+  if(type == "NAMCOT-3413") return new Namco34xx(cartridge);
+  if(type == "NAMCOT-3414") return new Namco34xx(cartridge);
+  if(type == "NAMCOT-3415") return new Namco34xx(cartridge);
+  if(type == "NAMCOT-3416") return new Namco34xx(cartridge);
+  if(type == "NAMCOT-3417") return new Namco34xx(cartridge);
+  if(type == "NAMCOT-3425") return new Namco34xx(cartridge);
+  if(type == "NAMCOT-3443") return new Namco34xx(cartridge);
+  if(type == "NAMCOT-3446") return new Namco34xx(cartridge);
+  if(type == "NAMCOT-3451") return new Namco34xx(cartridge);
+  if(type == "NAMCOT-3453") return new Namco34xx(cartridge);
+
+  if(type == "SUNSOFT-4" ) return new Sunsoft4(cartridge);
+  if(type == "SUNSOFT-5B") return new Sunsoft5B(cartridge);
+
+  if(type == "TAITO-TC0190FMC") return new TaitoTC(cartridge);
+  if(type == "TAITO-TC0350FMR") return new TaitoTC(cartridge);
+  if(type == "TAITO-TC0690FMR") return new TaitoTC(cartridge);
+
+  if(type == "FDS") return new FDS(cartridge);
+  if(type == "VS" ) return new VS(cartridge);
+
+  // Unlicensed boards below; feel free to remove
+  if(type == "AVE-NINA-01"       ) return new Nina(cartridge);
+  if(type == "AVE-NINA-02"       ) return new Nina(cartridge);
+  if(type == "AVE-NINA-03"       ) return new Nina(cartridge);
+  if(type == "AVE-NINA-06"       ) return new Nina(cartridge);
+  if(type == "CAMERICA-ALGN"     ) return new Camerica(cartridge);
+  if(type == "CAMERICA-ALGQ"     ) return new Camerica(cartridge);
+  if(type == "CAMERICA-BF9093"   ) return new Camerica(cartridge);
+  if(type == "CAMERICA-BF9096"   ) return new Camerica(cartridge);
+  if(type == "CAMERICA-BF9097"   ) return new Camerica(cartridge);
+  if(type == "CODEMASTERS-NR8N"  ) return new Camerica(cartridge);
+  if(type == "COLORDREAMS-74*377") return new ColorDreams74_377(cartridge);
+  if(type == "MLT-ACTION52"      ) return new MLT_Action52(cartridge);
+  if(type == "TENGEN-800002"     ) return new Namco34xx(cartridge);
+  if(type == "TENGEN-800003"     ) return new NES_NROM(cartridge);
+  if(type == "TENGEN-800004"     ) return new Namco34xx(cartridge);
+  if(type == "TENGEN-800008"     ) return new NES_CxROM(cartridge);
+  if(type == "TENGEN-800030"     ) return new Namco34xx(cartridge);
+  if(type == "TENGEN-800042"     ) return new Sunsoft4(cartridge);
+  // Homebrew boards; feel free to remove
+  if(type == "NoConflicts-CNROM") return new NoConflicts_CNROM(cartridge);
+  if(type == "SingleChip") return new SingleChip(cartridge);
 
   return nullptr;
 }
diff -Nru higan/fc/cartridge/board/board.hpp higan/fc/cartridge/board/board.hpp
--- higan/fc/cartridge/board/board.hpp	2015-09-16 02:20:06.371574580 +0900
+++ higan/fc/cartridge/board/board.hpp	2015-09-16 13:08:13.525563365 +0900
@@ -1,20 +1,9 @@
 struct Board {
-  struct Memory {
-    uint8_t* data;
-    unsigned size;
-    bool writable;
-
-    inline uint8 read(unsigned addr) const;
-    inline void write(unsigned addr, uint8 data);
-
-    inline Memory(uint8_t* data, unsigned size) : data(data), size(size) {}
-    inline Memory() : data(nullptr), size(0u), writable(false) {}
-    inline ~Memory() { if(data) delete[] data; }
-  };
-
+  static uint8 read(MappedRAM& memory, unsigned addr);
+  static void write(MappedRAM& memory, unsigned addr, uint8 byte);
   static unsigned mirror(unsigned addr, unsigned size);
 
-  virtual void main();
+  virtual void enter();
   virtual void tick();
 
   virtual uint8 prg_read(unsigned addr) = 0;
@@ -29,18 +18,17 @@
   virtual void reset();
 
   virtual void serialize(serializer&);
-  Board(Markup::Node& document);
+  Board(Markup::Node& cartridge);
   virtual ~Board();
 
-  static Board* load(string manifest);
+  static Board* load(Markup::Node cartridge);
+
+  Chip *chip;
 
-  struct Information {
-    string type;
-    bool battery;
-  } information;
-
-  Memory prgrom;
-  Memory prgram;
-  Memory chrrom;
-  Memory chrram;
+  MappedRAM prgrom;
+  MappedRAM prgram;
+  MappedRAM chrrom;
+  MappedRAM chrram;
+  MappedRAM instrom;
+  MappedRAM keyrom;
 };
diff -Nru higan/fc/cartridge/board/fds.cpp higan/fc/cartridge/board/fds.cpp
--- higan/fc/cartridge/board/fds.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/fc/cartridge/board/fds.cpp	2015-09-16 13:08:13.531563365 +0900
@@ -0,0 +1,211 @@
+struct FDS : Board {
+
+uint16 irq_counter;
+uint16 irq_latch;
+bool irq_repeat;
+bool irq_enable;
+
+bool disk_io_enable;
+bool sound_io_enable;
+
+uint8 fds_control;
+bool mirror;
+
+bool irq_pending;
+bool byte_transferred;
+
+uint8 data_register;
+
+bool disk_slot_empty;
+bool disk_not_ready;
+bool disk_write_protected;
+
+uint6 wavetable[0x40];
+bool wavetable_write_enable;
+
+void enter() {
+  while(true) {
+    if(scheduler.sync == Scheduler::SynchronizeMode::All) {
+      scheduler.exit(Scheduler::ExitReason::SynchronizeEvent);
+    }
+
+    if(irq_enable && irq_counter > 0 && --irq_counter == 0) {
+      cpu.set_irq_line(1);
+      if(irq_repeat) irq_counter = irq_latch;
+      else           irq_enable = false;
+      irq_latch = 0; // for Kaettekita Mario Bros.?
+    } else {
+      //TODO: Drive timer emulation
+    }
+    tick();
+  }
+}
+
+uint8 prg_read(unsigned addr) {
+  switch(addr) {
+  case 0x4030:
+    {
+      uint8 data = (irq_pending | (byte_transferred << 1));
+      irq_pending = false;
+      byte_transferred = false;
+      // 0x10: CRC 0=pass; 1=fail
+      // 0x40: End of disk head
+      // 0x80: Disk read/write enable
+      cpu.set_irq_line(0);
+      return 0;
+    }
+  case 0x4031:
+    return data_register;
+  case 0x4032:
+    return (
+      (disk_slot_empty      << 0) |
+      (disk_not_ready       << 1) |
+      (disk_write_protected << 2)
+    );
+  case 0x4033:
+    // 7-bit expansion input; 0x80 means low battery
+    return 0x00;
+  case 0x4090:
+    return cpu.mdr() & 0xc0;
+  case 0x4092:
+    return cpu.mdr() & 0xc0;
+  }
+  if((addr & 0xffc0) == 0x4040) {
+    return wavetable[addr & 0x3f] | (cpu.mdr() & 0xc0);
+  }
+  switch(addr & 0xe000) {
+  case 0x6000:
+  case 0x8000:
+  case 0xa000:
+  case 0xc000: return read(prgram, addr);
+  case 0xe000: return read(prgrom, addr);
+  }
+  return cpu.mdr();
+}
+
+void prg_write(unsigned addr, uint8 data) {
+  switch(addr) {
+  case 0x4020: irq_latch = (irq_latch & 0xff00) | (data << 0); break;
+  case 0x4021: irq_latch = (irq_latch & 0x00ff) | (data << 8); break;
+  case 0x4022:
+    irq_repeat = data & 0x01;
+    irq_enable = data & 0x02;
+    irq_counter = irq_latch;
+    byte_transferred = false;
+    cpu.set_irq_line(0); // if pending IRQ flag is clear
+    break;
+  case 0x4023:
+    disk_io_enable = data & 0x01;
+    sound_io_enable = data & 0x02;
+    break;
+  case 0x4024:
+    // clear pending IRQ flag
+    if(!byte_transferred) cpu.set_irq_line(0);
+    break;
+  case 0x4025:
+    fds_control = data & 0xf7;
+    mirror = data & 0x08;
+    break;
+  case 0x4026:
+    // 7-bit expansion output
+    break;
+  case 0x4080: break;
+  case 0x4082: break;
+  case 0x4083: break;
+  case 0x4084: break;
+  case 0x4085: break;
+  case 0x4086: break;
+  case 0x4087: break;
+  case 0x4088: break;
+  case 0x4089:
+    wavetable_write_enable = data & 0x80;
+    break;
+  case 0x408a: break;
+  }
+  if((addr & 0xffc0) == 0x4040) {
+    if(wavetable_write_enable) wavetable[addr & 0x3f] = data & 0x3f;
+  }
+  switch(addr & 0xe000) {
+  case 0x6000:
+  case 0x8000:
+  case 0xa000:
+  case 0xc000: write(prgram, addr, data); break;
+  }
+}
+
+uint8 chr_read(unsigned addr) {
+  if(addr & 0x2000) {
+    if(mirror) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    return ppu.ciram_read(addr);
+  }
+  return Board::chr_read(addr);
+}
+
+void chr_write(unsigned addr, uint8 data) {
+  if(addr & 0x2000) {
+    if(mirror) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    return ppu.ciram_write(addr, data);
+  }
+  return Board::chr_write(addr, data);
+}
+
+void power() {
+  reset();
+}
+
+void reset() {
+  irq_counter = 0;
+  irq_latch = 0;
+  irq_repeat = false;
+  irq_enable = false;
+
+  disk_io_enable = false;
+  sound_io_enable = false;
+
+  fds_control = 0x26;
+  mirror = false;
+
+  irq_pending = false;
+  byte_transferred = false;
+
+  data_register = 0x00;
+
+  disk_slot_empty = true;
+  disk_not_ready = true;
+  disk_write_protected = true;
+
+  for(auto& n : wavetable) n = 0x00;
+  wavetable_write_enable = false;
+}
+
+void serialize(serializer& s) {
+  Board::serialize(s);
+
+  s.integer(irq_counter);
+  s.integer(irq_latch);
+  s.integer(irq_repeat);
+  s.integer(irq_enable);
+
+  s.integer(disk_io_enable);
+  s.integer(sound_io_enable);
+
+  s.integer(fds_control);
+  s.integer(mirror);
+
+  s.integer(irq_pending);
+  s.integer(byte_transferred);
+
+  s.integer(data_register);
+
+  s.integer(disk_slot_empty);
+  s.integer(disk_not_ready);
+  s.integer(disk_write_protected);
+
+  s.array(wavetable);
+  s.integer(wavetable_write_enable);
+}
+
+FDS(Markup::Node& cartridge) : Board(cartridge) {
+}
+
+};
diff -Nru higan/fc/cartridge/board/irem-74-161-161-21-138.cpp higan/fc/cartridge/board/irem-74-161-161-21-138.cpp
--- higan/fc/cartridge/board/irem-74-161-161-21-138.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/fc/cartridge/board/irem-74-161-161-21-138.cpp	2015-09-16 13:08:13.534563366 +0900
@@ -0,0 +1,64 @@
+//IREM-74*161/161/21/138
+
+struct Irem74_161_161_21_138 : Board {
+
+uint4 prg_bank;
+uint4 chr_bank;
+
+uint8 prg_read(unsigned addr) {
+  if(addr & 0x8000) return read(prgrom, (prg_bank << 15) | (addr & 0x7fff));
+  return cpu.mdr();
+}
+
+void prg_write(unsigned addr, uint8 data) {
+  if(addr & 0x8000) {
+    // Bus conflicts
+    data &= prg_read(addr);
+    prg_bank = (data & 0x0f) >> 0;
+    chr_bank = (data & 0xf0) >> 4;
+  }
+}
+
+uint8 chr_read(unsigned addr) {
+  if(addr & 0x2000) return ciram_read(addr);
+  if((addr & 0x1800) == 0x0000) return read(chrrom, (addr & 0x07ff) | (chr_bank << 11));
+  return read(chrram, addr);
+}
+
+void chr_write(unsigned addr, uint8 data) {
+  if(addr & 0x2000) return ciram_write(addr, data);
+  if((addr & 0x1800) != 0x0000) return write(chrram, addr & 0x1fff, data);
+}
+
+uint8 ciram_read(unsigned addr) {
+  switch(addr & 0x0800) {
+  case 0x0000: return read(chrram, addr & 0x1fff);
+  case 0x0800: return ppu.ciram_read(addr);
+  }
+}
+
+void ciram_write(unsigned addr, uint8 data) {
+  switch(addr & 0x0800) {
+  case 0x0000: return write(chrram, addr & 0x1fff, data);
+  case 0x0800: return ppu.ciram_write(addr, data);
+  }
+}
+
+void power() {
+}
+
+void reset() {
+  prg_bank = 0;
+  chr_bank = 0;
+}
+
+void serialize(serializer& s) {
+  Board::serialize(s);
+  s.integer(prg_bank);
+  s.integer(chr_bank);
+}
+
+Irem74_161_161_21_138(Markup::Node& cartridge) : Board(cartridge) {
+}
+
+};
diff -Nru higan/fc/cartridge/board/irem-g101.cpp higan/fc/cartridge/board/irem-g101.cpp
--- higan/fc/cartridge/board/irem-g101.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/fc/cartridge/board/irem-g101.cpp	2015-09-16 13:08:13.530563365 +0900
@@ -0,0 +1,61 @@
+struct IremG101 : Board {
+
+struct Settings {
+  uint2 mirror;  //0 = G101-controlled, 1 = screen 0, 2 = screen 1
+} settings;
+
+G101 g101;
+
+uint8 prg_read(unsigned addr) {
+  if((addr & 0x8000) == 0x8000) return read(prgrom, g101.prg_addr(addr));
+  if((addr & 0xe000) == 0x6000) return read(prgram, addr & 0x1fff);
+  return cpu.mdr();
+}
+
+void prg_write(unsigned addr, uint8 data) {
+  if((addr & 0x8000) == 0x8000) return g101.reg_write(addr, data);
+  if((addr & 0xe000) == 0x6000) return write(prgram, addr & 0x1fff, data);
+}
+
+uint8 chr_read(unsigned addr) {
+  if(addr & 0x2000) switch(settings.mirror) {
+  case 0: return ppu.ciram_read(g101.ciram_addr(addr));
+  case 1: return ppu.ciram_read((addr & 0x03ff) | 0x0400);
+  case 2: return ppu.ciram_read((addr & 0x03ff) | 0x0800);
+  }
+  return Board::chr_read(g101.chr_addr(addr));
+}
+
+void chr_write(unsigned addr, uint8 data) {
+  if(addr & 0x2000) switch(settings.mirror) {
+  case 0: return ppu.ciram_write(g101.ciram_addr(addr), data);
+  case 1: return ppu.ciram_write((addr & 0x03ff) | 0x0400, data);
+  case 2: return ppu.ciram_write((addr & 0x03ff) | 0x0800, data);
+  }
+  return Board::chr_write(g101.chr_addr(addr), data);
+}
+
+void power() {
+  g101.power();
+}
+
+void reset() {
+  g101.reset();
+}
+
+void serialize(serializer& s) {
+  Board::serialize(s);
+  g101.serialize(s);
+}
+
+IremG101(Markup::Node& cartridge) : Board(cartridge), g101(*this, cartridge) {
+  if(!cartridge["mirror"]) {
+    settings.mirror = 0;
+  } else {
+    string mirror = cartridge["mirror/mode"].text();
+    if(mirror == "screen-0") settings.mirror = 1;
+    if(mirror == "screen-1") settings.mirror = 2;
+  }
+}
+
+};
diff -Nru higan/fc/cartridge/board/irem-h3001.cpp higan/fc/cartridge/board/irem-h3001.cpp
--- higan/fc/cartridge/board/irem-h3001.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/fc/cartridge/board/irem-h3001.cpp	2015-09-16 13:08:13.530563365 +0900
@@ -0,0 +1,46 @@
+struct IremH3001 : Board {
+
+IFH3001 ifh3001;
+
+void enter() {
+  ifh3001.enter();
+}
+
+uint8 prg_read(unsigned addr) {
+  if((addr & 0x8000) == 0x8000) return read(prgrom, ifh3001.prg_addr(addr));
+  if((addr & 0xe000) == 0x6000) return read(prgram, addr & 0x1fff);
+  return cpu.mdr();
+}
+
+void prg_write(unsigned addr, uint8 data) {
+  if((addr & 0x8000) == 0x8000) return ifh3001.reg_write(addr, data);
+  if((addr & 0xe000) == 0x6000) return write(prgram, addr & 0x1fff, data);
+}
+
+uint8 chr_read(unsigned addr) {
+  if(addr & 0x2000) return ppu.ciram_read(ifh3001.ciram_addr(addr));
+  return Board::chr_read(ifh3001.chr_addr(addr));
+}
+
+void chr_write(unsigned addr, uint8 data) {
+  if(addr & 0x2000) return ppu.ciram_write(ifh3001.ciram_addr(addr), data);
+  return Board::chr_write(ifh3001.chr_addr(addr), data);
+}
+
+void power() {
+  ifh3001.power();
+}
+
+void reset() {
+  ifh3001.reset();
+}
+
+void serialize(serializer& s) {
+  Board::serialize(s);
+  ifh3001.serialize(s);
+}
+
+IremH3001(Markup::Node& cartridge) : Board(cartridge), ifh3001(*this, cartridge) {
+}
+
+};
diff -Nru higan/fc/cartridge/board/irem-holydiver.cpp higan/fc/cartridge/board/irem-holydiver.cpp
--- higan/fc/cartridge/board/irem-holydiver.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/fc/cartridge/board/irem-holydiver.cpp	2015-09-16 13:08:13.528563365 +0900
@@ -0,0 +1,61 @@
+//IREM-HOLYDIVER
+
+struct IremHolyDiver : Board {
+
+uint3 prg_bank;
+uint4 chr_bank;
+bool mirror;
+
+uint8 prg_read(unsigned addr) {
+  switch(addr & 0xc000) {
+  case 0x8000: return read(prgrom, (prg_bank << 14) | (addr & 0x3fff));
+  case 0xc000: return read(prgrom, (    0x07 << 14) | (addr & 0x3fff));
+  }
+}
+
+void prg_write(unsigned addr, uint8 data) {
+  if(addr & 0x8000) {
+    // Bus conflicts
+    data &= prg_read(addr);
+    prg_bank = (data & 0x07) >> 0;
+    mirror = data & 0x08;
+    chr_bank = (data & 0xf0) >> 4;
+  }
+}
+
+uint8 chr_read(unsigned addr) {
+  if(addr & 0x2000) {
+    if(mirror == 0) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    return ppu.ciram_read(addr);
+  }
+  return Board::chr_read((chr_bank * 0x2000) + (addr & 0x1fff));
+}
+
+void chr_write(unsigned addr, uint8 data) {
+  if(addr & 0x2000) {
+    if(mirror == 0) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    return ppu.ciram_write(addr, data);
+  }
+  Board::chr_write((chr_bank * 0x2000) + (addr & 0x1fff), data);
+}
+
+void power() {
+}
+
+void reset() {
+  prg_bank = 0;
+  chr_bank = 0;
+  mirror = 0;
+}
+
+void serialize(serializer& s) {
+  Board::serialize(s);
+  s.integer(prg_bank);
+  s.integer(chr_bank);
+  s.integer(mirror);
+}
+
+IremHolyDiver(Markup::Node& cartridge) : Board(cartridge) {
+}
+
+};
diff -Nru higan/fc/cartridge/board/irem-tam-s1.cpp higan/fc/cartridge/board/irem-tam-s1.cpp
--- higan/fc/cartridge/board/irem-tam-s1.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/fc/cartridge/board/irem-tam-s1.cpp	2015-09-16 13:08:13.528563365 +0900
@@ -0,0 +1,69 @@
+//IREM-TAM-S1
+
+struct IremTamS1 : Board {
+
+uint4 prg_bank;
+uint2 mirror; //0 = screen 0, 1 = horizontal, 2 = vertical, 3 = screen 1
+
+uint8 prg_read(unsigned addr) {
+  if((addr & 0x8000) == 0x0000) return cpu.mdr();
+  switch(addr & 0xc000) {
+  case 0x8000: return read(prgrom, (    0x0f << 14) | (addr & 0x3fff));
+  case 0xc000: return read(prgrom, (prg_bank << 14) | (addr & 0x3fff));
+  }
+}
+
+void prg_write(unsigned addr, uint8 data) {
+  if(addr & 0x8000) {
+    //TODO: check for bus conflicts
+    //data &= prg_read(addr);
+    prg_bank = data & 0x0f;
+    mirror = (data & 0xc0) >> 6;
+  }
+}
+
+uint8 chr_read(unsigned addr) {
+  if(addr & 0x2000) {
+    switch(mirror) {
+    case 0: addr = (0x0000              ) | (addr & 0x03ff); break;
+    case 1: addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff); break;
+    case 2: addr = ((addr & 0x0400) >> 0) | (addr & 0x03ff); break;
+    case 3: addr = (0x0400              ) | (addr & 0x03ff); break;
+    }
+    return ppu.ciram_read(addr);
+  }
+  return Board::chr_read(addr);
+}
+
+void chr_write(unsigned addr, uint8 data) {
+  if(addr & 0x2000) {
+    switch(mirror) {
+    case 0: addr = (0x0000              ) | (addr & 0x03ff); break;
+    case 1: addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff); break;
+    case 2: addr = ((addr & 0x0400) >> 0) | (addr & 0x03ff); break;
+    case 3: addr = (0x0400              ) | (addr & 0x03ff); break;
+    }
+    return ppu.ciram_write(addr, data);
+  }
+  return Board::chr_write(addr, data);
+}
+
+void power() {
+}
+
+void reset() {
+  prg_bank = 0;
+  mirror = 0;
+}
+
+void serialize(serializer& s) {
+  Board::serialize(s);
+
+  s.integer(prg_bank);
+  s.integer(mirror);
+}
+
+IremTamS1(Markup::Node& cartridge) : Board(cartridge) {
+}
+
+};
diff -Nru higan/fc/cartridge/board/jaleco-jf-0x.cpp higan/fc/cartridge/board/jaleco-jf-0x.cpp
--- higan/fc/cartridge/board/jaleco-jf-0x.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/fc/cartridge/board/jaleco-jf-0x.cpp	2015-09-16 13:08:13.534563366 +0900
@@ -0,0 +1,101 @@
+//JALECO-JF-05
+//JALECO-JF-06
+//JALECO-JF-07
+//JALECO-JF-08
+//JALECO-JF-09
+//JALECO-JF-10
+//JALECO-JF-11
+//JALECO-JF-14
+
+struct JalecoJF0x : Board {
+
+enum class Revision : unsigned {
+  JF_05,
+  JF_06,
+  JF_07,
+  JF_08,
+  JF_09,
+  JF_10,
+  JF_11,
+  JF_14,
+} revision;
+
+struct Settings {
+  bool mirror;  //0 = vertical, 1 = horizontal
+} settings;
+
+uint2 prg_bank;
+uint4 chr_bank;
+
+uint8 prg_read(unsigned addr) {
+  if(addr & 0x8000) return read(prgrom, (prg_bank << 15) | (addr & 0x7fff));
+  return cpu.mdr();
+}
+
+void prg_write(unsigned addr, uint8 data) {
+  if((addr & 0xe000) == 0x6000) {
+    switch(revision) {
+    case Revision::JF_05:
+    case Revision::JF_06:
+    case Revision::JF_07:
+    case Revision::JF_08:
+    case Revision::JF_09:
+    case Revision::JF_10:
+      chr_bank = ((data & 0x01) << 1) | ((data & 0x02) >> 1);
+      break;
+    case Revision::JF_11:
+    case Revision::JF_14:
+      prg_bank = (data & 0x30) >> 4;
+      chr_bank = (data & 0x0f) >> 0;
+      break;
+    }
+  }
+}
+
+uint8 chr_read(unsigned addr) {
+  if(addr & 0x2000) {
+    if(settings.mirror == 1) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    return ppu.ciram_read(addr);
+  }
+  addr = (chr_bank * 0x2000) + (addr & 0x1fff);
+  return Board::chr_read(addr);
+}
+
+void chr_write(unsigned addr, uint8 data) {
+  if(addr & 0x2000) {
+    if(settings.mirror == 1) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    return ppu.ciram_write(addr, data);
+  }
+  addr = (chr_bank * 0x2000) + (addr & 0x1fff);
+  Board::chr_write(addr, data);
+}
+
+void power() {
+}
+
+void reset() {
+  prg_bank = 0;
+  chr_bank = 0;
+}
+
+void serialize(serializer& s) {
+  Board::serialize(s);
+  s.integer(prg_bank);
+  s.integer(chr_bank);
+}
+
+JalecoJF0x(Markup::Node& cartridge) : Board(cartridge) {
+  string type = cartridge["board/type"].text();
+  if(type.match("*JF-05*" )) revision = Revision::JF_05;
+  if(type.match("*JF-06*" )) revision = Revision::JF_06;
+  if(type.match("*JF-07*" )) revision = Revision::JF_07;
+  if(type.match("*JF-08*" )) revision = Revision::JF_08;
+  if(type.match("*JF-09*" )) revision = Revision::JF_09;
+  if(type.match("*JF-10*" )) revision = Revision::JF_10;
+  if(type.match("*JF-11*" )) revision = Revision::JF_11;
+  if(type.match("*JF-14*" )) revision = Revision::JF_14;
+
+  settings.mirror = cartridge["mirror/mode"].text() == "horizontal";
+}
+
+};
diff -Nru higan/fc/cartridge/board/jaleco-jf-16.cpp higan/fc/cartridge/board/jaleco-jf-16.cpp
--- higan/fc/cartridge/board/jaleco-jf-16.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/fc/cartridge/board/jaleco-jf-16.cpp	2015-09-16 13:08:13.524563365 +0900
@@ -0,0 +1,61 @@
+//JALECO-JF-16
+
+struct JalecoJF16 : Board {
+
+uint3 prg_bank;
+uint4 chr_bank;
+bool nametable;
+
+uint8 prg_read(unsigned addr) {
+  switch(addr & 0xc000) {
+  case 0x8000: return read(prgrom, (prg_bank << 14) | (addr & 0x3fff));
+  case 0xc000: return read(prgrom, (    0x07 << 14) | (addr & 0x3fff));
+  }
+}
+
+void prg_write(unsigned addr, uint8 data) {
+  if(addr & 0x8000) {
+    // Bus conflicts
+    data &= prg_read(addr);
+    prg_bank = (data & 0x07) >> 0;
+    nametable = data & 0x08;
+    chr_bank = (data & 0xf0) >> 4;
+  }
+}
+
+uint8 chr_read(unsigned addr) {
+  if(addr & 0x2000) {
+    addr = (nametable << 10) | (addr & 0x03ff);
+    return ppu.ciram_read(addr);
+  }
+  return Board::chr_read((chr_bank * 0x2000) + (addr & 0x1fff));
+}
+
+void chr_write(unsigned addr, uint8 data) {
+  if(addr & 0x2000) {
+    addr = (nametable << 10) | (addr & 0x03ff);
+    return ppu.ciram_write(addr, data);
+  }
+  Board::chr_write((chr_bank * 0x2000) + (addr & 0x1fff), data);
+}
+
+void power() {
+}
+
+void reset() {
+  prg_bank = 0;
+  chr_bank = 0;
+  nametable = 0;
+}
+
+void serialize(serializer& s) {
+  Board::serialize(s);
+  s.integer(prg_bank);
+  s.integer(chr_bank);
+  s.integer(nametable);
+}
+
+JalecoJF16(Markup::Node& cartridge) : Board(cartridge) {
+}
+
+};
diff -Nru higan/fc/cartridge/board/jaleco-jf-2x.cpp higan/fc/cartridge/board/jaleco-jf-2x.cpp
--- higan/fc/cartridge/board/jaleco-jf-2x.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/fc/cartridge/board/jaleco-jf-2x.cpp	2015-09-16 13:08:13.527563365 +0900
@@ -0,0 +1,67 @@
+//JALECO-JF-24
+//JALECO-JF-25
+
+struct JalecoJF2x : Board {
+
+enum class Revision : unsigned {
+  JF_23,
+  JF_24,
+  JF_25,
+  JF_27,
+  JF_29,
+  JF_37,
+  JF_40,
+} revision;
+
+SS88006 ss88006;
+
+void enter() {
+  ss88006.enter();
+}
+
+uint8 prg_read(unsigned addr) {
+  if((addr & 0x8000) == 0x8000) return read(prgrom, ss88006.prg_addr(addr));
+  if((addr & 0xe000) == 0x6000) return ss88006.ram_read(addr);
+  return cpu.mdr();
+}
+
+void prg_write(unsigned addr, uint8 data) {
+  if((addr & 0x8000) == 0x8000) return ss88006.reg_write(addr, data);
+  if((addr & 0xe000) == 0x6000) return ss88006.ram_write(addr, data);
+}
+
+uint8 chr_read(unsigned addr) {
+  if(addr & 0x2000) return ppu.ciram_read(ss88006.ciram_addr(addr));
+  return Board::chr_read(ss88006.chr_addr(addr));
+}
+
+void chr_write(unsigned addr, uint8 data) {
+  if(addr & 0x2000) return ppu.ciram_write(ss88006.ciram_addr(addr), data);
+  return Board::chr_write(ss88006.chr_addr(addr), data);
+}
+
+void power() {
+  ss88006.power();
+}
+
+void reset() {
+  ss88006.reset();
+}
+
+void serialize(serializer& s) {
+  Board::serialize(s);
+  ss88006.serialize(s);
+}
+
+JalecoJF2x(Markup::Node& cartridge) : Board(cartridge), ss88006(*this, cartridge) {
+  string type = cartridge["board/type"].text();
+  if(type.match("*JF-23")) revision = Revision::JF_23;
+  if(type.match("*JF-24")) revision = Revision::JF_24;
+  if(type.match("*JF-25")) revision = Revision::JF_25;
+  if(type.match("*JF-27")) revision = Revision::JF_27;
+  if(type.match("*JF-29")) revision = Revision::JF_29;
+  if(type.match("*JF-37")) revision = Revision::JF_37;
+  if(type.match("*JF-40")) revision = Revision::JF_40;
+}
+
+};
diff -Nru higan/fc/cartridge/board/konami-vrc1.cpp higan/fc/cartridge/board/konami-vrc1.cpp
--- higan/fc/cartridge/board/konami-vrc1.cpp	2015-09-16 02:20:06.371574580 +0900
+++ higan/fc/cartridge/board/konami-vrc1.cpp	2015-09-16 13:08:13.532563365 +0900
@@ -3,7 +3,7 @@
 VRC1 vrc1;
 
 uint8 prg_read(unsigned addr) {
-  if(addr & 0x8000) return prgrom.read(vrc1.prg_addr(addr));
+  if(addr & 0x8000) return read(prgrom, vrc1.prg_addr(addr));
   return cpu.mdr();
 }
 
@@ -34,7 +34,7 @@
   vrc1.serialize(s);
 }
 
-KonamiVRC1(Markup::Node& document) : Board(document), vrc1(*this) {
+KonamiVRC1(Markup::Node& cartridge) : Board(cartridge), vrc1(*this) {
 }
 
 };
diff -Nru higan/fc/cartridge/board/konami-vrc2.cpp higan/fc/cartridge/board/konami-vrc2.cpp
--- higan/fc/cartridge/board/konami-vrc2.cpp	2015-09-16 02:20:06.371574580 +0900
+++ higan/fc/cartridge/board/konami-vrc2.cpp	2015-09-16 13:08:13.528563365 +0900
@@ -4,6 +4,7 @@
   struct Pinout {
     unsigned a0;
     unsigned a1;
+    unsigned chr_shift;
   } pinout;
 } settings;
 
@@ -12,7 +13,7 @@
 uint8 prg_read(unsigned addr) {
   if(addr < 0x6000) return cpu.mdr();
   if(addr < 0x8000) return vrc2.ram_read(addr);
-  return prgrom.read(vrc2.prg_addr(addr));
+  return read(prgrom, vrc2.prg_addr(addr));
 }
 
 void prg_write(unsigned addr, uint8 data) {
@@ -28,7 +29,9 @@
 
 uint8 chr_read(unsigned addr) {
   if(addr & 0x2000) return ppu.ciram_read(vrc2.ciram_addr(addr));
-  return Board::chr_read(vrc2.chr_addr(addr));
+  addr = vrc2.chr_addr(addr);
+  addr = ((addr >> settings.pinout.chr_shift) & ~0x3ff) | (addr & 0x3ff);
+  return Board::chr_read(addr);
 }
 
 void chr_write(unsigned addr, uint8 data) {
@@ -49,9 +52,10 @@
   vrc2.serialize(s);
 }
 
-KonamiVRC2(Markup::Node& document) : Board(document), vrc2(*this) {
-  settings.pinout.a0 = 1 << document["cartridge/chip/pinout/a0"].decimal();
-  settings.pinout.a1 = 1 << document["cartridge/chip/pinout/a1"].decimal();
+KonamiVRC2(Markup::Node& cartridge) : Board(cartridge), vrc2(*this) {
+  settings.pinout.a0 = 1 << decimal(cartridge["chip/pinout/a0"].text());
+  settings.pinout.a1 = 1 << decimal(cartridge["chip/pinout/a1"].text());
+  settings.pinout.chr_shift = decimal(cartridge["chip/pinout/chr-shift"].text());
 }
 
 };
diff -Nru higan/fc/cartridge/board/konami-vrc3.cpp higan/fc/cartridge/board/konami-vrc3.cpp
--- higan/fc/cartridge/board/konami-vrc3.cpp	2015-09-16 02:20:06.371574580 +0900
+++ higan/fc/cartridge/board/konami-vrc3.cpp	2015-09-16 13:08:13.534563366 +0900
@@ -6,35 +6,35 @@
 
 VRC3 vrc3;
 
-void main() {
-  vrc3.main();
+void enter() {
+  vrc3.enter();
 }
 
 uint8 prg_read(unsigned addr) {
-  if((addr & 0xe000) == 0x6000) return prgram.read(addr & 0x1fff);
-  if(addr & 0x8000) return prgrom.read(vrc3.prg_addr(addr));
+  if((addr & 0xe000) == 0x6000) return read(prgram, addr & 0x1fff);
+  if(addr & 0x8000) return read(prgrom, vrc3.prg_addr(addr));
   return cpu.mdr();
 }
 
 void prg_write(unsigned addr, uint8 data) {
-  if((addr & 0xe000) == 0x6000) return prgram.write(addr & 0x1fff, data);
+  if((addr & 0xe000) == 0x6000) return write(prgram, addr & 0x1fff, data);
   if(addr & 0x8000) return vrc3.reg_write(addr, data);
 }
 
 uint8 chr_read(unsigned addr) {
   if(addr & 0x2000) {
     if(settings.mirror == 0) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
-    return ppu.ciram_read(addr & 0x07ff);
+    return ppu.ciram_read(addr);
   }
-  return chrram.read(addr);
+  return Board::chr_read(addr);
 }
 
 void chr_write(unsigned addr, uint8 data) {
   if(addr & 0x2000) {
     if(settings.mirror == 0) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
-    return ppu.ciram_write(addr & 0x07ff, data);
+    return ppu.ciram_write(addr, data);
   }
-  return chrram.write(addr, data);
+  return Board::chr_write(addr, data);
 }
 
 void power() {
@@ -50,8 +50,8 @@
   vrc3.serialize(s);
 }
 
-KonamiVRC3(Markup::Node& document) : Board(document), vrc3(*this) {
-  settings.mirror = document["cartridge/mirror/mode"].text() == "vertical" ? 1 : 0;
+KonamiVRC3(Markup::Node& cartridge) : Board(cartridge), vrc3(*this) {
+  settings.mirror = cartridge["mirror/mode"].text() == "vertical" ? 1 : 0;
 }
 
 };
diff -Nru higan/fc/cartridge/board/konami-vrc4.cpp higan/fc/cartridge/board/konami-vrc4.cpp
--- higan/fc/cartridge/board/konami-vrc4.cpp	2015-09-16 02:20:06.371574580 +0900
+++ higan/fc/cartridge/board/konami-vrc4.cpp	2015-09-16 13:08:13.530563365 +0900
@@ -9,23 +9,23 @@
 
 VRC4 vrc4;
 
-void main() {
-  return vrc4.main();
+void enter() {
+  return vrc4.enter();
 }
 
 uint8 prg_read(unsigned addr) {
   if(addr < 0x6000) return cpu.mdr();
-  if(addr < 0x8000) return prgram.read(addr);
-  return prgrom.read(vrc4.prg_addr(addr));
+  if(addr < 0x8000) return read(prgram, addr);
+  return read(prgrom, vrc4.prg_addr(addr));
 }
 
 void prg_write(unsigned addr, uint8 data) {
   if(addr < 0x6000) return;
-  if(addr < 0x8000) return prgram.write(addr, data);
+  if(addr < 0x8000) return write(prgram, addr, data);
 
   bool a0 = (addr & settings.pinout.a0);
   bool a1 = (addr & settings.pinout.a1);
-  addr &= 0xfff0;
+  addr &= 0xff00;
   addr |= (a1 << 1) | (a0 << 0);
   return vrc4.reg_write(addr, data);
 }
@@ -53,9 +53,9 @@
   vrc4.serialize(s);
 }
 
-KonamiVRC4(Markup::Node& document) : Board(document), vrc4(*this) {
-  settings.pinout.a0 = 1 << document["cartridge/chip/pinout/a0"].decimal();
-  settings.pinout.a1 = 1 << document["cartridge/chip/pinout/a1"].decimal();
+KonamiVRC4(Markup::Node& cartridge) : Board(cartridge), vrc4(*this) {
+  settings.pinout.a0 = 1 << decimal(cartridge["chip/pinout/a0"].text());
+  settings.pinout.a1 = 1 << decimal(cartridge["chip/pinout/a1"].text());
 }
 
 };
diff -Nru higan/fc/cartridge/board/konami-vrc6.cpp higan/fc/cartridge/board/konami-vrc6.cpp
--- higan/fc/cartridge/board/konami-vrc6.cpp	2015-09-16 02:20:06.371574580 +0900
+++ higan/fc/cartridge/board/konami-vrc6.cpp	2015-09-16 13:08:13.530563365 +0900
@@ -1,20 +1,29 @@
 struct KonamiVRC6 : Board {
 
+struct Settings {
+  struct Pinout {
+    unsigned a0;
+    unsigned a1;
+  } pinout;
+} settings;
+
 VRC6 vrc6;
 
 uint8 prg_read(unsigned addr) {
-  if((addr & 0xe000) == 0x6000) return vrc6.ram_read(addr);
-  if(addr & 0x8000) return prgrom.read(vrc6.prg_addr(addr));
-  return cpu.mdr();
+  if(addr < 0x6000) return cpu.mdr();
+  if(addr < 0x8000) return vrc6.ram_read(addr);
+  return read(prgrom, vrc6.prg_addr(addr));
 }
 
 void prg_write(unsigned addr, uint8 data) {
-  if((addr & 0xe000) == 0x6000) return vrc6.ram_write(addr, data);
-  if(addr & 0x8000) {
-    addr = (addr & 0xf003);
-    if(prgram.size) addr = (addr & ~3) | ((addr & 2) >> 1) | ((addr & 1) << 1);
-    return vrc6.reg_write(addr, data);
-  }
+  if(addr < 0x6000) return;
+  if(addr < 0x8000) return vrc6.ram_write(addr, data);
+
+  bool a0 = (addr & settings.pinout.a0);
+  bool a1 = (addr & settings.pinout.a1);
+  addr &= 0xf000;
+  addr |= (a1 << 1) | (a0 << 0);
+  return vrc6.reg_write(addr, data);
 }
 
 uint8 chr_read(unsigned addr) {
@@ -32,11 +41,13 @@
   vrc6.serialize(s);
 }
 
-void main() { vrc6.main(); }
+void enter() { vrc6.enter(); }
 void power() { vrc6.power(); }
 void reset() { vrc6.reset(); }
 
-KonamiVRC6(Markup::Node& document) : Board(document), vrc6(*this) {
+KonamiVRC6(Markup::Node& cartridge) : Board(cartridge), vrc6(*this) {
+  settings.pinout.a0 = 1 << decimal(cartridge["chip/pinout/a0"].text());
+  settings.pinout.a1 = 1 << decimal(cartridge["chip/pinout/a1"].text());
 }
 
 };
diff -Nru higan/fc/cartridge/board/konami-vrc7.cpp higan/fc/cartridge/board/konami-vrc7.cpp
--- higan/fc/cartridge/board/konami-vrc7.cpp	2015-09-16 02:20:06.371574580 +0900
+++ higan/fc/cartridge/board/konami-vrc7.cpp	2015-09-16 13:08:13.530563365 +0900
@@ -2,30 +2,30 @@
 
 VRC7 vrc7;
 
-void main() {
-  return vrc7.main();
+void enter() {
+  return vrc7.enter();
 }
 
 uint8 prg_read(unsigned addr) {
   if(addr < 0x6000) return cpu.mdr();
-  if(addr < 0x8000) return prgram.read(addr);
-  return prgrom.read(vrc7.prg_addr(addr));
+  if(addr < 0x8000) return read(prgram, addr);
+  return read(prgrom, vrc7.prg_addr(addr));
 }
 
 void prg_write(unsigned addr, uint8 data) {
   if(addr < 0x6000) return;
-  if(addr < 0x8000) return prgram.write(addr, data);
+  if(addr < 0x8000) return write(prgram, addr, data);
   return vrc7.reg_write(addr, data);
 }
 
 uint8 chr_read(unsigned addr) {
   if(addr & 0x2000) return ppu.ciram_read(vrc7.ciram_addr(addr));
-  return chrram.read(vrc7.chr_addr(addr));
+  return Board::chr_read(vrc7.chr_addr(addr));
 }
 
 void chr_write(unsigned addr, uint8 data) {
   if(addr & 0x2000) return ppu.ciram_write(vrc7.ciram_addr(addr), data);
-  return chrram.write(vrc7.chr_addr(addr), data);
+  return Board::chr_write(vrc7.chr_addr(addr), data);
 }
 
 void power() {
@@ -41,7 +41,7 @@
   vrc7.serialize(s);
 }
 
-KonamiVRC7(Markup::Node& document) : Board(document), vrc7(*this) {
+KonamiVRC7(Markup::Node& cartridge) : Board(cartridge), vrc7(*this) {
 }
 
 };
diff -Nru higan/fc/cartridge/board/namco-163.cpp higan/fc/cartridge/board/namco-163.cpp
--- higan/fc/cartridge/board/namco-163.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/fc/cartridge/board/namco-163.cpp	2015-09-16 13:08:13.534563366 +0900
@@ -0,0 +1,49 @@
+struct Namco163 : Board {
+
+N163 n163;
+
+void enter() {
+  n163.enter();
+}
+
+uint8 prg_read(unsigned addr) {
+  n163.prg_read(addr);
+}
+
+void prg_write(unsigned addr, uint8 data) {
+  n163.prg_write(addr, data);
+}
+
+uint8 chr_read(unsigned addr) {
+  n163.chr_read(addr);
+}
+
+void chr_write(unsigned addr, uint8 data) {
+  n163.chr_write(addr, data);
+}
+
+void serialize(serializer& s) {
+  Board::serialize(s);
+  n163.serialize(s);
+}
+
+void power() {
+  n163.power();
+}
+
+void reset() {
+  n163.reset();
+}
+
+Namco163(Markup::Node& cartridge) : Board(cartridge), n163(*this, cartridge) {
+  chip = &n163;
+  string name = cartridge["chip/ram/name"].text();
+  unsigned size = cartridge["chip/ram/size"].decimal();
+  n163.ram.map(allocate<uint8>(size, 0xff), size);
+  if(!name.empty()) {
+    interface->loadRequest(ID::ChipRAM, name, false);
+    Famicom::cartridge.memory.append({ID::ChipRAM, name});
+  }
+}
+
+};
diff -Nru higan/fc/cartridge/board/namco-34xx.cpp higan/fc/cartridge/board/namco-34xx.cpp
--- higan/fc/cartridge/board/namco-34xx.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/fc/cartridge/board/namco-34xx.cpp	2015-09-16 13:08:13.532563365 +0900
@@ -0,0 +1,150 @@
+//NAMCOT-3401
+//NAMCOT-3406
+//NAMCOT-3407
+//NAMCOT-3413
+//NAMCOT-3414
+//NAMCOT-3415
+//NAMCOT-3416
+//NAMCOT-3417
+//NAMCOT-3425
+//NAMCOT-3443
+//NAMCOT-3446
+//NAMCOT-3451
+//NAMCOT-3453
+//NES-DEROM
+//NES-DE1ROM
+//NES-DRROM
+
+struct Namco34xx : Board {
+
+enum class Revision : unsigned {
+  Namco3401, // bankswitching used even if PRG is 32KB (バベルの塔/Tower of Babel)
+  Namco3406,
+  Namco3407,
+  Namco3413,
+  Namco3414,
+  Namco3415,
+  Namco3416,
+  Namco3417,
+  Namco3425,
+  Namco3443,
+  Namco3446,
+  Namco3451,
+  Namco3453,
+  DEROM,
+  DE1ROM,
+  DRROM,
+} revision;
+
+struct Settings {
+  bool mirror;  //0 = vertical, 1 = horizontal
+} settings;
+
+N108 n108;
+
+bool nametable; // for Namco3453, used only by Devil Man
+
+unsigned prg_addr(unsigned addr) {
+  if(revision == Revision::Namco3401 || prgrom.size() > 0x8000) return n108.prg_addr(addr);
+  else return addr & 0x7fff;
+}
+
+uint8 prg_read(unsigned addr) {
+  if(addr & 0x8000) return read(prgrom, prg_addr(addr));
+  return cpu.mdr();
+}
+
+void prg_write(unsigned addr, uint8 data) {
+  if(addr & 0x8000) {
+    n108.reg_write(addr, data);
+    if(revision == Revision::Namco3453) nametable = data & 0x40;
+  }
+}
+
+unsigned chr_addr(unsigned addr) {
+  switch(revision) {
+  case Revision::Namco3443:
+  case Revision::Namco3453:
+    return n108.chr_addr(addr) | ((addr & 0x1000) << 4);
+  case Revision::Namco3446:
+    if(addr <= 0x07ff) return (n108.chr_addr(0x1000) << 1) | (addr & 0x07ff);
+    if(addr <= 0x0fff) return (n108.chr_addr(0x1400) << 1) | (addr & 0x07ff);
+    if(addr <= 0x17ff) return (n108.chr_addr(0x1800) << 1) | (addr & 0x07ff);
+    if(addr <= 0x1fff) return (n108.chr_addr(0x1c00) << 1) | (addr & 0x07ff);
+  default:
+    return n108.chr_addr(addr);
+  }
+}
+
+uint8 chr_read(unsigned addr) {
+  if(revision == Revision::DRROM) {
+    if(addr & 0x2000) {
+      if(!(addr & 0x0800)) return ppu.ciram_read(addr & 0x07ff);
+      else                 return read(chrram, addr & 0x07ff);
+    }
+    return read(chrrom, n108.chr_addr(addr));
+  }
+  if(addr & 0x2000) return ppu.ciram_read(ciram_addr(addr));
+  return Board::chr_read(chr_addr(addr));
+}
+
+void chr_write(unsigned addr, uint8 data) {
+  if(revision == Revision::DRROM) {
+    if(addr & 0x2000) {
+      if(!(addr & 0x0800)) ppu.ciram_write(addr & 0x07ff, data);
+      else                 write(chrram, addr & 0x07ff, data);
+    }
+    return;
+  }
+  if(addr & 0x2000) return ppu.ciram_write(ciram_addr(addr), data);
+  return Board::chr_write(chr_addr(addr), data);
+}
+
+unsigned ciram_addr(unsigned addr) const {
+  switch(revision) {
+  default:
+    if(settings.mirror == 0) return ((addr & 0x0400) >> 0) | (addr & 0x03ff);
+    if(settings.mirror == 1) return ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+  case Revision::Namco3425:
+    return ((n108.chr_addr(addr & 0x1fff) & 0x8000) >> 5) | (addr & 0x03ff);
+  case Revision::Namco3453:
+    return (addr & 0x03ff) | (nametable ? 0x0400 : 0x0000);
+  }
+}
+
+void reset() {
+  nametable = 0;
+}
+
+void serialize(serializer& s) {
+  Board::serialize(s);
+  if(revision == Revision::Namco3453) s.integer(nametable);
+}
+
+Namco34xx(Markup::Node& cartridge) : Board(cartridge), n108(*this, cartridge) {
+  string type = cartridge["board/type"].text();
+  if(type.match("*3401")) revision = Revision::Namco3401;
+  if(type.match("*3406")) revision = Revision::Namco3406;
+  if(type.match("*3407")) revision = Revision::Namco3407;
+  if(type.match("*3413")) revision = Revision::Namco3413;
+  if(type.match("*3414")) revision = Revision::Namco3414;
+  if(type.match("*3415")) revision = Revision::Namco3415;
+  if(type.match("*3416")) revision = Revision::Namco3416;
+  if(type.match("*3417")) revision = Revision::Namco3417;
+  if(type.match("*3425")) revision = Revision::Namco3425;
+  if(type.match("*3443")) revision = Revision::Namco3443;
+  if(type.match("*3446")) revision = Revision::Namco3446;
+  if(type.match("*3451")) revision = Revision::Namco3451;
+  if(type.match("*3453")) revision = Revision::Namco3453;
+  if(type.match("*DEROM")) revision = Revision::DEROM;
+  if(type.match("*DE1ROM")) revision = Revision::DE1ROM;
+  if(type.match("*DRROM")) revision = Revision::DRROM;
+  if(type == "TENGEN-800002") revision = Revision::DEROM;
+  if(type == "TENGEN-800030") revision = Revision::DE1ROM;
+  if(type == "TENGEN-800004") revision = Revision::DRROM;
+
+  if(revision != Revision::Namco3425 && revision != Revision::Namco3453)
+    settings.mirror = cartridge["mirror/mode"].text() == "horizontal";
+}
+
+};
diff -Nru higan/fc/cartridge/board/nes-axrom.cpp higan/fc/cartridge/board/nes-axrom.cpp
--- higan/fc/cartridge/board/nes-axrom.cpp	2015-09-16 02:20:06.371574580 +0900
+++ higan/fc/cartridge/board/nes-axrom.cpp	2015-09-16 13:08:13.525563365 +0900
@@ -5,16 +5,25 @@
 
 struct NES_AxROM : Board {
 
+enum class Revision : unsigned {
+  AMROM,
+  ANROM,
+  AN1ROM,
+  AOROM,
+} revision;
+
 uint4 prg_bank;
 bool mirror_select;
 
 uint8 prg_read(unsigned addr) {
-  if(addr & 0x8000) return prgrom.read((prg_bank << 15) | (addr & 0x7fff));
+  if(addr & 0x8000) return read(prgrom, (prg_bank << 15) | (addr & 0x7fff));
   return cpu.mdr();
 }
 
 void prg_write(unsigned addr, uint8 data) {
   if(addr & 0x8000) {
+    // Bus conflicts
+    if(revision == Revision::AMROM) data &= prg_read(addr);
     prg_bank = data & 0x0f;
     mirror_select = data & 0x10;
   }
@@ -45,7 +54,12 @@
   s.integer(mirror_select);
 }
 
-NES_AxROM(Markup::Node& document) : Board(document) {
+NES_AxROM(Markup::Node& cartridge) : Board(cartridge) {
+  string type = cartridge["board/type"].text();
+  if(type.match("*AMROM*" )) revision = Revision::AMROM;
+  if(type.match("*ANROM*" )) revision = Revision::ANROM;
+  if(type.match("*AN1ROM*")) revision = Revision::AN1ROM;
+  if(type.match("*AOROM*" )) revision = Revision::AOROM;
 }
 
 };
diff -Nru higan/fc/cartridge/board/nes-bnrom.cpp higan/fc/cartridge/board/nes-bnrom.cpp
--- higan/fc/cartridge/board/nes-bnrom.cpp	2015-09-16 02:20:06.371574580 +0900
+++ higan/fc/cartridge/board/nes-bnrom.cpp	2015-09-16 13:08:13.525563365 +0900
@@ -1,25 +1,30 @@
-//NES-BN-ROM-01
+//IREM-BNROM
+//NES-BNROM
 
 struct NES_BNROM : Board {
 
 struct Settings {
-  bool mirror;  //0 = horizontal, 1 = vertical
+  bool mirror;  //0 = vertical, 1 = horizontal
 } settings;
 
 uint2 prg_bank;
 
 uint8 prg_read(unsigned addr) {
-  if(addr & 0x8000) return prgrom.read((prg_bank << 15) | (addr & 0x7fff));
+  if(addr & 0x8000) return read(prgrom, (prg_bank << 15) | (addr & 0x7fff));
   return cpu.mdr();
 }
 
 void prg_write(unsigned addr, uint8 data) {
-  if(addr & 0x8000) prg_bank = data & 0x03;
+  if(addr & 0x8000) {
+    // Bus conflicts
+    data &= prg_read(addr);
+    prg_bank = data & 0x03;
+  }
 }
 
 uint8 chr_read(unsigned addr) {
   if(addr & 0x2000) {
-    if(settings.mirror == 0) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    if(settings.mirror == 1) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
     return ppu.ciram_read(addr);
   }
   return Board::chr_read(addr);
@@ -27,7 +32,7 @@
 
 void chr_write(unsigned addr, uint8 data) {
   if(addr & 0x2000) {
-    if(settings.mirror == 0) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    if(settings.mirror == 1) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
     return ppu.ciram_write(addr, data);
   }
   return Board::chr_write(addr, data);
@@ -45,8 +50,8 @@
   s.integer(prg_bank);
 }
 
-NES_BNROM(Markup::Node& document) : Board(document) {
-  settings.mirror = document["cartridge/mirror/mode"].text() == "vertical" ? 1 : 0;
+NES_BNROM(Markup::Node& cartridge) : Board(cartridge) {
+  settings.mirror = cartridge["mirror/mode"].text() == "horizontal";
 }
 
 };
diff -Nru higan/fc/cartridge/board/nes-cnrom.cpp higan/fc/cartridge/board/nes-cnrom.cpp
--- higan/fc/cartridge/board/nes-cnrom.cpp	2015-09-16 02:20:06.371574580 +0900
+++ higan/fc/cartridge/board/nes-cnrom.cpp	1970-01-01 09:00:00.000000000 +0900
@@ -1,54 +0,0 @@
-//NES-CNROM
-
-struct NES_CNROM : Board {
-
-struct Settings {
-  bool mirror;  //0 = horizontal, 1 = vertical
-} settings;
-
-uint2 chr_bank;
-
-uint8 prg_read(unsigned addr) {
-  if(addr & 0x8000) return prgrom.read(addr & 0x7fff);
-  return cpu.mdr();
-}
-
-void prg_write(unsigned addr, uint8 data) {
-  if(addr & 0x8000) chr_bank = data & 0x03;
-}
-
-uint8 chr_read(unsigned addr) {
-  if(addr & 0x2000) {
-    if(settings.mirror == 0) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
-    return ppu.ciram_read(addr & 0x07ff);
-  }
-  addr = (chr_bank * 0x2000) + (addr & 0x1fff);
-  return Board::chr_read(addr);
-}
-
-void chr_write(unsigned addr, uint8 data) {
-  if(addr & 0x2000) {
-    if(settings.mirror == 0) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
-    return ppu.ciram_write(addr & 0x07ff, data);
-  }
-  addr = (chr_bank * 0x2000) + (addr & 0x1fff);
-  Board::chr_write(addr, data);
-}
-
-void power() {
-}
-
-void reset() {
-  chr_bank = 0;
-}
-
-void serialize(serializer& s) {
-  Board::serialize(s);
-  s.integer(chr_bank);
-}
-
-NES_CNROM(Markup::Node& document) : Board(document) {
-  settings.mirror = document["cartridge/mirror/mode"].text() == "vertical" ? 1 : 0;
-}
-
-};
diff -Nru higan/fc/cartridge/board/nes-cxrom.cpp higan/fc/cartridge/board/nes-cxrom.cpp
--- higan/fc/cartridge/board/nes-cxrom.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/fc/cartridge/board/nes-cxrom.cpp	2015-09-16 13:08:13.532563365 +0900
@@ -0,0 +1,94 @@
+//NES-CNROM
+//NES-CPROM
+
+struct NES_CxROM : Board {
+
+enum class Revision : unsigned {
+  CNROM,
+  CPROM,
+} revision;
+
+struct Settings {
+  bool mirror;  //0 = vertical, 1 = horizontal
+  bool security;
+  uint2 pass;
+} settings;
+
+uint2 chr_bank;
+
+uint8 prg_read(unsigned addr) {
+  if(addr & 0x8000) return read(prgrom, addr & 0x7fff);
+  return cpu.mdr();
+}
+
+void prg_write(unsigned addr, uint8 data) {
+  if(addr & 0x8000) {
+    data &= prg_read(addr); // Bus conflicts
+    chr_bank = data & 0x03;
+  }
+}
+
+uint8 chr_read(unsigned addr) {
+  if(addr & 0x2000) {
+    if(settings.mirror == 1) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    return ppu.ciram_read(addr);
+  }
+  if(settings.security) {
+    if(chr_bank != settings.pass) return ppu.status.mdr;
+  }
+  switch(revision) {
+  case Revision::CNROM:
+    addr = (chr_bank * 0x2000) + (addr & 0x1fff);
+    break;
+  case Revision::CPROM:
+    if(addr < 0x1000) addr = addr & 0x1fff;
+    else              addr = (chr_bank * 0x1000) + (addr & 0x0fff);
+    break;
+  }
+  return Board::chr_read(addr);
+}
+
+void chr_write(unsigned addr, uint8 data) {
+  if(addr & 0x2000) {
+    if(settings.mirror == 1) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    return ppu.ciram_write(addr, data);
+  }
+  switch(revision) {
+  case Revision::CNROM:
+    addr = (chr_bank * 0x2000) + (addr & 0x1fff);
+    break;
+  case Revision::CPROM:
+    if(addr < 0x1000) addr = addr & 0x1fff;
+    else              addr = (chr_bank * 0x1000) + (addr & 0x0fff);
+    break;
+  }
+  Board::chr_write(addr, data);
+}
+
+void power() {
+}
+
+void reset() {
+  chr_bank = 0;
+}
+
+void serialize(serializer& s) {
+  Board::serialize(s);
+  s.integer(chr_bank);
+}
+
+NES_CxROM(Markup::Node& cartridge) : Board(cartridge) {
+  string type = cartridge["board/type"].text();
+  if(type.match("*CNROM" )) revision = Revision::CNROM;
+  if(type.match("*CPROM" )) revision = Revision::CPROM;
+  if(type.match("*PT-554")) revision = Revision::CNROM;
+  if(type == "TENGEN-800008") revision = Revision::CNROM;
+
+  settings.mirror = cartridge["mirror/mode"].text() == "horizontal";
+  settings.security = (bool)cartridge["board/security"];
+  if(settings.security) {
+    settings.pass = cartridge["board/security/pass"].integer();
+  }
+}
+
+};
diff -Nru higan/fc/cartridge/board/nes-event.cpp higan/fc/cartridge/board/nes-event.cpp
--- higan/fc/cartridge/board/nes-event.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/fc/cartridge/board/nes-event.cpp	2015-09-16 13:08:13.527563365 +0900
@@ -0,0 +1,110 @@
+struct NES_Event : Board {
+
+MMC1 mmc1;
+uint2 prg_lock;
+uint30 irq_counter;
+uint4 dip;
+
+void enter() {
+  while(true) {
+    if(scheduler.sync == Scheduler::SynchronizeMode::All) {
+      scheduler.exit(Scheduler::ExitReason::SynchronizeEvent);
+    }
+
+    if(mmc1.writedelay) mmc1.writedelay--;
+    switch(prg_lock) {
+    case 0: if((mmc1.chr_bank[0] & 0x10) == 0x10) prg_lock++; break;
+    case 1: if((mmc1.chr_bank[0] & 0x10) == 0x00) prg_lock++; break;
+    case 2:
+      if((mmc1.chr_bank[0] & 0x10) == 0x00) irq_counter++;
+      if((mmc1.chr_bank[0] & 0x10) == 0x10) {
+        irq_counter = 0x00000000;
+        cpu.set_irq_line(0);
+      }
+      break;
+    }
+    if(irq_counter == (0x20000000 | (dip << 25))) cpu.set_irq_line(1);
+    tick();
+  }
+}
+
+unsigned prg_addr(unsigned addr) {
+  if(prg_lock < 2) return addr & 0x7fff;
+  switch(mmc1.chr_bank[0] & 0x08) {
+  case 0: return ((mmc1.chr_bank[0] & 0x06) << 14) | (addr & 0x7fff);
+  case 8: return mmc1.prg_addr(addr) | 0x20000;
+  }
+}
+
+uint8 prg_read(unsigned addr) {
+  if((addr & 0xe000) == 0x6000) {
+    if(mmc1.ram_disable) return 0x00;
+    if(prgram.size() > 0) return read(prgram, addr);
+  }
+
+  if(addr & 0x8000) {
+    return read(prgrom, prg_addr(addr));
+  }
+
+  return cpu.mdr();
+}
+
+void prg_write(unsigned addr, uint8 data) {
+  if((addr & 0xe000) == 0x6000) {
+    if(mmc1.ram_disable) return;
+    if(prgram.size() > 0) return write(prgram, addr, data);
+  }
+
+  if(addr & 0x8000) return mmc1.mmio_write(addr, data);
+}
+
+uint8 chr_read(unsigned addr) {
+  if(addr & 0x2000) return ppu.ciram_read(mmc1.ciram_addr(addr));
+  return Board::chr_read(addr);
+}
+
+void chr_write(unsigned addr, uint8 data) {
+  if(addr & 0x2000) return ppu.ciram_write(mmc1.ciram_addr(addr), data);
+  return Board::chr_write(addr, data);
+}
+
+void power() {
+  mmc1.power();
+}
+
+void reset() {
+  mmc1.reset();
+  prg_lock = 0;
+  irq_counter = 0x00000000;
+}
+
+void serialize(serializer& s) {
+  Board::serialize(s);
+  mmc1.serialize(s);
+  s.integer(prg_lock);
+  s.integer(irq_counter);
+}
+
+NES_Event(Markup::Node& cartridge) : Board(cartridge), mmc1(*this, cartridge) {
+  dip = interface->dipSettings(BML::unserialize({
+    "setting name=Time\n",
+    "  option value=4 name=6:14.96\n",
+    "  option value=0 name=4:59.97\n",
+    "  option value=1 name=5:18.71\n",
+    "  option value=2 name=5:37.46\n",
+    "  option value=3 name=5:56.21\n",
+    "  option value=5 name=6:33.71\n",
+    "  option value=6 name=6:52.45\n",
+    "  option value=7 name=7:11.20\n",
+    "  option value=8 name=7:29.95\n",
+    "  option value=9 name=7:48.70\n",
+    "  option value=10 name=8:07.44\n",
+    "  option value=11 name=8:26.19\n",
+    "  option value=12 name=8:44.94\n",
+    "  option value=13 name=9:03.69\n",
+    "  option value=14 name=9:22.44\n",
+    "  option value=15 name=9:41.18\n",
+  }));
+}
+
+};
diff -Nru higan/fc/cartridge/board/nes-exrom.cpp higan/fc/cartridge/board/nes-exrom.cpp
--- higan/fc/cartridge/board/nes-exrom.cpp	2015-09-16 02:20:06.371574580 +0900
+++ higan/fc/cartridge/board/nes-exrom.cpp	2015-09-16 13:08:13.527563365 +0900
@@ -9,8 +9,8 @@
 
 MMC5 mmc5;
 
-void main() {
-  mmc5.main();
+void enter() {
+  mmc5.enter();
 }
 
 uint8 prg_read(unsigned addr) {
@@ -46,8 +46,24 @@
   mmc5.serialize(s);
 }
 
-NES_ExROM(Markup::Node& document) : Board(document), mmc5(*this) {
-  revision = Revision::ELROM;
+NES_ExROM(Markup::Node& cartridge) : Board(cartridge), mmc5(*this, cartridge) {
+  chip = &mmc5;
+  if(cartridge["chip/ram"]) {
+    string name = cartridge["chip/ram/name"].text();
+    unsigned size = cartridge["chip/ram/size"].decimal();
+    mmc5.ram.map(allocate<uint8>(size, 0xff), size);
+    if(!name.empty()) {
+      interface->loadRequest(ID::ChipRAM, name, false);
+      Famicom::cartridge.memory.append({ID::ChipRAM, name});
+    }
+  } else {
+    mmc5.ram.map(allocate<uint8>(1024, 0xff), 1024);
+  }
+  string type = cartridge["board/type"].text();
+  if(type.match("*EKROM*")) revision = Revision::EKROM;
+  if(type.match("*ELROM*")) revision = Revision::ELROM;
+  if(type.match("*ETROM*")) revision = Revision::ETROM;
+  if(type.match("*EWROM*")) revision = Revision::EWROM;
 }
 
 };
diff -Nru higan/fc/cartridge/board/nes-fxrom.cpp higan/fc/cartridge/board/nes-fxrom.cpp
--- higan/fc/cartridge/board/nes-fxrom.cpp	2015-09-16 02:20:06.371574580 +0900
+++ higan/fc/cartridge/board/nes-fxrom.cpp	2015-09-16 13:08:13.525563365 +0900
@@ -14,14 +14,14 @@
 
 uint8 prg_read(unsigned addr) {
   if(addr < 0x6000) return cpu.mdr();
-  if(addr < 0x8000) return prgram.read(addr);
+  if(addr < 0x8000) return read(prgram, addr);
   unsigned bank = addr < 0xc000 ? prg_bank : (uint4)0x0f;
-  return prgrom.read((bank * 0x4000) | (addr & 0x3fff));
+  return read(prgrom, (bank * 0x4000) | (addr & 0x3fff));
 }
 
 void prg_write(unsigned addr, uint8 data) {
   if(addr < 0x6000) return;
-  if(addr < 0x8000) return prgram.write(addr, data);
+  if(addr < 0x8000) return write(prgram, addr, data);
 
   switch(addr & 0xf000) {
   case 0xa000: prg_bank = data & 0x0f; break;
@@ -84,8 +84,10 @@
   s.array(latch);
 }
 
-NES_FxROM(Markup::Node& document) : Board(document) {
-  revision = Revision::FKROM;
+NES_FxROM(Markup::Node& cartridge) : Board(cartridge) {
+  string type = cartridge["board/type"].text();
+  if(type.match("*FJROM*" )) revision = Revision::FJROM;
+  if(type.match("*FKROM*" )) revision = Revision::FKROM;
 }
 
 };
diff -Nru higan/fc/cartridge/board/nes-gxrom.cpp higan/fc/cartridge/board/nes-gxrom.cpp
--- higan/fc/cartridge/board/nes-gxrom.cpp	2015-09-16 02:20:06.371574580 +0900
+++ higan/fc/cartridge/board/nes-gxrom.cpp	2015-09-16 13:08:13.524563365 +0900
@@ -4,19 +4,21 @@
 struct NES_GxROM : Board {
 
 struct Settings {
-  bool mirror;  //0 = horizontal, 1 = vertical
+  bool mirror;  //0 = vertical, 1 = horizontal
 } settings;
 
 uint2 prg_bank;
 uint2 chr_bank;
 
 uint8 prg_read(unsigned addr) {
-  if(addr & 0x8000) return prgrom.read((prg_bank << 15) | (addr & 0x7fff));
+  if(addr & 0x8000) return read(prgrom, (prg_bank << 15) | (addr & 0x7fff));
   return cpu.mdr();
 }
 
 void prg_write(unsigned addr, uint8 data) {
   if(addr & 0x8000) {
+    // Bus conflicts
+    data &= prg_read(addr);
     prg_bank = (data & 0x30) >> 4;
     chr_bank = (data & 0x03) >> 0;
   }
@@ -24,8 +26,8 @@
 
 uint8 chr_read(unsigned addr) {
   if(addr & 0x2000) {
-    if(settings.mirror == 0) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
-    return ppu.ciram_read(addr & 0x07ff);
+    if(settings.mirror == 1) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    return ppu.ciram_read(addr);
   }
   addr = (chr_bank * 0x2000) + (addr & 0x1fff);
   return Board::chr_read(addr);
@@ -33,8 +35,8 @@
 
 void chr_write(unsigned addr, uint8 data) {
   if(addr & 0x2000) {
-    if(settings.mirror == 0) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
-    return ppu.ciram_write(addr & 0x07ff, data);
+    if(settings.mirror == 1) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    return ppu.ciram_write(addr, data);
   }
   addr = (chr_bank * 0x2000) + (addr & 0x1fff);
   Board::chr_write(addr, data);
@@ -54,8 +56,8 @@
   s.integer(chr_bank);
 }
 
-NES_GxROM(Markup::Node& document) : Board(document) {
-  settings.mirror = document["cartridge/mirror/mode"].text() == "vertical" ? 1 : 0;
+NES_GxROM(Markup::Node& cartridge) : Board(cartridge) {
+  settings.mirror = cartridge["mirror/mode"].text() == "horizontal";
 }
 
 };
diff -Nru higan/fc/cartridge/board/nes-hkrom.cpp higan/fc/cartridge/board/nes-hkrom.cpp
--- higan/fc/cartridge/board/nes-hkrom.cpp	2015-09-16 02:20:06.371574580 +0900
+++ higan/fc/cartridge/board/nes-hkrom.cpp	2015-09-16 13:08:13.528563365 +0900
@@ -2,13 +2,13 @@
 
 MMC6 mmc6;
 
-void main() {
-  mmc6.main();
+void enter() {
+  mmc6.enter();
 }
 
 uint8 prg_read(unsigned addr) {
   if((addr & 0xf000) == 0x7000) return mmc6.ram_read(addr);
-  if(addr & 0x8000) return prgrom.read(mmc6.prg_addr(addr));
+  if(addr & 0x8000) return read(prgrom, mmc6.prg_addr(addr));
   return cpu.mdr();
 }
 
@@ -42,7 +42,7 @@
   mmc6.serialize(s);
 }
 
-NES_HKROM(Markup::Node& document) : Board(document), mmc6(*this) {
+NES_HKROM(Markup::Node& cartridge) : Board(cartridge), mmc6(*this) {
 }
 
 };
diff -Nru higan/fc/cartridge/board/nes-nrom.cpp higan/fc/cartridge/board/nes-nrom.cpp
--- higan/fc/cartridge/board/nes-nrom.cpp	2015-09-16 02:20:06.371574580 +0900
+++ higan/fc/cartridge/board/nes-nrom.cpp	2015-09-16 13:08:13.524563365 +0900
@@ -1,43 +1,71 @@
+//NES-FAMILYBASIC
+//NES-HROM
 //NES-NROM-128
 //NES-NROM-256
+//NES-RROM
+//NES-RROM-128
+//NES-RTROM
+//NES-SROM
+//NES-STROM
 
 struct NES_NROM : Board {
 
+enum class Revision : unsigned {
+  FAMILYBASIC,
+  HROM,
+  NROM,
+  RROM,
+  RTROM,
+  SROM,
+  STROM,
+} revision;
+
 struct Settings {
-  bool mirror;  //0 = horizontal, 1 = vertical
+  bool mirror;  //0 = vertical, 1 = horizontal
 } settings;
 
 uint8 prg_read(unsigned addr) {
-  if(addr & 0x8000) return prgrom.read(addr);
+  if((addr & 0x8000) == 0x8000) return read(prgrom, addr);
+  if(revision == Revision::FAMILYBASIC && (addr & 0xe000) == 0x6000)
+    return read(prgram, addr);
   return cpu.mdr();
 }
 
 void prg_write(unsigned addr, uint8 data) {
+  if(revision == Revision::FAMILYBASIC && (addr & 0xe000) == 0x6000)
+    write(prgram, addr, data);
 }
 
 uint8 chr_read(unsigned addr) {
   if(addr & 0x2000) {
-    if(settings.mirror == 0) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    if(settings.mirror == 1) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
     return ppu.ciram_read(addr & 0x07ff);
   }
-  if(chrram.size) return chrram.read(addr);
-  return chrrom.read(addr);
+  return Board::chr_read(addr);
 }
 
 void chr_write(unsigned addr, uint8 data) {
   if(addr & 0x2000) {
-    if(settings.mirror == 0) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
-    return ppu.ciram_write(addr & 0x07ff, data);
+    if(settings.mirror == 1) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    return ppu.ciram_write(addr, data);
   }
-  if(chrram.size) return chrram.write(addr, data);
+  return Board::chr_write(addr, data);
 }
 
 void serialize(serializer& s) {
   Board::serialize(s);
 }
 
-NES_NROM(Markup::Node& document) : Board(document) {
-  settings.mirror = document["cartridge/mirror/mode"].text() == "vertical" ? 1 : 0;
+NES_NROM(Markup::Node& cartridge) : Board(cartridge) {
+  string type = cartridge["board/type"].text();
+  if(type.match("*FAMILYBASIC*")) revision = Revision::FAMILYBASIC;
+  if(type.match("*HROM*"       )) revision = Revision::HROM;
+  if(type.match("*RROM*"       )) revision = Revision::RROM;
+  if(type.match("*SROM*"       )) revision = Revision::SROM;
+  if(revision == Revision::HROM)
+    settings.mirror = 0;
+  else
+    settings.mirror = cartridge["mirror/mode"].text() == "horizontal";
 }
 
 };
diff -Nru higan/fc/cartridge/board/nes-pxrom.cpp higan/fc/cartridge/board/nes-pxrom.cpp
--- higan/fc/cartridge/board/nes-pxrom.cpp	2015-09-16 02:20:06.371574580 +0900
+++ higan/fc/cartridge/board/nes-pxrom.cpp	2015-09-16 13:08:13.531563365 +0900
@@ -14,7 +14,7 @@
 
 uint8 prg_read(unsigned addr) {
   if(addr < 0x6000) return cpu.mdr();
-  if(addr < 0x8000) return prgram.read(addr);
+  if(addr < 0x8000) return read(prgram, addr);
   unsigned bank = 0;
   switch((addr / 0x2000) & 3) {
   case 0: bank = prg_bank; break;
@@ -22,12 +22,12 @@
   case 2: bank = 0x0e; break;
   case 3: bank = 0x0f; break;
   }
-  return prgrom.read((bank * 0x2000) | (addr & 0x1fff));
+  return read(prgrom, (bank * 0x2000) | (addr & 0x1fff));
 }
 
 void prg_write(unsigned addr, uint8 data) {
   if(addr < 0x6000) return;
-  if(addr < 0x8000) return prgram.write(addr, data);
+  if(addr < 0x8000) return write(prgram, addr, data);
 
   switch(addr & 0xf000) {
   case 0xa000: prg_bank = data & 0x0f; break;
@@ -90,8 +90,10 @@
   s.array(latch);
 }
 
-NES_PxROM(Markup::Node& document) : Board(document) {
-  revision = Revision::PNROM;
+NES_PxROM(Markup::Node& cartridge) : Board(cartridge) {
+  string type = cartridge["board/type"].text();
+  if(type.match("*PEEOROM*")) revision = Revision::PEEOROM;
+  if(type.match("*PNROM*"  )) revision = Revision::PNROM;
 }
 
 };
diff -Nru higan/fc/cartridge/board/nes-qj.cpp higan/fc/cartridge/board/nes-qj.cpp
--- higan/fc/cartridge/board/nes-qj.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/fc/cartridge/board/nes-qj.cpp	2015-09-16 13:08:13.531563365 +0900
@@ -0,0 +1,57 @@
+struct NES_QJ : Board {
+
+MMC3 mmc3;
+bool bank;
+
+void enter() {
+  mmc3.enter();
+}
+
+uint8 prg_read(unsigned addr) {
+  if(addr & 0x8000) {
+    addr = (mmc3.prg_addr(addr) & 0x1ffff) | (bank << 17);
+    return read(prgrom, addr);
+  }
+  return cpu.mdr();
+}
+
+void prg_write(unsigned addr, uint8 data) {
+  if((addr & 0xe000) == 0x6000 && mmc3.ram_enable && !mmc3.ram_write_protect) {
+    bank = data & 0x01;
+  }
+  if(addr & 0x8000) return mmc3.reg_write(addr, data);
+}
+
+uint8 chr_read(unsigned addr) {
+  if(addr & 0x2000) return ppu.ciram_read(mmc3.ciram_addr(addr));
+  return Board::chr_read((mmc3.chr_addr(addr) & 0x1ffff) | (bank << 17));
+}
+
+void chr_write(unsigned addr, uint8 data) {
+  if(addr & 0x2000) return ppu.ciram_write(mmc3.ciram_addr(addr), data);
+  return Board::chr_write((mmc3.chr_addr(addr) & 0x1ffff) | (bank << 17), data);
+}
+
+unsigned ciram_addr(unsigned addr) {
+  return mmc3.ciram_addr(addr);
+}
+
+void power() {
+  mmc3.power();
+}
+
+void reset() {
+  mmc3.reset();
+  bank = 0;
+}
+
+void serialize(serializer& s) {
+  Board::serialize(s);
+  mmc3.serialize(s);
+  s.integer(bank);
+}
+
+NES_QJ(Markup::Node& cartridge) : Board(cartridge), mmc3(*this, cartridge) {
+}
+
+};
diff -Nru higan/fc/cartridge/board/nes-sxrom.cpp higan/fc/cartridge/board/nes-sxrom.cpp
--- higan/fc/cartridge/board/nes-sxrom.cpp	2015-09-16 02:20:06.372574580 +0900
+++ higan/fc/cartridge/board/nes-sxrom.cpp	2015-09-16 13:08:13.533563366 +0900
@@ -7,6 +7,8 @@
   SC1ROM,
   SEROM,
   SFROM,
+  SF1ROM,
+  SFEXPROM,
   SGROM,
   SHROM,
   SH1ROM,
@@ -20,6 +22,7 @@
   SLRROM,
   SMROM,
   SNROM,
+  SNWEPROM,
   SOROM,
   SUROM,
   SXROM,
@@ -27,14 +30,13 @@
 
 MMC1 mmc1;
 
-void main() {
-  return mmc1.main();
+void enter() {
+  mmc1.enter();
 }
 
 unsigned ram_addr(unsigned addr) {
   unsigned bank = 0;
   if(revision == Revision::SOROM) bank = (mmc1.chr_bank[0] & 0x08) >> 3;
-  if(revision == Revision::SUROM) bank = (mmc1.chr_bank[0] & 0x0c) >> 2;
   if(revision == Revision::SXROM) bank = (mmc1.chr_bank[0] & 0x0c) >> 2;
   return (bank << 13) | (addr & 0x1fff);
 }
@@ -42,18 +44,26 @@
 uint8 prg_read(unsigned addr) {
   if((addr & 0xe000) == 0x6000) {
     if(revision == Revision::SNROM) {
-      if(mmc1.chr_bank[0] & 0x10) return cpu.mdr();
+      if((mmc1.chr_addr(ppu.status.chr_abus) >> 16) & 1) return cpu.mdr();
     }
-    if(mmc1.ram_disable) return 0x00;
-    return prgram.read(ram_addr(addr));
+    if(mmc1.ram_disable) return cpu.mdr();
+    if(prgram.size() > 0) return read(prgram, ram_addr(addr));
   }
 
   if(addr & 0x8000) {
-    addr = mmc1.prg_addr(addr);
-    if(revision == Revision::SXROM) {
-      addr |= ((mmc1.chr_bank[0] & 0x10) >> 4) << 18;
+    switch(revision) {
+    case Revision::SEROM:
+    case Revision::SHROM:
+    case Revision::SH1ROM:
+      break;
+    default:
+      addr = mmc1.prg_addr(addr);
+      if(revision == Revision::SUROM || revision == Revision::SXROM) {
+        addr |= ((mmc1.chr_addr(ppu.status.chr_abus) >> 16) & 1) << 18;
+      }
+      break;
     }
-    return prgrom.read(addr);
+    return read(prgrom, addr);
   }
 
   return cpu.mdr();
@@ -65,7 +75,7 @@
       if(mmc1.chr_bank[0] & 0x10) return;
     }
     if(mmc1.ram_disable) return;
-    return prgram.write(ram_addr(addr), data);
+    if(prgram.size() > 0) return write(prgram, ram_addr(addr), data);
   }
 
   if(addr & 0x8000) return mmc1.mmio_write(addr, data);
@@ -94,8 +104,33 @@
   mmc1.serialize(s);
 }
 
-NES_SxROM(Markup::Node& document) : Board(document), mmc1(*this) {
-  revision = Revision::SXROM;
+NES_SxROM(Markup::Node& cartridge) : Board(cartridge), mmc1(*this, cartridge) {
+  string type = cartridge["board/type"].text();
+  if(type.match("*SAROM"   )) revision = Revision::SAROM;
+  if(type.match("*SBROM"   )) revision = Revision::SBROM;
+  if(type.match("*SCROM"   )) revision = Revision::SCROM;
+  if(type.match("*SC1ROM"  )) revision = Revision::SC1ROM;
+  if(type.match("*SEROM"   )) revision = Revision::SEROM;
+  if(type.match("*SFROM"   )) revision = Revision::SFROM;
+  if(type.match("*SF1ROM"  )) revision = Revision::SF1ROM;
+  if(type.match("*SFEXPROM")) revision = Revision::SFEXPROM;
+  if(type.match("*SGROM"   )) revision = Revision::SGROM;
+  if(type.match("*SHROM"   )) revision = Revision::SHROM;
+  if(type.match("*SH1ROM"  )) revision = Revision::SH1ROM;
+  if(type.match("*SIROM"   )) revision = Revision::SIROM;
+  if(type.match("*SJROM"   )) revision = Revision::SJROM;
+  if(type.match("*SKROM"   )) revision = Revision::SKROM;
+  if(type.match("*SLROM"   )) revision = Revision::SLROM;
+  if(type.match("*SL1ROM"  )) revision = Revision::SL1ROM;
+  if(type.match("*SL2ROM"  )) revision = Revision::SL2ROM;
+  if(type.match("*SL3ROM"  )) revision = Revision::SL3ROM;
+  if(type.match("*SLRROM"  )) revision = Revision::SLRROM;
+  if(type.match("*SMROM"   )) revision = Revision::SMROM;
+  if(type.match("*SNROM"   )) revision = Revision::SNROM;
+  if(type.match("*SNWEPROM")) revision = Revision::SNWEPROM;
+  if(type.match("*SOROM"   )) revision = Revision::SOROM;
+  if(type.match("*SUROM"   )) revision = Revision::SUROM;
+  if(type.match("*SXROM"   )) revision = Revision::SXROM;
 }
 
 };
diff -Nru higan/fc/cartridge/board/nes-txrom.cpp higan/fc/cartridge/board/nes-txrom.cpp
--- higan/fc/cartridge/board/nes-txrom.cpp	2015-09-16 02:20:06.372574580 +0900
+++ higan/fc/cartridge/board/nes-txrom.cpp	2015-09-16 13:08:13.528563365 +0900
@@ -6,6 +6,7 @@
   TFROM,
   TGROM,
   TKROM,
+  TKEPROM,
   TKSROM,
   TLROM,
   TL1ROM,
@@ -16,37 +17,60 @@
   TR1ROM,
   TSROM,
   TVROM,
+  MCACC,
 } revision;
 
 MMC3 mmc3;
 
-void main() {
-  mmc3.main();
+void enter() {
+  mmc3.enter();
 }
 
 uint8 prg_read(unsigned addr) {
-  if((addr & 0xe000) == 0x6000) return mmc3.ram_read(addr);
-  if(addr & 0x8000) return prgrom.read(mmc3.prg_addr(addr));
+  if((addr & 0xe000) == 0x6000 && prgram.size() > 0) return mmc3.ram_read(addr);
+  if(addr & 0x8000) return read(prgrom, mmc3.prg_addr(addr));
   return cpu.mdr();
 }
 
 void prg_write(unsigned addr, uint8 data) {
-  if((addr & 0xe000) == 0x6000) return mmc3.ram_write(addr, data);
+  if((addr & 0xe000) == 0x6000 && prgram.size() > 0) return mmc3.ram_write(addr, data);
   if(addr & 0x8000) return mmc3.reg_write(addr, data);
 }
 
 uint8 chr_read(unsigned addr) {
-  mmc3.irq_test(addr);
-  if(addr & 0x2000) return ppu.ciram_read(mmc3.ciram_addr(addr));
+  if(revision == Revision::TR1ROM || revision == Revision::TVROM) {
+    if(addr & 0x2000) return read(chrram, addr & 0x0fff);
+    return read(chrrom, mmc3.chr_addr(addr));
+  }
+  if(addr & 0x2000) return ppu.ciram_read(ciram_addr(addr));
+  if(revision == Revision::TQROM) {
+    if(mmc3.chr_addr(addr) & (0x40 << 10))
+      return read(chrram, mmc3.chr_addr(addr));
+    else
+      return read(chrrom, mmc3.chr_addr(addr));
+  }
   return Board::chr_read(mmc3.chr_addr(addr));
 }
 
 void chr_write(unsigned addr, uint8 data) {
-  mmc3.irq_test(addr);
-  if(addr & 0x2000) return ppu.ciram_write(mmc3.ciram_addr(addr), data);
+  if(revision == Revision::TR1ROM || revision == Revision::TVROM) {
+    if(addr & 0x2000) write(chrram, addr & 0x0fff, data);
+    return;
+  }
+  if(addr & 0x2000) return ppu.ciram_write(ciram_addr(addr), data);
   return Board::chr_write(mmc3.chr_addr(addr), data);
 }
 
+unsigned ciram_addr(unsigned addr) {
+  switch(revision) {
+  default:
+    return mmc3.ciram_addr(addr);
+  case Revision::TKSROM:
+  case Revision::TLSROM:
+    return ((mmc3.chr_addr(addr & 0xfff) & 0x20000) >> 7) | (addr & 0x3ff);
+  }
+}
+
 void power() {
   mmc3.power();
 }
@@ -60,8 +84,25 @@
   mmc3.serialize(s);
 }
 
-NES_TxROM(Markup::Node& document) : Board(document), mmc3(*this) {
-  revision = Revision::TLROM;
+NES_TxROM(Markup::Node& cartridge) : Board(cartridge), mmc3(*this, cartridge) {
+  string type = cartridge["board/type"].text();
+  if(type.match("*TBROM"  )) revision = Revision::TBROM;
+  if(type.match("*TEROM"  )) revision = Revision::TEROM;
+  if(type.match("*TFROM"  )) revision = Revision::TFROM;
+  if(type.match("*TGROM"  )) revision = Revision::TGROM;
+  if(type.match("*TKROM"  )) revision = Revision::TKROM;
+  if(type.match("*TKEPROM")) revision = Revision::TKEPROM;
+  if(type.match("*TKSROM" )) revision = Revision::TKSROM;
+  if(type.match("*TLROM"  )) revision = Revision::TLROM;
+  if(type.match("*TL1ROM" )) revision = Revision::TL1ROM;
+  if(type.match("*TL2ROM" )) revision = Revision::TL2ROM;
+  if(type.match("*TLSROM" )) revision = Revision::TLSROM;
+  if(type.match("*TNROM"  )) revision = Revision::TNROM;
+  if(type.match("*TQROM"  )) revision = Revision::TQROM;
+  if(type.match("*TR1ROM" )) revision = Revision::TR1ROM;
+  if(type.match("*TSROM"  )) revision = Revision::TSROM;
+  if(type.match("*TVROM"  )) revision = Revision::TVROM;
+  if(type.match("*MC-ACC" )) revision = Revision::MCACC;
 }
 
 };
diff -Nru higan/fc/cartridge/board/nes-uxrom.cpp higan/fc/cartridge/board/nes-uxrom.cpp
--- higan/fc/cartridge/board/nes-uxrom.cpp	2015-09-16 02:20:06.372574580 +0900
+++ higan/fc/cartridge/board/nes-uxrom.cpp	2015-09-16 13:08:13.527563365 +0900
@@ -1,27 +1,54 @@
 //NES-UNROM
+//NES-UN1ROM
 //NES-UOROM
 
 struct NES_UxROM : Board {
 
+enum class Revision : unsigned {
+  UNROM,
+  UN1ROM,
+  UOROM,
+} revision;
+
+enum class ChipType : unsigned {
+  _7432,
+  _7408,
+} chip_type;
+
 struct Settings {
-  bool mirror;  //0 = horizontal, 1 = vertical
+  bool mirror;    //0 = vertical, 1 = horizontal
 } settings;
 
 uint4 prg_bank;
 
 uint8 prg_read(unsigned addr) {
-  if((addr & 0xc000) == 0x8000) return prgrom.read((prg_bank << 14) | (addr & 0x3fff));
-  if((addr & 0xc000) == 0xc000) return prgrom.read((    0x0f << 14) | (addr & 0x3fff));
-  return cpu.mdr();
+  if((addr & 0x8000) == 0x0000) return cpu.mdr();
+  switch(chip_type) {
+  case ChipType::_7432:
+    switch(addr & 0xc000) {
+    case 0x8000: return read(prgrom, (prg_bank << 14) | (addr & 0x3fff));
+    case 0xc000: return read(prgrom, (    0x0f << 14) | (addr & 0x3fff));
+    }
+  case ChipType::_7408:
+    switch(addr & 0xc000) {
+    case 0x8000: return read(prgrom, (    0x00 << 14) | (addr & 0x3fff));
+    case 0xc000: return read(prgrom, (prg_bank << 14) | (addr & 0x3fff));
+    }
+  }
 }
 
 void prg_write(unsigned addr, uint8 data) {
-  if(addr & 0x8000) prg_bank = data & 0x0f;
+  if(addr & 0x8000) {
+    // Bus conflicts
+    data &= prg_read(addr);
+    if(revision != Revision::UN1ROM) prg_bank = data & 0x0f;
+    if(revision == Revision::UN1ROM) prg_bank = (data & 0x1c) >> 2;
+  }
 }
 
 uint8 chr_read(unsigned addr) {
   if(addr & 0x2000) {
-    if(settings.mirror == 0) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    if(settings.mirror == 1) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
     return ppu.ciram_read(addr);
   }
   return Board::chr_read(addr);
@@ -29,7 +56,7 @@
 
 void chr_write(unsigned addr, uint8 data) {
   if(addr & 0x2000) {
-    if(settings.mirror == 0) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    if(settings.mirror == 1) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
     return ppu.ciram_write(addr, data);
   }
   return Board::chr_write(addr, data);
@@ -48,8 +75,15 @@
   s.integer(prg_bank);
 }
 
-NES_UxROM(Markup::Node& document) : Board(document) {
-  settings.mirror = document["cartridge/mirror/mode"].text() == "vertical" ? 1 : 0;
+NES_UxROM(Markup::Node& cartridge) : Board(cartridge) {
+  settings.mirror = cartridge["mirror/mode"].text() == "horizontal";
+  string type = cartridge["board/type"].text();
+  if(type.match("*UNROM" )) revision = Revision::UNROM;
+  if(type.match("*UN1ROM")) revision = Revision::UN1ROM;
+  if(type.match("*UOROM" )) revision = Revision::UOROM;
+  type = cartridge["chip/type"].text();
+  if(type.match("74*32")) chip_type = ChipType::_7432;
+  if(type.match("74*08")) chip_type = ChipType::_7408;
 }
 
 };
diff -Nru higan/fc/cartridge/board/pal-zz.cpp higan/fc/cartridge/board/pal-zz.cpp
--- higan/fc/cartridge/board/pal-zz.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/fc/cartridge/board/pal-zz.cpp	2015-09-16 13:08:13.534563366 +0900
@@ -0,0 +1,69 @@
+struct PAL_ZZ : Board {
+
+MMC3 mmc3;
+uint2 prg_a16_force;
+bool bank;
+
+void enter() {
+  mmc3.enter();
+}
+
+uint8 prg_read(unsigned addr) {
+  if(addr & 0x8000) {
+    addr = (mmc3.prg_addr(addr) & (0xffff | (bank << 16))) | (bank << 17);
+    addr |= (prg_a16_force == 0x03) << 16;
+    return read(prgrom, addr);
+  }
+  return cpu.mdr();
+}
+
+void prg_write(unsigned addr, uint8 data) {
+  if((addr & 0xe000) == 0x6000 && mmc3.ram_enable && !mmc3.ram_write_protect) {
+    prg_a16_force = data & 0x03;
+    bank = data & 0x04;
+  }
+  if(addr & 0x8000) return mmc3.reg_write(addr, data);
+}
+
+uint8 chr_read(unsigned addr) {
+  if(addr & 0x2000) return ppu.ciram_read(mmc3.ciram_addr(addr));
+  return Board::chr_read((mmc3.chr_addr(addr) & 0x1ffff) | (bank << 17));
+}
+
+void chr_write(unsigned addr, uint8 data) {
+  if(addr & 0x2000) return ppu.ciram_write(mmc3.ciram_addr(addr), data);
+  return Board::chr_write((mmc3.chr_addr(addr) & 0x1ffff) | (bank << 17), data);
+}
+
+unsigned ciram_addr(unsigned addr) {
+  return mmc3.ciram_addr(addr);
+}
+
+void power() {
+  mmc3.power();
+}
+
+void reset() {
+  mmc3.reset();
+  cic_reset();
+}
+
+void cic_reset() {
+  // this register is cleared by the CIC reset line.
+  // On a Famicom or toploader, only a power cycle can clear it.
+  //TODO: Check if Europe got the toploader.
+  prg_a16_force = 0;
+  bank = 0;
+}
+
+void serialize(serializer& s) {
+  Board::serialize(s);
+  mmc3.serialize(s);
+  s.integer(prg_a16_force);
+  s.integer(bank);
+}
+
+PAL_ZZ(Markup::Node& cartridge) : Board(cartridge), mmc3(*this, cartridge) {
+}
+
+};
diff -Nru higan/fc/cartridge/board/sunsoft-4.cpp higan/fc/cartridge/board/sunsoft-4.cpp
--- higan/fc/cartridge/board/sunsoft-4.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/fc/cartridge/board/sunsoft-4.cpp	2015-09-16 13:08:13.527563365 +0900
@@ -0,0 +1,87 @@
+//SUNSOFT-4
+
+struct Sunsoft4 : Board {
+
+uint8 chr_bank[4];
+uint7 ntrom_bank[2];
+uint2 mirror;
+bool nametable_mode;
+uint8 prg_bank;
+
+uint8 prg_read(unsigned addr) {
+  if((addr & 0xc000) == 0x8000) return read(prgrom, (prg_bank << 14) | (addr & 0x3fff));
+  if((addr & 0xc000) == 0xc000) return read(prgrom, (    0xff << 14) | (addr & 0x3fff));
+  return cpu.mdr();
+}
+
+void prg_write(unsigned addr, uint8 data) {
+  switch(addr & 0xf000) {
+  case 0x8000: chr_bank[0] = data; break;
+  case 0x9000: chr_bank[1] = data; break;
+  case 0xa000: chr_bank[2] = data; break;
+  case 0xb000: chr_bank[3] = data; break;
+  case 0xc000: ntrom_bank[0] = data | 0x80; break;
+  case 0xd000: ntrom_bank[1] = data | 0x80; break;
+  case 0xe000:
+    mirror = data & 0x03;
+    nametable_mode = data & 0x10;
+    break;
+  case 0xf000: prg_bank = data; break;
+  }
+}
+
+unsigned ciram_addr(unsigned addr) {
+  switch(mirror) {
+  case 0: return ((addr & 0x0400) >> 0) | (addr & 0x03ff);
+  case 1: return ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+  case 2: return 0x0000 | (addr & 0x03ff);
+  case 3: return 0x0400 | (addr & 0x03ff);
+  }
+}
+
+uint8 chr_read(unsigned addr) {
+  if(addr & 0x2000) {
+    addr = ciram_addr(addr);
+    if(nametable_mode) return Board::chr_read(((ntrom_bank[(addr & 0x0400) >> 10] | 0x80) << 10) | (addr & 0x03FF));
+    else               return ppu.ciram_read(addr);
+  }
+  addr = (chr_bank[(addr & 0x1800) >> 11] << 11) | (addr & 0x07ff);
+  return Board::chr_read(addr);
+}
+
+void chr_write(unsigned addr, uint8 data) {
+  if(addr & 0x2000) {
+    if(nametable_mode == 0) return ppu.ciram_write(ciram_addr(addr), data);
+  } else {
+    return Board::chr_write(addr, data);
+  }
+}
+
+void power() {
+}
+
+void reset() {
+  chr_bank[0] = 0;
+  chr_bank[1] = 0;
+  chr_bank[2] = 0;
+  chr_bank[3] = 0;
+  ntrom_bank[0] = 0;
+  ntrom_bank[1] = 0;
+  mirror = 0;
+  nametable_mode = 0;
+  prg_bank = 0;
+}
+
+void serialize(serializer& s) {
+  Board::serialize(s);
+  s.array(chr_bank);
+  s.array(ntrom_bank);
+  s.integer(mirror);
+  s.integer(nametable_mode);
+  s.integer(prg_bank);
+}
+
+Sunsoft4(Markup::Node& cartridge) : Board(cartridge) {
+}
+
+};
diff -Nru higan/fc/cartridge/board/sunsoft-5b.cpp higan/fc/cartridge/board/sunsoft-5b.cpp
--- higan/fc/cartridge/board/sunsoft-5b.cpp	2015-09-16 02:20:06.372574580 +0900
+++ higan/fc/cartridge/board/sunsoft-5b.cpp	2015-09-16 13:08:13.533563366 +0900
@@ -53,7 +53,7 @@
   }
 } pulse[3];
 
-void main() {
+void enter() {
   while(true) {
     if(scheduler.sync == Scheduler::SynchronizeMode::All) {
       scheduler.exit(Scheduler::ExitReason::SynchronizeEvent);
@@ -90,16 +90,15 @@
 
   if(ram_select) {
     if(ram_enable == false) return cpu.mdr();
-    return prgram.data[addr & 0x1fff];
+    return read(prgram, addr & 0x1fff);
   }
 
-  addr = (bank << 13) | (addr & 0x1fff);
-  return prgrom.read(addr);
+  return read(prgrom, (bank << 13) | (addr & 0x1fff));
 }
 
 void prg_write(unsigned addr, uint8 data) {
   if((addr & 0xe000) == 0x6000) {
-    prgram.data[addr & 0x1fff] = data;
+    write(prgram, addr & 0x1fff, data);
   }
 
   if(addr == 0x8000) {
@@ -220,7 +219,7 @@
   pulse[2].serialize(s);
 }
 
-Sunsoft5B(Markup::Node& document) : Board(document) {
+Sunsoft5B(Markup::Node& cartridge) : Board(cartridge) {
 }
 
 };
diff -Nru higan/fc/cartridge/board/taito-tc.cpp higan/fc/cartridge/board/taito-tc.cpp
--- higan/fc/cartridge/board/taito-tc.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/fc/cartridge/board/taito-tc.cpp	2015-09-16 13:08:13.530563365 +0900
@@ -0,0 +1,44 @@
+struct TaitoTC : Board {
+
+TC tc;
+
+void enter() {
+  tc.enter();
+}
+
+uint8 prg_read(unsigned addr) {
+  if(addr & 0x8000) return read(prgrom, tc.prg_addr(addr));
+  return cpu.mdr();
+}
+
+void prg_write(unsigned addr, uint8 data) {
+  if(addr & 0x8000) return tc.reg_write(addr, data);
+}
+
+uint8 chr_read(unsigned addr) {
+  if(addr & 0x2000) return ppu.ciram_read(tc.ciram_addr(addr));
+  return Board::chr_read(tc.chr_addr(addr));
+}
+
+void chr_write(unsigned addr, uint8 data) {
+  if(addr & 0x2000) return ppu.ciram_write(tc.ciram_addr(addr), data);
+  return Board::chr_write(tc.chr_addr(addr), data);
+}
+
+void power() {
+  tc.power();
+}
+
+void reset() {
+  tc.reset();
+}
+
+void serialize(serializer& s) {
+  Board::serialize(s);
+  tc.serialize(s);
+}
+
+TaitoTC(Markup::Node& cartridge) : Board(cartridge), tc(*this, cartridge) {
+}
+
+};
diff -Nru higan/fc/cartridge/board/unlicensed/camerica.cpp higan/fc/cartridge/board/unlicensed/camerica.cpp
--- higan/fc/cartridge/board/unlicensed/camerica.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/fc/cartridge/board/unlicensed/camerica.cpp	2015-09-16 13:08:13.526563365 +0900
@@ -0,0 +1,105 @@
+struct Camerica : Board {
+
+enum class Revision : unsigned {
+  ALGN, // Aladdin Game Enhancer
+  ALGQ, // Aladdin Game Enhancer (Quattro Multicarts)
+  BF9093,
+  BF9096,
+  BF9097,
+} revision;
+
+struct Settings {
+  bool mirror;    //0 = vertical, 1 = horizontal
+} settings;
+
+uint4 prg_bank;
+uint2 prg_block; // for ALGQ and BF9096
+bool nametable; // for BF9097
+
+uint8 prg_read(unsigned addr) {
+  if((addr & 0x8000) == 0x0000) return cpu.mdr();
+  if((addr & 0xc000) == 0x8000) {
+    return read(prgrom, (prg_block << 16) | (prg_bank << 14) | (addr & 0x3fff));
+  } else {
+    if(revision != Revision::ALGQ && revision != Revision::BF9096)
+      return read(prgrom, (0x0f << 14) | (addr & 0x3fff));
+    else
+      return read(prgrom, (prg_block << 16) | (0x03 << 14) | (addr & 0x3fff));
+  }
+}
+
+void prg_write(unsigned addr, uint8 data) {
+  switch(revision) {
+  case Revision::ALGQ:
+  case Revision::BF9096:
+    if((addr & 0xc000) == 0x8000) {
+      prg_block = (data & 0x18) >> 3;
+    }
+    break;
+  case Revision::BF9097:
+    if((addr & 0xe000) == 0x8000) {
+      nametable = data & 0x10;
+    }
+    break;
+  }
+  if((addr & 0xc000) == 0xc000) {
+    switch(revision) {
+    case Revision::ALGN:
+    case Revision::BF9093: prg_bank = data & 0x0f; break;
+    case Revision::ALGQ:
+    case Revision::BF9096: prg_bank = data & 0x03; break;
+    case Revision::BF9097: prg_bank = data & 0x07; break;
+    }
+  }
+}
+
+uint8 chr_read(unsigned addr) {
+  if(addr & 0x2000) return ppu.ciram_read(ciram_addr(addr));
+  return Board::chr_read(addr);
+}
+
+void chr_write(unsigned addr, uint8 data) {
+  if(addr & 0x2000) return ppu.ciram_write(ciram_addr(addr), data);
+  return Board::chr_write(addr, data);
+}
+
+unsigned ciram_addr(unsigned addr) const {
+  if(revision != Revision::BF9097) {
+    switch(settings.mirror) {
+    case 0: return ((addr & 0x0400) >> 0) | (addr & 0x03ff);
+    case 1: return ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    }
+  } else {
+    return (addr & 0x03ff) | (nametable << 10);
+  }
+}
+
+void power() {
+}
+
+void reset() {
+  prg_bank = 0;
+  prg_block = 0;
+  nametable = 0;
+}
+
+void serialize(serializer& s) {
+  Board::serialize(s);
+
+  s.integer(prg_bank);
+  s.integer(prg_block);
+  s.integer(nametable);
+}
+
+Camerica(Markup::Node& cartridge) : Board(cartridge) {
+  string type = cartridge["board/type"].text();
+  if(type.match("*ALGN*"  )) revision = Revision::ALGN;
+  if(type.match("*ALGQ*"  )) revision = Revision::ALGQ;
+  if(type.match("*BF9093*")) revision = Revision::BF9093;
+  if(type.match("*BF9096*")) revision = Revision::BF9096;
+  if(type.match("*BF9097*")) revision = Revision::BF9097;
+
+  settings.mirror = cartridge["mirror/mode"].text() == "horizontal";
+}
+
+};
diff -Nru higan/fc/cartridge/board/unlicensed/colordreams-74-377.cpp higan/fc/cartridge/board/unlicensed/colordreams-74-377.cpp
--- higan/fc/cartridge/board/unlicensed/colordreams-74-377.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/fc/cartridge/board/unlicensed/colordreams-74-377.cpp	2015-09-16 13:08:13.526563365 +0900
@@ -0,0 +1,64 @@
+//COLORDREAMS-74*377
+
+struct ColorDreams74_377 : Board {
+
+struct Settings {
+  bool mirror;  //0 = vertical, 1 = horizontal
+} settings;
+
+uint2 prg_bank;
+uint4 chr_bank;
+
+uint8 prg_read(unsigned addr) {
+  if(addr & 0x8000) return read(prgrom, (prg_bank << 15) | (addr & 0x7fff));
+  return cpu.mdr();
+}
+
+void prg_write(unsigned addr, uint8 data) {
+  if(addr & 0x8000) {
+    // Bus conflicts
+    data &= prg_read(addr);
+    // PRG and CHR bits are swapped relative to NES-GxROM.
+    // Additionally, up to 16 CHR banks are available instead of 4.
+    prg_bank = (data & 0x03) >> 0;
+    chr_bank = (data & 0xf0) >> 4;
+  }
+}
+
+uint8 chr_read(unsigned addr) {
+  if(addr & 0x2000) {
+    if(settings.mirror == 1) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    return ppu.ciram_read(addr);
+  }
+  addr = (chr_bank * 0x2000) + (addr & 0x1fff);
+  return Board::chr_read(addr);
+}
+
+void chr_write(unsigned addr, uint8 data) {
+  if(addr & 0x2000) {
+    if(settings.mirror == 1) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    return ppu.ciram_write(addr, data);
+  }
+  addr = (chr_bank * 0x2000) + (addr & 0x1fff);
+  Board::chr_write(addr, data);
+}
+
+void power() {
+}
+
+void reset() {
+  prg_bank = 0;
+  chr_bank = 0;
+}
+
+void serialize(serializer& s) {
+  Board::serialize(s);
+  s.integer(prg_bank);
+  s.integer(chr_bank);
+}
+
+ColorDreams74_377(Markup::Node& cartridge) : Board(cartridge) {
+  settings.mirror = cartridge["mirror/mode"].text() == "horizontal";
+}
+
+};
diff -Nru higan/fc/cartridge/board/unlicensed/mlt-action52.cpp higan/fc/cartridge/board/unlicensed/mlt-action52.cpp
--- higan/fc/cartridge/board/unlicensed/mlt-action52.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/fc/cartridge/board/unlicensed/mlt-action52.cpp	2015-09-16 13:08:13.526563365 +0900
@@ -0,0 +1,82 @@
+//MLT-ACTION52
+
+struct MLT_Action52 : Board {
+
+struct Settings {
+  uint4 connected_chips;
+  uint2 chip_map[4];
+} settings;
+
+bool mirror;
+uint2 prg_chip;
+uint5 prg_bank;
+bool prg_mode;
+uint6 chr_bank;
+
+uint8 prg_read(unsigned addr) {
+  if(addr & 0x8000 && settings.connected_chips & (1 << prg_chip)) {
+    unsigned target_bank = prg_bank;
+    target_bank |= settings.chip_map[prg_chip] << 5;
+    if(prg_mode) return read(prgrom, (target_bank << 14) | (addr & 0x3fff));
+    else         return read(prgrom, (target_bank << 14) | (addr & 0x7fff));
+  }
+  return cpu.mdr();
+}
+
+void prg_write(unsigned addr, uint8 data) {
+  if(addr & 0x8000) {
+    mirror = (addr & 0x2000) >> 13;
+    prg_chip = (addr & 0x1800) >> 11;
+    prg_bank = (addr & 0x07c0) >> 6;
+    prg_mode = (addr & 0x0020) >> 5;
+    chr_bank = ((addr & 0x000f) << 2) + (data & 0x03);
+  }
+}
+
+uint8 chr_read(unsigned addr) {
+  if(addr & 0x2000) {
+    if(mirror) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    return ppu.ciram_read(addr);
+  }
+  addr = (chr_bank * 0x2000) + (addr & 0x1fff);
+  return Board::chr_read(addr);
+}
+
+void chr_write(unsigned addr, uint8 data) {
+  if(addr & 0x2000) {
+    if(mirror) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    return ppu.ciram_write(addr, data);
+  }
+  addr = (chr_bank * 0x2000) + (addr & 0x1fff);
+  Board::chr_write(addr, data);
+}
+
+void power() {
+}
+
+void reset() {
+  mirror = 0;
+  prg_chip = 0;
+  prg_bank = 0;
+  prg_mode = 0;
+  chr_bank = 0;
+}
+
+void serialize(serializer &s) {
+  Board::serialize(s);
+  s.integer(mirror);
+  s.integer(prg_chip);
+  s.integer(prg_bank);
+  s.integer(prg_mode);
+  s.integer(chr_bank);
+}
+
+MLT_Action52(Markup::Node& cartridge) : Board(cartridge) {
+  settings.connected_chips = cartridge["board/connected-chips"].decimal();
+  uint2 chip_block = 0;
+  for(unsigned chip_id = 0; chip_id < 4; chip_id++) {
+    if(settings.connected_chips & (0x1 << chip_id)) settings.chip_map[chip_id] = chip_block++;
+  }
+}
+
+};
diff -Nru higan/fc/cartridge/board/unlicensed/nina.cpp higan/fc/cartridge/board/unlicensed/nina.cpp
--- higan/fc/cartridge/board/unlicensed/nina.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/fc/cartridge/board/unlicensed/nina.cpp	2015-09-16 13:08:13.526563365 +0900
@@ -0,0 +1,94 @@
+//AVE-NINA-01
+//AVE-NINA-02
+//AVE-NINA-03
+//AVE-NINA-06
+
+struct Nina : Board {
+
+unsigned revision;
+
+struct Settings {
+  bool mirror;  //0 = vertical, 1 = horizontal
+} settings;
+
+bool prg_bank;
+uint4 chr_bank[2];
+
+uint8 prg_read(unsigned addr) {
+  if(addr & 0x8000) return read(prgrom, (prg_bank << 15) | (addr & 0x7fff));
+  if((addr & 0xe000) == 0x6000) {
+    if(prgram.size() > 0) return read(prgram, addr);
+  }
+  return cpu.mdr();
+}
+
+void prg_write(unsigned addr, uint8 data) {
+  switch(revision) {
+  case  1:
+  case  2:
+    switch(addr) {
+    case 0x7ffd: prg_bank    = data & 0x01; break;
+    case 0x7ffe: chr_bank[0] = data & 0x0f; break;
+    case 0x7fff: chr_bank[1] = data & 0x0f; break;
+    }
+    break;
+  case  3:
+  case  6:
+    if((addr & 0xe100) == 0x4100) {
+      prg_bank    = (data & 0x08) >> 3;
+      chr_bank[0] = ((data & 0x07) << 1) | 0;
+      chr_bank[1] = ((data & 0x07) << 1) | 1;
+    }
+    break;
+  }
+  if((addr & 0xe000) == 0x6000 && prgram.size() > 0) write(prgram, addr, data);
+}
+
+uint8 chr_read(unsigned addr) {
+  if(addr & 0x2000) {
+    if(settings.mirror == 1) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    return ppu.ciram_read(addr);
+  }
+  return Board::chr_read((addr & 0x0fff) | (chr_bank[(addr & 0x1000) >> 12] << 12));
+}
+
+void chr_write(unsigned addr, uint8 data) {
+  if(addr & 0x2000) {
+    if(settings.mirror == 1) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    return ppu.ciram_write(addr, data);
+  }
+  return Board::chr_write((addr & 0x0fff) | (chr_bank[(addr & 0x1000) >> 12] << 12), data);
+}
+
+void power() {
+  reset();
+}
+
+void reset() {
+  prg_bank = 0;
+  chr_bank[0] = 0;
+  chr_bank[1] = 0;
+}
+
+void serialize(serializer& s) {
+  Board::serialize(s);
+  s.integer(prg_bank);
+  s.array(chr_bank);
+}
+
+Nina(Markup::Node& cartridge) : Board(cartridge) {
+  string type = cartridge["board/type"].text();
+  if(type.match("*NINA-01*")) revision =  1;
+  if(type.match("*NINA-02*")) revision =  2;
+  if(type.match("*NINA-03*")) revision =  3;
+  if(type.match("*NINA-06*")) revision =  6;
+
+  print("Revision: 0", revision, "\n");
+  if(revision ==  1 || revision ==  2) {
+    settings.mirror = 1;
+  } else {
+    settings.mirror = cartridge["mirror/mode"].text() == "horizontal";
+  }
+}
+
+};
diff -Nru higan/fc/cartridge/board/unlicensed/noconflicts-cnrom.cpp higan/fc/cartridge/board/unlicensed/noconflicts-cnrom.cpp
--- higan/fc/cartridge/board/unlicensed/noconflicts-cnrom.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/fc/cartridge/board/unlicensed/noconflicts-cnrom.cpp	2015-09-16 13:08:13.525563365 +0900
@@ -0,0 +1,56 @@
+// This board is intended for homebrew games that do not account for bus
+// conflicts. Many Sachen and Panesian games require this board, but they were
+// not the reason for its inclusion.
+
+struct NoConflicts_CNROM : Board {
+
+struct Settings {
+  bool mirror;  //0 = vertical, 1 = horizontal
+} settings;
+
+uint2 chr_bank;
+
+uint8 prg_read(unsigned addr) {
+  if(addr & 0x8000) return read(prgrom, addr & 0x7fff);
+  return cpu.mdr();
+}
+
+void prg_write(unsigned addr, uint8 data) {
+  if(addr & 0x8000) chr_bank = data & 0x03;
+}
+
+uint8 chr_read(unsigned addr) {
+  if(addr & 0x2000) {
+    if(settings.mirror == 1) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    return ppu.ciram_read(addr);
+  }
+  addr = (chr_bank * 0x2000) + (addr & 0x1fff);
+  return Board::chr_read(addr);
+}
+
+void chr_write(unsigned addr, uint8 data) {
+  if(addr & 0x2000) {
+    if(settings.mirror == 1) addr = ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+    return ppu.ciram_write(addr, data);
+  }
+  addr = (chr_bank * 0x2000) + (addr & 0x1fff);
+  Board::chr_write(addr, data);
+}
+
+void power() {
+}
+
+void reset() {
+  chr_bank = 0;
+}
+
+void serialize(serializer& s) {
+  Board::serialize(s);
+  s.integer(chr_bank);
+}
+
+NoConflicts_CNROM(Markup::Node& cartridge) : Board(cartridge) {
+  settings.mirror = cartridge["mirror/mode"].text() == "horizontal";
+}
+
+};
diff -Nru higan/fc/cartridge/board/unlicensed/single-chip.cpp higan/fc/cartridge/board/unlicensed/single-chip.cpp
--- higan/fc/cartridge/board/unlicensed/single-chip.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/fc/cartridge/board/unlicensed/single-chip.cpp	2015-09-16 13:08:13.525563365 +0900
@@ -0,0 +1,33 @@
+struct SingleChip : Board {
+
+struct Settings {
+  uint4 va10;  //10 = vertical, 11 = horizontal, 12 = BLK0, 13 = BLK1
+} settings;
+
+uint8 prg_read(unsigned addr) {
+  if(addr & 0x8000) return read(prgrom, addr);
+  return cpu.mdr();
+}
+
+void prg_write(unsigned addr, uint8 data) {
+}
+
+uint8 chr_read(unsigned addr) {
+  addr = ((addr & (1 << settings.va10)) >> (settings.va10 - 10)) | (addr & 0x03ff);
+  return ppu.ciram_read(addr);
+}
+
+void chr_write(unsigned addr, uint8 data) {
+  addr = ((addr & (1 << settings.va10)) >> (settings.va10 - 10)) | (addr & 0x03ff);
+  return ppu.ciram_write(addr, data);
+}
+
+void serialize(serializer& s) {
+  Board::serialize(s);
+}
+
+SingleChip(Markup::Node& cartridge) : Board(cartridge) {
+  settings.va10 = cartridge["board/va10"].decimal();
+}
+
+};
diff -Nru higan/fc/cartridge/board/vs.cpp higan/fc/cartridge/board/vs.cpp
--- higan/fc/cartridge/board/vs.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/fc/cartridge/board/vs.cpp	2015-09-16 13:08:13.533563366 +0900
@@ -0,0 +1,155 @@
+//VS
+
+struct VS : Board {
+
+enum class ChipType : unsigned {
+  None,
+  _74HC32,
+  MMC1,
+  N108,
+} chip_type;
+
+uint4 bank;
+MMC1 mmc1;
+N108 n108;
+
+void enter() {
+  if(chip_type == ChipType::MMC1) return mmc1.enter();
+  while(true) {
+    if(scheduler.sync == Scheduler::SynchronizeMode::All) {
+      scheduler.exit(Scheduler::ExitReason::SynchronizeEvent);
+    }
+
+    tick();
+  }
+}
+
+uint8 prg_read(unsigned addr) {
+  switch(chip_type) {
+  case ChipType::None:
+    if(addr & 0x8000) {
+      if(addr < 0xe000 && prgrom.size() < 0x2000) return cpu.mdr();
+      if(addr < 0xc000 && prgrom.size() < 0x4000) return cpu.mdr();
+      if(addr < 0xa000 && prgrom.size() < 0x6000) return cpu.mdr();
+      addr &= 0x7fff;
+      if(prgrom.size() > 0x8000) { // Games with oversize 1D such as VS. Gumshoe
+        if(addr >= 0x2000 || bank == 1) addr += 0x2000;
+      }
+      return read(prgrom, addr);
+    }
+    break;
+  case ChipType::_74HC32:
+    if(addr & 0x8000) {
+      if((addr & 0xc000) == 0x8000)
+        return read(prgrom, (bank << 14) | (addr & 0x3fff));
+      else
+        return read(prgrom, (0x0f << 14) | (addr & 0x3fff));
+    }
+    break;
+  case ChipType::MMC1:
+    if(addr & 0x8000) return read(prgrom, mmc1.prg_addr(addr));
+    //if(revision == Revision::SUROM || revision == Revision::SXROM) {
+    //  addr |= ((mmc1.chr_bank[last_chr_bank] & 0x10) >> 4) << 18;
+    //}
+    break;
+  case ChipType::N108:
+    if(addr & 0x8000) return read(prgrom, n108.prg_addr(addr));
+    break;
+  }
+  if((addr & 0xe000) == 0x6000) {
+    if(prgram.size() == 0) return vsarcadeboard.read(addr);
+    else                 return read(prgram, addr);
+  }
+  return cpu.mdr();
+}
+
+void prg_write(unsigned addr, uint8 data) {
+  switch(chip_type) {
+  case ChipType::None:
+    if(addr == 0x4016) bank = (data & 0x04) >> 2;
+    break;
+  case ChipType::_74HC32:
+    //TODO: Check if VS. UNROM has bus conflicts
+    //data &= prg_read(addr);
+    if(addr & 0x8000) bank = data & 0x0f;
+    break;
+  case ChipType::MMC1:
+    if(addr & 0x8000) return mmc1.mmio_write(addr, data);
+    break;
+  case ChipType::N108:
+    if(addr & 0x8000) return n108.reg_write(addr, data);
+    break;
+  }
+  if((addr & 0xe000) == 0x6000) {
+    if(prgram.size() == 0) vsarcadeboard.write(addr, data);
+    else                 write(prgram, addr, data);
+  }
+}
+
+uint8 chr_read(unsigned addr) {
+  if(addr & 0x2000) return ppu.ciram_read(addr);
+  switch(chip_type) {
+  case ChipType::None:
+    if(chrrom.size() < bank << 13) return ppu.status.mdr;
+    return read(chrrom, ((bank << 13) + (addr & 0x1fff)));
+  case ChipType::_74HC32:
+    return Board::chr_read(addr);
+  case ChipType::MMC1:
+    return Board::chr_read(mmc1.chr_addr(addr));
+  case ChipType::N108:
+    return Board::chr_read(n108.chr_addr(addr));
+  }
+}
+
+void chr_write(unsigned addr, uint8 data) {
+  if(addr & 0x2000) return ppu.ciram_write(addr, data);
+  switch(chip_type) {
+  case ChipType::None:
+    break;
+  case ChipType::_74HC32:
+    return Board::chr_write(addr, data);
+  case ChipType::MMC1:
+    return Board::chr_write(mmc1.chr_addr(addr), data);
+  case ChipType::N108:
+    return Board::chr_write(n108.chr_addr(addr), data);
+  }
+}
+
+void power() {
+  switch(chip_type) {
+  case ChipType::MMC1: mmc1.power(); break;
+  case ChipType::N108: n108.power(); break;
+  }
+}
+
+void reset() {
+  bank = 0;
+  switch(chip_type) {
+  case ChipType::MMC1: mmc1.reset(); break;
+  case ChipType::N108: n108.reset(); break;
+  }
+}
+
+void serialize(serializer& s) {
+  Board::serialize(s);
+  s.integer(bank);
+  switch(chip_type) {
+  case ChipType::MMC1: mmc1.serialize(s); break;
+  case ChipType::N108: n108.serialize(s); break;
+  }
+}
+
+VS(Markup::Node& cartridge) : Board(cartridge),
+mmc1(*this, cartridge),
+n108(*this, cartridge) {
+  chip_type = ChipType::None;
+  string type = cartridge["chip/type"].text();
+  if(type.match("74HC32")) chip_type = ChipType::_74HC32;
+  if(type.match("MMC1*" )) chip_type = ChipType::MMC1;
+  if(type.match("108"   )) chip_type = ChipType::N108;
+  if(type.match("109"   )) chip_type = ChipType::N108;
+  if(type.match("118"   )) chip_type = ChipType::N108;
+  if(type.match("119"   )) chip_type = ChipType::N108;
+}
+
+};
diff -Nru higan/fc/cartridge/cartridge.cpp higan/fc/cartridge/cartridge.cpp
--- higan/fc/cartridge/cartridge.cpp	2015-09-16 02:20:06.372574580 +0900
+++ higan/fc/cartridge/cartridge.cpp	2015-09-16 13:08:13.535563366 +0900
@@ -1,42 +1,62 @@
 #include <fc/fc.hpp>
 
+#define CARTRIDGE_CPP
 namespace Famicom {
 
+#include "markup.cpp"
 #include "chip/chip.cpp"
 #include "board/board.cpp"
 Cartridge cartridge;
 
 string Cartridge::title() {
-  return information.title;
+  //if(information.title.famicomDiskSystem.empty() == false) {
+  //  return {information.title.cartridge, " + ", information.title.famicomDiskSystem};
+  //}
+
+  return information.title.cartridge;
 }
 
-void Cartridge::Main() {
-  cartridge.main();
+void Cartridge::Enter() {
+  cartridge.enter();
 }
 
-void Cartridge::main() {
-  board->main();
+void Cartridge::enter() {
+  board->enter();
 }
 
-void Cartridge::load() {
+void Cartridge::load(System::Revision revision) {
+  _region = Region::NTSC;
+  system.revision = revision;
+
+  information.markup.cartridge         = "";
+  //information.markup.famicomDiskSystem = "";
+
+  information.title.cartridge         = "";
+  //information.title.famicomDiskSystem = "";
+
   interface->loadRequest(ID::Manifest, "manifest.bml", true);
+  parseMarkup(information.markup.cartridge);
 
-  Board::load(information.markup);  //this call will set Cartridge::board if successful
   if(board == nullptr) return;
 
   Hash::SHA256 sha;
-  sha.data(board->prgrom.data, board->prgrom.size);
-  sha.data(board->chrrom.data, board->chrrom.size);
-  sha256 = sha.digest();
+  sha.data(board->prgrom.data(), board->prgrom.size());
+  sha.data(board->chrrom.data(), board->chrrom.size());
+  sha.data(board->instrom.data(), board->instrom.size());
+  sha.data(board->keyrom.data(), board->keyrom.size());
+  _sha256 = sha.digest();
 
-  system.load();
-  loaded = true;
+  system.load(system.revision);
+  _loaded = true;
 }
 
 void Cartridge::unload() {
-  if(loaded == false) return;
-  loaded = false;
-  memory.reset();
+  if(_loaded) {
+    system.unload();
+
+    _loaded = false;
+    memory.reset();
+  }
 }
 
 void Cartridge::power() {
@@ -44,14 +64,10 @@
 }
 
 void Cartridge::reset() {
-  create(Cartridge::Main, 21477272);
+  create(Cartridge::Enter, system.cpu_frequency());
   board->reset();
 }
 
-Cartridge::Cartridge() {
-  loaded = false;
-}
-
 uint8 Cartridge::prg_read(unsigned addr) {
   return board->prg_read(addr);
 }
diff -Nru higan/fc/cartridge/cartridge.hpp higan/fc/cartridge/cartridge.hpp
--- higan/fc/cartridge/cartridge.hpp	2015-09-16 02:20:06.372574580 +0900
+++ higan/fc/cartridge/cartridge.hpp	2015-09-16 13:08:13.542563366 +0900
@@ -2,24 +2,14 @@
 #include "board/board.hpp"
 
 struct Cartridge : Thread, property<Cartridge> {
-  static void Main();
-  void main();
+  enum class Region : unsigned { NTSC, PAL/*, Dendy*/ };
 
-  void load();
-  void unload();
+  static void Enter();
+  void enter();
 
-  void power();
-  void reset();
-
-  readonly<bool> loaded;
-  readonly<string> sha256;
-
-  struct Information {
-    string markup;
-    string title;
-  } information;
-
-  string title();
+  auto loaded() const -> bool { return _loaded; }
+  auto sha256() const -> string { return _sha256; }
+  auto region() const -> Region { return _region; }
 
   struct Memory {
     unsigned id;
@@ -27,21 +17,55 @@
   };
   vector<Memory> memory;
 
-  void serialize(serializer&);
-  Cartridge();
+  struct Information {
+    struct Markup {
+      string cartridge;
+      //string famicomDiskSystem;
+    } markup;
+
+    struct Title {
+      string cartridge;
+      //string famicomDiskSystem;
+    } title;
+  } information;
+
+  auto power() -> void;
+  auto reset() -> void;
+  Cartridge() = default;
+  ~Cartridge() { unload(); }
+
+  auto title() -> string;
+
+  auto load(System::Revision) -> void;
+  auto unload() -> void;
+
+  auto serialize(serializer&) -> void;
 
 //privileged:
   Board *board;
 
-  uint8 prg_read(unsigned addr);
-  void prg_write(unsigned addr, uint8 data);
+  auto prg_read(unsigned addr) -> uint8;
+  auto prg_write(unsigned addr, uint8 data) -> void;
 
-  uint8 chr_read(unsigned addr);
-  void chr_write(unsigned addr, uint8 data);
+  auto chr_read(unsigned addr) -> uint8;
+  auto chr_write(unsigned addr, uint8 data) -> void;
 
   //scanline() is for debugging purposes only:
   //boards must detect scanline edges on their own
-  void scanline(unsigned y);
+  auto scanline(unsigned y) -> void;
+
+private:
+  friend class Interface;
+
+  //markup.cpp
+  auto parseMarkup(const char*) -> void;
+  auto parseMarkupMemory(MappedRAM&, Markup::Node, unsigned id, bool writable) -> void;
+
+  auto parseMarkupCartridge(Markup::Node) -> void;
+
+  bool _loaded = false;
+  string _sha256;
+  Region _region = Region::NTSC;
 };
 
 extern Cartridge cartridge;
diff -Nru higan/fc/cartridge/chip/chip.cpp higan/fc/cartridge/chip/chip.cpp
--- higan/fc/cartridge/chip/chip.cpp	2015-09-16 02:20:06.372574580 +0900
+++ higan/fc/cartridge/chip/chip.cpp	2015-09-16 13:08:13.539563366 +0900
@@ -1,7 +1,14 @@
+#include "fcg.cpp"
+#include "g101.cpp"
+#include "ifh3001.cpp"
 #include "mmc1.cpp"
 #include "mmc3.cpp"
 #include "mmc5.cpp"
 #include "mmc6.cpp"
+#include "n108.cpp"
+#include "n163.cpp"
+#include "ss88006.cpp"
+#include "tc.cpp"
 #include "vrc1.cpp"
 #include "vrc2.cpp"
 #include "vrc3.cpp"
diff -Nru higan/fc/cartridge/chip/chip.hpp higan/fc/cartridge/chip/chip.hpp
--- higan/fc/cartridge/chip/chip.hpp	2015-09-16 02:20:06.372574580 +0900
+++ higan/fc/cartridge/chip/chip.hpp	2015-09-16 13:08:13.538563366 +0900
@@ -2,6 +2,7 @@
 
 struct Chip {
   Board& board;
+  MappedRAM ram;
   void tick();
   Chip(Board& board);
 };
diff -Nru higan/fc/cartridge/chip/fcg.cpp higan/fc/cartridge/chip/fcg.cpp
--- higan/fc/cartridge/chip/fcg.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/fc/cartridge/chip/fcg.cpp	2015-09-16 13:08:13.536563366 +0900
@@ -0,0 +1,136 @@
+struct FCG : Chip {
+
+enum class Revision : unsigned {
+  FCG1,
+  FCG2,
+  LZ93D50,
+} revision;
+
+enum class EEPROM : unsigned {
+  None,
+  _24C01,
+  _24C02
+} eeprom;
+
+uint8 chr_bank[8];
+uint8 prg_bank;
+uint2 mirror;
+bool irq_counter_enable;
+uint16 irq_counter;
+uint16 irq_latch;
+bool eeprom_i2c_scl; // When using SRAM, enables RAM chip
+bool eeprom_enable_read;
+
+void enter() {
+  while(true) {
+    if(scheduler.sync == Scheduler::SynchronizeMode::All) {
+      scheduler.exit(Scheduler::ExitReason::SynchronizeEvent);
+    }
+
+    if(irq_counter_enable) {
+      if(--irq_counter == 0xffff) {
+        cpu.set_irq_line(1);
+        irq_counter_enable = false;
+      }
+    }
+
+    tick();
+  }
+}
+
+unsigned prg_addr(unsigned addr) const {
+  bool region = addr & 0x4000;
+  return ((region == 0 ? prg_bank : 15) << 14) | (addr & 0x3fff);
+}
+
+unsigned chr_addr(unsigned addr) const {
+  return (chr_bank[addr >> 10] << 10) | (addr & 0x03ff);
+}
+
+unsigned ciram_addr(unsigned addr) const {
+  switch(mirror) {
+  case 0: return ((addr & 0x0400) >> 0) | (addr & 0x03ff);
+  case 1: return ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+  case 2: return 0x0000 | (addr & 0x03ff);
+  case 3: return 0x0400 | (addr & 0x03ff);
+  }
+}
+
+uint8 ram_read(unsigned addr) {
+  return board.read(board.prgram, addr & 0x1fff);
+}
+
+void ram_write(unsigned addr, uint8 data) {
+  board.write(board.prgram, addr & 0x1fff, data);
+}
+
+void reg_write(unsigned addr, uint8 data) {
+  switch(addr & 0x0f) {
+  case 0x00: case 0x01: case 0x02: case 0x03:
+  case 0x04: case 0x05: case 0x06: case 0x07:
+    chr_bank[addr & 7] = data;
+    break;
+  case 0x08:
+    prg_bank = data & 0x0f;
+    break;
+  case 0x09:
+    mirror = data & 0x03;
+    break;
+  case 0x0a:
+    cpu.set_irq_line(0);
+    irq_counter_enable = data & 0x01;
+    irq_counter = irq_latch;
+    break;
+  case 0x0b:
+    irq_latch = (irq_latch & 0xff00) | (data << 0);
+    break;
+  case 0x0c:
+    irq_latch = (irq_latch & 0x00ff) | (data << 8);
+    break;
+  case 0x0d:
+    //TODO: serial EEPROM support
+    eeprom_i2c_scl = data & 0x20;
+    eeprom_enable_read = data & 0x80;
+    break;
+  }
+}
+
+void power() {
+  reset();
+}
+
+void reset() {
+  for(auto &n : chr_bank) n = 0;
+  prg_bank = 0;
+  mirror = 0;
+  irq_counter_enable = 0;
+  irq_counter = 0;
+  irq_latch = 0;
+  eeprom_i2c_scl = 0;
+  eeprom_enable_read = 0;
+}
+
+void serialize(serializer& s) {
+  s.array(chr_bank);
+  s.integer(prg_bank);
+  s.integer(mirror);
+  s.integer(irq_counter_enable);
+  s.integer(irq_counter);
+  s.integer(irq_latch);
+  s.integer(eeprom_i2c_scl);
+  s.integer(eeprom_enable_read);
+}
+
+FCG(Board& board, Markup::Node& cartridge) : Chip(board) {
+  string type = cartridge["chip[0]/type"].text();
+  if(type == "FCG-1"  ) revision = Revision::FCG1;
+  if(type == "FCG-2"  ) revision = Revision::FCG2;
+  if(type == "LZ93D50") revision = Revision::LZ93D50;
+
+  eeprom = EEPROM::None;
+  type = cartridge["chip[1]/type"].text();
+  if(type == "24C01") eeprom = EEPROM::_24C01;
+  if(type == "24C02") eeprom = EEPROM::_24C02;
+}
+
+};
diff -Nru higan/fc/cartridge/chip/g101.cpp higan/fc/cartridge/chip/g101.cpp
--- higan/fc/cartridge/chip/g101.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/fc/cartridge/chip/g101.cpp	2015-09-16 13:08:13.540563366 +0900
@@ -0,0 +1,80 @@
+struct G101 : Chip {
+
+bool prg_mode;
+uint5 prg_bank[2];
+uint8 chr_bank[8];
+bool mirror;
+
+unsigned prg_addr(unsigned addr) const {
+  switch(addr & 0xe000) {
+  case 0x8000:
+    if(prg_mode == 1) return (0x1e << 13) | (addr & 0x1fff);
+    return (prg_bank[0] << 13) | (addr & 0x1fff);
+  case 0xa000:
+    return (prg_bank[1] << 13) | (addr & 0x1fff);
+  case 0xc000:
+    if(prg_mode == 0) return (0x1e << 13) | (addr & 0x1fff);
+    return (prg_bank[0] << 13) | (addr & 0x1fff);
+  case 0xe000:
+    return (0x1f << 13) | (addr & 0x1fff);
+  }
+}
+
+unsigned chr_addr(unsigned addr) const {
+  return (chr_bank[addr >> 10] << 10) | (addr & 0x03ff);
+}
+
+unsigned ciram_addr(unsigned addr) const {
+  switch(mirror) {
+  case 0: return (addr & 0x03ff) | ((addr & 0x0400) >> 0);
+  case 1: return (addr & 0x03ff) | ((addr & 0x0800) >> 1);
+  }
+}
+
+void reg_write(unsigned addr, uint8 data) {
+  switch(addr & 0xf000) {
+  case 0x8000:
+    prg_bank[0] = data & 0x1f;
+    break;
+  case 0x9000:
+    mirror = data & 0x01;
+    prg_mode = data & 0x02;
+    break;
+  case 0xa000:
+    prg_bank[1] = data & 0x1f;
+    break;
+  case 0xb000:
+    chr_bank[addr & 0x0007] = data;
+    break;
+  }
+}
+
+void power() {
+  prg_mode = 0;
+  prg_bank[0] = 0x00;
+  prg_bank[1] = 0x1e;
+  chr_bank[0] = 0;
+  chr_bank[1] = 0;
+  chr_bank[2] = 0;
+  chr_bank[3] = 0;
+  chr_bank[4] = 0;
+  chr_bank[5] = 0;
+  chr_bank[6] = 0;
+  chr_bank[7] = 0;
+  mirror = 0;
+}
+
+void reset() {
+}
+
+void serialize(serializer& s) {
+  s.integer(prg_mode);
+  s.array(prg_bank);
+  s.array(chr_bank);
+  s.integer(mirror);
+}
+
+G101(Board& board, Markup::Node& cartridge) : Chip(board) {
+}
+
+};
diff -Nru higan/fc/cartridge/chip/ifh3001.cpp higan/fc/cartridge/chip/ifh3001.cpp
--- higan/fc/cartridge/chip/ifh3001.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/fc/cartridge/chip/ifh3001.cpp	2015-09-16 13:08:13.539563366 +0900
@@ -0,0 +1,125 @@
+struct IFH3001 : Chip {
+
+bool prg_mode;
+uint8 prg_bank[3];
+uint8 chr_bank[8];
+bool mirror;
+uint16 irq_counter;
+uint16 irq_latch;
+bool irq_enable;
+
+void enter() {
+  while(true) {
+    if(scheduler.sync == Scheduler::SynchronizeMode::All) {
+      scheduler.exit(Scheduler::ExitReason::SynchronizeEvent);
+    }
+
+    if(irq_enable && irq_counter) {
+      if(--irq_counter == 0) cpu.set_irq_line(1);
+    }
+    tick();
+  }
+}
+
+unsigned prg_addr(unsigned addr) const {
+  switch(addr & 0xe000) {
+  case 0x8000: return (prg_bank[0] << 13) | (addr & 0x1fff);
+  case 0xa000: return (prg_bank[1] << 13) | (addr & 0x1fff);
+  case 0xc000: return (prg_bank[2] << 13) | (addr & 0x1fff);
+  case 0xe000: return (0xff << 13) | (addr & 0x1fff);
+  }
+}
+
+unsigned chr_addr(unsigned addr) const {
+  return (chr_bank[addr >> 10] << 10) | (addr & 0x03ff);
+}
+
+unsigned ciram_addr(unsigned addr) const {
+  switch(mirror) {
+  case 0: return (addr & 0x03ff) | ((addr & 0x0400) >> 0);
+  case 1: return (addr & 0x03ff) | ((addr & 0x0800) >> 1);
+  }
+}
+
+void reg_write(unsigned addr, uint8 data) {
+  switch(addr & 0xf007) {
+  case 0x8000:
+  case 0x8001:
+  case 0x8002:
+  case 0x8003:
+  case 0x8004:
+  case 0x8005:
+  case 0x8006:
+  case 0x8007: prg_bank[0] = data; break;
+  case 0x9001: mirror = data & 0x80; break;
+  case 0x9003:
+    irq_enable = data & 0x80;
+    cpu.set_irq_line(0);
+    break;
+  case 0x9004:
+    irq_counter = irq_latch;
+    cpu.set_irq_line(0);
+    break;
+  case 0x9005: irq_latch = (irq_latch & 0x00ff) | (data << 8); break;
+  case 0x9006: irq_latch = (irq_latch & 0xff00) | (data << 0); break;
+  case 0xa000:
+  case 0xa001:
+  case 0xa002:
+  case 0xa003:
+  case 0xa004:
+  case 0xa005:
+  case 0xa006:
+  case 0xa007: prg_bank[1] = data; break;
+  case 0xb000: chr_bank[0] = data; break;
+  case 0xb001: chr_bank[1] = data; break;
+  case 0xb002: chr_bank[2] = data; break;
+  case 0xb003: chr_bank[3] = data; break;
+  case 0xb004: chr_bank[4] = data; break;
+  case 0xb005: chr_bank[5] = data; break;
+  case 0xb006: chr_bank[6] = data; break;
+  case 0xb007: chr_bank[7] = data; break;
+  case 0xc000:
+  case 0xc001:
+  case 0xc002:
+  case 0xc003:
+  case 0xc004:
+  case 0xc005:
+  case 0xc006:
+  case 0xc007: prg_bank[2] = data; break;
+  }
+}
+
+void power() {
+}
+
+void reset() {
+  prg_bank[0] = 0x00;
+  prg_bank[1] = 0x01;
+  prg_bank[2] = 0xfe;
+  chr_bank[0] = 0;
+  chr_bank[1] = 0;
+  chr_bank[2] = 0;
+  chr_bank[3] = 0;
+  chr_bank[4] = 0;
+  chr_bank[5] = 0;
+  chr_bank[6] = 0;
+  chr_bank[7] = 0;
+  mirror = 0;
+  irq_counter = 0;
+  irq_latch = 0;
+  irq_enable = false;
+}
+
+void serialize(serializer& s) {
+  s.array(prg_bank);
+  s.array(chr_bank);
+  s.integer(mirror);
+  s.integer(irq_counter);
+  s.integer(irq_latch);
+  s.integer(irq_enable);
+}
+
+IFH3001(Board& board, Markup::Node& cartridge) : Chip(board) {
+}
+
+};
diff -Nru higan/fc/cartridge/chip/mmc1.cpp higan/fc/cartridge/chip/mmc1.cpp
--- higan/fc/cartridge/chip/mmc1.cpp	2015-09-16 02:20:06.372574580 +0900
+++ higan/fc/cartridge/chip/mmc1.cpp	2015-09-16 13:08:13.536563366 +0900
@@ -21,7 +21,7 @@
 bool ram_disable;
 uint4 prg_bank;
 
-void main() {
+void enter() {
   while(true) {
     if(scheduler.sync == Scheduler::SynchronizeMode::All) {
       scheduler.exit(Scheduler::ExitReason::SynchronizeEvent);
@@ -89,7 +89,7 @@
         break;
 
       case 3:
-        ram_disable = (shiftdata & 0x10);
+        ram_disable = ((shiftdata & 0x10) && revision != Revision::MMC1 && revision != Revision::MMC1A);
         prg_bank = (shiftdata & 0x0f);
         break;
       }
@@ -111,7 +111,7 @@
   mirror = 0;
   chr_bank[0] = 0;
   chr_bank[1] = 1;
-  ram_disable = 0;
+  ram_disable = revision == Revision::MMC1C;
   prg_bank = 0;
 }
 
@@ -129,8 +129,15 @@
   s.integer(prg_bank);
 }
 
-MMC1(Board& board) : Chip(board) {
-  revision = Revision::MMC1B2;
+MMC1(Board& board, Markup::Node& cartridge) : Chip(board) {
+  string type = cartridge["chip/type"].text();
+
+  if(type == "MMC1"  ) revision = Revision::MMC1;
+  if(type == "MMC1A" ) revision = Revision::MMC1A;
+  if(type == "MMC1B1") revision = Revision::MMC1B1;
+  if(type == "MMC1B2") revision = Revision::MMC1B2;
+  if(type == "MMC1B3") revision = Revision::MMC1B3;
+  if(type == "MMC1C" ) revision = Revision::MMC1C;
 }
 
 };
diff -Nru higan/fc/cartridge/chip/mmc3.cpp higan/fc/cartridge/chip/mmc3.cpp
--- higan/fc/cartridge/chip/mmc3.cpp	2015-09-16 02:20:06.372574580 +0900
+++ higan/fc/cartridge/chip/mmc3.cpp	2015-09-16 13:08:13.537563366 +0900
@@ -1,5 +1,13 @@
 struct MMC3 : Chip {
 
+enum class Revision : unsigned {
+  MMC3,
+  MMC3A,
+  MMC3B,
+  MMC3C,
+  MC_ACC,
+} revision;
+
 bool chr_mode;
 bool prg_mode;
 uint3 bank_select;
@@ -16,20 +24,26 @@
 
 uint16 chr_abus;
 
-void main() {
+void enter() {
   while(true) {
     if(scheduler.sync == Scheduler::SynchronizeMode::All) {
       scheduler.exit(Scheduler::ExitReason::SynchronizeEvent);
     }
 
     if(irq_delay) irq_delay--;
+    irq_test(ppu.status.chr_abus);
     cpu.set_irq_line(irq_line);
     tick();
   }
 }
 
 void irq_test(unsigned addr) {
-  if(!(chr_abus & 0x1000) && (addr & 0x1000)) {
+  bool edge;
+  if(revision != Revision::MC_ACC)
+    edge = !(chr_abus & 0x1000) && (addr & 0x1000);
+  else
+    edge = (chr_abus & 0x1000) && !(addr & 0x1000);
+  if(edge) {
     if(irq_delay == 0) {
       if(irq_counter == 0) {
         irq_counter = irq_latch;
@@ -81,12 +95,12 @@
 }
 
 uint8 ram_read(unsigned addr) {
-  if(ram_enable) return board.prgram.data[addr & 0x1fff];
+  if(ram_enable) return board.read(board.prgram, addr & 0x1fff);
   return 0x00;
 }
 
 void ram_write(unsigned addr, uint8 data) {
-  if(ram_enable && !ram_write_protect) board.prgram.data[addr & 0x1fff] = data;
+  if(ram_enable && !ram_write_protect) board.write(board.prgram, addr & 0x1fff, data);
 }
 
 void reg_write(unsigned addr, uint8 data) {
@@ -183,7 +197,13 @@
   s.integer(chr_abus);
 }
 
-MMC3(Board& board) : Chip(board) {
+MMC3(Board& board, Markup::Node& cartridge) : Chip(board) {
+  string type = cartridge["chip/type"].text();
+  if(type == "MMC3"  ) revision = Revision::MMC3;
+  if(type == "MMC3A" ) revision = Revision::MMC3A;
+  if(type == "MMC3B" ) revision = Revision::MMC3B;
+  if(type == "MMC3C" ) revision = Revision::MMC3C;
+  if(type == "MC-ACC") revision = Revision::MC_ACC;
 }
 
 };
diff -Nru higan/fc/cartridge/chip/mmc5.cpp higan/fc/cartridge/chip/mmc5.cpp
--- higan/fc/cartridge/chip/mmc5.cpp	2015-09-16 02:20:06.372574580 +0900
+++ higan/fc/cartridge/chip/mmc5.cpp	2015-09-16 13:08:13.538563366 +0900
@@ -5,8 +5,6 @@
   MMC5B,
 } revision;
 
-uint8 exram[1024];
-
 //programmable registers
 
 uint2 prg_mode;  //$5100
@@ -58,7 +56,7 @@
 uint8 vs_vpos;
 uint8 vs_hpos;
 
-void main() {
+void enter() {
   while(true) {
     if(scheduler.sync == Scheduler::SynchronizeMode::All) {
       scheduler.exit(Scheduler::ExitReason::SynchronizeEvent);
@@ -109,16 +107,16 @@
 
   if(write == false) {
     if(rom) {
-      return board.prgrom.read((bank << 13) | addr);
+      return board.read(board.prgrom, (bank << 13) | addr);
     } else {
-      return board.prgram.read((bank << 13) | addr);
+      return board.read(board.prgram, (bank << 13) | addr);
     }
   } else {
     if(rom) {
-      board.prgrom.write((bank << 13) | addr, data);
+      board.write(board.prgrom, (bank << 13) | addr, data);
     } else {
       if(prgram_write_protect[0] == 2 && prgram_write_protect[1] == 1) {
-        board.prgram.write((bank << 13) | addr, data);
+        board.write(board.prgram, (bank << 13) | addr, data);
       }
     }
     return 0x00;
@@ -127,7 +125,7 @@
 
 uint8 prg_read(unsigned addr) {
   if((addr & 0xfc00) == 0x5c00) {
-    if(exram_mode >= 2) return exram[addr & 0x03ff];
+    if(exram_mode >= 2) return ram.read(addr & 0x03ff);
     return cpu.mdr();
   }
 
@@ -149,8 +147,8 @@
 void prg_write(unsigned addr, uint8 data) {
   if((addr & 0xfc00) == 0x5c00) {
     //writes 0x00 *during* Vblank (not during screen rendering ...)
-    if(exram_mode == 0 || exram_mode == 1) exram[addr & 0x03ff] = in_frame ? data : 0x00;
-    if(exram_mode == 2) exram[addr & 0x03ff] = data;
+    if(exram_mode == 0 || exram_mode == 1) ram.write(addr & 0x03ff, in_frame ? data : 0x00);
+    if(exram_mode == 2) ram.write(addr & 0x03ff, data);
     return;
   }
 
@@ -279,13 +277,13 @@
 }
 
 unsigned chr_bg_addr(unsigned addr) {
-  addr &= 0x0fff;
-
   if(chr_mode == 0) {
     auto bank = chr_bg_bank[3];
-    return (bank * 0x2000) + (addr & 0x0fff);
+    return (bank * 0x2000) + (addr & 0x1fff);
   }
 
+  addr &= 0x0fff;
+
   if(chr_mode == 1) {
     auto bank = chr_bg_bank[3];
     return (bank * 0x1000) + (addr & 0x0fff);
@@ -326,13 +324,13 @@
 }
 
 uint8 ciram_read(unsigned addr) {
-  if(vs_fetch && (hcounter & 2) == 0) return exram[vs_vpos / 8 * 32 + vs_hpos / 8];
-  if(vs_fetch && (hcounter & 2) != 0) return exram[vs_vpos / 32 * 8 + vs_hpos / 32 + 0x03c0];
+  if(vs_fetch && (hcounter & 2) == 0) return ram.read(vs_vpos / 8 * 32 + vs_hpos / 8);
+  if(vs_fetch && (hcounter & 2) != 0) return ram.read(vs_vpos / 32 * 8 + vs_hpos / 32 + 0x03c0);
 
   switch(nametable_mode[(addr >> 10) & 3]) {
   case 0: return ppu.ciram_read(0x0000 | (addr & 0x03ff));
   case 1: return ppu.ciram_read(0x0400 | (addr & 0x03ff));
-  case 2: return exram_mode < 2 ? exram[addr & 0x03ff] : 0x00;
+  case 2: return exram_mode < 2 ? ram.read(addr & 0x03ff) : 0x00;
   case 3: return (hcounter & 2) == 0 ? fillmode_tile : fillmode_color;
   }
 }
@@ -352,7 +350,7 @@
   if(in_frame == false) {
     vs_fetch = false;
     if(addr & 0x2000) return ciram_read(addr);
-    return board.chrrom.read(chr_active ? chr_bg_addr(addr) : chr_sprite_addr(addr));
+    return board.read(board.chrrom, (chr_active ? chr_bg_addr(addr) : chr_sprite_addr(addr)));
   }
 
   bool bg_fetch = (hcounter < 256 || hcounter >= 320);
@@ -367,18 +365,18 @@
 
     result = ciram_read(addr);
 
-    exbank = (chr_bank_hi << 6) | (exram[addr & 0x03ff] & 0x3f);
-    exattr = exram[addr & 0x03ff] >> 6;
+    exbank = (chr_bank_hi << 6) | (ram.read(addr & 0x03ff) & 0x3f);
+    exattr = ram.read(addr & 0x03ff) >> 6;
     exattr |= exattr << 2;
     exattr |= exattr << 4;
   } else if((hcounter & 7) == 2) {
     result = ciram_read(addr);
     if(bg_fetch && exram_mode == 1) result = exattr;
   } else {
-    if(vs_fetch) result = board.chrrom.read(chr_vs_addr(addr));
-    else if(sprite_8x16 ? bg_fetch : chr_active) result = board.chrrom.read(chr_bg_addr(addr));
-    else result = board.chrrom.read(chr_sprite_addr(addr));
-    if(bg_fetch && exram_mode == 1) result = board.chrrom.read(exbank * 0x1000 + (addr & 0x0fff));
+    if(vs_fetch) result = board.read(board.chrrom, (chr_vs_addr(addr)));
+    else if(sprite_8x16 ? bg_fetch : chr_active) result = board.read(board.chrrom, (chr_bg_addr(addr)));
+    else result = board.read(board.chrrom, (chr_sprite_addr(addr)));
+    if(bg_fetch && exram_mode == 1) result = board.read(board.chrrom, (exbank * 0x1000 + (addr & 0x0fff)));
   }
 
   hcounter += 2;
@@ -390,7 +388,7 @@
     switch(nametable_mode[(addr >> 10) & 3]) {
     case 0: return ppu.ciram_write(0x0000 | (addr & 0x03ff), data);
     case 1: return ppu.ciram_write(0x0400 | (addr & 0x03ff), data);
-    case 2: exram[addr & 0x03ff] = data; break;
+    case 2: ram.write(addr & 0x03ff, data); break;
     }
   }
 }
@@ -399,7 +397,7 @@
 }
 
 void reset() {
-  for(auto& n : exram) n = 0xff;
+  for(unsigned i = 0; i < ram.size(); i++) ram.write(i, 0xff);
 
   prg_mode = 3;
   chr_mode = 0;
@@ -446,7 +444,7 @@
 }
 
 void serialize(serializer& s) {
-  s.array(exram);
+  s.array(ram.data(), ram.size());
 
   s.integer(prg_mode);
   s.integer(chr_mode);
@@ -490,8 +488,11 @@
   s.integer(vs_hpos);
 }
 
-MMC5(Board& board) : Chip(board) {
-  revision = Revision::MMC5;
+MMC5(Board& board, Markup::Node& cartridge) : Chip(board) {
+  string type = cartridge["chip/type"].text();
+
+  if(type == "MMC5" ) revision = Revision::MMC5;
+  if(type == "MMC5B") revision = Revision::MMC5B;
 }
 
 };
diff -Nru higan/fc/cartridge/chip/mmc6.cpp higan/fc/cartridge/chip/mmc6.cpp
--- higan/fc/cartridge/chip/mmc6.cpp	2015-09-16 02:20:06.372574580 +0900
+++ higan/fc/cartridge/chip/mmc6.cpp	2015-09-16 13:08:13.539563366 +0900
@@ -17,7 +17,7 @@
 
 uint16 chr_abus;
 
-void main() {
+void enter() {
   while(true) {
     if(scheduler.sync == Scheduler::SynchronizeMode::All) {
       scheduler.exit(Scheduler::ExitReason::SynchronizeEvent);
@@ -86,14 +86,14 @@
   if(ram_readable[0] == false && ram_readable[1] == false) return cpu.mdr();
   bool region = addr & 0x0200;
   if(ram_readable[region] == false) return 0x00;
-  return board.prgram.read((region * 0x0200) + (addr & 0x01ff));
+  return board.read(board.prgram, (region * 0x0200) + (addr & 0x01ff));
 }
 
 void ram_write(unsigned addr, uint8 data) {
   if(ram_enable == false) return;
   bool region = addr & 0x0200;
   if(ram_writable[region] == false) return;
-  return board.prgram.write((region * 0x0200) + (addr & 0x01ff), data);
+  return board.write(board.prgram, (region * 0x0200) + (addr & 0x01ff), data);
 }
 
 void reg_write(unsigned addr, uint8 data) {
diff -Nru higan/fc/cartridge/chip/n108.cpp higan/fc/cartridge/chip/n108.cpp
--- higan/fc/cartridge/chip/n108.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/fc/cartridge/chip/n108.cpp	2015-09-16 13:08:13.540563366 +0900
@@ -0,0 +1,83 @@
+struct N108 : Chip {
+
+enum class Revision : unsigned {
+  N108,
+  N109,
+  N118,
+  N119,
+} revision;
+
+uint3 bank_select;
+uint8 prg_bank[2];
+uint8 chr_bank[6];
+
+unsigned prg_addr(unsigned addr) const {
+  switch((addr >> 13) & 3) {
+  case 0: return (prg_bank[0] << 13) | (addr & 0x1fff);
+  case 1: return (prg_bank[1] << 13) | (addr & 0x1fff);
+  case 2: return (0x0e << 13) | (addr & 0x1fff);
+  case 3: return (0x0f << 13) | (addr & 0x1fff);
+  }
+}
+
+unsigned chr_addr(unsigned addr) const {
+  if(addr <= 0x07ff) return (chr_bank[0] << 10) | (addr & 0x07ff);
+  if(addr <= 0x0fff) return (chr_bank[1] << 10) | (addr & 0x07ff);
+  if(addr <= 0x13ff) return (chr_bank[2] << 10) | (addr & 0x03ff);
+  if(addr <= 0x17ff) return (chr_bank[3] << 10) | (addr & 0x03ff);
+  if(addr <= 0x1bff) return (chr_bank[4] << 10) | (addr & 0x03ff);
+  if(addr <= 0x1fff) return (chr_bank[5] << 10) | (addr & 0x03ff);
+}
+
+void reg_write(unsigned addr, uint8 data) {
+  switch(addr & 0x8001) {
+  case 0x8000:
+    bank_select = data & 0x07;
+    break;
+
+  case 0x8001:
+    switch(bank_select) {
+    case 0: chr_bank[0] = data & 0x3e; break;
+    case 1: chr_bank[1] = data & 0x3e; break;
+    case 2: chr_bank[2] = data & 0x3f; break;
+    case 3: chr_bank[3] = data & 0x3f; break;
+    case 4: chr_bank[4] = data & 0x3f; break;
+    case 5: chr_bank[5] = data & 0x3f; break;
+    case 6: prg_bank[0] = data & 0x0f; break;
+    case 7: prg_bank[1] = data & 0x0f; break;
+    }
+    break;
+  }
+}
+
+void power() {
+}
+
+void reset() {
+  bank_select = 0;
+  prg_bank[0] = 0;
+  prg_bank[1] = 0;
+  chr_bank[0] = 0;
+  chr_bank[1] = 0;
+  chr_bank[2] = 0;
+  chr_bank[3] = 0;
+  chr_bank[4] = 0;
+  chr_bank[5] = 0;
+}
+
+void serialize(serializer& s) {
+  s.integer(bank_select);
+  s.array(prg_bank);
+  s.array(chr_bank);
+}
+
+N108(Board& board, Markup::Node& cartridge) : Chip(board) {
+  string type = cartridge["chip/type"].text();
+
+  if(type.match("*108*")) revision = Revision::N108;
+  if(type.match("*109*")) revision = Revision::N109;
+  if(type.match("*118*")) revision = Revision::N118;
+  if(type.match("*119*")) revision = Revision::N119;
+}
+
+};
diff -Nru higan/fc/cartridge/chip/n163.cpp higan/fc/cartridge/chip/n163.cpp
--- higan/fc/cartridge/chip/n163.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/fc/cartridge/chip/n163.cpp	2015-09-16 13:08:13.535563366 +0900
@@ -0,0 +1,226 @@
+struct N163 : Chip {
+
+enum class Revision : unsigned {
+  N129,
+  N163,
+  N175,
+  N340,
+} revision;
+
+uint6 prg_bank[3];
+uint8 chr_bank[12];
+uint15 irq_counter;
+bool irq_enable;
+uint2 chrram_disable;
+bool audio_disable;
+uint7 audio_address;
+bool audio_auto_increment;
+uint3 audio_channel;
+uint4 audio_channel_timer;
+bool ram_enable;
+uint2 mirror;
+
+void enter() {
+  while(true) {
+    if(irq_enable && irq_counter != 0x7fff) {
+      irq_counter++;
+      if(irq_counter == 0x7fff) cpu.set_irq_line(1);
+    }
+
+    if(!audio_disable) {
+      if(++audio_channel_timer == 15) {
+        audio_channel_timer = 0;
+      }
+    }
+    tick();
+  }
+}
+
+uint8 prg_read(unsigned addr) {
+  switch(addr & 0xf800) {
+  case 0x4800:
+    if(revision == Revision::N129 || revision == Revision::N163) {
+      uint8 byte = ram.read(audio_address);
+      if(audio_auto_increment) audio_address++;
+      return byte;
+    }
+    break;
+  case 0x5000: return irq_counter & 0xff;
+  case 0x5800: return ((irq_counter >> 8) & 0x7f) | (irq_enable << 7);
+  case 0x6000: case 0x6800: case 0x7000: case 0x7800:
+    if(ram_enable) return board.read(board.prgram, addr & 0x1fff);
+  case 0x8000: case 0x8800: case 0x9000: case 0x9800:
+  case 0xa000: case 0xa800: case 0xb000: case 0xb800:
+  case 0xc000: case 0xc800: case 0xd000: case 0xd800:
+    return board.read(board.prgrom, (prg_bank[(addr & 0x6000) >> 13] << 13) | (addr & 0x1fff));
+  case 0xe000: case 0xe800: case 0xf000: case 0xf800:
+    return board.read(board.prgrom, (0x3f << 13) | (addr & 0x1fff));
+  default: return cpu.mdr();
+  }
+}
+
+void prg_write(unsigned addr, uint8 data) {
+  if((addr & 0xe000) == 0x6000) {
+    if(ram_enable) {
+      board.write(board.prgram, addr & 0x1fff, data);
+    }
+  } else reg_write(addr, data);
+}
+
+void reg_write(unsigned addr, uint8 data) {
+  switch(addr & 0xf800) {
+  case 0x4800: // Audio
+    if(revision == Revision::N129 || revision == Revision::N163) {
+      ram.write(audio_address, data);
+      if(audio_auto_increment) audio_address++;
+    }
+    break;
+  case 0x5000: // IRQ Low
+    if(revision == Revision::N129 || revision == Revision::N163) {
+      irq_counter = (irq_counter & 0xff00) | data;
+      cpu.set_irq_line(0);
+    }
+    break;
+  case 0x5800: // IRQ High
+    if(revision == Revision::N129 || revision == Revision::N163) {
+      irq_counter = (irq_counter & 0x00ff) | ((data & 0x7f) << 8);
+      irq_enable = data & 0x80;
+      cpu.set_irq_line(0);
+    }
+    break;
+  case 0x8000: case 0x8800: case 0x9000: case 0x9800: // CHR Select
+  case 0xa000: case 0xa800: case 0xb000: case 0xb800:
+    chr_bank[(addr & 0x7800) >> 11] = data;
+    break;
+  case 0xc000: // Nametable Select/RAM Enable
+    if(revision == Revision::N175) {
+      ram_enable = data & 0x01;
+    }
+  case 0xc800: case 0xd000: case 0xd800: // Nametable Select
+    if(revision == Revision::N129 || revision == Revision::N163) {
+      chr_bank[(addr & 0x7800) >> 11] = data;
+    }
+    break;
+  case 0xe000: // PRG Select 8000
+    prg_bank[0] = data & 0x3f;
+    if(revision == Revision::N129 || revision == Revision::N163) {
+      audio_disable = data & 0x40;
+    } else if(revision == Revision::N340) {
+      mirror = (data & 0xc0) >> 6;
+    }
+    break;
+  case 0xe800: // PRG Select A000
+    prg_bank[1] = data & 0x3f;
+    if(revision == Revision::N129 || revision == Revision::N163) {
+      chrram_disable = (data & 0xc0) >> 6;
+    }
+    break;
+  case 0xf000: // PRG Select C000
+    prg_bank[2] = data & 0x3f;
+    break;
+  case 0xf800: // Sound RAM Address/Write Protection for External RAM
+    if(revision == Revision::N129 || revision == Revision::N163) {
+      audio_address = data & 0x7f;
+      audio_auto_increment = data & 0x80;
+    }
+    break;
+  }
+}
+
+unsigned ciram_addr(unsigned addr) {
+  switch(mirror) {
+  case 0: return (addr & 0x03ff) | (0x0000);
+  case 1: return (addr & 0x03ff) | ((addr & 0x400) >> 0);
+  case 2: return (addr & 0x03ff) | ((addr & 0x800) >> 1);
+  case 3: return (addr & 0x03ff) | (0x0400);
+  }
+}
+
+uint8 chr_read(unsigned addr) {
+  if(addr & 0x2000) {
+    if(revision == Revision::N175 || revision == Revision::N340) {
+      return ppu.ciram_read(ciram_addr(addr));
+    }
+    addr &= 0x2fff;
+  }
+  uint8 bank = chr_bank[(addr & 0x3c00) >> 10];
+  if(bank >= 0xe0 && ((addr & 0x2000) | !(chrram_disable & (1 << ((addr & 0x1000) >> 12))))) {
+    addr = (addr & 0x03ff) | (bank << 10);
+    if(board.chrram.size()) return board.read(board.chrram, addr);
+    else                    return ppu.ciram_read(addr);
+  } else return board.read(board.chrrom, ((bank << 10) | (addr & 0x3ff)));
+}
+
+void chr_write(unsigned addr, uint8 data) {
+  if(addr & 0x2000) {
+    if(revision == Revision::N175 || revision == Revision::N340) {
+      return ppu.ciram_write(ciram_addr(addr), data);
+    }
+    addr &= 0x2fff;
+  }
+  uint8 bank = chr_bank[(addr & 0x3c00) >> 10];
+  if(bank >= 0xe0 && ((addr & 0x2000) | !(chrram_disable & (1 << ((addr & 0x1000) >> 12))))) {
+    addr = (addr & 0x03ff) | (bank << 10);
+    if(board.chrram.size()) return board.write(board.chrram, addr, data);
+    else                    return ppu.ciram_write(addr, data);
+  }
+}
+
+void serialize(serializer& s) {
+  s.array(ram.data(), ram.size());
+
+  s.array(prg_bank);
+  s.array(chr_bank);
+  if(revision == Revision::N129 || revision == Revision::N163) {
+    s.integer(irq_counter);
+    s.integer(irq_enable);
+    s.integer(chrram_disable);
+    s.integer(audio_disable);
+    s.integer(audio_address);
+    s.integer(audio_auto_increment);
+  } else if(revision == Revision::N175) {
+    s.integer(ram_enable);
+  } else if(revision == Revision::N340) {
+    s.integer(mirror);
+  }
+}
+
+void power() {
+}
+
+void reset() {
+  prg_bank[0] = 0;
+  prg_bank[1] = 0;
+  prg_bank[2] = 0;
+  chr_bank[0] = 0;
+  chr_bank[1] = 0;
+  chr_bank[2] = 0;
+  chr_bank[3] = 0;
+  chr_bank[4] = 0;
+  chr_bank[5] = 0;
+  chr_bank[6] = 0;
+  chr_bank[7] = 0;
+  chr_bank[8] = 0;
+  chr_bank[9] = 0;
+  chr_bank[10] = 0;
+  chr_bank[11] = 0;
+  irq_counter = 0;
+  irq_enable = false;
+  chrram_disable = 0;
+  audio_disable = true;
+  audio_address = 0x00;
+  audio_auto_increment = false;
+  ram_enable = revision != Revision::N175;
+  mirror = 0;
+}
+
+N163(Board& board, Markup::Node& cartridge) : Chip(board) {
+  string type = cartridge["chip/type"].text();
+
+  if(type == "129") revision = Revision::N129;
+  if(type == "163") revision = Revision::N163;
+  if(type == "175") revision = Revision::N175;
+  if(type == "340") revision = Revision::N340;
+}
+
+};
diff -Nru higan/fc/cartridge/chip/ss88006.cpp higan/fc/cartridge/chip/ss88006.cpp
--- higan/fc/cartridge/chip/ss88006.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/fc/cartridge/chip/ss88006.cpp	2015-09-16 13:08:13.541563366 +0900
@@ -0,0 +1,143 @@
+struct SS88006 : Chip {
+
+uint8 prg_bank[3];
+uint8 chr_bank[8];
+uint2 mirror;
+bool ram_enable;
+bool ram_write_enable;
+uint16 irq_counter;
+uint16 irq_latch;
+bool irq_enable;
+uint16 irq_mask;
+
+void enter() {
+  while(true) {
+    if(scheduler.sync == Scheduler::SynchronizeMode::All) {
+      scheduler.exit(Scheduler::ExitReason::SynchronizeEvent);
+    }
+
+    if(irq_enable) {
+      irq_counter = (irq_counter & ~irq_mask) | ((irq_counter - 1) & irq_mask);
+      if((irq_counter & irq_mask) == irq_mask) cpu.set_irq_line(1);
+    }
+    tick();
+  }
+}
+
+unsigned prg_addr(unsigned addr) const {
+  switch((addr >> 13) & 3) {
+  case 0: return (prg_bank[0] << 13) | (addr & 0x1fff);
+  case 1: return (prg_bank[1] << 13) | (addr & 0x1fff);
+  case 2: return (prg_bank[2] << 13) | (addr & 0x1fff);
+  case 3: return (0xff << 13) | (addr & 0x1fff);
+  }
+}
+
+unsigned chr_addr(unsigned addr) const {
+  return (chr_bank[addr >> 10] << 10) | (addr & 0x03ff);
+}
+
+unsigned ciram_addr(unsigned addr) const {
+  switch(mirror) {
+  case 0: return (addr & 0x03ff) | ((addr & 0x0800) >> 1);
+  case 1: return (addr & 0x03ff) | ((addr & 0x0400) >> 0);
+  case 2: return (addr & 0x03ff) | 0x0000;
+  case 3: return (addr & 0x03ff) | 0x0400;
+  }
+}
+
+uint8 ram_read(unsigned addr) {
+  if(ram_enable) return board.read(board.prgram, addr & 0x1fff);
+}
+
+void ram_write(unsigned addr, uint8 data) {
+  if(ram_enable && ram_write_enable) board.write(board.prgram, addr & 0x1fff, data);
+}
+
+void reg_write(unsigned addr, uint8 data) {
+  data &= 0x0f;
+  switch(addr & 0xf003) {
+  case 0x8000: prg_bank[0] = (prg_bank[0] & 0xf0) | (data << 0); break;
+  case 0x8001: prg_bank[0] = (prg_bank[0] & 0x0f) | (data << 4); break;
+  case 0x8002: prg_bank[1] = (prg_bank[1] & 0xf0) | (data << 0); break;
+  case 0x8003: prg_bank[1] = (prg_bank[1] & 0x0f) | (data << 4); break;
+  case 0x9000: prg_bank[2] = (prg_bank[2] & 0xf0) | (data << 0); break;
+  case 0x9001: prg_bank[2] = (prg_bank[2] & 0x0f) | (data << 4); break;
+  case 0x9002:
+    ram_enable = data & 0x01;
+    ram_write_enable = data & 0x02;
+    break;
+  case 0xa000: chr_bank[0] = (chr_bank[0] & 0xf0) | (data << 0); break;
+  case 0xa001: chr_bank[0] = (chr_bank[0] & 0x0f) | (data << 4); break;
+  case 0xa002: chr_bank[1] = (chr_bank[1] & 0xf0) | (data << 0); break;
+  case 0xa003: chr_bank[1] = (chr_bank[1] & 0x0f) | (data << 4); break;
+  case 0xb000: chr_bank[2] = (chr_bank[2] & 0xf0) | (data << 0); break;
+  case 0xb001: chr_bank[2] = (chr_bank[2] & 0x0f) | (data << 4); break;
+  case 0xb002: chr_bank[3] = (chr_bank[3] & 0xf0) | (data << 0); break;
+  case 0xb003: chr_bank[3] = (chr_bank[3] & 0x0f) | (data << 4); break;
+  case 0xc000: chr_bank[4] = (chr_bank[4] & 0xf0) | (data << 0); break;
+  case 0xc001: chr_bank[4] = (chr_bank[4] & 0x0f) | (data << 4); break;
+  case 0xc002: chr_bank[5] = (chr_bank[5] & 0xf0) | (data << 0); break;
+  case 0xc003: chr_bank[5] = (chr_bank[5] & 0x0f) | (data << 4); break;
+  case 0xd000: chr_bank[6] = (chr_bank[6] & 0xf0) | (data << 0); break;
+  case 0xd001: chr_bank[6] = (chr_bank[6] & 0x0f) | (data << 4); break;
+  case 0xd002: chr_bank[7] = (chr_bank[7] & 0xf0) | (data << 0); break;
+  case 0xd003: chr_bank[7] = (chr_bank[7] & 0x0f) | (data << 4); break;
+  case 0xe000: irq_latch = (irq_latch & 0xfff0) | (data << 0x0); break;
+  case 0xe001: irq_latch = (irq_latch & 0xff0f) | (data << 0x4); break;
+  case 0xe002: irq_latch = (irq_latch & 0xf0ff) | (data << 0x8); break;
+  case 0xe003: irq_latch = (irq_latch & 0x0fff) | (data << 0xc); break;
+  case 0xf000:
+    cpu.set_irq_line(0);
+    irq_counter = irq_latch;
+    break;
+  case 0xf001:
+    cpu.set_irq_line(0);
+    irq_enable = data & 0x01;
+    irq_mask = data & 0x08 ? 0x000f : (data & 0x04 ? 0x00ff : (data & 0x02 ? 0x0fff : 0xffff));
+    break;
+  case 0xf002: mirror = data & 0x03; break;
+  case 0xf003: break; //TODO: μPD7756C ADPCM sound IC
+  }
+}
+
+void power() {
+}
+
+void reset() {
+  prg_bank[0] = 0;
+  prg_bank[1] = 0;
+  prg_bank[2] = 0;
+  chr_bank[0] = 0;
+  chr_bank[1] = 0;
+  chr_bank[2] = 0;
+  chr_bank[3] = 0;
+  chr_bank[4] = 0;
+  chr_bank[5] = 0;
+  chr_bank[6] = 0;
+  chr_bank[7] = 0;
+  mirror = 0;
+  ram_enable = 0;
+  ram_write_enable = 0;
+  irq_counter = 0;
+  irq_latch = 0;
+  irq_enable = false;
+  irq_mask = 0xffff;
+}
+
+void serialize(serializer& s) {
+  s.array(prg_bank);
+  s.array(chr_bank);
+  s.integer(mirror);
+  s.integer(ram_enable);
+  s.integer(ram_write_enable);
+  s.integer(irq_counter);
+  s.integer(irq_latch);
+  s.integer(irq_enable);
+  s.integer(irq_mask);
+}
+
+SS88006(Board& board, Markup::Node& cartridge) : Chip(board) {
+}
+
+};
diff -Nru higan/fc/cartridge/chip/tc.cpp higan/fc/cartridge/chip/tc.cpp
--- higan/fc/cartridge/chip/tc.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/fc/cartridge/chip/tc.cpp	2015-09-16 13:08:13.538563366 +0900
@@ -0,0 +1,167 @@
+struct TC : Chip {
+
+enum class Revision : unsigned {
+  TC0190FMC, // No IRQ
+  TC0350FMR, // identical to TC0190 except with IRQ that no game uses
+  TC0690FMR,
+} revision;
+
+struct Settings {
+  bool pal16r4;
+} settings;
+
+uint8 prg_bank[2];
+uint8 chr_bank[6];
+bool mirror;
+uint8 irq_latch;
+uint8 irq_counter;
+bool irq_enable;
+unsigned irq_delay;
+bool irq_line;
+
+uint16 chr_abus;
+
+void enter() {
+  while(true) {
+    if(scheduler.sync == Scheduler::SynchronizeMode::All) {
+      scheduler.exit(Scheduler::ExitReason::SynchronizeEvent);
+    }
+
+    if(revision != Revision::TC0190FMC) {
+      if(irq_delay) irq_delay--;
+      irq_test(ppu.status.chr_abus);
+      cpu.set_irq_line(irq_line);
+    }
+    tick();
+  }
+}
+
+void irq_test(unsigned addr) {
+  bool edge;
+  // IRQs occur a little after they would on the MMC3.
+  // Do they use the MC-ACC's behavior instead?
+  edge = (chr_abus & 0x1000) && !(addr & 0x1000);
+  if(edge) {
+    if(irq_delay == 0) {
+      if(irq_counter == 0xff) {
+        irq_counter = irq_latch;
+      } else if(++irq_counter == 0xff) {
+        if(irq_enable) irq_line = 1;
+      }
+    }
+    irq_delay = 6;
+  }
+  chr_abus = addr;
+}
+
+unsigned prg_addr(unsigned addr) const {
+  switch((addr >> 13) & 3) {
+  case 0: return (prg_bank[0] << 13) | (addr & 0x1fff);
+  case 1: return (prg_bank[1] << 13) | (addr & 0x1fff);
+  case 2: return (0x3e << 13) | (addr & 0x1fff);
+  case 3: return (0x3f << 13) | (addr & 0x1fff);
+  }
+}
+
+unsigned chr_addr(unsigned addr) const {
+  if(addr <= 0x07ff) return (chr_bank[0] << 11) | (addr & 0x07ff);
+  if(addr <= 0x0fff) return (chr_bank[1] << 11) | (addr & 0x07ff);
+  if(addr <= 0x13ff) return (chr_bank[2] << 10) | (addr & 0x03ff);
+  if(addr <= 0x17ff) return (chr_bank[3] << 10) | (addr & 0x03ff);
+  if(addr <= 0x1bff) return (chr_bank[4] << 10) | (addr & 0x03ff);
+  if(addr <= 0x1fff) return (chr_bank[5] << 10) | (addr & 0x03ff);
+}
+
+unsigned ciram_addr(unsigned addr) const {
+  if(mirror == 0) return ((addr & 0x0400) >> 0) | (addr & 0x03ff);
+  if(mirror == 1) return ((addr & 0x0800) >> 1) | (addr & 0x03ff);
+}
+
+void reg_write(unsigned addr, uint8 data) {
+  switch(addr & 0xe003) {
+  case 0x8000:
+    prg_bank[0] = data & 0x3f;
+    if(revision != Revision::TC0690FMR && !settings.pal16r4) mirror = data & 0x40;
+    break;
+  case 0x8001:
+    prg_bank[1] = data & 0x3f;
+    break;
+
+  case 0x8002: chr_bank[0] = data; break;
+  case 0x8003: chr_bank[1] = data; break;
+  case 0xa000: chr_bank[2] = data; break;
+  case 0xa001: chr_bank[3] = data; break;
+  case 0xa002: chr_bank[4] = data; break;
+  case 0xa003: chr_bank[5] = data; break;
+
+  case 0xc000:
+    if(revision != Revision::TC0190FMC) break;
+    irq_latch = data;
+    break;
+
+  case 0xc001:
+    if(revision != Revision::TC0190FMC) break;
+    irq_counter = 0xff;
+    break;
+
+  case 0xc002:
+    if(revision != Revision::TC0190FMC) break;
+    irq_enable = true;
+    break;
+
+  case 0xc003:
+    if(revision != Revision::TC0190FMC) break;
+    irq_enable = false;
+    irq_line = 0;
+    break;
+
+  case 0xe000:
+    if(revision == Revision::TC0690FMR || settings.pal16r4) mirror = data & 0x40;
+    break;
+  }
+}
+
+void power() {
+}
+
+void reset() {
+  prg_bank[0] = 0;
+  prg_bank[1] = 0;
+  chr_bank[0] = 0;
+  chr_bank[1] = 0;
+  chr_bank[2] = 0;
+  chr_bank[3] = 0;
+  chr_bank[4] = 0;
+  chr_bank[5] = 0;
+  mirror = 0;
+  irq_latch = 0;
+  irq_counter = 0;
+  irq_enable = false;
+  irq_delay = 0;
+  irq_line = 0;
+
+  chr_abus = 0;
+}
+
+void serialize(serializer& s) {
+  s.array(prg_bank);
+  s.array(chr_bank);
+  s.integer(mirror);
+  s.integer(irq_latch);
+  s.integer(irq_counter);
+  s.integer(irq_enable);
+  s.integer(irq_delay);
+  s.integer(irq_line);
+
+  s.integer(chr_abus);
+}
+
+TC(Board& board, Markup::Node& cartridge) : Chip(board) {
+  string type = cartridge["chip[0]/type"].text();
+  if(type == "TC0190FMC") revision = Revision::TC0190FMC;
+  if(type == "TC0350FMR") revision = Revision::TC0350FMR;
+  if(type == "TC0690FMR") revision = Revision::TC0690FMR;
+  settings.pal16r4 = (bool)cartridge["chip(type=PAL16R4)"];
+}
+
+};
diff -Nru higan/fc/cartridge/chip/vrc2.cpp higan/fc/cartridge/chip/vrc2.cpp
--- higan/fc/cartridge/chip/vrc2.cpp	2015-09-16 02:20:06.372574580 +0900
+++ higan/fc/cartridge/chip/vrc2.cpp	2015-09-16 13:08:13.537563366 +0900
@@ -32,19 +32,19 @@
 }
 
 uint8 ram_read(unsigned addr) {
-  if(board.prgram.size == 0) {
+  if(board.prgram.size() == 0) {
     if((addr & 0xf000) == 0x6000) return cpu.mdr() | latch;
     return cpu.mdr();
   }
-  return board.prgram.read(addr & 0x1fff);
+  return board.read(board.prgram, addr & 0x1fff);
 }
 
 void ram_write(unsigned addr, uint8 data) {
-  if(board.prgram.size == 0) {
+  if(board.prgram.size() == 0) {
     if((addr & 0xf000) == 0x6000) latch = data & 0x01;
     return;
   }
-  return board.prgram.write(addr & 0x1fff, data);
+  return board.write(board.prgram, addr & 0x1fff, data);
 }
 
 void reg_write(unsigned addr, uint8 data) {
diff -Nru higan/fc/cartridge/chip/vrc3.cpp higan/fc/cartridge/chip/vrc3.cpp
--- higan/fc/cartridge/chip/vrc3.cpp	2015-09-16 02:20:06.372574580 +0900
+++ higan/fc/cartridge/chip/vrc3.cpp	2015-09-16 13:08:13.541563366 +0900
@@ -13,7 +13,7 @@
 } irq_counter;
 bool irq_line;
 
-void main() {
+void enter() {
   while(true) {
     if(scheduler.sync == Scheduler::SynchronizeMode::All) {
       scheduler.exit(Scheduler::ExitReason::SynchronizeEvent);
diff -Nru higan/fc/cartridge/chip/vrc4.cpp higan/fc/cartridge/chip/vrc4.cpp
--- higan/fc/cartridge/chip/vrc4.cpp	2015-09-16 02:20:06.372574580 +0900
+++ higan/fc/cartridge/chip/vrc4.cpp	2015-09-16 13:08:13.542563366 +0900
@@ -14,7 +14,7 @@
 signed irq_scalar;
 bool irq_line;
 
-void main() {
+void enter() {
   while(true) {
     if(scheduler.sync == Scheduler::SynchronizeMode::All) {
       scheduler.exit(Scheduler::ExitReason::SynchronizeEvent);
@@ -50,7 +50,7 @@
 }
 
 unsigned prg_addr(unsigned addr) const {
-  unsigned bank = 0, banks = board.prgrom.size / 0x2000;
+  unsigned bank = 0, banks = board.prgrom.size() / 0x2000;
   switch(addr & 0xe000) {
   case 0x8000: bank = prg_mode == 0 ? (unsigned)prg_bank[0] : banks - 2; break;
   case 0xa000: bank = prg_bank[1]; break;
diff -Nru higan/fc/cartridge/chip/vrc6.cpp higan/fc/cartridge/chip/vrc6.cpp
--- higan/fc/cartridge/chip/vrc6.cpp	2015-09-16 02:20:06.372574580 +0900
+++ higan/fc/cartridge/chip/vrc6.cpp	2015-09-16 13:08:13.540563366 +0900
@@ -86,7 +86,7 @@
   }
 } sawtooth;
 
-void main() {
+void enter() {
   while(true) {
     if(scheduler.sync == Scheduler::SynchronizeMode::All) {
       scheduler.exit(Scheduler::ExitReason::SynchronizeEvent);
@@ -148,11 +148,11 @@
 }
 
 uint8 ram_read(unsigned addr) {
-  return board.prgram.data[addr & 0x1fff];
+  return board.read(board.prgram, addr & 0x1fff);
 }
 
 void ram_write(unsigned addr, uint8 data) {
-  board.prgram.data[addr & 0x1fff] = data;
+  board.write(board.prgram, addr & 0x1fff, data);
 }
 
 void reg_write(unsigned addr, uint8 data) {
diff -Nru higan/fc/cartridge/chip/vrc7.cpp higan/fc/cartridge/chip/vrc7.cpp
--- higan/fc/cartridge/chip/vrc7.cpp	2015-09-16 02:20:06.372574580 +0900
+++ higan/fc/cartridge/chip/vrc7.cpp	2015-09-16 13:08:13.536563366 +0900
@@ -16,7 +16,7 @@
 signed irq_scalar;
 bool irq_line;
 
-void main() {
+void enter() {
   while(true) {
     if(scheduler.sync == Scheduler::SynchronizeMode::All) {
       scheduler.exit(Scheduler::ExitReason::SynchronizeEvent);
diff -Nru higan/fc/cartridge/markup.cpp higan/fc/cartridge/markup.cpp
--- higan/fc/cartridge/markup.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/fc/cartridge/markup.cpp	2015-09-16 13:08:13.535563366 +0900
@@ -0,0 +1,86 @@
+#ifdef CARTRIDGE_CPP
+
+void Cartridge::parseMarkup(const char* markup) {
+  auto document = BML::unserialize(markup);
+  information.title.cartridge = document["information/title"].text();
+
+  auto cartridge = document["cartridge"];
+  _region = cartridge["region"].text() != "PAL" ? Region::NTSC : Region::PAL;
+
+  if(system.revision == System::Revision::VSSystem) {
+    unsigned ppus = 0;
+    auto vs = document["cartridge"].find("vs");
+    if(vs(0)["ppu"]) {
+      cartridge = vs(0);
+      ppus++;
+    }
+    if(vs(1)["ppu"]) {
+      if(ppus == 0) cartridge = vs(1);
+      ppus++;
+    }
+    auto controller = cartridge.find("controller");
+    vsarcadeboard.swap_controllers = controller(0)["port"].integer() == 2;
+    string device1 = cartridge["controller(port=1)/device"].text();
+    string device2 = cartridge["controller(port=2)/device"].text();
+    if(device1 == "joypad") {
+      input.connect(0, Input::Device::Joypad);
+    } else if(device1 == "none") {
+      input.connect(0, Input::Device::None);
+    }
+    if(device2 == "joypad") {
+      input.connect(1, Input::Device::Joypad);
+    } else if(device2 == "beamgun") {
+      input.connect(1, Input::Device::BeamGun);
+    } else if(device2 == "none") {
+      input.connect(1, Input::Device::None);
+    }
+    vsarcadeboard.set_dip(interface->dipSettings(cartridge));
+    string ppu_revision = cartridge["ppu/revision"].text();
+    if(ppu_revision == "RP2C02C")     ppu.revision = PPU::Revision::RP2C02C;
+    if(ppu_revision == "RP2C02G")     ppu.revision = PPU::Revision::RP2C02G;
+    if(ppu_revision == "RP2C03B")     ppu.revision = PPU::Revision::RP2C03B;
+    if(ppu_revision == "RP2C03G")     ppu.revision = PPU::Revision::RP2C03G;
+    if(ppu_revision == "RP2C04-0001") ppu.revision = PPU::Revision::RP2C04_0001;
+    if(ppu_revision == "RP2C04-0002") ppu.revision = PPU::Revision::RP2C04_0002;
+    if(ppu_revision == "RP2C04-0003") ppu.revision = PPU::Revision::RP2C04_0003;
+    if(ppu_revision == "RP2C04-0004") ppu.revision = PPU::Revision::RP2C04_0004;
+    if(ppu_revision == "RC2C03B")     ppu.revision = PPU::Revision::RC2C03B;
+    if(ppu_revision == "RC2C03C")     ppu.revision = PPU::Revision::RC2C03C;
+    if(ppu_revision == "RC2C05-01")   ppu.revision = PPU::Revision::RC2C05_01;
+    if(ppu_revision == "RC2C05-02")   ppu.revision = PPU::Revision::RC2C05_02;
+    if(ppu_revision == "RC2C05-03")   ppu.revision = PPU::Revision::RC2C05_03;
+    if(ppu_revision == "RC2C05-04")   ppu.revision = PPU::Revision::RC2C05_04;
+    if(ppu_revision == "RC2C05-05")   ppu.revision = PPU::Revision::RC2C05_05;
+
+    if(ppus == 2) interface->information.width = 512;
+  }
+  Board::load(document["cartridge"]);  //this call will set Cartridge::board if successful
+  parseMarkupCartridge(cartridge);
+}
+
+//
+
+void Cartridge::parseMarkupMemory(MappedRAM& ram, Markup::Node node, unsigned id, bool writable) {
+  string name = node["name"].text();
+  unsigned size = node["size"].decimal();
+  ram.map(allocate<uint8>(size, 0xff), size);
+  if(name.empty() == false) {
+    interface->loadRequest(id, name, !writable);
+    if(writable) memory.append({id, name});
+  }
+}
+
+//
+
+void Cartridge::parseMarkupCartridge(Markup::Node root) {
+  parseMarkupMemory(board->prgrom, root["prg/rom"], ID::ProgramROM, false);
+  parseMarkupMemory(board->prgram, root["prg/ram"], ID::ProgramRAM, true);
+  parseMarkupMemory(board->chrrom, root["chr/rom"], ID::CharacterROM, false);
+  parseMarkupMemory(board->chrram, root["chr/ram"], ID::CharacterRAM, true);
+  if(system.pc10()) {
+    parseMarkupMemory(board->instrom, root["pc10/rom[0]"], ID::InstructionROM, false);
+    parseMarkupMemory(board->keyrom, root["pc10/rom[1]"], ID::KeyROM, false);
+  }
+}
+
+#endif
diff -Nru higan/fc/controller/beamgun/beamgun.cpp higan/fc/controller/beamgun/beamgun.cpp
--- higan/fc/controller/beamgun/beamgun.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/fc/controller/beamgun/beamgun.cpp	2015-09-16 13:08:13.516563364 +0900
@@ -0,0 +1,121 @@
+#ifdef CONTROLLER_CPP
+
+void BeamGun::enter() {
+  unsigned prev = 0;
+  unsigned next;
+  while(true) {
+    next = ppu.vcounter() * 341 + ppu.hcounter();
+
+    if(lighttime > 0) {
+      lighttime -= 1;
+    }
+
+    if(!offscreen) {
+      unsigned target = y * 341 + x + (!system.vs() ? 8 : 8);
+      if(next >= target && prev < target) {
+        //CRT raster detected
+        //light remains in the gun for 10-25 scanlines
+        if(read_light()) lighttime = (!system.vs() ? 341 * 16 : 341 * 262);
+      }
+    }
+
+    if(next < prev) {
+      if(triggertime > 0) triggertime -= 1;
+      //Vcounter wrapped back to zero; update cursor coordinates for start of new frame
+      int nx = poll((unsigned)Input::BeamGunID::X);
+      int ny = poll((unsigned)Input::BeamGunID::Y);
+      nx += x;
+      ny += y;
+      x = max(-16, min(256 + 16, nx));
+      y = max(-16, min(240 + 16, ny));
+      offscreen = (x < 0 || y < 0 || x >= 256 || y >= 240);
+    }
+
+    prev = next;
+    step(3);
+  }
+}
+
+uint5 BeamGun::data() {
+  if(!system.vs()) return data2();
+  if(counter >= 8) return 1;
+  if(latched == 1) return 0;
+
+  switch(counter++) {
+  case 0: return 0;
+  case 1: return 0;
+  case 2: return 0;
+  case 3: return 0;
+  case 4: return 1; // connected
+  case 5: return 0;
+  case 6: return light;
+  case 7: return trigger;
+  }
+}
+
+uint2 BeamGun::data1() {
+  return 0;
+}
+
+uint5 BeamGun::data2() {
+  bool newtrigger = poll((unsigned)Input::BeamGunID::Trigger);
+  if(newtrigger && !triggerlock) {
+    triggertime = 2;
+    triggerlock = true;
+  } else if(!newtrigger) {
+    triggerlock = false;
+  }
+  light = lighttime > 0;
+  trigger = triggertime > 0;
+
+  return (trigger << 4) | ((!light) << 3);
+}
+
+bool BeamGun::read_light() {
+  if(offscreen) return false;
+  uint32 palette_index = ppu.output[y * 256 + x];
+  unsigned color;
+  switch(ppu.revision) {
+  default:
+    return ((palette_index & 0x20) && ((palette_index & 0x0F) < 0x0D));
+  case PPU::Revision::RP2C04_0001:
+    color = PPU::RP2C04_0001[palette_index & 63];
+    break;
+  case PPU::Revision::RP2C04_0002:
+    color = PPU::RP2C04_0002[palette_index & 63];
+    break;
+  case PPU::Revision::RP2C04_0003:
+    color = PPU::RP2C04_0003[palette_index & 63];
+    break;
+  case PPU::Revision::RP2C04_0004:
+    color = PPU::RP2C04_0004[palette_index & 63];
+    break;
+  }
+  if((color & 0xF00) > 0x600) return true;
+  if((color & 0x0F0) > 0x060) return true;
+  if((color & 0x00F) > 0x006) return true;
+  return false;
+}
+
+void BeamGun::latch(bool data) {
+  if(latched == data) return;
+  latched = data;
+  if(system.vs() && latched == 0) {
+    counter = 0;
+    trigger = poll((unsigned)Input::BeamGunID::Trigger);
+    light = lighttime > 0;
+  }
+}
+
+BeamGun::BeamGun(unsigned port):
+Controller(port, (unsigned)Input::Device::BeamGun) {
+  create(Controller::Enter, system.cpu_frequency());
+  latched = 0;
+  counter = 0;
+
+  //center cursor onscreen
+  x = 256 / 2;
+  y = 240 / 2;
+}
+
+#endif
diff -Nru higan/fc/controller/beamgun/beamgun.hpp higan/fc/controller/beamgun/beamgun.hpp
--- higan/fc/controller/beamgun/beamgun.hpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/fc/controller/beamgun/beamgun.hpp	2015-09-16 13:08:13.515563364 +0900
@@ -0,0 +1,23 @@
+struct BeamGun : Controller {
+  void enter();
+  uint5 data();
+  uint2 data1();
+  uint5 data2();
+  bool read_light();
+  void latch(bool data);
+  BeamGun(unsigned port);
+
+//private:
+  bool latched;
+  unsigned counter; // VS. System
+
+  signed x, y;
+  bool light;
+  bool trigger;
+  unsigned lighttime;
+  unsigned triggertime;
+
+  bool offscreen;
+
+  bool triggerlock;
+};
diff -Nru higan/fc/controller/controller.cpp higan/fc/controller/controller.cpp
--- higan/fc/controller/controller.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/fc/controller/controller.cpp	2015-09-16 13:08:13.514563364 +0900
@@ -0,0 +1,50 @@
+#include <fc/fc.hpp>
+
+#define CONTROLLER_CPP
+namespace Famicom {
+
+#include "gamepad/gamepad.cpp"
+#include "fourplayers/fourplayers.cpp"
+#include "fourscore/fourscore.cpp"
+#include "beamgun/beamgun.cpp"
+#include "familytrainer/familytrainer.cpp"
+#include "sfcgamepad/sfcgamepad.cpp"
+#include "mouse/mouse.cpp"
+#include "vspanel/vspanel.cpp"
+
+Controller::Controller(unsigned port, unsigned device):
+port(port),
+device(device) {
+  if(!thread) create(Controller::Enter, 1);
+}
+
+Controller::Controller(unsigned port):
+port(port),
+device((unsigned)Input::Device::None) {
+  if(!thread) create(Controller::Enter, 1);
+}
+
+auto Controller::Enter() -> void {
+  if(co_active() == input.port1->thread) input.port1->enter();
+  if(co_active() == input.port2->thread) input.port2->enter();
+  if(co_active() == input.expansion->thread) input.expansion->enter();
+}
+
+auto Controller::enter() -> void {
+  while(true) step(1);
+}
+
+auto Controller::step(unsigned clocks) -> void {
+  clock += clocks * (uint64)cpu.frequency;
+  synchronize_cpu();
+}
+
+auto Controller::synchronize_cpu() -> void {
+  if(clock >= 0 && scheduler.sync != Scheduler::SynchronizeMode::All) co_switch(cpu.thread);
+}
+
+auto Controller::poll(unsigned input) -> int16_t {
+  return interface->inputPoll(port, interface->device_ref[device].port[port], input);
+}
+
+}
diff -Nru higan/fc/controller/controller.hpp higan/fc/controller/controller.hpp
--- higan/fc/controller/controller.hpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/fc/controller/controller.hpp	2015-09-16 13:08:13.514563364 +0900
@@ -0,0 +1,68 @@
+// NES controller port pinout:
+// ┌────
+// │(7)  \
+// │(2)(1)│
+// │(3)(5)│
+// │(4)(6)│
+// └──────┘
+// pin    name     port1                            port2
+//  1:    +5v
+//  2:    clock    $4016 read                       $4017 read
+//  3:    latch    $4016.d0 write                   $4016.d0 write
+//  4:    data0    $4016.d0 read                    $4017.d0 read
+//  5:    data3    $4016.d3 read                    $4017.d3 read
+//  6:    data4    $4016.d4 read                    $4017.d4 read
+//  7:    gnd
+
+// Famicom expansion port pinout:
+// /--------------------------------\
+// \(08)(07)(06)(05)(04)(03)(02)(01)/
+//  \ (15)(14)(13)(12)(11)(10)(09) /
+//   \----------------------------/
+// pin    name     register
+// 01:    gnd
+// 02:    sound
+// 03:    irq
+// 04:    data2.4  $4017.d4 read
+// 05:    data2.3  $4017.d3 read
+// 06:    data2.2  $4017.d2 read
+// 07:    data2.1  $4017.d1 read
+// 08:    data2.0  $4017.d0 read
+// 09:    /oe 2
+// 10:    out 2    $4016.d2 write
+// 11:    out 1    $4016.d1 write
+// 12:    latch    $4016.d0 write
+// 13:    data1.1  $4016.d1 read
+// 14:    /oe 1
+// 15:    +5v
+
+struct Controller : Thread {
+  enum : unsigned { Port1 = 0, Port2 = 1, ExpansionPort = 2 };
+  Controller(unsigned port, unsigned device);
+  Controller(unsigned port);
+  static auto Enter() -> void;
+  virtual auto enter() -> void;
+
+  auto step(unsigned clocks) -> void;
+  auto synchronize_cpu() -> void;
+
+  virtual auto data() -> uint5 { return 0; }
+  virtual auto data1() -> uint2 { return 0; }
+  virtual auto data2() -> uint5 { return 0; }
+  virtual auto latch(bool data) -> void {}
+
+  const unsigned port;
+  const unsigned device;
+
+protected:
+  auto poll(unsigned input) -> int16_t;
+};
+
+#include "gamepad/gamepad.hpp"
+#include "fourplayers/fourplayers.hpp"
+#include "fourscore/fourscore.hpp"
+#include "beamgun/beamgun.hpp"
+#include "familytrainer/familytrainer.hpp"
+#include "sfcgamepad/sfcgamepad.hpp"
+#include "mouse/mouse.hpp"
+#include "vspanel/vspanel.hpp"
diff -Nru higan/fc/controller/familytrainer/familytrainer.cpp higan/fc/controller/familytrainer/familytrainer.cpp
--- higan/fc/controller/familytrainer/familytrainer.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/fc/controller/familytrainer/familytrainer.cpp	2015-09-16 13:08:13.516563364 +0900
@@ -0,0 +1,58 @@
+#ifdef CONTROLLER_CPP
+
+uint5 FamilyTrainer::data() {
+  if(counter >= 8) return 0x18;
+  if(latched == 1) return (b2 << 3) | (b4 << 4);
+
+  switch(counter++) {
+  case  0: return (b2  << 3) | (b4  << 4);
+  case  1: return (b1  << 3) | (b3  << 4);
+  case  2: return (b5  << 3) | (b12 << 4);
+  case  3: return (b9  << 3) | (b8  << 4);
+  case  4: return (b6  << 3) | 0x10;
+  case  5: return (b10 << 3) | 0x10;
+  case  6: return (b11 << 3) | 0x10;
+  case  7: return (b7  << 3) | 0x10;
+  }
+}
+
+uint2 FamilyTrainer::data1() {
+  return 0;
+}
+
+uint5 FamilyTrainer::data2() {
+  return data();
+}
+
+void FamilyTrainer::latch(bool data) {
+  if(latched == data) return;
+  latched = data;
+  counter = 0;
+
+  if(latched == 0) {
+    b1  = poll( 0);
+    b2  = poll( 1);
+    b3  = poll( 2);
+    b4  = poll( 3);
+    b5  = poll( 4);
+    b6  = poll( 5);
+    b7  = poll( 6);
+    b8  = poll( 7);
+    b9  = poll( 8);
+    b10 = poll( 9);
+    b11 = poll(10);
+    b12 = poll(11);
+  }
+}
+
+FamilyTrainer::FamilyTrainer(unsigned port):
+Controller(port, (unsigned)Input::Device::FamilyTrainer) {
+  latched = 0;
+  counter = 0;
+
+  b1 = b2 = b3 = b4 = 0;
+  b5 = b6 = b7 = b8 = 0;
+  b9 = b10 = b11 = b12 = 0;
+}
+
+#endif
diff -Nru higan/fc/controller/familytrainer/familytrainer.hpp higan/fc/controller/familytrainer/familytrainer.hpp
--- higan/fc/controller/familytrainer/familytrainer.hpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/fc/controller/familytrainer/familytrainer.hpp	2015-09-16 13:08:13.516563364 +0900
@@ -0,0 +1,15 @@
+struct FamilyTrainer : Controller {
+  uint5 data();
+  uint2 data1();
+  uint5 data2();
+  void latch(bool data);
+  FamilyTrainer(unsigned port);
+
+private:
+  bool latched;
+  unsigned counter;
+
+  bool b1, b2, b3, b4;
+  bool b5, b6, b7, b8;
+  bool b9, b10, b11, b12;
+};
diff -Nru higan/fc/controller/fourplayers/fourplayers.cpp higan/fc/controller/fourplayers/fourplayers.cpp
--- higan/fc/controller/fourplayers/fourplayers.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/fc/controller/fourplayers/fourplayers.cpp	2015-09-16 13:08:13.516563364 +0900
@@ -0,0 +1,31 @@
+#ifdef CONTROLLER_CPP
+
+uint2 FourPlayers::data1() {
+  if(counter1 >= 8) return 2;
+  if(latched) return poll(0) << 1;
+
+  return poll(counter1++) << 1;
+}
+
+uint5 FourPlayers::data2() {
+  if(counter2 >= 8) return 2;
+  if(latched) return poll(8) << 1;
+
+  return poll((counter2++) + 8) << 1;
+}
+
+void FourPlayers::latch(bool data) {
+  if(latched == data) return;
+  latched = data;
+  counter1 = 0;
+  counter2 = 0;
+}
+
+FourPlayers::FourPlayers(unsigned port):
+Controller(port, (unsigned)Input::Device::FourPlayers) {
+  latched = 0;
+  counter1 = 0;
+  counter2 = 0;
+}
+
+#endif
diff -Nru higan/fc/controller/fourplayers/fourplayers.hpp higan/fc/controller/fourplayers/fourplayers.hpp
--- higan/fc/controller/fourplayers/fourplayers.hpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/fc/controller/fourplayers/fourplayers.hpp	2015-09-16 13:08:13.516563364 +0900
@@ -0,0 +1,11 @@
+struct FourPlayers : Controller {
+  uint2 data1();
+  uint5 data2();
+  void latch(bool data);
+  FourPlayers(unsigned port);
+
+private:
+  bool latched;
+  unsigned counter1;
+  unsigned counter2;
+};
diff -Nru higan/fc/controller/fourscore/fourscore.cpp higan/fc/controller/fourscore/fourscore.cpp
--- higan/fc/controller/fourscore/fourscore.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/fc/controller/fourscore/fourscore.cpp	2015-09-16 13:08:13.516563364 +0900
@@ -0,0 +1,27 @@
+#ifdef CONTROLLER_CPP
+
+uint5 FourScore::data() {
+  if(counter >= 24) return 1;
+  if(latched) return poll(0);
+  uint5 data = 0;
+
+  if(counter >= 16) data = counter == (19 - port);
+  else data = poll(counter);
+  counter++;
+
+  return data;
+}
+
+void FourScore::latch(bool data) {
+  if(latched == data) return;
+  latched = data;
+  counter = 0;
+}
+
+FourScore::FourScore(unsigned port):
+Controller(port, (unsigned)Input::Device::FourScore) {
+  latched = 0;
+  counter = 0;
+}
+
+#endif
diff -Nru higan/fc/controller/fourscore/fourscore.hpp higan/fc/controller/fourscore/fourscore.hpp
--- higan/fc/controller/fourscore/fourscore.hpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/fc/controller/fourscore/fourscore.hpp	2015-09-16 13:08:13.516563364 +0900
@@ -0,0 +1,9 @@
+struct FourScore : Controller {
+  uint5 data();
+  void latch(bool data);
+  FourScore(unsigned port);
+
+private:
+  bool latched;
+  unsigned counter;
+};
diff -Nru higan/fc/controller/gamepad/gamepad.cpp higan/fc/controller/gamepad/gamepad.cpp
--- higan/fc/controller/gamepad/gamepad.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/fc/controller/gamepad/gamepad.cpp	2015-09-16 13:08:13.515563364 +0900
@@ -0,0 +1,59 @@
+#ifdef CONTROLLER_CPP
+
+uint5 Gamepad::data() {
+  if(counter >= 8) return 1;
+  if(latched == 1) return poll((unsigned)Input::JoypadID::A);
+
+  //note: D-pad physically prevents up+down and left+right from being pressed at the same time
+  switch(counter++) {
+  case 0: return a;
+  case 1: return b;
+  case 2: return select;
+  case 3: return start;
+  case 4: return up & !down;
+  case 5: return down & !up;
+  case 6: return left & !right;
+  case 7: return right & !left;
+  }
+}
+
+uint2 Gamepad::data1() {
+  return ((data() << 1) & 0x02);
+}
+
+uint5 Gamepad::data2() {
+  return 0;
+}
+
+void Gamepad::latch(bool data) {
+  if(latched == data) return;
+  latched = data;
+  counter = 0;
+
+  if(latched == 0) {
+    a      = poll(0);
+    b      = poll(1);
+    if(!system.vs()) {
+      select = poll(2);
+      start  = poll(3);
+    } else {
+      select = 0;
+      start  = 0;
+    }
+    up     = poll(4);
+    down   = poll(5);
+    left   = poll(6);
+    right  = poll(7);
+  }
+}
+
+Gamepad::Gamepad(unsigned port):
+Controller(port, (unsigned)Input::Device::Joypad) {
+  latched = 0;
+  counter = 0;
+
+  a = b = select = start = 0;
+  up = down = left = right = 0;
+}
+
+#endif
diff -Nru higan/fc/controller/gamepad/gamepad.hpp higan/fc/controller/gamepad/gamepad.hpp
--- higan/fc/controller/gamepad/gamepad.hpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/fc/controller/gamepad/gamepad.hpp	2015-09-16 13:08:13.514563364 +0900
@@ -0,0 +1,14 @@
+struct Gamepad : Controller {
+  uint5 data();
+  uint2 data1();
+  uint5 data2();
+  void latch(bool data);
+  Gamepad(unsigned port);
+
+private:
+  bool latched;
+  unsigned counter;
+
+  bool a, b, select, start;
+  bool up, down, left, right;
+};
diff -Nru higan/fc/controller/mouse/mouse.cpp higan/fc/controller/mouse/mouse.cpp
--- higan/fc/controller/mouse/mouse.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/fc/controller/mouse/mouse.cpp	2015-09-16 13:08:13.515563364 +0900
@@ -0,0 +1,99 @@
+#ifdef CONTROLLER_CPP
+
+uint5 Mouse::data() {
+  if(latched == 1) {
+    speed = (speed + 1) % 3;
+    return 0;
+  }
+
+  if(counter >= 32) return 1;
+
+  switch(counter++) { default:
+  case  0: return 0;
+  case  1: return 0;
+  case  2: return 0;
+  case  3: return 0;
+  case  4: return 0;
+  case  5: return 0;
+  case  6: return 0;
+  case  7: return 0;
+
+  case  8: return r;
+  case  9: return l;
+  case 10: return (speed >> 1) & 1;
+  case 11: return (speed >> 0) & 1;
+
+  case 12: return 0;  //signature
+  case 13: return 0;  // ||
+  case 14: return 0;  // ||
+  case 15: return 1;  // ||
+
+  case 16: return dy;
+  case 17: return (y >> 6) & 1;
+  case 18: return (y >> 5) & 1;
+  case 19: return (y >> 4) & 1;
+  case 20: return (y >> 3) & 1;
+  case 21: return (y >> 2) & 1;
+  case 22: return (y >> 1) & 1;
+  case 23: return (y >> 0) & 1;
+
+  case 24: return dx;
+  case 25: return (x >> 6) & 1;
+  case 26: return (x >> 5) & 1;
+  case 27: return (x >> 4) & 1;
+  case 28: return (x >> 3) & 1;
+  case 29: return (x >> 2) & 1;
+  case 30: return (x >> 1) & 1;
+  case 31: return (x >> 0) & 1;
+  }
+}
+
+uint2 Mouse::data1() {
+  return data() << 1;
+}
+
+uint5 Mouse::data2() {
+  return 0;
+}
+
+void Mouse::latch(bool data) {
+  if(latched == data) return;
+  latched = data;
+  counter = 0;
+
+  x = poll(0);  //-n = left, 0 = center, +n = right
+  y = poll(1);  //-n = up,   0 = center, +n = down
+  l = poll(2);
+  r = poll(3);
+
+  dx = x < 0;  //0 = right, 1 = left
+  dy = y < 0;  //0 = down,  1 = up
+
+  if(x < 0) x = -x;  //abs(position_x)
+  if(y < 0) y = -y;  //abs(position_y)
+
+  double multiplier = 1.0;
+  if(speed == 1) multiplier = 1.5;
+  if(speed == 2) multiplier = 2.0;
+  x = (double)x * multiplier;
+  y = (double)y * multiplier;
+
+  x = min(127, x);
+  y = min(127, y);
+}
+
+Mouse::Mouse(unsigned port):
+Controller(port, (unsigned)Input::Device::Mouse) {
+  latched = 0;
+  counter = 0;
+
+  speed = 0;
+  x = 0;
+  y = 0;
+  dx = 0;
+  dy = 0;
+  l = 0;
+  r = 0;
+}
+
+#endif
diff -Nru higan/fc/controller/mouse/mouse.hpp higan/fc/controller/mouse/mouse.hpp
--- higan/fc/controller/mouse/mouse.hpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/fc/controller/mouse/mouse.hpp	2015-09-16 13:08:13.515563364 +0900
@@ -0,0 +1,19 @@
+struct Mouse : Controller {
+  uint5 data();
+  uint2 data1();
+  uint5 data2();
+  void latch(bool data);
+  Mouse(unsigned port);
+
+private:
+  bool latched;
+  unsigned counter;
+
+  unsigned speed;  //0 = slow, 1 = normal, 2 = fast
+  signed x;        //x-coordinate
+  signed y;        //y-coordinate
+  bool dx;         //x-direction
+  bool dy;         //y-direction
+  bool l;          //left button
+  bool r;          //right button
+};
diff -Nru higan/fc/controller/sfcgamepad/sfcgamepad.cpp higan/fc/controller/sfcgamepad/sfcgamepad.cpp
--- higan/fc/controller/sfcgamepad/sfcgamepad.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/fc/controller/sfcgamepad/sfcgamepad.cpp	2015-09-16 13:08:13.515563364 +0900
@@ -0,0 +1,65 @@
+#ifdef CONTROLLER_CPP
+
+uint5 SFCGamepad::data() {
+  if(counter >= 16) return 1;
+  if(latched == 1) return poll(0);
+
+  //note: D-pad physically prevents up+down and left+right from being pressed at the same time
+  switch(counter++) {
+  case  0: return b;
+  case  1: return y;
+  case  2: return select;
+  case  3: return start;
+  case  4: return up & !down;
+  case  5: return down & !up;
+  case  6: return left & !right;
+  case  7: return right & !left;
+  case  8: return a;
+  case  9: return x;
+  case 10: return l;
+  case 11: return r;
+  }
+
+  return 0;  //12-15: signature
+}
+
+uint2 SFCGamepad::data1() {
+  return ((data() << 1) & 0x02);
+}
+
+uint5 SFCGamepad::data2() {
+  return 0;
+}
+
+void SFCGamepad::latch(bool data) {
+  if(latched == data) return;
+  latched = data;
+  counter = 0;
+
+  if(latched == 0) {
+    b      = poll( 0);
+    y      = poll( 1);
+    select = poll( 2);
+    start  = poll( 3);
+    up     = poll( 4);
+    down   = poll( 5);
+    left   = poll( 6);
+    right  = poll( 7);
+    a      = poll( 8);
+    x      = poll( 9);
+    l      = poll(10);
+    r      = poll(11);
+  }
+}
+
+SFCGamepad::SFCGamepad(unsigned port):
+Controller(port, (unsigned)Input::Device::SFCJoypad) {
+  latched = 0;
+  counter = 0;
+
+  b = y = select = start = 0;
+  up = down = left = right = 0;
+  a = x = l = r = 0;
+}
+
+#endif
diff -Nru higan/fc/controller/sfcgamepad/sfcgamepad.hpp higan/fc/controller/sfcgamepad/sfcgamepad.hpp
--- higan/fc/controller/sfcgamepad/sfcgamepad.hpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/fc/controller/sfcgamepad/sfcgamepad.hpp	2015-09-16 13:08:13.515563364 +0900
@@ -0,0 +1,15 @@
+struct SFCGamepad : Controller {
+  uint5 data();
+  uint2 data1();
+  uint5 data2();
+  void latch(bool data);
+  SFCGamepad(unsigned port);
+
+private:
+  bool latched;
+  unsigned counter;
+
+  bool b, y, select, start;
+  bool up, down, left, right;
+  bool a, x, l, r;
+};
diff -Nru higan/fc/controller/vspanel/vspanel.cpp higan/fc/controller/vspanel/vspanel.cpp
--- higan/fc/controller/vspanel/vspanel.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/fc/controller/vspanel/vspanel.cpp	2015-09-16 13:08:13.514563364 +0900
@@ -0,0 +1,55 @@
+#ifdef CONTROLLER_CPP
+
+uint5 VSPanel::data() {
+  unsigned data = 0x00;
+  if(poll(4)) data |= 0x01; // service button
+  if(poll(5)) data |= 0x08; // coin 1
+  if(poll(6)) data |= 0x10; // coin 2
+  // data will be left-shifted twice and OR'd into $4016 in CPU
+  return data;
+}
+
+uint2 VSPanel::data1() {
+  if(counter1 >= 8) return 1;
+  if(latched == 1) return 0;
+
+  switch(counter1++) { default: return 0;
+  case 2: return b1;
+  case 3: return b3;
+  }
+}
+
+uint5 VSPanel::data2() {
+  if(counter2 >= 8) return 1;
+  if(latched == 1) return 0;
+
+  switch(counter2++) { default: return 0;
+  case 2: return b2;
+  case 3: return b4;
+  }
+}
+
+void VSPanel::latch(bool data) {
+  if(latched == data) return;
+  latched = data;
+  counter1 = 0;
+  counter2 = 0;
+
+  if(latched == 0) {
+    b1 = poll(0);
+    b2 = poll(1);
+    b3 = poll(2);
+    b4 = poll(3);
+  }
+}
+
+VSPanel::VSPanel(unsigned port):
+Controller(port, (unsigned)Input::Device::VSPanel) {
+  latched = 0;
+  counter1 = 0;
+  counter2 = 0;
+
+  b1 = b2 = b3 = b4 = 0;
+}
+
+#endif
diff -Nru higan/fc/controller/vspanel/vspanel.hpp higan/fc/controller/vspanel/vspanel.hpp
--- higan/fc/controller/vspanel/vspanel.hpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/fc/controller/vspanel/vspanel.hpp	2015-09-16 13:08:13.514563364 +0900
@@ -0,0 +1,14 @@
+struct VSPanel : Controller {
+  uint5 data();
+  uint2 data1();
+  uint5 data2();
+  void latch(bool data);
+  VSPanel(unsigned port);
+
+private:
+  bool latched;
+  unsigned counter1;
+  unsigned counter2;
+
+  bool b1, b2, b3, b4;
+};
diff -Nru higan/fc/cpu/cpu.cpp higan/fc/cpu/cpu.cpp
--- higan/fc/cpu/cpu.cpp	2015-09-16 02:20:06.372574580 +0900
+++ higan/fc/cpu/cpu.cpp	2015-09-16 13:08:13.520563364 +0900
@@ -1,12 +1,50 @@
 #include <fc/fc.hpp>
 
+#define CPU_CPP
 namespace Famicom {
 
-#include "timing.cpp"
-#include "serialization.cpp"
 CPU cpu;
 
-void CPU::Enter() {
+#include "serialization.cpp"
+#include "timing/timing.cpp"
+
+void CPU::step(unsigned clocks) {
+  apu.clock -= clocks;
+  if(apu.clock < 0 && scheduler.sync != Scheduler::SynchronizeMode::All) co_switch(apu.thread);
+
+  ppu.clock -= clocks;
+  if(ppu.clock < 0 && scheduler.sync != Scheduler::SynchronizeMode::All) co_switch(ppu.thread);
+
+  cartridge.clock -= clocks;
+  if(cartridge.clock < 0 && scheduler.sync != Scheduler::SynchronizeMode::All) co_switch(cartridge.thread);
+
+  input.port1->clock -= clocks * (uint64)input.port1->frequency;
+  input.port2->clock -= clocks * (uint64)input.port2->frequency;
+  input.expansion->clock -= clocks * (uint64)input.expansion->frequency;
+  synchronize_controllers();
+}
+
+void CPU::synchronize_apu() {
+  if(apu.clock < 0) co_switch(apu.thread);
+}
+
+void CPU::synchronize_ppu() {
+  if(ppu.clock < 0) co_switch(ppu.thread);
+}
+
+void CPU::synchronize_cartridge() {
+  if(cartridge.clock < 0) co_switch(cartridge.thread);
+}
+
+void CPU::synchronize_controllers() {
+  if(input.port1->clock < 0) co_switch(input.port1->thread);
+  if(input.port2->clock < 0) co_switch(input.port2->thread);
+  if(input.expansion->clock < 0) co_switch(input.expansion->thread);
+}
+
+void CPU::Enter() { cpu.enter(); }
+
+void CPU::enter() {
   while(true) {
     if(scheduler.sync == Scheduler::SynchronizeMode::All) {
       scheduler.exit(Scheduler::ExitReason::SynchronizeEvent);
@@ -25,17 +63,6 @@
   exec();
 }
 
-void CPU::add_clocks(unsigned clocks) {
-  apu.clock -= clocks;
-  if(apu.clock < 0 && scheduler.sync != Scheduler::SynchronizeMode::All) co_switch(apu.thread);
-
-  ppu.clock -= clocks;
-  if(ppu.clock < 0 && scheduler.sync != Scheduler::SynchronizeMode::All) co_switch(ppu.thread);
-
-  cartridge.clock -= clocks;
-  if(cartridge.clock < 0 && scheduler.sync != Scheduler::SynchronizeMode::All) co_switch(cartridge.thread);
-}
-
 void CPU::power() {
   R6502::power();
 
@@ -48,7 +75,7 @@
 
 void CPU::reset() {
   R6502::reset();
-  create(CPU::Enter, 21477272);
+  create(CPU::Enter, system.cpu_frequency());
 
   regs.pc  = bus.read(0xfffc) << 0;
   regs.pc |= bus.read(0xfffd) << 8;
@@ -65,10 +92,6 @@
 
   status.oam_dma_pending = false;
   status.oam_dma_page = 0x00;
-
-  status.controller_latch = false;
-  status.controller_port0 = 0;
-  status.controller_port1 = 0;
 }
 
 uint8 CPU::debugger_read(uint16 addr) {
@@ -84,12 +107,16 @@
 }
 
 uint8 CPU::read(uint16 addr) {
-  if(addr == 0x4016) {
-    return (mdr() & 0xc0) | input.data(0);
-  }
+  if(system.revision != System::Revision::VSSystem) {
+    if(addr == 0x4016) {
+      return (mdr() & 0xe0) | input.port1->data() | input.expansion->data1();
+    }
 
-  if(addr == 0x4017) {
-    return (mdr() & 0xc0) | input.data(1);
+    if(addr == 0x4017) {
+      return (mdr() & 0xe0) | input.port2->data() | input.expansion->data2();
+    }
+  } else { // if using VS. System
+    if(addr >= 0x4016 && addr <= 0x5fff) return vsarcadeboard.read(addr);
   }
 
   return apu.read(addr);
@@ -101,8 +128,14 @@
     status.oam_dma_pending = true;
   }
 
-  if(addr == 0x4016) {
-    input.latch(data & 0x01);
+  if(system.revision != System::Revision::VSSystem) {
+    if(addr == 0x4016) {
+      input.port1->latch(data & 1);
+      input.port2->latch(data & 1);
+      input.expansion->latch(data & 1);
+    }
+  } else { // if using VS. System
+    if(addr >= 0x4016 && addr <= 0x5fff) vsarcadeboard.write(addr, data);
   }
 
   return apu.write(addr, data);
diff -Nru higan/fc/cpu/cpu.hpp higan/fc/cpu/cpu.hpp
--- higan/fc/cpu/cpu.hpp	2015-09-16 02:20:06.372574580 +0900
+++ higan/fc/cpu/cpu.hpp	2015-09-16 13:08:13.519563364 +0900
@@ -1,6 +1,30 @@
 struct CPU : Processor::R6502, Thread {
   uint8 ram[0x0800];
 
+  alwaysinline void step(unsigned clocks);
+  alwaysinline void synchronize_apu();
+  void synchronize_ppu();
+  void synchronize_cartridge();
+  void synchronize_controllers();
+
+  void enter();
+  void main();
+  void power();
+  void reset();
+
+  uint8 debugger_read(uint16 addr);
+
+  uint8 ram_read(uint16 addr);
+  void ram_write(uint16 addr, uint8 data);
+
+  uint8 read(uint16 addr);
+  void write(uint16 addr, uint8 data);
+
+  void serialize(serializer&);
+
+//privileged:
+  #include "timing/timing.hpp"
+
   struct Status {
     bool interrupt_pending;
     bool nmi_pending;
@@ -15,42 +39,12 @@
     bool oam_dma_pending;
     uint8 oam_dma_page;
 
-    bool controller_latch;
-    unsigned controller_port0;
-    unsigned controller_port1;
+    //bool controller_latch;
+    //unsigned controller_port0;
+    //unsigned controller_port1;
   } status;
 
   static void Enter();
-  void main();
-  void add_clocks(unsigned clocks);
-
-  void power();
-  void reset();
-
-  uint8 debugger_read(uint16 addr);
-
-  uint8 ram_read(uint16 addr);
-  void ram_write(uint16 addr, uint8 data);
-
-  uint8 read(uint16 addr);
-  void write(uint16 addr, uint8 data);
-
-  void serialize(serializer&);
-
-  //timing.cpp
-  uint8 op_read(uint16 addr);
-  void op_write(uint16 addr, uint8 data);
-  void last_cycle();
-  void nmi(uint16 &vector);
-
-  void oam_dma();
-
-  void set_nmi_line(bool);
-  void set_irq_line(bool);
-  void set_irq_apu_line(bool);
-
-  void set_rdy_line(bool);
-  void set_rdy_addr(bool valid, uint16 value = 0);
 };
 
 extern CPU cpu;
diff -Nru higan/fc/cpu/serialization.cpp higan/fc/cpu/serialization.cpp
--- higan/fc/cpu/serialization.cpp	2015-09-16 02:20:06.372574580 +0900
+++ higan/fc/cpu/serialization.cpp	2015-09-16 13:08:13.520563364 +0900
@@ -1,3 +1,5 @@
+#ifdef CPU_CPP
+
 void CPU::serialize(serializer& s) {
   R6502::serialize(s);
   Thread::serialize(s);
@@ -17,7 +19,9 @@
   s.integer(status.oam_dma_pending);
   s.integer(status.oam_dma_page);
 
-  s.integer(status.controller_latch);
-  s.integer(status.controller_port0);
-  s.integer(status.controller_port1);
+  //s.integer(status.controller_latch);
+  //s.integer(status.controller_port0);
+  //s.integer(status.controller_port1);
 }
+
+#endif
diff -Nru higan/fc/cpu/timing/timing.cpp higan/fc/cpu/timing/timing.cpp
--- higan/fc/cpu/timing/timing.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/fc/cpu/timing/timing.cpp	2015-09-16 13:08:13.519563364 +0900
@@ -0,0 +1,72 @@
+#ifdef CPU_CPP
+
+void CPU::add_clocks(unsigned clocks) {
+  step(clocks);
+}
+
+uint8 CPU::op_read(uint16 addr) {
+  if(status.oam_dma_pending) {
+    status.oam_dma_pending = false;
+    op_read(addr);
+    oam_dma();
+  }
+
+  while(status.rdy_line == 0) {
+    regs.mdr = bus.read(status.rdy_addr_valid ? status.rdy_addr_value : addr);
+    add_clocks(system.region() == System::Region::NTSC ? 12 : 16);
+  }
+
+  regs.mdr = bus.read(addr);
+  add_clocks(system.region() == System::Region::NTSC ? 12 : 16);
+  return regs.mdr;
+}
+
+void CPU::op_write(uint16 addr, uint8 data) {
+  bus.write(addr, regs.mdr = data);
+  add_clocks(system.region() == System::Region::NTSC ? 12 : 16);
+}
+
+void CPU::last_cycle() {
+  status.interrupt_pending = ((status.irq_line | status.irq_apu_line) & ~regs.p.i) | status.nmi_pending;
+}
+
+void CPU::nmi(uint16 &vector) {
+  if(status.nmi_pending) {
+    status.nmi_pending = false;
+    vector = 0xfffa;
+  }
+}
+
+void CPU::oam_dma() {
+  for(unsigned n = 0; n < 256; n++) {
+    uint8 data = op_read((status.oam_dma_page << 8) + n);
+    op_write(0x2004, data);
+  }
+}
+
+void CPU::set_nmi_line(bool line) {
+  //edge-sensitive (0->1)
+  if(!status.nmi_line && line) status.nmi_pending = true;
+  status.nmi_line = line;
+}
+
+void CPU::set_irq_line(bool line) {
+  //level-sensitive
+  status.irq_line = line;
+}
+
+void CPU::set_irq_apu_line(bool line) {
+  //level-sensitive
+  status.irq_apu_line = line;
+}
+
+void CPU::set_rdy_line(bool line) {
+  status.rdy_line = line;
+}
+
+void CPU::set_rdy_addr(bool valid, uint16 value) {
+  status.rdy_addr_valid = valid;
+  status.rdy_addr_value = value;
+}
+
+#endif
diff -Nru higan/fc/cpu/timing/timing.hpp higan/fc/cpu/timing/timing.hpp
--- higan/fc/cpu/timing/timing.hpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/fc/cpu/timing/timing.hpp	2015-09-16 13:08:13.519563364 +0900
@@ -0,0 +1,14 @@
+void add_clocks(unsigned clocks);
+uint8 op_read(uint16 addr);
+void op_write(uint16 addr, uint8 data);
+void last_cycle();
+void nmi(uint16 &vector);
+
+void oam_dma();
+
+void set_nmi_line(bool);
+void set_irq_line(bool);
+void set_irq_apu_line(bool);
+
+void set_rdy_line(bool);
+void set_rdy_addr(bool valid, uint16 value = 0);
diff -Nru higan/fc/cpu/timing.cpp higan/fc/cpu/timing.cpp
--- higan/fc/cpu/timing.cpp	2015-09-16 02:20:06.372574580 +0900
+++ higan/fc/cpu/timing.cpp	1970-01-01 09:00:00.000000000 +0900
@@ -1,64 +0,0 @@
-uint8 CPU::op_read(uint16 addr) {
-  if(status.oam_dma_pending) {
-    status.oam_dma_pending = false;
-    op_read(addr);
-    oam_dma();
-  }
-
-  while(status.rdy_line == 0) {
-    regs.mdr = bus.read(status.rdy_addr_valid ? status.rdy_addr_value : addr);
-    add_clocks(12);
-  }
-
-  regs.mdr = bus.read(addr);
-  add_clocks(12);
-  return regs.mdr;
-}
-
-void CPU::op_write(uint16 addr, uint8 data) {
-  bus.write(addr, regs.mdr = data);
-  add_clocks(12);
-}
-
-void CPU::last_cycle() {
-  status.interrupt_pending = ((status.irq_line | status.irq_apu_line) & ~regs.p.i) | status.nmi_pending;
-}
-
-void CPU::nmi(uint16 &vector) {
-  if(status.nmi_pending) {
-    status.nmi_pending = false;
-    vector = 0xfffa;
-  }
-}
-
-void CPU::oam_dma() {
-  for(unsigned n = 0; n < 256; n++) {
-    uint8 data = op_read((status.oam_dma_page << 8) + n);
-    op_write(0x2004, data);
-  }
-}
-
-void CPU::set_nmi_line(bool line) {
-  //edge-sensitive (0->1)
-  if(!status.nmi_line && line) status.nmi_pending = true;
-  status.nmi_line = line;
-}
-
-void CPU::set_irq_line(bool line) {
-  //level-sensitive
-  status.irq_line = line;
-}
-
-void CPU::set_irq_apu_line(bool line) {
-  //level-sensitive
-  status.irq_apu_line = line;
-}
-
-void CPU::set_rdy_line(bool line) {
-  status.rdy_line = line;
-}
-
-void CPU::set_rdy_addr(bool valid, uint16 value) {
-  status.rdy_addr_valid = valid;
-  status.rdy_addr_value = value;
-}
diff -Nru higan/fc/fc.hpp higan/fc/fc.hpp
--- higan/fc/fc.hpp	2015-09-16 02:20:06.372574580 +0900
+++ higan/fc/fc.hpp	2015-09-16 13:08:13.520563364 +0900
@@ -40,20 +45,25 @@
 
     cothread_t thread = nullptr;
     unsigned frequency = 0;
-    int64 clock = 0;
+    int64_t clock = 0;
   };
 
-  #include <fc/system/system.hpp>
-  #include <fc/scheduler/scheduler.hpp>
-  #include <fc/input/input.hpp>
   #include <fc/memory/memory.hpp>
-  #include <fc/cartridge/cartridge.hpp>
+  #include <fc/ppu/counter/counter.hpp>
+
   #include <fc/cpu/cpu.hpp>
   #include <fc/apu/apu.hpp>
   #include <fc/ppu/ppu.hpp>
+
+  #include <fc/controller/controller.hpp>
+  #include <fc/system/system.hpp>
+  #include <fc/arcade/arcade.hpp>
+  #include <fc/cartridge/cartridge.hpp>
   #include <fc/cheat/cheat.hpp>
-  #include <fc/video/video.hpp>
   #include <fc/interface/interface.hpp>
+
+  #include <fc/memory/memory-inline.hpp>
+  #include <fc/ppu/counter/counter-inline.hpp>
 }
 
 #endif
diff -Nru higan/fc/GNUmakefile higan/fc/GNUmakefile
--- higan/fc/GNUmakefile	2015-09-16 02:20:06.370574580 +0900
+++ higan/fc/GNUmakefile	2015-09-16 13:08:13.543563367 +0900
@@ -1,16 +1,18 @@
-fc_objects := fc-interface fc-system fc-scheduler fc-input
-fc_objects += fc-memory fc-cartridge fc-cpu fc-apu fc-ppu
-fc_objects += fc-cheat fc-video
+fc_objects := fc-interface fc-system fc-controller
+fc_objects += fc-cartridge fc-cheat
+fc_objects += fc-memory fc-cpu fc-apu fc-ppu
+fc_objects += fc-vsarcade fc-pc10arcade
 objects += $(fc_objects)
 
 obj/fc-interface.o: $(fc)/interface/interface.cpp $(call rwildcard,$(fc)/interface/)
 obj/fc-system.o: $(fc)/system/system.cpp $(call rwildcard,$(fc)/system/)
-obj/fc-scheduler.o: $(fc)/scheduler/scheduler.cpp $(call rwildcard,$(fc)/scheduler/)
-obj/fc-input.o: $(fc)/input/input.cpp $(call rwildcard,$(fc)/input/)
-obj/fc-memory.o: $(fc)/memory/memory.cpp $(call rwildcard,$(fc)/memory/)
+obj/fc-controller.o: $(fc)/controller/controller.cpp $(call rwildcard,$(fc)/controller/)
 obj/fc-cartridge.o: $(fc)/cartridge/cartridge.cpp $(call rwildcard,$(fc)/cartridge/)
+obj/fc-cheat.o: $(fc)/cheat/cheat.cpp $(call rwildcard,$(fc)/cheat/)
+obj/fc-memory.o: $(fc)/memory/memory.cpp $(call rwildcard,$(fc)/memory/)
 obj/fc-cpu.o: $(fc)/cpu/cpu.cpp $(call rwildcard,$(fc)/cpu/)
 obj/fc-apu.o: $(fc)/apu/apu.cpp $(call rwildcard,$(fc)/apu/)
 obj/fc-ppu.o: $(fc)/ppu/ppu.cpp $(call rwildcard,$(fc)/ppu/)
-obj/fc-cheat.o: $(fc)/cheat/cheat.cpp $(call rwildcard,$(fc)/cheat/)
-obj/fc-video.o: $(fc)/video/video.cpp $(call rwildcard,$(fc)/video/)
+
+obj/fc-vsarcade.o: $(fc)/arcade/vs/vs.cpp $(call rwildcard,$(fc)/arcade/vs/)
+obj/fc-pc10arcade.o: $(fc)/arcade/pc10/pc10.cpp $(call rwildcard,$(fc)/arcade/pc10/)
diff -Nru higan/fc/input/input.cpp higan/fc/input/input.cpp
--- higan/fc/input/input.cpp	2015-09-16 02:20:06.372574580 +0900
+++ higan/fc/input/input.cpp	1970-01-01 09:00:00.000000000 +0900
@@ -1,53 +0,0 @@
-#include <fc/fc.hpp>
-
-namespace Famicom {
-
-#include "serialization.cpp"
-Input input;
-
-void Input::latch(bool data) {
-  latchdata = data;
-
-  if(latchdata == 1) {
-    counter1 = 0;
-    counter2 = 0;
-  }
-}
-
-bool Input::data(bool port) {
-  bool result = 0;
-
-  if(port == 0) {
-    if(port1 == Device::Joypad) {
-      if(counter1 >= 8) return 1;
-      result = interface->inputPoll(0, 0u, counter1);
-      if(latchdata == 0) counter1++;
-    }
-  }
-
-  if(port == 1) {
-    if(port2 == Device::Joypad) {
-      if(counter2 >= 8) return 1;
-      result = interface->inputPoll(1, 0u, counter2);
-      if(latchdata == 0) counter2++;
-    }
-  }
-
-  return result;
-}
-
-void Input::connect(bool port, Device device) {
-  if(port == 0) port1 = device, counter1 = 0;
-  if(port == 1) port2 = device, counter2 = 0;
-}
-
-void Input::power() {
-}
-
-void Input::reset() {
-  latchdata = 0;
-  counter1 = 0;
-  counter2 = 0;
-}
-
-}
diff -Nru higan/fc/input/input.hpp higan/fc/input/input.hpp
--- higan/fc/input/input.hpp	2015-09-16 02:20:06.372574580 +0900
+++ higan/fc/input/input.hpp	1970-01-01 09:00:00.000000000 +0900
@@ -1,25 +0,0 @@
-struct Input {
-  enum class Device : unsigned {
-    Joypad,
-    None,
-  };
-
-  void latch(bool data);
-  bool data(bool port);
-  void connect(bool port, Device device);
-
-  void power();
-  void reset();
-
-  void serialize(serializer&);
-
-private:
-  Device port1;
-  Device port2;
-
-  bool latchdata;
-  unsigned counter1;
-  unsigned counter2;
-};
-
-extern Input input;
diff -Nru higan/fc/input/serialization.cpp higan/fc/input/serialization.cpp
--- higan/fc/input/serialization.cpp	2015-09-16 02:20:06.372574580 +0900
+++ higan/fc/input/serialization.cpp	1970-01-01 09:00:00.000000000 +0900
@@ -1,8 +0,0 @@
-void Input::serialize(serializer& s) {
-  s.integer((unsigned&)port1);
-  s.integer((unsigned&)port2);
-
-  s.integer(latchdata);
-  s.integer(counter1);
-  s.integer(counter2);
-}
diff -Nru higan/fc/interface/interface.cpp higan/fc/interface/interface.cpp
--- higan/fc/interface/interface.cpp	2015-09-16 02:20:06.373574580 +0900
+++ higan/fc/interface/interface.cpp	2015-09-16 13:08:13.543563367 +0900
@@ -4,115 +4,362 @@
 
 Interface* interface = nullptr;
 
-string Interface::title() {
+Interface::Interface() {
+  interface = this;
+  system.init();
+
+  information.name        = "Famicom";
+  information.width       = 256;
+  information.height      = 240;
+  information.overscan    = true;
+  information.aspectRatio = 8.0 / 7.0;
+  information.resettable  = true;
+  information.capability.states = true;
+  information.capability.cheats = true;
+
+  media.append({ID::Famicom,      "Famicom",       "fc",   true});
+  media.append({ID::VSSystem,     "VS. System",    "vs",   true});
+  media.append({ID::PlayChoice10, "PlayChoice-10", "pc10", true});
+
+  port.append({0, "Port 1"});
+  port.append({1, "Port 2"});
+  port.append({2, "Expansion Port"});
+
+  for(unsigned i = 0; i <= (unsigned)Input::Device::None; i++) {
+    device_ref.append(DeviceRef{i, 0, 0, 0});
+  }
+
+  { Device device{
+      (unsigned)Input::Device::Joypad,
+      ID::Port1 | ID::Port2 | ID::ExpansionPort,
+      "Controller"
+    };
+    device.input.append({0, 0, "A"     });
+    device.input.append({1, 0, "B"     });
+    device.input.append({2, 0, "Select"});
+    device.input.append({3, 0, "Start" });
+    device.input.append({4, 0, "Up"    });
+    device.input.append({5, 0, "Down"  });
+    device.input.append({6, 0, "Left"  });
+    device.input.append({7, 0, "Right" });
+    device.order = {4, 5, 6, 7, 1, 0, 2, 3};
+    addDevice(device);
+  }
+
+  { Device device{
+      (unsigned)Input::Device::FourPlayers,
+      ID::ExpansionPort,
+      "4-Players Adaptor"
+    };
+    for(unsigned p = 3, n = 0; p <= 4; p += 1, n += 8) {
+      device.input.append({n + 0, 0, {"Port ", p, " - ", "A"     }});
+      device.input.append({n + 1, 0, {"Port ", p, " - ", "B"     }});
+      device.input.append({n + 2, 0, {"Port ", p, " - ", "Select"}});
+      device.input.append({n + 3, 0, {"Port ", p, " - ", "Start" }});
+      device.input.append({n + 4, 0, {"Port ", p, " - ", "Up"    }});
+      device.input.append({n + 5, 0, {"Port ", p, " - ", "Down"  }});
+      device.input.append({n + 6, 0, {"Port ", p, " - ", "Left"  }});
+      device.input.append({n + 7, 0, {"Port ", p, " - ", "Right" }});
+      device.order.append(n + 4, n + 5, n + 6, n + 7);
+      device.order.append(n + 1, n + 0, n + 2, n + 3);
+    }
+    addDevice(device);
+  }
+
+  { Device device{
+      (unsigned)Input::Device::FourScore,
+      ID::Port1,
+      "Four Score"
+    };
+    for(unsigned p = 1, n = 0; p <= 4; p += 2, n += 8) {
+      device.input.append({n + 0, 0, {"Port ", p, " - ", "A"     }});
+      device.input.append({n + 1, 0, {"Port ", p, " - ", "B"     }});
+      device.input.append({n + 2, 0, {"Port ", p, " - ", "Select"}});
+      device.input.append({n + 3, 0, {"Port ", p, " - ", "Start" }});
+      device.input.append({n + 4, 0, {"Port ", p, " - ", "Up"    }});
+      device.input.append({n + 5, 0, {"Port ", p, " - ", "Down"  }});
+      device.input.append({n + 6, 0, {"Port ", p, " - ", "Left"  }});
+      device.input.append({n + 7, 0, {"Port ", p, " - ", "Right" }});
+      device.order.append(n + 4, n + 5, n + 6, n + 7);
+      device.order.append(n + 1, n + 0, n + 2, n + 3);
+    }
+    addDevice(device);
+  }
+
+  { Device device{
+      (unsigned)Input::Device::FourScore,
+      ID::Port2,
+      "Four Score"
+    };
+    for(unsigned p = 2, n = 0; p <= 4; p += 2, n += 8) {
+      device.input.append({n + 0, 0, {"Port ", p, " - ", "A"     }});
+      device.input.append({n + 1, 0, {"Port ", p, " - ", "B"     }});
+      device.input.append({n + 2, 0, {"Port ", p, " - ", "Select"}});
+      device.input.append({n + 3, 0, {"Port ", p, " - ", "Start" }});
+      device.input.append({n + 4, 0, {"Port ", p, " - ", "Up"    }});
+      device.input.append({n + 5, 0, {"Port ", p, " - ", "Down"  }});
+      device.input.append({n + 6, 0, {"Port ", p, " - ", "Left"  }});
+      device.input.append({n + 7, 0, {"Port ", p, " - ", "Right" }});
+      device.order.append(n + 4, n + 5, n + 6, n + 7);
+      device.order.append(n + 1, n + 0, n + 2, n + 3);
+    }
+    addDevice(device);
+  }
+
+  { Device device{
+      (unsigned)Input::Device::BeamGun,
+      ID::ExpansionPort,
+      "Beam Gun"
+    };
+    device.input.append({0, 1, "X-axis" });
+    device.input.append({1, 1, "Y-axis" });
+    device.input.append({2, 0, "Trigger"});
+    device.order = {0, 1, 2};
+    addDevice(device);
+  }
+
+  { Device device{
+      (unsigned)Input::Device::BeamGun,
+      ID::Port2,
+      "Zapper"
+    };
+    device.input.append({0, 1, "X-axis" });
+    device.input.append({1, 1, "Y-axis" });
+    device.input.append({2, 0, "Trigger"});
+    device.order = {0, 1, 2};
+    addDevice(device);
+  }
+
+  { Device device{
+      (unsigned)Input::Device::FamilyTrainer,
+      ID::ExpansionPort,
+      "Family Trainer"
+    };
+    for(unsigned n = 0; n <= 11; n++) {
+      device.input.append({n, 0, {"Button ", n + 1}});
+    }
+    device.order = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};
+    addDevice(device);
+  }
+
+  { Device device{
+      (unsigned)Input::Device::FamilyTrainer,
+      ID::Port2,
+      "Power Pad"
+    };
+    for(unsigned n = 0; n <= 11; n++) {
+      device.input.append({n, 0, {"Button ", n + 1}});
+    }
+    device.order = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};
+    addDevice(device);
+  }
+
+  { Device device{
+      (unsigned)Input::Device::SFCJoypad,
+      ID::Port1 | ID::Port2,
+      "SFC Controller"
+    };
+    device.input.append({ 0, 0, "B"     });
+    device.input.append({ 1, 0, "Y"     });
+    device.input.append({ 2, 0, "Select"});
+    device.input.append({ 3, 0, "Start" });
+    device.input.append({ 4, 0, "Up"    });
+    device.input.append({ 5, 0, "Down"  });
+    device.input.append({ 6, 0, "Left"  });
+    device.input.append({ 7, 0, "Right" });
+    device.input.append({ 8, 0, "A"     });
+    device.input.append({ 9, 0, "X"     });
+    device.input.append({10, 0, "L"     });
+    device.input.append({11, 0, "R"     });
+    device.order = {4, 5, 6, 7, 0, 8, 1, 9, 10, 11, 2, 3};
+    addDevice(device);
+  }
+
+  { Device device{
+      (unsigned)Input::Device::Mouse,
+      ID::Port1 | ID::Port2 | ID::ExpansionPort,
+      "Mouse"
+    };
+    device.input.append({0, 1, "X-axis"});
+    device.input.append({1, 1, "Y-axis"});
+    device.input.append({2, 0, "Left"  });
+    device.input.append({3, 0, "Right" });
+    device.order = {0, 1, 2, 3};
+    addDevice(device);
+  }
+
+  { Device device{
+      (unsigned)Input::Device::VSPanel,
+      ID::ExpansionPort,
+      "VS. Panel"
+    };
+    device.input.append({0, 0, "Button 1"      });
+    device.input.append({1, 0, "Button 2"      });
+    device.input.append({2, 0, "Button 3"      });
+    device.input.append({3, 0, "Button 4"      });
+    device.input.append({4, 0, "Service Button"});
+    device.input.append({5, 0, "Coin 1"        });
+    device.input.append({6, 0, "Coin 2"        });
+    device.order = {0, 1, 2, 3, 4, 5, 6};
+    addDevice(device);
+  }
+
+  { Device device{
+      (unsigned)Input::Device::None,
+      ID::Port1 | ID::Port2 | ID::ExpansionPort,
+      "None"
+    };
+    addDevice(device);
+  }
+}
+
+auto Interface::title() -> string {
   return cartridge.title();
 }
 
-double Interface::videoFrequency() {
-  return 21477272.0 / (262.0 * 1364.0 - 4.0);
+auto Interface::videoFrequency() -> double {
+  switch(system.region()) { default:
+  case System::Region::NTSC: return system.cpu_frequency() / (262.0 * 1364.0 - 4.0);
+  case System::Region::PAL:  return system.cpu_frequency() / (312.0 * 1705.0);
+  }
 }
 
-double Interface::audioFrequency() {
-  return 21477272.0 / 12.0;
+auto Interface::audioFrequency() -> double {
+  switch(system.region()) { default:
+  case System::Region::NTSC: return system.cpu_frequency() / 12.0;
+  case System::Region::PAL:  return system.cpu_frequency() / 16.0;
+  }
 }
 
-bool Interface::loaded() {
+auto Interface::loaded() -> bool {
   return cartridge.loaded();
 }
 
-string Interface::sha256() {
+auto Interface::sha256() -> string {
   return cartridge.sha256();
 }
 
-unsigned Interface::group(unsigned id) {
+auto Interface::group(unsigned id) -> unsigned {
   switch(id) {
   case ID::SystemManifest:
-    return 0;
+  case ID::PC10BIOS:
+  case ID::PC10CharacterROM:
+  case ID::PC10PaletteROM:
+    return ID::System;
   case ID::Manifest:
   case ID::ProgramROM:
   case ID::ProgramRAM:
   case ID::CharacterROM:
   case ID::CharacterRAM:
-    return 1;
+  case ID::ChipRAM:
+    switch(system.revision) {
+    case System::Revision::Famicom:      return ID::Famicom;
+    case System::Revision::VSSystem:     return ID::VSSystem;
+    case System::Revision::PlayChoice10: return ID::PlayChoice10;
+    }
+  case ID::InstructionROM:
+  case ID::KeyROM:
+    return ID::PlayChoice10;
   }
 
   throw;
 }
 
-void Interface::load(unsigned id) {
-  cartridge.load();
+auto Interface::load(unsigned id) -> void {
+  information.width  = 256;
+  information.height = 240;
+  switch(id) {
+  case ID::Famicom:      cartridge.load(System::Revision::Famicom);      break;
+  case ID::VSSystem:     cartridge.load(System::Revision::VSSystem);     break;
+  case ID::PlayChoice10: cartridge.load(System::Revision::PlayChoice10); break;
+  }
 }
 
-void Interface::save() {
+auto Interface::save() -> void {
   for(auto& memory : cartridge.memory) {
     saveRequest(memory.id, memory.name);
   }
 }
 
-void Interface::load(unsigned id, const stream& stream) {
-  if(id == ID::SystemManifest) {
+auto Interface::load(unsigned id, const stream& stream) -> void {
+  switch(id) {
+  case ID::SystemManifest:
     system.information.manifest = stream.text();
-  }
-
-  if(id == ID::Manifest) {
-    cartridge.information.markup = stream.text();
-  }
+    break;
+  case ID::PC10BIOS:
+    stream.read(pc10arcadeboard.bios, min(16384u, stream.size()));
+    break;
+  case ID::PC10CharacterROM:
+    stream.read(pc10arcadeboard.chrrom, min(24576u, stream.size()));
+    break;
+  case ID::PC10PaletteROM:
+    stream.read(pc10arcadeboard.cgrom, min(768u, stream.size()));
+    break;
+  }
+
+  if(id == ID::Manifest) cartridge.information.markup.cartridge = stream.text();
+  if(id == ID::ProgramROM) cartridge.board->prgrom.read(stream);
+  if(id == ID::ProgramRAM) cartridge.board->prgram.read(stream);
+  if(id == ID::CharacterROM) cartridge.board->chrrom.read(stream);
+  if(id == ID::CharacterRAM) cartridge.board->chrram.read(stream);
+  if(id == ID::ChipRAM) cartridge.board->chip->ram.read(stream);
 
-  if(id == ID::ProgramROM) {
-    stream.read(cartridge.board->prgrom.data, min(cartridge.board->prgrom.size, stream.size()));
-  }
+  if(id == ID::InstructionROM) cartridge.board->instrom.read(stream);
+  if(id == ID::KeyROM) cartridge.board->keyrom.read(stream);
+}
 
+auto Interface::save(unsigned id, const stream& stream) -> void {
   if(id == ID::ProgramRAM) {
-    stream.read(cartridge.board->prgram.data, min(cartridge.board->prgram.size, stream.size()));
-  }
-
-  if(id == ID::CharacterROM) {
-    stream.read(cartridge.board->chrrom.data, min(cartridge.board->chrrom.size, stream.size()));
+    stream.write(cartridge.board->prgram.data(), cartridge.board->prgram.size());
   }
 
   if(id == ID::CharacterRAM) {
-    stream.read(cartridge.board->chrram.data, min(cartridge.board->chrram.size, stream.size()));
+    stream.write(cartridge.board->chrram.data(), cartridge.board->chrram.size());
   }
-}
 
-void Interface::save(unsigned id, const stream& stream) {
-  if(id == ID::ProgramRAM) {
-    stream.write(cartridge.board->prgram.data, cartridge.board->prgram.size);
-  }
-
-  if(id == ID::CharacterRAM) {
-    stream.write(cartridge.board->chrram.data, cartridge.board->chrram.size);
+  if(id == ID::ChipRAM) {
+    stream.write(cartridge.board->chip->ram.data(), cartridge.board->chip->ram.size());
   }
 }
 
-void Interface::unload() {
+auto Interface::unload() -> void {
   save();
   cartridge.unload();
 }
 
-void Interface::power() {
+auto Interface::connect(unsigned port, unsigned device) -> void {
+  if(!system.vs()) {
+    // Don't allow switching to VS. Panel
+    if(device == (unsigned)Input::Device::VSPanel)
+      device = (unsigned)Input::Device::None;
+    input.connect(port, (Input::Device)device);
+  }
+}
+
+auto Interface::power() -> void {
   system.power();
 }
 
-void Interface::reset() {
+auto Interface::reset() -> void {
   system.reset();
 }
 
-void Interface::run() {
+auto Interface::run() -> void {
   system.run();
 }
 
-serializer Interface::serialize() {
+auto Interface::serialize() -> serializer {
   system.runtosave();
   return system.serialize();
 }
 
-bool Interface::unserialize(serializer& s) {
+auto Interface::unserialize(serializer& s) -> bool {
   return system.unserialize(s);
 }
 
-void Interface::cheatSet(const lstring& list) {
+auto Interface::cheatSet(const lstring& list) -> void {
   cheat.reset();
+
   for(auto& codeset : list) {
     lstring codes = codeset.split("+");
     for(auto& code : codes) {
@@ -123,47 +370,35 @@
   }
 }
 
-void Interface::paletteUpdate(PaletteMode mode) {
+auto Interface::paletteUpdate(PaletteMode mode) -> void {
   video.generate_palette(mode);
 }
 
-Interface::Interface() {
-  interface = this;
-
-  information.name        = "Famicom";
-  information.width       = 256;
-  information.height      = 240;
-  information.overscan    = true;
-  information.aspectRatio = 8.0 / 7.0;
-  information.resettable  = true;
-  information.capability.states = true;
-  information.capability.cheats = true;
-
-  media.append({ID::Famicom, "Famicom", "fc", true});
-
-  {
-    Device device{0, ID::Port1 | ID::Port2, "Controller"};
-    device.input.append({0, 0, "A"     });
-    device.input.append({1, 0, "B"     });
-    device.input.append({2, 0, "Select"});
-    device.input.append({3, 0, "Start" });
-    device.input.append({4, 0, "Up"    });
-    device.input.append({5, 0, "Down"  });
-    device.input.append({6, 0, "Left"  });
-    device.input.append({7, 0, "Right" });
-    device.order = {4, 5, 6, 7, 1, 0, 2, 3};
-    this->device.append(device);
+auto Interface::addDevice(Device device) -> void {
+  for(auto& port : this->port) {
+    if(device.portmask & (1 << port.id)) {
+      device_ref[device.id].port[port.id] = (unsigned)port.device.size();
+      port.device.append(device);
+    }
   }
+}
 
-  port.append({0, "Port 1"});
-  port.append({1, "Port 2"});
-
-  for(auto& device : this->device) {
-    for(auto& port : this->port) {
-      if(device.portmask & (1 << port.id)) {
-        port.device.append(device);
-      }
-    }
+auto Interface::exportMemory() -> void {
+  string pathname = {path(group(ID::ProgramROM)), "debug/"};
+  directory::create(pathname);
+
+  file::write({pathname, "work.ram"}, cpu.ram, 0x0800);
+  file::write({pathname, "video.ram"}, ppu.ciram, 2048);
+  file::write({pathname, "palette.ram"}, ppu.cgram, 32);
+  file::write({pathname, "sprite.ram"}, ppu.oam, 256);
+  if(cartridge.board->prgram.size()) {
+    file::write({pathname, "program.ram"}, cartridge.board->prgram.data(), cartridge.board->prgram.size());
+  }
+  if(cartridge.board->chrram.size()) {
+    file::write({pathname, "character.ram"}, cartridge.board->chrram.data(), cartridge.board->chrram.size());
+  }
+  if(cartridge.board->chip && cartridge.board->chip->ram.size()) {
+    file::write({pathname, "chip.ram"}, cartridge.board->chip->ram.data(), cartridge.board->chip->ram.size());
   }
 }
 
diff -Nru higan/fc/interface/interface.hpp higan/fc/interface/interface.hpp
--- higan/fc/interface/interface.hpp	2015-09-16 02:20:06.373574580 +0900
+++ higan/fc/interface/interface.hpp	2015-09-16 13:08:13.543563367 +0900
@@ -4,23 +4,32 @@
 
 struct ID {
   enum : unsigned {
+    //cartridges (folders)
     System,
     Famicom,
-  };
+    PlayChoice10,
+    VSSystem,
 
-  enum : unsigned {
+    //memory (files)
     SystemManifest,
+    PC10BIOS,
+    PC10CharacterROM,
+    PC10PaletteROM,
 
     Manifest,
     ProgramROM,
     ProgramRAM,
     CharacterROM,
     CharacterRAM,
-  };
+    ChipRAM,
 
-  enum : unsigned {
+    InstructionROM,
+    KeyROM,
+
+    //controller ports
     Port1 = 1,
     Port2 = 2,
+    ExpansionPort = 4,
   };
 };
 
@@ -38,6 +47,7 @@
   void save(unsigned id, const stream& stream);
   void unload();
 
+  void connect(unsigned port, unsigned device);
   void power();
   void reset();
   void run();
@@ -49,10 +59,19 @@
 
   void paletteUpdate(PaletteMode mode);
 
+  //debugger functions
+  void exportMemory();
+
   Interface();
 
+  struct DeviceRef {
+    unsigned id;
+    unsigned port[3];
+  };
+  vector<DeviceRef> device_ref;
+
 private:
-  vector<Device> device;
+  void addDevice(Device device);
 };
 
 extern Interface* interface;
diff -Nru higan/fc/memory/memory.cpp higan/fc/memory/memory.cpp
--- higan/fc/memory/memory.cpp	2015-09-16 02:20:06.373574580 +0900
+++ higan/fc/memory/memory.cpp	2015-09-16 13:08:13.543563367 +0900
@@ -1,34 +1,54 @@
 #include <fc/fc.hpp>
 
+#define MEMORY_CPP
 namespace Famicom {
 
 Bus bus;
 
-//$0000-07ff = RAM (2KB)
-//$0800-1fff = RAM (mirror)
-//$2000-2007 = PPU
-//$2008-3fff = PPU (mirror)
-//$4000-4017 = APU + I/O
-//$4018-ffff = Cartridge
+Bus::Bus() {
+  lookup = new uint8 [64 * 1024];
+  target = new uint32[64 * 1024];
+}
 
-uint8 Bus::read(uint16 addr) {
-  uint8 data = cartridge.prg_read(addr);
-       if(addr <= 0x1fff) data = cpu.ram_read(addr);
-  else if(addr <= 0x3fff) data = ppu.read(addr);
-  else if(addr <= 0x4017) data = cpu.read(addr);
+Bus::~Bus() {
+  delete[] lookup;
+  delete[] target;
+}
 
-  if(cheat.enable()) {
-    if(auto result = cheat.find(addr, data)) return result();
-  }
+auto Bus::reset() -> void {
+  function<uint8 (unsigned)> reader = [](unsigned) { return cpu.mdr(); };
+  function<void (unsigned, uint8)> writer = [](unsigned, uint8) {};
 
-  return data;
+  idcount = 0;
+  map(reader, writer, 0x0000, 0xffff);
 }
 
-void Bus::write(uint16 addr, uint8 data) {
-  cartridge.prg_write(addr, data);
-  if(addr <= 0x1fff) return cpu.ram_write(addr, data);
-  if(addr <= 0x3fff) return ppu.write(addr, data);
-  if(addr <= 0x4017) return cpu.write(addr, data);
+auto Bus::map(
+  const function<uint8 (unsigned)>& reader,
+  const function<void (unsigned, uint8)>& writer,
+  unsigned addrlo, unsigned addrhi,
+  unsigned size, unsigned base, unsigned mask
+) -> void {
+  assert(addrlo <= addrhi && addrlo <= 0xffff);
+  assert(idcount < 255);
+
+  unsigned id = idcount++;
+  this->reader[id] = reader;
+  this->writer[id] = writer;
+
+  for(unsigned addr = addrlo; addr <= addrhi; addr++) {
+    unsigned offset = reduce(addr, mask);
+    if(size) offset = base + mirror(offset, size - base);
+    lookup[addr] = id;
+    target[addr] = offset;
+  }
 }
 
+//$0000-07ff = RAM (2KB)
+//$0800-1fff = RAM (mirror)
+//$2000-2007 = PPU
+//$2008-3fff = PPU (mirror)
+//$4000-4017 = APU + I/O
+//$4018-ffff = Cartridge
+
 }
diff -Nru higan/fc/memory/memory.hpp higan/fc/memory/memory.hpp
--- higan/fc/memory/memory.hpp	2015-09-16 02:20:06.373574580 +0900
+++ higan/fc/memory/memory.hpp	2015-09-16 13:08:13.543563367 +0900
@@ -1,6 +1,71 @@
+struct Memory {
+  virtual inline auto size() const -> unsigned;
+  virtual auto read(unsigned addr) -> uint8 = 0;
+  virtual auto write(unsigned addr, uint8 data) -> void = 0;
+};
+
+struct StaticRAM : Memory {
+  inline StaticRAM(unsigned size);
+  inline ~StaticRAM();
+
+  inline auto data() -> uint8*;
+  inline auto size() const -> unsigned;
+
+  inline auto read(unsigned addr) -> uint8;
+  inline auto write(unsigned addr, uint8 n) -> void;
+  inline auto operator[](unsigned addr) -> uint8&;
+  inline auto operator[](unsigned addr) const -> const uint8&;
+
+private:
+  uint8* data_ = nullptr;
+  unsigned size_ = 0;
+};
+
+struct MappedRAM : Memory {
+  inline auto reset() -> void;
+  inline auto map(uint8*, unsigned) -> void;
+  inline auto copy(const stream& memory) -> void;
+  inline auto read(const stream& memory) -> void;
+
+  inline auto write_protect(bool status) -> void;
+  inline auto data() -> uint8*;
+  inline auto size() const -> unsigned;
+
+  inline auto read(unsigned addr) -> uint8;
+  inline auto write(unsigned addr, uint8 n) -> void;
+  inline auto operator[](unsigned addr) const -> const uint8&;
+
+private:
+  uint8* data_ = nullptr;
+  unsigned size_ = 0;
+  bool write_protect_ = false;
+};
+
 struct Bus {
-  uint8 read(uint16 addr);
-  void write(uint16 addr, uint8 data);
+  alwaysinline static auto mirror(unsigned addr, unsigned size) -> unsigned;
+  alwaysinline static auto reduce(unsigned addr, unsigned mask) -> unsigned;
+
+  Bus();
+  ~Bus();
+
+  alwaysinline auto read(unsigned addr) -> uint8;
+  alwaysinline auto write(unsigned addr, uint8 data) -> void;
+
+  auto reset() -> void;
+  auto map() -> void;
+  auto map(
+    const function<uint8 (unsigned)>& reader,
+    const function<void (unsigned, uint8)>& writer,
+    unsigned addrlo, unsigned addrhi,
+    unsigned size = 0, unsigned base = 0, unsigned mask = 0
+  ) -> void;
+
+  uint8* lookup = nullptr;
+  uint32* target = nullptr;
+
+  unsigned idcount;
+  function<uint8 (unsigned)> reader[256];
+  function<void (unsigned, uint8)> writer[256];
 };
 
 extern Bus bus;
diff -Nru higan/fc/memory/memory-inline.hpp higan/fc/memory/memory-inline.hpp
--- higan/fc/memory/memory-inline.hpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/fc/memory/memory-inline.hpp	2015-09-16 13:08:13.543563367 +0900
@@ -0,0 +1,109 @@
+//Memory
+
+auto Memory::size() const -> unsigned { return 0; }
+
+//StaticRAM
+
+auto StaticRAM::data() -> uint8* { return data_; }
+auto StaticRAM::size() const -> unsigned { return size_; }
+
+auto StaticRAM::read(unsigned addr) -> uint8 { return data_[addr]; }
+auto StaticRAM::write(unsigned addr, uint8 n) -> void { data_[addr] = n; }
+auto StaticRAM::operator[](unsigned addr) -> uint8& { return data_[addr]; }
+auto StaticRAM::operator[](unsigned addr) const -> const uint8& { return data_[addr]; }
+
+StaticRAM::StaticRAM(unsigned n) : size_(n) { data_ = new uint8[size_]; }
+StaticRAM::~StaticRAM() { delete[] data_; }
+
+//MappedRAM
+
+auto MappedRAM::reset() -> void {
+  if(data_) {
+    delete[] data_;
+    data_ = nullptr;
+  }
+  size_ = 0;
+  write_protect_ = false;
+}
+
+auto MappedRAM::map(uint8* source, unsigned length) -> void {
+  reset();
+  data_ = source;
+  size_ = data_ ? length : 0;
+}
+
+auto MappedRAM::copy(const stream& memory) -> void {
+  if(data_) delete[] data_;
+  //round size up to multiple of 256-bytes
+  size_ = (memory.size() & ~255) + ((bool)(memory.size() & 255) << 8);
+  data_ = new uint8[size_]();
+  memory.read(data_, memory.size());
+}
+
+auto MappedRAM::read(const stream& memory) -> void {
+  memory.read(data_, min(memory.size(), size_));
+}
+
+auto MappedRAM::write_protect(bool status) -> void { write_protect_ = status; }
+auto MappedRAM::data() -> uint8* { return data_; }
+auto MappedRAM::size() const -> unsigned { return size_; }
+
+auto MappedRAM::read(unsigned addr) -> uint8 { return data_[addr]; }
+auto MappedRAM::write(unsigned addr, uint8 n) -> void { if(!write_protect_) data_[addr] = n; }
+auto MappedRAM::operator[](unsigned addr) const -> const uint8& { return data_[addr]; }
+
+//Bus
+
+auto Bus::mirror(unsigned addr, unsigned size) -> unsigned {
+  if(size == 0) return 0;
+  unsigned base = 0;
+  unsigned mask = 1 << 15;
+  while(addr >= size) {
+    while(!(addr & mask)) mask >>= 1;
+    addr -= mask;
+    if(size > mask) {
+      size -= mask;
+      base += mask;
+    }
+    mask >>= 1;
+  }
+  return base + addr;
+}
+
+auto Bus::reduce(unsigned addr, unsigned mask) -> unsigned {
+  while(mask) {
+    unsigned bits = (mask & -mask) - 1;
+    addr = ((addr >> 1) & ~bits) | (addr & bits);
+    mask = (mask & (mask - 1)) >> 1;
+  }
+  return addr;
+}
+
+//$0000-07ff = RAM (2KB)
+//$0800-1fff = RAM (mirror)
+//$2000-2007 = PPU
+//$2008-3fff = PPU (mirror)
+//$4000-4017 = APU + I/O
+//$4018-ffff = Cartridge
+
+auto Bus::read(unsigned addr) -> uint8 {
+  uint8 data = cartridge.prg_read(addr);
+       if(addr <= 0x1fff) data = cpu.ram_read(addr);
+  else if(addr <= 0x3fff) data = ppu.read(addr);
+  else if(addr <= 0x4017) data = cpu.read(addr);
+  else if((addr & 0xe020) == 0x4020 && system.vs()) data = cpu.read(addr);
+
+  if(cheat.enable()) {
+    if(auto result = cheat.find(addr, data)) return result();
+  }
+
+  return data;
+}
+
+auto Bus::write(unsigned addr, uint8 data) -> void {
+  cartridge.prg_write(addr, data);
+  if(addr <= 0x1fff) return cpu.ram_write(addr, data);
+  if(addr <= 0x3fff) return ppu.write(addr, data);
+  if(addr <= 0x4017) return cpu.write(addr, data);
+  if((addr & 0xe020) == 0x4020 && system.vs()) return cpu.write(addr, data);
+}
diff -Nru higan/fc/ppu/counter/counter.hpp higan/fc/ppu/counter/counter.hpp
--- higan/fc/ppu/counter/counter.hpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/fc/ppu/counter/counter.hpp	2015-09-16 13:08:13.522563364 +0900
@@ -0,0 +1,24 @@
+class PPUcounter {
+public:
+  alwaysinline void tick(unsigned clocks);
+
+  alwaysinline bool   field   () const;
+  alwaysinline uint16 vcounter() const;
+  alwaysinline uint16 hcounter() const;
+  alwaysinline bool   skip    () const;
+  inline uint16 lineclocks() const;
+
+  inline void reset();
+  function<void ()> scanline;
+  void serialize(serializer&);
+
+//private:
+  inline void vcounter_tick();
+
+  struct {
+    bool field;
+    uint16 vcounter;
+    uint16 hcounter;
+    bool skip;
+  } status;
+};
diff -Nru higan/fc/ppu/counter/counter-inline.hpp higan/fc/ppu/counter/counter-inline.hpp
--- higan/fc/ppu/counter/counter-inline.hpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/fc/ppu/counter/counter-inline.hpp	2015-09-16 13:08:13.522563364 +0900
@@ -0,0 +1,38 @@
+void PPUcounter::tick(unsigned clocks) {
+  status.hcounter++;
+  if(status.hcounter == 337) status.skip = 341 - lineclocks();
+  if(status.hcounter == 341 - status.skip) {
+    status.hcounter = 0;
+    status.skip = false;
+    vcounter_tick();
+  }
+}
+
+//internal
+void PPUcounter::vcounter_tick() {
+  status.vcounter++;
+
+  if((system.region() == System::Region::NTSC && status.vcounter == 262)
+  || (system.region() == System::Region::PAL  && status.vcounter == 312)
+  ) {
+    status.vcounter = 0;
+    status.field = !status.field;
+  }
+  if(scanline) scanline();
+}
+
+bool   PPUcounter::field   () const { return status.field; }
+uint16 PPUcounter::vcounter() const { return status.vcounter; }
+uint16 PPUcounter::hcounter() const { return status.hcounter; }
+
+uint16 PPUcounter::lineclocks() const {
+  if(system.region() == System::Region::NTSC && ppu.raster_enable() && vcounter() == 261 && field() == 1) return 340;
+  return 341;
+}
+
+void PPUcounter::reset() {
+  status.field    = 0;
+  status.vcounter = 0;
+  status.hcounter = 0;
+  status.skip     = false;
+}
diff -Nru higan/fc/ppu/ppu.cpp higan/fc/ppu/ppu.cpp
--- higan/fc/ppu/ppu.cpp	2015-09-16 02:20:06.373574580 +0900
+++ higan/fc/ppu/ppu.cpp	2015-09-16 13:08:13.523563365 +0900
@@ -1,15 +1,22 @@
 #include <fc/fc.hpp>
 
+#define PPU_CPP
 namespace Famicom {
 
 #include "serialization.cpp"
 PPU ppu;
 
-void PPU::Main() {
-  ppu.main();
+void PPU::step(unsigned clocks) {
+  clock += clocks;
 }
 
-void PPU::main() {
+void PPU::synchronize_cpu() {
+  if(clock >= 0 && scheduler.sync != Scheduler::SynchronizeMode::All) co_switch(cpu.thread);
+}
+
+void PPU::Enter() { ppu.enter(); }
+
+void PPU::enter() {
   while(true) {
     if(scheduler.sync == Scheduler::SynchronizeMode::PPU) {
       scheduler.exit(Scheduler::ExitReason::SynchronizeEvent);
@@ -19,56 +26,73 @@
   }
 }
 
-void PPU::tick() {
-  if(status.ly == 240 && status.lx == 340) status.nmi_hold = 1;
-  if(status.ly == 241 && status.lx ==   0) status.nmi_flag = status.nmi_hold;
-  if(status.ly == 241 && status.lx ==   2) cpu.set_nmi_line(status.nmi_enable && status.nmi_flag);
+void PPU::add_clocks(unsigned clocks) {
+  unsigned vbl;
+  unsigned pre;
+  switch(system.region()) {
+  case System::Region::NTSC:  vbl = 241; pre = 261; break;
+  case System::Region::PAL:   vbl = 241; pre = 311; break;
+//case System::Region::Dendy: vbl = 291; pre = 311; break;
+  }
+
+  while(clocks--) {
+    if(vcounter() == 240 && hcounter() == 340) status.nmi_hold = 1;
+
+    if(vcounter() == vbl && hcounter() ==   0) status.chr_abus = status.vaddr & 0x3fff;
+    if(vcounter() == vbl && hcounter() ==   0) status.nmi_flag = status.nmi_hold;
+    if(vcounter() == vbl && hcounter() ==   2) cpu.set_nmi_line(status.nmi_enable && status.nmi_flag);
 
-  if(status.ly == 260 && status.lx == 340) status.sprite_zero_hit = 0, status.sprite_overflow = 0;
 
-  if(status.ly == 260 && status.lx == 340) status.nmi_hold = 0;
-  if(status.ly == 261 && status.lx ==   0) status.nmi_flag = status.nmi_hold;
-  if(status.ly == 261 && status.lx ==   2) cpu.set_nmi_line(status.nmi_enable && status.nmi_flag);
+    if(vcounter() == pre - 1 && hcounter() == 340) status.nmi_hold = 0;
+    if(vcounter() == pre     && hcounter() ==   0) status.nmi_flag = status.nmi_hold;
+    if(vcounter() == pre     && hcounter() ==   1) status.sprite_zero_hit = 0, status.sprite_overflow = 0;
+    if(vcounter() == pre     && hcounter() ==   2) cpu.set_nmi_line(status.nmi_enable && status.nmi_flag);
 
-  clock += 4;
-  if(clock >= 0) co_switch(cpu.thread);
+    step(system.region() == System::Region::NTSC ? 4 : 5);
+    synchronize_cpu();
 
-  status.lx++;
+    for(unsigned i = 0; i < 8; i++) {
+      if(--status.mdr_decay[i] == 0) status.mdr &= ~(1 << i);
+    }
+
+    tick(1);
+  }
 }
 
 void PPU::scanline() {
-  status.lx = 0;
-  if(++status.ly == 262) {
-    status.ly = 0;
-    frame();
-  }
-  cartridge.scanline(status.ly);
+  if(vcounter() == 0) frame();
+  cartridge.scanline(vcounter());
 }
 
 void PPU::frame() {
-  status.field ^= 1;
+  system.frame();
   scheduler.exit(Scheduler::ExitReason::FrameEvent);
 }
 
 void PPU::power() {
+  status.vaddr = 0x0000;
+
+  status.nmi_hold = 0;
+  status.nmi_flag = 1;
+
+  //$2003
+  status.oam_addr = 0x00;
+
+  for(auto& n : ciram  ) n = 0xff;
 }
 
 void PPU::reset() {
-  create(PPU::Main, 21477272);
+  create(PPU::Enter, system.cpu_frequency());
+  PPUcounter::reset();
+  memset(surface, 0, 256 * 312 * sizeof(uint32));
 
   status.mdr = 0x00;
-  status.field = 0;
-  status.ly = 0;
   status.bus_data = 0x00;
   status.address_latch = 0;
 
-  status.vaddr = 0x0000;
   status.taddr = 0x0000;
   status.xaddr = 0x00;
 
-  status.nmi_hold = 0;
-  status.nmi_flag = 0;
-
   //$2000
   status.nmi_enable = false;
   status.master_select = 0;
@@ -89,13 +113,8 @@
   status.sprite_zero_hit = false;
   status.sprite_overflow = false;
 
-  //$2003
-  status.oam_addr = 0x00;
-
-  for(auto& n : buffer) n = 0;
-  for(auto& n : ciram ) n = 0;
-  for(auto& n : cgram ) n = 0;
-  for(auto& n : oam   ) n = 0;
+  for(auto& n : cgram  ) n = 0;
+  for(auto& n : oam    ) n = 0;
 }
 
 uint8 PPU::read(uint16 addr) {
@@ -105,31 +124,52 @@
   case 2:  //PPUSTATUS
     result |= status.nmi_flag << 7;
     result |= status.sprite_zero_hit << 6;
-    result |= status.sprite_overflow << 5;
-    result |= status.mdr & 0x1f;
+    switch(revision) {
+    default:
+      result |= status.sprite_overflow << 5;
+      result |= status.mdr & 0x1f;
+      break;
+    case Revision::RC2C05_01:
+    case Revision::RC2C05_04: result |= 0x1b; break;
+    case Revision::RC2C05_02: result |= 0x3d; break;
+    case Revision::RC2C05_03: result |= 0x1c; break;
+    }
     status.address_latch = 0;
     status.nmi_hold = 0;
     cpu.set_nmi_line(status.nmi_flag = 0);
     break;
   case 4:  //OAMDATA
-    result = oam[status.oam_addr];
-    if((status.oam_addr & 3) == 3) result &= 0xe3;
+    switch(revision) {
+    case Revision::RP2C02C:
+      result = status.mdr;
+      break;
+    default:
+      result = oam_read(status.oam_addr);
+      if((status.oam_addr & 3) == 2) {
+        status.mdr = result;
+        for(unsigned i = 0; i < 8; i++) status.mdr_decay[i] = 3221591;
+      }
+      break;
+    }
     break;
   case 7:  //PPUDATA
-    if(raster_enable() && (status.ly <= 240 || status.ly == 261)) return 0x00;
+    if(raster_enable() && (vcounter() <= 240 || vcounter() == (system.region() == System::Region::NTSC ? 261 : 311))) {
+      return 0x00;
+    }
 
     addr = status.vaddr & 0x3fff;
-    if(addr <= 0x1fff) {
-      result = status.bus_data;
-      status.bus_data = cartridge.chr_read(addr);
-    } else if(addr <= 0x3eff) {
+    if(addr <= 0x3eff) {
       result = status.bus_data;
-      status.bus_data = cartridge.chr_read(addr);
     } else if(addr <= 0x3fff) {
-      result = cgram_read(addr);
-      status.bus_data = cartridge.chr_read(addr);
+      result = ((status.mdr & 0xc0) | cgram_read(addr));
     }
+    status.bus_data = cartridge.chr_read(status.chr_abus = addr);
     status.vaddr += status.vram_increment;
+    status.chr_abus = status.vaddr;
+    status.mdr = result;
+    break;
+  default:
+    result = status.mdr;
     break;
   }
 
@@ -138,6 +178,17 @@
 
 void PPU::write(uint16 addr, uint8 data) {
   status.mdr = data;
+  // Decay rate can vary depending on the system and temperature.
+  // Value used here is PPU's NTSC clock rate * 0.6 rounded to nearest integer.
+  for(unsigned i = 0; i < 8; i++) status.mdr_decay[i] = 3221591;
+
+  switch(revision) {
+  case Revision::RC2C05_01:
+  case Revision::RC2C05_02:
+  case Revision::RC2C05_03:
+  case Revision::RC2C05_04:
+  case Revision::RC2C05_05: if((addr & 6) == 0) addr ^= 1; break;
+  }
 
   switch(addr & 7) {
   case 0:  //PPUCTRL
@@ -152,6 +203,12 @@
     return;
   case 1:  //PPUMASK
     status.emphasis = data >> 5;
+    if(revision == Revision::RP2C07) {
+      status.emphasis =
+        ((status.emphasis & 1) << 1) | // swap red
+        ((status.emphasis & 2) >> 1) | // and green
+        ((status.emphasis & 4)     );
+    }
     status.sprite_enable = data & 0x10;
     status.bg_enable = data & 0x08;
     status.sprite_edge_enable = data & 0x04;
@@ -161,10 +218,18 @@
   case 2:  //PPUSTATUS
     return;
   case 3:  //OAMADDR
+    if(revision != Revision::RP2C07) {
+      // below corruption code only applies for preferred CPU-PPU alignment.
+      // on an actual Famicom/NES, waiting a while after writing to OAM will
+      // make this corruption happen because the OAM will have decayed at the
+      // spot being written to.
+      for(int i = 0; i < 8; i++)
+        oam[((addr & 0xf800) >> 8) + i] = oam[(status.oam_addr & 0xf8) + i];
+    }
     status.oam_addr = data;
     return;
   case 4:  //OAMDATA
-    oam[status.oam_addr++] = data;
+    oam_write(status.oam_addr++, data);
     return;
   case 5:  //PPUSCROLL
     if(status.address_latch == 0) {
@@ -181,45 +246,57 @@
     } else {
       status.taddr = (status.taddr & 0x7f00) | data;
       status.vaddr = status.taddr;
+      status.chr_abus = status.vaddr;
     }
     status.address_latch ^= 1;
     return;
   case 7:  //PPUDATA
-    if(raster_enable() && (status.ly <= 240 || status.ly == 261)) return;
+    if(raster_enable() && (vcounter() <= 240 || vcounter() == (system.region() != System::Region::PAL ? 261 : 311))) {
+      return;
+    }
 
     addr = status.vaddr & 0x3fff;
-    if(addr <= 0x1fff) {
-      cartridge.chr_write(addr, data);
-    } else if(addr <= 0x3eff) {
-      cartridge.chr_write(addr, data);
+    if(addr <= 0x3eff) {
+      cartridge.chr_write(status.chr_abus = addr, data);
     } else if(addr <= 0x3fff) {
       cgram_write(addr, data);
     }
     status.vaddr += status.vram_increment;
+    status.chr_abus = status.vaddr;
     return;
   }
 }
 
-uint8 PPU::ciram_read(uint16 addr) {
-  return ciram[addr & 0x07ff];
+uint8 PPU::ciram_read(uint14 addr) {
+  return ciram[addr & (!system.vs() ? 0x07ff : 0x0fff)];
 }
 
-void PPU::ciram_write(uint16 addr, uint8 data) {
-  ciram[addr & 0x07ff] = data;
+void PPU::ciram_write(uint14 addr, uint8 data) {
+  ciram[addr & (!system.vs() ? 0x07ff : 0x0fff)] = data;
 }
 
-uint8 PPU::cgram_read(uint16 addr) {
+uint8 PPU::cgram_read(uint14 addr) {
   if((addr & 0x13) == 0x10) addr &= ~0x10;
   uint8 data = cgram[addr & 0x1f];
   if(status.grayscale) data &= 0x30;
   return data;
 }
 
-void PPU::cgram_write(uint16 addr, uint8 data) {
+void PPU::cgram_write(uint14 addr, uint8 data) {
   if((addr & 0x13) == 0x10) addr &= ~0x10;
   cgram[addr & 0x1f] = data;
 }
 
+uint8 PPU::oam_read(uint8 addr) {
+  uint8 data = oam[addr];
+  return data;
+}
+
+void PPU::oam_write(uint8 addr, uint8 data) {
+  if((addr & 3) == 2) data &= 0xe3;
+  oam[addr] = data;
+}
+
 //
 
 //vaddr = 0yyy VHYY  YYYX XXXX
@@ -251,9 +328,9 @@
 
 //
 
-uint8 PPU::chr_load(uint16 addr) {
+uint8 PPU::chr_load(uint14 addr) {
   if(raster_enable() == false) return 0x00;
-  return cartridge.chr_read(addr);
+  return cartridge.chr_read(status.chr_abus = addr);
 }
 
 //
@@ -281,9 +358,8 @@
 //
 
 void PPU::raster_pixel() {
-  uint32* output = buffer + status.ly * 256;
-
-  unsigned mask = 0x8000 >> (status.xaddr + (status.lx & 7));
+  unsigned lx = hcounter() - 1;
+  unsigned mask = 0x8000 >> (status.xaddr + (lx & 7));
   unsigned palette = 0, object_palette = 0;
   bool object_priority = 0;
   palette |= (raster.tiledatalo & mask) ? 1 : 0;
@@ -295,14 +371,14 @@
   }
 
   if(status.bg_enable == false) palette = 0;
-  if(status.bg_edge_enable == false && status.lx < 8) palette = 0;
+  if(status.bg_edge_enable == false && lx < 8) palette = 0;
 
   if(status.sprite_enable == true)
   for(signed sprite = 7; sprite >= 0; sprite--) {
-    if(status.sprite_edge_enable == false && status.lx < 8) continue;
+    if(status.sprite_edge_enable == false && lx < 8) continue;
     if(raster.oam[sprite].id == 64) continue;
 
-    unsigned spritex = status.lx - raster.oam[sprite].x;
+    unsigned spritex = lx - raster.oam[sprite].x;
     if(spritex >= 8) continue;
 
     if(raster.oam[sprite].attr & 0x40) spritex ^= 7;
@@ -312,7 +388,7 @@
     sprite_palette |= (raster.oam[sprite].tiledatahi & mask) ? 2 : 0;
     if(sprite_palette == 0) continue;
 
-    if(raster.oam[sprite].id == 0 && palette && status.lx != 255) status.sprite_zero_hit = 1;
+    if(raster.oam[sprite].id == 0 && palette && lx != 255) status.sprite_zero_hit = 1;
     sprite_palette |= (raster.oam[sprite].attr & 3) << 2;
 
     object_priority = raster.oam[sprite].attr & 0x20;
@@ -323,15 +399,18 @@
     if(palette == 0 || object_priority == 0) palette = object_palette;
   }
 
-  if(raster_enable() == false) palette = 0;
-  output[status.lx] = (status.emphasis << 6) | cgram_read(palette);
+  if(raster_enable() == false) {
+    if((status.vaddr & 0x3f00) != 0x3f00) palette = 0;
+    else palette = status.vaddr;
+  }
+  output[vcounter() * 256 + lx] = (status.emphasis << 6) | cgram_read(palette);
 }
 
 void PPU::raster_sprite() {
   if(raster_enable() == false) return;
 
   unsigned n = raster.oam_iterator++;
-  signed ly = (status.ly == 261 ? -1 : status.ly);
+  signed ly = (vcounter() == (system.region() == System::Region::NTSC ? 261 : 311) ? -1 : vcounter());
   unsigned y = ly - oam[(n * 4) + 0];
 
   if(y >= sprite_height()) return;
@@ -349,8 +428,9 @@
 }
 
 void PPU::raster_scanline() {
-  if((status.ly >= 240 && status.ly <= 260)) {
-    for(unsigned x = 0; x < 341; x++) tick();
+  unsigned last_scanline = system.region() == System::Region::NTSC ? 261 : 311;
+  if((vcounter() >= 240 && vcounter() < last_scanline)) {
+    add_clocks(341);
     return scanline();
   }
 
@@ -367,41 +447,44 @@
     raster.soam[n].tiledatahi = 0;
   }
 
-  for(unsigned tile = 0; tile < 32; tile++) {  //  0-255
+  //  0
+  add_clocks(1);
+
+  for(unsigned tile = 0; tile < 32; tile++) {  //  1-256
     unsigned nametable = chr_load(0x2000 | (status.vaddr & 0x0fff));
     unsigned tileaddr = status.bg_addr + (nametable << 4) + (scrolly() & 7);
     raster_pixel();
-    tick();
+    add_clocks(1);
 
     raster_pixel();
-    tick();
+    add_clocks(1);
 
     unsigned attribute = chr_load(0x23c0 | (status.vaddr & 0x0fc0) | ((scrolly() >> 5) << 3) | (scrollx() >> 5));
     if(scrolly() & 16) attribute >>= 4;
     if(scrollx() & 16) attribute >>= 2;
     raster_pixel();
-    tick();
+    add_clocks(1);
 
     scrollx_increment();
     if(tile == 31) scrolly_increment();
     raster_pixel();
     raster_sprite();
-    tick();
+    add_clocks(1);
 
     unsigned tiledatalo = chr_load(tileaddr + 0);
     raster_pixel();
-    tick();
+    add_clocks(1);
 
     raster_pixel();
-    tick();
+    add_clocks(1);
 
     unsigned tiledatahi = chr_load(tileaddr + 8);
     raster_pixel();
-    tick();
+    add_clocks(1);
 
     raster_pixel();
     raster_sprite();
-    tick();
+    add_clocks(1);
 
     raster.nametable = (raster.nametable << 8) | nametable;
     raster.attribute = (raster.attribute << 2) | (attribute & 3);
@@ -411,56 +494,50 @@
 
   for(unsigned n = 0; n < 8; n++) raster.oam[n] = raster.soam[n];
 
-  for(unsigned sprite = 0; sprite < 8; sprite++) {  //256-319
+  for(unsigned sprite = 0; sprite < 8; sprite++) {  //257-320
     unsigned nametable = chr_load(0x2000 | (status.vaddr & 0x0fff));
-    tick();
+    add_clocks(1);
 
     if(raster_enable() && sprite == 0) status.vaddr = (status.vaddr & 0x7be0) | (status.taddr & 0x041f);  //257
-    tick();
+    add_clocks(1);
 
     unsigned attribute = chr_load(0x23c0 | (status.vaddr & 0x0fc0) | ((scrolly() >> 5) << 3) | (scrollx() >> 5));
     unsigned tileaddr = (sprite_height() == 8)
     ? status.sprite_addr + raster.oam[sprite].tile * 16
     : ((raster.oam[sprite].tile & ~1) * 16) + ((raster.oam[sprite].tile & 1) * 0x1000);
-    tick();
-    tick();
+    add_clocks(2);
 
-    unsigned spritey = (status.ly - raster.oam[sprite].y) & (sprite_height() - 1);
+    unsigned spritey = (vcounter() - raster.oam[sprite].y) & (sprite_height() - 1);
     if(raster.oam[sprite].attr & 0x80) spritey ^= (sprite_height() - 1);
     tileaddr += spritey + (spritey & 8);
 
     raster.oam[sprite].tiledatalo = chr_load(tileaddr + 0);
-    tick();
-    tick();
+    add_clocks(2);
 
     raster.oam[sprite].tiledatahi = chr_load(tileaddr + 8);
-    tick();
-    tick();
+    add_clocks(2);
 
-    if(raster_enable() && sprite == 6 && status.ly == 261) status.vaddr = status.taddr;  //304
+    if(raster_enable() && sprite == 6 && vcounter() == last_scanline) status.vaddr = status.taddr;  //304
   }
 
-  for(unsigned tile = 0; tile < 2; tile++) {  //320-335
+  for(unsigned tile = 0; tile < 2; tile++) {  //321-336
     unsigned nametable = chr_load(0x2000 | (status.vaddr & 0x0fff));
     unsigned tileaddr = status.bg_addr + (nametable << 4) + (scrolly() & 7);
-    tick();
-    tick();
+    add_clocks(2);
 
     unsigned attribute = chr_load(0x23c0 | (status.vaddr & 0x0fc0) | ((scrolly() >> 5) << 3) | (scrollx() >> 5));
     if(scrolly() & 16) attribute >>= 4;
     if(scrollx() & 16) attribute >>= 2;
-    tick();
+    add_clocks(1);
 
     scrollx_increment();
-    tick();
+    add_clocks(1);
 
     unsigned tiledatalo = chr_load(tileaddr + 0);
-    tick();
-    tick();
+    add_clocks(2);
 
     unsigned tiledatahi = chr_load(tileaddr + 8);
-    tick();
-    tick();
+    add_clocks(2);
 
     raster.nametable = (raster.nametable << 8) | nametable;
     raster.attribute = (raster.attribute << 2) | (attribute & 3);
@@ -468,20 +545,61 @@
     raster.tiledatahi = (raster.tiledatahi << 8) | tiledatahi;
   }
 
-  //336-339
+  //337-340
   chr_load(0x2000 | (status.vaddr & 0x0fff));
-  tick();
-  bool skip = (raster_enable() && status.field == 1 && status.ly == 261);
-  tick();
+  add_clocks(2);
 
   chr_load(0x2000 | (status.vaddr & 0x0fff));
-  tick();
-  tick();
-
-  //340
-  if(skip == false) tick();
+  add_clocks(1);
+  if(hcounter() > 0) add_clocks(1);
 
   return scanline();
 }
 
+PPU::PPU() {
+  surface = new uint32[256 * 312];
+  output = surface + 0 * 256;
+}
+
+PPU::~PPU() {
+  delete[] surface;
+}
+
+//
+
+const uint9_t PPU::RP2C03[16 * 4] = {
+  0333,0014,0006,0326,0403,0503,0510,0420,0320,0120,0031,0040,0022,0000,0000,0000,
+  0555,0036,0027,0407,0507,0704,0700,0630,0430,0140,0040,0053,0044,0000,0000,0000,
+  0777,0357,0447,0637,0707,0737,0740,0750,0660,0360,0070,0276,0077,0000,0000,0000,
+  0777,0567,0657,0757,0747,0755,0764,0772,0773,0572,0473,0276,0467,0000,0000,0000,
+};
+
+const uint9_t PPU::RP2C04_0001[16 * 4] = {
+  0755,0637,0700,0447,0044,0120,0222,0704,0777,0333,0750,0503,0403,0660,0320,0777,
+  0357,0653,0310,0360,0467,0657,0764,0027,0760,0276,0000,0200,0666,0444,0707,0014,
+  0003,0567,0757,0070,0077,0022,0053,0507,0000,0420,0747,0510,0407,0006,0740,0000,
+  0000,0140,0555,0031,0572,0326,0770,0630,0020,0036,0040,0111,0773,0737,0430,0473,
+};
+
+const uint9_t PPU::RP2C04_0002[16 * 4] = {
+  0000,0750,0430,0572,0473,0737,0044,0567,0700,0407,0773,0747,0777,0637,0467,0040,
+  0020,0357,0510,0666,0053,0360,0200,0447,0222,0707,0003,0276,0657,0320,0000,0326,
+  0403,0764,0740,0757,0036,0310,0555,0006,0507,0760,0333,0120,0027,0000,0660,0777,
+  0653,0111,0070,0630,0022,0014,0704,0140,0000,0077,0420,0770,0755,0503,0031,0444,
+};
+
+const uint9_t PPU::RP2C04_0003[16 * 4] = {
+  0507,0737,0473,0555,0040,0777,0567,0120,0014,0000,0764,0320,0704,0666,0653,0467,
+  0447,0044,0503,0027,0140,0430,0630,0053,0333,0326,0000,0006,0700,0510,0747,0755,
+  0637,0020,0003,0770,0111,0750,0740,0777,0360,0403,0357,0707,0036,0444,0000,0310,
+  0077,0200,0572,0757,0420,0070,0660,0222,0031,0000,0657,0773,0407,0276,0760,0022,
+};
+
+const uint9_t PPU::RP2C04_0004[16 * 4] = {
+  0430,0326,0044,0660,0000,0755,0014,0630,0555,0310,0070,0003,0764,0770,0040,0572,
+  0737,0200,0027,0747,0000,0222,0510,0740,0653,0053,0447,0140,0403,0000,0473,0357,
+  0503,0031,0420,0006,0407,0507,0333,0704,0022,0666,0036,0020,0111,0773,0444,0707,
+  0757,0777,0320,0700,0760,0276,0777,0467,0000,0750,0637,0567,0360,0657,0077,0120,
+};
+
 }
diff -Nru higan/fc/ppu/ppu.hpp higan/fc/ppu/ppu.hpp
--- higan/fc/ppu/ppu.hpp	2015-09-16 02:20:06.373574580 +0900
+++ higan/fc/ppu/ppu.hpp	2015-09-16 13:08:13.524563365 +0900
@@ -1,8 +1,12 @@
-struct PPU : Thread {
-  static void Main();
-  void main();
-  void tick();
+struct PPU : Thread, public PPUcounter {
+  uint8 ciram[4096]; // 2048 in Famicom and PlayChoice-10
+  uint8 cgram[32];
+  uint8 oam[256];
+
+  alwaysinline void step(unsigned clocks);
+  alwaysinline void synchronize_cpu();
 
+  void enter();
   void scanline();
   void frame();
 
@@ -12,11 +16,14 @@
   uint8 read(uint16 addr);
   void write(uint16 addr, uint8 data);
 
-  uint8 ciram_read(uint16 addr);
-  void ciram_write(uint16 addr, uint8 data);
+  uint8 ciram_read(uint14 addr);
+  void ciram_write(uint14 addr, uint8 data);
 
-  uint8 cgram_read(uint16 addr);
-  void cgram_write(uint16 addr, uint8 data);
+  uint8 cgram_read(uint14 addr);
+  void cgram_write(uint14 addr, uint8 data);
+
+  uint8 oam_read(uint8 addr);
+  void oam_write(uint8 addr, uint8 data);
 
   bool raster_enable() const;
   unsigned nametable_addr() const;
@@ -24,23 +31,47 @@
   unsigned scrolly() const;
   unsigned sprite_height() const;
 
-  uint8 chr_load(uint16 addr);
+  uint8 chr_load(uint14 addr);
 
   void scrollx_increment();
   void scrolly_increment();
 
-  void raster_pixel();
-  void raster_sprite();
-  void raster_scanline();
+  static const uint9_t RP2C03[16 * 4];
+  static const uint9_t RP2C04_0001[16 * 4];
+  static const uint9_t RP2C04_0002[16 * 4];
+  static const uint9_t RP2C04_0003[16 * 4];
+  static const uint9_t RP2C04_0004[16 * 4];
 
   void serialize(serializer&);
+  PPU();
+  ~PPU();
+
+  enum class Revision : unsigned {
+    RP2C02C,
+    RP2C02G,
+    RP2C07,
+    RP2C03B,
+    RP2C03G,
+    RP2C04_0001,
+    RP2C04_0002,
+    RP2C04_0003,
+    RP2C04_0004,
+    RC2C03B,
+    RC2C03C,
+    RC2C05_01,
+    RC2C05_02,
+    RC2C05_03,
+    RC2C05_04,
+    RC2C05_05,
+  } revision;
+
+  uint32* surface;
+  uint32* output;
 
   struct Status {
+    uint14 chr_abus;
     uint8 mdr;
-
-    bool field;
-    unsigned lx;
-    unsigned ly;
+    unsigned mdr_decay[8];
 
     uint8 bus_data;
 
@@ -77,6 +108,13 @@
     uint8 oam_addr;
   } status;
 
+  static void Enter();
+  void add_clocks(unsigned);
+
+  void raster_pixel();
+  void raster_sprite();
+  void raster_scanline();
+
   struct Raster {
     uint16 nametable;
     uint16 attribute;
@@ -97,11 +135,6 @@
       uint8 tiledatahi;
     } oam[8], soam[8];
   } raster;
-
-  uint32 buffer[256 * 262];
-  uint8 ciram[2048];
-  uint8 cgram[32];
-  uint8 oam[256];
 };
 
 extern PPU ppu;
diff -Nru higan/fc/ppu/serialization.cpp higan/fc/ppu/serialization.cpp
--- higan/fc/ppu/serialization.cpp	2015-09-16 02:20:06.373574580 +0900
+++ higan/fc/ppu/serialization.cpp	2015-09-16 13:08:13.524563365 +0900
@@ -1,11 +1,18 @@
+#ifdef PPU_CPP
+
+void PPUcounter::serialize(serializer& s) {
+  s.integer(status.field);
+  s.integer(status.hcounter);
+  s.integer(status.vcounter);
+}
+
 void PPU::serialize(serializer& s) {
   Thread::serialize(s);
+  PPUcounter::serialize(s);
 
+  s.integer(status.chr_abus);
   s.integer(status.mdr);
-
-  s.integer(status.field);
-  s.integer(status.lx);
-  s.integer(status.ly);
+  s.array(status.mdr_decay);
 
   s.integer(status.bus_data);
 
@@ -67,8 +74,9 @@
     s.integer(raster.soam[n].tiledatahi);
   }
 
-  s.array(buffer);
-  s.array(ciram);
+  s.array(ciram, !system.vs() ? 0x0800 : 0x1000);
   s.array(cgram);
   s.array(oam);
 }
+
+#endif
diff -Nru higan/fc/scheduler/scheduler.cpp higan/fc/scheduler/scheduler.cpp
--- higan/fc/scheduler/scheduler.cpp	2015-09-16 02:20:06.373574580 +0900
+++ higan/fc/scheduler/scheduler.cpp	2015-09-16 13:08:13.522563364 +0900
@@ -1,28 +1,26 @@
-#include <fc/fc.hpp>
-
-namespace Famicom {
+#ifdef SYSTEM_CPP
 
 Scheduler scheduler;
 
-void Scheduler::enter() {
+auto Scheduler::init() -> void {
+  host_thread = co_active();
+  thread = cpu.thread;
+  sync = SynchronizeMode::None;
+}
+
+auto Scheduler::enter() -> void {
   host_thread = co_active();
   co_switch(thread);
 }
 
-void Scheduler::exit(ExitReason reason) {
+auto Scheduler::exit(ExitReason reason) -> void {
   exit_reason = reason;
   thread = co_active();
   co_switch(host_thread);
 }
 
-void Scheduler::power() {
+auto Scheduler::debug() -> void {
+  exit(ExitReason::DebuggerEvent);
 }
 
-void Scheduler::reset() {
-  host_thread = co_active();
-  thread = cpu.thread;
-  sync = SynchronizeMode::None;
-  exit_reason = ExitReason::UnknownEvent;
-}
-
-}
+#endif
diff -Nru higan/fc/scheduler/scheduler.hpp higan/fc/scheduler/scheduler.hpp
--- higan/fc/scheduler/scheduler.hpp	2015-09-16 02:20:06.373574580 +0900
+++ higan/fc/scheduler/scheduler.hpp	2015-09-16 13:08:13.522563364 +0900
@@ -1,16 +1,16 @@
-struct Scheduler : property<Scheduler> {
+struct Scheduler {
   enum class SynchronizeMode : unsigned { None, PPU, All } sync;
-  enum class ExitReason : unsigned { UnknownEvent, FrameEvent, SynchronizeEvent };
-  readonly<ExitReason> exit_reason;
+  enum class ExitReason : unsigned { UnknownEvent, FrameEvent, SynchronizeEvent, DebuggerEvent };
 
-  cothread_t host_thread;  //program thread (used to exit emulation)
-  cothread_t thread;       //active emulation thread (used to enter emulation)
+  auto init() -> void;
+  auto enter() -> void;
+  auto exit(ExitReason) -> void;
+  auto debug() -> void;
 
-  void enter();
-  void exit(ExitReason);
+  cothread_t host_thread = nullptr;  //program thread (used to exit emulation)
+  cothread_t thread = nullptr;       //active emulation thread (used to enter emulation)
 
-  void power();
-  void reset();
+  ExitReason exit_reason = ExitReason::UnknownEvent;
 };
 
 extern Scheduler scheduler;
diff -Nru higan/fc/system/input.cpp higan/fc/system/input.cpp
--- higan/fc/system/input.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/fc/system/input.cpp	2015-09-16 13:08:13.521563364 +0900
@@ -0,0 +1,64 @@
+#ifdef SYSTEM_CPP
+
+Input input;
+
+void Input::connect(uint2 port, Device id) {
+  Controller*& controller = (
+    (port == Controller::Port1 ? port1 :
+    (port == Controller::Port2 ? port2 :
+                                expansion))
+  );
+  if(controller) {
+    delete controller;
+    controller = nullptr;
+  }
+
+  switch(id) { default:
+  case Device::None: controller = new Controller(port); break;
+  case Device::Joypad: controller = new Gamepad(port); break;
+  case Device::FourPlayers: controller = new FourPlayers(port); break;
+  case Device::FourScore: controller = new FourScore(port); break;
+  case Device::BeamGun: controller = new BeamGun(port); break;
+  case Device::FamilyTrainer: controller = new FamilyTrainer(port); break;
+  case Device::SFCJoypad: controller = new SFCGamepad(port); break;
+  case Device::Mouse: controller = new Mouse(port); break;
+  case Device::VSPanel: controller = new VSPanel(port); break;
+  }
+
+  switch(port) {
+  case Controller::Port1: configuration.controller_port1 = id; break;
+  case Controller::Port2: configuration.controller_port2 = id; break;
+  case Controller::ExpansionPort: configuration.expansion_port = id; break;
+  }
+
+  /*switch(port) {
+  case Controller::Port1:
+    if(id == Device::FourScore && configuration.controller_port2 != Device::FourScore) {
+      connect(Controller::Port2, Device::FourScore);
+    } else if(id != Device::FourScore && configuration.controller_port2 == Device::FourScore) {
+      connect(Controller::Port2, Device::None);
+    }
+    break;
+  case Controller::Port2:
+    if(id == Device::FourScore && configuration.controller_port1 != Device::FourScore) {
+      connect(Controller::Port1, Device::FourScore);
+    } else if(id != Device::FourScore && configuration.controller_port1 == Device::FourScore) {
+      connect(Controller::Port1, Device::None);
+    }
+    break;
+  }*/
+}
+
+Input::Input() {
+  connect(Controller::Port1, Input::Device::Joypad);
+  connect(Controller::Port2, Input::Device::Joypad);
+  connect(Controller::ExpansionPort, Input::Device::Joypad);
+}
+
+Input::~Input() {
+  if(port1) delete port1;
+  if(port2) delete port2;
+  if(expansion) delete expansion;
+}
+
+#endif
diff -Nru higan/fc/system/input.hpp higan/fc/system/input.hpp
--- higan/fc/system/input.hpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/fc/system/input.hpp	2015-09-16 13:08:13.522563364 +0900
@@ -0,0 +1,38 @@
+struct Input {
+  enum class Device : unsigned {
+    // Licensed devices
+    Joypad,
+    FourPlayers,
+    FourScore,
+    BeamGun,
+    FamilyTrainer,
+
+    // Unlicensed devices
+    SFCJoypad,
+    Mouse,
+
+    // Arcade panels
+    VSPanel,
+
+    None,
+  };
+
+  enum class JoypadID : unsigned {
+    A  =  0, B    =  1, Select =  2, Start =  3,
+    Up =  4, Down =  5, Left   =  6, Right =  7,
+  };
+
+  enum class BeamGunID : unsigned {
+    X = 0, Y = 1, Trigger = 2,
+  };
+
+  Controller* port1 = nullptr;
+  Controller* port2 = nullptr;
+  Controller* expansion = nullptr;
+
+  void connect(uint2 port, Device device);
+  Input();
+  ~Input();
+};
+
+extern Input input;
diff -Nru higan/fc/system/serialization.cpp higan/fc/system/serialization.cpp
--- higan/fc/system/serialization.cpp	2015-09-16 02:20:06.373574580 +0900
+++ higan/fc/system/serialization.cpp	2015-09-16 13:08:13.522563364 +0900
@@ -1,3 +1,5 @@
+#ifdef SYSTEM_CPP
+
 serializer System::serialize() {
   serializer s(serialize_size);
 
@@ -32,18 +34,28 @@
   return true;
 }
 
+//========
+//internal
+//========
+
 void System::serialize(serializer& s) {
+  s.integer((unsigned&)region);
 }
 
 void System::serialize_all(serializer& s) {
-  system.serialize(s);
-  input.serialize(s);
   cartridge.serialize(s);
+  system.serialize(s);
   cpu.serialize(s);
   apu.serialize(s);
   ppu.serialize(s);
+
+  if(revision == Revision::VSSystem) vsarcadeboard.serialize(s);
+  if(revision == Revision::PlayChoice10) pc10arcadeboard.serialize(s);
 }
 
+//perform dry-run state save:
+//determines exactly how many bytes are needed to save state for this cartridge,
+//as amount varies per game (eg different RAM sizes, etc.)
 void System::serialize_init() {
   serializer s;
 
@@ -58,3 +70,5 @@
   serialize_all(s);
   serialize_size = s.size();
 }
+
+#endif
diff -Nru higan/fc/system/system.cpp higan/fc/system/system.cpp
--- higan/fc/system/system.cpp	2015-09-16 02:20:06.373574580 +0900
+++ higan/fc/system/system.cpp	2015-09-16 13:08:13.521563364 +0900
@@ -1,14 +1,23 @@
 #include <fc/fc.hpp>
 
+#define SYSTEM_CPP
 namespace Famicom {
 
-#include "serialization.cpp"
 System system;
+Configuration configuration;
+
+#include "video.cpp"
+#include "input.cpp"
+#include "serialization.cpp"
+
+#include <fc/scheduler/scheduler.cpp>
 
 void System::run() {
+  scheduler.sync = Scheduler::SynchronizeMode::None;
+
   scheduler.enter();
-  if(scheduler.exit_reason() == Scheduler::ExitReason::FrameEvent) {
-    interface->videoRefresh(video.palette, ppu.buffer, 4 * 256, 256, 240);
+  if(scheduler.exit_reason == Scheduler::ExitReason::FrameEvent) {
+    video.update();
   }
 }
 
@@ -34,27 +43,110 @@
 void System::runthreadtosave() {
   while(true) {
     scheduler.enter();
-    if(scheduler.exit_reason() == Scheduler::ExitReason::SynchronizeEvent) break;
-    if(scheduler.exit_reason() == Scheduler::ExitReason::FrameEvent) {
-      interface->videoRefresh(video.palette, ppu.buffer, 4 * 256, 256, 240);
+    if(scheduler.exit_reason == Scheduler::ExitReason::SynchronizeEvent) break;
+    if(scheduler.exit_reason == Scheduler::ExitReason::FrameEvent) {
+      video.update();
     }
   }
 }
 
-void System::load() {
+void System::init() {
+  assert(interface != nullptr);
+
+  vsarcadeboard.init();
+  pc10arcadeboard.init();
+
+  video.init();
+
+  input.connect(0, configuration.controller_port1);
+  input.connect(1, configuration.controller_port2);
+  input.connect(2, configuration.expansion_port);
+}
+
+void System::term() {
+}
+
+void System::load(Revision revision) {
+  this->revision = revision;
   interface->loadRequest(ID::SystemManifest, "manifest.bml", true);
   auto document = BML::unserialize(information.manifest);
 
+  if(pc10()) {
+    auto rom = document["system/pc10"].find("rom");
+
+    auto firmware = rom(0)["name"].text();
+    interface->loadRequest(ID::PC10BIOS, firmware, true);
+    if(!file::exists({interface->path(ID::System), firmware})) {
+      interface->notify("Error: required PlayChoice-10 firmware ", firmware, " not found.\n");
+    }
+
+    auto character = rom(1)["name"].text();
+    interface->loadRequest(ID::PC10CharacterROM, character, true);
+    if(!file::exists({interface->path(ID::System), character})) {
+      interface->notify("Error: required PlayChoice-10 character data ", character, " not found.\n");
+    }
+
+    auto palette = rom(2)["name"].text();
+    interface->loadRequest(ID::PC10PaletteROM, palette, true);
+    if(!file::exists({interface->path(ID::System), palette})) {
+      interface->notify("Error: required PlayChoice-10 palette data ", palette, " not found.\n");
+    }
+  }
+
+  region = configuration.region;
+  if(region == Region::Autodetect) {
+    region = (cartridge.region() == Cartridge::Region::NTSC ? Region::NTSC : Region::PAL);
+  }
+
+  cpu_frequency = region() == Region::NTSC ? 21477272 : 26601712;
+
+  if(!vs()) { // VS. System PPU is set within cartridge.load().
+    auto game_manifest = BML::unserialize(cartridge.information.markup.cartridge);
+    if(!game_manifest["cartridge/pc10"]) {
+      // most Famicoms use a PPU with open bus OAMDATA (read).
+      // For now, we use an NES PPU where OAMDATA (read) is defined.
+      if(region == Region::NTSC) ppu.revision = PPU::Revision::RP2C02G;
+      if(region == Region::PAL)  ppu.revision = PPU::Revision::RP2C07;
+    } else {
+      ppu.revision = PPU::Revision::RP2C03B;
+    }
+  }
+
+  switch(revision) {
+  case Revision::Famicom:
+    break;
+  case Revision::VSSystem:
+    vsarcadeboard.load();
+    input.connect(2, Input::Device::VSPanel);
+    break;
+  case Revision::PlayChoice10:
+    interface->information.height = min(max(document["system/pc10/screen/mode"].integer(), 1), 2) * 240;
+    pc10arcadeboard.load();
+    break;
+  }
+
   serialize_init();
 }
 
+void System::unload() {
+  switch(revision) {
+  case Revision::VSSystem: vsarcadeboard.unload(); break;
+  case Revision::PlayChoice10: pc10arcadeboard.unload(); break;
+  }
+}
+
 void System::power() {
   cartridge.power();
   cpu.power();
   apu.power();
   ppu.power();
-  input.reset();
-  scheduler.power();
+
+  switch(revision) {
+  case Revision::VSSystem: vsarcadeboard.power(); break;
+  case Revision::PlayChoice10: pc10arcadeboard.power(); break;
+  }
+
+  ppu.reset();
   reset();
 }
 
@@ -62,18 +154,31 @@
   cartridge.reset();
   cpu.reset();
   apu.reset();
-  ppu.reset();
-  input.reset();
-  scheduler.reset();
+  // Only the NES front-loader's PPU will reset. The Famicom's and NES
+  // top-loader's PPU will not.
+  //ppu.reset();
+
+  switch(revision) {
+  case Revision::VSSystem: vsarcadeboard.reset(); break;
+  case Revision::PlayChoice10: pc10arcadeboard.reset(); break;
+  }
+
+  scheduler.init();
+  input.connect(0, configuration.controller_port1);
+  input.connect(1, configuration.controller_port2);
+  input.connect(2, configuration.expansion_port);
 }
 
-void System::init() {
-  assert(interface != 0);
-  input.connect(0, Input::Device::Joypad);
-  input.connect(1, Input::Device::None);
+void System::scanline() {
+  video.scanline();
+  if(ppu.vcounter() == 241) scheduler.exit(Scheduler::ExitReason::FrameEvent);
 }
 
-void System::term() {
+void System::frame() {
+}
+
+System::System() {
+  region = Region::Autodetect;
 }
 
 }
diff -Nru higan/fc/system/system.hpp higan/fc/system/system.hpp
--- higan/fc/system/system.hpp	2015-09-16 02:20:06.373574580 +0900
+++ higan/fc/system/system.hpp	2015-09-16 13:08:13.520563364 +0900
@@ -1,26 +1,69 @@
-struct System {
+struct Interface;
+
+struct System : property<System> {
+  enum class Region : unsigned { NTSC = 0, PAL = 1, Autodetect = 2 };
+  enum class Revision : unsigned {
+    Famicom,
+    PlayChoice10,
+    VSSystem,
+  } revision;
+
+  inline bool fc()   const { return revision == Revision::Famicom; }
+  inline bool vs()   const { return revision == Revision::VSSystem; }
+  inline bool pc10() const { return revision == Revision::PlayChoice10; }
+
   void run();
   void runtosave();
-  void runthreadtosave();
 
-  void load();
+  void init();
+  void term();
+  void load(Revision);
+  void unload();
   void power();
   void reset();
 
-  void init();
-  void term();
+  void frame();
+  void scanline();
+
+  //return *active* system information (settings are cached upon power-on)
+  readonly<Region> region;
+  readonly<unsigned> cpu_frequency;
+  readonly<unsigned> serialize_size;
 
   serializer serialize();
   bool unserialize(serializer&);
 
-  void serialize(serializer&);
-  void serialize_all(serializer&);
-  void serialize_init();
-  unsigned serialize_size;
+  System();
 
   struct Information {
     string manifest;
   } information;
+
+private:
+  void runthreadtosave();
+
+  void serialize(serializer&);
+  void serialize_all(serializer&);
+  void serialize_init();
+
+  friend class Cartridge;
+  friend class Video;
+  friend class Input;
 };
 
 extern System system;
+
+#include "video.hpp"
+#include "input.hpp"
+
+#include <fc/scheduler/scheduler.hpp>
+
+struct Configuration {
+  Input::Device controller_port1 = Input::Device::Joypad;
+  Input::Device controller_port2 = Input::Device::Joypad;
+  Input::Device expansion_port = Input::Device::Joypad;
+  System::Region region = System::Region::Autodetect;
+  bool random = true;
+};
+
+extern Configuration configuration;
diff -Nru higan/fc/system/video.cpp higan/fc/system/video.cpp
--- higan/fc/system/video.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/fc/system/video.cpp	2015-09-16 13:08:13.521563364 +0900
@@ -0,0 +1,283 @@
+#ifdef SYSTEM_CPP
+
+Video video;
+
+void Video::generate_palette(Emulator::Interface::PaletteMode mode) {
+  unsigned emphasis;
+  unsigned luma;
+  unsigned chroma;
+  bool rgb;
+  const uint9_t* ppu_pal = nullptr;
+  switch(ppu.revision) {
+  case PPU::Revision::RP2C02C:
+  case PPU::Revision::RP2C02G:
+  case PPU::Revision::RP2C07:
+    rgb = false;
+    break;
+  case PPU::Revision::RP2C03B:
+  case PPU::Revision::RP2C03G:
+  case PPU::Revision::RC2C03B:
+  case PPU::Revision::RC2C03C:
+  case PPU::Revision::RC2C05_01:
+  case PPU::Revision::RC2C05_02:
+  case PPU::Revision::RC2C05_03:
+  case PPU::Revision::RC2C05_04:
+  case PPU::Revision::RC2C05_05:
+    rgb = true;
+    ppu_pal = PPU::RP2C03;
+    break;
+  case PPU::Revision::RP2C04_0001:
+    rgb = true;
+    ppu_pal = PPU::RP2C04_0001;
+    break;
+  case PPU::Revision::RP2C04_0002:
+    rgb = true;
+    ppu_pal = PPU::RP2C04_0002;
+    break;
+  case PPU::Revision::RP2C04_0003:
+    rgb = true;
+    ppu_pal = PPU::RP2C04_0003;
+    break;
+  case PPU::Revision::RP2C04_0004:
+    ppu_pal = PPU::RP2C04_0004;
+    break;
+  }
+  for(unsigned color = 0; color < (1 << 9); color++) {
+    if(mode == Emulator::Interface::PaletteMode::Literal) {
+      palette[color] = color;
+      continue;
+    }
+    if(!rgb) {
+      if(mode == Emulator::Interface::PaletteMode::Standard) {
+        palette[color] = generate_color(color, 2.0, 0.0, 1.0, 1.0, 2.2);
+      } else if(mode == Emulator::Interface::PaletteMode::Channel) {
+        emphasis = image::normalize((color >> 6) &  7, 3, 16);
+        luma     = image::normalize((color >> 4) &  3, 2, 16);
+        chroma   = image::normalize((color >> 0) & 15, 4, 16);
+        palette[color] = interface->videoColor(color, 0, emphasis, luma, chroma);
+      } else if(mode == Emulator::Interface::PaletteMode::Emulation) {
+        palette[color] = generate_color(color, 2.0, 0.0, 1.0, 1.0, 1.8);
+      }
+    } else {
+      unsigned r = (ppu_pal[color & 0x3f] >> 6) & 7;
+      unsigned g = (ppu_pal[color & 0x3f] >> 3) & 7;
+      unsigned b = (ppu_pal[color & 0x3f] >> 0) & 7;
+      if(mode == Emulator::Interface::PaletteMode::Standard) {
+        palette[color] = interface->videoColor(color, 0,
+          image::normalize((color & 0x040) ? 7 : r, 3, 16),
+          image::normalize((color & 0x080) ? 7 : g, 3, 16),
+          image::normalize((color & 0x100) ? 7 : b, 3, 16)
+        );
+      } else if(mode == Emulator::Interface::PaletteMode::Channel) {
+        palette[color] = interface->videoColor(color, 0,
+          image::normalize((color & 0x040) ? 7 : r, 3, 16),
+          image::normalize((color & 0x080) ? 7 : g, 3, 16),
+          image::normalize((color & 0x100) ? 7 : b, 3, 16)
+        );
+      } else if(mode == Emulator::Interface::PaletteMode::Emulation) {
+        r = gamma_ramp[(color & 0x040) ? 7 : r];
+        g = gamma_ramp[(color & 0x080) ? 7 : g];
+        b = gamma_ramp[(color & 0x100) ? 7 : b];
+        //TODO: check how arcade displays alter the signal
+        palette[color] = interface->videoColor(color, 0,
+          image::normalize(r, 8, 16),
+          image::normalize(g, 8, 16),
+          image::normalize(b, 8, 16)
+        );
+      }
+    }
+  }
+  if(system.pc10()) {
+    if(mode == Emulator::Interface::PaletteMode::Standard) {
+      for(unsigned color = 0; color < 256; color++) {
+        palette[(1 << 9) + color] = interface->videoColor((1 << 9) + color, 0,
+          image::normalize(15 - pc10arcadeboard.cgrom[color + 0x000], 4, 16),
+          image::normalize(15 - pc10arcadeboard.cgrom[color + 0x100], 4, 16),
+          image::normalize(15 - pc10arcadeboard.cgrom[color + 0x200], 4, 16)
+        );
+      }
+    } else if(mode == Emulator::Interface::PaletteMode::Channel) {
+      for(unsigned color = 0; color < 256; color++) {
+        palette[(1 << 9) + color] = interface->videoColor((1 << 9) + color,
+          65535, // distinguish from the game screen
+          image::normalize(15 - pc10arcadeboard.cgrom[color + 0x000], 4, 16),
+          image::normalize(15 - pc10arcadeboard.cgrom[color + 0x100], 4, 16),
+          image::normalize(15 - pc10arcadeboard.cgrom[color + 0x200], 4, 16)
+        );
+      }
+    } else if(mode == Emulator::Interface::PaletteMode::Emulation) {
+      for(unsigned color = 0; color < 256; color++) {
+        palette[(1 << 9) + color] = interface->videoColor((1 << 9) + color, 0,
+          image::normalize(15 - pc10arcadeboard.cgrom[color + 0x000], 4, 16),
+          image::normalize(15 - pc10arcadeboard.cgrom[color + 0x100], 4, 16),
+          image::normalize(15 - pc10arcadeboard.cgrom[color + 0x200], 4, 16)
+        );
+      }
+    }
+  }
+}
+
+Video::Video() {
+  // * 2 for second VS. System PPU (of which 256 colors are used for PlayChoice-10)
+  palette = new uint32_t[(1 << 9) * 2]();
+}
+
+Video::~Video() {
+  delete[] palette;
+}
+
+//internal
+
+// for RGB PPUs
+const uint8_t Video::gamma_ramp[8] = {
+  0x00, 0x0a,
+  0x2d, 0x5b,
+  0x98, 0xb8,
+  0xe0, 0xff,
+};
+
+uint32_t Video::generate_color(
+  unsigned n, double saturation, double hue,
+  double contrast, double brightness, double gamma
+) {
+  signed color = (n & 0x0f), level = color < 0xe ? (n >> 4) & 3 : 1;
+
+  static const double black = 0.518, white = 1.962, attenuation = 0.746;
+  static const double levels[8] = {
+    0.350, 0.518, 0.962, 1.550,
+    1.094, 1.506, 1.962, 1.962,
+  };
+
+  double lo_and_hi[2] = {
+    levels[level + 4 * (color == 0x0)],
+    levels[level + 4 * (color <  0xd)],
+  };
+
+  double y = 0.0, i = 0.0, q = 0.0;
+  auto wave = [](signed p, signed color) { return (color + p + 8) % 12 < 6; };
+  for(signed p = 0; p < 12; p++) {
+    double spot = lo_and_hi[wave(p, color)];
+
+    if(((n & 0x040) && wave(p, 12))
+    || ((n & 0x080) && wave(p,  4))
+    || ((n & 0x100) && wave(p,  8))
+    ) spot *= attenuation;
+
+    double v = (spot - black) / (white - black);
+
+    v = (v - 0.5) * contrast + 0.5;
+    v *= brightness / 12.0;
+
+    y += v;
+    i += v * std::cos((3.141592653 / 6.0) * (p + hue));
+    q += v * std::sin((3.141592653 / 6.0) * (p + hue));
+  }
+
+  i *= saturation;
+  q *= saturation;
+
+  auto gammaAdjust = [=](double f) { return f < 0.0 ? 0.0 : std::pow(f, 2.2 / gamma); };
+  unsigned r = 65535.0 * gammaAdjust(y +  0.946882 * i +  0.623557 * q);
+  unsigned g = 65535.0 * gammaAdjust(y + -0.274788 * i + -0.635691 * q);
+  unsigned b = 65535.0 * gammaAdjust(y + -1.108545 * i +  1.709007 * q);
+
+  return interface->videoColor(n, 0, uclamp<16>(r), uclamp<16>(g), uclamp<16>(b));
+}
+
+const uint8_t Video::cursor[15 * 15] = {
+  0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,
+  0,0,0,0,1,1,2,2,2,1,1,0,0,0,0,
+  0,0,0,1,2,2,1,2,1,2,2,1,0,0,0,
+  0,0,1,2,1,1,0,1,0,1,1,2,1,0,0,
+  0,1,2,1,0,0,0,1,0,0,0,1,2,1,0,
+  0,1,2,1,0,0,1,2,1,0,0,1,2,1,0,
+  1,2,1,0,0,1,1,2,1,1,0,0,1,2,1,
+  1,2,2,1,1,2,2,2,2,2,1,1,2,2,1,
+  1,2,1,0,0,1,1,2,1,1,0,0,1,2,1,
+  0,1,2,1,0,0,1,2,1,0,0,1,2,1,0,
+  0,1,2,1,0,0,0,1,0,0,0,1,2,1,0,
+  0,0,1,2,1,1,0,1,0,1,1,2,1,0,0,
+  0,0,0,1,2,2,1,2,1,2,2,1,0,0,0,
+  0,0,0,0,1,1,2,2,2,1,1,0,0,0,0,
+  0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,
+};
+
+void Video::draw_cursor(uint16_t color, int x, int y) {
+  uint32_t* data = (uint32_t*)ppu.output;
+
+  for(int cy = 0; cy < 15; cy++) {
+    int vy = y + cy - 7;
+    if(vy <= 0 || vy >= 240) continue;  //do not draw offscreen
+
+    for(int cx = 0; cx < 15; cx++) {
+      int vx = x + cx - 7;
+      if(vx < 0 || vx >= 256) continue;  //do not draw offscreen
+      uint8_t pixel = cursor[cy * 15 + cx];
+      if(pixel == 0) continue;
+      uint32_t pixelcolor = (pixel == 1) ? 0x0f : color;
+
+      *((uint32_t*)data + vy * 256 + vx) = pixelcolor;
+    }
+  }
+}
+
+void Video::update() {
+  if(configuration.controller_port2 == Input::Device::BeamGun) {
+    BeamGun &device = (BeamGun&)*input.port2;
+    draw_cursor(0x27, device.x, device.y);
+  }
+  if(configuration.expansion_port == Input::Device::BeamGun) {
+    BeamGun &device = (BeamGun&)*input.expansion;
+    draw_cursor(0x2d, device.x, device.y);
+  }
+  if(system.vs()) return update_vs();
+  if(system.pc10()) return update_pc10();
+  interface->videoRefresh(video.palette, ppu.output, 4 * 256, 256, 240);
+}
+
+void Video::update_vs() {
+  if(interface->information.width == 256) {
+    interface->videoRefresh(video.palette, ppu.output, 4 * 256, 256, 240);
+  } else if(interface->information.width == 512) {
+    uint32 buffer[512 * 240];
+    for(unsigned y = 0; y < 240; y++) {
+      for(unsigned x = 0; x < 256; x++) {
+        buffer[y * 512 + x] = ppu.output[y * 256 + x];
+        buffer[y * 512 + x + 256] = 0;
+      }
+    }
+    interface->videoRefresh(video.palette, buffer, 4 * 512, 512, 240);
+  }
+}
+
+void Video::update_pc10() {
+  if(interface->information.height == 240) {
+    switch(pc10arcadeboard.display) {
+    case 0: // Z80
+      interface->videoRefresh(video.palette + (1 << 9), pc10arcadeboard.video_output, 4 * 256, 256, 240);
+      break;
+    case 1: // PPU
+      interface->videoRefresh(video.palette, ppu.output, 4 * 256, 256, 240);
+      break;
+    }
+  } else if(interface->information.height == 480) {
+    uint32 buffer[256 * 480];
+    for(unsigned y = 0; y < 240; y++) {
+      for(unsigned x = 0; x < 256; x++) {
+        buffer[(y + 240) * 256 + x] = ppu.output[y * 256 + x];
+        buffer[(y +   0) * 256 + x] = (1 << 9) + pc10arcadeboard.video_output[y * 256 + x];
+      }
+    }
+    interface->videoRefresh(video.palette, buffer, 4 * 256, 256, 480);
+  }
+}
+
+void Video::scanline() {
+  unsigned y = ppu.vcounter();
+  if(y >= 240) return;
+}
+
+void Video::init() {
+}
+
+#endif
diff -Nru higan/fc/system/video.hpp higan/fc/system/video.hpp
--- higan/fc/system/video.hpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/fc/system/video.hpp	2015-09-16 13:08:13.520563364 +0900
@@ -0,0 +1,22 @@
+struct Video {
+  uint32_t* palette;
+  void generate_palette(Emulator::Interface::PaletteMode mode);
+  Video();
+  ~Video();
+
+private:
+  void update();
+  void update_vs();
+  void update_pc10();
+  void scanline();
+  void init();
+
+  uint32_t generate_color(unsigned, double, double, double, double, double);
+  static const uint8_t gamma_ramp[8];
+  static const uint8_t cursor[15 * 15];
+  void draw_cursor(uint16_t color, int x, int y);
+
+  friend class System;
+};
+
+extern Video video;
diff -Nru higan/fc/video/video.cpp higan/fc/video/video.cpp
--- higan/fc/video/video.cpp	2015-09-16 02:20:06.373574580 +0900
+++ higan/fc/video/video.cpp	1970-01-01 09:00:00.000000000 +0900
@@ -1,85 +0,0 @@
-#include <fc/fc.hpp>
-#include <cmath>
-
-#define VIDEO_CPP
-namespace Famicom {
-
-Video video;
-
-void Video::generate_palette(Emulator::Interface::PaletteMode mode) {
-  for(unsigned color = 0; color < (1 << 9); color++) {
-    if(mode == Emulator::Interface::PaletteMode::Literal) {
-      palette[color] = color;
-    } else if(mode == Emulator::Interface::PaletteMode::Channel) {
-      unsigned emphasis = (color >> 6) &  7;
-      unsigned luma     = (color >> 4) &  3;
-      unsigned chroma   = (color >> 0) & 15;
-      emphasis = image::normalize(emphasis, 3, 16);
-      luma     = image::normalize(luma,     2, 16);
-      chroma   = image::normalize(chroma,   4, 16);
-      palette[color] = interface->videoColor(color, 0, emphasis, luma, chroma);
-    } else if(mode == Emulator::Interface::PaletteMode::Standard) {
-      palette[color] = generate_color(color, 2.0, 0.0, 1.0, 1.0, 2.2);
-    } else if(mode == Emulator::Interface::PaletteMode::Emulation) {
-      palette[color] = generate_color(color, 2.0, 0.0, 1.0, 1.0, 1.8);
-    }
-  }
-}
-
-Video::Video() {
-  palette = new uint32_t[1 << 9]();
-}
-
-Video::~Video() {
-  delete[] palette;
-}
-
-uint32_t Video::generate_color(
-  unsigned n, double saturation, double hue,
-  double contrast, double brightness, double gamma
-) {
-  signed color = (n & 0x0f), level = color < 0xe ? (n >> 4) & 3 : 1;
-
-  static const double black = 0.518, white = 1.962, attenuation = 0.746;
-  static const double levels[8] = {
-    0.350, 0.518, 0.962, 1.550,
-    1.094, 1.506, 1.962, 1.962,
-  };
-
-  double lo_and_hi[2] = {
-    levels[level + 4 * (color == 0x0)],
-    levels[level + 4 * (color <  0xd)],
-  };
-
-  double y = 0.0, i = 0.0, q = 0.0;
-  auto wave = [](signed p, signed color) { return (color + p + 8) % 12 < 6; };
-  for(signed p = 0; p < 12; p++) {
-    double spot = lo_and_hi[wave(p, color)];
-
-    if(((n & 0x040) && wave(p, 12))
-    || ((n & 0x080) && wave(p,  4))
-    || ((n & 0x100) && wave(p,  8))
-    ) spot *= attenuation;
-
-    double v = (spot - black) / (white - black);
-
-    v = (v - 0.5) * contrast + 0.5;
-    v *= brightness / 12.0;
-
-    y += v;
-    i += v * std::cos((3.141592653 / 6.0) * (p + hue));
-    q += v * std::sin((3.141592653 / 6.0) * (p + hue));
-  }
-
-  i *= saturation;
-  q *= saturation;
-
-  auto gammaAdjust = [=](double f) { return f < 0.0 ? 0.0 : std::pow(f, 2.2 / gamma); };
-  unsigned r = 65535.0 * gammaAdjust(y +  0.946882 * i +  0.623557 * q);
-  unsigned g = 65535.0 * gammaAdjust(y + -0.274788 * i + -0.635691 * q);
-  unsigned b = 65535.0 * gammaAdjust(y + -1.108545 * i +  1.709007 * q);
-
-  return interface->videoColor(n, 0, uclamp<16>(r), uclamp<16>(g), uclamp<16>(b));
-}
-
-}
diff -Nru higan/fc/video/video.hpp higan/fc/video/video.hpp
--- higan/fc/video/video.hpp	2015-09-16 02:20:06.373574580 +0900
+++ higan/fc/video/video.hpp	1970-01-01 09:00:00.000000000 +0900
@@ -1,12 +0,0 @@
-struct Video {
-  uint32_t* palette = nullptr;
-  void generate_palette(Emulator::Interface::PaletteMode mode);
-
-  Video();
-  ~Video();
-
-private:
-  uint32_t generate_color(unsigned, double, double, double, double, double);
-};
-
-extern Video video;
diff -Nru higan/gba/interface/interface.cpp higan/gba/interface/interface.cpp
--- higan/gba/interface/interface.cpp	2015-09-16 02:20:06.377574581 +0900
+++ higan/gba/interface/interface.cpp	2015-09-16 13:08:13.511563363 +0900
@@ -120,6 +120,21 @@
   video.generate_palette(mode);
 }
 
+void Interface::exportMemory() {
+  string pathname = {path(group(ID::ROM)), "debug/"};
+  directory::create(pathname);
+
+  file::write({pathname, "i-work.ram"}, cpu.iwram, 32 * 1024);
+  //file::write({pathname, "e-work.ram"}, cpu.ewram, 256 * 1024);
+  file::write({pathname, "video.ram"}, ppu.vram, 96 * 1024);
+  uint8 pal_data[1024];
+  for(unsigned color_id = 0; color_id < 512; color_id++) {
+    pal_data[(color_id << 1) + 0] = (ppu.pram[color_id] >> 0) & 0xFF;
+    pal_data[(color_id << 1) + 1] = (ppu.pram[color_id] >> 8) & 0x7F;
+  }
+  file::write({pathname, "palette.ram"}, pal_data, 1024);
+}
+
 Interface::Interface() {
   interface = this;
 
diff -Nru higan/gba/interface/interface.hpp higan/gba/interface/interface.hpp
--- higan/gba/interface/interface.hpp	2015-09-16 02:20:06.377574581 +0900
+++ higan/gba/interface/interface.hpp	2015-09-16 13:08:13.511563363 +0900
@@ -46,6 +46,8 @@
 
   void paletteUpdate(PaletteMode mode);
 
+  void exportMemory();
+
   Interface();
 
 private:
diff -Nru higan/gba/system/bios.cpp higan/gba/system/bios.cpp
--- higan/gba/system/bios.cpp	2015-09-16 02:20:06.378574581 +0900
+++ higan/gba/system/bios.cpp	2015-09-16 13:08:13.505563363 +0900
@@ -10,7 +10,9 @@
 auto BIOS::read(unsigned mode, uint32 addr) -> uint32 {
   //GBA BIOS is read-protected; only the BIOS itself can read its own memory
   //when accessed elsewhere; this returns the last value read by the BIOS program
-  if(cpu.r(15) >= 0x02000000) return mdr;
+  if(cpu.r(15) >= 0x02000000) {
+    return cpu.pipeline.fetch.instruction;
+  }
 
   if(mode & Word) return mdr = read(Half, addr &~ 2) << 0 | read(Half, addr | 2) << 16;
   if(mode & Half) return mdr = read(Byte, addr &~ 1) << 0 | read(Byte, addr | 1) <<  8;
diff -Nru higan/hiro/components.hpp higan/hiro/components.hpp
--- higan/hiro/components.hpp	2015-09-16 02:20:06.380574581 +0900
+++ higan/hiro/components.hpp	2015-09-16 13:08:13.456563358 +0900
@@ -9,15 +9,17 @@
  * As such, this file is really only meant for disabling individual widgets or menu items.
  */
 
-#define Hiro_Application
-
 #define Hiro_Color
+#define Hiro_Gradient
 #define Hiro_Alignment
+#define Hiro_Cursor
 #define Hiro_Position
 #define Hiro_Size
 #define Hiro_Geometry
-
 #define Hiro_Font
+#define Hiro_Image
+
+#define Hiro_Application
 #define Hiro_Desktop
 #define Hiro_Monitor
 #define Hiro_Keyboard
@@ -63,7 +65,7 @@
 #define Hiro_ProgressBar
 #define Hiro_RadioButton
 #define Hiro_RadioLabel
-#define Hiro_SourceView
+#define Hiro_SourceEdit
 #define Hiro_TabFrame
 #define Hiro_TextEdit
 #define Hiro_TreeView
@@ -86,6 +88,6 @@
 #if defined(HIRO_WINDOWS) || defined(HIRO_QT)
   #undef Hiro_Console
   #undef Hiro_IconView
-  #undef Hiro_SourceView
+  #undef Hiro_SourceEdit
   #undef Hiro_TreeView
 #endif
diff -Nru higan/hiro/core/action/menu.cpp higan/hiro/core/action/menu.cpp
--- higan/hiro/core/action/menu.cpp	2015-09-16 02:20:06.381574581 +0900
+++ higan/hiro/core/action/menu.cpp	2015-09-16 13:08:13.458563358 +0900
@@ -33,8 +33,8 @@
   return *this;
 }
 
-auto mMenu::icon() const -> image {
-  return state.icon;
+auto mMenu::image() const -> Image {
+  return state.image;
 }
 
 auto mMenu::remove(sAction action) -> type& {
@@ -51,9 +51,16 @@
   return *this;
 }
 
-auto mMenu::setIcon(const image& icon) -> type& {
-  state.icon = icon;
-  signal(setIcon, icon);
+auto mMenu::setImage(const Image& image) -> type& {
+  state.image = image;
+  signal(setImage, image);
+  return *this;
+}
+
+auto mMenu::setParent(mObject* parent, signed offset) -> type& {
+  for(auto n : rrange(state.actions)) state.actions[n]->destruct();
+  mObject::setParent(parent, offset);
+  for(auto& action : state.actions) action->setParent(this, action->offset());
   return *this;
 }
 
diff -Nru higan/hiro/core/action/menu-item.cpp higan/hiro/core/action/menu-item.cpp
--- higan/hiro/core/action/menu-item.cpp	2015-09-16 02:20:06.381574581 +0900
+++ higan/hiro/core/action/menu-item.cpp	2015-09-16 13:08:13.458563358 +0900
@@ -10,8 +10,8 @@
   if(state.onActivate) return state.onActivate();
 }
 
-auto mMenuItem::icon() const -> image {
-  return state.icon;
+auto mMenuItem::image() const -> Image {
+  return state.image;
 }
 
 auto mMenuItem::onActivate(const function<void ()>& callback) -> type& {
@@ -19,9 +19,9 @@
   return *this;
 }
 
-auto mMenuItem::setIcon(const image& icon) -> type& {
-  state.icon = icon;
-  signal(setIcon, icon);
+auto mMenuItem::setImage(const Image& image) -> type& {
+  state.image = image;
+  signal(setImage, image);
   return *this;
 }
 
diff -Nru higan/hiro/core/action/menu-radio-item.cpp higan/hiro/core/action/menu-radio-item.cpp
--- higan/hiro/core/action/menu-radio-item.cpp	2015-09-16 02:20:06.381574581 +0900
+++ higan/hiro/core/action/menu-radio-item.cpp	2015-09-16 13:08:13.457563358 +0900
@@ -39,9 +39,8 @@
 }
 
 auto mMenuRadioItem::setGroup(sGroup group) -> type& {
-  state.group = group;
+  state.group = group ? group : Group{&instance};
   signal(setGroup, group);
-  if(group && group->objectCount() == 1) setChecked();
   return *this;
 }
 
diff -Nru higan/hiro/core/alignment.cpp higan/hiro/core/alignment.cpp
--- higan/hiro/core/alignment.cpp	2015-09-16 02:20:06.381574581 +0900
+++ higan/hiro/core/alignment.cpp	2015-09-16 13:08:13.458563358 +0900
@@ -17,6 +17,10 @@
   return state.horizontal;
 }
 
+auto Alignment::reset() -> type& {
+  return setAlignment(-1.0, -1.0);
+}
+
 auto Alignment::setAlignment(double horizontal, double vertical) -> type& {
   state.horizontal = horizontal;
   state.vertical   = vertical;
diff -Nru higan/hiro/core/application.cpp higan/hiro/core/application.cpp
--- higan/hiro/core/application.cpp	2015-09-16 02:20:06.381574581 +0900
+++ higan/hiro/core/application.cpp	2015-09-16 13:08:13.472563359 +0900
@@ -6,7 +6,7 @@
   if(state.onMain) return state.onMain();
 }
 
-auto Application::font() -> string {
+auto Application::font() -> Font {
   return state.font;
 }
 
@@ -35,7 +35,7 @@
   return pApplication::quit();
 }
 
-auto Application::setFont(const string& font) -> void {
+auto Application::setFont(const Font& font) -> void {
   state.font = font;
 }
 
diff -Nru higan/hiro/core/color.cpp higan/hiro/core/color.cpp
--- higan/hiro/core/color.cpp	2015-09-16 02:20:06.381574581 +0900
+++ higan/hiro/core/color.cpp	2015-09-16 13:08:13.474563360 +0900
@@ -9,7 +9,7 @@
 }
 
 Color::operator bool() const {
-  return !empty();
+  return state.red || state.green || state.blue || state.alpha;
 }
 
 auto Color::operator==(const Color& source) const -> bool {
@@ -28,10 +28,6 @@
   return state.blue;
 }
 
-auto Color::empty() const -> bool {
-  return state.red == 0 && state.green == 0 && state.blue == 0 && state.alpha == 0;
-}
-
 auto Color::green() const -> uint8_t {
   return state.green;
 }
@@ -40,6 +36,10 @@
   return state.red;
 }
 
+auto Color::reset() -> type& {
+  return setColor(0, 0, 0, 0);
+}
+
 auto Color::setAlpha(signed alpha) -> type& {
   state.alpha = max(0, min(255, alpha));
   return *this;
@@ -73,7 +73,7 @@
 }
 
 auto Color::value() const -> uint32_t {
-  return (state.alpha << 24) + (state.red << 16) + (state.green << 8) + (state.blue << 0);
+  return state.alpha << 24 | state.red << 16 | state.green << 8 | state.blue << 0;
 }
 
 #endif
diff -Nru higan/hiro/core/core.cpp higan/hiro/core/core.cpp
--- higan/hiro/core/core.cpp	2015-09-16 02:20:06.381574581 +0900
+++ higan/hiro/core/core.cpp	2015-09-16 13:08:13.473563359 +0900
@@ -31,13 +31,17 @@
   (delegate ? self()->function(__VA_ARGS__) : decltype(self()->function(__VA_ARGS__))())
 
 namespace hiro {
-  #include "application.cpp"
   #include "color.cpp"
+  #include "gradient.cpp"
   #include "alignment.cpp"
+  #include "cursor.cpp"
   #include "position.cpp"
   #include "size.cpp"
   #include "geometry.cpp"
   #include "font.cpp"
+  #include "image.cpp"
+
+  #include "application.cpp"
   #include "desktop.cpp"
   #include "monitor.cpp"
   #include "keyboard.cpp"
diff -Nru higan/hiro/core/core.hpp higan/hiro/core/core.hpp
--- higan/hiro/core/core.hpp	2015-09-16 02:20:06.381574581 +0900
+++ higan/hiro/core/core.hpp	2015-09-16 13:08:13.471563359 +0900
@@ -13,7 +13,6 @@
 #include <nall/vector.hpp>
 
 using nall::function;
-using nall::image;
 using nall::lstring;
 using nall::maybe;
 using nall::shared_pointer;
@@ -23,6 +22,9 @@
 
 namespace hiro {
 
+struct Font;
+struct Keyboard;
+
 #define Declare(Name) \
   struct Name; \
   struct m##Name; \
@@ -30,11 +32,9 @@
   using s##Name = shared_pointer<m##Name>; \
   using w##Name = shared_pointer_weak<m##Name>; \
 
-Declare(Keyboard)
 Declare(Object)
 Declare(Group)
 Declare(Timer)
-Declare(Hotkey)
 Declare(Window)
 Declare(StatusBar)
 Declare(MenuBar)
@@ -83,64 +83,8 @@
 
 #undef Declare
 
-enum class Edge : unsigned { Top, Bottom, Left, Right };
-
 enum class Orientation : unsigned { Horizontal, Vertical };
-enum class Placement : unsigned { Top, Bottom, Left, Right };
-
-#if defined(Hiro_Application)
-struct Application {
-  Application() = delete;
-
-  static auto doMain() -> void;
-  static auto font() -> string;
-  static auto name() -> string;
-  static auto onMain(const function<void ()>& callback = {}) -> void;
-  static auto run() -> void;
-  static auto pendingEvents() -> bool;
-  static auto processEvents() -> void;
-  static auto quit() -> void;
-  static auto setFont(const string& font = "") -> void;
-  static auto setName(const string& name = "") -> void;
-
-  struct Windows {
-    static auto doModalChange(bool modal) -> void;
-    static auto onModalChange(const function<void (bool)>& callback = {}) -> void;
-  };
-
-  struct Cocoa {
-    static auto doAbout() -> void;
-    static auto doActivate() -> void;
-    static auto doPreferences() -> void;
-    static auto doQuit() -> void;
-    static auto onAbout(const function<void ()>& callback = {}) -> void;
-    static auto onActivate(const function<void ()>& callback = {}) -> void;
-    static auto onPreferences(const function<void ()>& callback = {}) -> void;
-    static auto onQuit(const function<void ()>& callback = {}) -> void;
-  };
-
-//private:
-  struct State {
-    string font;
-    string name;
-    function<void ()> onMain;
-    bool quit = false;
-
-    struct Windows {
-      function<void (bool)> onModalChange;
-    } windows;
-
-    struct Cocoa {
-      function<void ()> onAbout;
-      function<void ()> onActivate;
-      function<void ()> onPreferences;
-      function<void ()> onQuit;
-    } cocoa;
-  };
-  static State state;
-  static auto initialize() -> void;
-};
-#endif
+enum class Navigation : unsigned { Top, Bottom, Left, Right };
 
 #if defined(Hiro_Color)
 struct Color {
@@ -155,9 +99,9 @@
 
   auto alpha() const -> uint8_t;
   auto blue() const -> uint8_t;
-  auto empty() const -> bool;
   auto green() const -> uint8_t;
   auto red() const -> uint8_t;
+  auto reset() -> type&;
   auto setAlpha(signed alpha) -> type&;
   auto setBlue(signed blue) -> type&;
   auto setColor(Color color = {}) -> type&;
@@ -168,10 +112,31 @@
 
 //private:
   struct State {
-    signed red;
-    signed green;
-    signed blue;
-    signed alpha;
+    uint8_t red;
+    uint8_t green;
+    uint8_t blue;
+    uint8_t alpha;
+  } state;
+};
+#endif
+
+#if defined(Hiro_Gradient)
+struct Gradient {
+  using type = Gradient;
+
+  Gradient();
+
+  explicit operator bool() const;
+  auto operator==(const Gradient& source) const -> bool;
+  auto operator!=(const Gradient& source) const -> bool;
+
+  auto setBilinear(Color topLeft, Color topRight, Color bottomLeft, Color bottomRight) -> type&;
+  auto setHorizontal(Color left, Color right) -> type&;
+  auto setVertical(Color top, Color bottom) -> type&;
+
+//private:
+  struct State {
+    vector<Color> colors;
   } state;
 };
 #endif
@@ -188,6 +153,7 @@
   auto operator!=(const Alignment& source) const -> bool;
 
   auto horizontal() const -> double;
+  auto reset() -> type&;
   auto setAlignment(double horizontal = -1.0, double vertical = 0.5) -> type&;
   auto setHorizontal(double horizontal) -> type&;
   auto setVertical(double vertical) -> type&;
@@ -195,8 +161,32 @@
 
 //private:
   struct State {
-    double horizontal;
-    double vertical;
+    float horizontal;
+    float vertical;
+  } state;
+};
+#endif
+
+#if defined(Hiro_Cursor)
+struct Cursor {
+  using type = Cursor;
+
+  Cursor(signed offset = 0, signed length = 0);
+
+  explicit operator bool() const;
+  auto operator==(const Cursor& source) const -> bool;
+  auto operator!=(const Cursor& source) const -> bool;
+
+  auto length() const -> signed;
+  auto offset() const -> signed;
+  auto setCursor(signed offset = 0, signed length = 0) -> type&;
+  auto setLength(signed length = 0) -> type&;
+  auto setOffset(signed offset = 0) -> type&;
+
+//private:
+  struct State {
+    signed offset;
+    signed length;
   } state;
 };
 #endif
@@ -208,9 +198,11 @@
   Position();
   Position(signed x, signed y);
 
+  explicit operator bool() const;
   auto operator==(const Position& source) const -> bool;
   auto operator!=(const Position& source) const -> bool;
 
+  auto reset() -> type&;
   auto setPosition(Position position = {}) -> type&;
   auto setPosition(signed x, signed y) -> type&;
   auto setX(signed x) -> type&;
@@ -233,10 +225,12 @@
   Size();
   Size(signed width, signed height);
 
+  explicit operator bool() const;
   auto operator==(const Size& source) const -> bool;
   auto operator!=(const Size& source) const -> bool;
 
   auto height() const -> signed;
+  auto reset() -> type&;
   auto setHeight(signed height) -> type&;
   auto setSize(Size source = {}) -> type&;
   auto setSize(signed width, signed height) -> type&;
@@ -263,11 +257,13 @@
   Geometry(signed x, signed y, signed width, signed height);
   Geometry(const string& text);
 
+  explicit operator bool() const;
   auto operator==(const Geometry& source) const -> bool;
   auto operator!=(const Geometry& source) const -> bool;
 
   auto height() const -> signed;
   auto position() const -> Position;
+  auto reset() -> type&;
   auto setGeometry(Geometry geometry = {}) -> type&;
   auto setGeometry(Position position, Size size) -> type&;
   auto setGeometry(signed x, signed y, signed width, signed height) -> type&;
@@ -299,8 +295,7 @@
 struct Font {
   using type = Font;
 
-  Font();
-  Font(const string& family, unsigned size = 0);
+  Font(const string& family = "", unsigned size = 0);
 
   explicit operator bool() const;
   auto operator==(const Font& source) const -> bool;
@@ -309,27 +304,139 @@
   auto bold() const -> bool;
   auto family() const -> string;
   auto italic() const -> bool;
+  auto reset() -> type&;
   auto setBold(bool bold = true) -> type&;
   auto setFamily(const string& family = "") -> type&;
   auto setItalic(bool italic = true) -> type&;
   auto setSize(unsigned size = 0) -> type&;
   auto size() const -> unsigned;
-
-  static auto serif(unsigned size = 0, const string& style = "") -> string;
-  static auto sans(unsigned size = 0, const string& style = "") -> string;
-  static auto monospace(unsigned size = 0, const string& style = "") -> string;
-  static auto size(const string& font, const string& text = " ") -> Size;
+  auto size(const string& text) const -> Size;
 
 //private:
   struct State {
     string family;
-    unsigned size = 0;
-    bool bold = false;
-    bool italic = false;
+    unsigned size;
+    bool bold;
+    bool italic;
+  } state;
+};
+#endif
+
+#if defined(Hiro_Image)
+struct Image {
+  using type = Image;
+
+  Image();
+  Image(const Image& source);
+  Image(const string& source);
+  Image(const vector<uint8_t>& source);
+  Image(const uint32_t* data, Size size);
+  ~Image();
+
+  explicit operator bool() const;
+  auto operator=(const Image& source) -> type&;
+
+  auto data() const -> uint32_t*;
+  auto height() const -> signed;
+  auto reset() -> type&;
+  auto setImage(const uint32_t* data, Size size) -> type&;
+  auto setSize(Size size = {}) -> type&;
+  auto size() const -> Size;
+  auto width() const -> signed;
+
+//private:
+  struct State {
+    uint32_t* data = nullptr;
+    Size size;
   } state;
 };
 #endif
 
+#if defined(Hiro_Hotkey)
+struct Hotkey {
+  using type = Hotkey;
+
+  Hotkey();
+  Hotkey(const string& sequence);
+
+  explicit operator bool() const;
+  auto operator==(const Hotkey& source) const -> bool;
+  auto operator!=(const Hotkey& source) const -> bool;
+
+  auto doPress() const -> void;
+  auto doRelease() const -> void;
+  auto onPress(const function<void ()>& callback = {}) -> type&;
+  auto onRelease(const function<void ()>& callback = {}) -> type&;
+  auto reset() -> type&;
+  auto sequence() const -> string;
+  auto setSequence(const string& sequence = "") -> type&;
+
+//private:
+  struct State {
+    bool active = false;
+    vector<unsigned> keys;
+    function<void ()> onPress;
+    function<void ()> onRelease;
+    string sequence;
+  };
+  shared_pointer<State> state;
+};
+#endif
+
+#if defined(Hiro_Application)
+struct Application {
+  Application() = delete;
+
+  static auto doMain() -> void;
+  static auto font() -> Font;
+  static auto name() -> string;
+  static auto onMain(const function<void ()>& callback = {}) -> void;
+  static auto run() -> void;
+  static auto pendingEvents() -> bool;
+  static auto processEvents() -> void;
+  static auto quit() -> void;
+  static auto setFont(const Font& font = {}) -> void;
+  static auto setName(const string& name = "") -> void;
+
+  struct Windows {
+    static auto doModalChange(bool modal) -> void;
+    static auto onModalChange(const function<void (bool)>& callback = {}) -> void;
+  };
+
+  struct Cocoa {
+    static auto doAbout() -> void;
+    static auto doActivate() -> void;
+    static auto doPreferences() -> void;
+    static auto doQuit() -> void;
+    static auto onAbout(const function<void ()>& callback = {}) -> void;
+    static auto onActivate(const function<void ()>& callback = {}) -> void;
+    static auto onPreferences(const function<void ()>& callback = {}) -> void;
+    static auto onQuit(const function<void ()>& callback = {}) -> void;
+  };
+
+//private:
+  struct State {
+    Font font;
+    string name;
+    function<void ()> onMain;
+    bool quit = false;
+
+    struct Windows {
+      function<void (bool)> onModalChange;
+    } windows;
+
+    struct Cocoa {
+      function<void ()> onAbout;
+      function<void ()> onActivate;
+      function<void ()> onPreferences;
+      function<void ()> onQuit;
+    } cocoa;
+  };
+  static State state;
+  static auto initialize() -> void;
+};
+#endif
+
 #if defined(Hiro_Desktop)
 struct Desktop {
   Desktop() = delete;
@@ -353,19 +460,20 @@
 struct Keyboard {
   Keyboard() = delete;
 
-  static auto append(sHotkey hotkey) -> void;
+  static auto append(Hotkey hotkey) -> void;
   static auto hotkey(unsigned position) -> Hotkey;
-  static auto hotkeys() -> unsigned;
+  static auto hotkeyCount() -> unsigned;
+  static auto hotkeys() -> vector<Hotkey>;
   static auto poll() -> vector<bool>;
   static auto pressed(const string& key) -> bool;
   static auto released(const string& key) -> bool;
-  static auto remove(sHotkey hotkey) -> void;
+  static auto remove(Hotkey hotkey) -> void;
 
   static const vector<string> keys;
 
 //private:
   struct State {
-    vector<sHotkey> hotkeys;
+    vector<Hotkey> hotkeys;
   };
   static State state;
 };
@@ -439,6 +547,7 @@
   auto self() const -> const p##Name* { return (const p##Name*)delegate; } \
   auto bind(const s##Name& instance) -> void { \
     this->instance = instance; \
+    setGroup(); \
     if(!abstract()) construct(); \
   } \
   auto unbind() -> void { \
@@ -463,7 +572,7 @@
   auto adjustOffset(signed displacement) -> type&;
   auto enabled(bool recursive = false) const -> bool;
   virtual auto focused() const -> bool;
-  auto font(bool recursive = false) const -> string;
+  auto font(bool recursive = false) const -> Font;
   virtual auto group() const -> Group;
   auto offset() const -> signed;
   auto parent() const -> mObject*;
@@ -488,7 +597,7 @@
   virtual auto reset() -> type&;
   virtual auto setEnabled(bool enabled = true) -> type&;
   virtual auto setFocused() -> type&;
-  virtual auto setFont(const string& font = "") -> type&;
+  virtual auto setFont(const Font& font = {}) -> type&;
   virtual auto setGroup(sGroup group = {}) -> type&;
   virtual auto setParent(mObject* parent = nullptr, signed offset = -1) -> type&;
   virtual auto setVisible(bool visible = true) -> type&;
@@ -497,7 +606,7 @@
 //private:
   struct State {
     bool enabled = true;
-    string font;
+    Font font;
     signed offset = -1;
     mObject* parent = nullptr;
     bool visible = true;
@@ -529,32 +638,6 @@
 };
 #endif
 
-#if defined(Hiro_Hotkey)
-struct mHotkey : mObject {
-  Declare(Hotkey)
-
-  auto doPress() const -> void;
-  auto doRelease() const -> void;
-  auto onPress(const function<void ()>& callback = {}) -> type&;
-  auto onRelease(const function<void ()>& callback = {}) -> type&;
-  auto owner() const -> wObject;
-  auto remove() -> type& override;
-  auto sequence() const -> string;
-  auto setOwner(sObject owner) -> type&;
-  auto setSequence(const string& sequence = "") -> type&;
-
-//private:
-  struct State {
-    bool active = false;
-    vector<unsigned> keys;
-    function<void ()> onPress;
-    function<void ()> onRelease;
-    wObject owner;
-    string sequence;
-  } state;
-};
-#endif
-
 #if defined(Hiro_Timer)
 struct mTimer : mObject {
   Declare(Timer)
@@ -672,7 +755,7 @@
   auto remove() -> type& override;
   auto remove(sMenu menu) -> type&;
   auto reset() -> type&;
-//TODO setParent
+  auto setParent(mObject* parent = nullptr, signed offset = -1) -> type& override;
 
 //private:
   struct State {
@@ -727,18 +810,18 @@
   auto actionCount() const -> unsigned;
   auto actions() const -> vector<Action>;
   auto append(sAction action) -> type&;
-  auto icon() const -> image;
+  auto image() const -> Image;
   auto remove(sAction action) -> type&;
   auto reset() -> type&;
-  auto setIcon(const image& icon = {}) -> type&;
-//TODO setParent
+  auto setImage(const Image& image = {}) -> type&;
+  auto setParent(mObject* parent = nullptr, signed offset = -1) -> type& override;
   auto setText(const string& text = "") -> type&;
   auto text() const -> string;
 
 //private:
   struct State {
     vector<sAction> actions;
-    image icon;
+    Image image;
     string text;
   } state;
 
@@ -761,15 +844,15 @@
   Declare(MenuItem)
 
   auto doActivate() const -> void;
-  auto icon() const -> image;
+  auto image() const -> Image;
   auto onActivate(const function<void ()>& callback = {}) -> type&;
-  auto setIcon(const image& icon = {}) -> type&;
+  auto setImage(const Image& image = {}) -> type&;
   auto setText(const string& text = "") -> type&;
   auto text() const -> string;
 
 //private:
   struct State {
-    image icon;
+    Image image;
     function<void ()> onActivate;
     string text;
   } state;
@@ -877,11 +960,11 @@
 
   auto bordered() const -> bool;
   auto doActivate() const -> void;
-  auto icon() const -> image;
+  auto image() const -> Image;
   auto onActivate(const function<void ()>& callback = {}) -> type&;
   auto orientation() const -> Orientation;
   auto setBordered(bool bordered = true) -> type&;
-  auto setIcon(const image& icon = {}) -> type&;
+  auto setImage(const Image& image = {}) -> type&;
   auto setOrientation(Orientation orientation = Orientation::Horizontal) -> type&;
   auto setText(const string& text = "") -> type&;
   auto text() const -> string;
@@ -889,7 +972,7 @@
 //private:
   struct State {
     bool bordered = true;
-    image icon;
+    Image image;
     function<void ()> onActivate;
     Orientation orientation = Orientation::Horizontal;
     string text;
@@ -909,36 +992,32 @@
   auto doMouseMove(Position position) const -> void;
   auto doMousePress(Mouse::Button button) const -> void;
   auto doMouseRelease(Mouse::Button button) const -> void;
-  auto gradient() const -> vector<Color>;
-  auto icon() const -> image;
+  auto gradient() const -> Gradient;
+  auto image() const -> Image;
   auto onDrop(const function<void (lstring)>& callback = {}) -> type&;
   auto onMouseLeave(const function<void ()>& callback = {}) -> type&;
   auto onMouseMove(const function<void (Position)>& callback = {}) -> type&;
   auto onMousePress(const function<void (Mouse::Button)>& callback = {}) -> type&;
   auto onMouseRelease(const function<void (Mouse::Button)>& callback = {}) -> type&;
-  auto setColor(Color color) -> type&;
-  auto setData(Size size) -> type&;
+  auto setColor(Color color = {}) -> type&;
   auto setDroppable(bool droppable = true) -> type&;
-  auto setGradient(Color topLeft, Color topRight, Color bottomLeft, Color bottomRight) -> type&;
-  auto setHorizontalGradient(Color left, Color right) -> type&;
-  auto setIcon(const image& icon = {}) -> type&;
-  auto setVerticalGradient(Color top, Color bottom) -> type&;
+  auto setGradient(Gradient gradient = {}) -> type&;
+  auto setImage(const Image& image = {}) -> type&;
+  auto setSize(Size size = {}) -> type&;
   auto size() const -> Size;
   auto update() -> type&;
 
 //private:
   struct State {
     Color color;
-    vector<uint32_t> data;
     bool droppable = false;
-    vector<Color> gradient = {{}, {}, {}, {}};
-    image icon;
+    Gradient gradient;
+    Image image;
     function<void (lstring)> onDrop;
     function<void ()> onMouseLeave;
     function<void (Position)> onMouseMove;
     function<void (Mouse::Button)> onMousePress;
     function<void (Mouse::Button)> onMouseRelease;
-    Size size;
   } state;
 };
 #endif
@@ -950,12 +1029,12 @@
   auto bordered() const -> bool;
   auto checked() const -> bool;
   auto doToggle() const -> void;
-  auto icon() const -> image;
+  auto image() const -> Image;
   auto onToggle(const function<void ()>& callback = {}) -> type&;
   auto orientation() const -> Orientation;
   auto setBordered(bool bordered = true) -> type&;
   auto setChecked(bool checked = true) -> type&;
-  auto setIcon(const image& icon = {}) -> type&;
+  auto setImage(const Image& image = {}) -> type&;
   auto setOrientation(Orientation orientation = Orientation::Horizontal) -> type&;
   auto setText(const string& text = "") -> type&;
   auto text() const -> string;
@@ -964,7 +1043,7 @@
   struct State {
     bool bordered = true;
     bool checked = false;
-    image icon;
+    Image image;
     function<void ()> onToggle;
     Orientation orientation = Orientation::Horizontal;
     string text;
@@ -1022,17 +1101,17 @@
 struct mComboButtonItem : mObject {
   Declare(ComboButtonItem)
 
-  auto icon() const -> image;
+  auto image() const -> Image;
   auto remove() -> type& override;
   auto selected() const -> bool;
-  auto setIcon(const image& icon = {}) -> type&;
+  auto setImage(const Image& image = {}) -> type&;
   auto setSelected() -> type&;
   auto setText(const string& text = "") -> type&;
   auto text() const -> string;
 
 //private:
   struct State {
-    image icon;
+    Image image;
     bool selected = false;
     string text;
   } state;
@@ -1073,7 +1152,7 @@
   auto layout() const -> Layout;
   auto remove(sLayout layout) -> type&;
   auto reset() -> type&;
-//TODO setParent()
+  auto setParent(mObject* parent = nullptr, signed offset = -1) -> type& override;
   auto setText(const string& text = "") -> type&;
   auto text() const -> string;
 
@@ -1170,6 +1249,8 @@
 
   auto append(sIconViewItem item) -> type&;
   auto backgroundColor() const -> Color;
+  auto batchable() const -> bool;
+  auto batched() const -> vector<IconViewItem>;
   auto doActivate() const -> void;
   auto doChange() const -> void;
   auto doContext() const -> void;
@@ -1178,30 +1259,28 @@
   auto item(unsigned position) const -> IconViewItem;
   auto itemCount() const -> unsigned;
   auto items() const -> vector<IconViewItem>;
-  auto multiSelect() const -> bool;
   auto onActivate(const function<void ()>& callback = {}) -> type&;
   auto onChange(const function<void ()>& callback = {}) -> type&;
   auto onContext(const function<void ()>& callback = {}) -> type&;
   auto orientation() const -> Orientation;
   auto remove(sIconViewItem item) -> type&;
   auto reset() -> type&;
-  auto selected() const -> maybe<unsigned>;
-  auto selectedItems() const -> vector<unsigned>;
+  auto selected() const -> IconViewItem;
   auto setBackgroundColor(Color color = {}) -> type&;
+  auto setBatchable(bool batchable = true) -> type&;
   auto setFlow(Orientation flow = Orientation::Vertical) -> type&;
   auto setForegroundColor(Color color = {}) -> type&;
-  auto setMultiSelect(bool multipleSelections = true) -> type&;
   auto setOrientation(Orientation orientation = Orientation::Horizontal) -> type&;
-//TODO setParent()
+  auto setParent(mObject* object = nullptr, signed offset = -1) -> type& override;
   auto setSelected(const vector<signed>& selections) -> type&;
 
 //private:
   struct State {
     Color backgroundColor;
+    bool batchable = false;
     Color foregroundColor;
     Orientation flow = Orientation::Vertical;
     vector<sIconViewItem> items;
-    bool multiSelect = false;
     function<void ()> onActivate;
     function<void ()> onChange;
     function<void ()> onContext;
@@ -1216,17 +1295,17 @@
 struct mIconViewItem : mObject {
   Declare(IconViewItem)
 
-  auto icon() const -> image;
+  auto image() const -> Image;
   auto remove() -> type& override;
   auto selected() const -> bool;
-  auto setIcon(const image& icon = {}) -> type&;
+  auto setImage(const Image& image = {}) -> type&;
   auto setSelected(bool selected = true) -> type&;
   auto setText(const string& text = "") -> type&;
   auto text() const -> string;
 
 //private:
   struct State {
-    image icon;
+    Image image;
     bool selected = false;
     string text;
   } state;
@@ -1318,7 +1397,6 @@
   auto setBatchable(bool batchable = true) -> type&;
   auto setBordered(bool bordered = true) -> type&;
   auto setForegroundColor(Color color = {}) -> type&;
-  auto setGridVisible(bool visible = true) -> type&;
   auto setParent(mObject* parent = nullptr, signed offset = -1) -> type& override;
 
 //private:
@@ -1373,7 +1451,7 @@
   auto expandable() const -> bool;
   auto foregroundColor() const -> Color;
   auto horizontalAlignment() const -> double;
-  auto icon() const -> image;
+  auto image() const -> Image;
   auto remove() -> type& override;
   auto resizable() const -> bool;
   auto setActive() -> type&;
@@ -1383,7 +1461,7 @@
   auto setExpandable(bool expandable = true) -> type&;
   auto setForegroundColor(Color color = {}) -> type&;
   auto setHorizontalAlignment(double alignment = 0.0) -> type&;
-  auto setIcon(const image& icon = {}) -> type&;
+  auto setImage(const Image& image = {}) -> type&;
   auto setResizable(bool resizable = true) -> type&;
   auto setSortable(bool sortable = true) -> type&;
   auto setText(const string& text = "") -> type&;
@@ -1403,7 +1481,7 @@
     bool expandable = false;
     Color foregroundColor;
     double horizontalAlignment = 0.0;
-    image icon;
+    Image image;
     bool resizable = true;
     bool sortable = false;
     string text;
@@ -1454,15 +1532,15 @@
   auto backgroundColor(bool recursive = false) const -> Color;
   auto checkable() const -> bool;
   auto checked() const -> bool;
-  auto font(bool recursive = false) const -> string;
+  auto font(bool recursive = false) const -> Font;
   auto foregroundColor(bool recursive = false) const -> Color;
-  auto icon() const -> image;
+  auto image() const -> Image;
   auto setAlignment(Alignment alignment = {}) -> type&;
   auto setBackgroundColor(Color color = {}) -> type&;
   auto setCheckable(bool checkable = true) -> type&;
   auto setChecked(bool checked = true) -> type&;
   auto setForegroundColor(Color color = {}) -> type&;
-  auto setIcon(const image& icon = {}) -> type&;
+  auto setImage(const Image& image = {}) -> type&;
   auto setText(const string& text = "") -> type&;
   auto text() const -> string;
 
@@ -1473,7 +1551,7 @@
     bool checkable = false;
     bool checked = false;
     Color foregroundColor;
-    image icon;
+    Image image;
     string text;
   } state;
 };
@@ -1501,13 +1579,13 @@
   auto checked() const -> bool;
   auto doActivate() const -> void;
   auto group() const -> Group override;
-  auto icon() const -> image;
+  auto image() const -> Image;
   auto onActivate(const function<void ()>& callback = {}) -> type&;
   auto orientation() const -> Orientation;
   auto setBordered(bool bordered = true) -> type&;
   auto setChecked() -> type&;
   auto setGroup(sGroup group = {}) -> type& override;
-  auto setIcon(const image& icon = {}) -> type&;
+  auto setImage(const Image& image = {}) -> type&;
   auto setOrientation(Orientation orientation = Orientation::Horizontal) -> type&;
   auto setText(const string& text = "") -> type&;
   auto text() const -> string;
@@ -1517,7 +1595,7 @@
     bool bordered = true;
     bool checked = false;
     sGroup group;
-    image icon;
+    Image image;
     function<void ()> onActivate;
     Orientation orientation = Orientation::Horizontal;
     string text;
@@ -1552,22 +1630,20 @@
 struct mSourceEdit : mWidget {
   Declare(SourceEdit)
 
+  auto cursor() const -> Cursor;
   auto doChange() const -> void;
   auto doMove() const -> void;
   auto onChange(const function<void ()>& callback = {}) -> type&;
   auto onMove(const function<void ()>& callback = {}) -> type&;
-  auto position() const -> unsigned;
-  auto setPosition(signed position) -> type&;
-  auto setSelected(Position selected) -> type&;
+  auto setCursor(Cursor cursor = {}) -> type&;
   auto setText(const string& text = "") -> type&;
   auto text() const -> string;
 
 //private:
   struct State {
+    Cursor cursor;
     function<void ()> onChange;
     function<void ()> onMove;
-    unsigned position = 0;
-    Position selected;
     string text;
   } state;
 };
@@ -1583,23 +1659,23 @@
   auto doChange() const -> void;
   auto doClose(sTabFrameItem item) const -> void;
   auto doMove(sTabFrameItem from, sTabFrameItem to) const -> void;
-  auto edge() const -> Edge;
   auto item(unsigned position) const -> TabFrameItem;
   auto itemCount() const -> unsigned;
   auto items() const -> vector<TabFrameItem>;
+  auto navigation() const -> Navigation;
   auto onChange(const function<void ()>& callback = {}) -> type&;
   auto onClose(const function<void (TabFrameItem)>& callback = {}) -> type&;
   auto onMove(const function<void (TabFrameItem, TabFrameItem)>& callback = {}) -> type&;
   auto remove(sTabFrameItem item) -> type&;
   auto reset() -> type&;
   auto selected() const -> TabFrameItem;
-  auto setEdge(Edge edge = Edge::Top) -> type&;
+  auto setNavigation(Navigation navigation = Navigation::Top) -> type&;
   auto setParent(mObject* object = nullptr, signed offset = -1) -> type& override;
 
 //private:
   struct State {
-    Edge edge = Edge::Top;
     vector<sTabFrameItem> items;
+    Navigation navigation = Navigation::Top;
     function<void ()> onChange;
     function<void (TabFrameItem)> onClose;
     function<void (TabFrameItem, TabFrameItem)> onMove;
@@ -1615,7 +1691,7 @@
 
   auto append(sLayout layout) -> type&;
   auto closable() const -> bool;
-  auto icon() const -> image;
+  auto image() const -> Image;
   auto layout() const -> Layout;
   auto movable() const -> bool;
   auto remove() -> type& override;
@@ -1623,7 +1699,7 @@
   auto reset() -> type&;
   auto selected() const -> bool;
   auto setClosable(bool closable = true) -> type&;
-  auto setIcon(const image& icon = {}) -> type&;
+  auto setImage(const Image& image = {}) -> type&;
   auto setMovable(bool movable = true) -> type&;
   auto setParent(mObject* object = nullptr, signed offset = -1) -> type& override;
   auto setSelected() -> type&;
@@ -1633,7 +1709,7 @@
 //private:
   struct State {
     bool closable = false;
-    image icon;
+    Image image;
     sLayout layout;
     bool movable = false;
     bool selected = false;
@@ -1649,7 +1725,7 @@
   Declare(TextEdit)
 
   auto backgroundColor() const -> Color;
-  auto cursorPosition() const -> unsigned;
+  auto cursor() const -> Cursor;
   auto doChange() const -> void;
   auto doMove() const -> void;
   auto editable() const -> bool;
@@ -1657,7 +1733,7 @@
   auto onChange(const function<void ()>& callback = {}) -> type&;
   auto onMove(const function<void ()>& callback = {}) -> type&;
   auto setBackgroundColor(Color color = {}) -> type&;
-  auto setCursorPosition(unsigned position) -> type&;
+  auto setCursor(Cursor cursor = {}) -> type&;
   auto setEditable(bool editable = true) -> type&;
   auto setForegroundColor(Color color = {}) -> type&;
   auto setText(const string& text = "") -> type&;
@@ -1668,7 +1744,7 @@
 //private:
   struct State {
     Color backgroundColor;
-    unsigned cursorPosition = 0;
+    Cursor cursor;
     bool editable = true;
     Color foregroundColor;
     function<void ()> onChange;
@@ -1686,13 +1762,10 @@
 
   auto append(sTreeViewItem item) -> type&;
   auto backgroundColor() const -> Color;
-  auto checkable() const -> bool;
-  auto collapse() -> type&;
   auto doActivate() const -> void;
   auto doChange() const -> void;
   auto doContext() const -> void;
   auto doToggle(sTreeViewItem item) const -> void;
-  auto expand() -> type&;
   auto foregroundColor() const -> Color;
   auto item(const string& path) const -> TreeViewItem;
   auto itemCount() const -> unsigned;
@@ -1705,14 +1778,12 @@
   auto reset() -> type&;
   auto selected() const -> TreeViewItem;
   auto setBackgroundColor(Color color = {}) -> type&;
-  auto setCheckable(bool checkable = true) -> type&;
   auto setForegroundColor(Color color = {}) -> type&;
-//TODO setParent
+  auto setParent(mObject* parent = nullptr, signed offset = -1) -> type&;
 
 //private:
   struct State {
     Color backgroundColor;
-    bool checkable = false;
     Color foregroundColor;
     vector<sTreeViewItem> items;
     function<void ()> onActivate;
@@ -1731,8 +1802,11 @@
   Declare(TreeViewItem)
 
   auto append(sTreeViewItem item) -> type&;
+  auto backgroundColor(bool recursive = false) const -> Color;
+  auto checkable() const -> bool;
   auto checked() const -> bool;
-  auto icon() const -> image;
+  auto foregroundColor(bool recursive = false) const -> Color;
+  auto image() const -> Image;
   auto item(const string& path) const -> TreeViewItem;
   auto itemCount() const -> unsigned;
   auto items() const -> vector<TreeViewItem>;
@@ -1740,18 +1814,25 @@
   auto remove() -> type& override;
   auto remove(sTreeViewItem item) -> type&;
   auto selected() const -> bool;
+  auto setBackgroundColor(Color color = {}) -> type&;
+  auto setCheckable(bool checkable = true) -> type&;
   auto setChecked(bool checked = true) -> type&;
+  auto setExpanded(bool expanded = true) -> type&;
   auto setFocused() -> type& override;
-  auto setIcon(const image& icon = {}) -> type&;
-//TODO setParent
+  auto setForegroundColor(Color color = {}) -> type&;
+  auto setImage(const Image& image = {}) -> type&;
+  auto setParent(mObject* parent = nullptr, signed offset = -1) -> type&;
   auto setSelected() -> type&;
   auto setText(const string& text = "") -> type&;
   auto text() const -> string;
 
 //private:
   struct State {
+    Color backgroundColor;
+    bool checkable = false;
     bool checked = false;
-    image icon;
+    Color foregroundColor;
+    Image image;
     vector<sTreeViewItem> items;
     string text;
   } state;
diff -Nru higan/hiro/core/cursor.cpp higan/hiro/core/cursor.cpp
--- higan/hiro/core/cursor.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/hiro/core/cursor.cpp	2015-09-16 13:08:13.474563360 +0900
@@ -0,0 +1,43 @@
+#if defined(Hiro_Cursor)
+
+Cursor::Cursor(signed offset, signed length) {
+  setCursor(offset, length);
+}
+
+Cursor::operator bool() const {
+  return offset() && length();
+}
+
+auto Cursor::operator==(const Cursor& source) const -> bool {
+  return offset() == source.offset() && length() == source.length();
+}
+
+auto Cursor::operator!=(const Cursor& source) const -> bool {
+  return !operator==(source);
+}
+
+auto Cursor::length() const -> signed {
+  return state.length;
+}
+
+auto Cursor::offset() const -> signed {
+  return state.offset;
+}
+
+auto Cursor::setCursor(signed offset, signed length) -> type& {
+  state.offset = offset;
+  state.length = length;
+  return *this;
+}
+
+auto Cursor::setOffset(signed offset) -> type& {
+  state.offset = offset;
+  return *this;
+}
+
+auto Cursor::setLength(signed length) -> type& {
+  state.length = length;
+  return *this;
+}
+
+#endif
diff -Nru higan/hiro/core/font.cpp higan/hiro/core/font.cpp
--- higan/hiro/core/font.cpp	2015-09-16 02:20:06.381574581 +0900
+++ higan/hiro/core/font.cpp	2015-09-16 13:08:13.467563359 +0900
@@ -1,11 +1,10 @@
 #if defined(Hiro_Font)
 
-Font::Font() {
-}
-
 Font::Font(const string& family, unsigned size) {
-  state.family = family;
-  state.size = size;
+  setFamily(family);
+  setSize(size);
+  state.bold = false;
+  state.italic = false;
 }
 
 Font::operator bool() const {
@@ -13,8 +12,8 @@
 }
 
 auto Font::operator==(const Font& source) const -> bool {
-  return family() == source.family() || size() == source.size() && bold() == source.bold() && italic() == source.italic();
-};
+  return family() == source.family() && size() == source.size() && bold() == source.bold() && italic() == source.italic();
+}
 
 auto Font::operator!=(const Font& source) const -> bool {
   return !operator==(source);
@@ -32,6 +31,14 @@
   return state.italic;
 }
 
+auto Font::reset() -> type& {
+  state.family = "";
+  state.size = 0;
+  state.bold = false;
+  state.italic = false;
+  return *this;
+}
+
 auto Font::setBold(bool bold) -> type& {
   state.bold = bold;
   return *this;
@@ -56,22 +63,8 @@
   return state.size;
 }
 
-//
-
-auto Font::serif(unsigned size, const string& style) -> string {
-  return pFont::serif(size, style);
-}
-
-auto Font::sans(unsigned size, const string& style) -> string {
-  return pFont::sans(size, style);
-}
-
-auto Font::monospace(unsigned size, const string& style) -> string {
-  return pFont::monospace(size, style);
-}
-
-auto Font::size(const string& font, const string& text) -> Size {
-  return pFont::size(font, text);
+auto Font::size(const string& text) const -> Size {
+  return pFont::size(*this, text);
 }
 
 #endif
diff -Nru higan/hiro/core/geometry.cpp higan/hiro/core/geometry.cpp
--- higan/hiro/core/geometry.cpp	2015-09-16 02:20:06.381574581 +0900
+++ higan/hiro/core/geometry.cpp	2015-09-16 13:08:13.468563359 +0900
@@ -20,6 +20,10 @@
   state.height = integer(part(3));
 }
 
+Geometry::operator bool() const {
+  return state.x || state.y || state.width || state.height;
+}
+
 auto Geometry::operator==(const Geometry& source) const -> bool {
   return x() == source.x() && y() == source.y() && width() == source.width() && height() == source.height();
 }
@@ -36,6 +40,10 @@
   return {state.x, state.y};
 }
 
+auto Geometry::reset() -> type& {
+  return setGeometry(0, 0, 0, 0);
+}
+
 auto Geometry::setHeight(signed height) -> type& {
   state.height = height;
   return *this;
diff -Nru higan/hiro/core/gradient.cpp higan/hiro/core/gradient.cpp
--- higan/hiro/core/gradient.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/hiro/core/gradient.cpp	2015-09-16 13:08:13.472563359 +0900
@@ -0,0 +1,37 @@
+#if defined(Hiro_Gradient)
+
+Gradient::Gradient() {
+}
+
+Gradient::operator bool() const {
+  return state.colors.size() == 4;
+}
+
+auto Gradient::operator==(const Gradient& source) const -> bool {
+  if(state.colors.size() != source.state.colors.size()) return false;
+  for(auto n : range(state.colors)) {
+    if(state.colors[n] != source.state.colors[n]) return false;
+  }
+  return true;
+}
+
+auto Gradient::operator!=(const Gradient& source) const -> bool {
+  return !operator==(source);
+}
+
+auto Gradient::setBilinear(Color topLeft, Color topRight, Color bottomLeft, Color bottomRight) -> type& {
+  state.colors = {topLeft, topRight, bottomLeft, bottomRight};
+  return *this;
+}
+
+auto Gradient::setHorizontal(Color left, Color right) -> type& {
+  state.colors = {left, right, left, right};
+  return *this;
+}
+
+auto Gradient::setVertical(Color top, Color bottom) -> type& {
+  state.colors = {top, top, bottom, bottom};
+  return *this;
+}
+
+#endif
diff -Nru higan/hiro/core/hotkey.cpp higan/hiro/core/hotkey.cpp
--- higan/hiro/core/hotkey.cpp	2015-09-16 02:20:06.381574581 +0900
+++ higan/hiro/core/hotkey.cpp	2015-09-16 13:08:13.472563359 +0900
@@ -1,54 +1,59 @@
 #if defined(Hiro_Hotkey)
 
-auto mHotkey::allocate() -> pObject* {
-  return new pHotkey(*this);
+Hotkey::Hotkey() : state(new Hotkey::State) {
+  setSequence();
 }
 
-//
+Hotkey::Hotkey(const string& sequence) : state(new Hotkey::State) {
+  setSequence(sequence);
+}
 
-auto mHotkey::doPress() const -> void {
-  if(state.onPress) return state.onPress();
+Hotkey::operator bool() const {
+  return state->sequence;
 }
 
-auto mHotkey::doRelease() const -> void {
-  if(state.onRelease) return state.onRelease();
+auto Hotkey::operator==(const Hotkey& source) const -> bool {
+  return state == source.state;
 }
 
-auto mHotkey::onPress(const function<void ()>& callback) -> type& {
-  state.onPress = callback;
-  return *this;
+auto Hotkey::operator!=(const Hotkey& source) const -> bool {
+  return !operator==(source);
 }
 
-auto mHotkey::onRelease(const function<void ()>& callback) -> type& {
-  state.onRelease = callback;
-  return *this;
+auto Hotkey::doPress() const -> void {
+  if(state->onPress) state->onPress();
 }
 
-auto mHotkey::owner() const -> wObject {
-  return state.owner;
+auto Hotkey::doRelease() const -> void {
+  if(state->onRelease) state->onRelease();
 }
 
-auto mHotkey::remove() -> type& {
-//todo: remove from Keyboard::hotkeys
+auto Hotkey::onPress(const function<void ()>& callback) -> type& {
+  state->onPress = callback;
   return *this;
 }
 
-auto mHotkey::sequence() const -> string {
-  return state.sequence;
+auto Hotkey::onRelease(const function<void ()>& callback) -> type& {
+  state->onRelease = callback;
+  return *this;
 }
 
-auto mHotkey::setOwner(sObject owner) -> type& {
-  state.owner = owner;
+auto Hotkey::reset() -> type& {
+  setSequence();
   return *this;
 }
 
-auto mHotkey::setSequence(const string& sequence) -> type& {
-  state.active = false;
-  state.sequence = sequence;
-  state.keys.reset();
+auto Hotkey::sequence() const -> string {
+  return state->sequence;
+}
+
+auto Hotkey::setSequence(const string& sequence) -> type& {
+  state->active = false;
+  state->sequence = sequence;
+  state->keys.reset();
   for(auto& key : sequence.split("+")) {
     if(auto position = Keyboard::keys.find(key)) {
-      state.keys.append(*position);
+      state->keys.append(*position);
     }
   }
   return *this;
diff -Nru higan/hiro/core/image.cpp higan/hiro/core/image.cpp
--- higan/hiro/core/image.cpp	1970-01-01 09:00:00.000000000 +0900
+++ higan/hiro/core/image.cpp	2015-09-16 13:08:13.472563359 +0900
@@ -0,0 +1,83 @@
+#if defined(Hiro_Image)
+
+Image::Image() {
+}
+
+Image::Image(const Image& source) {
+  operator=(source);
+}
+
+Image::Image(const string& source) {
+  nall::image image{source};
+  image.transform();
+  setImage((const uint32_t*)image.data(), Size{(signed)image.width(), (signed)image.height()});
+}
+
+Image::Image(const vector<uint8_t>& source) {
+  nall::image image{source};
+  image.transform();
+  setImage((const uint32_t*)image.data(), Size{(signed)image.width(), (signed)image.height()});
+}
+
+Image::Image(const uint32_t* data, Size size) {
+  setImage(data, size);
+}
+
+Image::~Image() {
+  reset();
+}
+
+Image::operator bool() const {
+  return state.data;
+}
+
+auto Image::operator=(const Image& source) -> type& {
+  reset();
+  if(state.size = source.state.size) {
+    state.data = new uint32_t[state.size.width() * state.size.height()];
+    memory::copy(state.data, source.state.data, state.size.width() * state.size.height() * sizeof(uint32_t));
+  }
+  return *this;
+}
+
+auto Image::data() const -> uint32_t* {
+  return state.data;
+}
+
+auto Image::height() const -> signed {
+  return state.size.height();
+}
+
+auto Image::reset() -> type& {
+  if(state.data) delete[] state.data;
+  state.data = nullptr;
+  state.size = {};
+  return *this;
+}
+
+auto Image::setImage(const uint32_t* data, Size size) -> type& {
+  reset();
+  if(data && size) {
+    state.size = size;
+    state.data = new uint32_t[size.width() * size.height()];
+    memory::copy(state.data, data, size.width() * size.height() * sizeof(uint32_t));
+  }
+  return *this;
+}
+
+auto Image::setSize(Size size) -> type& {
+  state.size = size;
+  if(state.data) delete[] state.data;
+  if(state.size) state.data = new uint32_t[size.width() * size.height()];
+  return *this;
+}
+
+auto Image::size() const -> Size {
+  return state.size;
+}
+
+auto Image::width() const -> signed {
+  return state.size.width();
+}
+
+#endif
diff -Nru higan/hiro/core/keyboard.cpp higan/hiro/core/keyboard.cpp
--- higan/hiro/core/keyboard.cpp	2015-09-16 02:20:06.381574581 +0900
+++ higan/hiro/core/keyboard.cpp	2015-09-16 13:08:13.473563359 +0900
@@ -18,44 +18,43 @@
   "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine", "Zero",
 
   //group aliases
-  "Shift",    //"LeftShift" | "RightShift"
+  "Shift",    //"LeftShift"   | "RightShift"
   "Control",  //"LeftControl" | "RightControl"
-  "Alt",      //"LeftAlt" | "RightAlt"
-  "Super",    //"LeftSuper" | "RightSuper"
-  "Enter",    //"LeftEnter" | "RightEnter"
+  "Alt",      //"LeftAlt"     | "RightAlt"
+  "Super",    //"LeftSuper"   | "RightSuper"
+  "Enter",    //"LeftEnter"   | "RightEnter"
 };
 
-auto Keyboard::append(sHotkey hotkey) -> void {
+auto Keyboard::append(Hotkey hotkey) -> void {
   state.hotkeys.append(hotkey);
 }
 
 auto Keyboard::hotkey(unsigned position) -> Hotkey {
-  if(position < hotkeys()) return state.hotkeys[position];
+  if(position < hotkeyCount()) return state.hotkeys[position];
   return {};
 }
 
-auto Keyboard::hotkeys() -> unsigned {
+auto Keyboard::hotkeyCount() -> unsigned {
   return state.hotkeys.size();
 }
 
+auto Keyboard::hotkeys() -> vector<Hotkey> {
+  return state.hotkeys;
+}
+
 auto Keyboard::poll() -> vector<bool> {
   auto pressed = pKeyboard::poll();
 
   for(auto& hotkey : state.hotkeys) {
-    bool active = hotkey->state.sequence.size() > 0;
-    for(auto& key : hotkey->state.keys) {
+    bool active = hotkey.state->sequence.size() > 0;
+    for(auto& key : hotkey.state->keys) {
       if(pressed[key]) continue;
       active = false;
       break;
     }
-    if(auto owner = hotkey->state.owner.acquire()) {
-      //todo: set active = false if owner no longer exists
-      active &= owner->focused();
-    }
-    if(hotkey->state.active != active) {
-      hotkey->state.active = active;
-      if( active) hotkey->doPress();
-      if(!active) hotkey->doRelease();
+    if(hotkey.state->active != active) {
+      hotkey.state->active = active;
+      active ? hotkey.doPress() : hotkey.doRelease();
     }
   }
 
@@ -71,7 +70,7 @@
   return !pressed(key);
 }
 
-auto Keyboard::remove(sHotkey hotkey) -> void {
+auto Keyboard::remove(Hotkey hotkey) -> void {
   if(auto offset = state.hotkeys.find(hotkey)) {
     state.hotkeys.remove(*offset);
   }
diff -Nru higan/hiro/core/menu-bar.cpp higan/hiro/core/menu-bar.cpp
--- higan/hiro/core/menu-bar.cpp	2015-09-16 02:20:06.381574581 +0900
+++ higan/hiro/core/menu-bar.cpp	2015-09-16 13:08:13.474563360 +0900
@@ -54,4 +54,11 @@
   return *this;
 }
 
+auto mMenuBar::setParent(mObject* parent, signed offset) -> type& {
+  for(auto n : rrange(state.menus)) state.menus[n]->destruct();
+  mObject::setParent(parent, offset);
+  for(auto& menu : state.menus) menu->setParent(this, menu->offset());
+  return *this;
+}
+
 #endif
diff -Nru higan/hiro/core/object.cpp higan/hiro/core/object.cpp
--- higan/hiro/core/object.cpp	2015-09-16 02:20:06.381574581 +0900
+++ higan/hiro/core/object.cpp	2015-09-16 13:08:13.457563358 +0900
@@ -68,7 +68,7 @@
   return false;
 }
 
-auto mObject::font(bool recursive) const -> string {
+auto mObject::font(bool recursive) const -> Font {
   if(!recursive || state.font) return state.font;
   if(auto object = parent()) return object->font(true);
   return Application::font();
@@ -277,7 +277,7 @@
   return *this;
 }
 
-auto mObject::setFont(const string& font) -> type& {
+auto mObject::setFont(const Font& font) -> type& {
   state.font = font;
   signal(setFont, this->font(true));
   return *this;
diff -Nru higan/hiro/core/popup-menu.cpp higan/hiro/core/popup-menu.cpp
--- higan/hiro/core/popup-menu.cpp	2015-09-16 02:20:06.381574581 +0900
+++ higan/hiro/core/popup-menu.cpp	2015-09-16 13:08:13.474563360 +0900
@@ -50,7 +50,7 @@
 }
 
 auto mPopupMenu::setParent(mObject* parent, signed offset) -> type& {
-  for(auto& action : state.actions) action->destruct();
+  for(auto n : rrange(state.actions)) state.actions[n]->destruct();
   mObject::setParent(parent, offset);
   for(auto& action : state.actions) action->construct();
   return *this;
diff -Nru higan/hiro/core/position.cpp higan/hiro/core/position.cpp
--- higan/hiro/core/position.cpp	2015-09-16 02:20:06.381574581 +0900
+++ higan/hiro/core/position.cpp	2015-09-16 13:08:13.467563359 +0900
@@ -8,6 +8,10 @@
   setPosition(x, y);
 }
 
+Position::operator bool() const {
+  return state.x || state.y;
+}
+
 auto Position::operator==(const Position& source) const -> bool {
   return x() == source.x() && y() == source.y();
 }
@@ -16,6 +20,10 @@
   return !operator==(source);
 }
 
+auto Position::reset() -> type& {
+  return setPosition(0, 0);
+}
+
 auto Position::setPosition(Position position) -> type& {
   return setPosition(position.x(), position.y());
 }
diff -Nru higan/hiro/core/shared.hpp higan/hiro/core/shared.hpp
--- higan/hiro/core/shared.hpp	2015-09-16 02:20:06.382574581 +0900
+++ higan/hiro/core/shared.hpp	2015-09-16 13:08:13.460563358 +0900
@@ -28,7 +28,7 @@
   auto remove() { return self().remove(), *this; } \
   auto setEnabled(bool enabled = true) { return self().setEnabled(enabled), *this; } \
   auto setFocused() { return self().setFocused(), *this; } \
-  auto setFont(const string& font = "") { return self().setFont(font), *this; } \
+  auto setFont(const Font& font = {}) { return self().setFont(font), *this; } \
   auto setVisible(bool visible = true) { return self().setVisible(visible), *this; } \
   auto visible(bool recursive = false) const { return self().visible(recursive); } \
 
@@ -81,21 +81,6 @@
 };
 #endif
 
-#if defined(Hiro_Hotkey)
-struct Hotkey : sHotkey {
-  DeclareSharedObject(Hotkey)
-
-  auto doPress() const { return self().doPress(); }
-  auto doRelease() const { return self().doRelease(); }
-  auto onPress(const function<void ()>& callback = {}) { return self().onPress(callback), *this; }
-  auto onRelease(const function<void ()>& callback = {}) { return self().onRelease(callback), *this; }
-  auto owner() const { return self().owner(); }
-  auto sequence() const { return self().sequence(); }
-  auto setOwner(sObject owner) { return self().setOwner(owner), *this; }
-  auto setSequence(const string& sequence = "") { return self().setSequence(sequence), *this; }
-};
-#endif
-
 #if defined(Hiro_Timer)
 struct Timer : sTimer {
   DeclareSharedObject(Timer)
@@ -121,10 +106,10 @@
   auto actionCount() const { return self().actionCount(); }
   auto actions() const { return self().actions(); }
   auto append(sAction action) { return self().append(action), *this; }
-  auto icon() const { return self().icon(); }
+  auto image() const { return self().image(); }
   auto remove(sAction action) { return self().remove(action), *this; }
   auto reset() { return self().reset(), *this; }
-  auto setIcon(const image& icon = {}) { return self().setIcon(icon), *this; }
+  auto setImage(const Image& image = {}) { return self().setImage(image), *this; }
   auto setText(const string& text = "") { return self().setText(text), *this; }
   auto text() const { return self().text(); }
 };
@@ -141,9 +126,9 @@
   DeclareSharedAction(MenuItem)
 
   auto doActivate() const { return self().doActivate(); }
-  auto icon() const { return self().icon(); }
+  auto image() const { return self().image(); }
   auto onActivate(const function<void ()>& callback = {}) { return self().onActivate(callback), *this; }
-  auto setIcon(const image& icon = {}) { return self().setIcon(icon), *this; }
+  auto setImage(const Image& image = {}) { return self().setImage(image), *this; }
   auto setText(const string& text = "") { return self().setText(text), *this; }
   auto text() const { return self().text(); }
 };
@@ -200,11 +185,11 @@
 
   auto bordered() const { return self().bordered(); }
   auto doActivate() const { return self().doActivate(); }
-  auto icon() const { return self().icon(); }
+  auto image() const { return self().image(); }
   auto onActivate(const function<void ()>& callback = {}) { return self().onActivate(callback), *this; }
   auto orientation() const { return self().orientation(); }
   auto setBordered(bool bordered = true) { return self().setBordered(bordered), *this; }
-  auto setIcon(const image& icon = {}) { return self().setIcon(icon), *this; }
+  auto setImage(const Image& image = {}) { return self().setImage(image), *this; }
   auto setOrientation(Orientation orientation = Orientation::Horizontal) { return self().setOrientation(orientation), *this; }
   auto setText(const string& text = "") { return self().setText(text), *this; }
   auto text() const { return self().text(); }
@@ -224,20 +209,17 @@
   auto doMousePress(Mouse::Button button) const { return self().doMousePress(button); }
   auto doMouseRelease(Mouse::Button button) const { return self().doMouseRelease(button); }
   auto gradient() const { return self().gradient(); }
-  auto icon() const { return self().icon(); }
+  auto image() const { return self().image(); }
   auto onDrop(const function<void (lstring)>& callback = {}) { return self().onDrop(callback), *this; }
   auto onMouseLeave(const function<void ()>& callback = {}) { return self().onMouseLeave(callback), *this; }
   auto onMouseMove(const function<void (Position)>& callback = {}) { return self().onMouseMove(callback), *this; }
   auto onMousePress(const function<void (Mouse::Button)>& callback = {}) { return self().onMousePress(callback), *this; }
   auto onMouseRelease(const function<void (Mouse::Button)>& callback = {}) { return self().onMouseRelease(callback), *this; }
   auto setColor(Color color) { return self().setColor(color), *this; }
-  auto setData(Size size) { return self().setData(size), *this; }
   auto setDroppable(bool droppable = true) { return self().setDroppable(droppable), *this; }
-  auto setGradient(Color topLeft, Color topRight, Color bottomLeft, Color bottomRight) { return self().setGradient(topLeft, topRight, bottomLeft, bottomRight), *this; }
-  auto setHorizontalGradient(Color left, Color right) { return self().setGradient(left, right, left, right), *this; }
-  auto setIcon(const image& icon = {}) { return self().setIcon(icon), *this; }
-  auto setVerticalGradient(Color top, Color bottom) { return self().setGradient(top, top, bottom, bottom), *this; }
-  auto size() const { return self().size(); }
+  auto setGradient(Gradient gradient = {}) { return self().setGradient(gradient), *this; }
+  auto setImage(const Image& image = {}) { return self().setImage(image), *this; }
+  auto setSize(Size size = {}) { return self().setSize(size), *this; }
   auto update() { return self().update(), *this; }
 };
 #endif
@@ -249,12 +231,12 @@
   auto bordered() const { return self().bordered(); }
   auto checked() const { return self().checked(); }
   auto doToggle() const { return self().doToggle(); }
-  auto icon() const { return self().icon(); }
+  auto image() const { return self().image(); }
   auto onToggle(const function<void ()>& callback = {}) { return self().onToggle(callback), *this; }
   auto orientation() const { return self().orientation(); }
   auto setBordered(bool bordered = true) { return self().setBordered(bordered), *this; }
   auto setChecked(bool checked = true) { return self().setChecked(checked), *this; }
-  auto setIcon(const image& icon = {}) { return self().setIcon(icon), *this; }
+  auto setImage(const Image& image = {}) { return self().setImage(image), *this; }
   auto setOrientation(Orientation orientation = Orientation::Horizontal) { return self().setOrientation(orientation), *this; }
   auto setText(const string& text = "") { return self().setText(text), *this; }
   auto text() const { return self().text(); }
@@ -278,9 +260,9 @@
 struct ComboButtonItem : sComboButtonItem {
   DeclareSharedObject(ComboButtonItem)
 
-  auto icon() const { return self().icon(); }
+  auto image() const { return self().image(); }
   auto selected() const { return self().selected(); }
-  auto setIcon(const image& icon = {}) { return self().setIcon(icon), *this; }
+  auto setImage(const Image& image = {}) { return self().setImage(image), *this; }
   auto setSelected() { return self().setSelected(), *this; }
   auto setText(const string& text = "") { return self().setText(text), *this; }
   auto text() const { return self().text(); }
@@ -388,9 +370,9 @@
 struct IconViewItem : sIconViewItem {
   DeclareSharedObject(IconViewItem)
 
-  auto icon() const { return self().icon(); }
+  auto image() const { return self().image(); }
   auto selected() const { return self().selected(); }
-  auto setIcon(const image& icon = {}) { return self().setIcon(icon), *this; }
+  auto setImage(const Image& image = {}) { return self().setImage(image), *this; }
   auto setSelected(bool selected = true) { return self().setSelected(selected), *this; }
   auto setText(const string& text = "") { return self().setText(text), *this; }
   auto text() const { return self().text(); }
@@ -403,6 +385,8 @@
 
   auto append(sIconViewItem item) { return self().append(item), *this; }
   auto backgroundColor() const { return self().backgroundColor(); }
+  auto batchable() const { return self().batchable(); }
+  auto batched() const { return self().batched(); }
   auto doActivate() const { return self().doActivate(); }
   auto doChange() const { return self().doChange(); }
   auto doContext() const { return self().doContext(); }
@@ -411,7 +395,6 @@
   auto item(unsigned position) const { return self().item(position); }
   auto itemCount() const { return self().itemCount(); }
   auto items() const { return self().items(); }
-  auto multiSelect() const { return self().multiSelect(); }
   auto onActivate(const function<void ()>& callback = {}) { return self().onActivate(callback), *this; }
   auto onChange(const function<void ()>& callback = {}) { return self().onChange(callback), *this; }
   auto onContext(const function<void ()>& callback = {}) { return self().onContext(callback), *this; }
@@ -419,11 +402,10 @@
   auto remove(sIconViewItem item) { return self().remove(item), *this; }
   auto reset() { return self().reset(), *this; }
   auto selected() const { return self().selected(); }
-  auto selectedItems() const { return self().selectedItems(); }
   auto setBackgroundColor(Color color = {}) { return self().setBackgroundColor(color), *this; }
+  auto setBatchable(bool batchable = true) { return self().setBatchable(batchable), *this; }
   auto setFlow(Orientation orientation = Orientation::Vertical) { return self().setFlow(orientation), *this; }
   auto setForegroundColor(Color color = {}) { return self().setForegroundColor(color), *this; }
-  auto setMultiSelect(bool multiSelect = true) { return self().setMultiSelect(multiSelect), *this; }
   auto setOrientation(Orientation orientation = Orientation::Horizontal) { return self().setOrientation(orientation), *this; }
   auto setSelected(const vector<signed>& selections) { return self().setSelected(selections), *this; }
 };
@@ -470,7 +452,7 @@
   auto expandable() const { return self().expandable(); }
   auto foregroundColor() const { return self().foregroundColor(); }
   auto horizontalAlignment() const { return self().horizontalAlignment(); }
-  auto icon() const { return self().icon(); }
+  auto image() const { return self().image(); }
   auto resizable() const { return self().resizable(); }
   auto setActive() { return self().setActive(), *this; }
   auto setAlignment(Alignment alignment = {}) { return self().setAlignment(alignment), *this; }
@@ -478,12 +460,10 @@
   auto setEditable(bool editable = true) { return self().setEditable(editable), *this; }
   auto setExpandable(bool expandable = true) { return self().setExpandable(expandable), *this; }
   auto setForegroundColor(Color color = {}) { return self().setForegroundColor(color), *this; }
-  auto setHorizontalAlignment(double alignment = 0.0) { return self().setHorizontalAlignment(alignment), *this; }
-  auto setIcon(const image& icon = {}) { return self().setIcon(icon), *this; }
+  auto setImage(const Image& image = {}) { return self().setImage(image), *this; }
   auto setResizable(bool resizable = true) { return self().setResizable(resizable), *this; }
   auto setSortable(bool sortable = true) { return self().setSortable(sortable), *this; }
   auto setText(const string& text = "") { return self().setText(text), *this; }
-  auto setVerticalAlignment(double alignment = 0.5) { return self().setVerticalAlignment(alignment), *this; }
   auto setWidth(signed width = 0) { return self().setWidth(width), *this; }
   auto sortable() const { return self().sortable(); }
   auto text() const { return self().text(); }
@@ -513,13 +493,13 @@
   auto checkable() const { return self().checkable(); }
   auto checked() const { return self().checked(); }
   auto foregroundColor() const { return self().foregroundColor(); }
-  auto icon() const { return self().icon(); }
+  auto image() const { return self().image(); }
   auto setAlignment(Alignment alignment = {}) { return self().setAlignment(alignment), *this; }
   auto setBackgroundColor(Color color = {}) { return self().setBackgroundColor(color), *this; }
   auto setCheckable(bool checkable = true) const { return self().setCheckable(checkable), *this; }
   auto setChecked(bool checked = true) const { return self().setChecked(checked), *this; }
   auto setForegroundColor(Color color = {}) { return self().setForegroundColor(color), *this; }
-  auto setIcon(const image& icon = {}) { return self().setIcon(icon), *this; }
+  auto setImage(const Image& image = {}) { return self().setImage(image), *this; }
   auto setText(const string& text = "") { return self().setText(text), *this; }
   auto text() const { return self().text(); }
 };
@@ -603,12 +583,12 @@
   auto checked() const { return self().checked(); }
   auto doActivate() const { return self().doActivate(); }
   auto group() const { return self().group(); }
-  auto icon() const { return self().icon(); }
+  auto image() const { return self().image(); }
   auto onActivate(const function<void ()>& callback = {}) { return self().onActivate(callback), *this; }
   auto orientation() const { return self().orientation(); }
   auto setBordered(bool bordered = true) { return self().setBordered(bordered), *this; }
   auto setChecked() { return self().setChecked(), *this; }
-  auto setIcon(const image& icon = {}) { return self().setIcon(icon), *this; }
+  auto setImage(const Image& image = {}) { return self().setImage(image), *this; }
   auto setOrientation(Orientation orientation = Orientation::Horizontal) { return self().setOrientation(orientation), *this; }
   auto setText(const string& text = "") { return self().setText(text), *this; }
   auto text() const { return self().text(); }
@@ -633,13 +613,12 @@
 struct SourceEdit : sSourceEdit {
   DeclareSharedWidget(SourceEdit)
 
+  auto cursor() const { return self().cursor(); }
   auto doChange() const { return self().doChange(); }
   auto doMove() const { return self().doMove(); }
   auto onChange(const function<void ()>& callback = {}) { return self().onChange(callback), *this; }
   auto onMove(const function<void ()>& callback = {}) { return self().onMove(callback), *this; }
-  auto position() const { return self().position(); }
-  auto setPosition(signed position) { return self().setPosition(position), *this; }
-  auto setSelected(Position selected) { return self().setSelected(selected), *this; }
+  auto setCursor(Cursor cursor = {}) { return self().setCursor(cursor), *this; }
   auto setText(const string& text = "") { return self().setText(text), *this; }
   auto text() const { return self().text(); }
 };
@@ -651,14 +630,14 @@
 
   auto append(sLayout layout) { return self().append(layout), *this; }
   auto closable() const { return self().closable(); }
-  auto icon() const { return self().icon(); }
+  auto image() const { return self().image(); }
   auto layout() const { return self().layout(); }
   auto movable() const { return self().movable(); }
   auto remove(sLayout layout) { return self().remove(layout), *this; }
   auto reset() { return self().reset(), *this; }
   auto selected() const { return self().selected(); }
   auto setClosable(bool closable = true) { return self().setClosable(closable), *this; }
-  auto setIcon(const image& icon = {}) { return self().setIcon(icon), *this; }
+  auto setImage(const Image& image = {}) { return self().setImage(image), *this; }
   auto setMovable(bool movable = true) { return self().setMovable(movable), *this; }
   auto setSelected() { return self().setSelected(), *this; }
   auto setText(const string& text = "") { return self().setText(text), *this; }
@@ -674,17 +653,17 @@
   auto doChange() const { return self().doChange(); }
   auto doClose(sTabFrameItem item) const { return self().doClose(item); }
   auto doMove(sTabFrameItem from, sTabFrameItem to) const { return self().doMove(from, to); }
-  auto edge() const { return self().edge(); }
   auto item(unsigned position) const { return self().item(position); }
   auto itemCount() const { return self().itemCount(); }
   auto items() const { return self().items(); }
+  auto navigation() const { return self().navigation(); }
   auto onChange(const function<void ()>& callback = {}) { return self().onChange(callback), *this; }
   auto onClose(const function<void (sTabFrameItem)>& callback = {}) { return self().onClose(callback), *this; }
   auto onMove(const function<void (sTabFrameItem, sTabFrameItem)>& callback = {}) { return self().onMove(callback), *this; }
   auto remove(sTabFrameItem item) { return self().remove(item), *this; }
   auto reset() { return self().reset(), *this; }
   auto selected() const { return self().selected(); }
-  auto setEdge(Edge edge = Edge::Top) { return self().setEdge(edge), *this; }
+  auto setNavigation(Navigation navigation = Navigation::Top) { return self().setNavigation(navigation), *this; }
 };
 #endif
 
@@ -693,7 +672,7 @@
   DeclareSharedWidget(TextEdit)
 
   auto backgroundColor() const { return self().backgroundColor(); }
-  auto cursorPosition() const { return self().cursorPosition(); }
+  auto cursor() const { return self().cursor(); }
   auto doChange() const { return self().doChange(); }
   auto doMove() const { return self().doMove(); }
   auto editable() const { return self().editable(); }
@@ -701,7 +680,7 @@
   auto onChange(const function<void ()>& callback = {}) { return self().onChange(callback), *this; }
   auto onMove(const function<void ()>& callback = {}) { return self().onMove(callback), *this; }
   auto setBackgroundColor(Color color = {}) { return self().setBackgroundColor(color), *this; }
-  auto setCursorPosition(unsigned position) { return self().setCursorPosition(position), *this; }
+  auto setCursor(Cursor cursor = {}) { return self().setCursor(cursor), *this; }
   auto setEditable(bool editable = true) { return self().setEditable(editable), *this; }
   auto setForegroundColor(Color color = {}) { return self().setForegroundColor(color), *this; }
   auto setText(const string& text = "") { return self().setText(text), *this; }
@@ -716,16 +695,23 @@
   DeclareSharedObject(TreeViewItem)
 
   auto append(sTreeViewItem item) { return self().append(item), *this; }
+  auto backgroundColor() const { return self().backgroundColor(); }
+  auto checkable() const { return self().checkable(); }
   auto checked() const { return self().checked(); }
-  auto icon() const { return self().icon(); }
+  auto foregroundColor() const { return self().foregroundColor(); }
+  auto image() const { return self().image(); }
   auto item(const string& path) const { return self().item(path); }
   auto itemCount() const { return self().itemCount(); }
   auto items() const { return self().items(); }
   auto path() const { return self().path(); }
   auto remove(sTreeViewItem item) { return self().remove(item), *this; }
   auto selected() const { return self().selected(); }
+  auto setBackgroundColor(Color color = {}) { return self().setBackgroundColor(color), *this; }
+  auto setCheckable(bool checkable = true) { return self().setCheckable(checkable), *this; }
   auto setChecked(bool checked = true) { return self().setChecked(checked), *this; }
-  auto setIcon(const image& icon = {}) { return self().setIcon(icon), *this; }
+  auto setExpanded(bool expanded = true) { return self().setExpanded(expanded), *this; }
+  auto setForegroundColor(Color color = {}) { return self().setForegroundColor(color), *this; }
+  auto setImage(const Image& image = {}) { return self().setImage(image), *this; }
   auto setSelected() { return self().setSelected(), *this; }
   auto setText(const string& text = "") { return self().setText(text), *this; }
   auto text() const { return self().text(); }
@@ -738,13 +724,10 @@
 
   auto append(sTreeViewItem item) { return self().append(item), *this; }
   auto backgroundColor() const { return self().backgroundColor(); }
-  auto checkable() const { return self().checkable(); }
-  auto collapse() { return self().collapse(), *this; }
   auto doActivate() const { return self().doActivate(); }
   auto doChange() const { return self().doChange(); }
   auto doContext() const { return self().doContext(); }
   auto doToggle(sTreeViewItem item) const { return self().doToggle(item); }
-  auto expand() { return self().expand(), *this; }
   auto foregroundColor() const { return self().foregroundColor(); }
   auto item(const string& path) const { return self().item(path); }
   auto itemCount() const { return self().itemCount(); }
@@ -757,7 +740,6 @@
   auto reset() { return self().reset(), *this; }
   auto selected() const { return self().selected(); }
   auto setBackgroundColor(Color color = {}) { return self().setBackgroundColor(color), *this; }
-  auto setCheckable(bool checkable = true) { return self().setCheckable(checkable), *this; }
   auto setForegroundColor(Color color = {}) { return self().setForegroundColor(color), *this; }
 };
 #endif
diff -Nru higan/hiro/core/size.cpp higan/hiro/core/size.cpp
--- higan/hiro/core/size.cpp	2015-09-16 02:20:06.382574581 +0900
+++ higan/hiro/core/size.cpp	2015-09-16 13:08:13.468563359 +0900
@@ -8,6 +8,10 @@
   setSize(width, height);
 }
 
+Size::operator bool() const {
+  return state.width || state.height;
+}
+
 auto Size::operator==(const Size& source) const -> bool {
   return width() == source.width() && height() == source.height();
 }
@@ -20,6 +24,10 @@
   return state.height;
 }
 
+auto Size::reset() -> type& {
+  return setSize(0, 0);
+}
+
 auto Size::setHeight(signed height) -> type& {
   state.height = height;
   return *this;
diff -Nru higan/hiro/core/widget/button.cpp higan/hiro/core/widget/button.cpp
--- higan/hiro/core/widget/button.cpp	2015-09-16 02:20:06.382574581 +0900
+++ higan/hiro/core/widget/button.cpp	2015-09-16 13:08:13.460563358 +0900
@@ -14,8 +14,8 @@
   if(state.onActivate) return state.onActivate();
 }
 
-auto mButton::icon() const -> image {
-  return state.icon;
+auto mButton::image() const -> Image {
+  return state.image;
 }
 
 auto mButton::onActivate(const function<void ()>& callback) -> type& {
@@ -33,9 +33,9 @@
   return *this;
 }
 
-auto mButton::setIcon(const image& icon) -> type& {
-  state.icon = icon;
-  signal(setIcon, icon);
+auto mButton::setImage(const Image& image) -> type& {
+  state.image = image;
+  signal(setImage, image);
   return *this;
 }
 
diff -Nru higan/hiro/core/widget/canvas.cpp higan/hiro/core/widget/canvas.cpp
--- higan/hiro/core/widget/canvas.cpp	2015-09-16 02:20:06.382574581 +0900
+++ higan/hiro/core/widget/canvas.cpp	2015-09-16 13:08:13.461563358 +0900
@@ -11,7 +11,7 @@
 }
 
 auto mCanvas::data() -> uint32_t* {
-  return state.data.data();
+  return state.image.data();
 }
 
 auto mCanvas::droppable() const -> bool {
@@ -38,12 +38,12 @@
   if(state.onMouseRelease) return state.onMouseRelease(button);
 }
 
-auto mCanvas::gradient() const -> vector<Color> {
+auto mCanvas::gradient() const -> Gradient {
   return state.gradient;
 }
 
-auto mCanvas::icon() const -> image {
-  return state.icon;
+auto mCanvas::image() const -> Image {
+  return state.image;
 }
 
 auto mCanvas::onDrop(const function<void (lstring)>& callback) -> type& {
@@ -72,53 +72,38 @@
 }
 
 auto mCanvas::setColor(Color color) -> type& {
-  state.size = {};
   state.color = color;
   signal(setColor, color);
   return *this;
 }
 
-auto mCanvas::setData(Size size) -> type& {
-  state.size = size;
-  state.data.resize(size.width() * size.height());
-  memory::fill(state.data.data(), size.width() * size.height() * sizeof(uint32_t));
-  signal(setData, size);
-  return *this;
-}
-
 auto mCanvas::setDroppable(bool droppable) -> type& {
   state.droppable = droppable;
   signal(setDroppable, droppable);
   return *this;
 }
 
-auto mCanvas::setGradient(Color topLeft, Color topRight, Color bottomLeft, Color bottomRight) -> type& {
-  state.size = {};
-  state.gradient[0] = topLeft;
-  state.gradient[1] = topRight;
-  state.gradient[2] = bottomLeft;
-  state.gradient[3] = bottomRight;
-  signal(setGradient, topLeft, topRight, bottomLeft, bottomRight);
+auto mCanvas::setGradient(Gradient gradient) -> type& {
+  state.gradient = gradient;
+  signal(setGradient, gradient);
   return *this;
 }
 
-auto mCanvas::setHorizontalGradient(Color left, Color right) -> type& {
-  return setGradient(left, right, left, right);
-}
-
-auto mCanvas::setIcon(const image& icon) -> type& {
-  state.size = {(signed)icon.width(), (signed)icon.height()};
-  state.icon = icon;
-  signal(setIcon, icon);
+auto mCanvas::setImage(const Image& image) -> type& {
+  state.image = image;
+  signal(setImage, image);
   return *this;
 }
 
-auto mCanvas::setVerticalGradient(Color top, Color bottom) -> type& {
-  return setGradient(top, top, bottom, bottom);
+auto mCanvas::setSize(Size size) -> type& {
+  Image image;
+  image.setSize(size);
+  memory::fill(image.data(), size.width() * size.height() * sizeof(uint32_t), 0x00);
+  return setImage(image);
 }
 
 auto mCanvas::size() const -> Size {
-  return state.size;
+  return state.image.size();
 }
 
 auto mCanvas::update() -> type& {
diff -Nru higan/hiro/core/widget/check-button.cpp higan/hiro/core/widget/check-button.cpp
--- higan/hiro/core/widget/check-button.cpp	2015-09-16 02:20:06.382574581 +0900
+++ higan/hiro/core/widget/check-button.cpp	2015-09-16 13:08:13.463563358 +0900
@@ -18,8 +18,8 @@
   if(state.onToggle) return state.onToggle();
 }
 
-auto mCheckButton::icon() const -> image {
-  return state.icon;
+auto mCheckButton::image() const -> Image {
+  return state.image;
 }
 
 auto mCheckButton::onToggle(const function<void ()>& callback) -> type& {
@@ -43,9 +43,9 @@
   return *this;
 }
 
-auto mCheckButton::setIcon(const image& icon) -> type& {
-  state.icon = icon;
-  signal(setIcon, icon);
+auto mCheckButton::setImage(const Image& image) -> type& {
+  state.image = image;
+  signal(setImage, image);
   return *this;
 }
 
diff -Nru higan/hiro/core/widget/combo-button-item.cpp higan/hiro/core/widget/combo-button-item.cpp
--- higan/hiro/core/widget/combo-button-item.cpp	2015-09-16 02:20:06.382574581 +0900
+++ higan/hiro/core/widget/combo-button-item.cpp	2015-09-16 13:08:13.463563358 +0900
@@ -6,8 +6,8 @@
 
 //
 
-auto mComboButtonItem::icon() const -> image {
-  return state.icon;
+auto mComboButtonItem::image() const -> Image {
+  return state.image;
 }
 
 auto mComboButtonItem::remove() -> type& {
@@ -19,9 +19,9 @@
   return state.selected;
 }
 
-auto mComboButtonItem::setIcon(const image& icon) -> type& {
-  state.icon = icon;
-  signal(setIcon, icon);
+auto mComboButtonItem::setImage(const Image& image) -> type& {
+  state.image = image;
+  signal(setImage, image);
   return *this;
 }
 
diff -Nru higan/hiro/core/widget/frame.cpp higan/hiro/core/widget/frame.cpp
--- higan/hiro/core/widget/frame.cpp	2015-09-16 02:20:06.382574581 +0900
+++ higan/hiro/core/widget/frame.cpp	2015-09-16 13:08:13.464563358 +0900
@@ -33,6 +33,13 @@
   return *this;
 }
 
+auto mFrame::setParent(mObject* object, signed offset) -> type& {
+  if(auto& layout = state.layout) layout->destruct();
+  mObject::setParent(object, offset);
+  if(auto& layout = state.layout) layout->setParent(this, 0);
+  return *this;
+}
+
 auto mFrame::setText(const string& text) -> type& {
   state.text = text;
   signal(setText, text);
diff -Nru higan/hiro/core/widget/icon-view.cpp higan/hiro/core/widget/icon-view.cpp
--- higan/hiro/core/widget/icon-view.cpp	2015-09-16 02:20:06.382574581 +0900
+++ higan/hiro/core/widget/icon-view.cpp	2015-09-16 13:08:13.462563358 +0900
@@ -22,6 +22,18 @@
   return state.backgroundColor;
 }
 
+auto mIconView::batchable() const -> bool {
+  return state.batchable;
+}
+
+auto mIconView::batched() const -> vector<IconViewItem> {
+  vector<IconViewItem> items;
+  for(auto& item : state.items) {
+    if(item->selected()) items.append(item);
+  }
+  return items;
+}
+
 auto mIconView::doActivate() const -> void {
   if(state.onActivate) return state.onActivate();
 }
@@ -57,10 +69,6 @@
   return items;
 }
 
-auto mIconView::multiSelect() const -> bool {
-  return state.multiSelect;
-}
-
 auto mIconView::onActivate(const function<void ()>& callback) -> type& {
   state.onActivate = callback;
   return *this;
@@ -97,19 +105,11 @@
   return *this;
 }
 
-auto mIconView::selected() const -> maybe<unsigned> {
-  for(auto& item : state.items) {
-    if(item->selected()) return (unsigned)item->offset();
-  }
-  return nothing;
-}
-
-auto mIconView::selectedItems() const -> vector<unsigned> {
-  vector<unsigned> result;
+auto mIconView::selected() const -> IconViewItem {
   for(auto& item : state.items) {
-    if(item->selected()) result.append(item->offset());
+    if(item->selected()) return item;
   }
-  return result;
+  return {};
 }
 
 auto mIconView::setBackgroundColor(Color color) -> type& {
@@ -118,6 +118,12 @@
   return *this;
 }
 
+auto mIconView::setBatchable(bool batchable) -> type& {
+  state.batchable = batchable;
+  signal(setBatchable, batchable);
+  return *this;
+}
+
 auto mIconView::setFlow(Orientation flow) -> type& {
   state.flow = flow;
   signal(setFlow, flow);
@@ -130,18 +136,19 @@
   return *this;
 }
 
-auto mIconView::setMultiSelect(bool multiSelect) -> type& {
-  state.multiSelect = multiSelect;
-  signal(setMultiSelect, multiSelect);
-  return *this;
-}
-
 auto mIconView::setOrientation(Orientation orientation) -> type& {
   state.orientation = orientation;
   signal(setOrientation, orientation);
   return *this;
 }
 
+auto mIconView::setParent(mObject* parent, signed offset) -> type& {
+  for(auto n : rrange(state.items)) state.items[n]->destruct();
+  mObject::setParent(parent, offset);
+  for(auto& item : state.items) item->setParent(this, item->offset());
+  return *this;
+}
+
 auto mIconView::setSelected(const vector<signed>& selections) -> type& {
   bool selectAll = selections(0, 0) == ~0;
   for(auto& item : state.items) item->state.selected = selectAll;
diff -Nru higan/hiro/core/widget/icon-view-item.cpp higan/hiro/core/widget/icon-view-item.cpp
--- higan/hiro/core/widget/icon-view-item.cpp	2015-09-16 02:20:06.382574581 +0900
+++ higan/hiro/core/widget/icon-view-item.cpp	2015-09-16 13:08:13.460563358 +0900
@@ -6,8 +6,8 @@
 
 //
 
-auto mIconViewItem::icon() const -> image {
-  return state.icon;
+auto mIconViewItem::image() const -> Image {
+  return state.image;
 }
 
 auto mIconViewItem::remove() -> type& {
@@ -19,9 +19,9 @@
   return state.selected;
 }
 
-auto mIconViewItem::setIcon(const image& icon) -> type& {
-  state.icon = icon;
-  signal(setIcon, icon);
+auto mIconViewItem::setImage(const Image& image) -> type& {
+  state.image = image;
+  signal(setImage, image);
   return *this;
 }
 
diff -Nru higan/hiro/core/widget/list-view-cell.cpp higan/hiro/core/widget/list-view-cell.cpp
--- higan/hiro/core/widget/list-view-cell.cpp	2015-09-16 02:20:06.382574581 +0900
+++ higan/hiro/core/widget/list-view-cell.cpp	2015-09-16 13:08:13.463563358 +0900
@@ -54,7 +54,7 @@
   return state.checkable && state.checked;
 }
 
-auto mListViewCell::font(bool recursive) const -> string {
+auto mListViewCell::font(bool recursive) const -> Font {
   if(auto font = mObject::font()) return font;
   if(recursive) {
     if(auto parent = parentListViewItem()) {
@@ -94,8 +94,8 @@
   return state.foregroundColor;
 }
 
-auto mListViewCell::icon() const -> image {
-  return state.icon;
+auto mListViewCell::image() const -> Image {
+  return state.image;
 }
 
 auto mListViewCell::setAlignment(Alignment alignment) -> type& {
@@ -129,9 +129,9 @@
   return *this;
 }
 
-auto mListViewCell::setIcon(const image& icon) -> type& {
-  state.icon = icon;
-  signal(setIcon, icon);
+auto mListViewCell::setImage(const Image& image) -> type& {
+  state.image = image;
+  signal(setImage, image);
   return *this;
 }
 
diff -Nru higan/hiro/core/widget/list-view-column.cpp higan/hiro/core/widget/list-view-column.cpp
--- higan/hiro/core/widget/list-view-column.cpp	2015-09-16 02:20:06.382574581 +0900
+++ higan/hiro/core/widget/list-view-column.cpp	2015-09-16 13:08:13.466563359 +0900
@@ -35,8 +35,8 @@
   return state.horizontalAlignment;
 }
 
-auto mListViewColumn::icon() const -> image {
-  return state.icon;
+auto mListViewColumn::image() const -> Image {
+  return state.image;
 }
 
 auto mListViewColumn::remove() -> type& {
@@ -91,9 +91,9 @@
   return *this;
 }
 
-auto mListViewColumn::setIcon(const image& icon) -> type& {
-  state.icon = icon;
-  signal(setIcon, icon);
+auto mListViewColumn::setImage(const Image& image) -> type& {
+  state.image = image;
+  signal(setImage, image);
   return *this;
 }
 
diff -Nru higan/hiro/core/widget/list-view.cpp higan/hiro/core/widget/list-view.cpp
--- higan/hiro/core/widget/list-view.cpp	2015-09-16 02:20:06.382574581 +0900
+++ higan/hiro/core/widget/list-view.cpp	2015-09-16 13:08:13.464563358 +0900
@@ -194,7 +194,7 @@
 }
 
 auto mListView::setParent(mObject* parent, signed offset) -> type& {
-  for(auto& item : state.items) item->destruct();
+  for(auto n : rrange(state.items)) state.items[n]->destruct();
   if(auto& header = state.header) header->destruct();
   mObject::setParent(parent, offset);
   if(auto& header = state.header) header->setParent(this, 0);
diff -Nru higan/hiro/core/widget/radio-button.cpp higan/hiro/core/widget/radio-button.cpp
--- higan/hiro/core/widget/radio-button.cpp	2015-09-16 02:20:06.382574581 +0900
+++ higan/hiro/core/widget/radio-button.cpp	2015-09-16 13:08:13.464563358 +0900
@@ -22,8 +22,8 @@
   return state.group;
 }
 
-auto mRadioButton::icon() const -> image {
-  return state.icon;
+auto mRadioButton::image() const -> Image {
+  return state.image;
 }
 
 auto mRadioButton::onActivate(const function<void ()>& callback) -> type& {
@@ -57,15 +57,14 @@
 }
 
 auto mRadioButton::setGroup(sGroup group) -> type& {
-  state.group = group;
+  state.group = group ? group : Group{&instance};
   signal(setGroup, group);
-  if(group && group->objectCount() == 1) setChecked();
   return *this;
 }
 
-auto mRadioButton::setIcon(const image& icon) -> type& {
-  state.icon = icon;
-  signal(setIcon, icon);
+auto mRadioButton::setImage(const Image& image) -> type& {
+  state.image = image;
+  signal(setImage, image);
   return *this;
 }
 
diff -Nru higan/hiro/core/widget/radio-label.cpp higan/hiro/core/widget/radio-label.cpp
--- higan/hiro/core/widget/radio-label.cpp	2015-09-16 02:20:06.382574581 +0900
+++ higan/hiro/core/widget/radio-label.cpp	2015-09-16 13:08:13.466563359 +0900
@@ -39,9 +39,8 @@
 }
 
 auto mRadioLabel::setGroup(sGroup group) -> type& {
-  state.group = group;
+  state.group = group ? group : Group{&instance};
   signal(setGroup, group);
-  if(group && group->objectCount() == 1) setChecked();
   return *this;
 }
 
diff -Nru higan/hiro/core/widget/source-edit.cpp higan/hiro/core/widget/source-edit.cpp
--- higan/hiro/core/widget/source-edit.cpp	2015-09-16 02:20:06.382574581 +0900
+++ higan/hiro/core/widget/source-edit.cpp	2015-09-16 13:08:13.460563358 +0900
@@ -6,6 +6,10 @@
 
 //
 
+auto mSourceEdit::cursor() const -> Cursor {
+  return state.cursor;
+}
+
 auto mSourceEdit::doChange() const -> void {
   if(state.onChange) return state.onChange();
 }
@@ -24,22 +28,9 @@
   return *this;
 }
 
-auto mSourceEdit::position() const -> unsigned {
-  return state.position;
-}
-
-auto mSourceEdit::setPosition(signed position) -> type& {
-  state.position = position;
-  signal(setPosition, position);
-  return *this;
-}
-
-auto mSourceEdit::setSelected(Position selected) -> type& {
-  if(selected.x() < 0) return *this;
-  if(selected.y() < 0) selected.setY(-1);
-  else if(selected.x() > selected.y()) return *this;
-  state.selected = selected;
-  signal(setSelected, selected);
+auto mSourceEdit::setCursor(Cursor cursor) -> type& {
+  state.cursor = cursor;
+  signal(setCursor, cursor);
   return *this;
 }
 
diff -Nru higan/hiro/core/widget/tab-frame.cpp higan/hiro/core/widget/tab-frame.cpp
--- higan/hiro/core/widget/tab-frame.cpp	2015-09-16 02:20:06.382574581 +0900
+++ higan/hiro/core/widget/tab-frame.cpp	2015-09-16 13:08:13.465563359 +0900
@@ -12,6 +12,7 @@
 //
 
 auto mTabFrame::append(sTabFrameItem item) -> type& {
+  if(!state.items) item->state.selected = true;
   state.items.append(item);
   item->setParent(this, itemCount() - 1);
   signal(append, item);
@@ -30,10 +31,6 @@
   if(state.onMove) return state.onMove(from, to);
 }
 
-auto mTabFrame::edge() const -> Edge {
-  return state.edge;
-}
-
 auto mTabFrame::item(unsigned position) const -> TabFrameItem {
   if(position < itemCount()) return state.items[position];
   return {};
@@ -49,6 +46,10 @@
   return items;
 }
 
+auto mTabFrame::navigation() const -> Navigation {
+  return state.navigation;
+}
+
 auto mTabFrame::onChange(const function<void ()>& callback) -> type& {
   state.onChange = callback;
   return *this;
@@ -87,14 +88,14 @@
   return {};
 }
 
-auto mTabFrame::setEdge(Edge edge) -> type& {
-  state.edge = edge;
-  signal(setEdge, edge);
+auto mTabFrame::setNavigation(Navigation navigation) -> type& {
+  state.navigation = navigation;
+  signal(setNavigation, navigation);
   return *this;
 }
 
 auto mTabFrame::setParent(mObject* parent, signed offset) -> type& {
-  for(auto& item : state.items) item->destruct();
+  for(auto n : rrange(state.items)) state.items[n]->destruct();
   mObject::setParent(parent, offset);
   for(auto& item : state.items) item->setParent(this, item->offset());
   return *this;
diff -Nru higan/hiro/core/widget/tab-frame-item.cpp higan/hiro/core/widget/tab-frame-item.cpp
--- higan/hiro/core/widget/tab-frame-item.cpp	2015-09-16 02:20:06.382574581 +0900
+++ higan/hiro/core/widget/tab-frame-item.cpp	2015-09-16 13:08:13.461563358 +0900
@@ -23,8 +23,8 @@
   return state.closable;
 }
 
-auto mTabFrameItem::icon() const -> image {
-  return state.icon;
+auto mTabFrameItem::image() const -> Image {
+  return state.image;
 }
 
 auto mTabFrameItem::layout() const -> Layout {
@@ -62,9 +62,9 @@
   return *this;
 }
 
-auto mTabFrameItem::setIcon(const image& icon) -> type& {
-  state.icon = icon;
-  signal(setIcon, icon);
+auto mTabFrameItem::setImage(const Image& image) -> type& {
+  state.image = image;
+  signal(setImage, image);
   return *this;
 }
 
diff -Nru higan/hiro/core/widget/text-edit.cpp higan/hiro/core/widget/text-edit.cpp
--- higan/hiro/core/widget/text-edit.cpp	2015-09-16 02:20:06.382574581 +0900
+++ higan/hiro/core/widget/text-edit.cpp	2015-09-16 13:08:13.465563359 +0900
@@ -10,8 +10,8 @@
   return state.backgroundColor;
 }
 
-auto mTextEdit::cursorPosition() const -> unsigned {
-  return state.cursorPosition;
+auto mTextEdit::cursor() const -> Cursor {
+  return state.cursor;
 }
 
 auto mTextEdit::doChange() const -> void {
@@ -46,9 +46,9 @@
   return *this;
 }
 
-auto mTextEdit::setCursorPosition(unsigned position) -> type& {
-  state.cursorPosition = position;
-  signal(setCursorPosition, position);
+auto mTextEdit::setCursor(Cursor cursor) -> type& {
+  state.cursor = cursor;
+  signal(setCursor, cursor);
   return *this;
 }
 
diff -Nru higan/hiro/core/widget/tree-view.cpp higan/hiro/core/widget/tree-view.cpp
--- higan/hiro/core/widget/tree-view.cpp	2015-09-16 02:20:06.383574581 +0900
+++ higan/hiro/core/widget/tree-view.cpp	2015-09-16 13:08:13.461563358 +0900
@@ -22,15 +22,6 @@
   return state.backgroundColor;
 }
 
-auto mTreeView::checkable() const -> bool {
-  return state.checkable;
-}
-
-auto mTreeView::collapse() -> type& {
-  signal(collapse);
-  return *this;
-}
-
 auto mTreeView::doActivate() const -> void {
   if(state.onActivate) return state.onActivate();
 }
@@ -47,11 +38,6 @@
   if(state.onToggle) return state.onToggle(item);
 }
 
-auto mTreeView::expand() -> type& {
-  signal(expand);
-  return *this;
-}
-
 auto mTreeView::foregroundColor() const -> Color {
   return state.foregroundColor;
 }
@@ -107,9 +93,7 @@
 
 auto mTreeView::reset() -> type& {
   state.selectedPath.reset();
-  signal(reset);
-  for(auto& item : state.items) item->setParent();
-  state.items.reset();
+  for(auto n : rrange(state.items)) remove(state.items[n]);
   return *this;
 }
 
@@ -123,16 +107,17 @@
   return *this;
 }
 
-auto mTreeView::setCheckable(bool checkable) -> type& {
-  state.checkable = checkable;
-  signal(setCheckable, checkable);
-  return *this;
-}
-
 auto mTreeView::setForegroundColor(Color color) -> type& {
   state.foregroundColor = color;
   signal(setForegroundColor, color);
   return *this;
 }
 
+auto mTreeView::setParent(mObject* object, signed offset) -> type& {
+  for(auto n : rrange(state.items)) state.items[n]->destruct();
+  mObject::setParent(object, offset);
+  for(auto& item : state.items) item->setParent(this, item->offset());
+  return *this;
+}
+
 #endif
diff -Nru higan/hiro/core/widget/tree-view-item.cpp higan/hiro/core/widget/tree-view-item.cpp
--- higan/hiro/core/widget/tree-view-item.cpp	2015-09-16 02:20:06.383574581 +0900
+++ higan/hiro/core/widget/tree-view-item.cpp	2015-09-16 13:08:13.463563358 +0900
@@ -18,12 +18,42 @@
   return *this;
 }
 
+auto mTreeViewItem::backgroundColor(bool recursive) const -> Color {
+  if(auto color = state.backgroundColor) return color;
+  if(recursive) {
+    if(auto parent = parentTreeViewItem()) {
+      if(auto color = parent->backgroundColor(true)) return color;
+    }
+    if(auto parent = parentTreeView()) {
+      if(auto color = parent->backgroundColor()) return color;
+    }
+  }
+  return {};
+}
+
+auto mTreeViewItem::checkable() const -> bool {
+  return state.checkable;
+}
+
 auto mTreeViewItem::checked() const -> bool {
   return state.checked;
 }
 
-auto mTreeViewItem::icon() const -> image {
-  return state.icon;
+auto mTreeViewItem::foregroundColor(bool recursive) const -> Color {
+  if(auto color = state.foregroundColor) return color;
+  if(recursive) {
+    if(auto parent = parentTreeViewItem()) {
+      if(auto color = parent->foregroundColor(true)) return color;
+    }
+    if(auto parent = parentTreeView()) {
+      if(auto color = parent->foregroundColor()) return color;
+    }
+  }
+  return {};
+}
+
+auto mTreeViewItem::image() const -> Image {
+  return state.image;
 }
 
 auto mTreeViewItem::item(const string& path) const -> TreeViewItem {
@@ -73,23 +103,52 @@
   return false;
 }
 
+auto mTreeViewItem::setBackgroundColor(Color color) -> type& {
+  state.backgroundColor = color;
+  signal(setBackgroundColor, color);
+  return *this;
+}
+
+auto mTreeViewItem::setCheckable(bool checkable) -> type& {
+  state.checkable = checkable;
+  signal(setCheckable, checkable);
+  return *this;
+}
+
 auto mTreeViewItem::setChecked(bool checked) -> type& {
   state.checked = checked;
   signal(setChecked, checked);
   return *this;
 }
 
+auto mTreeViewItem::setExpanded(bool expanded) -> type& {
+  signal(setExpanded, expanded);
+  return *this;
+}
+
 auto mTreeViewItem::setFocused() -> type& {
   signal(setFocused);
   return *this;
 }
 
-auto mTreeViewItem::setIcon(const image& icon) -> type& {
-  state.icon = icon;
-  signal(setIcon, icon);
+auto mTreeViewItem::setForegroundColor(Color color) -> type& {
+  state.foregroundColor = color;
+  signal(setForegroundColor, color);
   return *this;
 }
 
+auto mTreeViewItem::setImage(const Image& image) -> type& {
+  state.image = image;
+  signal(setImage, image);
+  return *this;
+}
+
+auto mTreeViewItem::setParent(mObject* parent, signed offset) -> type& {
+  for(auto n : rrange(state.items)) state.items[n]->destruct();
+  mObject::setParent(parent, offset);
+  for(auto& item : state.items) item->setParent(this, item->offset());
+}
+
 auto mTreeViewItem::setSelected() -> type& {
   signal(setSelected);
   return *this;
diff -Nru higan/hiro/core/window.cpp higan/hiro/core/window.cpp
--- higan/hiro/core/window.cpp	2015-09-16 02:20:06.383574581 +0900
+++ higan/hiro/core/window.cpp	2015-09-16 13:08:13.473563359 +0900
@@ -219,8 +219,10 @@
 }
 
 auto mWindow::setFullScreen(bool fullScreen) -> type& {
-  state.fullScreen = fullScreen;
-  signal(setFullScreen, fullScreen);
+  if(fullScreen != state.fullScreen) {
+    state.fullScreen = fullScreen;
+    signal(setFullScreen, fullScreen);
+  }
   return *this;
 }
 
diff -Nru higan/hiro/extension/browser-dialog.cpp higan/hiro/extension/browser-dialog.cpp
--- higan/hiro/extension/browser-dialog.cpp	2015-09-16 02:20:06.383574581 +0900
+++ higan/hiro/extension/browser-dialog.cpp	2015-09-16 13:08:13.485563361 +0900
@@ -118,9 +118,9 @@
 
   layout.setMargin(5);
   pathName.onActivate([&] { setPath(pathName.text()); });
-  pathHome.setBordered(false).setIcon(Icon::Go::Home).onActivate([&] { setPath(userpath()); });
-  pathRefresh.setBordered(false).setIcon(Icon::Action::Refresh).onActivate([&] { setPath(state.path); });
-  pathUp.setBordered(false).setIcon(Icon::Go::Up).onActivate([&] { setPath(state.path.dirname()); });
+  pathHome.setBordered(false).setImage(Icon::Go::Home).onActivate([&] { setPath(userpath()); });
+  pathRefresh.setBordered(false).setImage(Icon::Action::Refresh).onActivate([&] { setPath(state.path); });
+  pathUp.setBordered(false).setImage(Icon::Go::Up).onActivate([&] { setPath(state.path.dirname()); });
   view.setBatchable(state.action == "openFiles").onActivate([&] { activate(); }).onChange([&] { change(); });
   filterList.setVisible(state.action != "selectFolder").onChange([&] { setPath(state.path); });
   for(auto& filter : state.filters) {
@@ -175,7 +175,7 @@
     if(folderMode && isMatch(content)) continue;
 
     view.append(ListViewItem()
-      .append(ListViewCell().setText(content).setIcon(Icon::Emblem::Folder))
+      .append(ListViewCell().setText(content).setImage(Icon::Emblem::Folder))
     );
   }
 
@@ -185,7 +185,7 @@
     if(!isMatch(content)) continue;
 
     view.append(ListViewItem()
-      .append(ListViewCell().setText(content).setIcon(folderMode ? Icon::Action::Open : Icon::Emblem::File))
+      .append(ListViewCell().setText(content).setImage(folderMode ? Icon::Action::Open : Icon::Emblem::File))
     );
   }
 
diff -Nru higan/hiro/extension/fixed-layout.cpp higan/hiro/extension/fixed-layout.cpp
--- higan/hiro/extension/fixed-layout.cpp	2015-09-16 02:20:06.383574581 +0900
+++ higan/hiro/extension/fixed-layout.cpp	2015-09-16 13:08:13.485563361 +0900
@@ -7,6 +7,14 @@
   return *this;
 }
 
+auto mFixedLayout::modify(sSizable sizable, Geometry geometry) -> type& {
+  if(sizable && this->sizable(sizable->offset()) == sizable) {
+    auto& properties = this->properties[sizable->offset()];
+    properties.geometry = geometry;
+  }
+  return *this;
+}
+
 auto mFixedLayout::minimumSize() const -> Size {
   signed width = Size::Minimum, height = Size::Minimum;
   for(auto n : range(sizableCount())) {
@@ -36,7 +44,7 @@
   return *this;
 }
 
-auto mFixedLayout::setFont(const string& font) -> type& {
+auto mFixedLayout::setFont(const Font& font) -> type& {
   mLayout::setFont(font);
   for(auto n : range(sizableCount())) {
     sizable(n)->setFont(sizable(n)->font());
diff -Nru higan/hiro/extension/fixed-layout.hpp higan/hiro/extension/fixed-layout.hpp
--- higan/hiro/extension/fixed-layout.hpp	2015-09-16 02:20:06.383574581 +0900
+++ higan/hiro/extension/fixed-layout.hpp	2015-09-16 13:08:13.484563361 +0900
@@ -6,11 +6,12 @@
   using mLayout::remove;
 
   auto append(sSizable sizable, Geometry geometry) -> type&;
+  auto modify(sSizable sizable, Geometry geometry) -> type&;
   auto minimumSize() const -> Size override;
   auto remove(sSizable sizable) -> type& override;
   auto reset() -> type& override;
   auto setEnabled(bool enabled = true) -> type& override;
-  auto setFont(const string& font = "") -> type& override;
+  auto setFont(const Font& font = {}) -> type& override;
   auto setVisible(bool visible = true) ->type& override;
 
   struct Properties {
diff -Nru higan/hiro/extension/horizontal-layout.cpp higan/hiro/extension/horizontal-layout.cpp
--- higan/hiro/extension/horizontal-layout.cpp	2015-09-16 02:20:06.383574581 +0900
+++ higan/hiro/extension/horizontal-layout.cpp	2015-09-16 13:08:13.483563360 +0900
@@ -6,6 +6,16 @@
   return *this;
 }
 
+auto mHorizontalLayout::modify(sSizable sizable, Size size, signed spacing) -> type& {
+  if(sizable && this->sizable(sizable->offset()) == sizable) {
+    auto& properties = this->properties[sizable->offset()];
+    properties.width = size.width();
+    properties.height = size.height();
+    properties.spacing = spacing;
+  }
+  return *this;
+}
+
 auto mHorizontalLayout::minimumSize() const -> Size {
   signed width = 0, height = 0;
 
@@ -56,7 +66,7 @@
   return *this;
 }
 
-auto mHorizontalLayout::setFont(const string& font) -> type& {
+auto mHorizontalLayout::setFont(const Font& font) -> type& {
   mLayout::setFont(font);
   for(auto n : range(sizableCount())) {
     sizable(n)->setFont(sizable(n)->font());
diff -Nru higan/hiro/extension/horizontal-layout.hpp higan/hiro/extension/horizontal-layout.hpp
--- higan/hiro/extension/horizontal-layout.hpp	2015-09-16 02:20:06.383574581 +0900
+++ higan/hiro/extension/horizontal-layout.hpp	2015-09-16 13:08:13.483563360 +0900
@@ -7,11 +7,12 @@
 
   auto append(sSizable sizable, Size size, signed spacing = 5) -> type&;
   auto minimumSize() const -> Size override;
+  auto modify(sSizable sizable, Size size, signed spacing = 5) -> type&;
   auto remove(sSizable sizable) -> type& override;
   auto reset() -> type& override;
   auto setAlignment(double alignment = 0.5) -> type&;
   auto setEnabled(bool enabled = true) -> type& override;
-  auto setFont(const string& font = "") -> type& override;
+  auto setFont(const Font& font = {}) -> type& override;
   auto setGeometry(Geometry geometry) -> type& override;
   auto setMargin(signed margin = 0) -> type&;
   auto setSpacing(signed spacing = 5) -> type&;
diff -Nru higan/hiro/extension/message-dialog.cpp higan/hiro/extension/message-dialog.cpp
--- higan/hiro/extension/message-dialog.cpp	2015-09-16 02:20:06.383574581 +0900
+++ higan/hiro/extension/message-dialog.cpp	2015-09-16 13:08:13.484563361 +0900
@@ -6,19 +6,19 @@
 
 auto MessageDialog::error(const lstring& buttons) -> string {
   state.buttons = buttons;
-  state.icon = Icon::Prompt::Error;
+  state.image = Icon::Prompt::Error;
   return _run();
 }
 
 auto MessageDialog::information(const lstring& buttons) -> string {
   state.buttons = buttons;
-  state.icon = Icon::Prompt::Information;
+  state.image = Icon::Prompt::Information;
   return _run();
 }
 
 auto MessageDialog::question(const lstring& buttons) -> string {
   state.buttons = buttons;
-  state.icon = Icon::Prompt::Question;
+  state.image = Icon::Prompt::Question;
   return _run();
 }
 
@@ -39,7 +39,7 @@
 
 auto MessageDialog::warning(const lstring& buttons) -> string {
   state.buttons = buttons;
-  state.icon = Icon::Prompt::Warning;
+  state.image = Icon::Prompt::Warning;
   return _run();
 }
 
@@ -53,7 +53,7 @@
         Widget controlSpacer{&controlLayout, Size{~0, 0}};
 
   layout.setMargin(5);
-  messageIcon.setIcon(state.icon);
+  messageIcon.setImage(state.image);
   messageText.setText(state.text);
   for(auto n : range(state.buttons)) {
     Button button{&controlLayout, Size{80, 0}, 5};
@@ -62,7 +62,7 @@
     button.setFocused();  //the last button will have effective focus
   }
 
-  signed widthMessage = 5 + 16 + 5 + Font::size(Font::sans(), state.text).width() + 5;
+  signed widthMessage = 5 + 16 + 5 + Font().size(state.text).width() + 5;
   signed widthButtons = 5 + state.buttons.size() * 85;
   signed width = max(320, widthMessage, widthButtons);
 
diff -Nru higan/hiro/extension/message-dialog.hpp higan/hiro/extension/message-dialog.hpp
--- higan/hiro/extension/message-dialog.hpp	2015-09-16 02:20:06.383574581 +0900
+++ higan/hiro/extension/message-dialog.hpp	2015-09-16 13:08:13.483563360 +0900
@@ -15,7 +15,7 @@
 private:
   struct State {
     lstring buttons;
-    vector<uint8_t> icon;
+    vector<uint8_t> image;
     sWindow parent;
     string response;
     string text;
diff -Nru higan/hiro/extension/shared.hpp higan/hiro/extension/shared.hpp
--- higan/hiro/extension/shared.hpp	2015-09-16 02:20:06.383574581 +0900
+++ higan/hiro/extension/shared.hpp	2015-09-16 13:08:13.483563360 +0900
@@ -4,6 +4,7 @@
   DeclareSharedLayout(FixedLayout)
 
   auto append(sSizable sizable, Geometry geometry) { return self().append(sizable, geometry), *this; }
+  auto modify(sSizable sizable, Geometry geometry) { return self().modify(sizable, geometry), *this; }
 };
 #endif
 
@@ -13,6 +14,7 @@
   DeclareSharedLayout(HorizontalLayout)
 
   auto append(sSizable sizable, Size size, signed spacing = 5) { return self().append(sizable, size, spacing), *this; }
+  auto modify(sSizable sizable, Size size, signed spacing = 5) { return self().modify(sizable, size, spacing), *this; }
   auto setAlignment(double alignment = 0.5) { return self().setAlignment(alignment), *this; }
   auto setMargin(signed margin = 0) { return self().setMargin(margin), *this; }
   auto setSpacing(signed spacing = 5) { return self().setSpacing(spacing), *this; }
@@ -25,6 +27,7 @@
   DeclareSharedLayout(VerticalLayout)
 
   auto append(sSizable sizable, Size size, signed spacing = 5) { return self().append(sizable, size, spacing), *this; }
+  auto modify(sSizable sizable, Size size, signed spacing = 5) { return self().modify(sizable, size, spacing), *this; }
   auto setAlignment(double alignment = 0.0) { return self().setAlignment(alignment), *this; }
   auto setMargin(signed margin = 0) { return self().setMargin(margin), *this; }
   auto setSpacing(signed spacing = 5) { return self().setSpacing(spacing), *this; }
diff -Nru higan/hiro/extension/vertical-layout.cpp higan/hiro/extension/vertical-layout.cpp
--- higan/hiro/extension/vertical-layout.cpp	2015-09-16 02:20:06.383574581 +0900
+++ higan/hiro/extension/vertical-layout.cpp	2015-09-16 13:08:13.484563361 +0900
@@ -6,6 +6,16 @@
   return *this;
 }
 
+auto mVerticalLayout::modify(sSizable sizable, Size size, signed spacing) -> type& {
+  if(sizable && this->sizable(sizable->offset()) == sizable) {
+    auto& properties = this->properties[sizable->offset()];
+    properties.width = size.width();
+    properties.height = size.height();
+    properties.spacing = spacing;
+  }
+  return *this;
+}
+
 auto mVerticalLayout::minimumSize() const -> Size {
   signed width = 0, height = 0;
 
@@ -56,7 +66,7 @@
   return *this;
 }
 
-auto mVerticalLayout::setFont(const string& font) -> type& {
+auto mVerticalLayout::setFont(const Font& font) -> type& {
   mLayout::setFont(font);
   for(auto n : range(sizableCount())) {
     sizable(n)->setFont(sizable(n)->font());
diff -Nru higan/hiro/extension/vertical-layout.hpp higan/hiro/extension/vertical-layout.hpp
--- higan/hiro/extension/vertical-layout.hpp	2015-09-16 02:20:06.383574581 +0900
+++ higan/hiro/extension/vertical-layout.hpp	2015-09-16 13:08:13.484563361 +0900
@@ -6,12 +6,13 @@
   using mLayout::remove;
 
   auto append(sSizable sizable, Size size, signed spacing = 5) -> type&;
+  auto modify(sSizable sizable, Size size, signed spacing = 5) -> type&;
   auto minimumSize() const -> Size override;
   auto remove(sSizable sizable) -> type& override;
   auto reset() -> type& override;
   auto setAlignment(double alignment = 0.0) -> type&;
   auto setEnabled(bool enabled = true) -> type& override;
-  auto setFont(const string& font = "") -> type& override;
+  auto setFont(const Font& font = {}) -> type& override;
   auto setGeometry(Geometry geometry) -> type& override;
   auto setMargin(signed margin = 0) -> type&;
   auto setSpacing(signed spacing = 5) -> type&;
diff -Nru higan/hiro/gtk/action/action.cpp higan/hiro/gtk/action/action.cpp
--- higan/hiro/gtk/action/action.cpp	2015-09-16 02:20:06.383574581 +0900
+++ higan/hiro/gtk/action/action.cpp	2015-09-16 13:08:13.419563354 +0900
@@ -12,7 +12,7 @@
   gtk_widget_set_sensitive(widget, enabled);
 }
 
-auto pAction::setFont(const string& font) -> void {
+auto pAction::setFont(const Font& font) -> void {
   pFont::setFont(widget, font);
 }
 
diff -Nru higan/hiro/gtk/action/action.hpp higan/hiro/gtk/action/action.hpp
--- higan/hiro/gtk/action/action.hpp	2015-09-16 02:20:06.383574581 +0900
+++ higan/hiro/gtk/action/action.hpp	2015-09-16 13:08:13.418563354 +0900
@@ -6,7 +6,7 @@
   Declare(Action, Object)
 
   auto setEnabled(bool enabled) -> void override;
-  auto setFont(const string& font) -> void override;
+  auto setFont(const Font& font) -> void override;
   auto setVisible(bool visible) -> void override;
 
   auto _mnemonic(string text) -> string;
diff -Nru higan/hiro/gtk/action/menu.cpp higan/hiro/gtk/action/menu.cpp
--- higan/hiro/gtk/action/menu.cpp	2015-09-16 02:20:06.383574581 +0900
+++ higan/hiro/gtk/action/menu.cpp	2015-09-16 13:08:13.420563354 +0900
@@ -6,6 +6,7 @@
   gtkMenu = gtk_menu_new();
   widget = gtk_image_menu_item_new_with_mnemonic("");
   gtk_menu_item_set_submenu(GTK_MENU_ITEM(widget), gtkMenu);
+  setImage(state().image);
   setText(state().text);
 
   for(auto& action : state().actions) append(*action);
@@ -27,16 +28,16 @@
 auto pMenu::remove(sAction action) -> void {
 }
 
-auto pMenu::setFont(const string& font) -> void {
+auto pMenu::setFont(const Font& font) -> void {
   pAction::setFont(font);
   for(auto& action : state().actions) {
     if(action->self()) action->self()->setFont(action->font(true));
   }
 }
 
-auto pMenu::setIcon(const image& icon) -> void {
-  if(icon) {
-    GtkImage* gtkImage = CreateImage(icon, true);
+auto pMenu::setImage(const Image& image) -> void {
+  if(image) {
+    GtkImage* gtkImage = CreateImage(image, true);
     gtk_image_menu_item_set_image(GTK_IMAGE_MENU_ITEM(widget), (GtkWidget*)gtkImage);
   } else {
     gtk_image_menu_item_set_image(GTK_IMAGE_MENU_ITEM(widget), nullptr);
diff -Nru higan/hiro/gtk/action/menu.hpp higan/hiro/gtk/action/menu.hpp
--- higan/hiro/gtk/action/menu.hpp	2015-09-16 02:20:06.383574581 +0900
+++ higan/hiro/gtk/action/menu.hpp	2015-09-16 13:08:13.419563354 +0900
@@ -7,8 +7,8 @@
 
   auto append(sAction action) -> void;
   auto remove(sAction action) -> void;
-  auto setFont(const string& font) -> void override;
-  auto setIcon(const image& icon) -> void;
+  auto setFont(const Font& font) -> void override;
+  auto setImage(const Image& image) -> void;
   auto setText(const string& text) -> void;
 
   GtkWidget* gtkMenu = nullptr;
diff -Nru higan/hiro/gtk/action/menu-item.cpp higan/hiro/gtk/action/menu-item.cpp
--- higan/hiro/gtk/action/menu-item.cpp	2015-09-16 02:20:06.383574581 +0900
+++ higan/hiro/gtk/action/menu-item.cpp	2015-09-16 13:08:13.419563354 +0900
@@ -9,6 +9,7 @@
 auto pMenuItem::construct() -> void {
   widget = gtk_image_menu_item_new_with_mnemonic("");
   g_signal_connect(G_OBJECT(widget), "activate", G_CALLBACK(MenuItem_activate), (gpointer)this);
+  setImage(state().image);
   setText(state().text);
 }
 
@@ -16,9 +17,9 @@
   if(widget) gtk_widget_destroy(widget), widget = nullptr;
 }
 
-auto pMenuItem::setIcon(const image& icon) -> void {
-  if(icon) {
-    GtkImage* gtkImage = CreateImage(icon, true);
+auto pMenuItem::setImage(const Image& image) -> void {
+  if(image) {
+    GtkImage* gtkImage = CreateImage(image, true);
     gtk_image_menu_item_set_image(GTK_IMAGE_MENU_ITEM(widget), (GtkWidget*)gtkImage);
   } else {
     gtk_image_menu_item_set_image(GTK_IMAGE_MENU_ITEM(widget), nullptr);
diff -Nru higan/hiro/gtk/action/menu-item.hpp higan/hiro/gtk/action/menu-item.hpp
--- higan/hiro/gtk/action/menu-item.hpp	2015-09-16 02:20:06.383574581 +0900
+++ higan/hiro/gtk/action/menu-item.hpp	2015-09-16 13:08:13.418563354 +0900
@@ -5,7 +5,7 @@
 struct pMenuItem : pAction {
   Declare(MenuItem, Action)
 
-  auto setIcon(const image& icon) -> void;
+  auto setImage(const Image& image) -> void;
   auto setText(const string& text) -> void;
 };
 
diff -Nru higan/hiro/gtk/action/menu-radio-item.cpp higan/hiro/gtk/action/menu-radio-item.cpp
--- higan/hiro/gtk/action/menu-radio-item.cpp	2015-09-16 02:20:06.383574581 +0900
+++ higan/hiro/gtk/action/menu-radio-item.cpp	2015-09-16 13:08:13.419563354 +0900
@@ -27,8 +27,6 @@
 }
 
 auto pMenuRadioItem::setGroup(sGroup group) -> void {
-  if(!group) return;
-
   maybe<GtkRadioMenuItem*> gtkRadioMenuItem;
   for(auto& weak : group->state.objects) {
     if(auto object = weak.acquire()) {
@@ -36,9 +34,13 @@
         if(auto self = menuRadioItem->self()) {
           self->lock();
           gtk_radio_menu_item_set_group(self->gtkRadioMenuItem, nullptr);
-          if(!gtkRadioMenuItem) gtkRadioMenuItem = self->gtkRadioMenuItem;
-          else gtk_radio_menu_item_set_group(self->gtkRadioMenuItem, gtk_radio_menu_item_get_group(*gtkRadioMenuItem));
-          gtk_check_menu_item_set_active(self->gtkCheckMenuItem, menuRadioItem->checked());
+          if(!gtkRadioMenuItem) {
+            gtkRadioMenuItem = self->gtkRadioMenuItem;
+            gtk_check_menu_item_set_active(self->gtkCheckMenuItem, menuRadioItem->state.checked = true);
+          } else {
+            gtk_radio_menu_item_set_group(self->gtkRadioMenuItem, gtk_radio_menu_item_get_group(*gtkRadioMenuItem));
+            gtk_check_menu_item_set_active(self->gtkCheckMenuItem, menuRadioItem->state.checked = false);
+          }
           self->unlock();
         }
       }
diff -Nru higan/hiro/gtk/font.cpp higan/hiro/gtk/font.cpp
--- higan/hiro/gtk/font.cpp	2015-09-16 02:20:06.384574581 +0900
+++ higan/hiro/gtk/font.cpp	2015-09-16 13:08:13.433563355 +0900
@@ -2,67 +2,45 @@
 
 namespace hiro {
 
-auto pFont::serif(unsigned size, string style) -> string {
-  if(size == 0) size = 8;
-  if(style == "") style = "Normal";
-  return {"Serif, ", size, ", ", style};
-}
-
-auto pFont::sans(unsigned size, string style) -> string {
-  if(size == 0) size = 8;
-  if(style == "") style = "Normal";
-  return {"Sans, ", size, ", ", style};
-}
-
-auto pFont::monospace(unsigned size, string style) -> string {
-  if(size == 0) size = 8;
-  return {"Liberation Mono, ", size, ", ", style};
-}
-
-auto pFont::size(string font, string text) -> Size {
+auto pFont::size(const Font& font, const string& text) -> Size {
   PangoFontDescription* description = create(font);
   Size size = pFont::size(description, text);
   free(description);
   return size;
 }
 
-auto pFont::create(string description) -> PangoFontDescription* {
-  lstring part = description.split(",", 2L).strip();
-
-  string family = "Sans";
-  unsigned size = 8u;
-  bool bold = false;
-  bool italic = false;
-
-  if(part[0] != "") family = part[0];
-  if(part.size() >= 2) size = decimal(part[1]);
-  if(part.size() >= 3) bold = (bool)part[2].find("Bold");
-  if(part.size() >= 3) italic = (bool)part[2].find("Italic");
-
-  PangoFontDescription* font = pango_font_description_new();
-  pango_font_description_set_family(font, family);
-  pango_font_description_set_size(font, size * PANGO_SCALE);
-  pango_font_description_set_weight(font, !bold ? PANGO_WEIGHT_NORMAL : PANGO_WEIGHT_BOLD);
-  pango_font_description_set_style(font, !italic ? PANGO_STYLE_NORMAL : PANGO_STYLE_OBLIQUE);
-  return font;
-}
-
-auto pFont::free(PangoFontDescription* font) -> void {
-  pango_font_description_free(font);
-}
-
-auto pFont::size(PangoFontDescription* font, string text) -> Size {
+auto pFont::size(PangoFontDescription* font, const string& text) -> Size {
   PangoContext* context = gdk_pango_context_get_for_screen(gdk_screen_get_default());
   PangoLayout* layout = pango_layout_new(context);
   pango_layout_set_font_description(layout, font);
   pango_layout_set_text(layout, text, -1);
-  int width = 0, height = 0;
+  signed width = 0, height = 0;
   pango_layout_get_pixel_size(layout, &width, &height);
   g_object_unref((gpointer)layout);
   return {width, height};
 }
 
-auto pFont::setFont(GtkWidget* widget, string font) -> void {
+auto pFont::family(const string& family) -> string {
+  if(family == "sans") return "Sans";
+  if(family == "serif") return "Serif";
+  if(family == "mono") return "Liberation Mono";
+  return family ? family : "Sans";
+}
+
+auto pFont::create(const Font& font) -> PangoFontDescription* {
+  auto p = pango_font_description_new();
+  pango_font_description_set_family(p, family(font.family()));
+  pango_font_description_set_size(p, (font.size() ? font.size() : 8) * PANGO_SCALE);
+  pango_font_description_set_weight(p, font.bold() ? PANGO_WEIGHT_BOLD : PANGO_WEIGHT_NORMAL);
+  pango_font_description_set_style(p, font.italic() ? PANGO_STYLE_OBLIQUE : PANGO_STYLE_NORMAL);
+  return p;
+}
+
+auto pFont::free(PangoFontDescription* font) -> void {
+  pango_font_description_free(font);
+}
+
+auto pFont::setFont(GtkWidget* widget, const Font& font) -> void {
   auto gtkFont = pFont::create(font);
   pFont::setFont(widget, (gpointer)gtkFont);
   pFont::free(gtkFont);
diff -Nru higan/hiro/gtk/font.hpp higan/hiro/gtk/font.hpp
--- higan/hiro/gtk/font.hpp	2015-09-16 02:20:06.384574581 +0900
+++ higan/hiro/gtk/font.hpp	2015-09-16 13:08:13.420563354 +0900
@@ -3,15 +3,12 @@
 namespace hiro {
 
 struct pFont {
-  static auto serif(unsigned size, string style) -> string;
-  static auto sans(unsigned size, string style) -> string;
-  static auto monospace(unsigned size, string style) -> string;
-  static auto size(string font, string text) -> Size;
-
-  static auto create(string description) -> PangoFontDescription*;
+  static auto size(const Font& font, const string& text) -> Size;
+  static auto size(PangoFontDescription* font, const string& text) -> Size;
+  static auto family(const string& family) -> string;
+  static auto create(const Font& font) -> PangoFontDescription*;
   static auto free(PangoFontDescription* font) -> void;
-  static auto size(PangoFontDescription* font, string text) -> Size;
-  static auto setFont(GtkWidget* widget, string font) -> void;
+  static auto setFont(GtkWidget* widget, const Font& font) -> void;
   static auto setFont(GtkWidget* widget, gpointer font) -> void;
 };
 
diff -Nru higan/hiro/gtk/hotkey.cpp higan/hiro/gtk/hotkey.cpp
--- higan/hiro/gtk/hotkey.cpp	2015-09-16 02:20:06.384574581 +0900
+++ higan/hiro/gtk/hotkey.cpp	1970-01-01 09:00:00.000000000 +0900
@@ -1,13 +0,0 @@
-#if defined(Hiro_Hotkey)
-
-namespace hiro {
-
-auto pHotkey::construct() -> void {
-}
-
-auto pHotkey::destruct() -> void {
-}
-
-}
-
-#endif
diff -Nru higan/hiro/gtk/hotkey.hpp higan/hiro/gtk/hotkey.hpp
--- higan/hiro/gtk/hotkey.hpp	2015-09-16 02:20:06.384574581 +0900
+++ higan/hiro/gtk/hotkey.hpp	1970-01-01 09:00:00.000000000 +0900
@@ -1,11 +0,0 @@
-#if defined(Hiro_Hotkey)
-
-namespace hiro {
-
-struct pHotkey : pObject {
-  Declare(Hotkey, Object)
-};
-
-}
-
-#endif
diff -Nru higan/hiro/gtk/layout.cpp higan/hiro/gtk/layout.cpp
--- higan/hiro/gtk/layout.cpp	2015-09-16 02:20:06.384574581 +0900
+++ higan/hiro/gtk/layout.cpp	2015-09-16 13:08:13.437563356 +0900
@@ -13,7 +13,7 @@
 auto pLayout::setEnabled(bool enabled) -> void {
 }
 
-auto pLayout::setFont(const string& font) -> void {
+auto pLayout::setFont(const Font& font) -> void {
 }
 
 auto pLayout::setVisible(bool visible) -> void {
diff -Nru higan/hiro/gtk/layout.hpp higan/hiro/gtk/layout.hpp
--- higan/hiro/gtk/layout.hpp	2015-09-16 02:20:06.384574581 +0900
+++ higan/hiro/gtk/layout.hpp	2015-09-16 13:08:13.437563356 +0900
@@ -6,7 +6,7 @@
   Declare(Layout, Sizable)
 
   auto setEnabled(bool enabled) -> void override;
-  auto setFont(const string& font) -> void override;
+  auto setFont(const Font& font) -> void override;
   auto setVisible(bool visible) -> void override;
 };
 
diff -Nru higan/hiro/gtk/menu-bar.cpp higan/hiro/gtk/menu-bar.cpp
--- higan/hiro/gtk/menu-bar.cpp	2015-09-16 02:20:06.384574581 +0900
+++ higan/hiro/gtk/menu-bar.cpp	2015-09-16 13:08:13.436563356 +0900
@@ -27,7 +27,7 @@
   }
 }
 
-auto pMenuBar::setFont(const string& font) -> void {
+auto pMenuBar::setFont(const Font& font) -> void {
   if(auto parent = _parent()) {
     parent->_setMenuFont(font);
   }
diff -Nru higan/hiro/gtk/menu-bar.hpp higan/hiro/gtk/menu-bar.hpp
--- higan/hiro/gtk/menu-bar.hpp	2015-09-16 02:20:06.384574581 +0900
+++ higan/hiro/gtk/menu-bar.hpp	2015-09-16 13:08:13.437563356 +0900
@@ -8,7 +8,7 @@
   auto append(sMenu menu) -> void;
   auto remove(sMenu menu) -> void;
   auto setEnabled(bool enabled) -> void override;
-  auto setFont(const string& font) -> void override;
+  auto setFont(const Font& font) -> void override;
   auto setVisible(bool visible) -> void override;
 
   auto _parent() -> pWindow*;
diff -Nru higan/hiro/gtk/object.cpp higan/hiro/gtk/object.cpp
--- higan/hiro/gtk/object.cpp	2015-09-16 02:20:06.384574581 +0900
+++ higan/hiro/gtk/object.cpp	2015-09-16 13:08:13.418563354 +0900
@@ -24,7 +24,7 @@
 auto pObject::setFocused() -> void {
 }
 
-auto pObject::setFont(const string& font) -> void {
+auto pObject::setFont(const Font& font) -> void {
 }
 
 auto pObject::setVisible(bool visible) -> void {
diff -Nru higan/hiro/gtk/object.hpp higan/hiro/gtk/object.hpp
--- higan/hiro/gtk/object.hpp	2015-09-16 02:20:06.384574581 +0900
+++ higan/hiro/gtk/object.hpp	2015-09-16 13:08:13.420563354 +0900
@@ -15,7 +15,7 @@
   virtual auto reset() -> void;
   virtual auto setEnabled(bool enabled) -> void;
   virtual auto setFocused() -> void;
-  virtual auto setFont(const string& font) -> void;
+  virtual auto setFont(const Font& font) -> void;
   virtual auto setVisible(bool visible) -> void;
 
   auto locked() const -> bool { return locks != 0; }
diff -Nru higan/hiro/gtk/platform.cpp higan/hiro/gtk/platform.cpp
--- higan/hiro/gtk/platform.cpp	2015-09-16 02:20:06.384574581 +0900
+++ higan/hiro/gtk/platform.cpp	2015-09-16 13:08:13.437563356 +0900
@@ -12,7 +12,6 @@
 #include "object.cpp"
 #include "group.cpp"
 
-#include "hotkey.cpp"
 #include "timer.cpp"
 #include "window.cpp"
 #include "status-bar.cpp"
diff -Nru higan/hiro/gtk/platform.hpp higan/hiro/gtk/platform.hpp
--- higan/hiro/gtk/platform.hpp	2015-09-16 02:20:06.384574581 +0900
+++ higan/hiro/gtk/platform.hpp	2015-09-16 13:08:13.420563354 +0900
@@ -23,7 +23,6 @@
 #include "object.hpp"
 #include "group.hpp"
 
-#include "hotkey.hpp"
 #include "timer.hpp"
 #include "window.hpp"
 #include "status-bar.hpp"
diff -Nru higan/hiro/gtk/popup-menu.cpp higan/hiro/gtk/popup-menu.cpp
--- higan/hiro/gtk/popup-menu.cpp	2015-09-16 02:20:06.384574581 +0900
+++ higan/hiro/gtk/popup-menu.cpp	2015-09-16 13:08:13.436563356 +0900
@@ -21,7 +21,7 @@
 auto pPopupMenu::remove(sAction action) -> void {
 }
 
-auto pPopupMenu::setFont(const string& font) -> void {
+auto pPopupMenu::setFont(const Font& font) -> void {
   for(auto& action : state().actions) {
     if(action->self()) action->self()->setFont(action->font(true));
   }
diff -Nru higan/hiro/gtk/popup-menu.hpp higan/hiro/gtk/popup-menu.hpp
--- higan/hiro/gtk/popup-menu.hpp	2015-09-16 02:20:06.384574581 +0900
+++ higan/hiro/gtk/popup-menu.hpp	2015-09-16 13:08:13.434563355 +0900
@@ -7,7 +7,7 @@
 
   auto append(sAction action) -> void;
   auto remove(sAction action) -> void;
-  auto setFont(const string& font) -> void override;
+  auto setFont(const Font& font) -> void override;
   auto setVisible(bool visible) -> void;
 
   GtkWidget* gtkMenu = nullptr;
diff -Nru higan/hiro/gtk/status-bar.cpp higan/hiro/gtk/status-bar.cpp
--- higan/hiro/gtk/status-bar.cpp	2015-09-16 02:20:06.384574581 +0900
+++ higan/hiro/gtk/status-bar.cpp	2015-09-16 13:08:13.433563355 +0900
@@ -14,7 +14,7 @@
   }
 }
 
-auto pStatusBar::setFont(const string& font) -> void {
+auto pStatusBar::setFont(const Font& font) -> void {
   if(auto parent = _parent()) {
     parent->_setStatusFont(font);
   }
diff -Nru higan/hiro/gtk/status-bar.hpp higan/hiro/gtk/status-bar.hpp
--- higan/hiro/gtk/status-bar.hpp	2015-09-16 02:20:06.384574581 +0900
+++ higan/hiro/gtk/status-bar.hpp	2015-09-16 13:08:13.433563355 +0900
@@ -6,7 +6,7 @@
   Declare(StatusBar, Object)
 
   auto setEnabled(bool enabled) -> void override;
-  auto setFont(const string& font) -> void override;
+  auto setFont(const Font& font) -> void override;
   auto setText(const string& text) -> void;
   auto setVisible(bool visible) -> void override;
 
diff -Nru higan/hiro/gtk/utility.cpp higan/hiro/gtk/utility.cpp
--- higan/hiro/gtk/utility.cpp	2015-09-16 02:20:06.384574581 +0900
+++ higan/hiro/gtk/utility.cpp	2015-09-16 13:08:13.438563356 +0900
@@ -20,6 +20,34 @@
   auto pixbuf = gdk_pixbuf_new(GDK_COLORSPACE_RGB, true, 8, icon.width(), icon.height());
   memory::copy(gdk_pixbuf_get_pixels(pixbuf), icon.data(), icon.size());
 
+  if(scale) {
+    auto scaled = gdk_pixbuf_scale_simple(pixbuf, 15, 15, GDK_INTERP_BILINEAR);
+    g_object_unref(pixbuf);
+    pixbuf = scaled;
+  }
+
+  return pixbuf;
+}
+
+static auto CreatePixbuf(const Image& image, bool scale = false) -> GdkPixbuf* {
+  if(!image.state.data) return nullptr;
+
+  auto pixbuf = gdk_pixbuf_new(GDK_COLORSPACE_RGB, true, 8, image.width(), image.height());
+
+  //ARGB -> ABGR conversion
+  const uint32_t* source = image.data();
+  uint32_t* target = (uint32_t*)gdk_pixbuf_get_pixels(pixbuf);
+  for(auto n : range(image.width() * image.height())) {
+    uint32_t pixel = *source++;
+    *target++ = (pixel & 0x00ff0000) >> 16 | (pixel & 0xff00ff00) | (pixel & 0x000000ff) << 16;
+  }
+
+  if(scale) {
+    auto scaled = gdk_pixbuf_scale_simple(pixbuf, 15, 15, GDK_INTERP_BILINEAR);
+    g_object_unref(pixbuf);
+    pixbuf = scaled;
+  }
+
   return pixbuf;
 }
 
@@ -27,6 +55,13 @@
   auto pixbuf = CreatePixbuf(image, scale);
   auto gtkImage = (GtkImage*)gtk_image_new_from_pixbuf(pixbuf);
   g_object_unref(pixbuf);
+  return gtkImage;
+}
+
+static auto CreateImage(const Image& image, bool scale = false) -> GtkImage* {
+  auto pixbuf = CreatePixbuf(image, scale);
+  auto gtkImage = (GtkImage*)gtk_image_new_from_pixbuf(pixbuf);
+  g_object_unref(pixbuf);
   return gtkImage;
 }
 
diff -Nru higan/hiro/gtk/widget/button.cpp higan/hiro/gtk/widget/button.cpp
--- higan/hiro/gtk/widget/button.cpp	2015-09-16 02:20:06.385574582 +0900
+++ higan/hiro/gtk/widget/button.cpp	2015-09-16 13:08:13.421563354 +0900
@@ -9,7 +9,7 @@
   gtkButton = GTK_BUTTON(gtkWidget);
 
   setBordered(state().bordered);
-  setIcon(state().icon);
+  setImage(state().image);
   setOrientation(state().orientation);
   setText(state().text);
 
@@ -26,13 +26,13 @@
   Size size = pFont::size(self().font(true), state().text);
 
   if(state().orientation == Orientation::Horizontal) {
-    size.setWidth(size.width() + state().icon.width());
-    size.setHeight(max(size.height(), state().icon.height()));
+    size.setWidth(size.width() + state().image.width());
+    size.setHeight(max(size.height(), state().image.height()));
   }
 
   if(state().orientation == Orientation::Vertical) {
-    size.setWidth(max(size.width(), state().icon.width()));
-    size.setHeight(size.height() + state().icon.height());
+    size.setWidth(max(size.width(), state().image.width()));
+    size.setHeight(size.height() + state().image.height());
   }
 
   return {size.width() + (state().text ? 24 : 12), size.height() + 12};
@@ -42,9 +42,9 @@
   gtk_button_set_relief(gtkButton, bordered ? GTK_RELIEF_NORMAL : GTK_RELIEF_NONE);
 }
 
-auto pButton::setIcon(const image& icon) -> void {
-  if(icon) {
-    auto gtkImage = CreateImage(icon);
+auto pButton::setImage(const Image& image) -> void {
+  if(image) {
+    auto gtkImage = CreateImage(image);
     gtk_button_set_image(gtkButton, (GtkWidget*)gtkImage);
   } else {
     gtk_button_set_image(gtkButton, nullptr);
diff -Nru higan/hiro/gtk/widget/button.hpp higan/hiro/gtk/widget/button.hpp
--- higan/hiro/gtk/widget/button.hpp	2015-09-16 02:20:06.385574582 +0900
+++ higan/hiro/gtk/widget/button.hpp	2015-09-16 13:08:13.422563354 +0900
@@ -7,7 +7,7 @@
 
   auto minimumSize() const -> Size override;
   auto setBordered(bool bordered) -> void;
-  auto setIcon(const image& icon) -> void;
+  auto setImage(const Image& image) -> void;
   auto setOrientation(Orientation orientation) -> void;
   auto setText(const string& text) -> void;
 
diff -Nru higan/hiro/gtk/widget/canvas.cpp higan/hiro/gtk/widget/canvas.cpp
--- higan/hiro/gtk/widget/canvas.cpp	2015-09-16 02:20:06.385574582 +0900
+++ higan/hiro/gtk/widget/canvas.cpp	2015-09-16 13:08:13.423563354 +0900
@@ -73,16 +73,11 @@
 }
 
 auto pCanvas::minimumSize() const -> Size {
-  return {max(0, state().size.width()), max(0, state().size.height())};
+  if(auto& image = state().image) return image.size();
+  return {0, 0};
 }
 
 auto pCanvas::setColor(Color color) -> void {
-  mode = Mode::Color;
-  update();
-}
-
-auto pCanvas::setData(Size size) -> void {
-  mode = Mode::Data;
   update();
 }
 
@@ -98,13 +93,11 @@
   pWidget::setGeometry(geometry);
 }
 
-auto pCanvas::setGradient(Color topLeft, Color topRight, Color bottomLeft, Color bottomRight) -> void {
-  mode = Mode::Gradient;
+auto pCanvas::setGradient(Gradient gradient) -> void {
   update();
 }
 
-auto pCanvas::setIcon(const image& icon) -> void {
-  mode = Mode::Icon;
+auto pCanvas::setImage(const Image& image) -> void {
   update();
 }
 
@@ -146,14 +139,13 @@
   signed width = 0;
   signed height = 0;
 
-  if(mode == Mode::Color || mode == Mode::Gradient) {
+  if(auto& image = state().image) {
+    width = image.width();
+    height = image.height();
+  } else {
     width = pSizable::state().geometry.width();
     height = pSizable::state().geometry.height();
-  } else {
-    width = state().size.width();
-    height = state().size.height();
   }
-
   if(width <= 0 || height <= 0) return;
 
   if(width != surfaceWidth || height != surfaceHeight) _release();
@@ -161,31 +153,19 @@
   surfaceHeight = height;
 
   if(!surface) surface = gdk_pixbuf_new(GDK_COLORSPACE_RGB, true, 8, width, height);
-  uint32_t* buffer = (uint32_t*)gdk_pixbuf_get_pixels(surface);
+  auto buffer = (uint32_t*)gdk_pixbuf_get_pixels(surface);
 
-  if(mode == Mode::Color) {
-    uint32_t color = state().color.value();
-    for(auto n : range(width * height)) buffer[n] = color;
-  }
-
-  if(mode == Mode::Gradient) {
-    image fill;
+  if(auto& image = state().image) {
+    memory::copy(buffer, state().image.data(), width * height * sizeof(uint32_t));
+  } else if(auto& gradient = state().gradient) {
+    auto& colors = gradient.state.colors;
+    nall::image fill;
     fill.allocate(width, height);
-    fill.gradient(
-      state().gradient[0].value(), state().gradient[1].value(), state().gradient[2].value(), state().gradient[3].value()
-    );
+    fill.gradient(colors[0].value(), colors[1].value(), colors[2].value(), colors[3].value());
     memory::copy(buffer, fill.data(), fill.size());
-  }
-
-  if(mode == Mode::Icon) {
-    auto icon = state().icon;
-    icon.scale(width, height);
-    icon.transform();
-    memory::copy(buffer, icon.data(), icon.size());
-  }
-
-  if(mode == Mode::Data) {
-    memory::copy(buffer, state().data.data(), state().data.size() * sizeof(uint32_t));
+  } else {
+    uint32_t color = state().color.value();
+    for(auto n : range(width * height)) buffer[n] = color;
   }
 
   //ARGB -> ABGR conversion
diff -Nru higan/hiro/gtk/widget/canvas.hpp higan/hiro/gtk/widget/canvas.hpp
--- higan/hiro/gtk/widget/canvas.hpp	2015-09-16 02:20:06.385574582 +0900
+++ higan/hiro/gtk/widget/canvas.hpp	2015-09-16 13:08:13.426563355 +0900
@@ -7,15 +7,12 @@
 
   auto minimumSize() const -> Size;
   auto setColor(Color color) -> void;
-  auto setData(Size size) -> void;
   auto setDroppable(bool droppable) -> void;
   auto setGeometry(Geometry geometry) -> void override;
-  auto setGradient(Color topLeft, Color topRight, Color bottomLeft, Color bottomRight) -> void;
-  auto setIcon(const image& icon) -> void;
+  auto setGradient(Gradient gradient) -> void;
+  auto setImage(const Image& image) -> void;
   auto update() -> void;
 
-  enum class Mode : unsigned { Color, Data, Gradient, Icon };
-
   auto _onExpose(GdkEventExpose* event) -> void;
   auto _rasterize() -> void;
   auto _redraw() -> void;
@@ -24,7 +21,6 @@
   GdkPixbuf* surface = nullptr;
   unsigned surfaceWidth = 0;
   unsigned surfaceHeight = 0;
-  Mode mode = Mode::Color;
 };
 
 }
diff -Nru higan/hiro/gtk/widget/check-button.cpp higan/hiro/gtk/widget/check-button.cpp
--- higan/hiro/gtk/widget/check-button.cpp	2015-09-16 02:20:06.385574582 +0900
+++ higan/hiro/gtk/widget/check-button.cpp	2015-09-16 13:08:13.425563354 +0900
@@ -12,7 +12,7 @@
 
   setBordered(state().bordered);
   setChecked(state().checked);
-  setIcon(state().icon);
+  setImage(state().image);
   setOrientation(state().orientation);
   setText(state().text);
 
@@ -29,13 +29,13 @@
   Size size = pFont::size(self().font(true), state().text);
 
   if(state().orientation == Orientation::Horizontal) {
-    size.setWidth(size.width() + state().icon.width());
-    size.setHeight(max(size.height(), state().icon.height()));
+    size.setWidth(size.width() + state().image.width());
+    size.setHeight(max(size.height(), state().image.height()));
   }
 
   if(state().orientation == Orientation::Vertical) {
-    size.setWidth(max(size.width(), state().icon.width()));
-    size.setHeight(size.height() + state().icon.height());
+    size.setWidth(max(size.width(), state().image.width()));
+    size.setHeight(size.height() + state().image.height());
   }
 
   return {size.width() + 24, size.height() + 12};
@@ -51,9 +51,9 @@
   unlock();
 }
 
-auto pCheckButton::setIcon(const image& icon) -> void {
-  if(icon) {
-    GtkImage* gtkImage = CreateImage(icon);
+auto pCheckButton::setImage(const Image& image) -> void {
+  if(image) {
+    GtkImage* gtkImage = CreateImage(image);
     gtk_button_set_image(GTK_BUTTON(gtkWidget), (GtkWidget*)gtkImage);
   } else {
     gtk_button_set_image(GTK_BUTTON(gtkWidget), nullptr);
diff -Nru higan/hiro/gtk/widget/check-button.hpp higan/hiro/gtk/widget/check-button.hpp
--- higan/hiro/gtk/widget/check-button.hpp	2015-09-16 02:20:06.385574582 +0900
+++ higan/hiro/gtk/widget/check-button.hpp	2015-09-16 13:08:13.422563354 +0900
@@ -8,7 +8,7 @@
   auto minimumSize() const -> Size override;
   auto setBordered(bool bordered) -> void;
   auto setChecked(bool checked) -> void;
-  auto setIcon(const image& icon) -> void;
+  auto setImage(const Image& image) -> void;
   auto setOrientation(Orientation orientation) -> void;
   auto setText(const string& text) -> void;
 };
diff -Nru higan/hiro/gtk/widget/combo-button.cpp higan/hiro/gtk/widget/combo-button.cpp
--- higan/hiro/gtk/widget/combo-button.cpp	2015-09-16 02:20:06.385574582 +0900
+++ higan/hiro/gtk/widget/combo-button.cpp	2015-09-16 13:08:13.425563354 +0900
@@ -32,7 +32,7 @@
   lock();
   if(auto self = item->self()) {
     gtk_list_store_append(gtkListStore, &self->gtkIter);
-    self->setIcon(item->state.icon);
+    self->setImage(item->state.image);
     if(item->state.selected) self->setSelected();
     self->setText(item->state.text);
   }
@@ -41,11 +41,11 @@
 }
 
 auto pComboButton::minimumSize() const -> Size {
-  string font = self().font(true);
+  auto font = self().font(true);
   signed maximumWidth = 0;
   for(auto& item : state().items) {
     maximumWidth = max(maximumWidth,
-      (item->state.icon ? pFont::size(font, " ").height() + 2 : 0)
+      (item->state.image ? pFont::size(font, " ").height() + 2 : 0)
     + pFont::size(font, item->state.text).width()
     );
   }
@@ -69,7 +69,7 @@
   unlock();
 }
 
-auto pComboButton::setFont(const string& font) -> void {
+auto pComboButton::setFont(const Font& font) -> void {
   pWidget::setFont(font);
   auto fontDescription = pFont::create(font);
   g_object_set(G_OBJECT(gtkCellText), "font-desc", fontDescription, nullptr);
diff -Nru higan/hiro/gtk/widget/combo-button.hpp higan/hiro/gtk/widget/combo-button.hpp
--- higan/hiro/gtk/widget/combo-button.hpp	2015-09-16 02:20:06.385574582 +0900
+++ higan/hiro/gtk/widget/combo-button.hpp	2015-09-16 13:08:13.427563355 +0900
@@ -9,7 +9,7 @@
   auto minimumSize() const -> Size override;
   auto remove(sComboButtonItem item) -> void;
   auto reset() -> void;
-  auto setFont(const string& font) -> void override;
+  auto setFont(const Font& font) -> void override;
 
   auto _updateSelected() -> void;
 
diff -Nru higan/hiro/gtk/widget/combo-button-item.cpp higan/hiro/gtk/widget/combo-button-item.cpp
--- higan/hiro/gtk/widget/combo-button-item.cpp	2015-09-16 02:20:06.385574582 +0900
+++ higan/hiro/gtk/widget/combo-button-item.cpp	2015-09-16 13:08:13.424563354 +0900
@@ -8,11 +8,10 @@
 auto pComboButtonItem::destruct() -> void {
 }
 
-auto pComboButtonItem::setIcon(image icon) -> void {
+auto pComboButtonItem::setImage(const Image& image) -> void {
   if(auto parent = _parent()) {
     auto size = pFont::size(self().font(true), " ").height();
-    if(icon) icon.scale(size, size);
-    auto pixbuf = CreatePixbuf(icon);
+    auto pixbuf = CreatePixbuf(image, true);
     gtk_list_store_set(parent->gtkListStore, &gtkIter, 0, pixbuf, -1);
   }
 }
diff -Nru higan/hiro/gtk/widget/combo-button-item.hpp higan/hiro/gtk/widget/combo-button-item.hpp
--- higan/hiro/gtk/widget/combo-button-item.hpp	2015-09-16 02:20:06.385574582 +0900
+++ higan/hiro/gtk/widget/combo-button-item.hpp	2015-09-16 13:08:13.432563355 +0900
@@ -5,7 +5,7 @@
 struct pComboButtonItem : pObject {
   Declare(ComboButtonItem, Object)
 
-  auto setIcon(image icon) -> void;
+  auto setImage(const Image& icon) -> void;
   auto setSelected() -> void;
   auto setText(const string& text) -> void;
 
diff -Nru higan/hiro/gtk/widget/frame.cpp higan/hiro/gtk/widget/frame.cpp
--- higan/hiro/gtk/widget/frame.cpp	2015-09-16 02:20:06.385574582 +0900
+++ higan/hiro/gtk/widget/frame.cpp	2015-09-16 13:08:13.426563355 +0900
@@ -33,7 +33,7 @@
   pWidget::setEnabled(enabled);
 }
 
-auto pFrame::setFont(const string& font) -> void {
+auto pFrame::setFont(const Font& font) -> void {
   if(auto layout = _layout()) layout->setFont(layout->self().font(true));
   pFont::setFont(gtkLabel, font);
 }
diff -Nru higan/hiro/gtk/widget/frame.hpp higan/hiro/gtk/widget/frame.hpp
--- higan/hiro/gtk/widget/frame.hpp	2015-09-16 02:20:06.385574582 +0900
+++ higan/hiro/gtk/widget/frame.hpp	2015-09-16 13:08:13.430563355 +0900
@@ -9,7 +9,7 @@
   auto container(mWidget& widget) -> GtkWidget* override;
   auto remove(shared_pointer<mLayout> layout) -> void;
   auto setEnabled(bool enabled) -> void override;
-  auto setFont(const string& font) -> void override;
+  auto setFont(const Font& font) -> void override;
   auto setGeometry(Geometry geometry) -> void override;
   auto setText(const string& text) -> void;
   auto setVisible(bool visible) -> void override;
diff -Nru higan/hiro/gtk/widget/icon-view.cpp higan/hiro/gtk/widget/icon-view.cpp
--- higan/hiro/gtk/widget/icon-view.cpp	2015-09-16 02:20:06.385574582 +0900
+++ higan/hiro/gtk/widget/icon-view.cpp	2015-09-16 13:08:13.424563354 +0900
@@ -39,9 +39,9 @@
   gtk_widget_show(subWidget);
 
   setBackgroundColor(state().backgroundColor);
+  setBatchable(state().batchable);
   setFlow(state().flow);
   setForegroundColor(state().foregroundColor);
-  setMultiSelect(state().multiSelect);
   setOrientation(state().orientation);
   for(auto position : range(self().items())) {
     auto& item = state().items[position];
@@ -65,7 +65,7 @@
 auto pIconView::append(sIconViewItem item) -> void {
   GtkTreeIter iter;
   gtk_list_store_append(store, &iter);
-  setItemIcon(item->offset(), item->state.icon);
+  setItemImage(item->offset(), item->state.image);
   setItemSelected(item->offset(), item->state.selected);
   setItemText(item->offset(), item->state.text);
 }
@@ -92,6 +92,12 @@
   gtk_widget_modify_base(subWidget, GTK_STATE_NORMAL, color ? &gdkColor : nullptr);
 }
 
+auto pIconView::setBatchable(bool batchable) -> void {
+  gtk_icon_view_set_selection_mode(GTK_ICON_VIEW(subWidget),
+    batchable ? GTK_SELECTION_MULTIPLE : GTK_SELECTION_SINGLE
+  );
+}
+
 auto pIconView::setFlow(Orientation flow) -> void {
   //GTK+ does not support vertical flow ... the closest we can get is a horizontal flow with only one column
   if(flow == Orientation::Horizontal) {
@@ -115,12 +121,12 @@
   }
 }
 
-auto pIconView::setItemIcon(unsigned position, const image& icon) -> void {
+auto pIconView::setItemImage(unsigned position, const Image& image) -> void {
   if(position >= self().itemCount()) return;
   GtkTreeIter iter;
   if(gtk_tree_model_get_iter_from_string(GTK_TREE_MODEL(store), &iter, string{position})) {
-    if(icon) {
-      GdkPixbuf* pixbuf = CreatePixbuf(icon);
+    if(image) {
+      GdkPixbuf* pixbuf = CreatePixbuf(image);
       gtk_list_store_set(store, &iter, 0, pixbuf, -1);
     } else {
       gtk_list_store_set(store, &iter, 0, nullptr, -1);
@@ -172,12 +178,6 @@
   }
 }
 
-auto pIconView::setMultiSelect(bool multiSelect) -> void {
-  gtk_icon_view_set_selection_mode(GTK_ICON_VIEW(subWidget),
-    multiSelect ? GTK_SELECTION_MULTIPLE : GTK_SELECTION_SINGLE
-  );
-}
-
 auto pIconView::setOrientation(Orientation orientation) -> void {
   gtk_icon_view_set_item_orientation(GTK_ICON_VIEW(subWidget),
     orientation == Orientation::Horizontal ? GTK_ORIENTATION_HORIZONTAL : GTK_ORIENTATION_VERTICAL
diff -Nru higan/hiro/gtk/widget/icon-view.hpp higan/hiro/gtk/widget/icon-view.hpp
--- higan/hiro/gtk/widget/icon-view.hpp	2015-09-16 02:20:06.385574582 +0900
+++ higan/hiro/gtk/widget/icon-view.hpp	2015-09-16 13:08:13.425563354 +0900
@@ -9,16 +9,16 @@
   auto remove(sIconViewItem item) -> void;
   auto reset() -> void;
   auto setBackgroundColor(Color color) -> void;
+  auto setBatchable(bool batchable) -> void;
   auto setFlow(Orientation flow) -> void;
   auto setForegroundColor(Color color) -> void;
   auto setGeometry(Geometry geometry) -> void;
-  auto setItemIcon(unsigned position, const image& icon) -> void;
+  auto setItemImage(unsigned position, const Image& image) -> void;
   auto setItemSelected(unsigned position, bool selected) -> void;
   auto setItemSelected(const vector<signed>& selections) -> void;
   auto setItemSelectedAll() -> void;
   auto setItemSelectedNone() -> void;
   auto setItemText(unsigned position, const string& text) -> void;
-  auto setMultiSelect(bool multiSelect) -> void;
   auto setOrientation(Orientation orientation) -> void;
 
   auto _updateSelected() -> void;
diff -Nru higan/hiro/gtk/widget/icon-view-item.cpp higan/hiro/gtk/widget/icon-view-item.cpp
--- higan/hiro/gtk/widget/icon-view-item.cpp	2015-09-16 02:20:06.385574582 +0900
+++ higan/hiro/gtk/widget/icon-view-item.cpp	2015-09-16 13:08:13.420563354 +0900
@@ -8,9 +8,9 @@
 auto pIconViewItem::destruct() -> void {
 }
 
-auto pIconViewItem::setIcon(const image& icon) -> void {
+auto pIconViewItem::setImage(const Image& image) -> void {
   if(auto parent = _parent()) {
-    parent->setItemIcon(self().offset(), icon);
+    parent->setItemImage(self().offset(), image);
   }
 }
 
diff -Nru higan/hiro/gtk/widget/icon-view-item.hpp higan/hiro/gtk/widget/icon-view-item.hpp
--- higan/hiro/gtk/widget/icon-view-item.hpp	2015-09-16 02:20:06.385574582 +0900
+++ higan/hiro/gtk/widget/icon-view-item.hpp	2015-09-16 13:08:13.427563355 +0900
@@ -5,7 +5,7 @@
 struct pIconViewItem : pObject {
   Declare(IconViewItem, Object)
 
-  auto setIcon(const image& icon) -> void;
+  auto setImage(const Image& image) -> void;
   auto setSelected(bool selected) -> void;
   auto setText(const string& text) -> void;
 
diff -Nru higan/hiro/gtk/widget/list-view-cell.cpp higan/hiro/gtk/widget/list-view-cell.cpp
--- higan/hiro/gtk/widget/list-view-cell.cpp	2015-09-16 02:20:06.385574582 +0900
+++ higan/hiro/gtk/widget/list-view-cell.cpp	2015-09-16 13:08:13.425563354 +0900
@@ -25,7 +25,7 @@
 auto pListViewCell::setForegroundColor(Color color) -> void {
 }
 
-auto pListViewCell::setIcon(const image& icon) -> void {
+auto pListViewCell::setImage(const Image& image) -> void {
   _setState();
 }
 
@@ -50,7 +50,7 @@
     if(auto grandparent = _grandparent()) {
       grandparent->lock();
       gtk_list_store_set(grandparent->gtkListStore, &parent->gtkIter, 3 * self().offset() + 0, state().checked, -1);
-      gtk_list_store_set(grandparent->gtkListStore, &parent->gtkIter, 3 * self().offset() + 1, CreatePixbuf(state().icon), -1);
+      gtk_list_store_set(grandparent->gtkListStore, &parent->gtkIter, 3 * self().offset() + 1, CreatePixbuf(state().image), -1);
       gtk_list_store_set(grandparent->gtkListStore, &parent->gtkIter, 3 * self().offset() + 2, state().text.data(), -1);
       grandparent->unlock();
     }
diff -Nru higan/hiro/gtk/widget/list-view-cell.hpp higan/hiro/gtk/widget/list-view-cell.hpp
--- higan/hiro/gtk/widget/list-view-cell.hpp	2015-09-16 02:20:06.385574582 +0900
+++ higan/hiro/gtk/widget/list-view-cell.hpp	2015-09-16 13:08:13.424563354 +0900
@@ -10,7 +10,7 @@
   auto setCheckable(bool checkable) -> void;
   auto setChecked(bool checked) -> void;
   auto setForegroundColor(Color color) -> void;
-  auto setIcon(const image& icon) -> void;
+  auto setImage(const Image& image) -> void;
   auto setText(const string& text) -> void;
 
   auto _grandparent() -> maybe<pListView&>;
diff -Nru higan/hiro/gtk/widget/list-view-column.cpp higan/hiro/gtk/widget/list-view-column.cpp
--- higan/hiro/gtk/widget/list-view-column.cpp	2015-09-16 02:20:06.386574582 +0900
+++ higan/hiro/gtk/widget/list-view-column.cpp	2015-09-16 13:08:13.431563355 +0900
@@ -75,15 +75,15 @@
   }
 }
 
-auto pListViewColumn::setFont(const string& font) -> void {
+auto pListViewColumn::setFont(const Font& font) -> void {
 }
 
 auto pListViewColumn::setForegroundColor(Color color) -> void {
 }
 
-auto pListViewColumn::setIcon(const image& icon) -> void {
-  if(icon) {
-    gtk_image_set_from_pixbuf(GTK_IMAGE(gtkHeaderIcon), CreatePixbuf(icon));
+auto pListViewColumn::setImage(const Image& image) -> void {
+  if(image) {
+    gtk_image_set_from_pixbuf(GTK_IMAGE(gtkHeaderIcon), CreatePixbuf(image));
   } else {
     gtk_image_clear(GTK_IMAGE(gtkHeaderIcon));
   }
diff -Nru higan/hiro/gtk/widget/list-view-column.hpp higan/hiro/gtk/widget/list-view-column.hpp
--- higan/hiro/gtk/widget/list-view-column.hpp	2015-09-16 02:20:06.386574582 +0900
+++ higan/hiro/gtk/widget/list-view-column.hpp	2015-09-16 13:08:13.429563355 +0900
@@ -10,10 +10,10 @@
   auto setBackgroundColor(Color color) -> void;
   auto setEditable(bool editable) -> void;
   auto setExpandable(bool expandable) -> void;
-  auto setFont(const string& font) -> void override;
+  auto setFont(const Font& font) -> void override;
   auto setForegroundColor(Color color) -> void;
   auto setHorizontalAlignment(double) -> void {}
-  auto setIcon(const image& icon) -> void;
+  auto setImage(const Image& image) -> void;
   auto setResizable(bool resizable) -> void;
   auto setSortable(bool sortable) -> void;
   auto setText(const string& text) -> void;
diff -Nru higan/hiro/gtk/widget/list-view.cpp higan/hiro/gtk/widget/list-view.cpp
--- higan/hiro/gtk/widget/list-view.cpp	2015-09-16 02:20:06.386574582 +0900
+++ higan/hiro/gtk/widget/list-view.cpp	2015-09-16 13:08:13.428563355 +0900
@@ -122,7 +122,7 @@
   gtk_widget_grab_focus(gtkWidgetChild);
 }
 
-auto pListView::setFont(const string& font) -> void {
+auto pListView::setFont(const Font& font) -> void {
   if(auto& header = state().header) {
     if(auto self = header->self()) self->_setState();
   }
@@ -149,11 +149,11 @@
       if(cell->state.checkable) {
         width += 24;
       }
-      if(auto& icon = cell->state.icon) {
-        width += icon.width() + 2;
+      if(auto& image = cell->state.image) {
+        width += image.width() + 2;
       }
       if(auto& text = cell->state.text) {
-        width += Font::size(cell->font(true), text).width();
+        width += pFont::size(cell->font(true), text).width();
       }
     }
   }
@@ -164,11 +164,11 @@
   unsigned width = 8;
   if(auto& header = state().header) {
     if(auto column = header->column(_column)) {
-      if(auto& icon = column->state.icon) {
-        width += icon.width() + 2;
+      if(auto& image = column->state.image) {
+        width += image.width() + 2;
       }
       if(auto& text = column->state.text) {
-        width += Font::size(column->font(true), text).width();
+        width += pFont::size(column->font(true), text).width();
       }
     }
   }
diff -Nru higan/hiro/gtk/widget/list-view.hpp higan/hiro/gtk/widget/list-view.hpp
--- higan/hiro/gtk/widget/list-view.hpp	2015-09-16 02:20:06.386574582 +0900
+++ higan/hiro/gtk/widget/list-view.hpp	2015-09-16 13:08:13.432563355 +0900
@@ -16,7 +16,7 @@
   auto setBatchable(bool batchable) -> void;
   auto setBordered(bool bordered) -> void;
   auto setFocused() -> void override;
-  auto setFont(const string& font) -> void override;
+  auto setFont(const Font& font) -> void override;
   auto setForegroundColor(Color color) -> void;
   auto setGeometry(Geometry geometry) -> void override;
 
diff -Nru higan/hiro/gtk/widget/radio-button.cpp higan/hiro/gtk/widget/radio-button.cpp
--- higan/hiro/gtk/widget/radio-button.cpp	2015-09-16 02:20:06.386574582 +0900
+++ higan/hiro/gtk/widget/radio-button.cpp	2015-09-16 13:08:13.428563355 +0900
@@ -5,7 +5,7 @@
 static auto RadioButton_activate(GtkToggleButton*, pRadioButton* p) -> void {
   if(p->groupLocked()) return;
   bool wasChecked = p->state().checked;
-  p->setChecked();
+  p->self().setChecked();
   if(!wasChecked) p->self().doActivate();
 }
 
@@ -13,7 +13,7 @@
   gtkWidget = gtk_toggle_button_new();
 
   setBordered(state().bordered);
-  setIcon(state().icon);
+  setImage(state().image);
   setOrientation(state().orientation);
   setText(state().text);
 
@@ -30,13 +30,13 @@
   Size size = pFont::size(self().font(true), state().text);
 
   if(state().orientation == Orientation::Horizontal) {
-    size.setWidth(size.width() + state().icon.width());
-    size.setHeight(max(size.height(), state().icon.height()));
+    size.setWidth(size.width() + state().image.width());
+    size.setHeight(max(size.height(), state().image.height()));
   }
 
   if(state().orientation == Orientation::Vertical) {
-    size.setWidth(max(size.width(), state().icon.width()));
-    size.setHeight(size.height() + state().icon.height());
+    size.setWidth(max(size.width(), state().image.width()));
+    size.setHeight(size.height() + state().image.height());
   }
 
   return {size.width() + 24, size.height() + 12};
@@ -47,14 +47,12 @@
 }
 
 auto pRadioButton::setChecked() -> void {
-  if(!self().group()) return;
   for(auto& weak : self().group()->state.objects) {
     if(auto object = weak.acquire()) {
       if(auto radioButton = dynamic_cast<mRadioButton*>(object.data())) {
         if(auto self = radioButton->self()) {
           self->lock();
-          bool checked = self == this;
-          gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(self->gtkWidget), radioButton->state.checked = checked);
+          gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(self->gtkWidget), radioButton->state.checked);
           self->unlock();
         }
       }
@@ -63,13 +61,14 @@
 }
 
 auto pRadioButton::setGroup(sGroup group) -> void {
-  if(!group) return;
+  bool first = true;
   for(auto& weak : group->state.objects) {
     if(auto object = weak.acquire()) {
       if(auto radioButton = dynamic_cast<mRadioButton*>(object.data())) {
         if(auto self = radioButton->self()) {
           self->lock();
-          gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(self->gtkWidget), radioButton->checked());
+          gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(self->gtkWidget), radioButton->state.checked = first);
+          first = false;
           self->unlock();
         }
       }
@@ -77,9 +76,9 @@
   }
 }
 
-auto pRadioButton::setIcon(const image& icon) -> void {
-  if(icon) {
-    GtkImage* gtkImage = CreateImage(icon);
+auto pRadioButton::setImage(const Image& image) -> void {
+  if(image) {
+    GtkImage* gtkImage = CreateImage(image);
     gtk_button_set_image(GTK_BUTTON(gtkWidget), (GtkWidget*)gtkImage);
   } else {
     gtk_button_set_image(GTK_BUTTON(gtkWidget), nullptr);
diff -Nru higan/hiro/gtk/widget/radio-button.hpp higan/hiro/gtk/widget/radio-button.hpp
--- higan/hiro/gtk/widget/radio-button.hpp	2015-09-16 02:20:06.386574582 +0900
+++ higan/hiro/gtk/widget/radio-button.hpp	2015-09-16 13:08:13.431563355 +0900
@@ -9,7 +9,7 @@
   auto setBordered(bool bordered) -> void;
   auto setChecked() -> void;
   auto setGroup(sGroup group) -> void;
-  auto setIcon(const image& icon) -> void;
+  auto setImage(const Image& image) -> void;
   auto setOrientation(Orientation orientation) -> void;
   auto setText(const string& text) -> void;
 
diff -Nru higan/hiro/gtk/widget/radio-label.cpp higan/hiro/gtk/widget/radio-label.cpp
--- higan/hiro/gtk/widget/radio-label.cpp	2015-09-16 02:20:06.386574582 +0900
+++ higan/hiro/gtk/widget/radio-label.cpp	2015-09-16 13:08:13.431563355 +0900
@@ -5,7 +5,7 @@
 static auto RadioLabel_activate(GtkToggleButton*, pRadioLabel* p) -> void {
   if(p->groupLocked()) return;
   bool wasChecked = p->state().checked;
-  p->setChecked();
+  p->self().setChecked();
   if(!wasChecked) p->self().doActivate();
 }
 
@@ -37,8 +37,6 @@
 }
 
 auto pRadioLabel::setGroup(sGroup group) -> void {
-  if(!group) return;
-
   maybe<GtkRadioButton*> gtkRadioButton;
   for(auto& weak : group->state.objects) {
     if(auto object = weak.acquire()) {
@@ -46,9 +44,13 @@
         if(auto self = radioLabel->self()) {
           self->lock();
           gtk_radio_button_set_group(self->gtkRadioButton, nullptr);
-          if(!gtkRadioButton) gtkRadioButton = self->gtkRadioButton;
-          else gtk_radio_button_set_group(self->gtkRadioButton, gtk_radio_button_get_group(*gtkRadioButton));
-          gtk_toggle_button_set_active(self->gtkToggleButton, radioLabel->checked());
+          if(!gtkRadioButton) {
+            gtkRadioButton = self->gtkRadioButton;
+            gtk_toggle_button_set_active(self->gtkToggleButton, radioLabel->state.checked = true);
+          } else {
+            gtk_radio_button_set_group(self->gtkRadioButton, gtk_radio_button_get_group(*gtkRadioButton));
+            gtk_toggle_button_set_active(self->gtkToggleButton, radioLabel->state.checked = false);
+          }
           self->unlock();
         }
       }
diff -Nru higan/hiro/gtk/widget/source-edit.cpp higan/hiro/gtk/widget/source-edit.cpp
--- higan/hiro/gtk/widget/source-edit.cpp	2015-09-16 02:20:06.386574582 +0900
+++ higan/hiro/gtk/widget/source-edit.cpp	2015-09-16 13:08:13.421563354 +0900
@@ -7,11 +7,11 @@
 }
 
 static auto SourceEdit_move(GObject*, GParamSpec*, pSourceEdit* p) -> void {
-  signed position = 0;
-  g_object_get(G_OBJECT(p->gtkSourceBuffer), "cursor-position", &position, nullptr);
+  signed offset = 0;
+  g_object_get(G_OBJECT(p->gtkSourceBuffer), "cursor-position", &offset, nullptr);
 
-  if(p->state().position != position) {
-    p->state().position = position;
+  if(p->state().cursor.offset() != offset) {
+    p->state().cursor.setOffset(offset);
     if(!p->locked()) p->self().doMove();
   }
 }
@@ -68,10 +68,25 @@
   gtk_widget_destroy(gtkWidget);
 }
 
+auto pSourceEdit::setCursor(Cursor cursor) -> void {
+  lock();
+  GtkTextIter offset, length;
+  gtk_text_buffer_get_end_iter(gtkTextBuffer, &offset);
+  gtk_text_buffer_get_end_iter(gtkTextBuffer, &length);
+  signed end = gtk_text_iter_get_offset(&offset);
+  gtk_text_iter_set_offset(&offset, max(0, min(end, cursor.offset())));
+  gtk_text_iter_set_offset(&length, max(0, min(end, cursor.offset() + cursor.length())));
+  gtk_text_buffer_select_range(gtkTextBuffer, &offset, &length);
+  auto mark = gtk_text_buffer_get_mark(gtkTextBuffer, "insert");
+  gtk_text_view_scroll_mark_onscreen(gtkTextView, mark);
+  unlock();
+}
+
 auto pSourceEdit::setFocused() -> void {
   gtk_widget_grab_focus(gtkWidgetSourceView);
 }
 
+/*
 auto pSourceEdit::setPosition(signed position) -> void {
   lock();
   GtkTextIter iter;
@@ -105,6 +120,7 @@
   gtk_text_buffer_select_range(gtkTextBuffer, &startIter, &endIter);
   unlock();
 }
+*/
 
 auto pSourceEdit::setText(const string& text) -> void {
   lock();
diff -Nru higan/hiro/gtk/widget/source-edit.hpp higan/hiro/gtk/widget/source-edit.hpp
--- higan/hiro/gtk/widget/source-edit.hpp	2015-09-16 02:20:06.386574582 +0900
+++ higan/hiro/gtk/widget/source-edit.hpp	2015-09-16 13:08:13.427563355 +0900
@@ -5,9 +5,8 @@
 struct pSourceEdit : pWidget {
   Declare(SourceEdit, Widget)
 
+  auto setCursor(Cursor cursor) -> void;
   auto setFocused() -> void override;
-  auto setPosition(signed position) -> void;
-  auto setSelected(Position selected) -> void;
   auto setText(const string& text) -> void;
   auto text() const -> string;
 
diff -Nru higan/hiro/gtk/widget/tab-frame.cpp higan/hiro/gtk/widget/tab-frame.cpp
--- higan/hiro/gtk/widget/tab-frame.cpp	2015-09-16 02:20:06.386574582 +0900
+++ higan/hiro/gtk/widget/tab-frame.cpp	2015-09-16 13:08:13.429563355 +0900
@@ -49,7 +49,7 @@
 
   tabs.reset();  //todo: memory leak, need to release each tab
   for(auto& item : state().items) append(item);
-  setEdge(state().edge);
+  setNavigation(state().navigation);
 
   g_signal_connect(G_OBJECT(gtkWidget), "page-reordered", G_CALLBACK(TabFrame_move), (gpointer)this);
   g_signal_connect(G_OBJECT(gtkWidget), "switch-page", G_CALLBACK(TabFrame_change), (gpointer)this);
@@ -72,7 +72,7 @@
   tab.close = gtk_button_new_with_label("\u00d7");  //Unicode multiplication sign (looks better than 'X')
   gtk_button_set_focus_on_click(GTK_BUTTON(tab.close), false);
   gtk_button_set_relief(GTK_BUTTON(tab.close), GTK_RELIEF_NONE);
-  pFont::setFont(tab.close, Font::sans(9, "Bold"));
+  pFont::setFont(tab.close, Font("sans", 9).setBold());
   auto color = CreateColor({255, 0, 0});
   gtk_widget_modify_fg(gtk_bin_get_child(GTK_BIN(tab.close)), GTK_STATE_PRELIGHT, &color);
   tabs.append(tab);
@@ -140,18 +140,6 @@
   unlock();
 }
 
-auto pTabFrame::setEdge(Edge edge) -> void {
-  GtkPositionType type;
-  switch(edge) { default:
-  case Edge::Top: type = GTK_POS_TOP; break;
-  case Edge::Bottom: type = GTK_POS_BOTTOM; break;
-  case Edge::Left: type = GTK_POS_LEFT; break;
-  case Edge::Right: type = GTK_POS_RIGHT; break;
-  }
-  gtk_notebook_set_tab_pos(GTK_NOTEBOOK(gtkWidget), type);
-  setGeometry(self().geometry());
-}
-
 auto pTabFrame::setEnabled(bool enabled) -> void {
   for(auto& item : state().items) {
     if(auto layout = item->state.layout) {
@@ -161,7 +149,7 @@
   pWidget::setEnabled(enabled);
 }
 
-auto pTabFrame::setFont(const string& font) -> void {
+auto pTabFrame::setFont(const Font& font) -> void {
   for(auto n : range(tabs.size())) {
     pFont::setFont(tabs[n].title, font);
     if(auto layout = state().items[n]->state.layout) {
@@ -174,7 +162,7 @@
   pWidget::setGeometry(geometry);
 
   geometry.setPosition(0, 0);
-  if(state().edge == Edge::Top || state().edge == Edge::Bottom) {
+  if(state().navigation == Navigation::Top || state().navigation == Navigation::Bottom) {
     geometry.setWidth(geometry.width() - 6);
     geometry.setHeight(geometry.height() - (15 + _tabHeight()));
   } else {
@@ -190,7 +178,7 @@
   _synchronizeTab(position);
 }
 
-auto pTabFrame::setItemIcon(unsigned position, const image& icon) -> void {
+auto pTabFrame::setItemImage(unsigned position, const Image& image) -> void {
   _synchronizeTab(position);
 }
 
@@ -214,6 +202,18 @@
   _synchronizeTab(position);
 }
 
+auto pTabFrame::setNavigation(Navigation navigation) -> void {
+  GtkPositionType type;
+  switch(navigation) { default:
+  case Navigation::Top: type = GTK_POS_TOP; break;
+  case Navigation::Bottom: type = GTK_POS_BOTTOM; break;
+  case Navigation::Left: type = GTK_POS_LEFT; break;
+  case Navigation::Right: type = GTK_POS_RIGHT; break;
+  }
+  gtk_notebook_set_tab_pos(GTK_NOTEBOOK(gtkWidget), type);
+  setGeometry(self().geometry());
+}
+
 auto pTabFrame::setVisible(bool visible) -> void {
   for(auto& item : state().items) {
     if(auto layout = item->state.layout) {
@@ -239,16 +239,15 @@
   auto& item = state().items[position];
   auto& tab = tabs[position];
   gtk_widget_set_visible(tab.close, item->closable());
-  if(auto copy = item->state.icon) {
+  if(auto& image = item->state.image) {
     unsigned size = pFont::size(self().font(true), " ").height();
-    copy.scale(size, size);
-    auto pixbuf = CreatePixbuf(copy);
+    auto pixbuf = CreatePixbuf(image, true);
     gtk_image_set_from_pixbuf(GTK_IMAGE(tab.image), pixbuf);
   } else {
     gtk_image_clear(GTK_IMAGE(tab.image));
   }
   string text = {
-    item->state.icon && item->state.text ? " " : "",
+    item->state.image && item->state.text ? " " : "",
     item->state.text,
     item->state.text && item->state.closable ? " " : ""
   };
diff -Nru higan/hiro/gtk/widget/tab-frame.hpp higan/hiro/gtk/widget/tab-frame.hpp
--- higan/hiro/gtk/widget/tab-frame.hpp	2015-09-16 02:20:06.386574582 +0900
+++ higan/hiro/gtk/widget/tab-frame.hpp	2015-09-16 13:08:13.427563355 +0900
@@ -8,16 +8,16 @@
   auto append(sTabFrameItem item) -> void;
   auto container(mWidget& widget) -> GtkWidget* override;
   auto remove(sTabFrameItem item) -> void;
-  auto setEdge(Edge edge) -> void;
   auto setEnabled(bool enabled) -> void override;
-  auto setFont(const string& font) -> void override;
+  auto setFont(const Font& font) -> void override;
   auto setGeometry(Geometry geometry) -> void override;
   auto setItemClosable(unsigned position, bool closable) -> void;
-  auto setItemIcon(unsigned position, const image& icon) -> void;
+  auto setItemImage(unsigned position, const Image& image) -> void;
   auto setItemLayout(unsigned position, sLayout layout) -> void;
   auto setItemMovable(unsigned position, bool movable) -> void;
   auto setItemSelected(unsigned position) -> void;
   auto setItemText(unsigned position, const string& text) -> void;
+  auto setNavigation(Navigation navigation) -> void;
   auto setVisible(bool visible) -> void override;
 
   auto _append(shared_pointer<mTabFrameItem> item) -> void;
diff -Nru higan/hiro/gtk/widget/tab-frame-item.cpp higan/hiro/gtk/widget/tab-frame-item.cpp
--- higan/hiro/gtk/widget/tab-frame-item.cpp	2015-09-16 02:20:06.386574582 +0900
+++ higan/hiro/gtk/widget/tab-frame-item.cpp	2015-09-16 13:08:13.422563354 +0900
@@ -22,9 +22,9 @@
   }
 }
 
-auto pTabFrameItem::setIcon(const image& icon) -> void {
+auto pTabFrameItem::setImage(const Image& image) -> void {
   if(auto parent = _parent()) {
-    parent->setItemIcon(self().offset(), icon);
+    parent->setItemImage(self().offset(), image);
   }
 }
 
diff -Nru higan/hiro/gtk/widget/tab-frame-item.hpp higan/hiro/gtk/widget/tab-frame-item.hpp
--- higan/hiro/gtk/widget/tab-frame-item.hpp	2015-09-16 02:20:06.386574582 +0900
+++ higan/hiro/gtk/widget/tab-frame-item.hpp	2015-09-16 13:08:13.426563355 +0900
@@ -8,7 +8,7 @@
   auto append(sLayout layout) -> void;
   auto remove(sLayout layout) -> void;
   auto setClosable(bool closable) -> void;
-  auto setIcon(const image& icon) -> void;
+  auto setImage(const Image& image) -> void;
   auto setMovable(bool movable) -> void;
   auto setSelected() -> void;
   auto setText(const string& text) -> void;
diff -Nru higan/hiro/gtk/widget/text-edit.cpp higan/hiro/gtk/widget/text-edit.cpp
--- higan/hiro/gtk/widget/text-edit.cpp	2015-09-16 02:20:06.386574582 +0900
+++ higan/hiro/gtk/widget/text-edit.cpp	2015-09-16 13:08:13.430563355 +0900
@@ -7,11 +7,11 @@
 }
 
 static auto TextEdit_move(GObject* object, GParamSpec* spec, pTextEdit* p) -> void {
-  int position = 0;
-  g_object_get(p->textBuffer, "cursor-position", &position, nullptr);
+  signed offset = 0;
+  g_object_get(p->textBuffer, "cursor-position", &offset, nullptr);
 
-  if(p->state().cursorPosition != position) {
-    p->state().cursorPosition = position;
+  if(p->state().cursor.offset() != offset) {
+    p->state().cursor.setOffset(offset);
     if(!p->locked()) p->self().doMove();
   }
 }
@@ -33,6 +33,7 @@
   setForegroundColor(state().foregroundColor);
   setText(state().text);
   setWordWrap(state().wordWrap);
+  setCursor(state().cursor);
 
   g_signal_connect(G_OBJECT(textBuffer), "changed", G_CALLBACK(TextEdit_change), (gpointer)this);
   g_signal_connect(G_OBJECT(textBuffer), "notify::cursor-position", G_CALLBACK(TextEdit_move), (gpointer)this);
@@ -55,13 +56,16 @@
   gtk_widget_modify_base(subWidget, GTK_STATE_NORMAL, color ? &gdkColor : nullptr);
 }
 
-auto pTextEdit::setCursorPosition(unsigned position) -> void {
+auto pTextEdit::setCursor(Cursor cursor) -> void {
   lock();
-  GtkTextMark* mark = gtk_text_buffer_get_mark(textBuffer, "insert");
-  GtkTextIter iter;
-  gtk_text_buffer_get_end_iter(textBuffer, &iter);
-  gtk_text_iter_set_offset(&iter, min(position, gtk_text_iter_get_offset(&iter)));
-  gtk_text_buffer_place_cursor(textBuffer, &iter);
+  GtkTextIter offset, length;
+  gtk_text_buffer_get_end_iter(textBuffer, &offset);
+  gtk_text_buffer_get_end_iter(textBuffer, &length);
+  signed end = gtk_text_iter_get_offset(&offset);
+  gtk_text_iter_set_offset(&offset, max(0, min(end, cursor.offset())));
+  gtk_text_iter_set_offset(&length, max(0, min(end, cursor.offset() + cursor.length())));
+  gtk_text_buffer_select_range(textBuffer, &offset, &length);
+  auto mark = gtk_text_buffer_get_mark(textBuffer, "insert");
   gtk_text_view_scroll_mark_onscreen(GTK_TEXT_VIEW(subWidget), mark);
   unlock();
 }
@@ -70,6 +74,10 @@
   gtk_text_view_set_editable(GTK_TEXT_VIEW(subWidget), editable);
 }
 
+auto pTextEdit::setFocused() -> void {
+  gtk_widget_grab_focus(subWidget);
+}
+
 auto pTextEdit::setForegroundColor(Color color) -> void {
   GdkColor gdkColor = CreateColor(color);
   gtk_widget_modify_text(subWidget, GTK_STATE_NORMAL, color ? &gdkColor : nullptr);
diff -Nru higan/hiro/gtk/widget/text-edit.hpp higan/hiro/gtk/widget/text-edit.hpp
--- higan/hiro/gtk/widget/text-edit.hpp	2015-09-16 02:20:06.386574582 +0900
+++ higan/hiro/gtk/widget/text-edit.hpp	2015-09-16 13:08:13.427563355 +0900
@@ -7,8 +7,9 @@
 
   auto focused() const -> bool override;
   auto setBackgroundColor(Color color) -> void;
-  auto setCursorPosition(unsigned position) -> void;
+  auto setCursor(Cursor cursor) -> void;
   auto setEditable(bool editable) -> void;
+  auto setFocused() -> void override;
   auto setForegroundColor(Color color) -> void;
   auto setText(const string& text) -> void;
   auto setWordWrap(bool wordWrap) -> void;
diff -Nru higan/hiro/gtk/widget/tree-view.cpp higan/hiro/gtk/widget/tree-view.cpp
--- higan/hiro/gtk/widget/tree-view.cpp	2015-09-16 02:20:06.386574582 +0900
+++ higan/hiro/gtk/widget/tree-view.cpp	2015-09-16 13:08:13.422563354 +0900
@@ -2,10 +2,14 @@
 
 namespace hiro {
 
+//gtk_tree_view_collapse_all(gtkTreeView);
+//gtk_tree_view_expand_all(gtkTreeView);
+
 static auto TreeView_activate(GtkTreeView*, GtkTreePath* gtkPath, GtkTreeViewColumn*, pTreeView* p) -> void { p->_activatePath(gtkPath); }
 static auto TreeView_buttonEvent(GtkTreeView*, GdkEventButton* gdkEvent, pTreeView* p) -> signed { return p->_buttonEvent(gdkEvent); }
 static auto TreeView_change(GtkTreeSelection*, pTreeView* p) -> void { p->_updateSelected(); }
 static auto TreeView_context(GtkTreeView*, pTreeView* p) -> void { p->self().doContext(); }
+static auto TreeView_dataFunc(GtkTreeViewColumn* column, GtkCellRenderer* renderer, GtkTreeModel* model, GtkTreeIter* iter, pTreeView* p) -> void { return p->_doDataFunc(column, renderer, iter); }
 static auto TreeView_toggle(GtkCellRendererToggle*, char* path, pTreeView* p) -> void { p->_togglePath(path); }
 
 auto pTreeView::construct() -> void {
@@ -29,15 +33,17 @@
   gtkCellToggle = gtk_cell_renderer_toggle_new();
   gtk_tree_view_column_pack_start(gtkTreeViewColumn, gtkCellToggle, false);
   gtk_tree_view_column_set_attributes(gtkTreeViewColumn, gtkCellToggle, "active", 0, nullptr);
-  gtk_cell_renderer_set_visible(gtkCellToggle, state().checkable);
+  gtk_tree_view_column_set_cell_data_func(gtkTreeViewColumn, GTK_CELL_RENDERER(gtkCellToggle), (GtkTreeCellDataFunc)TreeView_dataFunc, (gpointer)this, nullptr);
 
   gtkCellPixbuf = gtk_cell_renderer_pixbuf_new();
   gtk_tree_view_column_pack_start(gtkTreeViewColumn, gtkCellPixbuf, false);
   gtk_tree_view_column_set_attributes(gtkTreeViewColumn, gtkCellPixbuf, "pixbuf", 1, nullptr);
+  gtk_tree_view_column_set_cell_data_func(gtkTreeViewColumn, GTK_CELL_RENDERER(gtkCellPixbuf), (GtkTreeCellDataFunc)TreeView_dataFunc, (gpointer)this, nullptr);
 
   gtkCellText = gtk_cell_renderer_text_new();
   gtk_tree_view_column_pack_start(gtkTreeViewColumn, gtkCellText, true);
   gtk_tree_view_column_set_attributes(gtkTreeViewColumn, gtkCellText, "text", 2, nullptr);
+  gtk_tree_view_column_set_cell_data_func(gtkTreeViewColumn, GTK_CELL_RENDERER(gtkCellText), (GtkTreeCellDataFunc)TreeView_dataFunc, (gpointer)this, nullptr);
 
   gtk_tree_view_append_column(gtkTreeView, gtkTreeViewColumn);
   gtk_tree_view_set_search_column(gtkTreeView, 2);
@@ -63,29 +69,9 @@
 //
 
 auto pTreeView::append(sTreeViewItem item) -> void {
-  gtk_tree_store_append(gtkTreeStore, &item->self()->gtkIter, nullptr);
-  item->setChecked(item->checked());
-  item->setIcon(item->icon());
-  item->setText(item->text());
-}
-
-auto pTreeView::collapse() -> void {
-  gtk_tree_view_collapse_all(gtkTreeView);
-}
-
-auto pTreeView::expand() -> void {
-  gtk_tree_view_expand_all(gtkTreeView);
 }
 
 auto pTreeView::remove(sTreeViewItem item) -> void {
-  gtk_tree_store_remove(gtkTreeStore, &item->self()->gtkIter);
-}
-
-auto pTreeView::reset() -> void {
-  gtk_tree_view_set_model(gtkTreeView, nullptr);
-  gtkTreeStore = gtk_tree_store_new(3, G_TYPE_BOOLEAN, GDK_TYPE_PIXBUF, G_TYPE_STRING);
-  gtkTreeModel = GTK_TREE_MODEL(gtkTreeStore);
-  gtk_tree_view_set_model(gtkTreeView, gtkTreeModel);
 }
 
 auto pTreeView::setBackgroundColor(Color color) -> void {
@@ -93,10 +79,6 @@
   gtk_widget_modify_base(gtkWidgetChild, GTK_STATE_NORMAL, color ? &gdkColor : nullptr);
 }
 
-auto pTreeView::setCheckable(bool checkable) -> void {
-  gtk_cell_renderer_set_visible(gtkCellToggle, checkable);
-}
-
 auto pTreeView::setForegroundColor(Color color) -> void {
   auto gdkColor = CreateColor(color);
   gtk_widget_modify_text(gtkWidgetChild, GTK_STATE_NORMAL, color ? &gdkColor : nullptr);
@@ -136,6 +118,41 @@
   return false;
 }
 
+auto pTreeView::_doDataFunc(GtkTreeViewColumn* column, GtkCellRenderer* renderer, GtkTreeIter* iter) -> void {
+  auto path = gtk_tree_model_get_string_from_iter(gtkTreeModel, iter);
+  auto parts = string{path}.split(":");
+  g_free(path);
+
+  auto item = self().item(decimal(parts.takeFirst()));
+  if(!item) return;
+  while(parts) {
+    item = item.item(decimal(parts.takeFirst()));
+    if(!item) return;
+  }
+
+  if(renderer == GTK_CELL_RENDERER(gtkCellToggle)) {
+    gtk_cell_renderer_set_visible(renderer, item->state.checkable);
+  } else if(renderer == GTK_CELL_RENDERER(gtkCellPixbuf)) {
+    gtk_cell_renderer_set_visible(renderer, (bool)item->state.image);
+  } else if(renderer == GTK_CELL_RENDERER(gtkCellText)) {
+    auto font = pFont::create(item->font(true));
+    g_object_set(G_OBJECT(renderer), "font-desc", font, nullptr);
+    pango_font_description_free(font);
+    if(auto color = item->foregroundColor(true)) {
+      auto gdkColor = CreateColor(color);
+      g_object_set(G_OBJECT(renderer), "foreground-gdk", &gdkColor, nullptr);
+    } else {
+      g_object_set(G_OBJECT(renderer), "foreground-set", false, nullptr);
+    }
+  }
+  if(auto color = item->backgroundColor(true)) {
+    auto gdkColor = CreateColor(color);
+    g_object_set(G_OBJECT(renderer), "cell-background-gdk", &gdkColor, nullptr);
+  } else {
+    g_object_set(G_OBJECT(renderer), "cell-background-set", false, nullptr);
+  }
+}
+
 auto pTreeView::_togglePath(string path) -> void {
   if(auto item = self().item(path.transform(":", "/"))) {
     bool checked = !item->checked();
diff -Nru higan/hiro/gtk/widget/tree-view.hpp higan/hiro/gtk/widget/tree-view.hpp
--- higan/hiro/gtk/widget/tree-view.hpp	2015-09-16 02:20:06.386574582 +0900
+++ higan/hiro/gtk/widget/tree-view.hpp	2015-09-16 13:08:13.422563354 +0900
@@ -6,16 +6,13 @@
   Declare(TreeView, Widget)
 
   auto append(sTreeViewItem item) -> void;
-  auto collapse() -> void;
-  auto expand() -> void;
   auto remove(sTreeViewItem item) -> void;
-  auto reset() -> void;
   auto setBackgroundColor(Color color) -> void;
-  auto setCheckable(bool checkable) -> void;
   auto setForegroundColor(Color color) -> void;
 
   auto _activatePath(GtkTreePath* gtkPath) -> void;
   auto _buttonEvent(GdkEventButton* gdkEvent) -> signed;
+  auto _doDataFunc(GtkTreeViewColumn* column, GtkCellRenderer* renderer, GtkTreeIter* iter) -> void;
   auto _togglePath(string path) -> void;
   auto _updateSelected() -> void;
 
diff -Nru higan/hiro/gtk/widget/tree-view-item.cpp higan/hiro/gtk/widget/tree-view-item.cpp
--- higan/hiro/gtk/widget/tree-view-item.cpp	2015-09-16 02:20:06.386574582 +0900
+++ higan/hiro/gtk/widget/tree-view-item.cpp	2015-09-16 13:08:13.424563354 +0900
@@ -3,26 +3,36 @@
 namespace hiro {
 
 auto pTreeViewItem::construct() -> void {
+  if(auto parentWidget = _parentWidget()) {
+    if(auto parentItem = _parentItem()) {
+      gtk_tree_store_append(parentWidget->gtkTreeStore, &gtkIter, &parentItem->gtkIter);
+    } else {
+      gtk_tree_store_append(parentWidget->gtkTreeStore, &gtkIter, nullptr);
+    }
+    setChecked(state().checked);
+    setImage(state().image);
+    setText(state().text);
+  }
 }
 
 auto pTreeViewItem::destruct() -> void {
+  if(auto parent = _parentWidget()) {
+    gtk_tree_store_remove(parent->gtkTreeStore, &gtkIter);
+  }
 }
 
 //
 
 auto pTreeViewItem::append(sTreeViewItem item) -> void {
-  if(auto parentWidget = _parentWidget()) {
-    gtk_tree_store_append(parentWidget->gtkTreeStore, &item->self()->gtkIter, &gtkIter);
-    item->setChecked(item->checked());
-    item->setIcon(item->icon());
-    item->setText(item->text());
-  }
 }
 
 auto pTreeViewItem::remove(sTreeViewItem item) -> void {
-  if(auto parentWidget = _parentWidget()) {
-    gtk_tree_store_remove(parentWidget->gtkTreeStore, &item->self()->gtkIter);
-  }
+}
+
+auto pTreeViewItem::setBackgroundColor(Color color) -> void {
+}
+
+auto pTreeViewItem::setCheckable(bool checkable) -> void {
 }
 
 auto pTreeViewItem::setChecked(bool checked) -> void {
@@ -31,6 +41,18 @@
   }
 }
 
+auto pTreeViewItem::setExpanded(bool expanded) -> void {
+  if(auto parentWidget = _parentWidget()) {
+    auto path = gtk_tree_model_get_path(parentWidget->gtkTreeModel, &gtkIter);
+    if(expanded) {
+      gtk_tree_view_expand_row(parentWidget->gtkTreeView, path, false);
+    } else {
+      gtk_tree_view_collapse_row(parentWidget->gtkTreeView, path);
+    }
+    gtk_tree_path_free(path);
+  }
+}
+
 auto pTreeViewItem::setFocused() -> void {
   if(auto parentWidget = _parentWidget()) {
     GtkTreePath* path = gtk_tree_path_new_from_string(self().path().transform("/", ":"));
@@ -40,10 +62,13 @@
   }
 }
 
-auto pTreeViewItem::setIcon(const image& icon) -> void {
+auto pTreeViewItem::setForegroundColor(Color color) -> void {
+}
+
+auto pTreeViewItem::setImage(const Image& image) -> void {
   if(auto parentWidget = _parentWidget()) {
-    if(icon) {
-      auto pixbuf = CreatePixbuf(icon, true);
+    if(image) {
+      auto pixbuf = CreatePixbuf(image);
       gtk_tree_store_set(parentWidget->gtkTreeStore, &gtkIter, 1, pixbuf, -1);
     } else {
       gtk_tree_store_set(parentWidget->gtkTreeStore, &gtkIter, 1, nullptr, -1);
diff -Nru higan/hiro/gtk/widget/tree-view-item.hpp higan/hiro/gtk/widget/tree-view-item.hpp
--- higan/hiro/gtk/widget/tree-view-item.hpp	2015-09-16 02:20:06.386574582 +0900
+++ higan/hiro/gtk/widget/tree-view-item.hpp	2015-09-16 13:08:13.432563355 +0900
@@ -7,9 +7,13 @@
 
   auto append(sTreeViewItem item) -> void;
   auto remove(sTreeViewItem item) -> void;
+  auto setBackgroundColor(Color color) -> void;
+  auto setCheckable(bool checkable) -> void;
   auto setChecked(bool checked) -> void;
+  auto setExpanded(bool expanded) -> void;
   auto setFocused() -> void;
-  auto setIcon(const image& icon) -> void;
+  auto setForegroundColor(Color color) -> void;
+  auto setImage(const Image& image) -> void;
   auto setSelected() -> void;
   auto setText(const string& text) -> void;
 
diff -Nru higan/hiro/gtk/widget/widget.cpp higan/hiro/gtk/widget/widget.cpp
--- higan/hiro/gtk/widget/widget.cpp	2015-09-16 02:20:06.386574582 +0900
+++ higan/hiro/gtk/widget/widget.cpp	2015-09-16 13:08:13.423563354 +0900
@@ -33,7 +33,7 @@
   gtk_widget_grab_focus(gtkWidget);
 }
 
-auto pWidget::setFont(const string& font) -> void {
+auto pWidget::setFont(const Font& font) -> void {
   if(!gtkWidget) return;
   return pFont::setFont(gtkWidget, font);
 }
diff -Nru higan/hiro/gtk/widget/widget.hpp higan/hiro/gtk/widget/widget.hpp
--- higan/hiro/gtk/widget/widget.hpp	2015-09-16 02:20:06.386574582 +0900
+++ higan/hiro/gtk/widget/widget.hpp	2015-09-16 13:08:13.426563355 +0900
@@ -9,7 +9,7 @@
   virtual auto focused() const -> bool override;
   auto setEnabled(bool enabled) -> void override;
   virtual auto setFocused() -> void override;
-  auto setFont(const string& font) -> void override;
+  auto setFont(const Font& font) -> void override;
   auto setGeometry(Geometry geometry) -> void override;
   auto setVisible(bool visible) -> void override;
 
diff -Nru higan/hiro/gtk/window.cpp higan/hiro/gtk/window.cpp
--- higan/hiro/gtk/window.cpp	2015-09-16 02:20:06.387574582 +0900
+++ higan/hiro/gtk/window.cpp	2015-09-16 13:08:13.435563356 +0900
@@ -65,8 +65,7 @@
   //move
   if(geometry.x() != p->state().geometry.x() || geometry.y() != p->state().geometry.y()) {
     if(!p->state().fullScreen) {
-      p->state().geometry.setX(geometry.x());
-      p->state().geometry.setY(geometry.y());
+      p->state().geometry.setPosition({geometry.x(), geometry.y()});
     }
     if(!p->locked()) p->self().doMove();
   }
@@ -106,8 +105,9 @@
   if(allocation->width == p->lastAllocation.width
   && allocation->height == p->lastAllocation.height) return;
 
-  p->state().geometry.setWidth(allocation->width);
-  p->state().geometry.setHeight(allocation->height);
+  if(!p->state().fullScreen) {
+    p->state().geometry.setSize({allocation->width, allocation->height});
+  }
 
   if(auto& layout = p->state().layout) {
     layout->setGeometry(p->self().geometry().setPosition(0, 0));
@@ -259,10 +259,13 @@
 }
 
 auto pWindow::setFullScreen(bool fullScreen) -> void {
-  if(fullScreen == false) {
-    gtk_window_unfullscreen(GTK_WINDOW(widget));
-  } else {
+  if(fullScreen) {
+    windowedGeometry = state().geometry;
     gtk_window_fullscreen(GTK_WINDOW(widget));
+    state().geometry = Monitor::geometry(Monitor::primary());
+  } else {
+    gtk_window_unfullscreen(GTK_WINDOW(widget));
+    state().geometry = windowedGeometry;
   }
 }
 
@@ -385,7 +388,7 @@
   gtk_widget_set_sensitive(gtkMenu, enabled);
 }
 
-auto pWindow::_setMenuFont(const string& font) -> void {
+auto pWindow::_setMenuFont(const Font& font) -> void {
   pFont::setFont(gtkMenu, font);
 }
 
@@ -397,7 +400,7 @@
   gtk_widget_set_sensitive(gtkStatus, enabled);
 }
 
-auto pWindow::_setStatusFont(const string& font) -> void {
+auto pWindow::_setStatusFont(const Font& font) -> void {
   pFont::setFont(gtkStatus, font);
 }
 
diff -Nru higan/hiro/gtk/window.hpp higan/hiro/gtk/window.hpp
--- higan/hiro/gtk/window.hpp	2015-09-16 02:20:06.387574582 +0900
+++ higan/hiro/gtk/window.hpp	2015-09-16 13:08:13.436563356 +0900
@@ -5,15 +5,6 @@
 struct pWindow : pObject {
   Declare(Window, Object)
 
-  GtkWidget* widget = nullptr;
-  GtkWidget* menuContainer = nullptr;
-  GtkWidget* formContainer = nullptr;
-  GtkWidget* statusContainer = nullptr;
-  GtkWidget* gtkMenu = nullptr;
-  GtkWidget* gtkStatus = nullptr;
-  GtkAllocation lastAllocation = {0};
-  bool onSizePending = false;
-
   auto append(sLayout layout) -> void;
   auto append(sMenuBar menuBar) -> void;
   auto append(sStatusBar statusBar) -> void;
@@ -38,13 +29,23 @@
   auto _menuHeight() const -> signed;
   auto _setIcon(const string& basename) -> bool;
   auto _setMenuEnabled(bool enabled) -> void;
-  auto _setMenuFont(const string& font) -> void;
+  auto _setMenuFont(const Font& font) -> void;
   auto _setMenuVisible(bool visible) -> void;
   auto _setStatusEnabled(bool enabled) -> void;
-  auto _setStatusFont(const string& font) -> void;
+  auto _setStatusFont(const Font& font) -> void;
   auto _setStatusText(const string& text) -> void;
   auto _setStatusVisible(bool visible) -> void;
   auto _statusHeight() const -> signed;
+
+  GtkWidget* widget = nullptr;
+  GtkWidget* menuContainer = nullptr;
+  GtkWidget* formContainer = nullptr;
+  GtkWidget* statusContainer = nullptr;
+  GtkWidget* gtkMenu = nullptr;
+  GtkWidget* gtkStatus = nullptr;
+  GtkAllocation lastAllocation = {0};
+  bool onSizePending = false;
+  Geometry windowedGeometry{128, 128, 256, 256};
 };
 
 }
diff -Nru higan/hiro/qt/action/action.cpp higan/hiro/qt/action/action.cpp
--- higan/hiro/qt/action/action.cpp	2015-09-16 02:20:06.387574582 +0900
+++ higan/hiro/qt/action/action.cpp	2015-09-16 13:08:13.400563352 +0900
@@ -12,7 +12,7 @@
   _setState();
 }
 
-auto pAction::setFont(const string& font) -> void {
+auto pAction::setFont(const Font& font) -> void {
   _setState();
 }
 
diff -Nru higan/hiro/qt/action/action.hpp higan/hiro/qt/action/action.hpp
--- higan/hiro/qt/action/action.hpp	2015-09-16 02:20:06.387574582 +0900
+++ higan/hiro/qt/action/action.hpp	2015-09-16 13:08:13.399563352 +0900
@@ -6,7 +6,7 @@
   Declare(Action, Object)
 
   auto setEnabled(bool enabled) -> void override;
-  auto setFont(const string& font) -> void override;
+  auto setFont(const Font& font) -> void override;
   auto setVisible(bool visible) -> void override;
 
   auto _parentMenu() -> maybe<pMenu&>;
diff -Nru higan/hiro/qt/action/menu.cpp higan/hiro/qt/action/menu.cpp
--- higan/hiro/qt/action/menu.cpp	2015-09-16 02:20:06.387574582 +0900
+++ higan/hiro/qt/action/menu.cpp	2015-09-16 13:08:13.400563352 +0900
@@ -33,7 +33,7 @@
 auto pMenu::remove(sAction action) -> void {
 }
 
-auto pMenu::setIcon(const image& icon) -> void {
+auto pMenu::setImage(const Image& image) -> void {
   _setState();
 }
 
@@ -44,7 +44,7 @@
 auto pMenu::_setState() -> void {
   qtMenu->setEnabled(self().enabled());
   qtMenu->setFont(pFont::create(self().font(true)));
-  qtMenu->setIcon(CreateIcon(state().icon));
+  qtMenu->setIcon(CreateImage(state().image));
   qtMenu->setTitle(QString::fromUtf8(state().text));
   qtMenu->menuAction()->setVisible(self().visible());
 
diff -Nru higan/hiro/qt/action/menu.hpp higan/hiro/qt/action/menu.hpp
--- higan/hiro/qt/action/menu.hpp	2015-09-16 02:20:06.387574582 +0900
+++ higan/hiro/qt/action/menu.hpp	2015-09-16 13:08:13.399563352 +0900
@@ -7,7 +7,7 @@
 
   auto append(sAction action) -> void;
   auto remove(sAction action) -> void;
-  auto setIcon(const image& icon) -> void;
+  auto setImage(const Image& image) -> void;
   auto setText(const string& text) -> void;
 
   auto _setState() -> void override;
diff -Nru higan/hiro/qt/action/menu-item.cpp higan/hiro/qt/action/menu-item.cpp
--- higan/hiro/qt/action/menu-item.cpp	2015-09-16 02:20:06.387574582 +0900
+++ higan/hiro/qt/action/menu-item.cpp	2015-09-16 13:08:13.399563352 +0900
@@ -22,7 +22,7 @@
   qtMenuItem = nullptr;
 }
 
-auto pMenuItem::setIcon(const image& icon) -> void {
+auto pMenuItem::setImage(const Image& icon) -> void {
   _setState();
 }
 
@@ -31,7 +31,7 @@
 }
 
 auto pMenuItem::_setState() -> void {
-  qtMenuItem->setIcon(CreateIcon(state().icon));
+  qtMenuItem->setIcon(CreateImage(state().image));
   qtMenuItem->setText(state().text);
 }
 
diff -Nru higan/hiro/qt/action/menu-item.hpp higan/hiro/qt/action/menu-item.hpp
--- higan/hiro/qt/action/menu-item.hpp	2015-09-16 02:20:06.387574582 +0900
+++ higan/hiro/qt/action/menu-item.hpp	2015-09-16 13:08:13.398563352 +0900
@@ -5,7 +5,7 @@
 struct pMenuItem : pAction {
   Declare(MenuItem, Action)
 
-  auto setIcon(const image& icon) -> void;
+  auto setImage(const Image& image) -> void;
   auto setText(const string& text) -> void;
 
   auto _setState() -> void override;
diff -Nru higan/hiro/qt/action/menu-radio-item.cpp higan/hiro/qt/action/menu-radio-item.cpp
--- higan/hiro/qt/action/menu-radio-item.cpp	2015-09-16 02:20:06.387574582 +0900
+++ higan/hiro/qt/action/menu-radio-item.cpp	2015-09-16 13:08:13.399563352 +0900
@@ -18,6 +18,7 @@
     parent->qtPopupMenu->addAction(qtMenuRadioItem);
   }
 
+  setGroup(state().group);
   _setState();
 }
 
@@ -33,7 +34,19 @@
 }
 
 auto pMenuRadioItem::setGroup(sGroup group) -> void {
-  _setState();
+  bool first = true;
+  if(auto& group = state().group) {
+    for(auto& weak : group->state.objects) {
+      if(auto object = weak.acquire()) {
+        if(auto menuRadioItem = dynamic_cast<mMenuRadioItem*>(object.data())) {
+          if(auto self = menuRadioItem->self()) {
+            self->qtMenuRadioItem->setChecked(menuRadioItem->state.checked = first);
+            first = false;
+          }
+        }
+      }
+    }
+  }
 }
 
 auto pMenuRadioItem::setText(const string& text) -> void {
@@ -41,7 +54,7 @@
 }
 
 auto pMenuRadioItem::_setState() -> void {
-  if(auto group = state().group) {
+  if(auto& group = state().group) {
     if(auto object = group->object(0)) {
       if(auto menuRadioItem = dynamic_cast<mMenuRadioItem*>(object.data())) {
         if(auto self = menuRadioItem->self()) {
@@ -56,7 +69,7 @@
 
 auto QtMenuRadioItem::onActivate() -> void {
   if(p.state().checked) return;
-  p.state().checked = true;
+  p.self().setChecked();
   p.self().doActivate();
 }
 
diff -Nru higan/hiro/qt/font.cpp higan/hiro/qt/font.cpp
--- higan/hiro/qt/font.cpp	2015-09-16 02:20:06.387574582 +0900
+++ higan/hiro/qt/font.cpp	2015-09-16 13:08:13.410563353 +0900
@@ -2,61 +2,34 @@
 
 namespace hiro {
 
-auto pFont::serif(unsigned size, string style) -> string {
-  if(size == 0) size = 8;
-  if(style == "") style = "Normal";
-  return {"Serif, ", size, ", ", style};
-}
-
-auto pFont::sans(unsigned size, string style) -> string {
-  if(size == 0) size = 8;
-  if(style == "") style = "Normal";
-  return {"Sans, ", size, ", ", style};
-}
-
-auto pFont::monospace(unsigned size, string style) -> string {
-  if(size == 0) size = 8;
-  if(style == "") style = "Normal";
-  return {"Liberation Mono, ", size, ", ", style};
-}
-
-auto pFont::size(string font, string text) -> Size {
+auto pFont::size(const Font& font, const string& text) -> Size {
   return pFont::size(pFont::create(font), text);
 }
 
-auto pFont::create(string description) -> QFont {
-  lstring part = description.split(",", 2L).strip();
-
-  string family = "Sans";
-  unsigned size = 8u;
-  bool bold = false;
-  bool italic = false;
-
-  if(part[0] != "") family = part[0];
-  if(part.size() >= 2) size = decimal(part[1]);
-  if(part.size() >= 3) bold = (bool)part[2].find("Bold");
-  if(part.size() >= 3) italic = (bool)part[2].find("Italic");
-
-  QFont qtFont;
-  qtFont.setFamily(family);
-  qtFont.setPointSize(size);
-  if(bold) qtFont.setBold(true);
-  if(italic) qtFont.setItalic(true);
-  return qtFont;
-}
-
 auto pFont::size(const QFont& qtFont, const string& text) -> Size {
   QFontMetrics metrics(qtFont);
-
-  lstring lines;
-  lines.split(text ? text : " ", "\n");
-
-  unsigned maxWidth = 0;
+  signed maxWidth = 0;
+  auto lines = text.split("\n");
   for(auto& line : lines) {
     maxWidth = max(maxWidth, metrics.width(line));
   }
+  return {maxWidth, metrics.height() * (signed)lines.size()};
+}
 
-  return Size().setWidth(maxWidth).setHeight(metrics.height() * lines.size());
+auto pFont::family(const string& family) -> string {
+  if(family == "sans") return "Sans";
+  if(family == "serif") return "Serif";
+  if(family == "mono") return "Liberation Mono";
+  return family ? family : "Sans";
+}
+
+auto pFont::create(const Font& font) -> QFont {
+  QFont qtFont;
+  qtFont.setFamily(family(font.family()));
+  qtFont.setPointSize(font.size() ? font.size() : 8);
+  qtFont.setBold(font.bold());
+  qtFont.setItalic(font.italic());
+  return qtFont;
 }
 
 }
diff -Nru higan/hiro/qt/font.hpp higan/hiro/qt/font.hpp
--- higan/hiro/qt/font.hpp	2015-09-16 02:20:06.387574582 +0900
+++ higan/hiro/qt/font.hpp	2015-09-16 13:08:13.400563352 +0900
@@ -3,13 +3,10 @@
 namespace hiro {
 
 struct pFont {
-  static auto serif(unsigned size, string style) -> string;
-  static auto sans(unsigned size, string style) -> string;
-  static auto monospace(unsigned size, string style) -> string;
-  static auto size(string font, string text) -> Size;
-
-  static auto create(string description) -> QFont;
+  static auto size(const Font& font, const string& text) -> Size;
   static auto size(const QFont& qtFont, const string& text) -> Size;
+  static auto family(const string& family) -> string;
+  static auto create(const Font& font) -> QFont;
 };
 
 }
diff -Nru higan/hiro/qt/hotkey.cpp higan/hiro/qt/hotkey.cpp
--- higan/hiro/qt/hotkey.cpp	2015-09-16 02:20:06.387574582 +0900
+++ higan/hiro/qt/hotkey.cpp	1970-01-01 09:00:00.000000000 +0900
@@ -1,13 +0,0 @@
-#if defined(Hiro_Hotkey)
-
-namespace hiro {
-
-auto pHotkey::construct() -> void {
-}
-
-auto pHotkey::destruct() -> void {
-}
-
-}
-
-#endif
diff -Nru higan/hiro/qt/hotkey.hpp higan/hiro/qt/hotkey.hpp
--- higan/hiro/qt/hotkey.hpp	2015-09-16 02:20:06.387574582 +0900
+++ higan/hiro/qt/hotkey.hpp	1970-01-01 09:00:00.000000000 +0900
@@ -1,11 +0,0 @@
-#if defined(Hiro_Hotkey)
-
-namespace hiro {
-
-struct pHotkey : pObject {
-  Declare(Hotkey, Object)
-};
-
-}
-
-#endif
diff -Nru higan/hiro/qt/menu-bar.cpp higan/hiro/qt/menu-bar.cpp
--- higan/hiro/qt/menu-bar.cpp	2015-09-16 02:20:06.387574582 +0900
+++ higan/hiro/qt/menu-bar.cpp	2015-09-16 13:08:13.413563353 +0900
@@ -19,7 +19,7 @@
   _setState();
 }
 
-auto pMenuBar::setFont(const string& font) -> void {
+auto pMenuBar::setFont(const Font& font) -> void {
   _setState();
 }
 
diff -Nru higan/hiro/qt/menu-bar.hpp higan/hiro/qt/menu-bar.hpp
--- higan/hiro/qt/menu-bar.hpp	2015-09-16 02:20:06.387574582 +0900
+++ higan/hiro/qt/menu-bar.hpp	2015-09-16 13:08:13.413563353 +0900
@@ -8,7 +8,7 @@
   auto append(sMenu menu) -> void;
   auto remove(sMenu menu) -> void;
   auto setEnabled(bool enabled) -> void override;
-  auto setFont(const string& font) -> void override;
+  auto setFont(const Font& font) -> void override;
   auto setVisible(bool visible) -> void override;
 
   auto _parent() -> maybe<pWindow&>;
diff -Nru higan/hiro/qt/object.cpp higan/hiro/qt/object.cpp
--- higan/hiro/qt/object.cpp	2015-09-16 02:20:06.388574582 +0900
+++ higan/hiro/qt/object.cpp	2015-09-16 13:08:13.398563352 +0900
@@ -24,7 +24,7 @@
 auto pObject::setFocused() -> void {
 }
 
-auto pObject::setFont(const string& font) -> void {
+auto pObject::setFont(const Font& font) -> void {
 }
 
 auto pObject::setVisible(bool visible) -> void {
diff -Nru higan/hiro/qt/object.hpp higan/hiro/qt/object.hpp
--- higan/hiro/qt/object.hpp	2015-09-16 02:20:06.388574582 +0900
+++ higan/hiro/qt/object.hpp	2015-09-16 13:08:13.401563352 +0900
@@ -15,7 +15,7 @@
   virtual auto reset() -> void;
   virtual auto setEnabled(bool enabled) -> void;
   virtual auto setFocused() -> void;
-  virtual auto setFont(const string& font) -> void;
+  virtual auto setFont(const Font& font) -> void;
   virtual auto setVisible(bool visible) -> void;
 
   auto locked() const -> bool { return locks != 0; }
diff -Nru higan/hiro/qt/platform.cpp higan/hiro/qt/platform.cpp
--- higan/hiro/qt/platform.cpp	2015-09-16 02:20:06.388574582 +0900
+++ higan/hiro/qt/platform.cpp	2015-09-16 13:08:13.413563353 +0900
@@ -16,7 +16,6 @@
 #include "object.cpp"
 #include "group.cpp"
 
-#include "hotkey.cpp"
 #include "timer.cpp"
 #include "window.cpp"
 #include "status-bar.cpp"
diff -Nru higan/hiro/qt/platform.hpp higan/hiro/qt/platform.hpp
--- higan/hiro/qt/platform.hpp	2015-09-16 02:20:06.388574582 +0900
+++ higan/hiro/qt/platform.hpp	2015-09-16 13:08:13.400563352 +0900
@@ -19,7 +19,6 @@
 #include "object.hpp"
 #include "group.hpp"
 
-#include "hotkey.hpp"
 #include "timer.hpp"
 #include "window.hpp"
 #include "status-bar.hpp"
diff -Nru higan/hiro/qt/popup-menu.cpp higan/hiro/qt/popup-menu.cpp
--- higan/hiro/qt/popup-menu.cpp	2015-09-16 02:20:06.388574582 +0900
+++ higan/hiro/qt/popup-menu.cpp	2015-09-16 13:08:13.413563353 +0900
@@ -20,7 +20,7 @@
   _setState();
 }
 
-auto pPopupMenu::setFont(const string& font) -> void {
+auto pPopupMenu::setFont(const Font& font) -> void {
   _setState();
 }
 
diff -Nru higan/hiro/qt/popup-menu.hpp higan/hiro/qt/popup-menu.hpp
--- higan/hiro/qt/popup-menu.hpp	2015-09-16 02:20:06.388574582 +0900
+++ higan/hiro/qt/popup-menu.hpp	2015-09-16 13:08:13.411563353 +0900
@@ -7,7 +7,7 @@
 
   auto append(sAction action) -> void;
   auto remove(sAction action) -> void;
-  auto setFont(const string& font) -> void override;
+  auto setFont(const Font& font) -> void override;
   auto setVisible(bool visible) -> void override;
 
   auto _setState() -> void;
diff -Nru higan/hiro/qt/status-bar.cpp higan/hiro/qt/status-bar.cpp
--- higan/hiro/qt/status-bar.cpp	2015-09-16 02:20:06.388574582 +0900
+++ higan/hiro/qt/status-bar.cpp	2015-09-16 13:08:13.410563353 +0900
@@ -13,7 +13,7 @@
   _setState();
 }
 
-auto pStatusBar::setFont(const string& font) -> void {
+auto pStatusBar::setFont(const Font& font) -> void {
   _setState();
 }
 
diff -Nru higan/hiro/qt/status-bar.hpp higan/hiro/qt/status-bar.hpp
--- higan/hiro/qt/status-bar.hpp	2015-09-16 02:20:06.388574582 +0900
+++ higan/hiro/qt/status-bar.hpp	2015-09-16 13:08:13.411563353 +0900
@@ -6,7 +6,7 @@
   Declare(StatusBar, Object)
 
   auto setEnabled(bool enabled) -> void override;
-  auto setFont(const string& font) -> void override;
+  auto setFont(const Font& font) -> void override;
   auto setText(const string& text) -> void;
   auto setVisible(bool visible) -> void override;
 
diff -Nru higan/hiro/qt/utility.cpp higan/hiro/qt/utility.cpp
--- higan/hiro/qt/utility.cpp	2015-09-16 02:20:06.388574582 +0900
+++ higan/hiro/qt/utility.cpp	2015-09-16 13:08:13.414563353 +0900
@@ -24,6 +24,12 @@
   return QIcon(QPixmap::fromImage(qtImage));
 }
 
+static auto CreateImage(const Image& image, bool scale = false) -> QIcon {
+  if(!image) return QIcon();
+  QImage qtImage((const uint8_t*)image.data(), image.width(), image.height(), QImage::Format_ARGB32);
+  return QIcon(QPixmap::fromImage(qtImage));
+}
+
 static auto DropPaths(QDropEvent* event) -> lstring {
   QList<QUrl> urls = event->mimeData()->urls();
   if(urls.size() == 0) return {};
diff -Nru higan/hiro/qt/widget/button.cpp higan/hiro/qt/widget/button.cpp
--- higan/hiro/qt/widget/button.cpp	2015-09-16 02:20:06.388574582 +0900
+++ higan/hiro/qt/widget/button.cpp	2015-09-16 13:08:13.401563352 +0900
@@ -8,7 +8,7 @@
   qtButton->connect(qtButton, SIGNAL(released()), SLOT(onActivate()));
 
   setBordered(state().bordered);
-  setIcon(state().icon);
+  setImage(state().image);
   setOrientation(state().orientation);
   setText(state().text);
 
@@ -21,16 +21,16 @@
 }
 
 auto pButton::minimumSize() const -> Size {
-  auto size = pFont::size(qtWidget->font(), state().text);
+  auto size = pFont::size(qtWidget->font(), state().text ? state().text : " ");
 
   if(state().orientation == Orientation::Horizontal) {
-    size.setWidth(size.width() + state().icon.width());
-    size.setHeight(max(state().icon.height(), size.height()));
+    size.setWidth(size.width() + state().image.width());
+    size.setHeight(max(state().image.height(), size.height()));
   }
 
   if(state().orientation == Orientation::Vertical) {
-    size.setWidth(max(state().icon.width(), size.width()));
-    size.setHeight(size.height() + state().icon.height());
+    size.setWidth(max(state().image.width(), size.width()));
+    size.setHeight(size.height() + state().image.height());
   }
 
   return {size.width() + (state().text ? 20 : 12), size.height() + 12};
@@ -40,9 +40,9 @@
   qtButton->setAutoRaise(!bordered);
 }
 
-auto pButton::setIcon(const image& icon) -> void {
-  qtButton->setIconSize(QSize(icon.width(), icon.height()));
-  qtButton->setIcon(CreateIcon(icon));
+auto pButton::setImage(const Image& image) -> void {
+  qtButton->setIconSize(QSize(image.width(), image.height()));
+  qtButton->setIcon(CreateImage(image));
   qtButton->setStyleSheet("text-align: top;");
 }
 
diff -Nru higan/hiro/qt/widget/button.hpp higan/hiro/qt/widget/button.hpp
--- higan/hiro/qt/widget/button.hpp	2015-09-16 02:20:06.388574582 +0900
+++ higan/hiro/qt/widget/button.hpp	2015-09-16 13:08:13.402563352 +0900
@@ -7,7 +7,7 @@
 
   auto minimumSize() const -> Size override;
   auto setBordered(bool bordered) -> void;
-  auto setIcon(const image& icon) -> void;
+  auto setImage(const Image& image) -> void;
   auto setOrientation(Orientation orientation) -> void;
   auto setText(const string& text) -> void;
 
diff -Nru higan/hiro/qt/widget/canvas.cpp higan/hiro/qt/widget/canvas.cpp
--- higan/hiro/qt/widget/canvas.cpp	2015-09-16 02:20:06.388574582 +0900
+++ higan/hiro/qt/widget/canvas.cpp	2015-09-16 13:08:13.402563352 +0900
@@ -18,16 +18,11 @@
 }
 
 auto pCanvas::minimumSize() const -> Size {
-  return {max(0, state().size.width()), max(0, state().size.height())};
+  if(auto& image = state().image) return image.size();
+  return {0, 0};
 }
 
 auto pCanvas::setColor(Color color) -> void {
-  mode = Mode::Color;
-  update();
-}
-
-auto pCanvas::setData(Size size) -> void {
-  mode = Mode::Data;
   update();
 }
 
@@ -40,13 +35,11 @@
   pWidget::setGeometry(geometry);
 }
 
-auto pCanvas::setGradient(Color topLeft, Color topRight, Color bottomLeft, Color bottomRight) -> void {
-  mode = Mode::Gradient;
+auto pCanvas::setGradient(Gradient gradient) -> void {
   update();
 }
 
-auto pCanvas::setIcon(const image& icon) -> void {
-  mode = Mode::Icon;
+auto pCanvas::setImage(const Image& image) -> void {
   update();
 }
 
@@ -59,14 +52,13 @@
   signed width = 0;
   signed height = 0;
 
-  if(mode == Mode::Color || mode == Mode::Gradient) {
+  if(auto& image = state().image) {
+    width = image.width();
+    height = image.height();
+  } else {
     width = pSizable::state().geometry.width();
     height = pSizable::state().geometry.height();
-  } else {
-    width = state().size.width();
-    height = state().size.height();
   }
-
   if(width <= 0 || height <= 0) return;
 
   if(width != qtImageWidth || height != qtImageHeight) _release();
@@ -76,29 +68,17 @@
   if(!qtImage) qtImage = new QImage(width, height, QImage::Format_ARGB32);
   auto buffer = (uint32_t*)qtImage->bits();
 
-  if(mode == Mode::Color) {
-    uint32_t color = state().color.value();
-    for(auto n : range(width * height)) buffer[n] = color;
-  }
-
-  if(mode == Mode::Gradient) {
-    image fill;
+  if(auto& image = state().image) {
+    memory::copy(buffer, state().image.data(), width * height * sizeof(uint32_t));
+  } else if(auto& gradient = state().gradient) {
+    auto& colors = gradient.state.colors;
+    nall::image fill;
     fill.allocate(width, height);
-    fill.gradient(
-      state().gradient[0].value(), state().gradient[1].value(), state().gradient[2].value(), state().gradient[3].value()
-    );
+    fill.gradient(colors[0].value(), colors[1].value(), colors[2].value(), colors[3].value());
     memory::copy(buffer, fill.data(), fill.size());
-  }
-
-  if(mode == Mode::Icon) {
-    auto icon = state().icon;
-    icon.scale(width, height);
-    icon.transform();
-    memory::copy(buffer, icon.data(), icon.size());
-  }
-
-  if(mode == Mode::Data) {
-    memory::copy(buffer, state().data.data(), state().data.size() * sizeof(uint32_t));
+  } else {
+    uint32_t color = state().color.value();
+    for(auto n : range(width * height)) buffer[n] = color;
   }
 }
 
diff -Nru higan/hiro/qt/widget/canvas.hpp higan/hiro/qt/widget/canvas.hpp
--- higan/hiro/qt/widget/canvas.hpp	2015-09-16 02:20:06.388574582 +0900
+++ higan/hiro/qt/widget/canvas.hpp	2015-09-16 13:08:13.405563352 +0900
@@ -7,15 +7,12 @@
 
   auto minimumSize() const -> Size;
   auto setColor(Color color) -> void;
-  auto setData(Size size) -> void;
   auto setDroppable(bool droppable) -> void;
   auto setGeometry(Geometry geometry) -> void;
-  auto setGradient(Color topLeft, Color topRight, Color bottomLeft, Color bottomRight) -> void;
-  auto setIcon(const image& icon) -> void;
+  auto setGradient(Gradient gradient) -> void;
+  auto setImage(const Image& image) -> void;
   auto update() -> void;
 
-  enum class Mode : unsigned { Color, Data, Gradient, Icon };
-
   auto _rasterize() -> void;
   auto _release() -> void;
 
@@ -23,7 +20,6 @@
   QImage* qtImage = nullptr;
   unsigned qtImageWidth = 0;
   unsigned qtImageHeight = 0;
-  Mode mode = Mode::Color;
 };
 
 }
diff -Nru higan/hiro/qt/widget/check-button.cpp higan/hiro/qt/widget/check-button.cpp
--- higan/hiro/qt/widget/check-button.cpp	2015-09-16 02:20:06.388574582 +0900
+++ higan/hiro/qt/widget/check-button.cpp	2015-09-16 13:08:13.404563352 +0900
@@ -21,13 +21,13 @@
   auto size = pFont::size(qtWidget->font(), state().text);
 
   if(state().orientation == Orientation::Horizontal) {
-    size.setWidth(size.width() + state().icon.width());
-    size.setHeight(max(state().icon.height(), size.height()));
+    size.setWidth(size.width() + state().image.width());
+    size.setHeight(max(state().image.height(), size.height()));
   }
 
   if(state().orientation == Orientation::Vertical) {
-    size.setWidth(max(state().icon.width(), size.width()));
-    size.setHeight(size.height() + state().icon.height());
+    size.setWidth(max(state().image.width(), size.width()));
+    size.setHeight(size.height() + state().image.height());
   }
 
   return {size.width() + 20, size.height() + 12};
@@ -41,7 +41,7 @@
   _setState();
 }
 
-auto pCheckButton::setIcon(const image& icon) -> void {
+auto pCheckButton::setImage(const Image& image) -> void {
   _setState();
 }
 
@@ -57,8 +57,8 @@
   lock();
   qtCheckButton->setAutoRaise(!state().bordered);
   qtCheckButton->setChecked(state().checked);
-  qtCheckButton->setIconSize(QSize(state().icon.width(), state().icon.height()));
-  qtCheckButton->setIcon(CreateIcon(state().icon));
+  qtCheckButton->setIconSize(QSize(state().image.width(), state().image.height()));
+  qtCheckButton->setIcon(CreateImage(state().image));
   qtCheckButton->setStyleSheet("text-align: top;");
   switch(state().orientation) {
   case Orientation::Horizontal: qtCheckButton->setToolButtonStyle(Qt::ToolButtonTextBesideIcon); break;
diff -Nru higan/hiro/qt/widget/check-button.hpp higan/hiro/qt/widget/check-button.hpp
--- higan/hiro/qt/widget/check-button.hpp	2015-09-16 02:20:06.388574582 +0900
+++ higan/hiro/qt/widget/check-button.hpp	2015-09-16 13:08:13.402563352 +0900
@@ -8,7 +8,7 @@
   auto minimumSize() const -> Size override;
   auto setBordered(bool bordered) -> void;
   auto setChecked(bool checked) -> void;
-  auto setIcon(const image& icon) -> void;
+  auto setImage(const Image& image) -> void;
   auto setOrientation(Orientation orientation) -> void;
   auto setText(const string& text) -> void;
 
diff -Nru higan/hiro/qt/widget/combo-button-item.cpp higan/hiro/qt/widget/combo-button-item.cpp
--- higan/hiro/qt/widget/combo-button-item.cpp	2015-09-16 02:20:06.389574582 +0900
+++ higan/hiro/qt/widget/combo-button-item.cpp	2015-09-16 13:08:13.403563352 +0900
@@ -19,7 +19,7 @@
   }
 }
 
-auto pComboButtonItem::setIcon(const image& icon) -> void {
+auto pComboButtonItem::setImage(const Image& image) -> void {
   _setState();
 }
 
@@ -40,7 +40,7 @@
 
 auto pComboButtonItem::_setState() -> void {
   if(auto parent = _parent()) {
-    parent->qtComboButton->setItemIcon(self().offset(), CreateIcon(state().icon));
+    parent->qtComboButton->setItemIcon(self().offset(), CreateImage(state().image));
     if(state().selected) parent->qtComboButton->setCurrentIndex(self().offset());
     parent->qtComboButton->setItemText(self().offset(), QString::fromUtf8(state().text));
   }
diff -Nru higan/hiro/qt/widget/combo-button-item.hpp higan/hiro/qt/widget/combo-button-item.hpp
--- higan/hiro/qt/widget/combo-button-item.hpp	2015-09-16 02:20:06.389574582 +0900
+++ higan/hiro/qt/widget/combo-button-item.hpp	2015-09-16 13:08:13.409563353 +0900
@@ -5,7 +5,7 @@
 struct pComboButtonItem : pObject {
   Declare(ComboButtonItem, Object)
 
-  auto setIcon(const image& icon) -> void;
+  auto setImage(const Image& image) -> void;
   auto setSelected() -> void;
   auto setText(const string& text) -> void;
 
diff -Nru higan/hiro/qt/widget/list-view-cell.cpp higan/hiro/qt/widget/list-view-cell.cpp
--- higan/hiro/qt/widget/list-view-cell.cpp	2015-09-16 02:20:06.389574582 +0900
+++ higan/hiro/qt/widget/list-view-cell.cpp	2015-09-16 13:08:13.404563352 +0900
@@ -32,7 +32,7 @@
   _setState();
 }
 
-auto pListViewCell::setIcon(const image& icon) -> void {
+auto pListViewCell::setImage(const Image& image) -> void {
   _setState();
 }
 
@@ -60,7 +60,7 @@
       }
       parent->qtItem->setFont(self().offset(), pFont::create(self().font(true)));
       parent->qtItem->setForeground(self().offset(), CreateBrush(self().foregroundColor(true)));
-      parent->qtItem->setIcon(self().offset(), CreateIcon(state().icon));
+      parent->qtItem->setIcon(self().offset(), CreateImage(state().image));
       parent->qtItem->setText(self().offset(), QString::fromUtf8(state().text));
       parent->qtItem->setTextAlignment(self().offset(), CalculateAlignment(self().alignment(true)));
       grandparent->unlock();
diff -Nru higan/hiro/qt/widget/list-view-cell.hpp higan/hiro/qt/widget/list-view-cell.hpp
--- higan/hiro/qt/widget/list-view-cell.hpp	2015-09-16 02:20:06.389574582 +0900
+++ higan/hiro/qt/widget/list-view-cell.hpp	2015-09-16 13:08:13.403563352 +0900
@@ -11,7 +11,7 @@
   auto setChecked(bool checked) -> void;
   auto setFont(const string& font) -> void;
   auto setForegroundColor(Color color) -> void;
-  auto setIcon(const image& icon) -> void;
+  auto setImage(const Image& image) -> void;
   auto setText(const string& text) -> void;
 
   auto _parent() -> maybe<pListViewItem&>;
diff -Nru higan/hiro/qt/widget/list-view-column.cpp higan/hiro/qt/widget/list-view-column.cpp
--- higan/hiro/qt/widget/list-view-column.cpp	2015-09-16 02:20:06.389574582 +0900
+++ higan/hiro/qt/widget/list-view-column.cpp	2015-09-16 13:08:13.408563353 +0900
@@ -28,7 +28,7 @@
   _setState();
 }
 
-auto pListViewColumn::setFont(const string& font) -> void {
+auto pListViewColumn::setFont(const Font& font) -> void {
   _setState();
 }
 
@@ -40,7 +40,7 @@
   _setState();
 }
 
-auto pListViewColumn::setIcon(const image& icon) -> void {
+auto pListViewColumn::setImage(const Image& image) -> void {
   //unsupported
 }
 
diff -Nru higan/hiro/qt/widget/list-view-column.hpp higan/hiro/qt/widget/list-view-column.hpp
--- higan/hiro/qt/widget/list-view-column.hpp	2015-09-16 02:20:06.389574582 +0900
+++ higan/hiro/qt/widget/list-view-column.hpp	2015-09-16 13:08:13.407563353 +0900
@@ -10,10 +10,10 @@
   auto setBackgroundColor(Color color) -> void;
   auto setEditable(bool editable) -> void;
   auto setExpandable(bool expandable) -> void;
-  auto setFont(const string& font) -> void override;
+  auto setFont(const Font& font) -> void override;
   auto setForegroundColor(Color color) -> void;
   auto setHorizontalAlignment(double alignment) -> void;
-  auto setIcon(const image& icon) -> void;
+  auto setImage(const Image& image) -> void;
   auto setResizable(bool resizable) -> void;
   auto setSortable(bool sortable) -> void;
   auto setText(const string& text) -> void;
diff -Nru higan/hiro/qt/widget/list-view.cpp higan/hiro/qt/widget/list-view.cpp
--- higan/hiro/qt/widget/list-view.cpp	2015-09-16 02:20:06.389574582 +0900
+++ higan/hiro/qt/widget/list-view.cpp	2015-09-16 13:08:13.406563353 +0900
@@ -154,11 +154,11 @@
   unsigned width = 8;
   if(auto& header = state().header) {
     if(auto column = header->column(_column)) {
-      if(auto& icon = column->state.icon) {
-        width += icon.width() + 2;
+      if(auto& image = column->state.image) {
+        width += image.width() + 2;
       }
       if(auto& text = column->state.text) {
-        width += Font::size(column->font(true), text).width();
+        width += pFont::size(column->font(true), text).width();
       }
     }
   }
@@ -172,11 +172,11 @@
       if(cell->state.checkable) {
         width += 16 + 2;
       }
-      if(auto& icon = cell->state.icon) {
-        width += icon.width() + 2;
+      if(auto& image = cell->state.image) {
+        width += image.width() + 2;
       }
       if(auto& text = cell->state.text) {
-        width += Font::size(cell->font(true), text).width();
+        width += pFont::size(cell->font(true), text).width();
       }
     }
   }
diff -Nru higan/hiro/qt/widget/list-view-item.cpp higan/hiro/qt/widget/list-view-item.cpp
--- higan/hiro/qt/widget/list-view-item.cpp	2015-09-16 02:20:06.389574582 +0900
+++ higan/hiro/qt/widget/list-view-item.cpp	2015-09-16 13:08:13.403563352 +0900
@@ -28,7 +28,7 @@
   _setState();
 }
 
-auto pListViewItem::setFont(const string& font) -> void {
+auto pListViewItem::setFont(const Font& font) -> void {
   _setState();
 }
 
diff -Nru higan/hiro/qt/widget/list-view-item.hpp higan/hiro/qt/widget/list-view-item.hpp
--- higan/hiro/qt/widget/list-view-item.hpp	2015-09-16 02:20:06.389574582 +0900
+++ higan/hiro/qt/widget/list-view-item.hpp	2015-09-16 13:08:13.401563352 +0900
@@ -9,7 +9,7 @@
   auto remove(sListViewCell cell) -> void;
   auto setAlignment(Alignment alignment) -> void;
   auto setBackgroundColor(Color color) -> void;
-  auto setFont(const string& font) -> void override;
+  auto setFont(const Font& font) -> void override;
   auto setForegroundColor(Color color) -> void;
   auto setSelected(bool selected) -> void;
 
diff -Nru higan/hiro/qt/widget/radio-button.cpp higan/hiro/qt/widget/radio-button.cpp
--- higan/hiro/qt/widget/radio-button.cpp	2015-09-16 02:20:06.389574582 +0900
+++ higan/hiro/qt/widget/radio-button.cpp	2015-09-16 13:08:13.406563353 +0900
@@ -9,6 +9,7 @@
   qtRadioButton->connect(qtRadioButton, SIGNAL(toggled(bool)), SLOT(onActivate()));
 
   pWidget::construct();
+  setGroup(state().group);
   _setState();
 }
 
@@ -21,13 +22,13 @@
   auto size = pFont::size(qtWidget->font(), state().text);
 
   if(state().orientation == Orientation::Horizontal) {
-    size.setWidth(size.width() + state().icon.width());
-    size.setHeight(max(state().icon.height(), size.height()));
+    size.setWidth(size.width() + state().image.width());
+    size.setHeight(max(state().image.height(), size.height()));
   }
 
   if(state().orientation == Orientation::Vertical) {
-    size.setWidth(max(state().icon.width(), size.width()));
-    size.setHeight(size.height() + state().icon.height());
+    size.setWidth(max(state().image.width(), size.width()));
+    size.setHeight(size.height() + state().image.height());
   }
 
   return {size.width() + 20, size.height() + 12};
@@ -41,10 +42,24 @@
 }
 
 auto pRadioButton::setGroup(sGroup group) -> void {
-  _setState();
+  bool first = true;
+  if(auto& group = state().group) {
+    group->self()->lock();
+    for(auto& weak : group->state.objects) {
+      if(auto object = weak.acquire()) {
+        if(auto radioButton = dynamic_cast<mRadioButton*>(object.data())) {
+          if(auto self = radioButton->self()) {
+            self->qtRadioButton->setChecked(radioButton->state.checked = first);
+            first = false;
+          }
+        }
+      }
+    }
+    group->self()->unlock();
+  }
 }
 
-auto pRadioButton::setIcon(const image& icon) -> void {
+auto pRadioButton::setImage(const Image& image) -> void {
   _setState();
 }
 
@@ -70,8 +85,8 @@
     }
     group->self()->unlock();
   }
-  qtRadioButton->setIconSize(QSize(state().icon.width(), state().icon.height()));
-  qtRadioButton->setIcon(CreateIcon(state().icon));
+  qtRadioButton->setIconSize(QSize(state().image.width(), state().image.height()));
+  qtRadioButton->setIcon(CreateImage(state().image));
   qtRadioButton->setStyleSheet("text-align: top;");
   switch(state().orientation) {
   case Orientation::Horizontal: qtRadioButton->setToolButtonStyle(Qt::ToolButtonTextBesideIcon); break;
diff -Nru higan/hiro/qt/widget/radio-button.hpp higan/hiro/qt/widget/radio-button.hpp
--- higan/hiro/qt/widget/radio-button.hpp	2015-09-16 02:20:06.389574582 +0900
+++ higan/hiro/qt/widget/radio-button.hpp	2015-09-16 13:08:13.409563353 +0900
@@ -9,7 +9,7 @@
   auto setBordered(bool bordered) -> void;
   auto setChecked() -> void;
   auto setGroup(sGroup group) -> void;
-  auto setIcon(const image& icon) -> void;
+  auto setImage(const Image& image) -> void;
   auto setOrientation(Orientation orientation) -> void;
   auto setText(const string& text) -> void;
 
diff -Nru higan/hiro/qt/widget/radio-label.cpp higan/hiro/qt/widget/radio-label.cpp
--- higan/hiro/qt/widget/radio-label.cpp	2015-09-16 02:20:06.389574582 +0900
+++ higan/hiro/qt/widget/radio-label.cpp	2015-09-16 13:08:13.408563353 +0900
@@ -8,6 +8,7 @@
   qtRadioLabel->connect(qtRadioLabel, SIGNAL(toggled(bool)), SLOT(onActivate()));
 
   pWidget::construct();
+  setGroup(state().group);
   _setState();
 }
 
@@ -26,7 +27,21 @@
 }
 
 auto pRadioLabel::setGroup(sGroup group) -> void {
-  _setState();
+  bool first = true;
+  if(auto& group = state().group) {
+    group->self()->lock();
+    for(auto& weak : group->state.objects) {
+      if(auto object = weak.acquire()) {
+        if(auto radioLabel = dynamic_cast<mRadioLabel*>(object.data())) {
+          if(auto self = radioLabel->self()) {
+            self->qtRadioLabel->setChecked(radioLabel->state.checked = first);
+            first = false;
+          }
+        }
+      }
+    }
+    group->self()->unlock();
+  }
 }
 
 auto pRadioLabel::setText(const string& text) -> void {
diff -Nru higan/hiro/qt/widget/tab-frame.cpp higan/hiro/qt/widget/tab-frame.cpp
--- higan/hiro/qt/widget/tab-frame.cpp	2015-09-16 02:20:06.390574582 +0900
+++ higan/hiro/qt/widget/tab-frame.cpp	2015-09-16 13:08:13.407563353 +0900
@@ -22,9 +22,6 @@
 auto pTabFrame::remove(sTabFrameItem item) -> void {
 }
 
-auto pTabFrame::setEdge(Edge edge) -> void {
-}
-
 auto pTabFrame::setGeometry(Geometry geometry) -> void {
   pWidget::setGeometry(geometry);
 
@@ -33,7 +30,18 @@
   }
 }
 
+auto pTabFrame::setNavigation(Navigation navigation) -> void {
+  _setState();
+}
+
 auto pTabFrame::_setState() -> void {
+  switch(state().navigation) { default:
+  case Navigation::Top: qtTabFrame->setTabPosition(QTabWidget::TabPosition::North); break;
+  case Navigation::Bottom: qtTabFrame->setTabPosition(QTabWidget::TabPosition::South); break;
+  case Navigation::Left: qtTabFrame->setTabPosition(QTabWidget::TabPosition::West); break;
+  case Navigation::Right: qtTabFrame->setTabPosition(QTabWidget::TabPosition::East); break;
+  }
+
   for(auto& item : state().items) {
     if(auto self = item->self()) self->_setState();
   }
diff -Nru higan/hiro/qt/widget/tab-frame.hpp higan/hiro/qt/widget/tab-frame.hpp
--- higan/hiro/qt/widget/tab-frame.hpp	2015-09-16 02:20:06.390574582 +0900
+++ higan/hiro/qt/widget/tab-frame.hpp	2015-09-16 13:08:13.405563352 +0900
@@ -7,8 +7,8 @@
 
   auto append(sTabFrameItem item) -> void;
   auto remove(sTabFrameItem item) -> void;
-  auto setEdge(Edge edge) -> void;
   auto setGeometry(Geometry geometry) -> void override;
+  auto setNavigation(Navigation navigation) -> void;
 
   auto _setState() -> void;
 
diff -Nru higan/hiro/qt/widget/tab-frame-item.cpp higan/hiro/qt/widget/tab-frame-item.cpp
--- higan/hiro/qt/widget/tab-frame-item.cpp	2015-09-16 02:20:06.389574582 +0900
+++ higan/hiro/qt/widget/tab-frame-item.cpp	2015-09-16 13:08:13.402563352 +0900
@@ -34,7 +34,7 @@
   }
 }
 
-auto pTabFrameItem::setIcon(const image& icon) -> void {
+auto pTabFrameItem::setImage(const Image& image) -> void {
   _setState();
 }
 
@@ -62,7 +62,7 @@
 
 auto pTabFrameItem::_setState() -> void {
   if(auto parent = _parent()) {
-    parent->qtTabFrame->setTabIcon(self().offset(), CreateIcon(state().icon));
+    parent->qtTabFrame->setTabIcon(self().offset(), CreateImage(state().image));
     if(state().selected) parent->qtTabFrame->setCurrentIndex(self().offset());
     parent->qtTabFrame->setTabText(self().offset(), QString::fromUtf8(state().text));
     if(auto layout = state().layout) {
diff -Nru higan/hiro/qt/widget/tab-frame-item.hpp higan/hiro/qt/widget/tab-frame-item.hpp
--- higan/hiro/qt/widget/tab-frame-item.hpp	2015-09-16 02:20:06.389574582 +0900
+++ higan/hiro/qt/widget/tab-frame-item.hpp	2015-09-16 13:08:13.405563352 +0900
@@ -8,7 +8,7 @@
   auto append(sLayout layout) -> void;
   auto remove(sLayout layout) -> void;
   auto setClosable(bool closable) -> void;
-  auto setIcon(const image& icon) -> void;
+  auto setImage(const Image& image) -> void;
   auto setGeometry(Geometry geometry) -> void;
   auto setMovable(bool movable) -> void;
   auto setSelected() -> void;
diff -Nru higan/hiro/qt/widget/text-edit.cpp higan/hiro/qt/widget/text-edit.cpp
--- higan/hiro/qt/widget/text-edit.cpp	2015-09-16 02:20:06.390574582 +0900
+++ higan/hiro/qt/widget/text-edit.cpp	2015-09-16 13:08:13.407563353 +0900
@@ -19,7 +19,7 @@
   _setState();
 }
 
-auto pTextEdit::setCursorPosition(unsigned position) -> void {
+auto pTextEdit::setCursor(Cursor cursor) -> void {
   _setState();
 }
 
@@ -53,8 +53,9 @@
     //todo
   }
   QTextCursor cursor = qtTextEdit->textCursor();
-  unsigned lastCharacter = strlen(qtTextEdit->toPlainText().toUtf8().constData());
-  cursor.setPosition(min(state().cursorPosition, lastCharacter));
+  signed lastCharacter = strlen(qtTextEdit->toPlainText().toUtf8().constData());
+  cursor.setPosition(max(0, min(lastCharacter, state().cursor.offset())));
+  cursor.setPosition(max(0, min(lastCharacter, state().cursor.offset() + state().cursor.length())), QTextCursor::KeepAnchor);
   qtTextEdit->setTextCursor(cursor);
   qtTextEdit->setTextInteractionFlags(state().editable
     ? Qt::TextEditorInteraction
diff -Nru higan/hiro/qt/widget/text-edit.hpp higan/hiro/qt/widget/text-edit.hpp
--- higan/hiro/qt/widget/text-edit.hpp	2015-09-16 02:20:06.390574582 +0900
+++ higan/hiro/qt/widget/text-edit.hpp	2015-09-16 13:08:13.405563352 +0900
@@ -6,7 +6,7 @@
   Declare(TextEdit, Widget)
 
   auto setBackgroundColor(Color color) -> void;
-  auto setCursorPosition(unsigned position) -> void;
+  auto setCursor(Cursor cursor) -> void;
   auto setEditable(bool editable) -> void;
   auto setForegroundColor(Color color) -> void;
   auto setText(const string& text) -> void;
diff -Nru higan/hiro/qt/widget/widget.cpp higan/hiro/qt/widget/widget.cpp
--- higan/hiro/qt/widget/widget.cpp	2015-09-16 02:20:06.390574582 +0900
+++ higan/hiro/qt/widget/widget.cpp	2015-09-16 13:08:13.402563352 +0900
@@ -47,7 +47,7 @@
   qtWidget->setFocus(Qt::OtherFocusReason);
 }
 
-auto pWidget::setFont(const string& font) -> void {
+auto pWidget::setFont(const Font& font) -> void {
   if(!qtWidget) return;
   qtWidget->setFont(pFont::create(font));
 }
diff -Nru higan/hiro/qt/widget/widget.hpp higan/hiro/qt/widget/widget.hpp
--- higan/hiro/qt/widget/widget.hpp	2015-09-16 02:20:06.390574582 +0900
+++ higan/hiro/qt/widget/widget.hpp	2015-09-16 13:08:13.405563352 +0900
@@ -8,7 +8,7 @@
   auto focused() const -> bool override;
   auto setEnabled(bool enabled) -> void override;
   auto setFocused() -> void override;
-  auto setFont(const string& font) -> void override;
+  auto setFont(const Font& font) -> void override;
   auto setGeometry(Geometry geometry) -> void override;
   auto setVisible(bool visible) -> void override;
 
diff -Nru higan/hiro/qt/window.cpp higan/hiro/qt/window.cpp
--- higan/hiro/qt/window.cpp	2015-09-16 02:20:06.390574582 +0900
+++ higan/hiro/qt/window.cpp	2015-09-16 13:08:13.412563353 +0900
@@ -89,13 +89,6 @@
 auto pWindow::remove(sStatusBar statusBar) -> void {
 }
 
-/*
-  //orphan() destroys and recreates widgets (to disassociate them from their parent);
-  //attempting to create widget again after QApplication::quit() crashes libQtGui
-  if(qtApplication) widget.p.orphan();
-}
-*/
-
 auto pWindow::setBackgroundColor(Color color) -> void {
   if(color) {
     QPalette palette;
@@ -120,15 +113,20 @@
 }
 
 auto pWindow::setFullScreen(bool fullScreen) -> void {
-  if(!fullScreen) {
-    setResizable(state().resizable);
-    qtWindow->showNormal();
-    qtWindow->adjustSize();
-  } else {
+  lock();
+  if(fullScreen) {
+    windowedGeometry = state().geometry;
     qtLayout->setSizeConstraint(QLayout::SetDefaultConstraint);
     qtContainer->setFixedSize(Desktop::size().width() - frameMargin().width(), Desktop::size().height() - frameMargin().height());
     qtWindow->showFullScreen();
+    state().geometry = Monitor::geometry(Monitor::primary());
+  } else {
+    setResizable(state().resizable);
+    qtWindow->showNormal();
+    qtWindow->adjustSize();
+    self().setGeometry(windowedGeometry);
   }
+  unlock();
 }
 
 auto pWindow::setGeometry(Geometry geometry) -> void {
@@ -256,8 +254,10 @@
 
 auto QtWindow::moveEvent(QMoveEvent* event) -> void {
   if(!p.locked() && !p.state().fullScreen && p.qtWindow->isVisible()) {
-    p.state().geometry.setX(p.state().geometry.x() + event->pos().x() - event->oldPos().x());
-    p.state().geometry.setY(p.state().geometry.y() + event->pos().y() - event->oldPos().y());
+    p.state().geometry.setPosition({
+      p.state().geometry.x() + event->pos().x() - event->oldPos().x(),
+      p.state().geometry.y() + event->pos().y() - event->oldPos().y()
+    });
   }
 
   if(!p.locked()) {
@@ -287,8 +287,10 @@
 
 auto QtWindow::resizeEvent(QResizeEvent*) -> void {
   if(!p.locked() && !p.state().fullScreen && p.qtWindow->isVisible()) {
-    p.state().geometry.setWidth(p.qtContainer->geometry().width());
-    p.state().geometry.setHeight(p.qtContainer->geometry().height());
+    p.state().geometry.setSize({
+      p.qtContainer->geometry().width(),
+      p.qtContainer->geometry().height()
+    });
   }
 
   if(auto& layout = p.state().layout) {
diff -Nru higan/hiro/qt/window.hpp higan/hiro/qt/window.hpp
--- higan/hiro/qt/window.hpp	2015-09-16 02:20:06.390574582 +0900
+++ higan/hiro/qt/window.hpp	2015-09-16 13:08:13.412563353 +0900
@@ -34,6 +34,7 @@
   QMenuBar* qtMenuBar = nullptr;
   QStatusBar* qtStatusBar = nullptr;
   QWidget* qtContainer = nullptr;
+  Geometry windowedGeometry{128, 128, 256, 256};
 };
 
 }
diff -Nru higan/hiro/windows/action/menu.cpp higan/hiro/windows/action/menu.cpp
--- higan/hiro/windows/action/menu.cpp	2015-09-16 02:20:06.395574583 +0900
+++ higan/hiro/windows/action/menu.cpp	2015-09-16 13:08:13.440563356 +0900
@@ -19,7 +19,7 @@
   _synchronize();
 }
 
-auto pMenu::setIcon(const image& icon) -> void {
+auto pMenu::setImage(const Image& image) -> void {
   _createBitmap();
   _synchronize();
 }
@@ -31,8 +31,10 @@
 auto pMenu::_createBitmap() -> void {
   if(hbitmap) { DeleteObject(hbitmap); hbitmap = 0; }
 
-  if(auto icon = state().icon) {
-    icon.transform();
+  if(auto& image = state().image) {
+    nall::image icon;
+    icon.allocate(image.width(), image.height());
+    memory::copy(icon.data(), image.data(), icon.size());
     icon.alphaBlend(GetSysColor(COLOR_MENU));  //Windows does not alpha blend menu icons properly (leaves black outline)
     icon.scale(GetSystemMetrics(SM_CXMENUCHECK), GetSystemMetrics(SM_CYMENUCHECK), Interpolation::Linear);
     hbitmap = CreateBitmap(icon);
diff -Nru higan/hiro/windows/action/menu.hpp higan/hiro/windows/action/menu.hpp
--- higan/hiro/windows/action/menu.hpp	2015-09-16 02:20:06.395574583 +0900
+++ higan/hiro/windows/action/menu.hpp	2015-09-16 13:08:13.439563356 +0900
@@ -7,7 +7,7 @@
 
   auto append(sAction action) -> void;
   auto remove(sAction action) -> void;
-  auto setIcon(const image& icon) -> void;
+  auto setImage(const Image& image) -> void;
   auto setText(const string& text) -> void;
 
   auto _createBitmap() -> void;
diff -Nru higan/hiro/windows/action/menu-item.cpp higan/hiro/windows/action/menu-item.cpp
--- higan/hiro/windows/action/menu-item.cpp	2015-09-16 02:20:06.395574583 +0900
+++ higan/hiro/windows/action/menu-item.cpp	2015-09-16 13:08:13.439563356 +0900
@@ -10,7 +10,7 @@
   if(hbitmap) { DeleteObject(hbitmap); hbitmap = nullptr; }
 }
 
-auto pMenuItem::setIcon(const image& icon) -> void {
+auto pMenuItem::setImage(const Image& image) -> void {
   _createBitmap();
   _synchronize();
 }
@@ -26,8 +26,10 @@
 auto pMenuItem::_createBitmap() -> void {
   if(hbitmap) { DeleteObject(hbitmap); hbitmap = nullptr; }
 
-  if(auto icon = state().icon) {
-    icon.transform();
+  if(auto& image = state().image) {
+    nall::image icon;
+    icon.allocate(image.width(), image.height());
+    memory::copy(icon.data(), image.data(), icon.size());
     icon.alphaBlend(GetSysColor(COLOR_MENU));  //Windows does not alpha blend menu icons properly (leaves black outline)
     icon.scale(GetSystemMetrics(SM_CXMENUCHECK), GetSystemMetrics(SM_CYMENUCHECK), Interpolation::Linear);
     hbitmap = CreateBitmap(icon);
diff -Nru higan/hiro/windows/action/menu-item.hpp higan/hiro/windows/action/menu-item.hpp
--- higan/hiro/windows/action/menu-item.hpp	2015-09-16 02:20:06.395574583 +0900
+++ higan/hiro/windows/action/menu-item.hpp	2015-09-16 13:08:13.439563356 +0900
@@ -5,7 +5,7 @@
 struct pMenuItem : pAction {
   Declare(MenuItem, Action)
 
-  auto setIcon(const image& icon) -> void;
+  auto setImage(const Image& image) -> void;
   auto setText(const string& text) -> void;
 
   auto onActivate() -> void;
diff -Nru higan/hiro/windows/action/menu-radio-item.cpp higan/hiro/windows/action/menu-radio-item.cpp
--- higan/hiro/windows/action/menu-radio-item.cpp	2015-09-16 02:20:06.395574583 +0900
+++ higan/hiro/windows/action/menu-radio-item.cpp	2015-09-16 13:08:13.439563356 +0900
@@ -3,13 +3,14 @@
 namespace hiro {
 
 auto pMenuRadioItem::construct() -> void {
+  setGroup(state().group);
 }
 
 auto pMenuRadioItem::destruct() -> void {
 }
 
 auto pMenuRadioItem::setChecked() -> void {
-  if(auto group = self().group()) {
+  if(auto& group = state().group) {
     for(auto& weak : group->state.objects) {
       if(auto object = weak.acquire()) {
         if(auto menuRadioItem = dynamic_cast<mMenuRadioItem*>(object.data())) {
@@ -32,6 +33,20 @@
 }
 
 auto pMenuRadioItem::setGroup(sGroup group) -> void {
+  bool first = true;
+  if(auto& group = state().group) {
+    for(auto& weak : group->state.objects) {
+      if(auto object = weak.acquire()) {
+        if(auto menuRadioItem = dynamic_cast<mMenuRadioItem*>(object.data())) {
+          if(auto self = menuRadioItem->self()) {
+            menuRadioItem->state.checked = first;
+            first = false;
+          }
+        }
+      }
+    }
+  }
+  setChecked();
 }
 
 auto pMenuRadioItem::setText(const string& text) -> void {
diff -Nru higan/hiro/windows/font.cpp higan/hiro/windows/font.cpp
--- higan/hiro/windows/font.cpp	2015-09-16 02:20:06.395574583 +0900
+++ higan/hiro/windows/font.cpp	2015-09-16 13:08:13.450563357 +0900
@@ -2,48 +2,34 @@
 
 namespace hiro {
 
-auto pFont::serif(unsigned size, string style) -> string {
-  if(size == 0) size = 8;
-  if(style == "") style = "Normal";
-  return {"Georgia, ", size, ", ", style};
-}
-
-auto pFont::sans(unsigned size, string style) -> string {
-  if(size == 0) size = 8;
-  if(style == "") style = "Normal";
-  return {"Tahoma, ", size, ", ", style};
-}
-
-auto pFont::monospace(unsigned size, string style) -> string {
-  if(size == 0) size = 8;
-  if(style == "") style = "Normal";
-  return {"Lucida Console, ", size, ", ", style};
-}
-
-auto pFont::size(const string& font, const string& text) -> Size {
-  HFONT hfont = pFont::create(font);
-  Size size = pFont::size(hfont, text);
+auto pFont::size(const Font& font, const string& text) -> Size {
+  auto hfont = pFont::create(font);
+  auto size = pFont::size(hfont, text);
   pFont::free(hfont);
   return size;
 }
 
-auto pFont::create(const string& description) -> HFONT {
-  lstring part = description.split(",", 2L).strip();
+auto pFont::size(HFONT hfont, const string& text) -> Size {
+  HDC hdc = GetDC(0);
+  SelectObject(hdc, hfont);
+  RECT rc = {0, 0, 0, 0};
+  DrawText(hdc, utf16_t(text), -1, &rc, DT_CALCRECT);
+  ReleaseDC(0, hdc);
+  return {rc.right, rc.bottom};
+}
 
-  string family = "Tahoma";
-  unsigned size = 8u;
-  bool bold = false;
-  bool italic = false;
-
-  if(part[0] != "") family = part[0];
-  if(part.size() >= 2) size = decimal(part[1]);
-  if(part.size() >= 3) bold = (bool)part[2].find("Bold");
-  if(part.size() >= 3) italic = (bool)part[2].find("Italic");
+auto pFont::family(const string& family) -> string {
+  if(family == "sans") return "Tahoma";
+  if(family == "serif") return "Georgia";
+  if(family == "monospace") return "Lucida Console";
+  return family ? family : "Tahoma";
+}
 
+auto pFont::create(const Font& font) -> HFONT {
   return CreateFont(
-    -(size * 96.0 / 72.0 + 0.5),
-    0, 0, 0, bold ? FW_BOLD : FW_NORMAL, italic, 0, 0, 0, 0, 0, 0, 0,
-    utf16_t(family)
+    -((font.size() ? font.size() : 8) * 96.0 / 72.0 + 0.5),
+    0, 0, 0, font.bold() ? FW_BOLD : FW_NORMAL, font.italic(), 0, 0, 0, 0, 0, 0, 0,
+    utf16_t(family(font.family()))
   );
 }
 
@@ -51,18 +37,6 @@
   DeleteObject(hfont);
 }
 
-auto pFont::size(HFONT hfont, string text) -> Size {
-  //temporary fix: empty text string returns height of zero; bad for eg Button height
-  if(text.empty()) text = " ";
-
-  HDC hdc = GetDC(0);
-  SelectObject(hdc, hfont);
-  RECT rc = {0, 0, 0, 0};
-  DrawText(hdc, utf16_t(text), -1, &rc, DT_CALCRECT);
-  ReleaseDC(0, hdc);
-  return {rc.right, rc.bottom};
-}
-
 }
 
 #endif
diff -Nru higan/hiro/windows/font.hpp higan/hiro/windows/font.hpp
--- higan/hiro/windows/font.hpp	2015-09-16 02:20:06.395574583 +0900
+++ higan/hiro/windows/font.hpp	2015-09-16 13:08:13.440563356 +0900
@@ -3,14 +3,11 @@
 namespace hiro {
 
 struct pFont {
-  static auto serif(unsigned size, string style) -> string;
-  static auto sans(unsigned size, string style) -> string;
-  static auto monospace(unsigned size, string style) -> string;
-  static auto size(const string& font, const string& text) -> Size;
-
-  static auto create(const string& description) -> HFONT;
+  static auto size(const Font& font, const string& text) -> Size;
+  static auto size(HFONT hfont, const string& text) -> Size;
+  static auto family(const string& family) -> string;
+  static auto create(const Font& font) -> HFONT;
   static auto free(HFONT hfont) -> void;
-  static auto size(HFONT hfont, string text) -> Size;
 };
 
 }
diff -Nru higan/hiro/windows/header.hpp higan/hiro/windows/header.hpp
--- higan/hiro/windows/header.hpp	2015-09-16 02:20:06.395574583 +0900
+++ higan/hiro/windows/header.hpp	2015-09-16 13:08:13.452563357 +0900
@@ -35,6 +35,30 @@
   #define Button_SetImageList(hwnd, pbuttonImagelist) (WINBOOL)SNDMSG((hwnd),BCM_SETIMAGELIST,0,(LPARAM)(pbuttonImagelist))
 #endif
 
+#if !defined(BP_PUSHBUTTON)
+  #define BP_PUSHBUTTON 1
+#endif
+
+#if !defined(PBS_NORMAL)
+  #define PBS_NORMAL 1
+#endif
+
+#if !defined(PBS_HOT)
+  #define PBS_HOT 2
+#endif
+
+#if !defined(PBS_PRESSED)
+  #define PBS_PRESSED 3
+#endif
+
+#if !defined(PBS_DISABLED)
+  #define PBS_DISABLED 4
+#endif
+
+#if !defined(PBS_DEFAULTED)
+  #define PBS_DEFAULTED 5
+#endif
+
 #if !defined(BP_CHECKBOX)
   #define BP_CHECKBOX 3
 #endif
diff -Nru higan/hiro/windows/hotkey.cpp higan/hiro/windows/hotkey.cpp
--- higan/hiro/windows/hotkey.cpp	2015-09-16 02:20:06.395574583 +0900
+++ higan/hiro/windows/hotkey.cpp	1970-01-01 09:00:00.000000000 +0900
@@ -1,13 +0,0 @@
-#if defined(Hiro_Hotkey)
-
-namespace hiro {
-
-auto pHotkey::construct() -> void {
-}
-
-auto pHotkey::destruct() -> void {
-}
-
-}
-
-#endif
diff -Nru higan/hiro/windows/hotkey.hpp higan/hiro/windows/hotkey.hpp
--- higan/hiro/windows/hotkey.hpp	2015-09-16 02:20:06.395574583 +0900
+++ higan/hiro/windows/hotkey.hpp	1970-01-01 09:00:00.000000000 +0900
@@ -1,11 +0,0 @@
-#if defined(Hiro_Hotkey)
-
-namespace hiro {
-
-struct pHotkey : pObject {
-  Declare(Hotkey, Object)
-};
-
-}
-
-#endif
diff -Nru higan/hiro/windows/layout.cpp higan/hiro/windows/layout.cpp
--- higan/hiro/windows/layout.cpp	2015-09-16 02:20:06.395574583 +0900
+++ higan/hiro/windows/layout.cpp	2015-09-16 13:08:13.455563358 +0900
@@ -14,7 +14,7 @@
   }
 }
 
-auto pLayout::setFont(const string& font) -> void {
+auto pLayout::setFont(const Font& font) -> void {
   for(auto& sizable : state().sizables) {
     if(auto self = sizable->self()) self->setFont(sizable->font(true));
   }
diff -Nru higan/hiro/windows/layout.hpp higan/hiro/windows/layout.hpp
--- higan/hiro/windows/layout.hpp	2015-09-16 02:20:06.395574583 +0900
+++ higan/hiro/windows/layout.hpp	2015-09-16 13:08:13.455563358 +0900
@@ -6,7 +6,7 @@
   Declare(Layout, Sizable)
 
   auto setEnabled(bool enabled) -> void override;
-  auto setFont(const string& font) -> void override;
+  auto setFont(const Font& font) -> void override;
   auto setVisible(bool visible) -> void override;
 };
 
diff -Nru higan/hiro/windows/menu-bar.cpp higan/hiro/windows/menu-bar.cpp
--- higan/hiro/windows/menu-bar.cpp	2015-09-16 02:20:06.395574583 +0900
+++ higan/hiro/windows/menu-bar.cpp	2015-09-16 13:08:13.454563357 +0900
@@ -25,7 +25,7 @@
   _update();
 }
 
-auto pMenuBar::setFont(const string& font) -> void {
+auto pMenuBar::setFont(const Font& font) -> void {
   //unsupported
 }
 
diff -Nru higan/hiro/windows/menu-bar.hpp higan/hiro/windows/menu-bar.hpp
--- higan/hiro/windows/menu-bar.hpp	2015-09-16 02:20:06.396574583 +0900
+++ higan/hiro/windows/menu-bar.hpp	2015-09-16 13:08:13.454563357 +0900
@@ -8,7 +8,7 @@
   auto append(sMenu menu) -> void;
   auto remove(sMenu menu) -> void;
   auto setEnabled(bool enabled) -> void override;
-  auto setFont(const string& font) -> void override;
+  auto setFont(const Font& font) -> void override;
   auto setVisible(bool visible) -> void override;
 
   auto _parent() -> maybe<pWindow&>;
diff -Nru higan/hiro/windows/object.cpp higan/hiro/windows/object.cpp
--- higan/hiro/windows/object.cpp	2015-09-16 02:20:06.396574583 +0900
+++ higan/hiro/windows/object.cpp	2015-09-16 13:08:13.439563356 +0900
@@ -27,7 +27,7 @@
 auto pObject::setFocused() -> void {
 }
 
-auto pObject::setFont(const string& font) -> void {
+auto pObject::setFont(const Font& font) -> void {
 }
 
 auto pObject::setGroup(sGroup group) -> void {
diff -Nru higan/hiro/windows/object.hpp higan/hiro/windows/object.hpp
--- higan/hiro/windows/object.hpp	2015-09-16 02:20:06.396574583 +0900
+++ higan/hiro/windows/object.hpp	2015-09-16 13:08:13.441563356 +0900
@@ -14,7 +14,7 @@
   virtual auto reset() -> void;
   virtual auto setEnabled(bool enabled) -> void;
   virtual auto setFocused() -> void;
-  virtual auto setFont(const string& font) -> void;
+  virtual auto setFont(const Font& font) -> void;
   virtual auto setGroup(sGroup group) -> void;
   virtual auto setVisible(bool visible) -> void;
 
diff -Nru higan/hiro/windows/platform.cpp higan/hiro/windows/platform.cpp
--- higan/hiro/windows/platform.cpp	2015-09-16 02:20:06.396574583 +0900
+++ higan/hiro/windows/platform.cpp	2015-09-16 13:08:13.454563357 +0900
@@ -11,7 +11,6 @@
 #include "object.cpp"
 #include "group.cpp"
 
-#include "hotkey.cpp"
 #include "font.cpp"
 #include "timer.cpp"
 #include "window.cpp"
diff -Nru higan/hiro/windows/platform.hpp higan/hiro/windows/platform.hpp
--- higan/hiro/windows/platform.hpp	2015-09-16 02:20:06.396574583 +0900
+++ higan/hiro/windows/platform.hpp	2015-09-16 13:08:13.441563356 +0900
@@ -41,7 +41,6 @@
 #include "object.hpp"
 #include "group.hpp"
 
-#include "hotkey.hpp"
 #include "timer.hpp"
 #include "window.hpp"
 #include "status-bar.hpp"
diff -Nru higan/hiro/windows/popup-menu.cpp higan/hiro/windows/popup-menu.cpp
--- higan/hiro/windows/popup-menu.cpp	2015-09-16 02:20:06.396574583 +0900
+++ higan/hiro/windows/popup-menu.cpp	2015-09-16 13:08:13.454563357 +0900
@@ -17,7 +17,7 @@
 auto pPopupMenu::remove(sAction action) -> void {
 }
 
-auto pPopupMenu::setFont(const string& font) -> void {
+auto pPopupMenu::setFont(const Font& font) -> void {
 }
 
 auto pPopupMenu::setVisible(bool visible) -> void {
diff -Nru higan/hiro/windows/popup-menu.hpp higan/hiro/windows/popup-menu.hpp
--- higan/hiro/windows/popup-menu.hpp	2015-09-16 02:20:06.396574583 +0900
+++ higan/hiro/windows/popup-menu.hpp	2015-09-16 13:08:13.452563357 +0900
@@ -7,7 +7,7 @@
 
   auto append(sAction action) -> void;
   auto remove(sAction action) -> void;
-  auto setFont(const string& font) -> void override;
+  auto setFont(const Font& font) -> void override;
   auto setVisible(bool visible) -> void override;
 
   HWND hwnd = nullptr;
diff -Nru higan/hiro/windows/status-bar.cpp higan/hiro/windows/status-bar.cpp
--- higan/hiro/windows/status-bar.cpp	2015-09-16 02:20:06.396574583 +0900
+++ higan/hiro/windows/status-bar.cpp	2015-09-16 13:08:13.451563357 +0900
@@ -25,7 +25,7 @@
   //unsupported
 }
 
-auto pStatusBar::setFont(const string& font) -> void {
+auto pStatusBar::setFont(const Font& font) -> void {
   if(hfont) DeleteObject(hfont);
   hfont = pFont::create(font);
   if(hwnd) SendMessage(hwnd, WM_SETFONT, (WPARAM)hfont, 0);
diff -Nru higan/hiro/windows/status-bar.hpp higan/hiro/windows/status-bar.hpp
--- higan/hiro/windows/status-bar.hpp	2015-09-16 02:20:06.396574583 +0900
+++ higan/hiro/windows/status-bar.hpp	2015-09-16 13:08:13.451563357 +0900
@@ -6,7 +6,7 @@
   Declare(StatusBar, Object)
 
   auto setEnabled(bool enabled) -> void override;
-  auto setFont(const string& font) -> void override;
+  auto setFont(const Font& font) -> void override;
   auto setText(const string& text) -> void;
   auto setVisible(bool visible) -> void override;
 
diff -Nru higan/hiro/windows/widget/button.cpp higan/hiro/windows/widget/button.cpp
--- higan/hiro/windows/widget/button.cpp	2015-09-16 02:20:06.396574583 +0900
+++ higan/hiro/windows/widget/button.cpp	2015-09-16 13:08:13.441563356 +0900
@@ -2,44 +2,92 @@
 
 namespace hiro {
 
+static auto Button_paintProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam,
+  bool bordered, bool checked, bool enabled, const Font& font, const Image& image, Orientation orientation, const string& text
+) -> LRESULT {
+  if(msg == WM_PAINT) {
+    PAINTSTRUCT ps;
+    BeginPaint(hwnd, &ps);
+    auto state = Button_GetState(hwnd);
+    Button_CustomDraw(hwnd, ps,
+      (state & BST_PUSHED || checked) ? PBS_PRESSED
+    : (state & BST_HOT) ? PBS_HOT
+    : bordered ? (enabled ? PBS_NORMAL : PBS_DISABLED)
+    : 0, font, image, orientation, text
+    );
+    EndPaint(hwnd, &ps);
+  }
+  return DefWindowProc(hwnd, msg, wparam, lparam);
+}
+
+//BUTTON cannot draw borderless buttons on its own
+//BS_OWNERDRAW will send WM_DRAWITEM; but will disable hot-tracking notifications
+//to gain hot-tracking plus borderless buttons; BUTTON is superclassed and WM_PAINT is hijacked
+//note: letting hiro paint bordered buttons will lose the fade animations on Vista+;
+//however, it will allow placing icons immediately next to text (original forces icon left alignment)
+static auto CALLBACK Button_windowProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam) -> LRESULT {
+  if(auto object = (mObject*)GetWindowLongPtr(hwnd, GWLP_USERDATA)) {
+    if(auto button = dynamic_cast<mButton*>(object)) {
+      if(auto self = button->self()) {
+        if(msg == WM_ERASEBKGND) return DefWindowProc(hwnd, msg, wparam, lparam);
+        if(msg == WM_PAINT) return Button_paintProc(hwnd, msg, wparam, lparam,
+          button->state.bordered, false, button->enabled(true), button->font(true),
+          button->state.image, button->state.orientation, button->state.text
+        );
+        return self->windowProc(hwnd, msg, wparam, lparam);
+      }
+    }
+  }
+  return DefWindowProc(hwnd, msg, wparam, lparam);
+}
+
 auto pButton::construct() -> void {
   hwnd = CreateWindow(
-    L"BUTTON", L"",
-    WS_CHILD | WS_TABSTOP,
+    L"BUTTON", L"", WS_CHILD | WS_TABSTOP,
     0, 0, 0, 0, _parentHandle(), nullptr, GetModuleHandle(0), 0
   );
   SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)&reference);
+  windowProc = (WindowProc)GetWindowLongPtr(hwnd, GWLP_WNDPROC);
+  SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR)Button_windowProc);
   pWidget::_setState();
   _setState();
-  setBordered(state().bordered);
 }
 
 auto pButton::destruct() -> void {
-  if(hbitmap) { DeleteObject(hbitmap); hbitmap = 0; }
-  if(himagelist) { ImageList_Destroy(himagelist); himagelist = 0; }
   DestroyWindow(hwnd);
 }
 
 auto pButton::minimumSize() const -> Size {
-  auto size = pFont::size(hfont, state().text);
-
+  Size image = state().image.size();
+  Size text = state().text ? pFont::size(self().font(true), state().text) : Size{};
+  Size size;
   if(state().orientation == Orientation::Horizontal) {
-    size.setWidth(size.width() + state().icon.width());
-    size.setHeight(max(size.height(), state().icon.height()));
+    size.setWidth(image.width() + (image && text ? 5 : 0) + text.width());
+    size.setHeight(max(image.height(), text.height()));
   }
-
   if(state().orientation == Orientation::Vertical) {
-    size.setWidth(max(size.width(), state().icon.width()));
-    size.setHeight(size.height() + state().icon.height());
+    size.setWidth(max(image.width(), text.width()));
+    size.setHeight(image.height() + (image && text ? 5 : 0) + text.height());
   }
-
-  return {size.width() + (state().text ? 20 : 13), size.height() + 10};
+  size.setHeight(max(size.height(), pFont::size(self().font(true), " ").height()));
+  return {size.width() + (state().bordered && text ? 20 : 10), size.height() + 10};
 }
 
 auto pButton::setBordered(bool bordered) -> void {
+  _setState();
 }
 
-auto pButton::setIcon(const image& icon) -> void {
+auto pButton::setEnabled(bool enabled) -> void {
+  pWidget::setEnabled(enabled);
+  _setState();
+}
+
+auto pButton::setFont(const Font& font) -> void {
+  pWidget::setFont(font);
+  _setState();
+}
+
+auto pButton::setImage(const Image& image) -> void {
   _setState();
 }
 
@@ -51,42 +99,84 @@
   _setState();
 }
 
+auto pButton::setVisible(bool visible) -> void {
+  pWidget::setVisible(visible);
+  _setState();
+}
+
 auto pButton::onActivate() -> void {
   self().doActivate();
 }
 
-//performs setIcon, setOrientation, setText
 auto pButton::_setState() -> void {
-  image icon = state().icon;
-  icon.transform();
+  InvalidateRect(hwnd, 0, false);
+}
+
+//this function is designed to be used with Button, CheckButton, and RadioButton
+auto Button_CustomDraw(HWND hwnd, PAINTSTRUCT& ps, unsigned state, const Font& font, const Image& image, Orientation orientation, const string& text) -> void {
+  RECT rc;
+  GetClientRect(hwnd, &rc);
+  Geometry geometry{rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top}, imageGeometry, textGeometry;
+  if(image) imageGeometry.setSize(image.size());
+  if(text) textGeometry.setSize(pFont::size(font, text));
+
+  Position position;
+  Size size;
+
+  switch(orientation) {
+  case Orientation::Horizontal:
+    size = {imageGeometry.width() + (image && text ? 5 : 0) + textGeometry.width(), max(imageGeometry.height(), textGeometry.height())};
+    position = {(geometry.width() - size.width()) / 2, (geometry.height() - size.height()) / 2};
+    imageGeometry.setPosition({position.x(), position.y() + (size.height() - imageGeometry.height()) / 2});
+    textGeometry.setPosition({position.x() + size.width() - textGeometry.width(), position.y() + (size.height() - textGeometry.height()) / 2});
+    break;
+  case Orientation::Vertical:
+    size = {max(imageGeometry.width(), textGeometry.width()), imageGeometry.height() + (image && text ? 5 : 0) + textGeometry.height()};
+    position = {(geometry.width() - size.width()) / 2, (geometry.height() - size.height()) / 2};
+    imageGeometry.setPosition({position.x() + (size.width() - imageGeometry.width()) / 2, position.y()});
+    textGeometry.setPosition({position.x() + (size.width() - textGeometry.width()) / 2, position.y() + size.height() - textGeometry.height()});
+    break;
+  }
 
-  if(hbitmap) { DeleteObject(hbitmap); hbitmap = 0; }
-  if(himagelist) { ImageList_Destroy(himagelist); himagelist = 0; }
+  HDC hdcSource = CreateCompatibleDC(ps.hdc);
+  DrawThemeParentBackground(hwnd, ps.hdc, &rc);
 
-  //Windows XP and earlier do not support translucent images
-  //so we must blend with the button background color (which does not look great with XP gradient-button themes)
-  if(OsVersion() < WindowsVista) icon.alphaBlend(GetSysColor(COLOR_BTNFACE));
-
-  hbitmap = CreateBitmap(icon);
-  himagelist = ImageList_Create(icon.width(), icon.height(), ILC_COLOR32, 1, 0);
-  ImageList_Add(himagelist, hbitmap, NULL);
-  BUTTON_IMAGELIST list;
-  list.himl = himagelist;
-  switch(state().orientation) {
-  case Orientation::Horizontal: SetRect(&list.margin, 5, 0, 0, 0); list.uAlign = BUTTON_IMAGELIST_ALIGN_LEFT; break;
-  case Orientation::Vertical:   SetRect(&list.margin, 0, 5, 0, 0); list.uAlign = BUTTON_IMAGELIST_ALIGN_TOP;  break;
-  }
-  Button_SetImageList(hwnd, &list);
-
-  if(auto text = state().text) {
-    //text will not show up if BS_BITMAP is set
-    SetWindowLongPtr(hwnd, GWL_STYLE, GetWindowLongPtr(hwnd, GWL_STYLE) &~ BS_BITMAP);
-    SetWindowText(hwnd, utf16_t(text));
-  } else {
-    //bitmaps will not show up if text is empty
-    SetWindowLongPtr(hwnd, GWL_STYLE, GetWindowLongPtr(hwnd, GWL_STYLE) |  BS_BITMAP);
-    SetWindowText(hwnd, L"");
+  if(state) {
+    if(auto theme = OpenThemeData(hwnd, L"BUTTON")) {
+      DrawThemeBackground(theme, ps.hdc, BP_PUSHBUTTON, state, &rc, &ps.rcPaint);
+      CloseThemeData(theme);
+    }
   }
+
+  if(GetFocus() == hwnd) {
+    signed offset = state ? 4 : 1;
+    RECT rcFocus{rc.left + offset, rc.top + offset, rc.right - offset, rc.bottom - offset};
+    if(!state || state == PBS_NORMAL) DrawFocusRect(ps.hdc, &rcFocus);
+  }
+
+  if(image) {
+    auto bitmap = CreateBitmap(image);
+    SelectBitmap(hdcSource, bitmap);
+    BLENDFUNCTION blend{AC_SRC_OVER, 0, (BYTE)(IsWindowEnabled(hwnd) ? 255 : 128), AC_SRC_ALPHA};
+    AlphaBlend(
+      ps.hdc, imageGeometry.x(), imageGeometry.y(), image.width(), image.height(),
+      hdcSource, 0, 0, image.width(), image.height(), blend
+    );
+    DeleteObject(bitmap);
+  }
+
+  if(text) {
+    utf16_t wText(text);
+    SetBkMode(ps.hdc, TRANSPARENT);
+    SetTextColor(ps.hdc, GetSysColor(IsWindowEnabled(hwnd) ? COLOR_BTNTEXT : COLOR_GRAYTEXT));
+    auto hFont = pFont::create(font);
+    SelectObject(ps.hdc, hFont);
+    RECT rcText{textGeometry.x(), textGeometry.y(), textGeometry.x() + textGeometry.width(), textGeometry.y() + textGeometry.height()};
+    DrawText(ps.hdc, wText, -1, &rcText, DT_NOPREFIX | DT_END_ELLIPSIS);
+    DeleteObject(hFont);
+  }
+
+  DeleteDC(hdcSource);
 }
 
 }
diff -Nru higan/hiro/windows/widget/button.hpp higan/hiro/windows/widget/button.hpp
--- higan/hiro/windows/widget/button.hpp	2015-09-16 02:20:06.396574583 +0900
+++ higan/hiro/windows/widget/button.hpp	2015-09-16 13:08:13.442563356 +0900
@@ -7,16 +7,18 @@
 
   auto minimumSize() const -> Size override;
   auto setBordered(bool bordered) -> void;
-  auto setIcon(const image& icon) -> void;
+  auto setEnabled(bool enabled) -> void override;
+  auto setFont(const Font& font) -> void override;
+  auto setImage(const Image& image) -> void;
   auto setOrientation(Orientation orientation) -> void;
   auto setText(const string& text) -> void;
+  auto setVisible(bool visible) -> void override;
 
   auto onActivate() -> void;
 
   auto _setState() -> void;
 
-  HBITMAP hbitmap;
-  HIMAGELIST himagelist;
+  WindowProc windowProc = nullptr;
 };
 
 }
diff -Nru higan/hiro/windows/widget/canvas.cpp higan/hiro/windows/widget/canvas.cpp
--- higan/hiro/windows/widget/canvas.cpp	2015-09-16 02:20:06.396574583 +0900
+++ higan/hiro/windows/widget/canvas.cpp	2015-09-16 13:08:13.443563356 +0900
@@ -69,16 +69,11 @@
 }
 
 auto pCanvas::minimumSize() const -> Size {
-  return {max(0, state().size.width()), max(0, state().size.height())};
+  if(auto& image = state().image) return image.size();
+  return {0, 0};
 }
 
 auto pCanvas::setColor(Color color) -> void {
-  mode = Mode::Color;
-  update();
-}
-
-auto pCanvas::setData(Size size) -> void {
-  mode = Mode::Data;
   update();
 }
 
@@ -91,13 +86,11 @@
   update();
 }
 
-auto pCanvas::setGradient(Color topLeft, Color topRight, Color bottomLeft, Color bottomRight) -> void {
-  mode = Mode::Gradient;
+auto pCanvas::setGradient(Gradient gradient) -> void {
   update();
 }
 
-auto pCanvas::setIcon(const image& icon) -> void {
-  mode = Mode::Icon;
+auto pCanvas::setImage(const Image& image) -> void {
   update();
 }
 
@@ -121,8 +114,18 @@
   bmi.bmiHeader.biHeight = -height;  //GDI stores bitmaps upside now; negative height flips bitmap
   bmi.bmiHeader.biSizeImage = pixels.size() * sizeof(uint32_t);
   void* bits = nullptr;
-  HBITMAP bitmap = CreateDIBSection(hdc, &bmi, DIB_RGB_COLORS, &bits, NULL, 0);
-  if(bits) memory::copy(bits, pixels.data(), pixels.size() * sizeof(uint32_t));
+  HBITMAP bitmap = CreateDIBSection(hdc, &bmi, DIB_RGB_COLORS, &bits, nullptr, 0);
+  if(bits) {
+    auto source = (const uint8_t*)pixels.data();
+    auto target = (uint8_t*)bits;
+    for(auto n : range(width * height)) {
+      target[0] = (source[0] * source[3]) / 255;
+      target[1] = (source[1] * source[3]) / 255;
+      target[2] = (source[2] * source[3]) / 255;
+      target[3] = (source[3]);
+      source += 4, target += 4;
+    }
+  }
   SelectObject(hdc, bitmap);
 
   RECT rc;
@@ -139,44 +142,28 @@
 }
 
 auto pCanvas::_rasterize() -> void {
-  if(mode == Mode::Color || mode == Mode::Gradient) {
+  if(auto& image = state().image) {
+    width = image.width();
+    height = image.height();
+  } else {
     width = self().geometry().width();
     height = self().geometry().height();
-  } else {
-    width = state().size.width();
-    height = state().size.height();
   }
   if(width <= 0 || height <= 0) return;
 
   pixels.reallocate(width * height);
 
-  if(mode == Mode::Color) {
-    uint32_t color = state().color.value();
-    for(auto& pixel : pixels) pixel = color;
-  }
-
-  if(mode == Mode::Gradient) {
-    image fill;
+  if(auto& image = state().image) {
+    memory::copy(pixels.data(), image.data(), width * height * sizeof(uint32_t));
+  } else if(auto& gradient = state().gradient) {
+    auto& colors = gradient.state.colors;
+    nall::image fill;
     fill.allocate(width, height);
-    fill.gradient(
-      state().gradient[0].value(), state().gradient[1].value(),
-      state().gradient[2].value(), state().gradient[3].value()
-    );
+    fill.gradient(colors[0].value(), colors[1].value(), colors[2].value(), colors[3].value());
     memory::copy(pixels.data(), fill.data(), fill.size());
-  }
-
-  if(mode == Mode::Icon) {
-    auto icon = state().icon;
-    icon.scale(width, height);
-    icon.transform();
-    memory::copy(pixels.data(), icon.data(), icon.size());
-  }
-
-  if(mode == Mode::Data) {
-    memory::copy(
-      pixels.data(), pixels.size() * sizeof(uint32_t),
-      state().data.data(), state().data.size() * sizeof(uint32_t)
-    );
+  } else {
+    uint32_t color = state().color.value();
+    for(auto& pixel : pixels) pixel = color;
   }
 }
 
diff -Nru higan/hiro/windows/widget/canvas.hpp higan/hiro/windows/widget/canvas.hpp
--- higan/hiro/windows/widget/canvas.hpp	2015-09-16 02:20:06.396574583 +0900
+++ higan/hiro/windows/widget/canvas.hpp	2015-09-16 13:08:13.445563357 +0900
@@ -7,20 +7,16 @@
 
   auto minimumSize() const -> Size override;
   auto setColor(Color color) -> void;
-  auto setData(Size size) -> void;
   auto setDroppable(bool droppable) -> void;
   auto setGeometry(Geometry geometry) -> void override;
-  auto setGradient(Color topLeft, Color topRight, Color bottomLeft, Color bottomRight) -> void;
-  auto setIcon(const image& icon) -> void;
+  auto setGradient(Gradient gradient) -> void;
+  auto setImage(const Image& image) -> void;
   auto update() -> void;
 
-  enum class Mode : unsigned { Color, Data, Gradient, Icon };
-
   auto _paint() -> void;
   auto _rasterize() -> void;
   auto _redraw() -> void;
 
-  Mode mode = Mode::Color;
   vector<uint32_t> pixels;
   signed width = 0;
   signed height = 0;
diff -Nru higan/hiro/windows/widget/check-button.cpp higan/hiro/windows/widget/check-button.cpp
--- higan/hiro/windows/widget/check-button.cpp	2015-09-16 02:20:06.396574583 +0900
+++ higan/hiro/windows/widget/check-button.cpp	2015-09-16 13:08:13.444563356 +0900
@@ -2,47 +2,73 @@
 
 namespace hiro {
 
+static auto CALLBACK CheckButton_windowProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam) -> LRESULT {
+  if(auto object = (mObject*)GetWindowLongPtr(hwnd, GWLP_USERDATA)) {
+    if(auto button = dynamic_cast<mCheckButton*>(object)) {
+      if(auto self = button->self()) {
+        if(msg == WM_ERASEBKGND) return DefWindowProc(hwnd, msg, wparam, lparam);
+        if(msg == WM_PAINT) return Button_paintProc(hwnd, msg, wparam, lparam,
+          button->state.bordered, button->state.checked, button->enabled(true), button->font(true),
+          button->state.image, button->state.orientation, button->state.text
+        );
+        return self->windowProc(hwnd, msg, wparam, lparam);
+      }
+    }
+  }
+  return DefWindowProc(hwnd, msg, wparam, lparam);
+}
+
 auto pCheckButton::construct() -> void {
   hwnd = CreateWindow(L"BUTTON", L"",
     WS_CHILD | WS_TABSTOP | BS_CHECKBOX | BS_PUSHLIKE,
     0, 0, 0, 0, _parentHandle(), nullptr, GetModuleHandle(0), 0);
   SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)&reference);
+  windowProc = (WindowProc)GetWindowLongPtr(hwnd, GWLP_WNDPROC);
+  SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR)CheckButton_windowProc);
   pWidget::_setState();
   _setState();
-  setBordered(state().bordered);
   setChecked(state().checked);
 }
 
 auto pCheckButton::destruct() -> void {
-  if(hbitmap) { DeleteObject(hbitmap); hbitmap = 0; }
-  if(himagelist) { ImageList_Destroy(himagelist); himagelist = 0; }
   DestroyWindow(hwnd);
 }
 
 auto pCheckButton::minimumSize() const -> Size {
-  auto size = pFont::size(hfont, state().text);
-
+  Size image = state().image.size();
+  Size text = state().text ? pFont::size(self().font(true), state().text) : Size{};
+  Size size;
   if(state().orientation == Orientation::Horizontal) {
-    size.setWidth(size.width() + state().icon.width());
-    size.setHeight(max(size.height(), state().icon.height()));
+    size.setWidth(image.width() + (image && text ? 5 : 0) + text.width());
+    size.setHeight(max(image.height(), text.height()));
   }
-
   if(state().orientation == Orientation::Vertical) {
-    size.setWidth(max(size.width(), state().icon.width()));
-    size.setHeight(size.height() + state().icon.height());
+    size.setWidth(max(image.width(), text.width()));
+    size.setHeight(image.height() + (image && text ? 5 : 0) + text.height());
   }
-
-  return {size.width() + (state().text ? 20 : 10), size.height() + 10};
+  size.setHeight(max(size.height(), pFont::size(self().font(true), " ").height()));
+  return {size.width() + (state().bordered && text ? 20 : 10), size.height() + 10};
 }
 
 auto pCheckButton::setBordered(bool bordered) -> void {
+  _setState();
 }
 
 auto pCheckButton::setChecked(bool checked) -> void {
   SendMessage(hwnd, BM_SETCHECK, (WPARAM)checked, 0);
 }
 
-auto pCheckButton::setIcon(const image& icon) -> void {
+auto pCheckButton::setEnabled(bool enabled) -> void {
+  pWidget::setEnabled(enabled);
+  _setState();
+}
+
+auto pCheckButton::setFont(const Font& font) -> void {
+  pWidget::setFont(font);
+  _setState();
+}
+
+auto pCheckButton::setImage(const Image& image) -> void {
   _setState();
 }
 
@@ -54,6 +80,11 @@
   _setState();
 }
 
+auto pCheckButton::setVisible(bool visible) -> void {
+  pWidget::setVisible(visible);
+  _setState();
+}
+
 auto pCheckButton::onToggle() -> void {
   state().checked = !state().checked;
   setChecked(state().checked);
@@ -61,32 +92,7 @@
 }
 
 auto pCheckButton::_setState() -> void {
-  image icon = state().icon;
-  icon.transform();
-
-  if(hbitmap) { DeleteObject(hbitmap); hbitmap = nullptr; }
-  if(himagelist) { ImageList_Destroy(himagelist); himagelist = nullptr; }
-
-  if(OsVersion() < WindowsVista) icon.alphaBlend(GetSysColor(COLOR_BTNFACE));
-
-  hbitmap = CreateBitmap(icon);
-  himagelist = ImageList_Create(icon.width(), icon.height(), ILC_COLOR32, 1, 0);
-  ImageList_Add(himagelist, hbitmap, nullptr);
-  BUTTON_IMAGELIST list;
-  list.himl = himagelist;
-  switch(state().orientation) {
-  case Orientation::Horizontal: SetRect(&list.margin, 5, 0, 0, 0); list.uAlign = BUTTON_IMAGELIST_ALIGN_LEFT; break;
-  case Orientation::Vertical:   SetRect(&list.margin, 0, 5, 0, 0); list.uAlign = BUTTON_IMAGELIST_ALIGN_TOP;  break;
-  }
-  Button_SetImageList(hwnd, &list);
-
-  if(auto text = state().text) {
-    SetWindowLongPtr(hwnd, GWL_STYLE, GetWindowLongPtr(hwnd, GWL_STYLE) &~ BS_BITMAP);
-    SetWindowText(hwnd, utf16_t(text));
-  } else {
-    SetWindowLongPtr(hwnd, GWL_STYLE, GetWindowLongPtr(hwnd, GWL_STYLE) |  BS_BITMAP);
-    SetWindowText(hwnd, L"");
-  }
+  InvalidateRect(hwnd, 0, false);
 }
 
 }
diff -Nru higan/hiro/windows/widget/check-button.hpp higan/hiro/windows/widget/check-button.hpp
--- higan/hiro/windows/widget/check-button.hpp	2015-09-16 02:20:06.396574583 +0900
+++ higan/hiro/windows/widget/check-button.hpp	2015-09-16 13:08:13.442563356 +0900
@@ -7,17 +7,19 @@
 
   auto minimumSize() const -> Size override;
   auto setBordered(bool bordered) -> void;
+  auto setEnabled(bool enabled) -> void override;
+  auto setFont(const Font& font) -> void override;
   auto setChecked(bool checked) -> void;
-  auto setIcon(const image& icon) -> void;
+  auto setImage(const Image& image) -> void;
   auto setOrientation(Orientation orientation) -> void;
   auto setText(const string& text) -> void;
+  auto setVisible(bool visible) -> void override;
 
   auto onToggle() -> void;
 
   auto _setState() -> void;
 
-  HBITMAP hbitmap = 0;
-  HIMAGELIST himagelist = 0;
+  WindowProc windowProc = nullptr;
 };
 
 }
diff -Nru higan/hiro/windows/widget/check-label.cpp higan/hiro/windows/widget/check-label.cpp
--- higan/hiro/windows/widget/check-label.cpp	2015-09-16 02:20:06.396574583 +0900
+++ higan/hiro/windows/widget/check-label.cpp	2015-09-16 13:08:13.443563356 +0900
@@ -19,7 +19,7 @@
 }
 
 auto pCheckLabel::minimumSize() const -> Size {
-  auto size = pFont::size(hfont, state().text);
+  auto size = pFont::size(self().font(true), state().text ? state().text : " ");
   return {size.width() + 20, size.height() + 4};
 }
 
diff -Nru higan/hiro/windows/widget/combo-button-item.cpp higan/hiro/windows/widget/combo-button-item.cpp
--- higan/hiro/windows/widget/combo-button-item.cpp	2015-09-16 02:20:06.396574583 +0900
+++ higan/hiro/windows/widget/combo-button-item.cpp	2015-09-16 13:08:13.443563356 +0900
@@ -8,7 +8,7 @@
 auto pComboButtonItem::destruct() -> void {
 }
 
-auto pComboButtonItem::setIcon(const image& icon) -> void {
+auto pComboButtonItem::setImage(const Image& image) -> void {
   //unsupported
 }
 
diff -Nru higan/hiro/windows/widget/combo-button-item.hpp higan/hiro/windows/widget/combo-button-item.hpp
--- higan/hiro/windows/widget/combo-button-item.hpp	2015-09-16 02:20:06.396574583 +0900
+++ higan/hiro/windows/widget/combo-button-item.hpp	2015-09-16 13:08:13.450563357 +0900
@@ -5,7 +5,7 @@
 struct pComboButtonItem : pObject {
   Declare(ComboButtonItem, Object)
 
-  auto setIcon(const image& icon) -> void;
+  auto setImage(const Image& image) -> void;
   auto setSelected() -> void;
   auto setText(const string& text) -> void;
 
diff -Nru higan/hiro/windows/widget/line-edit.cpp higan/hiro/windows/widget/line-edit.cpp
--- higan/hiro/windows/widget/line-edit.cpp	2015-09-16 02:20:06.397574583 +0900
+++ higan/hiro/windows/widget/line-edit.cpp	2015-09-16 13:08:13.448563357 +0900
@@ -21,7 +21,7 @@
 }
 
 auto pLineEdit::minimumSize() const -> Size {
-  auto size = pFont::size(hfont, state().text);
+  auto size = pFont::size(hfont, state().text ? state().text : " ");
   return {size.width() + 12, size.height() + 10};
 }
 
diff -Nru higan/hiro/windows/widget/list-view-cell.cpp higan/hiro/windows/widget/list-view-cell.cpp
--- higan/hiro/windows/widget/list-view-cell.cpp	2015-09-16 02:20:06.397574583 +0900
+++ higan/hiro/windows/widget/list-view-cell.cpp	2015-09-16 13:08:13.444563356 +0900
@@ -27,7 +27,7 @@
   _repaint();
 }
 
-auto pListViewCell::setIcon(const image& icon) -> void {
+auto pListViewCell::setImage(const Image& icon) -> void {
   _repaint();
 }
 
diff -Nru higan/hiro/windows/widget/list-view-cell.hpp higan/hiro/windows/widget/list-view-cell.hpp
--- higan/hiro/windows/widget/list-view-cell.hpp	2015-09-16 02:20:06.397574583 +0900
+++ higan/hiro/windows/widget/list-view-cell.hpp	2015-09-16 13:08:13.443563356 +0900
@@ -10,7 +10,7 @@
   auto setCheckable(bool checkable) -> void;
   auto setChecked(bool checked) -> void;
   auto setForegroundColor(Color color) -> void;
-  auto setIcon(const image& icon) -> void;
+  auto setImage(const Image& image) -> void;
   auto setText(const string& text) -> void;
 
   auto _parent() -> maybe<pListViewItem&>;
diff -Nru higan/hiro/windows/widget/list-view-column.cpp higan/hiro/windows/widget/list-view-column.cpp
--- higan/hiro/windows/widget/list-view-column.cpp	2015-09-16 02:20:06.397574583 +0900
+++ higan/hiro/windows/widget/list-view-column.cpp	2015-09-16 13:08:13.449563357 +0900
@@ -49,7 +49,7 @@
   _setState();
 }
 
-auto pListViewColumn::setIcon(const image& icon) -> void {
+auto pListViewColumn::setImage(const Image& image) -> void {
   _setState();
 }
 
@@ -97,7 +97,7 @@
     lvColumn.cx = _width;
     if(state().horizontalAlignment < 0.333) lvColumn.fmt = LVCFMT_LEFT;
     if(state().horizontalAlignment > 0.666) lvColumn.fmt = LVCFMT_RIGHT;
-    if(state().icon) lvColumn.mask |= LVCF_IMAGE;
+    if(state().image) lvColumn.mask |= LVCF_IMAGE;
     if(!state().resizable) lvColumn.fmt |= LVCFMT_FIXED_WIDTH;
     ListView_SetColumn(grandparent->hwnd, self().offset(), &lvColumn);
     grandparent->unlock();
diff -Nru higan/hiro/windows/widget/list-view-column.hpp higan/hiro/windows/widget/list-view-column.hpp
--- higan/hiro/windows/widget/list-view-column.hpp	2015-09-16 02:20:06.397574583 +0900
+++ higan/hiro/windows/widget/list-view-column.hpp	2015-09-16 13:08:13.447563357 +0900
@@ -12,7 +12,7 @@
   auto setExpandable(bool expandable) -> void;
   auto setForegroundColor(Color color) -> void;
   auto setHorizontalAlignment(double alignment) -> void;
-  auto setIcon(const image& icon) -> void;
+  auto setImage(const Image& image) -> void;
   auto setResizable(bool resizable) -> void;
   auto setSortable(bool sortable) -> void;
   auto setText(const string& text) -> void;
diff -Nru higan/hiro/windows/widget/list-view.cpp higan/hiro/windows/widget/list-view.cpp
--- higan/hiro/windows/widget/list-view.cpp	2015-09-16 02:20:06.397574583 +0900
+++ higan/hiro/windows/widget/list-view.cpp	2015-09-16 13:08:13.446563357 +0900
@@ -52,6 +52,10 @@
 }
 
 auto pListView::remove(sListViewHeader header) -> void {
+  LVCOLUMN lvColumn{LVCF_WIDTH};
+  while(ListView_GetColumn(hwnd, 0, &lvColumn)) {
+    ListView_DeleteColumn(hwnd, 0);
+  }
 }
 
 auto pListView::remove(sListViewItem item) -> void {
@@ -215,13 +219,11 @@
           rc.left += 2;
         }
 
-        if(auto icon = cell->state.icon) {
-          icon.scale(iconSize, iconSize);
-          icon.transform();
-          auto bitmap = CreateBitmap(icon);
+        if(auto& image = cell->state.image) {
+          auto bitmap = CreateBitmap(image);
           SelectBitmap(hdcSource, bitmap);
           BLENDFUNCTION blend{AC_SRC_OVER, 0, (BYTE)(selected ? 128 : 255), AC_SRC_ALPHA};
-          AlphaBlend(hdc, rc.left, rc.top, iconSize, iconSize, hdcSource, 0, 0, iconSize, iconSize, blend);
+          AlphaBlend(hdc, rc.left, rc.top, iconSize, iconSize, hdcSource, 0, 0, image.width(), image.height(), blend);
           DeleteObject(bitmap);
           rc.left += iconSize + 2;
         }
@@ -321,11 +323,11 @@
       if(cell->state.checkable) {
         width += 16 + 2;
       }
-      if(auto& icon = cell->state.icon) {
+      if(auto& image = cell->state.image) {
         width += 16 + 2;
       }
       if(auto& text = cell->state.text) {
-        width += Font::size(_font(_row, _column), text).width();
+        width += pFont::size(_font(_row, _column), text).width();
       }
     }
   }
@@ -336,18 +338,18 @@
   unsigned width = 12;
   if(auto header = state().header) {
     if(auto column = header->column(_column)) {
-      if(auto& icon = column->state.icon) {
+      if(auto& image = column->state.image) {
         width += 16 + 12;  //yes; icon spacing in column headers is excessive
       }
       if(auto& text = column->state.text) {
-        width += Font::size(self().font(true), text).width();
+        width += pFont::size(self().font(true), text).width();
       }
     }
   }
   return width;
 }
 
-auto pListView::_font(unsigned _row, unsigned _column) -> string {
+auto pListView::_font(unsigned _row, unsigned _column) -> Font {
   if(auto item = self().item(_row)) {
     if(auto cell = item->cell(_column)) {
       if(auto font = cell->font()) return font;
@@ -358,7 +360,7 @@
 //    if(auto font = column->font()) return font;
 //  }
   if(auto font = self().font(true)) return font;
-  return Font::sans(8);
+  return {};
 }
 
 auto pListView::_foregroundColor(unsigned _row, unsigned _column) -> Color {
@@ -383,10 +385,11 @@
 
   if(auto& header = state().header) {
     for(auto column : range(header->columnCount())) {
-      auto icon = header->state.columns[column]->state.icon;
-      if(icon) {
+      nall::image icon;
+      if(auto& image = header->state.columns[column]->state.image) {
+        icon.allocate(image.width(), image.height());
+        memory::copy(icon.data(), image.data(), icon.size());
         icon.scale(16, 16);
-        icon.transform();
       } else {
         icon.allocate(16, 16);
         icon.fill(0x00ffffff);
@@ -398,7 +401,7 @@
   }
 
   //empty icon used for ListViewItems (drawn manually via onCustomDraw)
-  image icon;
+  nall::image icon;
   icon.allocate(16, 16);
   icon.fill(0x00ffffff);
   auto bitmap = CreateBitmap(icon);
diff -Nru higan/hiro/windows/widget/list-view.hpp higan/hiro/windows/widget/list-view.hpp
--- higan/hiro/windows/widget/list-view.hpp	2015-09-16 02:20:06.397574583 +0900
+++ higan/hiro/windows/widget/list-view.hpp	2015-09-16 13:08:13.450563357 +0900
@@ -27,7 +27,7 @@
   auto _backgroundColor(unsigned row, unsigned column) -> Color;
   auto _cellWidth(unsigned row, unsigned column) -> unsigned;
   auto _columnWidth(unsigned column) -> unsigned;
-  auto _font(unsigned row, unsigned column) -> string;
+  auto _font(unsigned row, unsigned column) -> Font;
   auto _foregroundColor(unsigned row, unsigned column) -> Color;
   auto _setIcons() -> void;
   auto _setSortable() -> void;
diff -Nru higan/hiro/windows/widget/radio-button.cpp higan/hiro/windows/widget/radio-button.cpp
--- higan/hiro/windows/widget/radio-button.cpp	2015-09-16 02:20:06.397574583 +0900
+++ higan/hiro/windows/widget/radio-button.cpp	2015-09-16 13:08:13.447563357 +0900
@@ -2,44 +2,60 @@
 
 namespace hiro {
 
+static auto CALLBACK RadioButton_windowProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam) -> LRESULT {
+  if(auto object = (mObject*)GetWindowLongPtr(hwnd, GWLP_USERDATA)) {
+    if(auto button = dynamic_cast<mRadioButton*>(object)) {
+      if(auto self = button->self()) {
+        if(msg == WM_ERASEBKGND) return DefWindowProc(hwnd, msg, wparam, lparam);
+        if(msg == WM_PAINT) return Button_paintProc(hwnd, msg, wparam, lparam,
+          button->state.bordered, button->state.checked, button->enabled(true), button->font(true),
+          button->state.image, button->state.orientation, button->state.text
+        );
+        return self->windowProc(hwnd, msg, wparam, lparam);
+      }
+    }
+  }
+  return DefWindowProc(hwnd, msg, wparam, lparam);
+}
+
 auto pRadioButton::construct() -> void {
   hwnd = CreateWindow(L"BUTTON", L"",
     WS_CHILD | WS_TABSTOP | BS_CHECKBOX | BS_PUSHLIKE,
     0, 0, 0, 0, _parentHandle(), nullptr, GetModuleHandle(0), 0);
   SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)&reference);
+  windowProc = (WindowProc)GetWindowLongPtr(hwnd, GWLP_WNDPROC);
+  SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR)RadioButton_windowProc);
   pWidget::_setState();
+  setGroup(state().group);
   _setState();
-  setBordered(state().bordered);
-  if(state().checked) setChecked();
 }
 
 auto pRadioButton::destruct() -> void {
-  if(hbitmap) { DeleteObject(hbitmap); hbitmap = 0; }
-  if(himagelist) { ImageList_Destroy(himagelist); himagelist = 0; }
   DestroyWindow(hwnd);
 }
 
 auto pRadioButton::minimumSize() const -> Size {
-  auto size = pFont::size(hfont, state().text);
-
+  Size image = state().image.size();
+  Size text = state().text ? pFont::size(self().font(true), state().text) : Size{};
+  Size size;
   if(state().orientation == Orientation::Horizontal) {
-    size.setWidth(size.width() + state().icon.width());
-    size.setHeight(max(size.height(), state().icon.height()));
+    size.setWidth(image.width() + (image && text ? 5 : 0) + text.width());
+    size.setHeight(max(image.height(), text.height()));
   }
-
   if(state().orientation == Orientation::Vertical) {
-    size.setWidth(max(size.width(), state().icon.width()));
-    size.setHeight(size.height() + state().icon.height());
+    size.setWidth(max(image.width(), text.width()));
+    size.setHeight(image.height() + (image && text ? 5 : 0) + text.height());
   }
-
-  return {size.width() + (state().text ? 20 : 10), size.height() + 10};
+  size.setHeight(max(size.height(), pFont::size(self().font(true), " ").height()));
+  return {size.width() + (state().bordered && text ? 20 : 10), size.height() + 10};
 }
 
 auto pRadioButton::setBordered(bool bordered) -> void {
+  _setState();
 }
 
 auto pRadioButton::setChecked() -> void {
-  if(auto group = self().group()) {
+  if(auto& group = state().group) {
     for(auto& weak : group->state.objects) {
       if(auto object = weak.acquire()) {
         if(auto radioButton = dynamic_cast<mRadioButton*>(object.data())) {
@@ -52,10 +68,33 @@
   }
 }
 
+auto pRadioButton::setEnabled(bool enabled) -> void {
+  pWidget::setEnabled(enabled);
+  _setState();
+}
+
+auto pRadioButton::setFont(const Font& font) -> void {
+  pWidget::setFont(font);
+  _setState();
+}
+
 auto pRadioButton::setGroup(sGroup group) -> void {
+  bool first = true;
+  if(auto& group = state().group) {
+    for(auto& weak : group->state.objects) {
+      if(auto object = weak.acquire()) {
+        if(auto radioButton = dynamic_cast<mRadioButton*>(object.data())) {
+          if(auto self = radioButton->self()) {
+            SendMessage(self->hwnd, BM_SETCHECK, (WPARAM)(radioButton->state.checked = first), 0);
+            first = false;
+          }
+        }
+      }
+    }
+  }
 }
 
-auto pRadioButton::setIcon(const image& icon) -> void {
+auto pRadioButton::setImage(const Image& image) -> void {
   _setState();
 }
 
@@ -63,43 +102,23 @@
   _setState();
 }
 
-void pRadioButton::setText(const string& text) {
+auto pRadioButton::setText(const string& text) -> void {
+  _setState();
+}
+
+auto pRadioButton::setVisible(bool visible) -> void {
+  pWidget::setVisible(visible);
   _setState();
 }
 
-void pRadioButton::onActivate() {
+auto pRadioButton::onActivate() -> void {
   if(state().checked) return;
   self().setChecked();
   self().doActivate();
 }
 
 auto pRadioButton::_setState() -> void {
-  image icon = state().icon;
-  icon.transform();
-
-  if(hbitmap) { DeleteObject(hbitmap); hbitmap = nullptr; }
-  if(himagelist) { ImageList_Destroy(himagelist); himagelist = nullptr; }
-
-  if(OsVersion() < WindowsVista) icon.alphaBlend(GetSysColor(COLOR_BTNFACE));
-
-  hbitmap = CreateBitmap(icon);
-  himagelist = ImageList_Create(icon.width(), icon.height(), ILC_COLOR32, 1, 0);
-  ImageList_Add(himagelist, hbitmap, nullptr);
-  BUTTON_IMAGELIST list;
-  list.himl = himagelist;
-  switch(state().orientation) {
-  case Orientation::Horizontal: SetRect(&list.margin, 5, 0, 0, 0); list.uAlign = BUTTON_IMAGELIST_ALIGN_LEFT; break;
-  case Orientation::Vertical:   SetRect(&list.margin, 0, 5, 0, 0); list.uAlign = BUTTON_IMAGELIST_ALIGN_TOP;  break;
-  }
-  Button_SetImageList(hwnd, &list);
-
-  if(auto text = state().text) {
-    SetWindowLongPtr(hwnd, GWL_STYLE, GetWindowLongPtr(hwnd, GWL_STYLE) &~ BS_BITMAP);
-    SetWindowText(hwnd, utf16_t(text));
-  } else {
-    SetWindowLongPtr(hwnd, GWL_STYLE, GetWindowLongPtr(hwnd, GWL_STYLE) |  BS_BITMAP);
-    SetWindowText(hwnd, L"");
-  }
+  InvalidateRect(hwnd, 0, false);
 }
 
 }
diff -Nru higan/hiro/windows/widget/radio-button.hpp higan/hiro/windows/widget/radio-button.hpp
--- higan/hiro/windows/widget/radio-button.hpp	2015-09-16 02:20:06.397574583 +0900
+++ higan/hiro/windows/widget/radio-button.hpp	2015-09-16 13:08:13.449563357 +0900
@@ -8,17 +8,19 @@
   auto minimumSize() const -> Size override;
   auto setBordered(bool bordered) -> void;
   auto setChecked() -> void;
+  auto setEnabled(bool enabled) -> void override;
+  auto setFont(const Font& font) -> void override;
   auto setGroup(sGroup group) -> void override;
-  auto setIcon(const image& icon) -> void;
+  auto setImage(const Image& image) -> void;
   auto setOrientation(Orientation orientation) -> void;
   auto setText(const string& text) -> void;
+  auto setVisible(bool visible) -> void override;
 
   auto onActivate() -> void;
 
   auto _setState() -> void;
 
-  HBITMAP hbitmap = 0;
-  HIMAGELIST himagelist = 0;
+  WindowProc windowProc = nullptr;
 };
 
 }
diff -Nru higan/hiro/windows/widget/radio-label.cpp higan/hiro/windows/widget/radio-label.cpp
--- higan/hiro/windows/widget/radio-label.cpp	2015-09-16 02:20:06.397574583 +0900
+++ higan/hiro/windows/widget/radio-label.cpp	2015-09-16 13:08:13.449563357 +0900
@@ -4,13 +4,12 @@
 
 auto pRadioLabel::construct() -> void {
   hwnd = CreateWindow(
-    L"BUTTON", L"",
-    WS_CHILD | WS_TABSTOP | BS_RADIOBUTTON,
+    L"BUTTON", L"", WS_CHILD | WS_TABSTOP | BS_RADIOBUTTON,
     0, 0, 0, 0, _parentHandle(), nullptr, GetModuleHandle(0), 0
   );
   SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)&reference);
   pWidget::_setState();
-  if(state().checked) setChecked();
+  setGroup(state().group);
   setText(state().text);
 }
 
@@ -18,13 +17,13 @@
   DestroyWindow(hwnd);
 }
 
-auto pRadioLabel::minimumSize() -> Size {
-  auto size = pFont::size(hfont, state().text);
+auto pRadioLabel::minimumSize() const -> Size {
+  auto size = pFont::size(self().font(true), state().text ? state().text : " ");
   return {size.width() + 20, size.height() + 4};
 }
 
 auto pRadioLabel::setChecked() -> void {
-  if(auto group = self().group()) {
+  if(auto& group = state().group) {
     for(auto& weak : group->state.objects) {
       if(auto object = weak.acquire()) {
         if(auto radioLabel = dynamic_cast<mRadioLabel*>(object.data())) {
@@ -38,6 +37,19 @@
 }
 
 auto pRadioLabel::setGroup(sGroup group) -> void {
+  bool first = true;
+  if(auto& group = state().group) {
+    for(auto& weak : group->state.objects) {
+      if(auto object = weak.acquire()) {
+        if(auto radioLabel = dynamic_cast<mRadioLabel*>(object.data())) {
+          if(auto self = radioLabel->self()) {
+            SendMessage(self->hwnd, BM_SETCHECK, (WPARAM)(radioLabel->state.checked = first), 0);
+            first = false;
+          }
+        }
+      }
+    }
+  }
 }
 
 auto pRadioLabel::setText(const string& text) -> void {
diff -Nru higan/hiro/windows/widget/radio-label.hpp higan/hiro/windows/widget/radio-label.hpp
--- higan/hiro/windows/widget/radio-label.hpp	2015-09-16 02:20:06.397574583 +0900
+++ higan/hiro/windows/widget/radio-label.hpp	2015-09-16 13:08:13.441563356 +0900
@@ -5,7 +5,7 @@
 struct pRadioLabel : pWidget {
   Declare(RadioLabel, Widget)
 
-  auto minimumSize() -> Size;
+  auto minimumSize() const -> Size override;
   auto setChecked() -> void;
   auto setGroup(sGroup group) -> void override;
   auto setText(const string& text) -> void;
diff -Nru higan/hiro/windows/widget/tab-frame.cpp higan/hiro/windows/widget/tab-frame.cpp
--- higan/hiro/windows/widget/tab-frame.cpp	2015-09-16 02:20:06.397574583 +0900
+++ higan/hiro/windows/widget/tab-frame.cpp	2015-09-16 13:08:13.448563357 +0900
@@ -15,9 +15,10 @@
 }
 
 auto pTabFrame::construct() -> void {
-  hwnd = CreateWindow(WC_TABCONTROL, L"",
-    WS_CHILD | WS_TABSTOP,
-    0, 0, 0, 0, _parentHandle(), nullptr, GetModuleHandle(0), 0);
+  hwnd = CreateWindow(
+    WC_TABCONTROL, L"", WS_CHILD | WS_TABSTOP,
+    0, 0, 0, 0, _parentHandle(), nullptr, GetModuleHandle(0), 0
+  );
   SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)&reference);
   windowProc = (WindowProc)GetWindowLongPtr(hwnd, GWLP_WNDPROC);
   SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR)TabFrame_windowProc);
@@ -38,7 +39,7 @@
   TabCtrl_InsertItem(hwnd, item->offset(), &tcItem);
   if(auto self = item->self()) {
     self->setClosable(item->state.closable);
-    self->setIcon(item->state.icon);
+    self->setImage(item->state.image);
     self->setMovable(item->state.movable);
     self->setText(item->state.text);
     if(item->selected()) self->setSelected();
@@ -52,10 +53,6 @@
   _buildImageList();
 }
 
-auto pTabFrame::setEdge(Edge edge) -> void {
-  //unsupported
-}
-
 auto pTabFrame::setEnabled(bool enabled) -> void {
   pWidget::setEnabled(enabled);
   for(auto& item : state().items) {
@@ -78,6 +75,10 @@
   }
 }
 
+auto pTabFrame::setNavigation(Navigation navigation) -> void {
+  //unsupported
+}
+
 auto pTabFrame::setVisible(bool visible) -> void {
   pWidget::setVisible(visible);
   for(auto& item : state().items) {
@@ -93,13 +94,13 @@
   if(imageList) { ImageList_Destroy(imageList); imageList = nullptr; }
   imageList = ImageList_Create(size, size, ILC_COLOR32, 1, 0);
   for(auto& item : state().items) {
-    ImageList_Append(imageList, item->state.icon, size);
+    ImageList_Append(imageList, item->state.image, size);
   }
   TabCtrl_SetImageList(hwnd, imageList);
   for(auto offset : range(state().items)) {
     TCITEM tcItem;
     tcItem.mask = TCIF_IMAGE;
-    tcItem.iImage = state().items[offset]->state.icon ? offset : -1;
+    tcItem.iImage = state().items[offset]->state.image ? offset : -1;
     TabCtrl_SetItem(hwnd, offset, &tcItem);
   }
 }
diff -Nru higan/hiro/windows/widget/tab-frame.hpp higan/hiro/windows/widget/tab-frame.hpp
--- higan/hiro/windows/widget/tab-frame.hpp	2015-09-16 02:20:06.397574583 +0900
+++ higan/hiro/windows/widget/tab-frame.hpp	2015-09-16 13:08:13.445563357 +0900
@@ -7,9 +7,9 @@
 
   auto append(sTabFrameItem item) -> void;
   auto remove(sTabFrameItem item) -> void;
-  auto setEdge(Edge edge) -> void;
   auto setEnabled(bool enabled) -> void override;
   auto setGeometry(Geometry geometry) -> void override;
+  auto setNavigation(Navigation navigation) -> void;
   auto setVisible(bool visible) -> void override;
 
   auto onChange() -> void;
diff -Nru higan/hiro/windows/widget/tab-frame-item.cpp higan/hiro/windows/widget/tab-frame-item.cpp
--- higan/hiro/windows/widget/tab-frame-item.cpp	2015-09-16 02:20:06.397574583 +0900
+++ higan/hiro/windows/widget/tab-frame-item.cpp	2015-09-16 13:08:13.442563356 +0900
@@ -24,7 +24,7 @@
   //unsupported
 }
 
-auto pTabFrameItem::setIcon(const image& icon) -> void {
+auto pTabFrameItem::setImage(const Image& image) -> void {
   if(auto parent = _parent()) {
     parent->_buildImageList();
   }
diff -Nru higan/hiro/windows/widget/tab-frame-item.hpp higan/hiro/windows/widget/tab-frame-item.hpp
--- higan/hiro/windows/widget/tab-frame-item.hpp	2015-09-16 02:20:06.397574583 +0900
+++ higan/hiro/windows/widget/tab-frame-item.hpp	2015-09-16 13:08:13.445563357 +0900
@@ -8,7 +8,7 @@
   auto append(sLayout layout) -> void;
   auto remove(sLayout layout) -> void;
   auto setClosable(bool closable) -> void;
-  auto setIcon(const image& icon) -> void;
+  auto setImage(const Image& image) -> void;
   auto setMovable(bool movable) -> void;
   auto setSelected() -> void;
   auto setText(const string& text) -> void;
diff -Nru higan/hiro/windows/widget/text-edit.cpp higan/hiro/windows/widget/text-edit.cpp
--- higan/hiro/windows/widget/text-edit.cpp	2015-09-16 02:20:06.397574583 +0900
+++ higan/hiro/windows/widget/text-edit.cpp	2015-09-16 13:08:13.448563357 +0900
@@ -11,9 +11,9 @@
   SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)&reference);
   pWidget::_setState();
   setBackgroundColor(state().backgroundColor);
-  setCursorPosition(state().cursorPosition);
   setEditable(state().editable);
   setText(state().text);
+  setCursor(state().cursor);
 }
 
 auto pTextEdit::destruct() -> void {
@@ -27,9 +27,11 @@
   backgroundBrush = CreateSolidBrush(color ? CreateRGB(color) : GetSysColor(COLOR_WINDOW));
 }
 
-auto pTextEdit::setCursorPosition(unsigned position) -> void {
-  if(position == ~0) position >>= 1;  //Edit_SetSel takes signed type
-  Edit_SetSel(hwnd, position, position);
+auto pTextEdit::setCursor(Cursor cursor) -> void {
+  signed end = GetWindowTextLength(hwnd);
+  signed offset = max(0, min(end, cursor.offset()));
+  signed length = max(0, min(end, cursor.offset() + cursor.length()));
+  Edit_SetSel(hwnd, offset, length);
   Edit_ScrollCaret(hwnd);
 }
 
diff -Nru higan/hiro/windows/widget/text-edit.hpp higan/hiro/windows/widget/text-edit.hpp
--- higan/hiro/windows/widget/text-edit.hpp	2015-09-16 02:20:06.397574583 +0900
+++ higan/hiro/windows/widget/text-edit.hpp	2015-09-16 13:08:13.445563357 +0900
@@ -6,7 +6,7 @@
   Declare(TextEdit, Widget)
 
   auto setBackgroundColor(Color color) -> void;
-  auto setCursorPosition(unsigned position) -> void;
+  auto setCursor(Cursor cursor) -> void;
   auto setEditable(bool editable) -> void;
   auto setForegroundColor(Color color) -> void;
   auto setText(string text) -> void;
diff -Nru higan/hiro/windows/widget/widget.cpp higan/hiro/windows/widget/widget.cpp
--- higan/hiro/windows/widget/widget.cpp	2015-09-16 02:20:06.397574583 +0900
+++ higan/hiro/windows/widget/widget.cpp	2015-09-16 13:08:13.442563356 +0900
@@ -35,11 +35,9 @@
   SetFocus(hwnd);
 }
 
-auto pWidget::setFont(const string&) -> void {
-  auto font = self().font(true);
-  if(!font) font = Font::sans(8);
+auto pWidget::setFont(const Font&) -> void {
   if(hfont) DeleteObject(hfont);
-  hfont = pFont::create(font);
+  hfont = pFont::create(self().font(true));
   SendMessage(hwnd, WM_SETFONT, (WPARAM)hfont, 0);
 }
 
diff -Nru higan/hiro/windows/widget/widget.hpp higan/hiro/windows/widget/widget.hpp
--- higan/hiro/windows/widget/widget.hpp	2015-09-16 02:20:06.397574583 +0900
+++ higan/hiro/windows/widget/widget.hpp	2015-09-16 13:08:13.445563357 +0900
@@ -9,7 +9,7 @@
   virtual auto minimumSize() -> Size;
   auto setEnabled(bool enabled) -> void override;
   auto setFocused() -> void;
-  auto setFont(const string& font) -> void override;
+  auto setFont(const Font& font) -> void override;
   virtual auto setGeometry(Geometry geometry) -> void;
   auto setVisible(bool visible) -> void override;
 
diff -Nru higan/hiro/windows/window.cpp higan/hiro/windows/window.cpp
--- higan/hiro/windows/window.cpp	2015-09-16 02:20:06.397574583 +0900
+++ higan/hiro/windows/window.cpp	2015-09-16 13:08:13.453563357 +0900
@@ -82,7 +82,7 @@
   SetFocus(hwnd);
 }
 
-auto pWindow::setFont(const string& font) -> void {
+auto pWindow::setFont(const Font& font) -> void {
   if(auto layout = state().layout) {
     if(auto self = layout->self()) self->setFont(layout->font(true));
   }
@@ -91,10 +91,8 @@
 auto pWindow::setFullScreen(bool fullScreen) -> void {
   auto style = GetWindowLongPtr(hwnd, GWL_STYLE) & WS_VISIBLE;
   lock();
-  if(fullScreen == false) {
-    SetWindowLongPtr(hwnd, GWL_STYLE, style | (state().resizable ? ResizableStyle : FixedStyle));
-    setGeometry(state().geometry);
-  } else {
+  if(fullScreen) {
+    windowedGeometry = self().geometry();
     HMONITOR monitor = MonitorFromWindow(hwnd, MONITOR_DEFAULTTONEAREST);
     MONITORINFOEX info;
     memset(&info, 0, sizeof(MONITORINFOEX));
@@ -104,10 +102,13 @@
     Geometry geometry = {rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top};
     SetWindowLongPtr(hwnd, GWL_STYLE, style | WS_POPUP);
     Geometry margin = frameMargin();
-    setGeometry({
+    self().setGeometry({
       geometry.x() + margin.x(), geometry.y() + margin.y(),
       geometry.width() - margin.width(), geometry.height() - margin.height()
     });
+  } else {
+    SetWindowLongPtr(hwnd, GWL_STYLE, style | (state().resizable ? ResizableStyle : FixedStyle));
+    self().setGeometry(windowedGeometry);
   }
   unlock();
 }
@@ -116,7 +117,7 @@
   lock();
   Geometry margin = frameMargin();
   SetWindowPos(
-    hwnd, NULL,
+    hwnd, nullptr,
     geometry.x() - margin.x(), geometry.y() - margin.y(),
     geometry.width() + margin.width(), geometry.height() + margin.height(),
     SWP_NOZORDER | SWP_FRAMECHANGED
diff -Nru higan/hiro/windows/window.hpp higan/hiro/windows/window.hpp
--- higan/hiro/windows/window.hpp	2015-09-16 02:20:06.397574583 +0900
+++ higan/hiro/windows/window.hpp	2015-09-16 13:08:13.453563357 +0900
@@ -17,7 +17,7 @@
   auto setDroppable(bool droppable) -> void;
   auto setEnabled(bool enabled) -> void;
   auto setFocused() -> void;
-  auto setFont(const string& font) -> void override;
+  auto setFont(const Font& font) -> void override;
   auto setFullScreen(bool fullScreen) -> void;
   auto setGeometry(Geometry geometry) -> void;
   auto setModal(bool modal) -> void;
@@ -42,6 +42,7 @@
   HFONT hstatusfont = nullptr;
   HBRUSH hbrush = nullptr;
   COLORREF hbrushColor = 0;
+  Geometry windowedGeometry{128, 128, 256, 256};
 };
 
 }
diff -Nru higan/nall/image/base.hpp higan/nall/image/base.hpp
--- higan/nall/image/base.hpp	2015-09-16 02:20:06.401574583 +0900
+++ higan/nall/image/base.hpp	2015-09-16 13:08:13.670563380 +0900
@@ -80,6 +80,7 @@
   //utility.hpp
   inline auto crop(unsigned x, unsigned y, unsigned width, unsigned height) -> bool;
   inline auto alphaBlend(uint64_t alphaColor) -> void;
+  inline auto alphaMultiply() -> void;
   inline auto transform(const image& source = {}) -> void;
   inline auto transform(bool endian, unsigned depth, uint64_t alphaMask, uint64_t redMask, uint64_t greenMask, uint64_t blueMask) -> void;
 
diff -Nru higan/nall/image/utility.hpp higan/nall/image/utility.hpp
--- higan/nall/image/utility.hpp	2015-09-16 02:20:06.402574583 +0900
+++ higan/nall/image/utility.hpp	2015-09-16 13:08:13.668563379 +0900
@@ -56,6 +56,30 @@
   }
 }
 
+auto image::alphaMultiply() -> void {
+  unsigned divisor = (1 << _alpha.depth()) - 1;
+
+  #pragma omp parallel for
+  for(unsigned y = 0; y < _height; y++) {
+    uint8_t* dp = _data + pitch() * y;
+    for(unsigned x = 0; x < _width; x++) {
+      uint64_t color = read(dp);
+
+      uint64_t colorA = (color & _alpha.mask()) >> _alpha.shift();
+      uint64_t colorR = (color & _red.mask()  ) >> _red.shift();
+      uint64_t colorG = (color & _green.mask()) >> _green.shift();
+      uint64_t colorB = (color & _blue.mask() ) >> _blue.shift();
+
+      colorR = (colorR * colorA) / divisor;
+      colorG = (colorG * colorA) / divisor;
+      colorB = (colorB * colorA) / divisor;
+
+      write(dp, (colorA << _alpha.shift()) | (colorR << _red.shift()) | (colorG << _green.shift()) | (colorB << _blue.shift()));
+      dp += stride();
+    }
+  }
+}
+
 auto image::transform(const image& source) -> void {
   return transform(source._endian, source._depth, source._alpha.mask(), source._red.mask(), source._green.mask(), source._blue.mask());
 }
diff -Nru higan/processor/r6502/instructions.cpp higan/processor/r6502/instructions.cpp
--- higan/processor/r6502/instructions.cpp	2015-09-16 02:20:06.407574584 +0900
+++ higan/processor/r6502/instructions.cpp	2015-09-16 13:08:13.638563376 +0900
@@ -323,7 +323,7 @@
   call(op);
 }
 
-void R6502::opi_store_absolute(uint8& r) {
+void R6502::opi_store_absolute(uint8 r) {
   abs.l = op_readpci();
   abs.h = op_readpci();
 L op_write(abs.w, r);
@@ -343,7 +343,7 @@
 L op_write(abs.w + regs.y, r);
 }
 
-void R6502::opi_store_indirect_zero_page_x(uint8& r) {
+void R6502::opi_store_indirect_zero_page_x(uint8 r) {
   zp = op_readpci();
   op_readzp(zp);
   abs.l = op_readzp(zp++ + regs.x);
@@ -359,7 +359,7 @@
 L op_write(abs.w + regs.y, r);
 }
 
-void R6502::opi_store_zero_page(uint8& r) {
+void R6502::opi_store_zero_page(uint8 r) {
   zp = op_readpci();
 L op_writezp(zp, r);
 }
@@ -370,7 +370,7 @@
 L op_writezp(zp + regs.x, r);
 }
 
-void R6502::opi_store_zero_page_y(uint8& r) {
+void R6502::opi_store_zero_page_y(uint8 r) {
   zp = op_readpci();
   op_readzp(zp);
 L op_writezp(zp + regs.y, r);
@@ -391,11 +391,12 @@
   op_readpci();
   op_writesp(regs.pc >> 8);
   op_writesp(regs.pc >> 0);
+  uint16 vector = 0xfffe;
+  nmi(vector);
   op_writesp(regs.p | 0x30);
-  abs.l = op_read(0xfffe);
+  abs.l = op_read(vector + 0);
   regs.p.i = 1;
-  regs.p.d = 0;
-L abs.h = op_read(0xffff);
+L abs.h = op_read(vector + 1);
   regs.pc = abs.w;
 }
 
@@ -456,9 +457,118 @@
   regs.pc = ++abs.w;
 }
 
+//illegal opcode functions
+//========================
+
+void R6502::opillf_dcp() {
+  opf_dec();
+  opf_cmp();
+}
+
+void R6502::opillf_lax() {
+  opf_lda();
+  regs.x = regs.a;
+}
+
+//illegal opcode implementations
+//==============================
+
+template<void (R6502::*opw)(),void (R6502::*opr)()>
+void R6502::opilli_rmwr_absolute() {
+  abs.l = op_readpci();
+  abs.h = op_readpci();
+  rd = op_read(abs.w);
+  op_write(abs.w, rd);
+  call(opw);
+L op_write(abs.w, rd);
+  call(opr);
+}
+
+template<void (R6502::*opw)(),void (R6502::*opr)()>
+void R6502::opilli_rmwr_absolute_x() {
+  abs.l = op_readpci();
+  abs.h = op_readpci();
+  op_page_always(abs.w, abs.w + regs.x);
+  rd = op_read(abs.w + regs.x);
+  op_write(abs.w + regs.x, rd);
+  call(opw);
+L op_write(abs.w + regs.x, rd);
+  call(opr);
+}
+
+template<void (R6502::*opw)(),void (R6502::*opr)()>
+void R6502::opilli_rmwr_absolute_y() {
+  abs.l = op_readpci();
+  abs.h = op_readpci();
+  op_page_always(abs.w, abs.w + regs.y);
+  rd = op_read(abs.w + regs.y);
+  op_write(abs.w + regs.y, rd);
+  call(opw);
+L op_write(abs.w + regs.y, rd);
+  call(opr);
+}
+
+template<void (R6502::*opw)(),void (R6502::*opr)()>
+void R6502::opilli_rmwr_indirect_zero_page_x() {
+  zp = op_readpci();
+  op_readzp(zp);
+  abs.l = op_readzp(zp++ + regs.x);
+  abs.h = op_readzp(zp++ + regs.x);
+  rd = op_read(abs.w);
+  op_write(abs.w, rd);
+  call(opw);
+L op_write(abs.w, rd);
+  call(opr);
+}
+
+template<void (R6502::*opw)(),void (R6502::*opr)()>
+void R6502::opilli_rmwr_indirect_zero_page_y() {
+  rd = op_readpci();
+  abs.l = op_readzp(rd++);
+  abs.h = op_readzp(rd++);
+  op_page_always(abs.w, abs.w + regs.y);
+  rd = op_read(abs.w + regs.y);
+  op_write(abs.w + regs.y, rd);
+  call(opw);
+L op_write(abs.w + regs.y, rd);
+  call(opr);
+}
+
+template<void (R6502::*opw)(),void (R6502::*opr)()>
+void R6502::opilli_rmwr_zero_page() {
+  zp = op_readpci();
+  rd = op_readzp(zp);
+  op_writezp(zp, rd);
+  call(opw);
+L op_writezp(zp, rd);
+  call(opr);
+}
+
+template<void (R6502::*opw)(),void (R6502::*opr)()>
+void R6502::opilli_rmwr_zero_page_x() {
+  zp = op_readpci();
+  op_readzp(zp);
+  rd = op_readzp(zp + regs.x);
+  op_writezp(zp + regs.x, rd);
+  call(opw);
+L op_writezp(zp + regs.x, rd);
+  call(opr);
+}
+
 //illegal opcodes
 //===============
 
+void R6502::opill_alr_immediate() {
+  opi_read_immediate<&R6502::opf_and>();
+  opf_sra();
+}
+
+void R6502::opill_anc_immediate() {
+L rd = op_readpci();
+  opf_and();
+  regs.p.c = regs.p.n;
+}
+
 void R6502::opill_arr_immediate() {
 L rd = op_readpci();
   regs.a &= rd;
@@ -469,6 +579,66 @@
   regs.p.v = regs.p.c ^ ((regs.a >> 5) & 1);
 }
 
+void R6502::opill_axs_immediate() {
+L rd = op_readpci();
+  signed r = (regs.a & regs.x) - rd;
+  regs.p.n = (r & 0x80);
+  regs.p.z = ((uint8)r == 0);
+  regs.p.c = (r >= 0);
+  regs.x = r;
+}
+
+void R6502::opill_dcp_absolute_y() {
+  abs.l = op_readpci();
+  abs.h = op_readpci();
+  op_page_always(abs.w, abs.w + regs.y);
+  rd = op_read(abs.w + regs.y);
+  op_write(abs.w + regs.y, rd);
+  opf_dec();
+  opf_cmp();
+L op_write(abs.w + regs.y, rd);
+}
+
+void R6502::opill_dcp_indirect_zero_page_x() {
+  zp = op_readpci();
+  op_readzp(zp);
+  abs.l = op_readzp(zp++ + regs.x);
+  abs.h = op_readzp(zp++ + regs.x);
+  rd = op_read(abs.w);
+  op_write(abs.w, rd);
+  opf_dec();
+  opf_cmp();
+L op_write(abs.w, rd);
+}
+
+void R6502::opill_dcp_indirect_zero_page_y() {
+  rd = op_readpci();
+  abs.l = op_readzp(rd++);
+  abs.h = op_readzp(rd++);
+  op_page_always(abs.w, abs.w + regs.y);
+  rd = op_read(abs.w + regs.y);
+  op_write(abs.w + regs.y, rd);
+  opf_dec();
+  opf_cmp();
+L op_write(abs.w + regs.y, rd);
+}
+
+void R6502::opill_las_absolute_y() {
+  abs.l = op_readpci();
+  abs.h = op_readpci();
+  op_page(abs.w, abs.w + regs.y);
+L rd = op_read(abs.w + regs.y);
+  regs.a = regs.x = regs.s = rd & regs.s;
+}
+
+void R6502::opill_lxa_immediate() {
+  // line noise on the data bus interferes with what would be LAX #i.
+L rd = op_readpci();
+  regs.a = regs.x = (regs.a | (rand() & 0xff)) & rd;
+  regs.p.n = (regs.a & 0x80);
+  regs.p.z = (regs.a == 0);
+}
+
 void R6502::opill_nop_absolute() {
   abs.l = op_readpci();
   abs.h = op_readpci();
@@ -483,7 +653,7 @@
 }
 
 void R6502::opill_nop_immediate() {
-L rd = op_readpc();
+L rd = op_readpci();
 }
 
 void R6502::opill_nop_implied() {
@@ -500,3 +670,49 @@
   op_readzp(zp);
 L op_readzp(zp + regs.x);
 }
+
+void R6502::opill_sha_absolute_y() {
+  abs.l = op_readpci();
+  abs.h = op_readpci();
+  op_page_always(abs.w, abs.w + regs.y);
+L op_write(abs.w + regs.y, regs.a & regs.x & (abs.h + 1));
+}
+
+void R6502::opill_sha_indirect_zero_page_y() {
+  rd = op_readpci();
+  abs.l = op_readzp(rd++);
+  abs.h = op_readzp(rd++);
+  op_page_always(abs.w, abs.w + regs.y);
+L op_write(abs.w + regs.y, regs.a & regs.x & (abs.h + 1));
+}
+
+void R6502::opill_shx_absolute_y() {
+  abs.l = op_readpci();
+  abs.h = op_readpci();
+  op_page_always(abs.w, abs.w + regs.y);
+L op_write(abs.w + regs.y, regs.x & (abs.h + 1));
+}
+
+void R6502::opill_shy_absolute_x() {
+  abs.l = op_readpci();
+  abs.h = op_readpci();
+  op_page_always(abs.w, abs.w + regs.x);
+L op_write(abs.w + regs.x, regs.y & (abs.h + 1));
+}
+
+void R6502::opill_stp() {
+  while(true) op_readpc();
+}
+
+void R6502::opill_tas_absolute_y() {
+  abs.l = op_readpci();
+  abs.h = op_readpci();
+  op_page_always(abs.w, abs.w + regs.y);
+  regs.s = regs.a & regs.x;
+L op_write(abs.w + regs.y, regs.a & regs.x & (abs.h + 1));
+}
+
+void R6502::opill_xaa_immediate() {
+  rd = op_readpci();
+  regs.a = (regs.a | (rand() & 0xff)) & regs.x & rd;
+}
diff -Nru higan/processor/r6502/r6502.cpp higan/processor/r6502/r6502.cpp
--- higan/processor/r6502/r6502.cpp	2015-09-16 02:20:06.407574584 +0900
+++ higan/processor/r6502/r6502.cpp	2015-09-16 13:08:13.639563376 +0900
@@ -35,12 +35,11 @@
   op_readpc();
   op_writesp(regs.pc >> 8);
   op_writesp(regs.pc >> 0);
-  op_writesp(regs.p | 0x20);
   uint16 vector = 0xfffe;  //IRQ
   nmi(vector);
+  op_writesp(regs.p | 0x20);
   abs.l = op_read(vector++);
   regs.p.i = 1;
-  regs.p.d = 0;
 L abs.h = op_read(vector++);
   regs.pc = abs.w;
 }
@@ -50,75 +49,108 @@
   switch(opcode) {
   case 0x00: return op_brk();
   case 0x01: return opi_read_indirect_zero_page_x<&R6502::opf_ora>();
+I case 0x02: return opill_stp();
+I case 0x03: return opilli_rmwr_indirect_zero_page_x<&R6502::opf_asl,&R6502::opf_ora>();
 I case 0x04: return opill_nop_zero_page();
   case 0x05: return opi_read_zero_page<&R6502::opf_ora>();
   case 0x06: return opi_rmw_zero_page<&R6502::opf_asl>();
+I case 0x07: return opilli_rmwr_zero_page<&R6502::opf_asl,&R6502::opf_ora>();
   case 0x08: return op_php();
   case 0x09: return opi_read_immediate<&R6502::opf_ora>();
   case 0x0a: return opi_shift<&R6502::opf_sla>();
+I case 0x0b: return opill_anc_immediate();
 I case 0x0c: return opill_nop_absolute();
   case 0x0d: return opi_read_absolute<&R6502::opf_ora>();
   case 0x0e: return opi_rmw_absolute<&R6502::opf_asl>();
+I case 0x0f: return opilli_rmwr_absolute<&R6502::opf_asl,&R6502::opf_ora>();
   case 0x10: return opi_branch(regs.p.n == 0);
   case 0x11: return opi_read_indirect_zero_page_y<&R6502::opf_ora>();
+I case 0x12: return opill_stp();
+I case 0x13: return opilli_rmwr_indirect_zero_page_y<&R6502::opf_asl,&R6502::opf_ora>();
 I case 0x14: return opill_nop_zero_page_x();
   case 0x15: return opi_read_zero_page_x<&R6502::opf_ora>();
   case 0x16: return opi_rmw_zero_page_x<&R6502::opf_asl>();
+I case 0x17: return opilli_rmwr_zero_page_x<&R6502::opf_asl,&R6502::opf_ora>();
   case 0x18: return opi_clear_flag(regs.p.c);
   case 0x19: return opi_read_absolute_y<&R6502::opf_ora>();
 I case 0x1a: return opill_nop_implied();
+I case 0x1b: return opilli_rmwr_absolute_y<&R6502::opf_asl,&R6502::opf_ora>();
 I case 0x1c: return opill_nop_absolute_x();
   case 0x1d: return opi_read_absolute_x<&R6502::opf_ora>();
   case 0x1e: return opi_rmw_absolute_x<&R6502::opf_asl>();
+I case 0x1f: return opilli_rmwr_absolute_x<&R6502::opf_asl,&R6502::opf_ora>();
   case 0x20: return op_jsr_absolute();
   case 0x21: return opi_read_indirect_zero_page_x<&R6502::opf_and>();
+I case 0x22: return opill_stp();
+I case 0x23: return opilli_rmwr_indirect_zero_page_x<&R6502::opf_rol,&R6502::opf_and>();
   case 0x24: return opi_read_zero_page<&R6502::opf_bit>();
   case 0x25: return opi_read_zero_page<&R6502::opf_and>();
   case 0x26: return opi_rmw_zero_page<&R6502::opf_rol>();
+I case 0x27: return opilli_rmwr_zero_page<&R6502::opf_rol,&R6502::opf_and>();
   case 0x28: return op_plp();
   case 0x29: return opi_read_immediate<&R6502::opf_and>();
   case 0x2a: return opi_shift<&R6502::opf_rla>();
+I case 0x2b: return opill_anc_immediate();
   case 0x2c: return opi_read_absolute<&R6502::opf_bit>();
   case 0x2d: return opi_read_absolute<&R6502::opf_and>();
   case 0x2e: return opi_rmw_absolute<&R6502::opf_rol>();
+I case 0x2f: return opilli_rmwr_absolute<&R6502::opf_rol,&R6502::opf_and>();
   case 0x30: return opi_branch(regs.p.n == 1);
   case 0x31: return opi_read_indirect_zero_page_y<&R6502::opf_and>();
+I case 0x32: return opill_stp();
+I case 0x33: return opilli_rmwr_indirect_zero_page_y<&R6502::opf_rol,&R6502::opf_and>();
 I case 0x34: return opill_nop_zero_page_x();
   case 0x35: return opi_read_zero_page_x<&R6502::opf_and>();
   case 0x36: return opi_rmw_zero_page_x<&R6502::opf_rol>();
+I case 0x37: return opilli_rmwr_zero_page_x<&R6502::opf_rol,&R6502::opf_and>();
   case 0x38: return opi_set_flag(regs.p.c);
   case 0x39: return opi_read_absolute_y<&R6502::opf_and>();
 I case 0x3a: return opill_nop_implied();
+I case 0x3b: return opilli_rmwr_absolute_y<&R6502::opf_rol,&R6502::opf_and>();
 I case 0x3c: return opill_nop_absolute_x();
   case 0x3d: return opi_read_absolute_x<&R6502::opf_and>();
   case 0x3e: return opi_rmw_absolute_x<&R6502::opf_rol>();
+I case 0x3f: return opilli_rmwr_absolute_x<&R6502::opf_rol,&R6502::opf_and>();
   case 0x40: return op_rti();
   case 0x41: return opi_read_indirect_zero_page_x<&R6502::opf_eor>();
+I case 0x42: return opill_stp();
+I case 0x43: return opilli_rmwr_indirect_zero_page_x<&R6502::opf_lsr,&R6502::opf_eor>();
 I case 0x44: return opill_nop_zero_page();
   case 0x45: return opi_read_zero_page<&R6502::opf_eor>();
   case 0x46: return opi_rmw_zero_page<&R6502::opf_lsr>();
+I case 0x47: return opilli_rmwr_zero_page<&R6502::opf_lsr,&R6502::opf_eor>();
   case 0x48: return opi_push(regs.a);
   case 0x49: return opi_read_immediate<&R6502::opf_eor>();
   case 0x4a: return opi_shift<&R6502::opf_sra>();
+I case 0x4b: return opill_alr_immediate();
   case 0x4c: return op_jmp_absolute();
   case 0x4d: return opi_read_absolute<&R6502::opf_eor>();
   case 0x4e: return opi_rmw_absolute<&R6502::opf_lsr>();
+I case 0x4f: return opilli_rmwr_absolute<&R6502::opf_lsr,&R6502::opf_eor>();
   case 0x50: return opi_branch(regs.p.v == 0);
   case 0x51: return opi_read_indirect_zero_page_y<&R6502::opf_eor>();
+I case 0x52: return opill_stp();
+I case 0x53: return opilli_rmwr_indirect_zero_page_y<&R6502::opf_lsr,&R6502::opf_eor>();
 I case 0x54: return opill_nop_zero_page_x();
   case 0x55: return opi_read_zero_page_x<&R6502::opf_eor>();
   case 0x56: return opi_rmw_zero_page_x<&R6502::opf_lsr>();
+I case 0x57: return opilli_rmwr_zero_page_x<&R6502::opf_lsr,&R6502::opf_eor>();
   case 0x58: return opi_clear_flag(regs.p.i);
   case 0x59: return opi_read_absolute_y<&R6502::opf_eor>();
 I case 0x5a: return opill_nop_implied();
+I case 0x5b: return opilli_rmwr_absolute_y<&R6502::opf_lsr,&R6502::opf_eor>();
 I case 0x5c: return opill_nop_absolute_x();
   case 0x5d: return opi_read_absolute_x<&R6502::opf_eor>();
   case 0x5e: return opi_rmw_absolute_x<&R6502::opf_lsr>();
+I case 0x5f: return opilli_rmwr_absolute_x<&R6502::opf_lsr,&R6502::opf_eor>();
   case 0x60: return op_rts();
   case 0x61: return opi_read_indirect_zero_page_x<&R6502::opf_adc>();
+I case 0x62: return opill_stp();
+I case 0x63: return opilli_rmwr_indirect_zero_page_x<&R6502::opf_ror,&R6502::opf_adc>();
 I case 0x64: return opill_nop_zero_page();
   case 0x65: return opi_read_zero_page<&R6502::opf_adc>();
   case 0x66: return opi_rmw_zero_page<&R6502::opf_ror>();
+I case 0x67: return opilli_rmwr_zero_page<&R6502::opf_ror,&R6502::opf_adc>();
   case 0x68: return opi_pull(regs.a);
   case 0x69: return opi_read_immediate<&R6502::opf_adc>();
   case 0x6a: return opi_shift<&R6502::opf_rra>();
@@ -126,90 +158,127 @@
   case 0x6c: return op_jmp_indirect_absolute();
   case 0x6d: return opi_read_absolute<&R6502::opf_adc>();
   case 0x6e: return opi_rmw_absolute<&R6502::opf_ror>();
+I case 0x6f: return opilli_rmwr_absolute<&R6502::opf_ror,&R6502::opf_adc>();
   case 0x70: return opi_branch(regs.p.v == 1);
-I case 0x74: return opill_nop_zero_page_x();
   case 0x71: return opi_read_indirect_zero_page_y<&R6502::opf_adc>();
+I case 0x72: return opill_stp();
+I case 0x73: return opilli_rmwr_indirect_zero_page_y<&R6502::opf_ror,&R6502::opf_adc>();
+I case 0x74: return opill_nop_zero_page_x();
   case 0x75: return opi_read_zero_page_x<&R6502::opf_adc>();
   case 0x76: return opi_rmw_zero_page_x<&R6502::opf_ror>();
+I case 0x77: return opilli_rmwr_zero_page_x<&R6502::opf_ror,&R6502::opf_adc>();
   case 0x78: return opi_set_flag(regs.p.i);
   case 0x79: return opi_read_absolute_y<&R6502::opf_adc>();
 I case 0x7a: return opill_nop_implied();
+I case 0x7b: return opilli_rmwr_absolute_y<&R6502::opf_ror,&R6502::opf_adc>();
 I case 0x7c: return opill_nop_absolute_x();
   case 0x7d: return opi_read_absolute_x<&R6502::opf_adc>();
   case 0x7e: return opi_rmw_absolute_x<&R6502::opf_ror>();
-I case 0x80: return opill_nop_absolute();
+I case 0x7f: return opilli_rmwr_absolute_x<&R6502::opf_ror,&R6502::opf_adc>();
+I case 0x80: return opill_nop_immediate(); // regs.y
   case 0x81: return opi_store_indirect_zero_page_x(regs.a);
-I case 0x82: return opill_nop_immediate();
+I case 0x82: return opill_nop_immediate(); // regs.x
+I case 0x83: return opi_store_indirect_zero_page_x(regs.a & regs.x);
   case 0x84: return opi_store_zero_page(regs.y);
   case 0x85: return opi_store_zero_page(regs.a);
   case 0x86: return opi_store_zero_page(regs.x);
+I case 0x87: return opi_store_zero_page(regs.a & regs.x);
   case 0x88: return opi_decrement(regs.y);
-I case 0x89: return opill_nop_immediate();
+I case 0x89: return opill_nop_immediate(); // regs.a
   case 0x8a: return opi_transfer(regs.x, regs.a, 1);
+I case 0x8b: return opill_xaa_immediate();
   case 0x8c: return opi_store_absolute(regs.y);
   case 0x8d: return opi_store_absolute(regs.a);
   case 0x8e: return opi_store_absolute(regs.x);
+I case 0x8f: return opi_store_absolute(regs.a & regs.x);
   case 0x90: return opi_branch(regs.p.c == 0);
   case 0x91: return opi_store_indirect_zero_page_y(regs.a);
+I case 0x92: return opill_stp();
+I case 0x93: return opill_sha_indirect_zero_page_y();
   case 0x94: return opi_store_zero_page_x(regs.y);
   case 0x95: return opi_store_zero_page_x(regs.a);
   case 0x96: return opi_store_zero_page_y(regs.x);
+I case 0x97: return opi_store_zero_page_y(regs.a & regs.x);
   case 0x98: return opi_transfer(regs.y, regs.a, 1);
   case 0x99: return opi_store_absolute_y(regs.a);
   case 0x9a: return opi_transfer(regs.x, regs.s, 0);
+I case 0x9b: return opill_tas_absolute_y();
+I case 0x9c: return opill_shy_absolute_x();
   case 0x9d: return opi_store_absolute_x(regs.a);
+I case 0x9e: return opill_shx_absolute_y();
+I case 0x9f: return opill_sha_absolute_y();
   case 0xa0: return opi_read_immediate<&R6502::opf_ldy>();
   case 0xa1: return opi_read_indirect_zero_page_x<&R6502::opf_lda>();
   case 0xa2: return opi_read_immediate<&R6502::opf_ldx>();
+I case 0xa3: return opi_read_indirect_zero_page_x<&R6502::opillf_lax>();
   case 0xa4: return opi_read_zero_page<&R6502::opf_ldy>();
   case 0xa5: return opi_read_zero_page<&R6502::opf_lda>();
   case 0xa6: return opi_read_zero_page<&R6502::opf_ldx>();
+I case 0xa7: return opi_read_zero_page<&R6502::opillf_lax>();
   case 0xa8: return opi_transfer(regs.a, regs.y, 1);
   case 0xa9: return opi_read_immediate<&R6502::opf_lda>();
   case 0xaa: return opi_transfer(regs.a, regs.x, 1);
+I case 0xab: return opill_lxa_immediate();
   case 0xac: return opi_read_absolute<&R6502::opf_ldy>();
   case 0xad: return opi_read_absolute<&R6502::opf_lda>();
   case 0xae: return opi_read_absolute<&R6502::opf_ldx>();
+I case 0xaf: return opi_read_absolute<&R6502::opillf_lax>();
   case 0xb0: return opi_branch(regs.p.c == 1);
   case 0xb1: return opi_read_indirect_zero_page_y<&R6502::opf_lda>();
+I case 0xb2: return opill_stp();
+I case 0xb3: return opi_read_indirect_zero_page_y<&R6502::opillf_lax>();
   case 0xb4: return opi_read_zero_page_x<&R6502::opf_ldy>();
   case 0xb5: return opi_read_zero_page_x<&R6502::opf_lda>();
   case 0xb6: return opi_read_zero_page_y<&R6502::opf_ldx>();
+I case 0xb7: return opi_read_zero_page_y<&R6502::opillf_lax>();
   case 0xb8: return opi_clear_flag(regs.p.v);
   case 0xb9: return opi_read_absolute_y<&R6502::opf_lda>();
   case 0xba: return opi_transfer(regs.s, regs.x, 1);
+I case 0xbb: return opill_las_absolute_y();
   case 0xbc: return opi_read_absolute_x<&R6502::opf_ldy>();
   case 0xbd: return opi_read_absolute_x<&R6502::opf_lda>();
   case 0xbe: return opi_read_absolute_y<&R6502::opf_ldx>();
+I case 0xbf: return opi_read_absolute_y<&R6502::opillf_lax>();
   case 0xc0: return opi_read_immediate<&R6502::opf_cpy>();
   case 0xc1: return opi_read_indirect_zero_page_x<&R6502::opf_cmp>();
 I case 0xc2: return opill_nop_immediate();
+I case 0xc3: return opill_dcp_indirect_zero_page_x();
   case 0xc4: return opi_read_zero_page<&R6502::opf_cpy>();
   case 0xc5: return opi_read_zero_page<&R6502::opf_cmp>();
   case 0xc6: return opi_rmw_zero_page<&R6502::opf_dec>();
+I case 0xc7: return opi_rmw_zero_page<&R6502::opillf_dcp>();
   case 0xc8: return opi_increment(regs.y);
   case 0xc9: return opi_read_immediate<&R6502::opf_cmp>();
   case 0xca: return opi_decrement(regs.x);
+I case 0xcb: return opill_axs_immediate();
   case 0xcc: return opi_read_absolute<&R6502::opf_cpy>();
   case 0xcd: return opi_read_absolute<&R6502::opf_cmp>();
   case 0xce: return opi_rmw_absolute<&R6502::opf_dec>();
+I case 0xcf: return opi_rmw_absolute<&R6502::opillf_dcp>();
   case 0xd0: return opi_branch(regs.p.z == 0);
   case 0xd1: return opi_read_indirect_zero_page_y<&R6502::opf_cmp>();
+I case 0xd2: return opill_stp();
+I case 0xd3: return opill_dcp_indirect_zero_page_y();
 I case 0xd4: return opill_nop_zero_page_x();
   case 0xd5: return opi_read_zero_page_x<&R6502::opf_cmp>();
   case 0xd6: return opi_rmw_zero_page_x<&R6502::opf_dec>();
+I case 0xd7: return opi_rmw_zero_page_x<&R6502::opillf_dcp>();
   case 0xd8: return opi_clear_flag(regs.p.d);
   case 0xd9: return opi_read_absolute_y<&R6502::opf_cmp>();
 I case 0xda: return opill_nop_implied();
+I case 0xdb: return opill_dcp_absolute_y();
 I case 0xdc: return opill_nop_absolute_x();
   case 0xdd: return opi_read_absolute_x<&R6502::opf_cmp>();
   case 0xde: return opi_rmw_absolute_x<&R6502::opf_dec>();
+I case 0xdf: return opi_rmw_absolute_x<&R6502::opillf_dcp>();
   case 0xe0: return opi_read_immediate<&R6502::opf_cpx>();
   case 0xe1: return opi_read_indirect_zero_page_x<&R6502::opf_sbc>();
 I case 0xe2: return opill_nop_immediate();
+I case 0xe3: return opilli_rmwr_indirect_zero_page_x<&R6502::opf_inc,&R6502::opf_sbc>();
   case 0xe4: return opi_read_zero_page<&R6502::opf_cpx>();
   case 0xe5: return opi_read_zero_page<&R6502::opf_sbc>();
   case 0xe6: return opi_rmw_zero_page<&R6502::opf_inc>();
+I case 0xe7: return opilli_rmwr_zero_page<&R6502::opf_inc,&R6502::opf_sbc>();
   case 0xe8: return opi_increment(regs.x);
   case 0xe9: return opi_read_immediate<&R6502::opf_sbc>();
   case 0xea: return op_nop();
@@ -217,17 +286,23 @@
   case 0xec: return opi_read_absolute<&R6502::opf_cpx>();
   case 0xed: return opi_read_absolute<&R6502::opf_sbc>();
   case 0xee: return opi_rmw_absolute<&R6502::opf_inc>();
+I case 0xef: return opilli_rmwr_absolute<&R6502::opf_inc,&R6502::opf_sbc>();
   case 0xf0: return opi_branch(regs.p.z == 1);
   case 0xf1: return opi_read_indirect_zero_page_y<&R6502::opf_sbc>();
+I case 0xf2: return opill_stp();
+I case 0xf3: return opilli_rmwr_indirect_zero_page_y<&R6502::opf_inc,&R6502::opf_sbc>();
 I case 0xf4: return opill_nop_zero_page_x();
   case 0xf5: return opi_read_zero_page_x<&R6502::opf_sbc>();
   case 0xf6: return opi_rmw_zero_page_x<&R6502::opf_inc>();
+I case 0xf7: return opilli_rmwr_zero_page_x<&R6502::opf_inc,&R6502::opf_sbc>();
   case 0xf8: return opi_set_flag(regs.p.d);
   case 0xf9: return opi_read_absolute_y<&R6502::opf_sbc>();
 I case 0xfa: return opill_nop_implied();
+I case 0xfb: return opilli_rmwr_absolute_y<&R6502::opf_inc,&R6502::opf_sbc>();
 I case 0xfc: return opill_nop_absolute_x();
   case 0xfd: return opi_read_absolute_x<&R6502::opf_sbc>();
   case 0xfe: return opi_rmw_absolute_x<&R6502::opf_inc>();
+I case 0xff: return opilli_rmwr_absolute_x<&R6502::opf_inc,&R6502::opf_sbc>();
   }
 
   //unimplemented opcode
diff -Nru higan/processor/r6502/r6502.hpp higan/processor/r6502/r6502.hpp
--- higan/processor/r6502/r6502.hpp	2015-09-16 02:20:06.407574584 +0900
+++ higan/processor/r6502/r6502.hpp	2015-09-16 13:08:13.639563376 +0900
@@ -81,14 +81,14 @@
   template<void (R6502::*op)()> void opi_rmw_zero_page_x();
   void opi_set_flag(bool& flag);
   template<void (R6502::*op)()> void opi_shift();
-  void opi_store_absolute(uint8& r);
+  void opi_store_absolute(uint8 r);
   void opi_store_absolute_x(uint8& r);
   void opi_store_absolute_y(uint8& r);
-  void opi_store_indirect_zero_page_x(uint8& r);
+  void opi_store_indirect_zero_page_x(uint8 r);
   void opi_store_indirect_zero_page_y(uint8& r);
-  void opi_store_zero_page(uint8& r);
+  void opi_store_zero_page(uint8 r);
   void opi_store_zero_page_x(uint8& r);
-  void opi_store_zero_page_y(uint8& r);
+  void opi_store_zero_page_y(uint8 r);
   void opi_transfer(uint8& s, uint8& d, bool flag);
 
   void op_brk();
@@ -101,13 +101,46 @@
   void op_rti();
   void op_rts();
 
+  void opillf_dcp();
+  void opillf_lax();
+
+  template<void (R6502::*opw)(),void (R6502::*opr)()>
+  void opilli_rmwr_absolute();
+  template<void (R6502::*opw)(),void (R6502::*opr)()>
+  void opilli_rmwr_absolute_x();
+  template<void (R6502::*opw)(),void (R6502::*opr)()>
+  void opilli_rmwr_absolute_y();
+  template<void (R6502::*opw)(),void (R6502::*opr)()>
+  void opilli_rmwr_indirect_zero_page_x();
+  template<void (R6502::*opw)(),void (R6502::*opr)()>
+  void opilli_rmwr_indirect_zero_page_y();
+  template<void (R6502::*opw)(),void (R6502::*opr)()>
+  void opilli_rmwr_zero_page();
+  template<void (R6502::*opw)(),void (R6502::*opr)()>
+  void opilli_rmwr_zero_page_x();
+
+  void opill_alr_immediate();
+  void opill_anc_immediate();
   void opill_arr_immediate();
+  void opill_axs_immediate();
+  void opill_dcp_absolute_y();
+  void opill_dcp_indirect_zero_page_x();
+  void opill_dcp_indirect_zero_page_y();
+  void opill_las_absolute_y();
+  void opill_lxa_immediate();
   void opill_nop_absolute();
   void opill_nop_absolute_x();
   void opill_nop_immediate();
   void opill_nop_implied();
   void opill_nop_zero_page();
   void opill_nop_zero_page_x();
+  void opill_sha_absolute_y();
+  void opill_sha_indirect_zero_page_y();
+  void opill_shx_absolute_y();
+  void opill_shy_absolute_x();
+  void opill_stp();
+  void opill_tas_absolute_y();
+  void opill_xaa_immediate();
 
   //disassembler.cpp
   string disassemble();
diff -Nru higan/profile/PlayChoice-10.sys/manifest.bml higan/profile/PlayChoice-10.sys/manifest.bml
--- higan/profile/PlayChoice-10.sys/manifest.bml	1970-01-01 09:00:00.000000000 +0900
+++ higan/profile/PlayChoice-10.sys/manifest.bml	2015-09-16 13:08:13.512563363 +0900
@@ -0,0 +1,13 @@
+system name:PlayChoice-10
+  pc10
+    screen mode=2
+    rom name=bios-dual.rom size=16384
+    rom name=character.rom size=24576
+    rom name=palette.rom size=768
+    setting name="Attract Mode Sounds"
+      option value="0x0040" name="Plays"
+      option value="0x0000" name="Muted"
+    setting name="Play Time / Coin"
+      option value="0x8000" name="Free Play"
+      option value="0x3f00" name="5:00"
+      option value="0x2200" name="2:30"
diff -Nru "higan/profile/VS. System.sys/manifest.bml" "higan/profile/VS. System.sys/manifest.bml"
--- "higan/profile/VS. System.sys/manifest.bml"	1970-01-01 09:00:00.000000000 +0900
+++ "higan/profile/VS. System.sys/manifest.bml"	2015-09-16 13:08:13.512563363 +0900
@@ -0,0 +1 @@
+system name:VS. System
diff -Nru higan/ruby/audio/directsound.cpp higan/ruby/audio/directsound.cpp
--- higan/ruby/audio/directsound.cpp	2015-09-16 02:20:06.409574584 +0900
+++ higan/ruby/audio/directsound.cpp	2015-09-16 13:08:13.884563402 +0900
@@ -63,7 +63,8 @@
     }
 
     if(name == Audio::Latency && value.is<unsigned>()) {
-      settings.latency = value.get<unsigned>();
+      //latency settings below 40ms causes DirectSound to hang
+      settings.latency = max(40u, value.get<unsigned>());
       if(ds) init();
       return true;
     }
diff -Nru higan/sfc/alt/ppu-balanced/ppu.cpp higan/sfc/alt/ppu-balanced/ppu.cpp
--- higan/sfc/alt/ppu-balanced/ppu.cpp	2015-09-16 02:20:06.412574584 +0900
+++ higan/sfc/alt/ppu-balanced/ppu.cpp	2015-09-16 13:08:13.245563336 +0900
@@ -368,6 +368,36 @@
   regs.bg_y[3] = 0;
 }
 
+void PPU::exportRegisters(string &markup) {
+  markup.append("ppu\n");
+  // 2105
+  markup.append("  bgmode:       ", regs.bg_mode,      "\n");
+  markup.append("  bg3-priority: ", regs.bg3_priority, "\n");
+  // 2133
+  markup.append("  pseudo-hires: ", regs.pseudo_hires, "\n");
+  markup.append("  overscan:     ", regs.overscan,     "\n");
+  // individual backgrounds
+  unsigned bg;
+  for(unsigned bg_id = 1; bg_id <= 4; bg_id++) {
+    switch(bg_id) {
+      case 1: bg = BG1; break;
+      case 2: bg = BG2; break;
+      case 3: bg = BG3; break;
+      case 4: bg = BG4; break;
+    }
+    markup.append("  bg\n");
+    markup.append("    tile-size:     ",   regs.bg_tilesize[bg],        "\n");
+    markup.append("    mosaic:        ",   regs.mosaic_enabled[bg],     "\n");
+    markup.append("    screen-addr:   0x", hex(regs.bg_scaddr[bg], 4L), "\n");
+    markup.append("    screen-size:   ",   regs.bg_scsize[bg],          "\n");
+    markup.append("    tiledata-addr: 0x", hex(regs.bg_tdaddr[bg], 4L), "\n");
+    markup.append("    hoffset:       0x", hex(regs.bg_hofs[bg], 4L),   "\n");
+    markup.append("    voffset:       0x", hex(regs.bg_vofs[bg], 4L),   "\n");
+    markup.append("    main-enable:   ",   regs.bg_enabled[bg],         "\n");
+    markup.append("    sub-enable:    ",   regs.bgsub_enabled[bg],      "\n");
+  }
+}
+
 void PPU::layer_enable(unsigned layer, unsigned priority, bool enable) {
   switch(layer * 4 + priority) {
   case  0: layer_enabled[BG1][0] = enable; break;
diff -Nru higan/sfc/alt/ppu-balanced/ppu.hpp higan/sfc/alt/ppu-balanced/ppu.hpp
--- higan/sfc/alt/ppu-balanced/ppu.hpp	2015-09-16 02:20:06.412574584 +0900
+++ higan/sfc/alt/ppu-balanced/ppu.hpp	2015-09-16 13:08:13.245563336 +0900
@@ -62,6 +62,9 @@
   void power();
   void reset();
 
+  //debugger functions
+  void exportRegisters(string &markup);
+
   bool layer_enabled[5][4];
   void layer_enable(unsigned layer, unsigned priority, bool enable);
   unsigned frameskip;
diff -Nru higan/sfc/alt/ppu-performance/ppu.cpp higan/sfc/alt/ppu-performance/ppu.cpp
--- higan/sfc/alt/ppu-performance/ppu.cpp	2015-09-16 02:20:06.413574584 +0900
+++ higan/sfc/alt/ppu-performance/ppu.cpp	2015-09-16 13:08:13.233563335 +0900
@@ -105,6 +105,9 @@
   display.overscan = false;
 }
 
+void PPU::exportRegisters(string &markup) {
+}
+
 void PPU::layer_enable(unsigned layer, unsigned priority, bool enable) {
   switch(layer * 4 + priority) {
   case  0: bg1.priority0_enable = enable; break;
diff -Nru higan/sfc/alt/ppu-performance/ppu.hpp higan/sfc/alt/ppu-performance/ppu.hpp
--- higan/sfc/alt/ppu-performance/ppu.hpp	2015-09-16 02:20:06.413574584 +0900
+++ higan/sfc/alt/ppu-performance/ppu.hpp	2015-09-16 13:08:13.233563335 +0900
@@ -19,6 +19,9 @@
   void scanline();
   void frame();
 
+  //debugger functions
+  void exportRegisters(string &markup);
+
   void layer_enable(unsigned layer, unsigned priority, bool enable);
   void set_frameskip(unsigned frameskip);
 
diff -Nru higan/sfc/interface/interface.cpp higan/sfc/interface/interface.cpp
--- higan/sfc/interface/interface.cpp	2015-09-16 02:20:06.420574585 +0900
+++ higan/sfc/interface/interface.cpp	2015-09-16 13:08:13.280563340 +0900
@@ -463,4 +463,28 @@
   video.generate_palette(mode);
 }
 
+auto Interface::exportMemory() -> void {
+  string pathname = {path(group(ID::ROM)), "debug/"};
+  directory::create(pathname);
+
+  // Registers
+  string markup = "";
+  ppu.exportRegisters(markup);
+  file::write({pathname, "registers.bml"}, markup);
+
+  file::write({pathname, "work.ram"}, cpu.wram, 128 * 1024);
+  file::write({pathname, "video.ram"}, ppu.vram, 64 * 1024);
+  file::write({pathname, "sprite.ram"}, ppu.oam, 544);
+  file::write({pathname, "palette.ram"}, ppu.cgram, 512);
+  file::write({pathname, "apu.ram"}, smp.apuram, 64 * 1024);
+  if(cartridge.hasSA1())
+    file::write({pathname, "sa1.internal.ram"}, sa1.iram.data(), sa1.iram.size());
+  if(cartridge.hasARMDSP())
+    file::write({pathname, "st018.program.ram"}, armdsp.programRAM, sizeof(armdsp.programRAM));
+  if(cartridge.hasHitachiDSP())
+    file::write({pathname, "cx4.data.ram"}, hitachidsp.ram.data(), hitachidsp.ram.size());
+  //if(cartridge.hasNECDSP())
+  //  file::write({pathname, "dsp.data.ram"}, necdsp.dataRAM, sizeof(necdsp.dataRAM));
+}
+
 }
diff -Nru higan/sfc/interface/interface.hpp higan/sfc/interface/interface.hpp
--- higan/sfc/interface/interface.hpp	2015-09-16 02:20:06.420574585 +0900
+++ higan/sfc/interface/interface.hpp	2015-09-16 13:08:13.280563340 +0900
@@ -120,6 +120,9 @@
 
   auto paletteUpdate(PaletteMode mode) -> void;
 
+  //debugger functions
+  auto exportMemory() -> void;
+
   vector<Device> device;
 };
 
diff -Nru higan/sfc/ppu/ppu.cpp higan/sfc/ppu/ppu.cpp
--- higan/sfc/ppu/ppu.cpp	2015-09-16 02:20:06.421574585 +0900
+++ higan/sfc/ppu/ppu.cpp	2015-09-16 13:08:13.272563339 +0900
@@ -109,6 +109,36 @@
   frame();
 }
 
+void PPU::exportRegisters(string &markup) {
+  markup.append("ppu\n");
+  // 2105
+  markup.append("  bgmode:       ", regs.bgmode,       "\n");
+  markup.append("  bg3-priority: ", regs.bg3_priority, "\n");
+  // 2133
+  markup.append("  pseudo-hires: ", regs.pseudo_hires, "\n");
+  markup.append("  overscan:     ", regs.overscan,     "\n");
+  // individual backgrounds
+  auto bg = &bg1;
+  for(unsigned bg_id = 1; bg_id <= 4; bg_id++) {
+    switch(bg_id) {
+      case 1: bg = &bg1; break;
+      case 2: bg = &bg2; break;
+      case 3: bg = &bg3; break;
+      case 4: bg = &bg4; break;
+    }
+    markup.append("  bg\n");
+    markup.append("    tile-size:     ",   bg->regs.tile_size,              "\n");
+    markup.append("    mosaic:        ",   bg->regs.mosaic,                 "\n");
+    markup.append("    screen-addr:   0x", hex(bg->regs.screen_addr, 4L),   "\n");
+    markup.append("    screen-size:   ",   bg->regs.screen_size,            "\n");
+    markup.append("    tiledata-addr: 0x", hex(bg->regs.tiledata_addr, 4L), "\n");
+    markup.append("    hoffset:       0x", hex(bg->regs.hoffset, 3L),       "\n");
+    markup.append("    voffset:       0x", hex(bg->regs.voffset, 3L),       "\n");
+    markup.append("    main-enable:   ",   bg->regs.main_enable,            "\n");
+    markup.append("    sub-enable:    ",   bg->regs.sub_enable,             "\n");
+  }
+}
+
 void PPU::scanline() {
   if(vcounter() == 0) {
     frame();
diff -Nru higan/sfc/ppu/ppu.hpp higan/sfc/ppu/ppu.hpp
--- higan/sfc/ppu/ppu.hpp	2015-09-16 02:20:06.421574585 +0900
+++ higan/sfc/ppu/ppu.hpp	2015-09-16 13:08:13.272563339 +0900
@@ -17,6 +17,9 @@
   void power();
   void reset();
 
+  //debugger functions
+  void exportRegisters(string &markup);
+
   void serialize(serializer&);
   PPU();
   ~PPU();
diff -Nru higan/shaders/Curvature.shader/manifest.bml higan/shaders/Curvature.shader/manifest.bml
--- higan/shaders/Curvature.shader/manifest.bml	2015-09-16 02:20:06.422574585 +0900
+++ higan/shaders/Curvature.shader/manifest.bml	2015-09-16 13:08:13.619563374 +0900
@@ -1,4 +1,6 @@
-program
+input
   filter: linear
   wrap: border
+
+program
   fragment: curvature.fs
diff -Nru "higan/shaders/Edge Detection.shader/manifest.bml" "higan/shaders/Edge Detection.shader/manifest.bml"
--- "higan/shaders/Edge Detection.shader/manifest.bml"	2015-09-16 02:20:06.422574585 +0900
+++ "higan/shaders/Edge Detection.shader/manifest.bml"	2015-09-16 13:08:13.619563374 +0900
@@ -1,4 +1,6 @@
-program
+input
   filter: linear
   wrap: edge
+
+program
   fragment: edge-detection.fs
diff -Nru higan/shaders/Makefile higan/shaders/Makefile
--- higan/shaders/Makefile	2015-09-16 02:20:06.422574585 +0900
+++ higan/shaders/Makefile	1970-01-01 09:00:00.000000000 +0900
@@ -1,5 +0,0 @@
-install:
-	if [ -d /usr/share/higan/Video\ Shaders ]; then sudo rm -r /usr/share/higan/Video\ Shaders; fi
-	sudo mkdir -p /usr/share/higan/Video\ Shaders
-	sudo cp -r *.shader /usr/share/higan/Video\ Shaders
-	sudo chmod -R 777 /usr/share/higan/Video\ Shaders
diff -Nru higan/shaders/GNUmakefile higan/shaders/GNUmakefile
--- higan/shaders/GNUmakefile	1970-01-01 09:00:00.000000000 +0900
+++ higan/shaders/GNUmakefile	2015-09-16 13:08:13.625563375 +0900
@@ -0,0 +1,5 @@
+install:
+	if [ -d /usr/share/higan/Video\ Shaders ]; then sudo rm -r /usr/share/higan/Video\ Shaders; fi
+	sudo mkdir -p /usr/share/higan/Video\ Shaders
+	sudo cp -r *.shader /usr/share/higan/Video\ Shaders
+	sudo chmod -R 777 /usr/share/higan/Video\ Shaders
diff -Nru higan/shaders/Scanline.shader/manifest.bml higan/shaders/Scanline.shader/manifest.bml
--- higan/shaders/Scanline.shader/manifest.bml	2015-09-16 02:20:06.422574585 +0900
+++ higan/shaders/Scanline.shader/manifest.bml	2015-09-16 13:08:13.619563374 +0900
@@ -1,4 +1,6 @@
-program
+input
   filter: linear
   wrap: border
+
+program
   fragment: scanline.fs
diff -Nru higan/target-tomoko/presentation/presentation.cpp higan/target-tomoko/presentation/presentation.cpp
--- higan/target-tomoko/presentation/presentation.cpp	2015-09-16 02:20:06.422574585 +0900
+++ higan/target-tomoko/presentation/presentation.cpp	2015-09-16 14:06:40.927923131 +0900
@@ -97,12 +97,12 @@
   cheatEditor.setText("Cheat Editor").onActivate([&] { toolsManager->show(0); });
   stateManager.setText("State Manager").onActivate([&] { toolsManager->show(1); });
 
-  statusBar.setFont(Font::sans(8, "Bold"));
+  statusBar.setFont(Font("sans", 8).setBold(true));
   statusBar.setVisible(config->userInterface.showStatusBar);
 
   onClose([&] { program->quit(); });
 
-  setTitle({"higan v", Emulator::Version});
+  setTitle({"tomoko v", Emulator::Version});
   setResizable(false);
   setBackgroundColor({0, 0, 0});
   resizeViewport();
diff -Nru higan/target-tomoko/program/interface.cpp higan/target-tomoko/program/interface.cpp
--- higan/target-tomoko/program/interface.cpp	2015-09-16 02:20:06.423574585 +0900
+++ higan/target-tomoko/program/interface.cpp	2015-09-16 14:06:40.925923130 +0900
@@ -35,7 +35,7 @@
       return emulator->load(id, stream);
     }
   }
-  if(required) MessageDialog().setTitle("higan").setText({
+  if(required) MessageDialog().setTitle("tomoko").setText({
     "Missing required file: ", location.filename(), "\n\n",
     "From location:\n", location.pathname()
   }).error();
diff -Nru higan/target-tomoko/program/media.cpp higan/target-tomoko/program/media.cpp
--- higan/target-tomoko/program/media.cpp	2015-09-16 02:20:06.423574585 +0900
+++ higan/target-tomoko/program/media.cpp	2015-09-16 14:06:40.925923130 +0900
@@ -45,7 +45,7 @@
   mediaPaths.reset();
   folderPaths.reset();
 
-  presentation->setTitle({"higan v", Emulator::Version});
+  presentation->setTitle({"tomoko v", Emulator::Version});
   presentation->systemMenu.setVisible(false);
   presentation->toolsMenu.setVisible(false);
   toolsManager->setVisible(false);
diff -Nru higan/target-tomoko/settings/advanced.cpp higan/target-tomoko/settings/advanced.cpp
--- higan/target-tomoko/settings/advanced.cpp	2015-09-16 02:20:06.423574585 +0900
+++ higan/target-tomoko/settings/advanced.cpp	2015-09-16 14:06:40.930923131 +0900
@@ -1,10 +1,10 @@
 AdvancedSettings::AdvancedSettings(TabFrame* parent) : TabFrameItem(parent) {
-  setIcon(Icon::Action::Settings);
+  setImage(Icon::Action::Settings);
   setText("Advanced");
 
   layout.setMargin(5);
 
-  driverLabel.setText("Driver Selection").setFont(Font::sans(8, "Bold"));
+  driverLabel.setText("Driver Selection").setFont(Font("sans", 8).setBold(true));
   videoLabel.setText("Video:");
   videoDriver.onChange([&] { config->video.driver = videoDriver.selected()->text(); });
   for(auto& driver : Video::availableDrivers()) {
@@ -30,7 +30,7 @@
     if(config->input.driver == driver) item.setSelected();
   }
 
-  libraryLabel.setText("Game Library").setFont(Font::sans(8, "Bold"));
+  libraryLabel.setText("Game Library").setFont(Font("sans", 8).setBold(true));
   libraryPrefix.setText("Location:");
   libraryLocation.setEditable(false).setText(config->library.location);
   libraryChange.setText("Change ...").onActivate([&] {
diff -Nru higan/target-tomoko/settings/audio.cpp higan/target-tomoko/settings/audio.cpp
--- higan/target-tomoko/settings/audio.cpp	2015-09-16 02:20:06.423574585 +0900
+++ higan/target-tomoko/settings/audio.cpp	2015-09-16 14:06:40.929923131 +0900
@@ -1,5 +1,5 @@
 AudioSettings::AudioSettings(TabFrame* parent) : TabFrameItem(parent) {
-  setIcon(Icon::Device::Speaker);
+  setImage(Icon::Device::Speaker);
   setText("Audio");
 
   layout.setMargin(5);
diff -Nru higan/target-tomoko/settings/hotkeys.cpp higan/target-tomoko/settings/hotkeys.cpp
--- higan/target-tomoko/settings/hotkeys.cpp	2015-09-16 02:20:06.423574585 +0900
+++ higan/target-tomoko/settings/hotkeys.cpp	2015-09-16 14:06:40.928923131 +0900
@@ -1,5 +1,5 @@
 HotkeySettings::HotkeySettings(TabFrame* parent) : TabFrameItem(parent) {
-  setIcon(Icon::Device::Keyboard);
+  setImage(Icon::Device::Keyboard);
   setText("Hotkeys");
 
   layout.setMargin(5);
diff -Nru higan/target-tomoko/settings/input.cpp higan/target-tomoko/settings/input.cpp
--- higan/target-tomoko/settings/input.cpp	2015-09-16 02:20:06.423574585 +0900
+++ higan/target-tomoko/settings/input.cpp	2015-09-16 14:06:40.929923131 +0900
@@ -1,5 +1,5 @@
 InputSettings::InputSettings(TabFrame* parent) : TabFrameItem(parent) {
-  setIcon(Icon::Device::Joypad);
+  setImage(Icon::Device::Joypad);
   setText("Input");
 
   layout.setMargin(5);
diff -Nru higan/target-tomoko/settings/settings.cpp higan/target-tomoko/settings/settings.cpp
--- higan/target-tomoko/settings/settings.cpp	2015-09-16 02:20:06.423574585 +0900
+++ higan/target-tomoko/settings/settings.cpp	2015-09-16 14:06:40.928923131 +0900
@@ -11,7 +11,7 @@
   settingsManager = this;
 
   layout.setMargin(5);
-  statusBar.setFont(Font::sans(8, "Bold"));
+  statusBar.setFont(Font("sans", 8).setBold(true));
 
   setTitle("Configuration Settings");
   setSize({600, 400});
diff -Nru higan/target-tomoko/settings/timing.cpp higan/target-tomoko/settings/timing.cpp
--- higan/target-tomoko/settings/timing.cpp	2015-09-16 02:20:06.423574585 +0900
+++ higan/target-tomoko/settings/timing.cpp	2015-09-16 14:06:40.929923131 +0900
@@ -1,5 +1,5 @@
 TimingSettings::TimingSettings(TabFrame* parent) : TabFrameItem(parent) {
-  setIcon(Icon::Device::Clock);
+  setImage(Icon::Device::Clock);
   setText("Timing");
 
   layout.setMargin(5);
diff -Nru higan/target-tomoko/settings/video.cpp higan/target-tomoko/settings/video.cpp
--- higan/target-tomoko/settings/video.cpp	2015-09-16 02:20:06.423574585 +0900
+++ higan/target-tomoko/settings/video.cpp	2015-09-16 14:06:40.929923131 +0900
@@ -1,10 +1,10 @@
 VideoSettings::VideoSettings(TabFrame* parent) : TabFrameItem(parent) {
-  setIcon(Icon::Device::Display);
+  setImage(Icon::Device::Display);
   setText("Video");
 
   layout.setMargin(5);
 
-  colorAdjustmentLabel.setFont(Font::sans(8, "Bold")).setText("Color Adjustment");
+  colorAdjustmentLabel.setFont(Font("sans", 8).setBold(true)).setText("Color Adjustment");
   saturationLabel.setText("Saturation:");
   saturationSlider.setLength(201).setPosition(config->video.saturation).onChange([&] { update(); });
   gammaLabel.setText("Gamma:");
@@ -12,7 +12,7 @@
   luminanceLabel.setText("Luminance:");
   luminanceSlider.setLength(101).setPosition(config->video.luminance).onChange([&] { update(); });
 
-  overscanMaskLabel.setFont(Font::sans(8, "Bold")).setText("Overscan Mask");
+  overscanMaskLabel.setFont(Font("sans", 8).setBold(true)).setText("Overscan Mask");
   horizontalMaskLabel.setText("Horizontal:");
   horizontalMaskSlider.setLength(17).setPosition(config->video.overscan.horizontal).onChange([&] { update(); });
   verticalMaskLabel.setText("Vertical:");
diff -Nru higan/target-tomoko/tools/cheat-editor.cpp higan/target-tomoko/tools/cheat-editor.cpp
--- higan/target-tomoko/tools/cheat-editor.cpp	2015-09-16 02:20:06.423574585 +0900
+++ higan/target-tomoko/tools/cheat-editor.cpp	2015-09-16 14:06:40.926923131 +0900
@@ -1,5 +1,5 @@
 CheatEditor::CheatEditor(TabFrame* parent) : TabFrameItem(parent) {
-  setIcon(Icon::Edit::Replace);
+  setImage(Icon::Edit::Replace);
   setText("Cheat Editor");
 
   layout.setMargin(5);
diff -Nru higan/target-tomoko/tools/state-manager.cpp higan/target-tomoko/tools/state-manager.cpp
--- higan/target-tomoko/tools/state-manager.cpp	2015-09-16 02:20:06.423574585 +0900
+++ higan/target-tomoko/tools/state-manager.cpp	2015-09-16 14:06:40.926923131 +0900
@@ -1,5 +1,5 @@
 StateManager::StateManager(TabFrame* parent) : TabFrameItem(parent) {
-  setIcon(Icon::Application::FileManager);
+  setImage(Icon::Application::FileManager);
   setText("State Manager");
 
   layout.setMargin(5);
